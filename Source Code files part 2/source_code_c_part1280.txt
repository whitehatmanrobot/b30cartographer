ol Helper for debugging

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

--*/


#define _SYMHELP_SOURCE_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <debug.h>
#include <stdio.h>
#include <stdlib.h>
#include "symhelp.h"

//
// Primitives to access symbolic debug information in an image file
//

typedef struct _RTL_SYMBOL_INFORMATION {
    ULONG Type;
    ULONG SectionNumber;
    ULONG Value;
    STRING Name;
} RTL_SYMBOL_INFORMATION, *PRTL_SYMBOL_INFORMATION;

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    );

typedef struct _PROCESS_DEBUG_INFORMATION {
    LIST_ENTRY List;
    HANDLE UniqueProcess;
    DWORD ImageBase;
    DWORD EndOfImage;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    UCHAR ImageFilePath[ MAX_PATH ];
} PROCESS_DEBUG_INFORMATION, *PPROCESS_DEBUG_INFORMATION;


PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilterRoutine;

RTL_CRITICAL_SECTION LoadedImageDebugInfoListCritSect;
LIST_ENTRY LoadedImageDebugInfoListHead;
LIST_ENTRY LoadedProcessDebugInfoListHead;

LPSTR SymbolSearchPath;

// This variable tracks how many times InitializeImageDebugInformation has been
//  called. Certain operations are performed only on the first call (as
//  NumInitCalls transitions from -1 to 0).
LONG NumInitCalls = -1;

LPSTR
GetEnvVariable(
    IN LPSTR VariableName
    )
{
    NTSTATUS Status;
    STRING Name, Value;
    UNICODE_STRING UnicodeName, UnicodeValue;

    RtlInitString( &Name, VariableName );
    RtlInitUnicodeString( &UnicodeValue, NULL );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof( UNICODE_NULL );
    UnicodeValue.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, UnicodeValue.MaximumLength );
    if (UnicodeValue.Buffer == NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlQueryEnvironmentVariable_U( NULL, &UnicodeName, &UnicodeValue );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
        return NULL;
        }

    Status = RtlUnicodeStringToAnsiString( &Value, &UnicodeValue, TRUE );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeValue.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Value.Buffer[ Value.Length ] = '\0';
    return Value.Buffer;
}

LPSTR
SetSymbolSearchPath( )
{
    ULONG Size, i, Attributes, NumberOfSymbolPaths;
    LPSTR s, SymbolPaths[ 4 ];

    if (SymbolSearchPath != NULL) {
        return SymbolSearchPath;
        }

    Size = 0;
    NumberOfSymbolPaths = 0;
    if (s = GetEnvVariable( "_NT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "_NT_ALT_SYMBOL_PATH" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    if (s = GetEnvVariable( "SystemRoot" )) {
        SymbolPaths[ NumberOfSymbolPaths++ ] = s;
        }

    SymbolPaths[ NumberOfSymbolPaths++ ] = ".";

    Size = 1;
    for (i=0; i<NumberOfSymbolPaths; i++) {
        Attributes = GetFileAttributesA( SymbolPaths[ i ] );
        if ( Attributes != 0xffffffff && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            Size += 1 + strlen( SymbolPaths[ i ] );
            }
        else {
            SymbolPaths[ i ] = NULL;
            }
        }

    SymbolSearchPath = RtlAllocateHeap( RtlProcessHeap(), 0, Size );
    if (SymbolSearchPath == NULL) {
        return NULL;
        }
    *SymbolSearchPath = '\0';
    for (i=0; i<NumberOfSymbolPaths; i++) {
        if (s = SymbolPaths[ i ]) {
            if (*SymbolSearchPath != '\0') {
                strcat( SymbolSearchPath, ";" );
                }
            strcat( SymbolSearchPath, s );
            }
        }

    return SymbolSearchPath;
}

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead, LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPSTR ImageFilePath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    RTL_PROCESS_MODULES ModuleInfoBuffer;
    PRTL_PROCESS_MODULES ModuleInfo;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo1;
    ULONG RequiredLength, ModuleNumber;

    // Is this the first call?
    if ( InterlockedIncrement ( &NumInitCalls ) == 0 )
    {
        // Yes
        SetSymbolSearchPath();
        InitializeListHead( &LoadedImageDebugInfoListHead );
        InitializeListHead( &LoadedProcessDebugInfoListHead );
        Status = RtlInitializeCriticalSection( &LoadedImageDebugInfoListCritSect );
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    // The filter routine can be superceded at any time.
    LoadSymbolsFilterRoutine = LoadSymbolsFilter;

    if (GetKernelSymbols) {
        ModuleInfo = &ModuleInfoBuffer;
        RequiredLength = sizeof( *ModuleInfo );
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           ModuleInfo,
                                           RequiredLength,
                                           &RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            ModuleInfo = NULL;
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &ModuleInfo,
                                              0,
                                              &RequiredLength,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if (NT_SUCCESS( Status )) {
                Status = NtQuerySystemInformation( SystemModuleInformation,
                                                   ModuleInfo,
                                                   RequiredLength,
                                                   &RequiredLength
                                                 );
                if (NT_SUCCESS( Status )) {
                    ModuleInfo1 = &ModuleInfo->Modules[ 0 ];
                    for (ModuleNumber=0; ModuleNumber<ModuleInfo->NumberOfModules; ModuleNumber++) {
                        if ((DWORD)(ModuleInfo1->ImageBase) & 0x80000000) {
                            if (ImageFilePath = strchr( ModuleInfo1->FullPathName, ':')) {
                                ImageFilePath -= 1;
                                }
                            else {
                                ImageFilePath = ModuleInfo1->FullPathName +
                                                strlen( ModuleInfo1->FullPathName );
                                while (ImageFilePath > ModuleInfo1->FullPathName) {
                                    if (ImageFilePath[ -1 ] == '\\') {
                                        break;
                                        }
                                    else {
                                        ImageFilePath -= 1;
                                        }
                                    }
                                }

                            AddImageDebugInformation( NULL,
                                                      ImageFilePath,
                                                      (DWORD)ModuleInfo1->ImageBase,
                                                      ModuleInfo1->ImageSize
                                                    );
                            }

                        ModuleInfo1++;
                        }
                    }

                NtFreeVirtualMemory( NtCurrentProcess(),
                                     &ModuleInfo,
                                     &RequiredLength,
                                     MEM_RELEASE
                                   );
                }
            }
        }

    if (TargetProcess == NULL) {

        // Load module information for this process.

        TargetProcess = GetCurrentProcess();
        }

    Status = NtQueryInformationProcess( TargetProcess,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL
                                      );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Peb = ProcessInformation.PebBaseAddress;

    if (NewProcess) {
        return TRUE;
        }

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &Peb->Ldr,
                                  &Ldr,
                                  sizeof( Ldr ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory( TargetProcess,
                                  &LdrHead->Flink,
                                  &LdrNext,
                                  sizeof( LdrNext ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    while (LdrNext != LdrHead) {
        LdrEntry = CONTAINING_RECORD( LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntry,
                                      &LdrEntryData,
                                      sizeof( LdrEntryData ),
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        UnicodeString.Length = LdrEntryData.FullDllName.Length;
        UnicodeString.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        UnicodeString.Buffer = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                UnicodeString.MaximumLength
                                              );
        if (!UnicodeString.Buffer) {
            return FALSE;
            }
        Status = NtReadVirtualMemory( TargetProcess,
                                      LdrEntryData.FullDllName.Buffer,
                                      UnicodeString.Buffer,
                                      UnicodeString.MaximumLength,
                                      NULL
                                    );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
            return FALSE;
            }

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &UnicodeString,
                                      TRUE
                                    );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeString.Buffer );
        if (ImageFilePath = strchr( AnsiString.Buffer, ':')) {
            ImageFilePath -= 1;
            }
        else {
            ImageFilePath = AnsiString.Buffer;
            }

        AddImageDebugInformation( (HANDLE)ProcessInformation.UniqueProcessId,
                                  ImageFilePath,
                                  (DWORD)LdrEntryData.DllBase,
                                  LdrEntryData.SizeOfImage
                                );

        RtlFreeAnsiString( &AnsiString );

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    return TRUE;
}


BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo = NULL;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;
    HANDLE FileHandle;
    UCHAR PathBuffer[ MAX_PATH ];

    FileHandle = FindExecutableImage( ImageFilePath, SymbolSearchPath, PathBuffer );
    if (FileHandle == NULL) {
        if (LoadSymbolsFilterRoutine != NULL) {
            (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                         ImageFilePath,
                                         ImageBase,
                                         ImageSize,
                                         LoadSymbolsPathNotFound
                                       );
            }

        return FALSE;
        }
    CloseHandle( FileHandle );
    if (LoadSymbolsFilterRoutine != NULL) {
        (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                     PathBuffer,
                                     ImageBase,
                                     ImageSize,
                                     LoadSymbolsDeferredLoad
                                   );
        }

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Head = &LoadedImageDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next, IMAGE_DEBUG_INFORMATION, List );
        if (DebugInfo->ImageBase == ImageBase &&
            !_stricmp( PathBuffer, DebugInfo->ImageFilePath )
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        DebugInfo = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            !_stricmp( PathBuffer, ProcessInfo->ImageFilePath )
           ) {
            return TRUE;
            }

        Next = Next->Flink;
        }

    ProcessInfo = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *ProcessInfo ) );
    if (ProcessInfo == NULL) {
        return FALSE;
        }
    ProcessInfo->ImageBase = ImageBase;
    ProcessInfo->EndOfImage = ImageBase + ImageSize;
    ProcessInfo->UniqueProcess = UniqueProcess;
    ProcessInfo->DebugInfo = DebugInfo;
    strcpy( ProcessInfo->ImageFilePath, PathBuffer );
    InsertTailList( &LoadedProcessDebugInfoListHead, &ProcessInfo->List );

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return TRUE;
}


BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    )
{
    PLIST_ENTRY Head, Next;
    PPROCESS_DEBUG_INFORMATION ProcessInfo;

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            (!ARGUMENT_PRESENT( ImageFilePath ) ||
             !_stricmp( ImageFilePath, ProcessInfo->ImageFilePath )
            )
           ) {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnload
                                           );
                }

            Next = Next->Blink;
            RemoveEntryList( &ProcessInfo->List );
            RtlFreeHeap( RtlProcessHeap(), 0, ProcessInfo );
            if (ARGUMENT_PRESENT( ImageFilePath )) {
                break;
                }
            }

        Next = Next->Flink;
        }

    return TRUE;
}

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    PPROCESS_DEBUG_INFORMATION ProcessInfo = NULL;

    Status = RtlEnterCriticalSection( &LoadedImageDebugInfoListCritSect );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    if (Address & 0x80000000) {
        UniqueProcess = NULL;
        }

    Head = &LoadedProcessDebugInfoListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessInfo = CONTAINING_RECORD( Next, PROCESS_DEBUG_INFORMATION, List );
        if (ProcessInfo->UniqueProcess == UniqueProcess &&
            Address >= ProcessInfo->ImageBase &&
            Address < ProcessInfo->EndOfImage
           ) {
            break;
            }

        Next = Next->Flink;
        }

    if (Next == Head) {
        RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
        return NULL;
        }

    DebugInfo = ProcessInfo->DebugInfo;
    if (DebugInfo == NULL) {
        DebugInfo = MapDebugInformation( NULL, ProcessInfo->ImageFilePath, SymbolSearchPath, ProcessInfo->ImageBase );
        if (DebugInfo != NULL) {
            DebugInfo->ImageBase = ProcessInfo->ImageBase;
            ProcessInfo->DebugInfo = DebugInfo;
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsLoad
                                           );
                }

            InsertTailList( &LoadedImageDebugInfoListHead, &DebugInfo->List );
            }
        else {
            if (LoadSymbolsFilterRoutine != NULL) {
                (*LoadSymbolsFilterRoutine)( UniqueProcess,
                                             ProcessInfo->ImageFilePath,
                                             ProcessInfo->ImageBase,
                                             ProcessInfo->EndOfImage - ProcessInfo->ImageBase,
                                             LoadSymbolsUnableToLoad
                                           );
                }
            }
        }

    RtlLeaveCriticalSection( &LoadedImageDebugInfoListCritSect );
    return DebugInfo;
}


ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
{
    NTSTATUS Status;
    PIMAGE_DEBUG_INFORMATION DebugInfo;
    RTL_SYMBOL_INFORMATION SymbolInformation;
    ULONG i, ModuleNameLength, Result, Offset;
    LPSTR s;

    DebugInfo = FindImageDebugInformation( UniqueProcess,
                                           Address
                                         );
    if (DebugInfo != NULL) {
        if (s = strchr( DebugInfo->ImageFileName, '.' )) {
            ModuleNameLength = s - DebugInfo->ImageFileName;
            }
        else {
            ModuleNameLength = strlen( DebugInfo->ImageFileName );
            }

        //  [mikese] RtlLookupSymbolByAddress will fault if there is
        //  no COFF symbol information.
        if ( DebugInfo->CoffSymbols != NULL ) {
            Status = RtlLookupSymbolByAddress( (PVOID)DebugInfo->ImageBase,
                                       DebugInfo->CoffSymbols,
                                       (PVOID)Address,
                                       0x4000,
                                       &SymbolInformation,
                                       NULL
                                     );

            }
        else {
            Status = STATUS_UNSUCCESSFUL;
             }
        }
    else {
        ModuleNameLength = 0;
        Status = STATUS_UNSUCCESSFUL;
        }

    if (NT_SUCCESS( Status )) {
        s = SymbolInformation.Name.Buffer;
        i = 1;
        while (SymbolInformation.Name.Length > i &&
               isdigit( s[ SymbolInformation.Name.Length - i ] )
              ) {
            i += 1;
            }

        if (s[ SymbolInformation.Name.Length - i ] == '@') {
            SymbolInformation.Name.Length = (USHORT)(SymbolInformation.Name.Length - i);
            }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%Z",
                            ModuleNameLength,
                            DebugInfo->ImageFileName,
                            &SymbolInformation.Name
                          );
        Offset = Address - DebugInfo->ImageBase - SymbolInformation.Value;
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
            }
        }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                DebugInfo->ImageFileName,
                                Address
                              );
            }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }

    return Result;
}

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength )
{
    PRTL_DEBUG_INFORMATION p;
    NTSTATUS Status;
    DWORD ProcessId;
    ULONG Result = 0;
    ULONG Attempts = 0;

    // We need to call Initialize once to ensure that GetSymbolicNameForAddress
    //  does not fault.
    if ( NumInitCalls == -1 )
    {
        InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                         NULL, FALSE, FALSE );
    }

    ProcessId = GetCurrentProcessId();

    while ( Result == 0 )
    {
        Result = GetSymbolicNameForAddress ( (HANDLE)ProcessId, Address,
                                             Name, MaxNameLength );
        if ( Result == 0 )
        {
            if ( ++Attempts < 2 )
            {
                // Try reintialising, to load any modules we missed on a previous
                //  occasion (or if we haven't initialised yet).
                // I don't need a load-symbols-filter, so just use whatever is
                //  already there, if any
                InitializeImageDebugInformation( LoadSymbolsFilterRoutine,
                                                 NULL, FALSE, FALSE );
            }
            else
            {
                // Apparently we are unable to do the right thing, so just return
                //  the address as hex.
                Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
            }
        }
    }

    return Result;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    );

PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    );

NTSTATUS
RtlLookupSymbolByAddress(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL,
    IN PVOID Address,
    IN ULONG ClosenessLimit,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation,
    OUT PRTL_SYMBOL_INFORMATION NextSymbolInformation OPTIONAL
    )
/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within ClosenessLimit of the location,
    STATUS_ENTRYPOINT_NOT_FOUND is returned.

Arguments:

    ImageBase - Supplies the base address of the image containing
                Address

    MappedBase - Optional parameter, that if specified means the image
                 was mapped as a data file and the MappedBase gives the
                 location it was mapped.  If this parameter does not
                 point to an image file base, then it is assumed that
                 this is a pointer to the coff debug info.

    ClosenessLimit - Specifies the maximum distance that Address can be
                     from the value of a symbol to be considered
                     "found".  Symbol's whose value is further away then
                     this are not "found".

    SymbolInformation - Points to a structure that is filled in by
                        this routine if a symbol table entry is found.

    NextSymbolInformation - Optional parameter, that if specified, is
                            filled in with information about these
                            symbol whose value is the next address above
                            Address


Return Value:

    Status of operation.

--*/

{
    NTSTATUS Status;
    ULONG AddressOffset, i;
    PIMAGE_SYMBOL PreviousSymbolEntry = NULL;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    BOOLEAN SymbolFound;
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;

    DebugInfo = RtlpGetCoffDebugInfo( ImageBase, MappedBase );
    if (DebugInfo == NULL) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)
        ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);

    StringTable = (PUCHAR)
        ((ULONG)SymbolEntry + DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);


    //
    // Find the "header" symbol (skipping all the section names)
    //

    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        if (!strcmp( &SymbolEntry->N.ShortName[ 0 ], "header" )) {
            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
        }

    //
    // If no "header" symbol found, just start at the first symbol.
    //

    if (i >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
        i = 0;
        }

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

    AddressOffset = (ULONG)Address - (ULONG)ImageBase;
    SymbolFound = FALSE;
    for (; i < DebugInfo->NumberOfSymbols; i++) {

        //
        // Skip over any Auxilliary entries.
        //
        try {
            while (SymbolEntry->NumberOfAuxSymbols) {
                i = i + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)
                    ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL +
                     SymbolEntry->NumberOfAuxSymbols * IMAGE_SIZEOF_SYMBOL
                    );

                }

            RtlMoveMemory( &Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL );
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
            }

        //
        // If this symbol value is less than the value we are looking for.
        //

        if (Symbol.Value <= AddressOffset) {
            //
            // Then remember this symbol entry.
            //

            PreviousSymbolEntry = SymbolEntry;
            SymbolFound = TRUE;
            }
        else {
            //
            // All done looking if value of symbol is greater than
            // what we are looking for, as symbols are in address order
            //

            break;
            }

        SymbolEntry = (PIMAGE_SYMBOL)
            ((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);

        }

    if (!SymbolFound || (AddressOffset - PreviousSymbolEntry->Value) > ClosenessLimit) {
        return STATUS_ENTRYPOINT_NOT_FOUND;
        }

    Status = RtlpCaptureSymbolInformation( PreviousSymbolEntry, StringTable, SymbolInformation );
    if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( NextSymbolInformation )) {
        Status = RtlpCaptureSymbolInformation( SymbolEntry, StringTable, NextSymbolInformation );
        }

    return Status;
}


NTSTATUS
RtlpCaptureSymbolInformation(
    IN PIMAGE_SYMBOL SymbolEntry,
    IN PCHAR StringTable,
    OUT PRTL_SYMBOL_INFORMATION SymbolInformation
    )
{
    USHORT MaximumLength;
    PCHAR s;

    SymbolInformation->SectionNumber = SymbolEntry->SectionNumber;
    SymbolInformation->Type = SymbolEntry->Type;
    SymbolInformation->Value = SymbolEntry->Value;

    if (SymbolEntry->N.Name.Short) {
        MaximumLength = 8;
        s = &SymbolEntry->N.ShortName[ 0 ];
        }

    else {
        MaximumLength = 64;
        s = &StringTable[ SymbolEntry->N.Name.Long ];
        }

#if i386
    if (*s == '_') {
        s++;
        MaximumLength--;
        }
#endif

    SymbolInformation->Name.Buffer = s;
    SymbolInformation->Name.Length = 0;
    while (*s && MaximumLength--) {
        SymbolInformation->Name.Length++;
        s++;
        }

    SymbolInformation->Name.MaximumLength = SymbolInformation->Name.Length;
    return( STATUS_SUCCESS );
}


PIMAGE_COFF_SYMBOLS_HEADER
RtlpGetCoffDebugInfo(
    IN PVOID ImageBase,
    IN PVOID MappedBase OPTIONAL
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugSize;
    ULONG NumberOfDebugDirectories;

    DosHeader = (PIMAGE_DOS_HEADER)MappedBase;
    if ( !DosHeader || DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {
        //
        // Locate debug section.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)(MappedBase == NULL ? ImageBase : MappedBase),
                                          (BOOLEAN)(MappedBase == NULL ? TRUE : FALSE),
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          &DebugSize
                                        );

        if (!DebugDirectory ||
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            ((DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)) != 0)) {
            return NULL;
        }
        //
        // point debug directory at coff debug directory
        //
        NumberOfDebugDirectories = DebugSize / sizeof(*DebugDirectory);

        while ( NumberOfDebugDirectories-- ) {
            if ( DebugDirectory->Type == IMAGE_DEBUG_TYPE_COFF ) {
                break;
            }
            DebugDirectory++;
        }

        if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_COFF ) {
            return NULL;
        }

        if (MappedBase == NULL) {
            if (DebugDirectory->AddressOfRawData == 0) {
                return(NULL);
            }
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) ImageBase + DebugDirectory->AddressOfRawData);
        } else {
            DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)
                        ((ULONG) MappedBase + DebugDirectory->PointerToRawData);
        }
    } else {
        DebugInfo = (PIMAGE_COFF_SYMBOLS_HEADER)MappedBase;
    }
    return DebugInfo;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\utils\debug.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debug support functions. These do not produce any
    code in the retail build.

Environment:

    User mode

Revision History:

    03/20/98 -srinivac-
        Created it

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <objidl.h>
#include <stdio.h>

#include "symhelp.h"
#include "debug.h"

#if DBG

//
// Variable for maintaining current debug level
//

DWORD gdwDebugLevel = DBG_LEVEL_WARNING;

//
// Global debugging flag
//

DWORD gdwGlobalDbgFlags = 0;

PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\binddlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       binddlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// BindDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "BindDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBindDlg dialog


CBindDlg::CBindDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CBindDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBindDlg)
	m_Pwd = _T("");
	m_BindDn = _T("");
	m_Domain = _T("");
	m_bSSPIdomain = TRUE;
	//}}AFX_DATA_INIT
}


void CBindDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBindDlg)
	DDX_Control(pDX, IDC_BindDmn, m_CtrlBindDmn);
	DDX_Text(pDX, IDC_BindPwd, m_Pwd);
	DDX_Text(pDX, IDC_BindDn, m_BindDn);
	DDX_Text(pDX, IDC_BindDmn, m_Domain);
	DDX_Check(pDX, IDC_SSPI_DOMAIN, m_bSSPIdomain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBindDlg, CDialog)
	//{{AFX_MSG_MAP(CBindDlg)
	ON_BN_CLICKED(IDOPTS, OnOpts)
	ON_BN_CLICKED(IDC_SSPI_DOMAIN, OnSspiDomain)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBindDlg message handlers

void CBindDlg::OnOpts()
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND,   ID_OPTIONS_BIND);
	
}

void CBindDlg::OnSspiDomain()
{

	UpdateData(TRUE);
	m_CtrlBindDmn.EnableWindow(m_bSSPIdomain);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_SSPI_DOMAIN_SHORTCUT);
}

BOOL CBindDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	m_CtrlBindDmn.EnableWindow(m_bSSPIdomain);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CBindDlg::OnOK()
{
	CDialog::OnOK();
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\utils\memory.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions 

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "debug.h"
#include "memory.h"
#include "symhelp.h"

//#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))
#define DWORD_ALIGN_UP(size) ((size+3)&~3)

DWORD
MemSizeOri(
   LPVOID pMem
);

int
UnicodeToAnsiString(
    PCWSTR pszUnicode,
    PSTR pszAnsi
    )

/*++

Routine Description:

    Convert a Unicode string to ansi. If the same string is passed in to the
    result string pszAnsi, it will use the same blob of memory.

Arguments:

    pszUnicode - the unicode string to be converted to an ansi string
    pszAnsi  - the result ansi string

Return Value:

--*/

{
    PSTR  pszTemp = NULL;
    int   rc = 0;
    DWORD dwLength = 0;

    dwLength = wcslen(pszUnicode) + 1;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if(pszAnsi == (PSTR)pszUnicode) {
        pszTemp = (PSTR)MemAlloc_E(dwLength*sizeof(WCHAR));
        if (!pszTemp) {
            return rc;
        }
        pszAnsi = pszTemp;
    }

    if(pszAnsi) {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pszUnicode,
                                  dwLength,
                                  pszAnsi,
                                  dwLength*sizeof(WCHAR),
                                  NULL,
                                  NULL );
    }

    //
    // If szTemp is non-null, we must copy the resulting string
    // so that it looks as if we did it in place:
    //
    if( pszTemp && ( rc > 0 ) ) {
        pszAnsi = (PSTR)pszUnicode;
        strcpy( pszAnsi, pszTemp );
        MemFree( pszTemp );
    }
    /*
    else {
        DWORD WinError = GetLastError();
        RIP();
    }
    */

    return rc;
}

PSTR
AllocateAnsiString(
    PCWSTR  pszUnicodeString
    )

/*++

Routine Description:

    Allocate an Ansi string with a unicode string as input

Arguments:

    pszUnicodeString - the unicode string to be converted to an ansi string

Return Value:

--*/

{
    PSTR pszAnsiString = NULL;
    int rc = 0;

    ASSERT(pszUnicodeString);

    pszAnsiString = (PSTR)MemAlloc_E(wcslen(pszUnicodeString)+1);

    if (pszAnsiString) {
        rc = UnicodeToAnsiString(
                pszUnicodeString,
                pszAnsiString
                );
    }

    if (rc>0) {
        return pszAnsiString;
    }

    if (pszAnsiString) {
        MemFree(pszAnsiString);
    }

    return NULL;
}

int
AnsiToUnicodeString(
    PCSTR pszAnsi,
    PWSTR pszUnicode
    )

/*++

Routine Description:

    Convert an ansi string to unicode. An output string of enough size
    is expected to be passed in.

Arguments:

    pszUnicode - the unicode string to be converted to an ansi string
    pszAnsi  - the result ansi string

Return Value:

--*/

{
    int rc;
    DWORD dwLength = strlen(pszAnsi);

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pszAnsi,
                             dwLength + 1,
                             pszUnicode,
                             dwLength + 1);

    //
    // Ensure NULL termination.
    //
    pszUnicode[dwLength] = 0;

    return rc;
}


LPWSTR
AllocateUnicodeString(
    PCSTR  pszAnsiString
    )

/*++

Routine Description:

    Allocate a Unicode string with an ansi string as input

Arguments:

    pszAnsiString - the ansi string to be converted to a unicode string

Return Value:

--*/

{
    PWSTR  pszUnicodeString = NULL;
    int rc = 0;

    ASSERT(pszAnsiString);

    pszUnicodeString = (PWSTR)MemAlloc(strlen(pszAnsiString)*sizeof(WCHAR) +
                                       sizeof(WCHAR));

    if (pszUnicodeString) {
        rc = AnsiToUnicodeString(
                pszAnsiString,
                pszUnicodeString
                );
    }

    if (rc>0) {
        return pszUnicodeString;
    }

    if (pszUnicodeString) {
        MemFree(pszUnicodeString);
    }
    return NULL;
}

PSTR MemAllocStr_E(
    PSTR pszIn
    ) 
{
    PSTR pszTemp;
    
    pszTemp = (PSTR)MemAlloc_E((strlen(pszIn)+1)*sizeof(char));
    
    if (pszTemp==NULL) {
        return NULL;
    }

    return strcpy(pszTemp, pszIn);

}

PWSTR MemAllocStrW_E(
    PWSTR pszIn
    ) 
{
    PWSTR pszTemp;
    
    pszTemp = (PWSTR)MemAlloc_E((wcslen(pszIn)+1)*sizeof(WCHAR));
    
    if (pszTemp==NULL) {
        return NULL;
    }

    return wcscpy(pszTemp, pszIn);

}


LPVOID MemAlloc_E(
    DWORD dwBytes
    ) 
{
    LPVOID pReturn = NULL;
    pReturn = MemAlloc(dwBytes);
    if (!pReturn) {
        RaiseException(LL_MEMORY_ERROR, 0, 0, NULL);    
    }
    return pReturn;
}

LPVOID MemRealloc_E(
            LPVOID IpMem, 
            DWORD dwBytes
            ) 
{
    DWORD dwSize;
    LPVOID pReturn = NULL;

    dwSize = MemSizeOri(IpMem);

    pReturn = MemRealloc(IpMem,dwSize,dwBytes);
    if (!pReturn) {
        RaiseException(LL_MEMORY_ERROR, 0, 0, NULL);    
    }
    return pReturn;

}   

#if DBG

DWORD dwMemoryLog = 1;

#define MAXDEPTH 10

typedef struct _MEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} MEMTAG, *PMEMTAG ;

LIST_ENTRY       MemList ;
DWORD            MemCount ;
CRITICAL_SECTION MemCritSect ;

/*++

Routine Description:

    This function initializes the mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitMem(
    VOID
)
{
    InitializeCriticalSection(&MemCritSect) ;
    InitializeListHead(&MemList) ;
    MemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertMemLeaks(
    VOID
)
{
    ASSERT(IsListEmpty(&MemList)) ;
}

#endif

LPVOID
MemAlloc(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
#if DBG
    DWORD cbNew ;
    PMEMTAG pMem ;
    DWORD i = 0;

    ULONG ulHash;

    //
    // adjust size for our tag and one spare dword at end
    // and allocate the memory
    //
    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb + ( sizeof(MEMTAG) + sizeof(DWORD) );

    pMem=(PMEMTAG)LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    //
    // fill in deadbeef at end and tag info.
    // and insert it into the MemList
    //

    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;
    pMem->Tag = 0xB00FB00F ;
    pMem->Size = cb ;


    //
    // Capture a backtrace at this spot for debugging.
    //

#if (defined(i386) && !defined(WIN95))

    pMem->uDepth = RtlCaptureStackBackTrace(
                            0,
                            MAXDEPTH,
                            pMem->pvBackTrace,
                            &ulHash
                            );



#else

    pMem->uDepth = 0;

#endif


    EnterCriticalSection(&MemCritSect) ;
    InsertHeadList(&MemList, &pMem->List) ;
    MemCount++ ;
    LeaveCriticalSection(&MemCritSect) ;

    //
    // skip past the mem tag
    //
    pMem++ ;
    return (LPVOID)(pMem);
#else
    return(LocalAlloc(LPTR, cb));
#endif

}

BOOL
MemFree(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    DWORD        cbNew = 0;
    PMEMTAG pNewMem ;
    LPDWORD      pRetAddr;
    DWORD i = 0;



    pNewMem = (PMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;
    cbNew = cb + sizeof(DWORD) + sizeof(MEMTAG);

    //
    // check the trailing deadbeef and remove from list
    //

    if (*(LPDWORD)(((LPBYTE)pNewMem) + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        ERR(("Freeing memory not allocated by MemAlloc"));
        return FALSE;
    }

    EnterCriticalSection(&MemCritSect) ;
    RemoveEntryList(&pNewMem->List) ;
    MemCount-- ;
    LeaveCriticalSection(&MemCritSect) ;


    for (i = 0; i < pNewMem->uDepth; i++) {

        if (pNewMem->pszSymbol[i]) {
            LocalFree(pNewMem->pszSymbol[i]);
        }
    }


    //
    // Whack freed memory with known pattern
    //

    memset(pMem, 0x65, cb);
    return(LocalFree((LPVOID)pNewMem) == NULL);

#else

    return(LocalFree(pMem) == NULL);

#endif


}

DWORD
MemSize(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    DWORD        cbNew = 0;
    PMEMTAG      pNewMem ;
    LPDWORD      pRetAddr;
    DWORD i = 0;



    pNewMem = (PMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;
    cbNew = cb + sizeof(DWORD) + sizeof(MEMTAG);

    if (*(LPDWORD)(((LPBYTE)pNewMem) + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        ERR(("Getting size not allocated by MemAlloc!"));
        return 0;
    }

    return((DWORD)cb);
#else
    return((DWORD)LocalSize(pMem));
#endif
}

DWORD
MemSizeOri(
   LPVOID pMem
)
{
#if DBG
    DWORD        cb;
    PMEMTAG      pNewMem ;

    pNewMem = (PMEMTAG)pMem;
    pNewMem -- ;

    cb = pNewMem->Size;

    return((DWORD)cb);
#else
    return((DWORD)LocalSize(pMem));
#endif
}



LPVOID
MemRealloc(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=MemAlloc(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        MemFree(pOldMem);
    }

    return pNewMem;
}

LPSTR
MemAllocStr(
    LPSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPSTR)MemAlloc( strlen(pStr)*sizeof(CHAR) + sizeof(CHAR) ))
      strcpy(pMem, pStr);

   return pMem;
}

PWSTR
MemAllocStrW(
    PWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   PWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (PWSTR)MemAlloc( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
MemReallocStr(
   LPSTR *ppStr,
   LPSTR pStr
)
{
   if (ppStr && (*ppStr)) {
        MemFree(*ppStr);
        *ppStr=MemAllocStr(pStr);

        return TRUE;
    }
    else {
        return FALSE;
    }
}


#if DBG
VOID
DumpMemoryTracker(
    VOID
    )
{
#ifndef _WIN64
   LIST_ENTRY* pEntry;
   MEMTAG*  pMem;
   BYTE*       pTemp;
   DWORD i = 0;
   CHAR szSymbolPath[MAX_PATH+1];
   DWORD dwCount = 0;

   pEntry   = MemList.Flink;

   if (!dwMemoryLog) {
      return;
   }


   if ( pEntry == &MemList ) {
       OutputDebugStringA( "No Memory leaks found\n" );
   }

   while( pEntry != &MemList )
   {
      CHAR szLeak[1024];

      pTemp = (BYTE*)pEntry;
      pTemp = pTemp - sizeof(DWORD) - sizeof(DWORD)
              - sizeof(DWORD) -
              (sizeof(CHAR*) + sizeof(LPVOID))*( MAXDEPTH +1);
      pMem  = (MEMTAG*)pTemp;

      sprintf(
        szLeak,
        "[ldifde/csvde] Memory leak!!! Addresss = %.8x Size = %ld \n",
        pMem + 1,
        pMem->Size
        );
      OutputDebugStringA( szLeak );


     for (i = 0; i < pMem->uDepth; i++) {

         dwCount = TranslateAddress(
                     (ULONG)pMem->pvBackTrace[ i ],
                     szSymbolPath,
                     MAX_PATH
                     );
         szSymbolPath[dwCount] = '\0';
         sprintf(szLeak, "%s\n",szSymbolPath);
         OutputDebugStringA( szLeak);

     }

      pEntry   = pEntry->Flink;
   }
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\adddlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       adddlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// AddDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "AddDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// AddDlg dialog


AddDlg::AddDlg(CWnd* pParent /*=NULL*/)
	: CDialog(AddDlg::IDD, pParent)
{

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	
	//{{AFX_DATA_INIT(AddDlg)
	m_Dn = _T("");
	m_Attr = _T("");
	m_Vals = _T("");
	m_Sync = TRUE;
	m_bExtended = FALSE;
	//}}AFX_DATA_INIT
	iChecked = -1;
	m_Sync = app->GetProfileInt("Operations",  "AddSync", m_Sync);
	m_bExtended = app->GetProfileInt("Operations",  "AddExtended", m_bExtended);
}



AddDlg::~AddDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Operations", "AddSync", m_Sync);
	app->WriteProfileInt("Operations",  "AddExtended", m_bExtended);
}





void AddDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(AddDlg)
	DDX_Control(pDX, IDC_ADD_ENTERATTR, m_EnterAttr);
	DDX_Control(pDX, IDC_ADD_RMATTR, m_RmAttr);
	DDX_Control(pDX, IDC_ADD_EDITATTR, m_EditAttr);
	DDX_Control(pDX, IDC_ADD_ATTRLIST, m_AttrList);
	DDX_Text(pDX, IDC_ADD_DN, m_Dn);
	DDX_Text(pDX, IDC_ADD_ATTR, m_Attr);
	DDX_Text(pDX, IDC_ADD_VALS, m_Vals);
	DDX_Check(pDX, IDC_ADD_SYNC, m_Sync);
	DDX_Check(pDX, IDC_ADD_EXTENDED, m_bExtended);
	//}}AFX_DATA_MAP
}





CString AddDlg::GetEntry(int i){

	CString str;

	m_AttrList.GetText(i, str);
	return str;
}




BEGIN_MESSAGE_MAP(AddDlg, CDialog)
	//{{AFX_MSG_MAP(AddDlg)
	ON_BN_CLICKED(IDRUN, OnRun)
	ON_BN_CLICKED(IDC_ADD_ENTERATTR, OnAddEnterattr)
	ON_BN_CLICKED(IDC_ADD_EDITATTR, OnAddEditattr)
	ON_BN_CLICKED(IDC_ADD_RMATTR, OnAddRmattr)
	ON_BN_CLICKED(IDC_ADD_INSBER, OnAddInsber)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// AddDlg message handlers

void AddDlg::OnRun()
{
	UpdateData(TRUE);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_ADDGO);
	
}



void AddDlg::OnAddEnterattr()
{
	UpdateData(TRUE);
	CString str = m_Attr + ":" + m_Vals;
	if(iChecked >= 0){
		m_AttrList.DeleteString(iChecked);
		iChecked = -1;
	}
	m_AttrList.AddString(LPCTSTR(str));
}



void AddDlg::OnAddEditattr()
{
	CString attrVal, str;
	int i, k;
	if((i= m_AttrList.GetCurSel()) != LB_ERR){
		m_AttrList.GetText(i,  attrVal);
		iChecked = i;

		k = attrVal.Find(':');

		if(k > 0){
			m_Attr = attrVal.Left(k);
			m_Vals = attrVal.Right(attrVal.GetLength() - m_Attr.GetLength()-1);
		}

		UpdateData(FALSE);
	}
	
}



void AddDlg::OnAddRmattr()
{
	int i;
	if((i = m_AttrList.GetCurSel()) != LB_ERR){
		m_AttrList.DeleteString(i);
		if(i == iChecked)
			iChecked = -1;
	}

}




void AddDlg::OnAddInsber()
{
	CFileDialog	FileDlg(TRUE);

	if(FileDlg.DoModal() == IDOK){


		CString fname = FileDlg.GetPathName();
		CFile tmpFile(fname, CFile::modeRead|CFile::shareDenyNone);
		CString str;
		DWORD dwLength;

		try{
			dwLength = tmpFile.GetLength();
		}
		catch(CFileException *e){
			dwLength = 0;
			e->Delete();
		}

		str.Format("\\BER(%lu): %s", dwLength, fname);
		UpdateData(TRUE);
		m_Vals += str;
		UpdateData(FALSE);
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\adddlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       adddlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// AddDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// AddDlg dialog

class AddDlg : public CDialog
{
// Construction
private:
	int iChecked;
public:
	AddDlg(CWnd* pParent = NULL);   // standard constructor
	~AddDlg();
	virtual void OnCancel()		{
															AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_ADDEND);
															DestroyWindow();
														}

	virtual void OnOK()				{	OnRun(); }
	int GetEntryCount()					{ return m_AttrList.GetCount(); }
	CString GetEntry(int i);
																

// Dialog Data
	//{{AFX_DATA(AddDlg)
	enum { IDD = IDD_ADD };
	CButton	m_EnterAttr;
	CButton	m_RmAttr;
	CButton	m_EditAttr;
	CListBox	m_AttrList;
	CString	m_Dn;
	CString	m_Attr;
	CString	m_Vals;
	BOOL	m_Sync;
	BOOL	m_bExtended;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(AddDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//	afx_msg int OnCreate( LPCREATESTRUCT lpCreateStruct );


	// Generated message map functions
	//{{AFX_MSG(AddDlg)
	afx_msg void OnRun();
	afx_msg void OnAddEnterattr();
	afx_msg void OnAddEditattr();
	afx_msg void OnAddRmattr();
	afx_msg void OnAddInsber();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\bndopt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       bndopt.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// BndOpt.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "BndOpt.h"


#include "winldap.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CBndOpt dialog


CBndOpt::CBndOpt(CWnd* pParent /*=NULL*/)
	: CDialog(CBndOpt::IDD, pParent)
{
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	
	//{{AFX_DATA_INIT(CBndOpt)
	m_bSync = TRUE;
	m_Auth = 7;
	m_API = BND_GENERIC_API;
	m_bAuthIdentity = TRUE;
	//}}AFX_DATA_INIT

	m_API = app->GetProfileInt("Connection", "BindAPI", m_API);
	m_bSync = app->GetProfileInt("Connection", "BindSync", m_bSync);
	m_Auth = app->GetProfileInt("Connection", "BindAuth", m_Auth);
	m_bAuthIdentity = app->GetProfileInt("Connection", "BindAuthIdentity", m_bAuthIdentity);
}




CBndOpt::~CBndOpt(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Connection", "BindAPI", m_API);
	app->WriteProfileInt("Connection", "BindSync", m_bSync);
	app->WriteProfileInt("Connection", "BindAuth", m_Auth);
	app->WriteProfileInt("Connection", "BindAuthIdentity", m_bAuthIdentity);
}






void CBndOpt::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBndOpt)
	DDX_Check(pDX, IDC_SYNC, m_bSync);
	DDX_CBIndex(pDX, IDC_AUTH, m_Auth);
	DDX_Radio(pDX, IDC_API_TYPE, m_API);
	DDX_Check(pDX, IDC_AUTH_IDENTITY, m_bAuthIdentity);
	//}}AFX_DATA_MAP

}


BEGIN_MESSAGE_MAP(CBndOpt, CDialog)
	//{{AFX_MSG_MAP(CBndOpt)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBndOpt message handlers





ULONG CBndOpt::GetAuthMethod(){

	ULONG mthd = LDAP_AUTH_SIMPLE;
	//
	// Mapped based on the UI dialog strings order
	//

#ifdef WINLDAP
	switch (m_Auth){
	case 0:
		mthd = LDAP_AUTH_SIMPLE;
		break;
	case 1:
		mthd = LDAP_AUTH_SASL;
		break;
	case 2:
		mthd = LDAP_AUTH_OTHERKIND;
		break;
	case 3:
		mthd = LDAP_AUTH_SICILY;
		break;
	case 4:
		mthd = LDAP_AUTH_MSN;
		break;
	case 5:
		mthd = LDAP_AUTH_NTLM;
		break;
	case 6:
		mthd = LDAP_AUTH_DPA;
		break;
	case 7:
		mthd = LDAP_AUTH_SSPI;
		break;
    case 8:
        mthd = LDAP_AUTH_DIGEST;
        break;
	default:
		mthd = LDAP_AUTH_SIMPLE;
	}
#endif

	return mthd;
}






void CBndOpt::OnOK()
{

	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_BIND_OPT_OK);
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\binddlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       binddlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// BindDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBindDlg dialog

class CBindDlg : public CDialog
{
// Construction
public:
	CBindDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBindDlg)
	enum { IDD = IDD_BIND };
	CEdit	m_CtrlBindDmn;
	CString	m_Pwd;
	CString	m_BindDn;
	CString	m_Domain;
	BOOL	m_bSSPIdomain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBindDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CBindDlg)
	afx_msg void OnOpts();
	afx_msg void OnSspiDomain();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\cnctdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cnctdlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// nctDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CnctDlg dialog

class CnctDlg : public CDialog
{
// Construction
public:
	CnctDlg(CWnd* pParent = NULL);   // standard constructor
	~CnctDlg();

// Dialog Data
	//{{AFX_DATA(CnctDlg)
	enum { IDD = IDD_Connect };
	CString	m_Svr;
	BOOL	m_bCnctless;
	int		m_Port;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CnctDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CnctDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\bndopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       bndopt.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// BndOpt.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CBndOpt dialog



// hard-code UI order for m_Auth (see GetAuthMethod)
#define BIND_OPT_AUTH_SSPI					7
#define BIND_OPT_AUTH_SIMPLE				0

class CBndOpt : public CDialog
{
// Construction
public:

	enum {BND_GENERIC_API=0, BND_SIMPLE_API, BND_EXTENDED_API};

	CBndOpt(CWnd* pParent = NULL);   // standard constructor
	~CBndOpt();

	ULONG GetAuthMethod();
	BOOL UseAuthI()		{ return m_bAuthIdentity; }
// Dialog Data
	//{{AFX_DATA(CBndOpt)
	enum { IDD = IDD_BINDOPT };
	BOOL	m_bSync;
	int		m_Auth;
	int		m_API;
	BOOL	m_bAuthIdentity;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBndOpt)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CBndOpt)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\cnctdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cnctdlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// nctDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "cnctDlg.h"



#ifdef WINLDAP
//
// 	Microsoft winldap.dll implementation
//
#include "winldap.h"


#else
//
// Umich ldap32.dll implementation
//
#include "lber.h"
#include "ldap.h"
#include "proto-ld.h"

// fix incompatibilities
#define LDAP_TIMEVAL								  struct timeval

#endif



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CnctDlg dialog


CnctDlg::CnctDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CnctDlg::IDD, pParent)
{

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	
	//{{AFX_DATA_INIT(CnctDlg)
	m_Svr = _T("");
	m_bCnctless = FALSE;
	m_Port = LDAP_PORT;
	//}}AFX_DATA_INIT

	m_bCnctless = app->GetProfileInt("Connection", "Connectionless", m_bCnctless);
	m_Port = app->GetProfileInt("Connection", "Port", m_Port);
}



CnctDlg::~CnctDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Connection", "Connectionless", m_bCnctless);
	m_Port = app->WriteProfileInt("Connection", "Port", m_Port);
}


void CnctDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CnctDlg)
	DDX_Text(pDX, IDC_Svr, m_Svr);
	DDX_Check(pDX, IDC_CNCTLESS, m_bCnctless);
	DDX_Text(pDX, IDC_PORT, m_Port);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CnctDlg, CDialog)
	//{{AFX_MSG_MAP(CnctDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CnctDlg message handlers

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\compdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       compdlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// CompDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "CompDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCompDlg dialog


CCompDlg::CCompDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCompDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCompDlg)
	m_attr = _T("");
	m_dn = _T("");
	m_val = _T("");
	m_sync = TRUE;
	//}}AFX_DATA_INIT

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	m_sync = app->GetProfileInt("Operations", "CompSync", m_sync);
	m_dn = app->GetProfileString("Operations", "CompDn", m_dn);
	m_attr = app->GetProfileString("Operations", "CompAttr", m_attr);
	m_val = app->GetProfileString("Operations", "CompVal", m_val);

}


void CCompDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCompDlg)
	DDX_Text(pDX, IDC_COMP_ATTR, m_attr);
	DDX_Text(pDX, IDC_COMP_DN, m_dn);
	DDX_Text(pDX, IDC_COMP_VAL, m_val);
	DDX_Check(pDX, IDC_SYNC, m_sync);
	//}}AFX_DATA_MAP

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	app->WriteProfileInt("Operations", "CompSync", m_sync);
	app->WriteProfileString("Operations", "CompDn", m_dn);
	app->WriteProfileString("Operations", "CompAttr", m_attr);
	app->WriteProfileString("Operations", "CompVal", m_val);
}


BEGIN_MESSAGE_MAP(CCompDlg, CDialog)
	//{{AFX_MSG_MAP(CCompDlg)
	ON_BN_CLICKED(ID_COMP_RUN, OnCompRun)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCompDlg message handlers






void CCompDlg::OnCompRun()
{
	UpdateData(TRUE);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_COMPGO);
	
}



void CCompDlg::OnCancel()
{
		AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_COMPEND);
		DestroyWindow();
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\dbgdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// DbgDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "DbgDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDbgDlg dialog


CDbgDlg::CDbgDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDbgDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDbgDlg)
	m_api_err = FALSE;
	m_bind = FALSE;
	m_conn = FALSE;
	m_err = FALSE;
	m_err2 = FALSE;
	m_filter = FALSE;
	m_init_term = FALSE;
	m_net_err = FALSE;
	m_ref = FALSE;
	m_req = FALSE;
	m_scratch = FALSE;
	m_srch = FALSE;
	m_tdi = FALSE;
	m_stop_on_err = FALSE;
	//}}AFX_DATA_INIT

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	m_api_err = app->GetProfileInt("Debug", "ApiErr", m_api_err);
	m_bind = app->GetProfileInt("Debug", "ApiErr", m_bind);
	m_conn = app->GetProfileInt("Debug", "ApiErr", m_conn);
	m_err = app->GetProfileInt("Debug", "ApiErr", m_err);
	m_err2 = app->GetProfileInt("Debug", "ApiErr", m_err2);
	m_filter = app->GetProfileInt("Debug", "ApiErr", m_filter);
	m_init_term = app->GetProfileInt("Debug", "ApiErr", m_init_term);
	m_net_err = app->GetProfileInt("Debug", "ApiErr", m_net_err);
	m_ref = app->GetProfileInt("Debug", "ApiErr", m_ref);
	m_req = app->GetProfileInt("Debug", "ApiErr", m_req);
	m_scratch = app->GetProfileInt("Debug", "ApiErr", m_scratch);
	m_srch = app->GetProfileInt("Debug", "ApiErr", m_srch);
	m_tdi = app->GetProfileInt("Debug", "ApiErr", m_tdi);
	m_stop_on_err = app->GetProfileInt("Debug", "ApiErr", m_stop_on_err);
	OrFlags();

}



CDbgDlg::~CDbgDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	app->WriteProfileInt("Debug", "ApiErr", m_api_err);
	app->WriteProfileInt("Debug", "ApiErr", m_bind);
	app->WriteProfileInt("Debug", "ApiErr", m_conn);
	app->WriteProfileInt("Debug", "ApiErr", m_err);
	app->WriteProfileInt("Debug", "ApiErr", m_err2);
	app->WriteProfileInt("Debug", "ApiErr", m_filter);
	app->WriteProfileInt("Debug", "ApiErr", m_init_term);
	app->WriteProfileInt("Debug", "ApiErr", m_net_err);
	app->WriteProfileInt("Debug", "ApiErr", m_ref);
	app->WriteProfileInt("Debug", "ApiErr", m_req);
	app->WriteProfileInt("Debug", "ApiErr", m_scratch);
	app->WriteProfileInt("Debug", "ApiErr", m_srch);
	app->WriteProfileInt("Debug", "ApiErr", m_tdi);
	app->WriteProfileInt("Debug", "ApiErr", m_stop_on_err);
}





void CDbgDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDbgDlg)
	DDX_Check(pDX, IDC_DBG_API_ERR, m_api_err);
	DDX_Check(pDX, IDC_DBG_BIND, m_bind);
	DDX_Check(pDX, IDC_DBG_CONN, m_conn);
	DDX_Check(pDX, IDC_DBG_ERR, m_err);
	DDX_Check(pDX, IDC_DBG_ERR2, m_err2);
	DDX_Check(pDX, IDC_DBG_FILTER, m_filter);
	DDX_Check(pDX, IDC_DBG_INIT_TERM, m_init_term);
	DDX_Check(pDX, IDC_DBG_NET_ERR, m_net_err);
	DDX_Check(pDX, IDC_DBG_REF, m_ref);
	DDX_Check(pDX, IDC_DBG_REQ, m_req);
	DDX_Check(pDX, IDC_DBG_SCRATCH, m_scratch);
	DDX_Check(pDX, IDC_DBG_SRCH, m_srch);
	DDX_Check(pDX, IDC_DBG_TDI, m_tdi);
	DDX_Check(pDX, IDC_DBG_STOP_ON_ERR, m_stop_on_err);
	//}}AFX_DATA_MAP
	OrFlags();
}


BEGIN_MESSAGE_MAP(CDbgDlg, CDialog)
	//{{AFX_MSG_MAP(CDbgDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDbgDlg message handlers

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ctrldlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctrldlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_CTRLDLG_H__1BD80CD8_E1A5_11D0_A9A8_0000F803AA83__INCLUDED_)
#define AFX_CTRLDLG_H__1BD80CD8_E1A5_11D0_A9A8_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ctrldlg.h : header file
//

// sizeof predefined controls count
// Warning: Must match resource list definition
#define PREDEF_CTRL_COUNT		12


class CtrlInfo{
public:
	CString sOid;
	BOOL bCritical;
	CString sDesc;
	CString sVal;
	BOOL bSvrCtrl;

	CtrlInfo()	{;}

	CtrlInfo(CString sOid_, CString sVal_, CString sDesc_ = "<Unavailable>", 
		BOOL bSvrCtrl_=TRUE, BOOL bCritical_=FALSE){
		sOid = sOid_;
		sVal = sVal_;
		sDesc = sDesc_;
		bSvrCtrl = bSvrCtrl_;
		bCritical = bCritical_;
//		sOid.LockBuffer();
//		sVal.LockBuffer();
//		sDesc.LockBuffer();
	}

	CtrlInfo &Init(CString sOid_, CString sVal_, CString sDesc_ = "<Unavailable>", 
		BOOL bSvrCtrl_=TRUE, BOOL bCritical_=FALSE){
		sOid = sOid_;
		sVal = sVal_;
		sDesc = sDesc_;
		bSvrCtrl = bSvrCtrl_;
		bCritical = bCritical_;
		return *this;
	}

	CtrlInfo(CtrlInfo& c): 
		sOid(c.sOid), 
		bCritical(c.bCritical),
		sDesc(c.sDesc),
		sVal(c.sVal),
		bSvrCtrl(c.bSvrCtrl)
		{;}

};



/////////////////////////////////////////////////////////////////////////////
// ctrldlg dialog

class ctrldlg : public CDialog
{
private:
	// attributes
	CtrlInfo **ControlInfoList;
	CtrlInfo PreDefined[PREDEF_CTRL_COUNT];

	// members
	void InitPredefined(void);
	DWORD BerEncode(CtrlInfo* ci,  PBERVAL pBerVal);

public:
// Dialog Data
	enum CONTROLTYPE { CT_SVR=0, CT_CLNT, CT_INVALID };

// Construction
	ctrldlg(CWnd* pParent = NULL);   // standard constructor
	~ctrldlg();
	PLDAPControl *AllocCtrlList(enum ctrldlg::CONTROLTYPE CtrlType);
	virtual  BOOL OnInitDialog( );


	//{{AFX_DATA(ctrldlg)
	enum { IDD = IDD_CONTROLS };
	CComboBox	m_PredefCtrlCombo;
	CListBox	m_ActiveList;
	BOOL	m_bCritical;
	CString	m_CtrlVal;
	CString	m_description;
	int		m_SvrCtrl;
	CString	m_OID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ctrldlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(ctrldlg)
	afx_msg void OnCtrladd();
	afx_msg void OnCtrlDel();
	virtual void OnOK();
	afx_msg void OnSelchangePredefControl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CTRLDLG_H__1BD80CD8_E1A5_11D0_A9A8_0000F803AA83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ctrldlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctrldlg.cpp
//
//--------------------------------------------------------------------------

// ctrldlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include <winldap.h>
#include <ntldap.h>
#include <winber.h>
#include "ctrldlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ctrldlg dialog


ctrldlg::ctrldlg(CWnd* pParent /*=NULL*/)
	: CDialog(ctrldlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(ctrldlg)
	m_bCritical = FALSE;
	m_CtrlVal = _T("");
	m_description = _T("<unavailable>");
	m_SvrCtrl = 0;
	m_OID = _T("");
	//}}AFX_DATA_INIT

	INT i, cbCtrl = 0;
	CLdpApp *app = (CLdpApp*)AfxGetApp();
	CString str;

	InitPredefined();

	ControlInfoList = NULL;


   //
	// get control count
   //
	cbCtrl = app->GetProfileInt("Controls",  "ControlCount", 0);

   //
   // allocate controls
   //
	if(cbCtrl != 0){
		// alloc ControlInfoList
		ControlInfoList = new CtrlInfo*[cbCtrl+1];

		for(i = 0; i<cbCtrl; i++){

			str.Format("Oid_%d", i);
			CString sOid = app->GetProfileString("Controls",  str);
         if(sOid.IsEmpty()){
            i++;
            break;
         }
			CtrlInfo *c = ControlInfoList[i] = new CtrlInfo;
			c->sOid = sOid;
			str.Format("Critical_%d", i);
			c->bCritical = app->GetProfileInt("Controls",  str, (INT)FALSE);
			str.Format("Description_%d", i);
			c->sDesc = app->GetProfileString("Controls",  str);
			str.Format("Value_%d", i);
			c->sVal = app->GetProfileString("Controls",  str);
			str.Format("ServerControl_%d", i);
			c->bSvrCtrl = app->GetProfileInt("Controls",  str, (INT)TRUE);
		}
		ControlInfoList[i] = NULL;
	}


}

ctrldlg::~ctrldlg(){

	CString str;
	CLdpApp *app = (CLdpApp*)AfxGetApp();
   INT i;

	for(i=0; ControlInfoList != NULL && ControlInfoList[i] != NULL; i++);

   app->WriteProfileInt("Controls", "ControlCount", i);

	for(i=0; ControlInfoList != NULL && ControlInfoList[i] != NULL; i++){
		CtrlInfo *c = ControlInfoList[i];
		str.Format("Oid_%d", i);
		app->WriteProfileString("Controls",  str, c->sOid);
		str.Format("Critical_%d", i);
		app->WriteProfileInt("Controls",  str, c->bCritical);
		str.Format("Description_%d", i);
		app->WriteProfileString("Controls",  str, c->sDesc);
		str.Format("Value_%d", i);
		app->WriteProfileString("Controls",  str, c->sVal);
		str.Format("ServerControl_%d", i);
		app->WriteProfileInt("Controls",  str, c->bSvrCtrl);
		delete ControlInfoList[i];
	}
	delete ControlInfoList;
}





void ctrldlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ctrldlg)
	DDX_Control(pDX, IDC_PREDEF_CONTROL, m_PredefCtrlCombo);
	DDX_Control(pDX, IDC_ACTIVELIST, m_ActiveList);
	DDX_Check(pDX, IDC_CRITICAL, m_bCritical);
	DDX_Text(pDX, IDC_CTRLVAL, m_CtrlVal);
	DDX_Text(pDX, IDC_DESCRIPTION, m_description);
	DDX_Radio(pDX, IDC_SVRCTRL, m_SvrCtrl);
	DDX_Text(pDX, IDC_OID, m_OID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ctrldlg, CDialog)
	//{{AFX_MSG_MAP(ctrldlg)
	ON_BN_CLICKED(IDC_CTRLADD, OnCtrladd)
	ON_BN_CLICKED(IDC_CTRLRM, OnCtrlDel)
	ON_LBN_DBLCLK(IDC_ACTIVELIST, OnCtrlDel)
	ON_CBN_SELCHANGE(IDC_PREDEF_CONTROL, OnSelchangePredefControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ctrldlg message handlers

void ctrldlg::OnCtrladd()
{
	CString str;
	INT index;

	UpdateData(TRUE);

	if(m_OID.IsEmpty()){
		MessageBox("Please provide Object Identifier string", "Usage Error", MB_ICONHAND|MB_OK);
	}
	else{
		if(LB_ERR == (index = m_ActiveList.FindStringExact(0, m_OID))){
			index = m_ActiveList.AddString(m_OID);
			CtrlInfo *ci = new CtrlInfo(m_OID, m_CtrlVal, m_description,
										m_SvrCtrl == 0 ? TRUE:FALSE,
										m_bCritical);
			m_ActiveList.SetItemDataPtr(index, (PVOID)ci);
		}
		else{
			CtrlInfo *ci = (CtrlInfo *)m_ActiveList.GetItemDataPtr(index);

			ci->sVal = m_CtrlVal;
			ci->sDesc = m_description;
			ci->bSvrCtrl = m_SvrCtrl == 0 ? TRUE : FALSE;
			ci->bCritical = m_bCritical;
		}

	}
	UpdateData(FALSE);
	m_ActiveList.SetCurSel(index);
	
}






void ctrldlg::OnCtrlDel()
{
	UpdateData(TRUE);
	INT index = m_ActiveList.GetCurSel();
	if(index == LB_ERR){
		MessageBox("Please select Active Control to remove", "Usage Error",MB_ICONHAND|MB_OK);
	}
	else{
		CtrlInfo *ci = (CtrlInfo*)m_ActiveList.GetItemDataPtr(index);
		m_OID = ci->sOid;
		m_CtrlVal = ci->sVal;
		m_description = ci->sDesc;
		m_SvrCtrl = ci->bSvrCtrl ? 0 : 1;
		m_bCritical = ci->bCritical;
		delete ci;
		m_ActiveList.DeleteString(index);

		UpdateData(FALSE);
	}
}





PLDAPControl *ctrldlg::AllocCtrlList(enum CONTROLTYPE CtrlType){

	INT cbCtrl = 0, i=0,j=0;
	DWORD status;

	// count requested type controls
	for(i=0; ControlInfoList != NULL && ControlInfoList[i] != NULL; i++){
		CtrlInfo *ci = ControlInfoList[i];
		if((ci->bSvrCtrl && CtrlType == CT_SVR) ||
			(!ci->bSvrCtrl && CtrlType == CT_CLNT))
			cbCtrl++;

	}
	if(cbCtrl == 0)
		return NULL;

	// allocate & create controls
	PLDAPControl *ctrl = new PLDAPControl[cbCtrl+1];
	for(i=0, j=0; ControlInfoList != NULL && ControlInfoList[i] != NULL; i++){
		CtrlInfo *ci = ControlInfoList[i];
		if((ci->bSvrCtrl && CtrlType == CT_SVR) ||
			(!ci->bSvrCtrl && CtrlType == CT_CLNT)){


			ctrl[j] = new LDAPControl;
            if (!ctrl[j]) {
                // notify user & return as much as we can (mostly so that
                // we free it later).
                ::AfxMessageBox("Error: Out of memory", MB_ICONERROR);
                return ctrl;
            }
			ctrl[j]->ldctl_oid = new TCHAR[ci->sOid.GetLength()+1];
            if (!ctrl[j]->ldctl_oid) {
                // notify user & return as much as we can (mostly so that
                // we free it later).
                ::AfxMessageBox("Error: Out of memory", MB_ICONERROR);
                return ctrl;
            }
			strcpy(ctrl[j]->ldctl_oid, (PCHAR)LPCTSTR(ci->sOid));

            // check for ASQ control
            //
            if (strcmp (ctrl[j]->ldctl_oid, LDAP_SERVER_ASQ_OID) == 0) {
                BerElement* ber;
                BERVAL  *bval = NULL;
                DWORD rc;

                ber = ber_alloc_t(LBER_USE_DER);

                if (ber != NULL) {
                    rc = ber_printf(ber, "{o}", (PCHAR)LPCTSTR(ci->sVal), ci->sVal.GetLength() ); //

                    if ( rc == -1 ) {
                        ber_free(ber,1);
                        ctrl[j]->ldctl_value.bv_val = NULL;
                        ctrl[j]->ldctl_value.bv_len = 0;
                    }
                    else {
                        rc = ber_flatten(ber, &bval);

                        ctrl[j]->ldctl_value.bv_val = new char[bval->bv_len+1];
                        if (!ctrl[j]->ldctl_value.bv_val) {
                            // notify user & return as much as we can (mostly so that
                            // we free it later).
                            ::AfxMessageBox("Error: Out of memory", MB_ICONERROR);
                            ctrl[j]->ldctl_value.bv_val = NULL;
                            ctrl[j]->ldctl_value.bv_len = 0;
                            return ctrl;
                        }
                        memcpy (ctrl[j]->ldctl_value.bv_val, bval->bv_val, bval->bv_len);
                        ctrl[j]->ldctl_value.bv_len = bval->bv_len;

                        ber_free(ber,1);
                        ber_bvfree(bval);
                    }
                }
                else {
                    ctrl[j]->ldctl_value.bv_val = NULL;
                    ctrl[j]->ldctl_value.bv_len = 0;
                }
            }
            // Check for SD control
            //
            else if (strcmp (ctrl[j]->ldctl_oid, LDAP_SERVER_SD_FLAGS_OID) == 0) {
                BerElement* ber;
                BERVAL  *bval = NULL;
                DWORD rc;

                ber = ber_alloc_t(LBER_USE_DER);

                if (ber != NULL) {
                    rc = ber_printf(ber, "{i}", (atoi(LPCTSTR(ci->sVal)) &  0xF) ); //

                    if ( rc == -1 ) {
                        ber_free(ber,1);
                        ctrl[j]->ldctl_value.bv_val = NULL;
                        ctrl[j]->ldctl_value.bv_len = 0;
                    }
                    else {
                        rc = ber_flatten(ber, &bval);

                        ctrl[j]->ldctl_value.bv_val = new char[bval->bv_len+1];
                        if (!ctrl[j]->ldctl_value.bv_val) {
                            // notify user & return as much as we can (mostly so that
                            // we free it later).
                            ::AfxMessageBox("Error: Out of memory", MB_ICONERROR);
                            ctrl[j]->ldctl_value.bv_val = NULL;
                            ctrl[j]->ldctl_value.bv_len = 0;
                            return ctrl;
                        }
                        memcpy (ctrl[j]->ldctl_value.bv_val, bval->bv_val, bval->bv_len);
                        ctrl[j]->ldctl_value.bv_len = bval->bv_len;

                        ber_free(ber,1);
                        ber_bvfree(bval);
                    }
                }
                else {
                    ctrl[j]->ldctl_value.bv_val = NULL;
                    ctrl[j]->ldctl_value.bv_len = 0;
                }
            }
            // The rest of the controls are encoded the standard way
            //
            else {
                status = BerEncode(ci, &ctrl[j]->ldctl_value);
                if (status != ERROR_SUCCESS){
                    CString str;
                    str.Format("Error <%lu>: cannot encode control %s.", status, ci->sOid);
                    ::AfxMessageBox(str, MB_ICONERROR);
                }
            }

			ctrl[j]->ldctl_iscritical = (UCHAR)ci->bCritical;
			j++;
		}

	}
	ctrl[j] = NULL;

	return ctrl;
}




BOOL ctrldlg::OnInitDialog(){

	BOOL bRet = CDialog::OnInitDialog();

	for(INT i=0; ControlInfoList != NULL && ControlInfoList[i] != NULL; i++){
		CtrlInfo *ci = ControlInfoList[i];
		INT index = m_ActiveList.AddString(ci->sOid);
		m_ActiveList.SetItemDataPtr(index, (PVOID)ci);
	}
	delete ControlInfoList;
	ControlInfoList = NULL;

    for (int i=0; i<PREDEF_CTRL_COUNT; i++) {
        m_PredefCtrlCombo.AddString (PreDefined[i].sDesc);
    }

	m_PredefCtrlCombo.SetCurSel(0);
	
	if(m_ActiveList.GetCount() > 0)
		m_ActiveList.SetCurSel(0);

	return bRet;
}




void ctrldlg::OnOK()
{
	INT i;
	
	ControlInfoList = new CtrlInfo* [m_ActiveList.GetCount()+1];
	for(i=0; i< m_ActiveList.GetCount(); i++){
		ControlInfoList[i] = (CtrlInfo*)m_ActiveList.GetItemDataPtr(i);

	}
	ControlInfoList[i] = NULL;
	
	CDialog::OnOK();
}

void ctrldlg::OnSelchangePredefControl()
{
	INT iActive	= m_ActiveList.GetCurSel();	
	INT iPredef;
	iPredef = m_PredefCtrlCombo.GetCurSel();
	if(CB_ERR == iPredef){
		CString str;
		str.Format("Internal Error <%lu>", GetLastError());
		MessageBox(str, "Error", MB_ICONHAND|MB_OK);
	}
	else {
		CString oid = PreDefined[iPredef].sOid;
		if(LB_ERR == (iActive = m_ActiveList.FindStringExact(0, oid))){
			iActive = m_ActiveList.AddString(oid);
			CtrlInfo *ci = new CtrlInfo(PreDefined[iPredef]);
			m_ActiveList.SetItemDataPtr(iActive, (PVOID)ci);
		}
		else{
			CtrlInfo *ci = (CtrlInfo *)m_ActiveList.GetItemDataPtr(iActive);
			*ci = PreDefined[iPredef];
		}
	}
	UpdateData(FALSE);
	m_ActiveList.SetCurSel(iActive);	
}

void ctrldlg::InitPredefined()
{
	ASSERT(PREDEF_CTRL_COUNT == 12);

    int cnt=0;

	PreDefined[cnt++].Init(
		LDAP_SERVER_PERMISSIVE_MODIFY_OID,
		"",
		"Permit no-op modify");
	PreDefined[cnt++].Init(
		LDAP_SERVER_SHOW_DELETED_OID,
		"",
		"Return deleted objects");
	PreDefined[cnt++].Init(
		LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID,
		"<enter target path>",
		"Cross domain move");
	PreDefined[cnt++].Init(
		LDAP_SERVER_NOTIFICATION_OID,
		"",
		"Set change notifications");
	PreDefined[cnt++].Init(
		LDAP_SERVER_LAZY_COMMIT_OID,
		"",
		"Delayed write");
	PreDefined[cnt++].Init(
		LDAP_SERVER_SD_FLAGS_OID,
		"5",
		"Security Descriptor flags");
	PreDefined[cnt++].Init(
		LDAP_SERVER_TREE_DELETE_OID,
		"",
		"Subtree delete");
	//PreDefined[cnt++].Init(
	//	LDAP_SERVER_DIRSYNC_OID,
	//	"<unavailable now>",
	//	"DirSync control");
	PreDefined[cnt++].Init(
		LDAP_SERVER_VERIFY_NAME_OID,
		"<unavailable now>",
		"Verify name existance");
	PreDefined[cnt++].Init(
		LDAP_SERVER_DOMAIN_SCOPE_OID,
		"",
		"No referrals generated");
	PreDefined[cnt++].Init(
		LDAP_SERVER_SEARCH_OPTIONS_OID,
		"1",
		"Domain or phantom scope");
	PreDefined[cnt++].Init(
		"1.2.840.113556.1.4.970",
		"",
		"Search Stats");
	PreDefined[cnt++].Init(
		"1.2.840.113556.1.4.1504",
		"",
		"Attribute Scoped Query");
}

DWORD ctrldlg::BerEncode(CtrlInfo *ci, PBERVAL pBerVal)
{

    BerElement *pBer = NULL;
	PBERVAL pBerTemp = NULL;
	DWORD status;
	BOOL fFlatten=FALSE;

    pBer = ber_alloc_t(LBER_USE_DER);
    if (!pBer) {
        return STATUS_NO_MEMORY;
    }

        if ( ci->sOid == CString(LDAP_SERVER_DIRSYNC_OID) ){
		if (ber_printf(pBer, "{iio}", 0, 1048576, NULL, 0) == -1) {
			status = STATUS_INVALID_PARAMETER;
			goto error;
		}
		fFlatten=TRUE;
	}
	else if ( ci->sOid == CString(LDAP_SERVER_VERIFY_NAME_OID) ){
		if (ber_printf(pBer, "{is}", 0, LPCTSTR(ci->sVal)) == -1) {
			status = STATUS_INVALID_PARAMETER;
			goto error;
		}
		fFlatten=TRUE;
	}
	else if ( ci->sOid == CString(LDAP_SERVER_SEARCH_OPTIONS_OID) ){
		if (ber_printf(pBer, "{i}", atoi(LPCTSTR(ci->sVal))) == -1) {
			status = STATUS_INVALID_PARAMETER;
			goto error;
		}
		fFlatten=TRUE;
	}
		


    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (fFlatten) {
		if (ber_flatten(pBer, &pBerTemp) != 0) {
			status = STATUS_INVALID_PARAMETER;
			goto error;
		}
		if(pBerTemp){
			pBerVal->bv_val = new char[pBerTemp->bv_len];
			CopyMemory(pBerVal->bv_val, pBerTemp->bv_val, pBerTemp->bv_len);
			pBerVal->bv_len = pBerTemp->bv_len;
			ber_bvfree(pBerTemp);
		}

    }
	else{
		if(ci->sVal.IsEmpty()){
			pBerVal->bv_val = NULL;
			pBerVal->bv_len = 0;
		}
		else{
			pBerVal->bv_val = new char[ci->sVal.GetLength()+1];
			strcpy(pBerVal->bv_val, (PCHAR)LPCTSTR(ci->sVal));
			pBerVal->bv_len = ci->sVal.GetLength()+1;
                        AfxMessageBox(pBerVal->bv_val);
		}
	}

    status = ERROR_SUCCESS;

error:
    if (pBer) {
        ber_free(pBer,1);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\deldlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       deldlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// DelDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "DelDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DelDlg dialog


DelDlg::DelDlg(CWnd* pParent /*=NULL*/)
	: CDialog(DelDlg::IDD, pParent)
{
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	//{{AFX_DATA_INIT(DelDlg)
	m_Dn = _T("");
	m_Sync = TRUE;
	m_Recursive = FALSE;
	m_bExtended = FALSE;
	//}}AFX_DATA_INIT

	m_Dn = app->GetProfileString("Operations", "DeleteDN", m_Dn);
	m_Sync = app->GetProfileInt("Operations", "DeleteSync", m_Sync);
	m_Recursive = app->GetProfileInt("Operations", "DeleteRecursive", m_Recursive);
	m_bExtended = app->GetProfileInt("Operations", "DeleteExtended", m_bExtended);
}



DelDlg::~DelDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileString("Operations", "DeleteDN", m_Dn);
	app->WriteProfileInt("Operations", "DeleteSync", m_Sync);
	app->WriteProfileInt("Operations", "DeleteRecursive", m_Recursive);
	app->WriteProfileInt("Operations", "DeleteExtended", m_bExtended);
}



void DelDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DelDlg)
	DDX_Text(pDX, IDC_DELDN, m_Dn);
	DDX_Check(pDX, IDC_DEL_SYNC, m_Sync);
	DDX_Check(pDX, IDC_RECURSIVE, m_Recursive);
	DDX_Check(pDX, IDC_DEL_EXTENDED, m_bExtended);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DelDlg, CDialog)
	//{{AFX_MSG_MAP(DelDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DelDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\dstree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dstree.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// DSTree.cpp : implementation file
//


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDSTree

#include "stdafx.h"
#include "DSTree.h"
#include "ldp.h"
#include "ldpdoc.h"




#define DEF_ROOT        _T("Invalid base context")
#define NO_CHILDREN     _T("No children")


IMPLEMENT_DYNCREATE(CDSTree, CTreeView)

CDSTree::CDSTree()
{
    m_dn.Empty();
    m_bContextActivated = FALSE;

}

CDSTree::~CDSTree()
{
}


BEGIN_MESSAGE_MAP(CDSTree, CTreeView)
    //{{AFX_MSG_MAP(CDSTree)
    ON_WM_LBUTTONDBLCLK()
    //}}AFX_MSG_MAP
    ON_WM_RBUTTONDOWN()
    ON_WM_CONTEXTMENU ()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDSTree drawing

void CDSTree::OnDraw(CDC* pDC)
{


}

/////////////////////////////////////////////////////////////////////////////
// CDSTree diagnostics

#ifdef _DEBUG
void CDSTree::AssertValid() const
{
    CTreeView::AssertValid();
}

void CDSTree::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDSTree message handlers



void CDSTree::BuildTree(void){

    CLdpDoc *pDoc = (CLdpDoc*)GetDocument();
    CTreeCtrl& tree = GetTreeCtrl();
    CString base = pDoc->m_TreeViewDlg->m_BaseDn;


    base = (!base.IsEmpty()) ? base :
            (!pDoc->DefaultContext.IsEmpty()) ? pDoc->DefaultContext :
            DEF_ROOT;

    if(pDoc->bConnected){
        //
        // delete all prev & init
        //
        HTREEITEM currItem;

        tree.DeleteAllItems();
        currItem = tree.InsertItem(base);

        ExpandBase(currItem, base);

    }
}


void CDSTree::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    BuildTree();


}




void CDSTree::OnInitialUpdate()
{
//  CTreeView::OnInitialUpdate();

}





BOOL CDSTree::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |= TVS_HASLINES
                | TVS_LINESATROOT
                | TVS_HASBUTTONS
                | TVS_SHOWSELALWAYS;


    return CTreeView::PreCreateWindow(cs);
}






void CDSTree::OnLButtonDblClk(UINT nFlags, CPoint point)
{

    CTreeCtrl& tree = GetTreeCtrl();

    HTREEITEM currItem = tree.GetSelectedItem();
    CString base = tree.GetItemText(currItem);

    if(tree.ItemHasChildren(currItem)){

        HTREEITEM item, nxt;
        item = tree.GetChildItem(currItem);
        while(item != NULL){
            nxt = tree.GetNextSiblingItem(item);
            tree.DeleteItem(item);
            item = nxt;
        }
    }

    ExpandBase(currItem, base);

    CTreeView::OnLButtonDblClk(nFlags, point);
}


void CDSTree::OnRButtonDown(UINT nFlags, CPoint point)
{

    CTreeCtrl& tree = GetTreeCtrl();


    // if we're on an item, select it, translate point & call context menu function.
    // also set active dn string.
    UINT uFlag=0;
    HTREEITEM currItem = tree.HitTest(point, &uFlag);
    if( uFlag == TVHT_ONITEM ||
        uFlag == TVHT_ONITEMBUTTON ||
        uFlag == TVHT_ONITEMICON ||
        uFlag == TVHT_ONITEMINDENT ||
        uFlag == TVHT_ONITEMLABEL){

        if(tree.SelectItem(currItem)){
            m_dn = tree.GetItemText(currItem);
            CPoint local = point;
            ClientToScreen(&local);
            OnContextMenu(this, local);
        }
    }
}





void CDSTree::ExpandBase(HTREEITEM item, CString strBase)
{

    CLdpDoc *pDoc = (CLdpDoc*)GetDocument();
    CTreeCtrl& tree = GetTreeCtrl();
    LDAPMessage *res = NULL;
    LDAPMessage *nxt;
    char *dn=NULL;
    CString str;
    char *attrs[2] = { "msDS-Approx-Immed-Subordinates", NULL };
    char *defAttrs[1] = { NULL };
    char *attr;
    void *ptr;
    LDAP_BERVAL **bval = NULL;
    ULONG err;
    long count = 0;

    //
    // start search
    //

    if(strBase == DEF_ROOT)
        pDoc->Out(_T("Please use View/Tree dialog to initialize naming context"));
    else if(!pDoc->bConnected){
      AfxMessageBox(_T("Ldap connection disconnected. Please re-connect."));
    }
    else if (strBase != NO_CHILDREN){

        str.Format("Expanding base '%s'...", strBase);
        pDoc->Out(str);

        if (pDoc->bServerVLVcapable && pDoc->m_GenOptDlg->m_ContBrowse) {

            BeginWaitCursor();
            err = ldap_search_s(pDoc->hLdap,
                                      (PCHAR)LPCTSTR(strBase),
                                      LDAP_SCOPE_BASE,
                                      _T("objectClass=*"),
                                      attrs,
                                      FALSE,
                                      &res);

            if(err != LDAP_SUCCESS){
                str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
                pDoc->Out(str);
            }

            LDAPMessage *baseEntry;
            char **val;
            baseEntry = ldap_first_entry(pDoc->hLdap, res);

            val = ldap_get_values(pDoc->hLdap, baseEntry, "msDS-Approx-Immed-Subordinates");
            if(0 < ldap_count_values(val)) {
                count = atol (val[0]);
            }
            ldap_value_free(val);

            ldap_msgfree(res);
            EndWaitCursor();

            if (count > pDoc->m_GenOptDlg->m_ContThresh) {
                pDoc->Out("Using VLV Dialog to show results");
                pDoc->ShowVLVDialog (LPCTSTR (strBase), TRUE);
                return;
            }
        }

        BeginWaitCursor();
        err = ldap_search_s(pDoc->hLdap,
                                  (PCHAR)LPCTSTR(strBase),
                                  LDAP_SCOPE_ONELEVEL,
                                  _T("objectClass=*"),
                                  defAttrs,
                                  FALSE,
                                  &res);

        if(err != LDAP_SUCCESS){
            str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
            pDoc->Out(str);
        }

        BOOL bnoItems = TRUE;
        for(nxt = ldap_first_entry(pDoc->hLdap, res);
            nxt != NULL;
            nxt = ldap_next_entry(pDoc->hLdap, nxt)){

                dn = ldap_get_dn(pDoc->hLdap, nxt);

                tree.InsertItem(dn, item);
                bnoItems = FALSE;


        }


        if(bnoItems)
            tree.InsertItem(NO_CHILDREN, item);

        ldap_msgfree(res);

        //
        // Show base entry values
        //
        err = ldap_search_s(pDoc->hLdap,
                                  (PCHAR)LPCTSTR(strBase),
                                  LDAP_SCOPE_BASE,
                                  _T("objectClass=*"),
                                  NULL,
                                  FALSE,
                                  &res);
        pDoc->DisplaySearchResults(res);

        EndWaitCursor();

    }
}






void CDSTree::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
    // make sure window is active
    GetParentFrame()->ActivateFrame();


    CPoint local = point;
    ScreenToClient(&local);

    CMenu menu;
    if (menu.LoadMenu(IDR_TREE_CONTEXT)){
       CMenu* pContextMenu = menu.GetSubMenu(0);
       ASSERT(pContextMenu!= NULL);

       SetContextActivation(TRUE);
       pContextMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                              point.x, point.y,
                              AfxGetMainWnd()); // use main window for cmds
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\compdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       compdlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// CompDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCompDlg dialog

class CCompDlg : public CDialog
{
// Construction
public:
	CCompDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCompDlg)
	enum { IDD = IDD_COMPARE };
	CString	m_attr;
	CString	m_dn;
	CString	m_val;
	BOOL	m_sync;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCompDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:


	virtual void OnCancel();
	virtual void OnOK()				{	OnCompRun(); }
	// Generated message map functions
	//{{AFX_MSG(CCompDlg)
	afx_msg void OnCompRun();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\deldlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       deldlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// DelDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DelDlg dialog

class DelDlg : public CDialog
{
// Construction
public:
	DelDlg(CWnd* pParent = NULL);   // standard constructor
	~DelDlg();

// Dialog Data
	//{{AFX_DATA(DelDlg)
	enum { IDD = IDD_DELETE };
	CString	m_Dn;
	BOOL	m_Sync;
	BOOL	m_Recursive;
	BOOL	m_bExtended;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DelDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DelDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\dbgdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

/* DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE   */
/* Not used anymore by LDAP development. Taked out of ldp UI. Left for reference and  */
/* in case they ever want to revive debugging on this                                 */
/* DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE DEADCODE   */


// DbgDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDbgDlg dialog

// Custom debug flags from \nt\private\ds\src\ldap\client\debug.h
#define DEBUG_TRACE1              0x00000001
#define DEBUG_TRACE2              0x00000002
#define DEBUG_REFCNT              0x00000004
#define DEBUG_HEAP                0x00000008

#define DEBUG_UNUSED10            0x00000010
#define DEBUG_UNUSED20            0x00000020
#define DEBUG_SPEWSEARCH          0x00000040
#define DEBUG_SERVERDOWN          0x00000080

#define DEBUG_CONNECT             0x00000100
#define DEBUG_RECONNECT           0x00000200
#define DEBUG_RECEIVEDATA         0x00000400
#define DEBUG_PING                0x00000800

#define DEBUG_EOM                 0x00001000
#define DEBUG_BER                 0x00002000
#define DEBUG_OUTMEMORY           0x00004000
#define DEBUG_CONTROLS            0x00008000

#define DEBUG_HANDLES             0x00010000
#define DEBUG_CLDAP               0x00020000
#define DEBUG_FILTER              0x00040000
#define DEBUG_BIND                0x00080000

#define DEBUG_NETWORK_ERRORS      0x00100000
#define DEBUG_SCRATCH             0x00200000
#define DEBUG_PARSE               0x00400000
#define DEBUG_REFERRALS           0x00800000

#define DEBUG_SEARCH              0x01000000
#define DEBUG_REQUEST             0x02000000
#define DEBUG_CONNECTION          0x04000000
#define DEBUG_INIT_TERM           0x08000000

#define DEBUG_API_ERRORS          0x10000000
#define DEBUG_STOP_ON_ERRORS      0x20000000 /* If set, stop on internal errs */
#define DEBUG_ERRORS2             0x40000000
#define DEBUG_ERRORS              0x80000000

// left for back compatibility
#define DEBUG_TDI                 0x00400000




class CDbgDlg : public CDialog
{
// Construction
public:
	CDbgDlg(CWnd* pParent = NULL);   // standard constructor
	~CDbgDlg();

// Dialog Data
	//{{AFX_DATA(CDbgDlg)
	enum { IDD = IDD_DBGFLAGS };
	BOOL	m_api_err;
	BOOL	m_bind;
	BOOL	m_conn;
	BOOL	m_err;
	BOOL	m_err2;
	BOOL	m_filter;
	BOOL	m_init_term;
	BOOL	m_net_err;
	BOOL	m_ref;
	BOOL	m_req;
	BOOL	m_scratch;
	BOOL	m_srch;
	BOOL	m_tdi;
	BOOL	m_stop_on_err;
	//}}AFX_DATA

	ULONG ulDbgFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDbgDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void OrFlags()		{
#ifdef WINLDAP
			ulDbgFlags = (m_api_err	? DEBUG_API_ERRORS : 0) |
						 (m_bind		? DEBUG_BIND : 0) |
						 (m_conn		? DEBUG_CONNECTION : 0) |
						 (m_err		? DEBUG_ERRORS : 0) |
						 (m_err2		? DEBUG_ERRORS2 : 0) |
						 (m_filter	? DEBUG_FILTER : 0) |
						 (m_init_term? DEBUG_INIT_TERM: 0) |
						 (m_net_err	? DEBUG_NETWORK_ERRORS : 0) |
						 (m_ref		? DEBUG_REFERRALS: 0) |
						 (m_req		? DEBUG_REQUEST: 0) |
						 (m_scratch	? DEBUG_SCRATCH: 0) |
						 (m_srch		? DEBUG_SEARCH: 0) |
						 (m_tdi		? DEBUG_TDI: 0) |
						 (m_stop_on_err ? DEBUG_STOP_ON_ERRORS : 0);
#else
			ulDbgFlags = 0;
#endif
	}

	// Generated message map functions
	//{{AFX_MSG(CDbgDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\dstree.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dstree.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// DSTree.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDSTree view


#ifndef DSTREE_H
#define DSTREE_H




class CDSTree : public CTreeView
{

	CString m_dn;
	BOOL m_bContextActivated;
protected:
	CDSTree();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDSTree)

// Attributes
public:
	void ExpandBase(HTREEITEM item, CString strBase);

// Operations
public:
	void BuildTree(void);
	CString GetDn(void)   { return m_dn; }
	void SetContextActivation(BOOL bFlag=TRUE) {
		// sets the state w/ default TRUE
		m_bContextActivated = bFlag;
	}
	BOOL GetContextActivation(void) {
		// sets & returns the state w/ default TRUE
		return m_bContextActivated;
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDSTree)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDSTree();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CDSTree)
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnContextMenu(CWnd* /*pWnd*/, CPoint point);
	DECLARE_MESSAGE_MAP()
};



#endif

/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\enttree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       enttree.cpp
//
//--------------------------------------------------------------------------

// EntTree.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "EntTree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG_MEMLEAK
#include <crtdbg.h>
#endif


/////////////////////////////////////////////////////////////////////////////
// CEntTree dialog
#define NO_CHILDREN		_T("No children")
#define NO_SERVERS		_T("No Servers")
#define NO_CONFIG		_T("Invalid Configuration")

// index of ImageList entries
#define IDX_COMPUTER        0
#define IDX_DOMAIN          1
#define IDX_ERROR           2

#define TIME_EVENT			5

// global file vars //
#ifdef _DEBUG_MEMLEAK
   _CrtMemState et_s1, et_s2, et_s3;      // detect mem leaks
#endif

CEntTree::CEntTree(CWnd* pParent /*=NULL*/)
	: CDialog(CEntTree::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEntTree)
	m_nRefreshRate = 0;
	//}}AFX_DATA_INIT
	m_nOldRefreshRate=0;
   ld=NULL;
   m_nTimer=0;
   pCfg = NULL;
   pTreeImageList = NULL;
}

CEntTree::~CEntTree(){
   delete pCfg;
	delete pTreeImageList;
}

void CEntTree::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEntTree)
	DDX_Control(pDX, IDC_LIVEENT_TREE, m_TreeCtrl);
	DDX_Text(pDX, IDC_AUTO_SEC, m_nRefreshRate);
	DDV_MinMaxUInt(pDX, m_nRefreshRate, 0, 86400);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEntTree, CDialog)
	//{{AFX_MSG_MAP(CEntTree)
	ON_BN_CLICKED(IDREFRESH, OnRefresh)
	//}}AFX_MSG_MAP
	ON_WM_TIMER()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEntTree message handlers

void CEntTree::OnRefresh()
{
   HTREEITEM currItem, currSvrItem;
	TV_ITEM tv;
	BOOL bStatus = FALSE;

	if(pCfg){
		delete pCfg;

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&et_s2);
   if ( _CrtMemDifference( &et_s3, &et_s1, &et_s2 ) ){

    OutputDebugString("*** _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &et_s3 );
    _CrtMemDumpAllObjectsSince(&et_s3);
   }
   ASSERT(_CrtCheckMemory());
#endif
   }

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&et_s1);
#endif


	BeginWaitCursor();
		pCfg = new ConfigStore(ld);

        m_TreeCtrl.DeleteAllItems();

        if(!pCfg){
            currItem = MyInsertItem(NO_CONFIG, IDX_ERROR);

        }
        else if(!pCfg->valid()){
            currItem = MyInsertItem(NO_CONFIG, IDX_ERROR);
        }
        else{
           //
           // find enterprise root & call recursively
           //
           CString str;
           HTREEITEM currItem;
           vector<DomainInfo*> Dmns = pCfg->GetDomainList();
           if(Dmns.empty()){
              currItem = MyInsertItem(NO_CHILDREN, IDX_ERROR);
           }
           else{
              INT i,j;
              BOOL bFoundRoot=FALSE;
              for(i=0;i<Dmns.size(); i++){
                 if(Dmns[i]->GetTrustParent() == NULL){
                    //
                    // this is the official root domain
                    //
                    bFoundRoot=TRUE;

                    //
                    // insert domain item
                    //
                    currItem = MyInsertItem(Dmns[i]->GetFlatName(), IDX_DOMAIN);


                    //
                    // insert all servers
                    //
                    vector <ServerInfo*>Svrs = Dmns[i]->ServerList;
                    if(Svrs.empty()){
                       currSvrItem = MyInsertItem(NO_SERVERS, IDX_ERROR, currItem);
                    }
                    else{
                       // we have servers in this domain
                       for(j=0;j<Svrs.size();j++){
                         currSvrItem = MyInsertItem(Svrs[j]->m_lpszFlatName,
                                                    Svrs[j]->valid() ? IDX_COMPUTER : IDX_ERROR,
                                                    currItem);
                       }
                    }
                    //
                    // insert recursively
                    //
                    BuildTree(currItem, Dmns[i]->ChildDomainList);
                    m_TreeCtrl.Expand(currItem, TVE_EXPAND);
                 }
              }

              if(!bFoundRoot){
                 //
                 // could not find root
                 //
	            currItem = MyInsertItem(NO_CONFIG, IDX_ERROR);
                return;
              }

           }


        }
	EndWaitCursor();

	UpdateData(TRUE);

	if(m_nOldRefreshRate != m_nRefreshRate && m_nTimer != 0){
	// if refresh rate has changed, re-create timer.
		KillTimer(m_nTimer);
		m_nTimer = 0;
	}

	if(m_nTimer == 0 && m_nRefreshRate != 0){
	// if first time -- no timer & refresh is non-zero
	     m_nTimer =  SetTimer(TIME_EVENT, m_nRefreshRate*1000*60, NULL);
	 	 m_nOldRefreshRate= m_nRefreshRate;
	}


}

void CEntTree::OnCancel()
{
	delete pCfg, pCfg=NULL;

   CImageList	*pimagelist=NULL;

   if(m_nTimer != 0){
	KillTimer(m_nTimer);
   }

   pimagelist = m_TreeCtrl.GetImageList(TVSIL_NORMAL);
   pimagelist->DeleteImageList();	
   AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_ENT_TREE_END);
   DestroyWindow();

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&et_s2);
   if ( _CrtMemDifference( &et_s3, &et_s1, &et_s2 ) ){

    OutputDebugString("*** [EntTree.cpp] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &et_s3 );
    _CrtMemDumpAllObjectsSince(&et_s3);
   }
   ASSERT(_CrtCheckMemory());
#endif

}

HTREEITEM CEntTree::MyInsertItem(CString str, INT image, HTREEITEM hParent){

		TV_INSERTSTRUCT tvstruct;

      memset(&tvstruct, 0, sizeof(tvstruct));

		tvstruct.hParent = hParent;
		tvstruct.hInsertAfter = TVI_LAST;
		tvstruct.item.iImage = image;
		tvstruct.item.iSelectedImage = image;
		tvstruct.item.pszText = (LPTSTR)LPCTSTR(str);
		tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
		return m_TreeCtrl.InsertItem(&tvstruct);

}


void CEntTree::BuildTree(HTREEITEM rootItem, vector<DomainInfo*> Dmns){


	HTREEITEM currItem, currSvrItem;
	CString str;
	INT i,j;

	INT iMask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;

      if(Dmns.size() != 0){
         //
         // recurse down domain tree
         //
         for(i=0;i<Dmns.size(); i++){
            //
            // insert domain item
            //
            currItem = MyInsertItem(Dmns[i]->GetFlatName(), IDX_DOMAIN, rootItem);

            //
            // insert server list
            //
            vector <ServerInfo*>Svrs = Dmns[i]->ServerList;
            if(Svrs.empty()){
	           currSvrItem = MyInsertItem(NO_SERVERS, IDX_ERROR, currItem);
            }
            else{
               // we have servers in this domain
               for(j=0;j<Svrs.size();j++){
                  currSvrItem = MyInsertItem(Svrs[j]->m_lpszFlatName,
                                             Svrs[j]->valid() ? IDX_COMPUTER : IDX_ERROR,
                                             currItem);
               }
            }

            //
            // Insert rest of domains
            //
            BuildTree(currItem, Dmns[i]->ChildDomainList);

            m_TreeCtrl.Expand(currItem, TVE_EXPAND);

         }

      }

}




BOOL CEntTree::OnInitDialog( ){

	BOOL bRet= FALSE;
	
	bRet = CDialog::OnInitDialog();	
	// Create CImageList
	if(bRet){
	   BOOL bStatus=FALSE;
	   // create image list
	   pTreeImageList = new CImageList;
	   bStatus = pTreeImageList->Create(16, 16, FALSE, 3, 3);
	   ASSERT (bStatus);
	   // Load CImageList
	   CBitmap *pImage= new CBitmap;

	   pImage->LoadBitmap(IDB_COMP1);
	   pTreeImageList->Add(pImage, (COLORREF)0L);
	   pImage->DeleteObject();

	   pImage->LoadBitmap(IDB_DOMAIN);
	   pTreeImageList->Add(pImage, (COLORREF)0L);
	   pImage->DeleteObject();

	   pImage->LoadBitmap(IDB_TREE_ERROR);
	   pTreeImageList->Add(pImage, (COLORREF)0L);
	   pImage->DeleteObject();

	   delete pImage, pImage = NULL;

	   // set tree ctrl image list
	   m_TreeCtrl.SetImageList(pTreeImageList,TVSIL_NORMAL);


	}
	return bRet;
}



afx_msg void CEntTree::OnTimer(UINT nIDEvent)
{
	if(nIDEvent == TIME_EVENT)
		OnRefresh();
    CWnd::OnTimer(nIDEvent);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\enttree.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       enttree.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_ENTTREE_H__D52C60B9_BF68_11D1_941A_0000F803AA83__INCLUDED_)
#define AFX_ENTTREE_H__D52C60B9_BF68_11D1_941A_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EntTree.h : header file
//


#include "cfgstore.hxx"

/////////////////////////////////////////////////////////////////////////////
// CEntTree dialog

class CEntTree : public CDialog
{
// Construction

	ConfigStore *pCfg;
	LDAP *ld;
   CImageList *pTreeImageList;
   UINT m_nTimer;

   HTREEITEM MyInsertItem(CString str, INT image, HTREEITEM hParent = NULL);
   void BuildTree(HTREEITEM rootItem, vector<DomainInfo*> Dmns);

public:
	CEntTree(CWnd* pParent = NULL);   // standard constructor
	~CEntTree();
	void SetLd(LDAP *ld_)		{ ld = ld_; }

	virtual BOOL OnInitDialog( );


// Dialog Data
	//{{AFX_DATA(CEntTree)
	enum { IDD = IDD_ENTERPRISE_TREE };
	CTreeCtrl	m_TreeCtrl;
	UINT	m_nRefreshRate;
	//}}AFX_DATA
	UINT m_nOldRefreshRate;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEntTree)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	afx_msg void OnTimer(UINT nIDEvent);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEntTree)
	afx_msg void OnRefresh();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENTTREE_H__D52C60B9_BF68_11D1_941A_0000F803AA83__INCLUDED_)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\genopt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       genopt.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// GenOpt.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "winldap.h"
#include "GenOpt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenOpt dialog


CGenOpt::CGenOpt(CWnd* pParent /*=NULL*/)
	: CDialog(CGenOpt::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGenOpt)
	m_DnProc = 0;
	m_ValProc = STRING_VAL_PROC;
	m_initTree = TRUE;
	m_Version = 1;
	m_LineSize = MAXSTR;
	m_PageSize = 512;
	m_ContThresh = 100;
	m_ContBrowse = FALSE;
	//}}AFX_DATA_INIT

	bVerUI = TRUE;
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	m_DnProc = app->GetProfileInt("General",  "DNProcessing", m_DnProc);
	m_ValProc = app->GetProfileInt("General",  "ValProcessing", m_ValProc);
	m_initTree = app->GetProfileInt("General",  "InitTreeView", m_initTree);
	m_Version = app->GetProfileInt("General",  "LdapVersion", m_Version);
	m_LineSize = app->GetProfileInt("General",  "BufferLineSize", m_LineSize);
	m_PageSize = app->GetProfileInt("General",  "BufferPageSize", m_PageSize);
    
    m_ContThresh = app->GetProfileInt("General",  "ContainerThreshold", m_ContThresh);
    m_ContBrowse = app->GetProfileInt("General",  "ContainerBrowse", m_ContBrowse);
}




CGenOpt::~CGenOpt(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("General",  "DNProcessing", m_DnProc);
	app->WriteProfileInt("General",  "ValProcessing", m_ValProc);
	app->WriteProfileInt("General",  "InitTreeView", m_initTree);
	app->WriteProfileInt("General",  "LdapVersion", m_Version);
	app->WriteProfileInt("General",  "BufferLineSize", m_LineSize);
	app->WriteProfileInt("General",  "BufferPageSize", m_PageSize);
    app->WriteProfileInt("General",  "ContainerThreshold", m_ContThresh);
    app->WriteProfileInt("General",  "ContainerBrowse", m_ContBrowse);
}



void CGenOpt::DoDataExchange(CDataExchange* pDX)
{

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGenOpt)
	DDX_Radio(pDX, IDC_DN_NONE, m_DnProc);
	DDX_Radio(pDX, IDC_BER, m_ValProc);
	DDX_Check(pDX, IDC_INIT_TREE, m_initTree);
	DDX_Radio(pDX, IDC_VER2, m_Version);
	DDX_Text(pDX, IDC_LINESIZE, m_LineSize);
	DDV_MinMaxInt(pDX, m_LineSize, 80, 65535);
	DDX_Text(pDX, IDC_PAGESIZE, m_PageSize);
	DDV_MinMaxInt(pDX, m_PageSize, 16, 65535);
	DDX_Text(pDX, IDC_CONT_THRESHOLD, m_ContThresh);
	DDX_Check(pDX, IDC_BROWSE_CONT, m_ContBrowse);
	//}}AFX_DATA_MAP
}




BOOL CGenOpt::OnInitDialog(){
	BOOL bRet = CDialog::OnInitDialog();
	GetDlgItem(IDC_VER2)->EnableWindow(bVerUI);
	GetDlgItem(IDC_VER3)->EnableWindow(bVerUI);
	return bRet;
}




BEGIN_MESSAGE_MAP(CGenOpt, CDialog)
	//{{AFX_MSG_MAP(CGenOpt)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGenOpt message handlers


INT CGenOpt::MaxLineSize()
{

	return m_LineSize;
}

INT CGenOpt::MaxPageSize()
{
	return m_PageSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\genopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       genopt.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// GenOpt.h : header file
//



#define STRING_VAL_PROC 1
#define BER_VAL_PROC 0


/////////////////////////////////////////////////////////////////////////////
// CGenOpt dialog

class CGenOpt : public CDialog
{
// Construction
	BOOL bVerUI;
public:
	INT MaxPageSize(void);
	INT MaxLineSize(void);
	CGenOpt(CWnd* pParent = NULL);   // standard constructor
	~CGenOpt();

	INT GetLdapVer(void)		{ return m_Version == 0 ? LDAP_VERSION2 : LDAP_VERSION3; }
	void DisableVersionUI(void)	{ bVerUI = FALSE; }
	void EnableVersionUI(void)	{ bVerUI = TRUE; }
	virtual BOOL OnInitDialog();

// Dialog Data
	enum { GEN_DN_NONE=0, GEN_DN_EXPLD, GEN_DN_NOTYPE, GEN_DN_UFN };
	enum {GEN_VAL_BER=0, GEN_VAL_STR };

	//{{AFX_DATA(CGenOpt)
	enum { IDD = IDD_GENOPT };
	int		m_DnProc;
	int		m_ValProc;
	BOOL	m_initTree;
	int		m_Version;
	int		m_LineSize;
	int		m_PageSize;
	UINT	m_ContThresh;
	BOOL	m_ContBrowse;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGenOpt)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenOpt)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ldp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldp.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// Ldp.h : main header file for the LDP application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLdpApp:
// See Ldp.cpp for the implementation of this class
//

class CLdpApp : public CWinApp
{
public:
	CLdpApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLdpApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CLdpApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ldp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldp.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// Ldp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Ldp.h"

#include "LdpDoc.h"
#include "MainFrm.h"
#include "LdpView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG_MEMLEAK
#include <crtdbg.h>
#endif


/////////////////////////////////////////////////////////////////////////////
// CLdpApp

BEGIN_MESSAGE_MAP(CLdpApp, CWinApp)
	//{{AFX_MSG_MAP(CLdpApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLdpApp construction

CLdpApp::CLdpApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLdpApp object

CLdpApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLdpApp initialization

BOOL CLdpApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CLdpDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CLdpView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;


#ifdef _DEBUG_MEMLEAK
//   _CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF);
   _CrtSetDbgFlag(_CRTDBG_CHECK_ALWAYS_DF |
                  _CRTDBG_CHECK_CRT_DF |
                  _CRTDBG_LEAK_CHECK_DF |
                  _CRTDBG_ALLOC_MEM_DF |
                  _CRTDBG_DELAY_FREE_MEM_DF);
#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CLdpApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CLdpApp commands

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\extopdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       extopdlg.cpp
//
//--------------------------------------------------------------------------

// ExtOpDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "ExtOpDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ExtOpDlg dialog


ExtOpDlg::ExtOpDlg(CWnd* pParent /*=NULL*/)
	: CDialog(ExtOpDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(ExtOpDlg)
	m_strData = _T("");
	m_strOid = _T("");
	//}}AFX_DATA_INIT
}


void ExtOpDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ExtOpDlg)
	DDX_Text(pDX, IDC_DATA, m_strData);
	DDX_Text(pDX, IDC_OID, m_strOid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ExtOpDlg, CDialog)
	//{{AFX_MSG_MAP(ExtOpDlg)
	ON_BN_CLICKED(IDC_CTRL, OnCtrl)
	ON_BN_CLICKED(IDSEND, OnSend)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ExtOpDlg message handlers

void ExtOpDlg::OnCtrl() 
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_OPTIONS_CONTROLS);
	
}

void ExtOpDlg::OnSend() 
{
	UpdateData(TRUE);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_EXTOPGO);
}

void ExtOpDlg::OnCancel() 
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_EXTOPEND);
	DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\extopdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       extopdlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_EXTOPDLG_H__F993FFCE_0398_11D1_A9AF_0000F803AA83__INCLUDED_)
#define AFX_EXTOPDLG_H__F993FFCE_0398_11D1_A9AF_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ExtOpDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// ExtOpDlg dialog

class ExtOpDlg : public CDialog
{
// Construction
public:
	ExtOpDlg(CWnd* pParent = NULL);   // standard constructor
	virtual void OnOK()				{	OnSend(); }
// Dialog Data
	//{{AFX_DATA(ExtOpDlg)
	enum { IDD = IDD_EXT_OPT };
	CString	m_strData;
	CString	m_strOid;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ExtOpDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(ExtOpDlg)
	afx_msg void OnCtrl();
	afx_msg void OnSend();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXTOPDLG_H__F993FFCE_0398_11D1_A9AF_0000F803AA83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ldpdoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldpdoc.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : ldpdoc.cpp
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



// includes


#include "stdafx.h"


#include "Ldp.h"
#include "LdpDoc.h"
#include "LdpView.h"
#include "CnctDlg.h"
#include "MainFrm.h"
#include "string.h"
#include <rpc.h>            // for SEC_WINNT_AUTH_IDENTITY
#include <drs.h>
#include <mdglobal.h>
#include <ntldap.h>
#include <sddl.h>

extern "C" {
#include <dsutil.h>
}

#if(_WIN32_WINNT < 0x0500)

// Currently due to some MFC issues, even on a 5.0 system this is left as a 4.0

#undef _WIN32_WINNT

#define _WIN32_WINNT 0x500

#endif

#include <aclapi.h>         // for Security Stuff
#include <aclapip.h>         // for Security Stuff




#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif




//
// Server stat info
//
#define PARSE_THREADCOUNT           1
#define PARSE_CALLTIME              3
#define PARSE_RETURNED              5
#define PARSE_VISITED               6
#define PARSE_FILTER                7
#define PARSE_INDEXES               8

#define MAXSVRSTAT                  32


/////////////////////////////////////////////////////////////////////////////
// CLdpDoc
// Message maps

IMPLEMENT_DYNCREATE(CLdpDoc, CDocument)

BEGIN_MESSAGE_MAP(CLdpDoc, CDocument)
    //{{AFX_MSG_MAP(CLdpDoc)
    ON_COMMAND(ID_CONNECTION_BIND, OnConnectionBind)
    ON_COMMAND(ID_CONNECTION_CONNECT, OnConnectionConnect)
    ON_COMMAND(ID_CONNECTION_DISCONNECT, OnConnectionDisconnect)
    ON_COMMAND(ID_BROWSE_SEARCH, OnBrowseSearch)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_SEARCH, OnUpdateBrowseSearch)
    ON_COMMAND(ID_BROWSE_ADD, OnBrowseAdd)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_ADD, OnUpdateBrowseAdd)
    ON_COMMAND(ID_BROWSE_DELETE, OnBrowseDelete)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_DELETE, OnUpdateBrowseDelete)
    ON_COMMAND(ID_BROWSE_MODIFYRDN, OnBrowseModifyrdn)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_MODIFYRDN, OnUpdateBrowseModifyrdn)
    ON_COMMAND(ID_BROWSE_MODIFY, OnBrowseModify)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_MODIFY, OnUpdateBrowseModify)
    ON_COMMAND(ID_OPTIONS_SEARCH, OnOptionsSearch)
    ON_COMMAND(ID_BROWSE_PENDING, OnBrowsePending)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_PENDING, OnUpdateBrowsePending)
    ON_COMMAND(ID_OPTIONS_PEND, OnOptionsPend)
    ON_UPDATE_COMMAND_UI(ID_CONNECTION_CONNECT, OnUpdateConnectionConnect)
    ON_UPDATE_COMMAND_UI(ID_CONNECTION_DISCONNECT, OnUpdateConnectionDisconnect)
    ON_COMMAND(ID_VIEW_SOURCE, OnViewSource)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SOURCE, OnUpdateViewSource)
    ON_COMMAND(ID_OPTIONS_BIND, OnOptionsBind)
    ON_COMMAND(ID_OPTIONS_PROTECTIONS, OnOptionsProtections)
    ON_UPDATE_COMMAND_UI(ID_OPTIONS_PROTECTIONS, OnUpdateOptionsProtections)
    ON_COMMAND(ID_OPTIONS_GENERAL, OnOptionsGeneral)
    ON_COMMAND(ID_BROWSE_COMPARE, OnBrowseCompare)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_COMPARE, OnUpdateBrowseCompare)
    ON_COMMAND(ID_OPTIONS_DEBUG, OnOptionsDebug)
    ON_COMMAND(ID_VIEW_TREE, OnViewTree)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TREE, OnUpdateViewTree)
    ON_COMMAND(ID_OPTIONS_SERVEROPTIONS, OnOptionsServeroptions)
    ON_COMMAND(ID_OPTIONS_CONTROLS, OnOptionsControls)
    ON_COMMAND(ID_OPTIONS_SORTKEYS, OnOptionsSortkeys)
    ON_COMMAND(ID_OPTIONS_SETFONT, OnOptionsSetFont)
    ON_COMMAND(ID_BROWSE_SECURITY_SD, OnBrowseSecuritySd)
    ON_COMMAND(ID_BROWSE_SECURITY_EFFECTIVE, OnBrowseSecurityEffective)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_SECURITY_SD, OnUpdateBrowseSecuritySd)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_SECURITY_EFFECTIVE, OnUpdateBrowseSecurityEffective)
    ON_COMMAND(ID_BROWSE_REPLICATION_VIEWMETADATA, OnBrowseReplicationViewmetadata)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_REPLICATION_VIEWMETADATA, OnUpdateBrowseReplicationViewmetadata)
    ON_COMMAND(ID_BROWSE_EXTENDEDOP, OnBrowseExtendedop)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_EXTENDEDOP, OnUpdateBrowseExtendedop)
    ON_COMMAND(ID_VIEW_LIVEENTERPRISE, OnViewLiveEnterprise)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LIVEENTERPRISE, OnUpdateViewLiveEnterprise)
    ON_COMMAND(ID_BROWSE_VLVSEARCH, OnBrowseVlvsearch)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_VLVSEARCH, OnUpdateBrowseVlvsearch)
    ON_COMMAND(ID_EDIT_COPYDN, OnEditCopy)
    ON_COMMAND(ID_OPTIONS_START_TLS, OnOptionsStartTls)
    ON_COMMAND(ID_OPTIONS_STOP_TLS, OnOptionsStopTls)
    ON_COMMAND(ID_BROWSE_GetError, OnGetLastError)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_SRCHEND, OnSrchEnd)
    ON_COMMAND(ID_SRCHGO, OnSrchGo)
    ON_COMMAND(ID_ADDGO, OnAddGo)
    ON_COMMAND(ID_ADDEND, OnAddEnd)
    ON_COMMAND(ID_MODGO, OnModGo)
    ON_COMMAND(ID_MODEND, OnModEnd)
    ON_COMMAND(ID_MODRDNGO, OnModRdnGo)
    ON_COMMAND(ID_MODRDNEND, OnModRdnEnd)
    ON_COMMAND(ID_PENDEND, OnPendEnd)
    ON_COMMAND(ID_PROCPEND, OnProcPend)
    ON_COMMAND(ID_PENDANY, OnPendAny)
    ON_COMMAND(ID_PENDABANDON, OnPendAbandon)
    ON_COMMAND(ID_COMPGO, OnCompGo)
    ON_COMMAND(ID_COMPEND, OnCompEnd)
    ON_COMMAND(ID_BIND_OPT_OK, OnBindOptOK)
    ON_COMMAND(ID_SSPI_DOMAIN_SHORTCUT, OnSSPIDomainShortcut)
    ON_COMMAND(ID_EXTOPGO, OnExtOpGo)
    ON_COMMAND(ID_EXTOPEND, OnExtOpEnd)
    ON_COMMAND(ID_ENT_TREE_END, OnLiveEntTreeEnd)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLdpDoc construction/destruction

/*+++
Function   : CLdpDoc
Description: Constructor
Parameters :
Return     :
Remarks    : none.
---*/
CLdpDoc::CLdpDoc()
{

    CLdpApp *app = (CLdpApp*)AfxGetApp();

   SetSecurityPrivilege();
   //
   // registry
   //
    Svr = app->GetProfileString("Connection",  "Server");
    BindDn = app->GetProfileString("Connection",  "BindDn");
    BindPwd.Empty();
   //   BindPwd = app->GetProfileString("Connection",  "BindPwd");
    BindDomain = app->GetProfileString("Connection",  "BindDomain");

   //
   // init flags dialogs & params
   //
    hLdap = NULL;
    m_SrcMode = FALSE;
    m_bCnctless = FALSE;
    m_bProtect = TRUE;      // disabled in the UI. Forced TRUE forever.
    bConnected = FALSE;
    bSrch = FALSE;
    bAdd = FALSE;
    bLiveEnterprise = FALSE;
    bExtOp = FALSE;
    bMod = FALSE;
    bModRdn = FALSE;
    bPndDlg = FALSE;
    bCompDlg = FALSE;
    SearchDlg = new SrchDlg;
    m_EntTreeDlg = new CEntTree;
    m_AddDlg = new AddDlg;
    m_ModDlg = new ModDlg;
    m_ModRdnDlg = new ModRDNDlg;
    m_PndDlg = new PndDlg(&m_PendList);
    m_GenOptDlg = new CGenOpt;
    m_CompDlg = new CCompDlg;
    m_BndOpt = new CBndOpt;
    m_TreeViewDlg = new TreeVwDlg;
    m_CtrlDlg = new ctrldlg;
    m_SKDlg = new SortKDlg;
    m_ExtOpDlg = new ExtOpDlg;
    m_vlvDlg = NULL;

#ifdef WINLDAP
    ldap_set_dbg_flags(m_DbgDlg.ulDbgFlags);
#endif

   //
   // Initial search info struct
   //
    for(int i=0; i<MAXLIST; i++)
        SrchInfo.attrList[i] = NULL;


   //
   // setup default attributes to retrieve
   //
   const TCHAR pszDefaultAttrList[] = "objectClass;name;cn;ou;dc;hideFromAB;distinguishedName;description;canonicalName";


    SrchInfo.lTlimit = 0;
    SrchInfo.lSlimit = 0;
    SrchInfo.lToutSec = 0;
    SrchInfo.lToutMs = 0;
    SrchInfo.bChaseReferrals = FALSE;
    SrchInfo.bAttrOnly = FALSE;
    SrchInfo.fCall = CALL_SYNC;
    SrchInfo.lPageSize = 16;

    SrchInfo.fCall = app->GetProfileInt("Search_Operations",  "SearchSync", SrchInfo.fCall);
    SrchInfo.bAttrOnly = app->GetProfileInt("Search_Operations",  "SearchAttrOnly", SrchInfo.bAttrOnly );
    SrchInfo.bChaseReferrals = app->GetProfileInt("Search_Operations",  "ChaseReferrals", SrchInfo.bChaseReferrals);
    SrchInfo.lToutMs = app->GetProfileInt("Search_Operations",  "SearchToutMs", SrchInfo.lToutMs );
    SrchInfo.lToutSec = app->GetProfileInt("Search_Operations",  "SearchToutSec", SrchInfo.lToutSec );
    SrchInfo.lTlimit = app->GetProfileInt("Search_Operations",  "SearchTlimit", SrchInfo.lTlimit );
    SrchInfo.lSlimit = app->GetProfileInt("Search_Operations",  "SearchSlimit", SrchInfo.lSlimit );
    SrchInfo.lPageSize = app->GetProfileInt("Search_Operations",  "SearchPageSize", SrchInfo.lPageSize );
    LPTSTR pAttrList = _strdup(app->GetProfileString("Search_Operations",  "SearchAttrList", pszDefaultAttrList));

    for(i=0, SrchInfo.attrList[i] = strtok(pAttrList, ";");
       SrchInfo.attrList[i] != NULL;
       SrchInfo.attrList[++i] = strtok(NULL, ";"));

    SrchOptDlg.UpdateSrchInfo(SrchInfo, FALSE);
    hPage = NULL;
    bPagedMode = FALSE;

    bServerVLVcapable = FALSE;
    m_ServerSupportedControls = NULL;

    //
    // init pending info struct
    //
    PndInfo.All = TRUE;
    PndInfo.bBlock = TRUE;
    PndInfo.tv.tv_sec = 0;
    PndInfo.tv.tv_usec = 0;


    DefaultContext.Empty();

    //
    // more registry update (passed default settings)
    //
    m_bProtect = app->GetProfileInt("Environment",  "Protections", m_bProtect);
}








/*+++
Function   : ~CLdapDoc
Description: Destructor
Parameters :
Return     :
Remarks    : none.
---*/
CLdpDoc::~CLdpDoc()
{
    CLdpApp *app = (CLdpApp*)AfxGetApp();
    INT i=0;

   SetSecurityPrivilege(FALSE);
   //
   // register
   //
    app->WriteProfileString("Connection",  "Server", Svr);
    app->WriteProfileString("Connection",  "BindDn", BindDn);
//  app->WriteProfileString("Connection",  "BindPwd", BindPwd);
    app->WriteProfileString("Connection",  "BindDomain", BindDomain);
    m_bProtect = app->WriteProfileInt("Environment",  "Protections", m_bProtect);

    app->WriteProfileInt("Search_Operations",  "SearchSync", SrchInfo.fCall);
    app->WriteProfileInt("Search_Operations",  "SearchAttrOnly", SrchInfo.bAttrOnly );
    app->WriteProfileInt("Search_Operations",  "SearchToutMs", SrchInfo.lToutMs );
    app->WriteProfileInt("Search_Operations",  "SearchToutSec", SrchInfo.lToutSec );
    app->WriteProfileInt("Search_Operations",  "SearchTlimit", SrchInfo.lTlimit );
    app->WriteProfileInt("Search_Operations",  "SearchSlimit", SrchInfo.lSlimit );
    app->WriteProfileInt("Search_Operations",  "ChaseReferrals", SrchInfo.bChaseReferrals);
    app->WriteProfileInt("Search_Operations",  "SearchPageSize", SrchInfo.lPageSize);

    //
    // extract attribute list to write to ini file
    //
    INT cbAttrList=0;
    LPTSTR pAttrList = NULL;

    for(i=0; SrchInfo.attrList != NULL && SrchInfo.attrList[i] != NULL; i++){
        cbAttrList+= strlen(SrchInfo.attrList[i]) + 1;
    }
    if(cbAttrList != 0){

        pAttrList = new TCHAR[cbAttrList+1];
        strcpy(pAttrList, SrchInfo.attrList[0]);
        for(i=1; SrchInfo.attrList[i] != NULL; i++){
            pAttrList = strcat(pAttrList, ";");
            pAttrList = strcat(pAttrList, SrchInfo.attrList[i]);
        }
    }

    app->WriteProfileString("Search_Operations",  "SearchAttrList", !pAttrList?"":pAttrList);
    delete pAttrList;


    if(NULL != hLdap)
        ldap_unbind(hLdap);

   //
   // cleanup mem
   //
    delete SearchDlg;
    delete m_AddDlg;
    delete m_EntTreeDlg;
    delete m_ModDlg;
    delete m_ModRdnDlg;
    delete m_PndDlg;
    delete m_GenOptDlg;
    delete m_BndOpt;
    delete m_CompDlg;
    delete m_TreeViewDlg;
    delete m_CtrlDlg;
    delete m_SKDlg;
    delete m_ExtOpDlg;
    if (m_vlvDlg)
        delete m_vlvDlg;

    if(SrchInfo.attrList[0] != NULL)
        free(SrchInfo.attrList[0]);

}




BOOL CLdpDoc::SetSecurityPrivilege(BOOL bOn){


   HANDLE hToken;
   LUID seSecVal;
   TOKEN_PRIVILEGES tkp;
   BOOL bRet = FALSE;

   /* Retrieve a handle of the access token.           */

   if (OpenProcessToken(GetCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                        &hToken)) {

      if (LookupPrivilegeValue((LPSTR)NULL,
                                SE_SECURITY_NAME,
                                &seSecVal)) {

        tkp.PrivilegeCount = 1;
        tkp.Privileges[0].Luid = seSecVal;
        tkp.Privileges[0].Attributes = bOn? SE_PRIVILEGE_ENABLED: 0L;

        AdjustTokenPrivileges(hToken,
            FALSE,
            &tkp,
            sizeof(TOKEN_PRIVILEGES),
            (PTOKEN_PRIVILEGES) NULL,
            (PDWORD) NULL);

      }
        if (GetLastError() == ERROR_SUCCESS) {
            bRet =  TRUE;
        }

   }

   return bRet;
}







/*+++
Function   : OnNewDocument
Description: Automatic MFC code
Parameters :
Return     :
Remarks    : none.
---*/
BOOL CLdpDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

   //
   // set a clean buffer
   //
    ((CEditView*)m_viewList.GetHead())->SetWindowText(NULL);

    return TRUE;
}






/////////////////////////////////////////////////////////////////////////////
// CLdpDoc serialization

/*+++
Function   : Serialize
Description: Automatic MFC code
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::Serialize(CArchive& ar)
{
    // CEditView contains an edit control which handles all serialization
    ((CEditView*)m_viewList.GetHead())->SerializeRaw(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CLdpDoc diagnostics
/*+++
Functionis  : Diagnostics
Description: Automatic MFC Code
Parameters :
Return     :
Remarks    : none.
---*/

#ifdef _DEBUG
void CLdpDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CLdpDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG




//////////////////////////////////////////////////////
// Utilty functions



/*+++
Function   : Print
Description: Interface for text pane output
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::Print(CString str){


    POSITION pos;
    CView *pTmpVw;
    INT iLineSize=m_GenOptDlg->MaxLineSize();



    pos = GetFirstViewPosition();
    while(pos != NULL){

        pTmpVw = GetNextView(pos);
        if((CString)(pTmpVw->GetRuntimeClass()->m_lpszClassName) == _T("CLdpView")){
            CLdpView* pView = (CLdpView* )pTmpVw;
            if(str.GetLength() > iLineSize){
                CString tmp;
                tmp = str.GetBufferSetLength(iLineSize);
                tmp += "...";
                pView->Print(tmp);
            }
            else
                pView->Print(str);

            break;
        }
    }
}




/*+++
Function   : CodePrint
Description: Used for code generation
Parameters :
Return     :
Remarks    : unsupported anymore.
---*/

void CLdpDoc::CodePrint(CString str, int type){
    type &= ~CP_ONLY;
    switch (type){
            case CP_SRC:
                Print(str);
                break;
            case CP_CMT:
                Print(CString("// ") + str);
                break;
            case CP_PRN:
                Print(CString("\tprintf(\"") + str + _T("\");"));
                break;
            case CP_NON:
                break;
            default:
                AfxMessageBox("Unknown switch in CLdpDoc::CodePrint()");
    }
}



/*+++
Function   : Out
Description: Used for interfacing w/ text pane
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::Out(CString str, int type){

    if(m_SrcMode)
        CodePrint(str, type);
    else if(!(type & CP_ONLY))
                        Print(str);
}




/////////////////////////////////////////////////////////////////////////////
// CLdpDoc commands

/*+++
Function   : Cldp::OnConnectionBind
Description: response to UI bind request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnConnectionBind() {
    int res;
    CString str;
    LPTSTR dn, pwd, domain;
    ULONG ulMethod;
    SEC_WINNT_AUTH_IDENTITY AuthI;


    //
    // init dialog props
    //
    m_BindDlg.m_BindDn = BindDn;
    m_BindDlg.m_Pwd = BindPwd;
    m_BindDlg.m_Domain = BindDomain;

    //
    // execute dialog request
    //
    // sync SSPI domain checkbox w/ bind options
    OnBindOptOK();
    // Execute bind dialog
    if (IDOK == m_BindDlg.DoModal()) {

        //
        // sync dialog info
        //
        BindDn = m_BindDlg.m_BindDn;
        BindPwd = m_BindDlg.m_Pwd;
        BindDomain = m_BindDlg.m_Domain;

        ulMethod = m_BndOpt->GetAuthMethod();

        //
        // automatically connect if we're not connected & we're in auto mode.
        //
        if (NULL == hLdap && m_GenOptDlg->m_initTree) {

            Connect(Svr);
        }


        //
        // If we have a connection
        //
        BeginWaitCursor();


        if (NULL != hLdap || !m_bProtect) {
            //
            //   map bind dlg info into local:
            //     user, pwd, domain
            dn =  BindDn.IsEmpty()? NULL: (LPTSTR)LPCTSTR(BindDn);

            //
            // Password rules:
            //   - non-empty-- use what we have
            //   - empty pwd:
            //     - if user's name is NULL -->
            //         treat as currently logged on user (pwd == NULL)
            //     - otherwise
            //         treat as empty pwd for user.
            //
            //
            if ( !BindPwd.IsEmpty() ) {
                // non-empty password
                pwd = (LPTSTR)LPCTSTR(BindPwd);
            }
            else if ( !dn ) {
                // pwd is empty & user dn is empty
                // --> treat as currently logged on
                pwd = NULL;
            }
            else {
                // pwd is empty but user isn't NULL (treat as NULL pwd)
                pwd = _T("");
            }

            /* old pwd way. rm later
            // special case empty string ""
            if(!BindPwd.IsEmpty() && BindPwd == _T("\"\""))
                pwd = _T("");
            else
                pwd = BindPwd.IsEmpty()? NULL: (LPTSTR)LPCTSTR(BindPwd);
            */

            domain = m_BindDlg.m_Domain.IsEmpty()? NULL: (LPTSTR)LPCTSTR(m_BindDlg.m_Domain);

            if (m_BndOpt->m_API == CBndOpt::BND_SIMPLE_API) {
                //
                // Do a simple bind
                //
                if (!m_BndOpt->m_bSync) {
                    //
                    // Async simple bind
                    //

                    str.Format(_T("res = ldap_simple_bind(ld, '%s', <unavailable>); // v.%d"),
                        dn == NULL?_T("NULL"): dn,
                        m_GenOptDlg->GetLdapVer());
                    Out(str);


                    res = ldap_simple_bind(hLdap, dn, pwd);
                    if (res == -1) {
                        str.Format(_T("Error <%ld>: ldap_simple_bind() failed: %s"),
                            res, ldap_err2string(res));

                        Out(str, CP_CMT);
                    }
                    else {

                        //
                        // append to pending list
                        //
                        CPend pnd;
                        pnd.mID = res;
                        pnd.OpType = CPend::P_BIND;
                        pnd.ld = hLdap;
                        str.Format(_T("%4d: ldap_simple_bind: dn=\"%s\"."),
                            res,
                            dn == NULL ? _T("NULL") : dn);
                        pnd.strMsg = str;
                        m_PendList.AddTail(pnd);
                        m_PndDlg->Refresh(&m_PendList);
                    }
                }
                else {
                    //
                    // Sync simple
                    //
                    str.Format(_T("res = ldap_simple_bind_s(ld, '%s', <unavailable>); // v.%d"),
                        dn == NULL?_T("NULL"): dn,
                        m_GenOptDlg->GetLdapVer());
                    Out(str);
                    res = ldap_simple_bind_s(hLdap, dn, pwd);
                    if (res != LDAP_SUCCESS) {
                        str.Format(_T("Error <%ld>: ldap_simple_bind_s() failed: %s"),
                            res, ldap_err2string(res));

                        Out(str, CP_CMT);
                    }
                    else {
                        str.Format(_T("Authenticated as dn:'%s'."),
                            dn == NULL ? _T("NULL") : dn);
                        Out(str, CP_CMT);
                    }
                }
            }
            else if (m_BndOpt->m_API == CBndOpt::BND_GENERIC_API) {
                //
                // generic bind
                //

                //
                // Fill in NT_Authority_Identity struct in case we use it
                //
                if (m_BndOpt->UseAuthI()) {
                    AuthI.User = (PUCHAR) dn;
                    AuthI.UserLength = dn == NULL ? 0 : strlen(dn);
                    AuthI.Domain = (PUCHAR) domain;
                    AuthI.DomainLength =  domain == NULL ? 0 : strlen(domain);
                    AuthI.Password = (PUCHAR) pwd;
                    AuthI.PasswordLength = pwd == NULL ? 0 : strlen(pwd);
                    AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
                }


                if (m_BndOpt->m_bSync) {
                    //
                    // generic sync
                    //
                    if (m_BndOpt->UseAuthI()) {
                        str.Format(_T("res = ldap_bind_s(ld, NULL, &NtAuthIdentity, %d); // v.%d"),
                            ulMethod,
                            m_GenOptDlg->GetLdapVer());
                        Out(str);
                        str.Format(_T("\t{NtAuthIdentity: User='%s'; Pwd= <unavailable>; domain = '%s'.}"),
                            dn == NULL ? _T("NULL") : dn,
                            domain == NULL ? _T("NULL"): domain);
                        Out(str);
                        res = ldap_bind_s(hLdap, NULL, (char*)(&AuthI), ulMethod);
                    }
                    else {
                        str.Format(_T("res = ldap_bind_s(ld, '%s', <unavailable>, %d); // v.%d"),
                            dn == NULL?_T("NULL"): dn,
                            ulMethod,
                            m_GenOptDlg->GetLdapVer());
                        Out(str);
                        res = ldap_bind_s(hLdap, dn, pwd, ulMethod);
                    }
                    if (res != LDAP_SUCCESS) {
                        str.Format(_T("Error <%ld>: ldap_bind_s() failed: %s."),
                            res, ldap_err2string(res));
                        Out(str, CP_CMT);
                    }
                    else {
                        str.Format(_T("Authenticated as dn:'%s'."),
                            dn == NULL ? _T("NULL") : dn);
                        Out(str, CP_CMT);
                    }

                }
                else {
                    //
                    // Async generic
                    //
                    if (m_BndOpt->UseAuthI()) {
                        str.Format(_T("res = ldap_bind(ld, NULL, &NtAuthIdentity, %d); // v.%d"),
                            ulMethod,
                            m_GenOptDlg->GetLdapVer());
                        Out(str);
                        str.Format(_T("\t{NtAuthIdentity: User='%s'; Pwd= <unavailable>; domain = '%s'}"),
                            dn == NULL ? _T("NULL") : dn,
                            domain == NULL ? _T("NULL"): domain);
                        Out(str);
                        res = ldap_bind(hLdap, NULL, (char*)(&AuthI), ulMethod);
                    }
                    else {
                        str.Format("res = ldap_bind(ld, '%s', <unavailable, %d); // v.%d",
                            dn == NULL?"NULL": dn,
                            ulMethod,
                            m_GenOptDlg->GetLdapVer());
                        Out(str);
                        res = ldap_bind(hLdap, dn, pwd, ulMethod);
                    }

                    res = ldap_bind(hLdap, dn, pwd, ulMethod);
                    if (res == -1) {
                        str.Format(_T("Error <%ld>: ldap_bind() failed: %s"),
                            res, ldap_err2string(res));

                        Out(str, CP_CMT);
                    }

                    else {
                        //
                        // append to pending list
                        //
                        CPend pnd;
                        pnd.mID = res;
                        pnd.OpType = CPend::P_BIND;
                        pnd.ld = hLdap;
                        str.Format(_T("%4d: ldap_bind: dn=\"%s\",method=%d"), res,
                            dn == NULL ? _T("NULL") : dn,
                            ulMethod);
                        pnd.strMsg = str;
                        m_PendList.AddTail(pnd);
                        m_PndDlg->Refresh(&m_PendList);
                    }
                }
            }
            else if (m_BndOpt->m_API == CBndOpt::BND_EXTENDED_API) {

    /***************** Extensions not implemented yet in wldap32.dll ***********************

    **** Add new NT_AUTH_IDENTITY format to extensions when implemented ****
                //
                // extended api bind
                //

                if(m_BndOpt->m_bSync){



                    //
                    // generic sync
                    //
                    str.Format("res = ldap_bind_extended_s(ld, \"%s\", \"%s\", %d, \"%s\");",
                                dn == NULL?"NULL": dn,
                                pwd == NULL ?"NULL": pwd,
                                ulMethod,
                                m_BndOpt->GetExtendedString());
                    Out(str);
                    res = ldap_bind_extended_s(hLdap, dn, pwd, ulMethod,
                                                (LPTSTR)m_BndOpt->GetExtendedString());
                    if(res != LDAP_SUCCESS){
                        str.Format("Error <%ld>: ldap_bind_extended_s() failed: %s",
                                            res, ldap_err2string(res));

                        Out(str, CP_CMT);
                    }
                    else{
                        str.Format("Authenticated as dn:'%s', pwd:'%s'.",
                            dn == NULL ? "NULL" : dn,
                            pwd == NULL ? "NULL" : pwd);
                        Out(str, CP_CMT);
                    }

                }
                else{
                    //
                    // Async extended
                    //
                    str.Format("res = ldap_bind_extended(ld, \"%s\", \"%s\", %d, \"%s\");",
                                dn == NULL?"NULL": dn,
                                pwd == NULL ?"NULL": pwd,
                                ulMethod,
                                m_BndOpt->GetExtendedString());
                    Out(str);

                    res = ldap_bind_extended(hLdap, dn, pwd,
                                ulMethod, (LPTSTR)m_BndOpt->GetExtendedString());
                    if(res == -1){
                        str.Format("Error <%ld>: ldap_extended_bind() failed: %s",
                                            res, ldap_err2string(res));

                        Out(str, CP_CMT);
                    }

                    else{
                        CPend pnd;
                        pnd.mID = res;
                        pnd.OpType = CPend::P_BIND;
                        pnd.ld = hLdap;
                        str.Format("%4d: ldap_bind_ext: dn=\"%s\",pwd=\"%s\",method=%d", res,
                            dn == NULL ? "NULL" : dn,
                            pwd == NULL ? "NULL" : pwd,
                            ulMethod);
                        pnd.strMsg = str;
                        m_PendList.AddTail(pnd);
                        m_PndDlg->Refresh(&m_PendList);
                    }
                }

    *****************************************************************************/

                AfxMessageBox("Ldap_bind extensions are not implemented yet. Sorry");
            }
        }
        EndWaitCursor();
    }
}



void CLdpDoc::Connect(CString Svr, INT port){

   CString str;

#ifndef WINLDAP
        if(m_bCnctless){
            AfxMessageBox("Connectionless protocol is not "
                          "implemented for U. of Michigan API."
                          "Continuing with ldap_open().");
            m_bCnctless = FALSE;
        }
#endif



        BeginWaitCursor();

      //
      // Unsupported automatic code generation
      //
        PrintHeader();

        if(m_bCnctless){
         //
         // connectionless
         //
#ifdef WINLDAP
            str.Format(_T("ld = cldap_open(\"%s\", %d);"), LPCTSTR(Svr), port);
            Out(str);
            hLdap = cldap_open(Svr.IsEmpty() ? NULL : (LPTSTR)LPCTSTR(Svr), port);
#endif
        }
        else{
         //
         // Tcp std connection
         //
            str.Format(_T("ld = ldap_open(\"%s\", %d);"), LPCTSTR(Svr), port);
            Out(str);
            hLdap = ldap_open(Svr.IsEmpty() ? NULL : (LPTSTR)LPCTSTR(Svr), port);
        }

        EndWaitCursor();

      //
      // If connected init flags & show base
      //
        if(hLdap != NULL){
            str.Format(_T("Established connection to %s."), Svr);
            Out(str, CP_PRN);
            bConnected = TRUE;

            //
            // Now that we have a valid handle we can set version
            // to whatever specified in general options dialog.
            //
            hLdap->ld_version = m_GenOptDlg->GetLdapVer();
            m_GenOptDlg->DisableVersionUI();

            //
            // Attempt to show base DSA info & get default context
            //
            if(m_GenOptDlg->m_initTree){

            Out(_T("Retrieving base DSA information..."), CP_PRN);
            LDAPMessage *res = NULL;

            BeginWaitCursor();
            ldap_search_s(hLdap,
                          NULL,
                          LDAP_SCOPE_BASE,
                          _T("objectClass=*"),
                          NULL,
                          FALSE,
                          &res);

            //
            // Get default context
            //
             if(1 == ldap_count_entries(hLdap, res)){

                char **val;
                LDAPMessage *baseEntry;

                //
                // Get entry
                //
                baseEntry = ldap_first_entry(hLdap, res);

                //
                // Get default naming context
                //
                val = ldap_get_values(hLdap, baseEntry, LDAP_OPATT_DEFAULT_NAMING_CONTEXT);
                if(0 < ldap_count_values(val))
                    DefaultContext = (CString)val[0];
                ldap_value_free(val);

                // get the schema naming context
                //
                val = ldap_get_values(hLdap, baseEntry, LDAP_OPATT_SCHEMA_NAMING_CONTEXT);
                if(0 < ldap_count_values(val))
                    SchemaNC = (CString)val[0];
                ldap_value_free(val);

                // get the config naming context
                //
                val = ldap_get_values(hLdap, baseEntry, LDAP_OPATT_CONFIG_NAMING_CONTEXT);
                if(0 < ldap_count_values(val))
                    ConfigNC = (CString)val[0];
                ldap_value_free(val);

                // get server name
                val = ldap_get_values(hLdap, baseEntry, LDAP_OPATT_DNS_HOST_NAME);
                if(0 < ldap_count_values(val)){
                    //
                    // Try to extract server name: could be full DN format or just a name
                    // so try both.
                    //
                    CString TitleString;
                    if(val[0] == NULL){
                        Out("Error: ldap internal error: val[0] == NULL");
                    }
                    else{
                        //
                        // Prepare window title from dns string
                        //

                        TitleString.Format("ldap:://%s/%s", val[0],DefaultContext);
                        AfxGetMainWnd()->SetWindowText(TitleString);
                        ldap_value_free(val);
                    }
                }

                // try to read supporteControls

                int cnt;
                val = ldap_get_values(hLdap, baseEntry, LDAP_OPATT_SUPPORTED_CONTROL);
                if(0 < (cnt = ldap_count_values(val)) ) {
                    SetSupportedServerControls (cnt, val);
                }
                else {
                    SetSupportedServerControls (0, NULL);
                }
                ldap_value_free(val);

             }

             //
             // Display search results
             //
             DisplaySearchResults(res);
             EndWaitCursor();
         }
         else{
                    CString TitleString;
               TitleString.Format("%s - connected", AfxGetAppName());
               AfxGetMainWnd()->SetWindowText(TitleString);
         }

        }
        else{
            str.Format(_T("Error <0x%X>: Fail to connect to %s."), LdapGetLastError(), Svr);
            Out(str, CP_PRN);
            AfxMessageBox(_T("Cannot open connection."));
        }
}

void CLdpDoc::SetSupportedServerControls (int cnt, char **val)
{
    int i;


    // free existing controls
    if (m_ServerSupportedControls) {
        for (i=0; m_ServerSupportedControls[i]; i++) {
            free (m_ServerSupportedControls[i]);
        }
        free (m_ServerSupportedControls);
        m_ServerSupportedControls = NULL;
    }

    bServerVLVcapable = FALSE;

    if (cnt && val) {
        m_ServerSupportedControls = (char **)malloc (sizeof (char *) * (cnt + 1));
        if (m_ServerSupportedControls) {
            for (i=0; i < cnt; i++) {
                char *pCtrl = m_ServerSupportedControls[i] = _strdup (val[i]);

                if (pCtrl && (strcmp (pCtrl, LDAP_CONTROL_VLVREQUEST) == 0)) {
                    bServerVLVcapable = TRUE;
                }
            }
            m_ServerSupportedControls[cnt]=NULL;
        }
    }
}

void CLdpDoc::ShowVLVDialog (const char *strDN, BOOL runQuery)
{
    if (!m_vlvDlg) {
        m_vlvDlg = new CVLVDialog;
        if (!m_vlvDlg) {
            return;
        }
        m_vlvDlg->pldpdoc = this;

        m_vlvDlg->Create(IDD_VLV_DLG);
    }
    else {
        m_vlvDlg->ShowWindow(SW_SHOW);
    }

    if (strDN) {
        m_vlvDlg->m_BaseDN = strDN;
    }

    m_vlvDlg->UpdateData(FALSE);

    if (runQuery) {
        m_vlvDlg->RunQuery();
    }
}



/*+++
Function   : CLdp::OnConnectionConnect
Description: response to UI connect request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnConnectionConnect()
{

    CnctDlg dlg;
    CString str;
    int port;

    dlg.m_Svr = Svr;


    if(IDOK == dlg.DoModal()){
        Svr = dlg.m_Svr;
        m_bCnctless = dlg.m_bCnctless;
        port = dlg.m_Port;

      Connect(Svr, port);

    }
}




/*+++
Function   : OnConnectionDisconnect
Description: response to UI disconnect request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnConnectionDisconnect()
{

   CString str;

    //
    // Close connection/less session
    //

    ldap_unbind(hLdap);
   str.Format(_T("0x%x = ldap_unbind(ld);"), LdapGetLastError());
   Out(str);

    //
    // reset connection handle
    //
    hLdap = NULL;
    Out(_T("Disconnected."), CP_PRN | CP_ONLY);
    Out(_T("}"), CP_SRC | CP_ONLY);
    bConnected = FALSE;
    DefaultContext.Empty();
    m_TreeViewDlg->m_BaseDn.Empty();
    m_GenOptDlg->EnableVersionUI();
    CString TitleString;
    TitleString.Format("%s - disconnected", AfxGetAppName());
    AfxGetMainWnd()->SetWindowText(TitleString);
}




/*+++
Function   : OnBrowseSearch
Description: Create modeless search diag
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnBrowseSearch()
{
    bSrch = TRUE;
    if(GetContextActivation()){
        SearchDlg->m_BaseDN = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        SearchDlg->m_BaseDN = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }
    SearchDlg->Create(IDD_SRCH);
}






/*+++
Function   :
Description: a few UI utils
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnUpdateConnectionConnect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!bConnected || !m_bProtect);

}

void CLdpDoc::OnUpdateConnectionDisconnect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(bConnected || !m_bProtect);

}


void CLdpDoc::OnUpdateBrowseSearch(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bSrch && bConnected) || !m_bProtect);

}

void CLdpDoc::OnEditCopy()
{
    CString copyStr;

    if(GetContextActivation()){
        copyStr = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        copyStr = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }
    else {
        return;
    }

    if ( !OpenClipboard(HWND (AfxGetApp()->m_pActiveWnd)) ) {
        AfxMessageBox( "Cannot open the Clipboard" );
        return;
    }

    EmptyClipboard();

    HANDLE hData = GlobalAlloc (GMEM_MOVEABLE, copyStr.GetLength()+2);

    if (hData) {
        char *pStr = (char *)GlobalLock (hData);
        strcpy (pStr, LPCTSTR (copyStr));
        GlobalUnlock (hData);

        if ( ::SetClipboardData( CF_TEXT, hData ) == NULL ) {
            AfxMessageBox( "Unable to set Clipboard data" );
            CloseClipboard();
            return;
        }
    }
    else {
        AfxMessageBox( "Out of memory" );
    }

    CloseClipboard();
}

void CLdpDoc::OnBrowseVlvsearch()
{
    const char *baseDN = NULL;

    if(GetContextActivation()){
        baseDN = LPCTSTR (TreeView()->GetDn());
        TreeView()->SetContextActivation(FALSE);
    }

    ShowVLVDialog (baseDN);
}

void CLdpDoc::OnUpdateBrowseVlvsearch(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( (( !m_vlvDlg || (m_vlvDlg && !m_vlvDlg->GetState())) && bConnected && bServerVLVcapable) || !m_bProtect);

}

void CLdpDoc::OnSrchEnd(){

    bSrch = FALSE;       // dialog is closed.
    CString str;
   //
    // if in paged mode, mark end of page session
   //
    if(bPagedMode){
        str.Format("ldap_search_abandon_page(ld, hPage)");
        Out(str);
        ldap_search_abandon_page(hLdap, hPage);
        bPagedMode = FALSE;
    }
}


/*+++
Function   : OnSrchGo
Description: Response to UI search request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnSrchGo(){

    CString str;
    LPTSTR dn;
    LPTSTR filter;
    LDAP_TIMEVAL tm;
    int i;
    static LDAPMessage *msg;
    ULONG err, MsgId;
    ULONG ulEntryCount=0;
    PLDAPSortKey *SortKeys = m_SKDlg->KList;
    PLDAPControl *SvrCtrls;
    PLDAPControl *ClntCtrls;
    LDAPControl SortCtrl;
//   PLDAPControl SortCtrl=NULL;
    PLDAPControl *CombinedCtrl = NULL;
    INT cbCombined;


    if(!bConnected && m_bProtect)
    {
        AfxMessageBox("Please re-connect session first");
        return;
    }

    //
    // init local time struct
    //
    tm.tv_sec = SrchInfo.lToutSec;
    tm.tv_usec = SrchInfo.lToutMs;


    //
    // If we're in paged mode, then run means next page, & close is abandon (see onsrchEnd)
    //
    if(bPagedMode)
    {

        ulEntryCount=0;
        BeginWaitCursor();
        err = ldap_get_next_page_s(hLdap, hPage, &tm, SrchInfo.lPageSize, &ulEntryCount, &msg);
        EndWaitCursor();

        str.Format("0x%X = ldap_get_next_page_s(ld, hPage, %ld, &timeout, %ld, 0x%X);",
                   err, SrchInfo.lPageSize,ulEntryCount, msg);
        Out(str);

        if(err != LDAP_SUCCESS)
        {
            str.Format("ldap_search_abandon_page(ld, hPage)");
            Out(str);
            ldap_search_abandon_page(hLdap, hPage);
            bPagedMode = FALSE;
        }
        else
        {
            bPagedMode = TRUE;
        }


        DisplaySearchResults(msg);

        if(err == LDAP_SUCCESS)
        {
            Out("   -=>> 'Run' for more, 'Close' to abandon <<=-");
        }

        return;
    }

    Out("***Searching...", CP_PRN);

    //
    // set scope
    //
    int scope = SearchDlg->m_Scope == 0 ? LDAP_SCOPE_BASE :
                SearchDlg->m_Scope == 1 ? LDAP_SCOPE_ONELEVEL :
                LDAP_SCOPE_SUBTREE;

    //
    // Set time/size limits only if connected & hLdap is valid
    //
    if(bConnected)
    {
        hLdap->ld_timelimit = SrchInfo.lTlimit;
        hLdap->ld_sizelimit = SrchInfo.lSlimit;
        ULONG ulVal = SrchInfo.bChaseReferrals ? 1 : 0;
        ldap_set_option(hLdap,
                        LDAP_OPT_REFERRALS,
                        (LPVOID)&ulVal);
    }

    //
    // set base DN
    //
    dn = SearchDlg->m_BaseDN.IsEmpty()? NULL :  (LPTSTR)LPCTSTR(SearchDlg->m_BaseDN);
    if(SearchDlg->m_Filter.IsEmpty() && m_bProtect)
    {
        AfxMessageBox("Please enter a valid filter string (such as objectclass=*). Empty string is invalid.");
        return;
    }
    //
    // & filter
    //
    filter = (LPTSTR)LPCTSTR(SearchDlg->m_Filter);

    // controls
    SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
    ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);

    //
    // execute search call
    //
    switch(SrchInfo.fCall)
    {
        case CALL_ASYNC:
            str.Format("ldap_search_ext(ld, \"%s\", %d, \"%s\", %s, %d ...)",
                       dn,
                       scope,
                       filter,
                       SrchInfo.attrList[0] != NULL ? "attrList" : "NULL",
                       SrchInfo.bAttrOnly);
            Out(str);

            //
            // Combine sort & server controls
            //

            if(SortKeys != NULL)
            {
                err = ldap_encode_sort_controlA(hLdap,
                                                SortKeys,
                                                &SortCtrl,
                                                TRUE);
                if(err != LDAP_SUCCESS)
                {
                    //           str.Format("Error <0x%X>: ldap_create_create_control returned: %s", err, ldap_err2string(err));
                    str.Format("Error <0x%X>: ldap_create_encode_control returned: %s", err, ldap_err2string(err));
                    SortKeys = NULL;
                }
            }

            CombinedCtrl = NULL;

            //
            // count total controls
            //
            for(i=0, cbCombined=0; SvrCtrls != NULL && SvrCtrls[i] != NULL; i++)
                cbCombined++;
            CombinedCtrl = new PLDAPControl[cbCombined+2];
            //
            // set combined
            //
            for(i=0; SvrCtrls != NULL && SvrCtrls[i] != NULL; i++)
                CombinedCtrl[i] = SvrCtrls[i];
            if(SortKeys != NULL)
                CombinedCtrl[i++] = &SortCtrl;
            CombinedCtrl[i] = NULL;

            BeginWaitCursor();
            err = ldap_search_ext(hLdap,
                                  dn,
                                  scope,
                                  filter,
                                  SrchInfo.attrList[0] != NULL ? SrchInfo.attrList : NULL,
                                  SrchInfo.bAttrOnly,
                                  CombinedCtrl,
                                  ClntCtrls,
                                  SrchInfo.lToutSec,
                                  SrchInfo.lSlimit,
                                  &MsgId);
            EndWaitCursor();


            //
            // cleanup
            //
            if(SortKeys != NULL)
            {
                ldap_memfree(SortCtrl.ldctl_value.bv_val);
                ldap_memfree(SortCtrl.ldctl_oid);
            }
            delete CombinedCtrl;

            if(err != LDAP_SUCCESS || (DWORD)MsgId <= 0)
            {
                str.Format("Error<%lu>: %s. (msg = %lu).", err, ldap_err2string(err), MsgId);
                Out(str, CP_PRN);
            }
            else
            {
                //
                // add to pending requests
                //

                CPend pnd;
                pnd.mID = MsgId;
                pnd.OpType = CPend::P_SRCH;
                pnd.ld = hLdap;
                str.Format("%4d: ldap_search: base=\"%s\",filter=\"%s\"", MsgId,
                           dn,
                           filter);
                pnd.strMsg = str;
                m_PendList.AddTail(pnd);
                m_PndDlg->Refresh(&m_PendList);
            }
            break;


        case CALL_SYNC:

            str.Format("ldap_search_s(ld, \"%s\", %d, \"%s\", %s,  %d, &msg)",
                       dn,
                       scope,
                       filter,
                       SrchInfo.attrList[0] != NULL ? "attrList" : "NULL",
                       SrchInfo.bAttrOnly);
            Print(str);

            BeginWaitCursor();
            err = ldap_search_s(hLdap,
                                dn,
                                scope,
                                filter,
                                SrchInfo.attrList[0] != NULL ? SrchInfo.attrList : NULL,
                                SrchInfo.bAttrOnly,
                                &msg);
            EndWaitCursor();


            if(err != LDAP_SUCCESS)
            {
                str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
                Out(str, CP_PRN);
            }

            //
            // display results even if res is unsuccessfull (specs)
            //
            DisplaySearchResults(msg);
            break;

        case CALL_EXTS:

            str.Format("ldap_search_ext_s(ld, \"%s\", %d, \"%s\", %s,  %d, svrCtrls, ClntCtrls, %ld, %ld ,&msg)",
                       dn,
                       scope,
                       filter,
                       SrchInfo.attrList[0] != NULL ? "attrList" : "NULL",
                       SrchInfo.bAttrOnly,
                       SrchInfo.lToutSec,
                       SrchInfo.lSlimit);
            Out(str);



            //
            // Combine sort & server controls
            //

            if(SortKeys != NULL)
            {
                err = ldap_encode_sort_controlA(hLdap,
                                                SortKeys,
                                                &SortCtrl,
                                                TRUE);
                if(err != LDAP_SUCCESS)
                {
                    str.Format("Error <0x%X>: ldap_create_encode_control returned: %s", err, ldap_err2string(err));
		    Out(str, CP_PRN);
                    SortKeys = NULL;
                }
            }

            CombinedCtrl = NULL;

            //
            // count total controls
            //
            for(i=0, cbCombined=0; SvrCtrls != NULL && SvrCtrls[i] != NULL; i++)
                cbCombined++;
            CombinedCtrl = new PLDAPControl[cbCombined+2];
            //
            // set combined
            //
            for(i=0; SvrCtrls != NULL && SvrCtrls[i] != NULL; i++)
                CombinedCtrl[i] = SvrCtrls[i];
            if(SortKeys != NULL)
                CombinedCtrl[i++] = &SortCtrl;
            CombinedCtrl[i] = NULL;


            //
            // call search
            //
            BeginWaitCursor();
            err = ldap_search_ext_s(hLdap,
                                    dn,
                                    scope,
                                    filter,
                                    SrchInfo.attrList[0] != NULL ? SrchInfo.attrList : NULL,
                                    SrchInfo.bAttrOnly,
                                    CombinedCtrl,
                                    ClntCtrls,
                                    &tm,
                                    SrchInfo.lSlimit,
                                    &msg);
            EndWaitCursor();

            //
            // cleanup
            //
            if(SortKeys != NULL)
            {
                ldap_memfree(SortCtrl.ldctl_value.bv_val);
                ldap_memfree(SortCtrl.ldctl_oid);
            }
            delete CombinedCtrl;



            if(err != LDAP_SUCCESS)
            {
                str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
                Out(str, CP_PRN);
            }

            //
            // display results even if res is unsuccessfull (specs)
            //
            DisplaySearchResults(msg);
            break;

        case CALL_PAGED:

            str.Format("ldap_search_init_page(ld, \"%s\", %d, \"%s\", %s,  %d, svrCtrls, ClntCtrls, %ld, %ld ,SortKeys)",
                       dn,
                       scope,
                       filter,
                       SrchInfo.attrList[0] != NULL ? "attrList" : "NULL",
                       SrchInfo.bAttrOnly,
                       SrchInfo.lTlimit,
                       SrchInfo.lSlimit);
            Print(str);



            BeginWaitCursor();
            hPage = ldap_search_init_page(hLdap,
                                          dn,
                                          scope,
                                          filter,
                                          SrchInfo.attrList[0] != NULL ? SrchInfo.attrList : NULL,
                                          SrchInfo.bAttrOnly,
                                          SvrCtrls,
                                          ClntCtrls,
                                          SrchInfo.lTlimit,
                                          SrchInfo.lSlimit,
                                          SortKeys);
            EndWaitCursor();


            if(hPage == NULL)
            {
                err = LdapGetLastError();
                str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
                Out(str, CP_PRN);
            }

            //
            // display results even if res is unsuccessfull (specs)
            //
            ulEntryCount=0;
            BeginWaitCursor();
            err = ldap_get_next_page_s(hLdap, hPage, &tm, SrchInfo.lPageSize, &ulEntryCount, &msg);
            EndWaitCursor();
            str.Format("0x%X = ldap_get_next_page_s(ld, hPage, %lu, &timeout, %ld, 0x%X);",
                       err, SrchInfo.lPageSize,ulEntryCount, msg);
            Out(str);

            if(err != LDAP_SUCCESS)
            {
                str.Format("ldap_search_abandon_page(ld, hPage)");
                Out(str);
                ldap_search_abandon_page(hLdap, hPage);
                bPagedMode = FALSE;
            }
            else
            {
                bPagedMode = TRUE;
            }


            DisplaySearchResults(msg);

            if(err == LDAP_SUCCESS)
            {
                Out("   -=>> 'Run' for more, 'Close' to abandon <<=-");
            }

            break;

        case CALL_TSYNC:
            str.Format("ldap_search_st(ld, \"%s\", %d, \"%s\", %s,%d, &tm, &msg)",
                       dn,
                       scope,
                       filter,
                       SrchInfo.attrList[0] != NULL ? "attrList" : "NULL",
                       SrchInfo.bAttrOnly);
            Out(str);

            tm.tv_sec = SrchInfo.lToutSec;
            tm.tv_usec = SrchInfo.lToutMs;
            BeginWaitCursor();
            err = ldap_search_st(hLdap,
                                 dn,
                                 scope,
                                 filter,
                                 SrchInfo.attrList[0] != NULL ? SrchInfo.attrList : NULL,
                                 SrchInfo.bAttrOnly,
                                 &tm,
                                 &msg);
            EndWaitCursor();

            if(err != LDAP_SUCCESS)
            {
                str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
                Out(str, CP_PRN);
            }
            //
            // display search even if res is unsuccessfull (specs)
            //
            DisplaySearchResults(msg);

            break;
    }

    //
    // Cleanup
    //

    FreeControls(SvrCtrls);
    FreeControls(ClntCtrls);

}






/*+++
Function   : DisplaySearchResults
Description: Display results
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::DisplaySearchResults(LDAPMessage *msg){

    //
    // Parse results
    //
    CString str, strDN;
    char *dn;
    void *ptr;
    char *attr;
    LDAPMessage *nxt;
    ULONG nEntries;
    CLdpView *pView;


    pView = (CLdpView*)GetOwnView(_T("CLdpView"));

   ParseResults(msg);

    Out("", CP_ONLY|CP_SRC);
    str.Format("Getting %lu entries:", ldap_count_entries(hLdap, msg));
    Out(str, CP_PRN);
    if(!SrchOptDlg.m_bDispResults)
        Out(_T("<Skipping search results display (search options)...>"));

   //
   // disable redraw
   //
    pView->SetRedraw(FALSE);
   pView->CacheStart();

   //
   // traverse entries
   //
    for(nxt = ldap_first_entry(hLdap, msg)/*,
            Out("nxt = ldap_first_entry(ld, msg);", CP_ONLY|CP_SRC)*/,
         nEntries = 0;
            nxt != NULL;
            nxt = ldap_next_entry(hLdap, nxt)/*,
            Out("nxt = ldap_next_entry(ld,nxt);", CP_ONLY|CP_SRC)*/,
            nEntries++){

            //
            // get dn text & process
            //
//              Out("dn = ldap_get_dn(ld,nxt);", CP_ONLY|CP_SRC);
                dn = ldap_get_dn(hLdap, nxt);
                strDN = DNProcess(dn);
                if(m_SrcMode){
                   str = "\tprintf(\"Dn: %%s\\n\", dn);";
                }
                else{
                   str = CString(">> Dn: ") + strDN;
                }
                if(SrchOptDlg.m_bDispResults)
                    Out(str);

            //
            // traverse attributes
            //
                for(attr = ldap_first_attribute(hLdap, nxt, (BERPTRTYPE)&ptr)/*,
                        Out("attr = ldap_first_attribute(ld, nxt, (BERPTRTYPE)&ptr);", CP_ONLY|CP_SRC)*/;
                        attr != NULL;
                        attr = ldap_next_attribute(hLdap, nxt, (struct berelement*)ptr)/*,
                        Out("attr = ldap_next_attribute(ld, nxt, (struct berelement*)ptr);", CP_ONLY|CP_SRC) */){

//                          Out("\tprintf(\"\\t%%s: \", attr);", CP_ONLY|CP_SRC);

                     //
                     // display values
                     //
                            if(m_GenOptDlg->m_ValProc == STRING_VAL_PROC){
                                DisplayValues(nxt, attr);
                            }
                            else{
                                DisplayBERValues(nxt, attr);
                            }
                }
//              Out("", CP_ONLY|CP_SRC);

     }

    //
    // verify consistency
    //
    if(nEntries != ldap_count_entries(hLdap, msg)){
        str.Format("Error: ldap_count_entries reports %lu entries. Parsed %lu.",
                        ldap_count_entries(hLdap, msg), nEntries);
        Out(str, CP_PRN);
    }
    Out("ldap_msgfree(msg);", CP_ONLY|CP_SRC);
    ldap_msgfree(msg);
    Out("-----------", CP_PRN);
    Out("", CP_ONLY|CP_SRC);

   //
   // now allow refresh
   //
   pView->CacheEnd();
    pView->SetRedraw();
}




/*+++
Function   : FormatValue
Description: generates a string from a berval value
             this provides a tiny substitute to loading the schema dynamically & provide
             some minimal value parsing for most important/requested attributes
Parameters :
        pbval: a ptr to berval value
        str: result

Return     :
Remarks    : none.
---*/
VOID
CLdpDoc::FormatValue(
                     IN     CString         attr,
                     IN     PLDAP_BERVAL    pbval,
                     IN     CString&         str){

    DWORD err;
    CString tstr;
    BOOL bValid;


    if (!pbval)
    {
        tstr = "<value format error>";
    }
    else
    {
        if ( 0 == _stricmp(attr, "objectGuid") ||
             0 == _stricmp(attr, "invocationId") ||
             0 == _stricmp(attr, "attributeSecurityGUID") ||
             0 == _stricmp(attr, "schemaIDGUID") ||
             0 == _stricmp(attr, "serviceClassID") )
        {
            //
            // format as a guid
            //
            PUCHAR  pszGuid = NULL;

            err = UuidToString((GUID*)pbval->bv_val, &pszGuid);
            if(err != RPC_S_OK){
               tstr.Format("<ldp error %lu: UuidFromString failure>", err);
            }
            if ( pszGuid )
            {
                tstr = pszGuid;
                RpcStringFree(&pszGuid);
            }
            else
            {
                tstr = "<invalid Guid>";
            }

        }
        else if ( 0 == _stricmp(attr, "objectSid") ||
                  0 == _stricmp(attr, "sidHistory") )
        {
            //
            // format as object sid
            //
            PSID psid = pbval->bv_val;
            LPSTR pszTmp = NULL;


            if ( ConvertSidToStringSidA(psid, &pszTmp) &&
                 pszTmp )
            {
                tstr = pszTmp;
                LocalFree(pszTmp);
            }
            else {
                tstr = "<ldp error: invalid sid>";
            }
        }
        else if (( 0 == _stricmp(attr, "whenChanged") ||
                  0 == _stricmp(attr, "whenCreated") ||
                  0 == _stricmp(attr, "dSCorePropagationData") ||
                  0 == _stricmp(attr, "msDS-Entry-Time-To-Die") ||
                  0 == _stricmp(attr, "schemaUpdate") ||
                  0 == _stricmp(attr, "modifyTimeStamp") ||
                  0 == _stricmp(attr, "createTimeStamp") ||
                  0 == _stricmp(attr, "currentTime")) && (atoi (pbval->bv_val) != 0))
        {
            //
            // print in time format
            //
            SYSTEMTIME sysTime, localTime;
            err = GeneralizedTimeToSystemTime(pbval->bv_val,
                                               &sysTime);
            if( ERROR_SUCCESS == err)
            {

                TIME_ZONE_INFORMATION tz;
                BOOL bstatus;

                err = GetTimeZoneInformation(&tz);
                if ( err == TIME_ZONE_ID_INVALID ) {
                    tstr.Format("<ldp error <%lu>: cannot format time field>",
                                GetLastError());
                }
                else {

                    bstatus = SystemTimeToTzSpecificLocalTime(
                                    (err == TIME_ZONE_ID_UNKNOWN) ? NULL : &tz,
                                    &sysTime,
                                    &localTime );

                    if ( bstatus )
                    {
                        tstr.Format("%d/%d/%d %d:%d:%d %S %S",
                                    localTime.wMonth,
                                    localTime.wDay,
                                    localTime.wYear,
                                    localTime.wHour,
                                    localTime.wMinute,
                                    localTime.wSecond,
                                    tz.StandardName,
                                    tz.DaylightName);
                    }
                    else
                    {
                        tstr.Format("%d/%d/%d %d:%d:%d UNC",
                                    localTime.wMonth,
                                    localTime.wDay,
                                    localTime.wYear,
                                    localTime.wHour,
                                    localTime.wMinute,
                                    localTime.wSecond);

                    }

                }
            }
            else
            {
                tstr.Format("<ldp error <0x%x>: Time processing failed in GeneralizedTimeToSystemTime>", err);
            }

        }
        else if ((0 == _stricmp(attr, "accountExpires") ||
		 0 == _stricmp(attr, "badPasswordTime") ||
                 0 == _stricmp(attr, "creationTime") ||
                 0 == _stricmp(attr, "lastLogon") ||
                 0 == _stricmp(attr, "lastLogoff") ||
                 0 == _stricmp(attr, "lastLogonTimestamp") ||
                 0 == _stricmp(attr, "pwdLastSet") ||
 		 0 == _stricmp(attr, "msDS-Cached-Membership-Time-Stamp")) && (atoi (pbval->bv_val) != 0)) {

            //
            // print in time format
            //
            SYSTEMTIME sysTime, localTime;
            err = DSTimeToSystemTime(pbval->bv_val, &sysTime);
            if( ERROR_SUCCESS == err)
            {

                TIME_ZONE_INFORMATION tz;
                BOOL bstatus;

                err = GetTimeZoneInformation(&tz);
                if ( err != TIME_ZONE_ID_INVALID &&
                     err != TIME_ZONE_ID_UNKNOWN )
                {

                    bstatus = SystemTimeToTzSpecificLocalTime(&tz,
                                                              &sysTime,
                                                              &localTime);
                    if ( bstatus )
                    {
                        tstr.Format("%d/%d/%d %d:%d:%d %S %S",
                                    localTime.wMonth,
                                    localTime.wDay,
                                    localTime.wYear,
                                    localTime.wHour,
                                    localTime.wMinute,
                                    localTime.wSecond,
                                    tz.StandardName,
                                    tz.DaylightName);
                    }
                    else
                    {
                        tstr.Format("%d/%d/%d %d:%d:%d UNC",
                                    localTime.wMonth,
                                    localTime.wDay,
                                    localTime.wYear,
                                    localTime.wHour,
                                    localTime.wMinute,
                                    localTime.wSecond);

                    }

                }
                else
                {
                    tstr.Format("<ldp error <0x%x>: cannot format time field", err);
                }

            }
            else
            {
                tstr.Format("<ldp error <0x%x>: cannot format time field", err);
            }
        }
	else if (0 == _stricmp(attr, "lockoutDuration") ||
		0 == _stricmp(attr, "lockoutObservationWindow") ||
		0 == _stricmp(attr, "forceLogoff") ||
		0 == _stricmp(attr, "minPwdAge") ||
                0 == _stricmp(attr, "maxPwdAge")) {

		//
		//  Caculate the duration for this value
		//  it's stored as a negitive value in nanoseconds.
		//   a value of -9223372036854775808 is never
		__int64   lTemp;

		lTemp = _atoi64 (pbval->bv_val);
		if (lTemp > 0x8000000000000000){
			lTemp = lTemp * -1;
			lTemp = lTemp / 10000000;		
			tstr.Format("%ld", lTemp);
		}
		else
			tstr.Format("%s (none)", pbval->bv_val);

	} 
        else if (0 ==  _stricmp(attr, "userAccountControl") ||
		0 ==  _stricmp(attr, "groupType") ||
		0 ==  _stricmp(attr, "systemFlags") ) {
            tstr.Format("0x%x", atoi (pbval->bv_val));
        }
        else if ( 0 == _stricmp(attr, "dnsRecord") )
        {
            // Taken from \nt\private\net\sockets\dns\server\server\record.h
            //
            //  DS Record
            //


            typedef struct _DsRecord
            {
                WORD                wDataLength;
                WORD                wType;

                //DWORD               dwFlags;
                BYTE                Version;
                BYTE                Rank;
                WORD                wFlags;

                DWORD               dwSerial;
                DWORD               dwTtlSeconds;
                DWORD               dwTimeout;
                DWORD               dwStartRefreshHr;

                union               _DataUnion
                {
                    struct
                    {
                        LONGLONG        EntombedTime;
                    }
                    Tombstone;
                }
                Data;
            }
            DS_RECORD, *PDS_RECORD;

            //
            // foramt as a dns record
            //
            PDS_RECORD pDnsRecord = (PDS_RECORD)pbval->bv_val;
            DWORD cbDnsRecord = pbval->bv_len;
            bValid=TRUE;

            if ( cbDnsRecord < sizeof(DS_RECORD) )
            {
                tstr.Format("<ldp error: cannot format DS_DNSRECORD field");
                //
                // Weird way to store info...but this is still valid
                //
                bValid = cbDnsRecord == sizeof(DS_RECORD)-4 ? TRUE : FALSE;
            }

            //
            // ready to print
            //

            if ( bValid )
            {

                PBYTE pData = ((PBYTE)pDnsRecord+sizeof(DS_RECORD)-sizeof(LONGLONG));
                DWORD cbData = pDnsRecord->wDataLength;
                CString sData;
                tstr.Format("wDataLength: %d "
                            "wType: %d; "
                            "Version: %d "
                            "Rank: %d "
                            "wFlags: %d "
                            "dwSerial: %lu "
                            "dwTtlSeconds: %lu "
                            "dwTimeout: %lu "
                            "dwStartRefreshHr: %lu "
                            "Data: ",
                            pDnsRecord->wDataLength,
                            pDnsRecord->wType,
                            pDnsRecord->Version,
                            pDnsRecord->Rank,
                            pDnsRecord->wFlags,
                            pDnsRecord->dwSerial,
                            pDnsRecord->dwTtlSeconds,
                            pDnsRecord->dwTimeout,
                            pDnsRecord->dwStartRefreshHr);
                DumpBuffer(pData, cbData, sData);
                tstr += sData;
            }



        }
        else if ( 0 == _stricmp(attr, "replUpToDateVector") )
        {
            //
            // foramt as Uptodatevector
            /*
            typedef struct _UPTODATE_VECTOR {
            DWORD   dwVersion;
            DWORD   dwReserved1;
            SWITCH_IS(dwVersion) union {
                CASE(1) UPTODATE_VECTOR_V1 V1;
            };
            } UPTODATE_VECTOR;
            typedef struct _UPTODATE_VECTOR_V1 {
            DWORD               cNumCursors;
            DWORD               dwReserved2;
            #ifdef MIDL_PASS
            [size_is(cNumCursors)]
                UPTODATE_CURSOR rgCursors[];
            #else
                UPTODATE_CURSOR     rgCursors[1];
            #endif
            } UPTODATE_VECTOR_V1;
            etc...
            */
            //
            UPTODATE_VECTOR *pUtdVec = (UPTODATE_VECTOR *)pbval->bv_val;
            DWORD cbUtdVec = pbval->bv_len;

            if ( pUtdVec->dwVersion != 1 )
            {
                tstr.Format("<ldp error: cannot process UPDATE_VECTOR v.%lu>", pUtdVec->dwVersion );
            }
            else
            {
                tstr.Format("dwVersion: %lu, dwReserved1: %lu, V1.cNumCursors: %lu, V1.dwReserved2: %lu,rgCursors: ",
                            pUtdVec->dwVersion, pUtdVec->dwReserved1,
                            pUtdVec->V1.cNumCursors, pUtdVec->V1.dwReserved2 );
                bValid = TRUE;
                for (INT i=0;
                     bValid && i < pUtdVec->V1.cNumCursors;
                     i++)
                {
                    PUCHAR  pszGuid = NULL;

                    err = UuidToString(&(pUtdVec->V1.rgCursors[i].uuidDsa), &pszGuid);
                    if(err != RPC_S_OK || !pszGuid){
                       tstr.Format("<ldp error %lu: UuidFromString failure>", err);
                       bValid = FALSE;
                    }
                    else
                    {
                        CString strCursor;
                        strCursor.Format("{uuidDsa: %s, usnHighPropUpdate: %I64d}, ",
                                         pszGuid, pUtdVec->V1.rgCursors[i].usnHighPropUpdate);
                        RpcStringFree(&pszGuid);
                        tstr += strCursor;
                    }
                }
            }
        }
        else if ( 0 == _stricmp(attr, "repsFrom") ||
                  0 == _stricmp(attr, "repsTo") )
        {
            //
            // format as REPLICA_LINK
            /*
            typedef struct _ReplicaLink_V1 {
                ULONG       cb;                     // total size of this structure
                ULONG       cConsecutiveFailures;   // * number of consecutive call failures along
                                                    //    this link; used by the KCC to route around
                                                    //    servers that are temporarily down
                DSTIME       timeLastSuccess;      // (Reps-From) time of last successful replication or
                                                    //    (Reps-To) time at which Reps-To was added or updated
                DSTIME       timeLastAttempt;      // * time of last replication attempt
                ULONG       ulResultLastAttempt;    // * result of last replication attempt (DRSERR_*)
                ULONG       cbOtherDraOffset;       // offset (from struct *) of other-dra MTX_ADDR
                ULONG       cbOtherDra;             // size of other-dra MTX_ADDR
                ULONG       ulReplicaFlags;         // zero or more DRS_* flags
                REPLTIMES   rtSchedule;             // * periodic replication schedule
                                                    //    (valid only if ulReplicaFlags & DRS_PER_SYNC)
                USN_VECTOR  usnvec;                 // * propagation state
                UUID        uuidDsaObj;             // objectGUID of other-dra's ntdsDSA object
                UUID        uuidInvocId;            // * invocation id of other-dra
                UUID        uuidTransportObj;       // * objectGUID of interSiteTransport object
                                                    //      corresponding to the transport by which we
                                                    //      communicate with the source DSA
                DWORD       dwReserved1;             // * unused
                                                    //   and it assumes max size of DWORD rather then the extensible
                                                    //   DRS_EXTENSIONS. We would filter only those props we're interested in
                                                    //   storing in RepsFrom so it should last for a while (32 exts)
                ULONG       cbPASDataOffset;        // * offset from beginning of struct to PAS_DATA section
                BYTE        rgb[];                  // storage for the rest of the structure

                                                    // * indicates valid only on Reps-From
            } REPLICA_LINK_V1;

            typedef struct _ReplicaLink {
                DWORD       dwVersion;
                union
                {
                    REPLICA_LINK_V1 V1;
                };
            } REPLICA_LINK;
            etc...
            */
            //
            REPLICA_LINK *pReplink = (REPLICA_LINK *)pbval->bv_val;
            DWORD cbReplink = pbval->bv_len;
            // See what generation did we read
            BOOL  fShowExtended = pReplink->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.rgb);
            BOOL  fUsePasData = fShowExtended && pReplink->V1.cbPASDataOffset;
            PPAS_DATA pPasData = fUsePasData ? RL_PPAS_DATA(pReplink) : NULL;

            if ( pReplink->dwVersion != 1 )
            {
                tstr.Format("<ldp error: cannot process REPLICA_LINK v.%lu>", pReplink->dwVersion );
            }
            else
            {
                PUCHAR pszUuidDsaObj=NULL, pszUuidInvocId=NULL, pszUuidTransportObj=NULL;
                // Workaround CString inability to convert several longlong in a sequence (eyals)
                CString strLastSuccess, strLastAttempt, strUsnHighObj, strUsnHighProp;
                strLastSuccess.Format("%I64d", pReplink->V1.timeLastSuccess);
                strLastAttempt.Format("%I64d", pReplink->V1.timeLastAttempt);
                strUsnHighObj.Format("%I64d", pReplink->V1.usnvec.usnHighObjUpdate);
                strUsnHighProp.Format("%I64d", pReplink->V1.usnvec.usnHighPropUpdate);

                (VOID)UuidToString(&(pReplink->V1.uuidDsaObj), &pszUuidDsaObj);
                (VOID)UuidToString(&(pReplink->V1.uuidInvocId), &pszUuidInvocId);
                (VOID)UuidToString(&(pReplink->V1.uuidTransportObj), &pszUuidTransportObj);
                tstr.Format("dwVersion = 1, " \
                            "V1.cb: %lu, " \
                            "V1.cConsecutiveFailures: %lu " \
                            "V1.timeLastSuccess: %s " \
                            "V1.timeLastAttempt: %s " \
                            "V1.ulResultLastAttempt: 0x%X " \
                            "V1.cbOtherDraOffset: %lu " \
                            "V1.cbOtherDra: %lu " \
                            "V1.ulReplicaFlags: 0x%x " \
                            "V1.rtSchedule: <ldp:skipped> " \
                            "V1.usnvec.usnHighObjUpdate: %s " \
                            "V1.usnvec.usnHighPropUpdate: %s " \
                            "V1.uuidDsaObj: %s " \
                            "V1.uuidInvocId: %s "  \
                            "V1.uuidTransportObj: %s " \
                            "V1~mtx_address: %s " \
                            "V1.cbPASDataOffset: %lu "   \
                            "V1~PasData: version = %d, size = %d, flag = %d ",
                            pReplink->V1.cb,
                            pReplink->V1.cConsecutiveFailures,
                            strLastSuccess,
                            strLastAttempt,
                            pReplink->V1.ulResultLastAttempt,
                            pReplink->V1.cbOtherDraOffset,
                            pReplink->V1.cbOtherDra,
                            pReplink->V1.ulReplicaFlags,
                            strUsnHighObj,
                            strUsnHighProp,
                            pszUuidDsaObj ? (PCHAR)pszUuidDsaObj : "<Invalid Uuid>",
                            pszUuidInvocId ? (PCHAR)pszUuidInvocId : "<Invalid Uuid>",
                            pszUuidTransportObj ? (PCHAR)pszUuidTransportObj : "<Invalid Uuid>",
                            RL_POTHERDRA(pReplink)->mtx_name,
                            fUsePasData ? pReplink->V1.cbPASDataOffset : 0,
                            pPasData ? pPasData->version : -1,
                            pPasData ? pPasData->size : -1,
                            pPasData ? pPasData->flag : -1);
                if (pszUuidDsaObj)
                {
                    RpcStringFree(&pszUuidDsaObj);
                }
                if (pszUuidInvocId)
                {
                    RpcStringFree(&pszUuidInvocId);
                }
                if (pszUuidTransportObj)
                {
                    RpcStringFree(&pszUuidTransportObj);
                }
            }
        }
        else if ( 0 == _stricmp(attr, "schedule") )
        {
            //
            // foramt as Schedule
            /*
            typedef struct _repltimes {
                UCHAR rgTimes[84];
            } REPLTIMES;
            */
            //
            //
            // Hack:
            // Note that we're reding rgtimes[168] (see SCHEDULE_DATA_ENTRIES) but storing
            // in rgtimes[84]. We're ok here but this is ugly & not maintainable & for sure will
            // break sometimes soon.
            // The problem is due to inconsistency due to storing the schedule in 1 byte == 1 hour
            // whereas the internal format is using 1 byte == 2 hours. (hence 84 to 168).
            //
            CString strSched;
            PBYTE pTimes;
            PSCHEDULE pSched = (PSCHEDULE)pbval->bv_val;;
            DWORD cbSched = pbval->bv_len;
            if ( cbSched != sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES )
            {
                tstr.Format("<ldp: cannot format schedule. sizeof(REPLTIMES) = %d>", cbSched );
            }
            else
            {
                INT bitCount=0;

                tstr.Format("Size: %lu, Bandwidth: %lu, NumberOfSchedules: %lu, Schedules[0].Type: %lu, " \
                            "Schedules[0].Offset: %lu ",
                            pSched->Size,
                            pSched->Bandwidth,
                            pSched->NumberOfSchedules,
                            pSched->Schedules[0].Type,
                            pSched->Schedules[0].Offset );
                pTimes = (BYTE*)((PBYTE)pSched + pSched->Schedules[0].Offset);
                // traverse schedule blob
                strSched = "  ";
                for ( INT i=0; i<168;i++ )
                {

                    BYTE byte = *(pTimes+i);
                    for ( INT j=0; j<=3;j++ )
                    {
                        // traverse bits & mark on/off
                        strSched += (byte & (1 << j))? "1" : "0";
                        if( (++bitCount % 4) == 0 )
                        {
                            // hour boundary
                            strSched += ".";
                        }
                        if ( (bitCount % 96) == 0)
                        {
                            // a day boundary
                            strSched += "  ";
                        }
                    }
                }

                tstr += strSched;
            }
        }
        else if ( 0 == _stricmp(attr, "partialAttributeSet") )
        {
            //
            // foramt as PARTIAL_ATTR_VECTOR
            /*
            // PARTIAL_ATTR_VECTOR - represents the partial attribute set. This is an array of
            //      sorted attids that make the partial set.
            typedef struct _PARTIAL_ATTR_VECTOR_V1 {
                DWORD cAttrs;    // count of partial attributes in the array
            #ifdef MIDL_PASS
                [size_is(cAttrs)] ATTRTYP rgPartialAttr[];
            #else
                ATTRTYP rgPartialAttr[1];
            #endif
            } PARTIAL_ATTR_VECTOR_V1;

            // We need to make sure the start of the union is aligned at an 8 byte
            // boundary so that we can freely cast between internal and external
            // formats.
            typedef struct _PARTIAL_ATTR_VECTOR_INTERNAL {
                DWORD   dwVersion;
                DWORD   dwFlag;
                SWITCH_IS(dwVersion) union {
                    CASE(1) PARTIAL_ATTR_VECTOR_V1 V1;
                };
            } PARTIAL_ATTR_VECTOR_INTERNAL;

            typedef PARTIAL_ATTR_VECTOR_INTERNAL PARTIAL_ATTR_VECTOR;
            */
            //
            CString strPAS;
            PARTIAL_ATTR_VECTOR *pPAS = (PARTIAL_ATTR_VECTOR*)pbval->bv_val;;
            DWORD cbPAS = pbval->bv_len;
            if ( cbPAS < sizeof(PARTIAL_ATTR_VECTOR))
            {
                tstr.Format("<ldp: cannot format partialAttributeSet. sizeof(PARTIAL_ATTR_VECTOR) = %d>", cbPAS );
            }
            else
            {
                tstr.Format("dwVersion: %lu, dwFlag: %lu, V1.cAttrs: %lu, V1.rgPartialAttr: ",
                            pPAS->dwVersion, pPAS->dwReserved1, pPAS->V1.cAttrs);

                // traverse partial attr list
                for ( INT i=0; i<pPAS->V1.cAttrs; i++ )
                {
                    strPAS.Format("%X ", pPAS->V1.rgPartialAttr[i]);
                    tstr += strPAS;
                }
            }
        }
        else
        {
            //
            // unknown attribute.
            // try to find if it's printable
            //
            BOOL bPrintable=TRUE;
            for (INT i=0; i<pbval->bv_len; i++)
            {
                if (!isalpha(pbval->bv_val[i]) &&
                    !isspace(pbval->bv_val[i]) &&
                    !isdigit(pbval->bv_val[i]) &&
                    !isgraph(pbval->bv_val[i]) &&
                    pbval->bv_val[i] != 0               // accept Null terminated strings
                    )
                {
                    bPrintable = FALSE;
                    break;
                }
            }
            if (bPrintable)
            {
                tstr = pbval->bv_val;
            }
            else
            {
                tstr = "<ldp: Binary blob>";
            }

        }


    }

    str += tstr;
}




/*+++
Function   : DisplayValues
Description: printout the values of a dn
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::DisplayValues(LDAPMessage *entry, char *attr){


    LDAP_BERVAL **bval;
    unsigned long i;
    CString str;

   //
   // get & traverse values
   //
    bval = ldap_get_values_len(hLdap, entry, attr);
//  Out("val = ldap_get_values(ld, nxt, attr);", CP_ONLY|CP_SRC);
    str.Format("\t%lu> %s: ", ldap_count_values_len(bval), attr);

    for(i=0/*,
        Out("i=0;", CP_ONLY|CP_SRC)*/;
        bval != NULL && bval[i] != NULL;
        i++/*, Out("i++;", CP_ONLY|CP_SRC)*/){

            FormatValue(attr, bval[i], str);
            str += "; ";
//          Out("\tprintf(\"\\t\\t%%s; \",val[i]);", CP_ONLY|CP_SRC);
    }
//  Out("\\n", CP_ONLY|CP_PRN);
    if(SrchOptDlg.m_bDispResults)
        Out(str, CP_CMT);
//  Out("", CP_ONLY|CP_SRC);
    if(i != ldap_count_values_len(bval)){
        str.Format("Error: ldap_count_values_len reports %lu values. Parsed %lu",
                   ldap_count_values_len(bval), i);
        Out(str, CP_PRN);
    }
   //
   // free up mem
   //
    if(bval != NULL){
        ldap_value_free_len(bval);
//      Out("ldap_value_free(val);", CP_ONLY|CP_SRC);
    }
}









/*+++
Function   : DisplayBERValues
Description: Display values using BER interface
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::DisplayBERValues(LDAPMessage *entry, char *attr){


    struct berval **val;
    unsigned long i;
    CString str, tmpStr;

   //
   // get & traverse values
   //
    val = ldap_get_values_len(hLdap, entry, attr);
//  Out("val = ldap_get_values_len(ld, nxt, attr);", CP_ONLY|CP_SRC);
    str.Format("\t%lu> %s: ", ldap_count_values_len(val), attr);

    for(i=0/*,
        Out("i=0;", CP_ONLY|CP_SRC)*/;
        val != NULL && val[i] != NULL;
        i++/*, Out("i++;", CP_ONLY|CP_SRC)*/){

         DumpBuffer(val[i]->bv_val, val[i]->bv_len, tmpStr);


            str += tmpStr;
//          Out("\tprintf(\"\\t\\t%%s; \",val[i]);", CP_ONLY|CP_SRC);
    }

//  Out("\\n", CP_ONLY|CP_PRN);
    if(SrchOptDlg.m_bDispResults)
        Out(str, CP_CMT);
//  Out("", CP_ONLY|CP_SRC);
   //
   // verify consistency
   //
    if(i != ldap_count_values_len(val)){
        str.Format("Error: ldap_count_values reports %lu values. Parsed %lu",
                    ldap_count_values_len(val), i);
        Out(str, CP_PRN);
    }
   //
   // free up
   //
    if(val != NULL){
        ldap_value_free_len(val);
//      Out("ldap_value_free(val);", CP_ONLY|CP_SRC);
    }
}








/*+++
Function   : DNProcess
Description: process DN format for display (types etc)
Parameters :
Return     :
Remarks    : none.
---*/
CString CLdpDoc::DNProcess(PCHAR dn){

    CString strDN;
    PCHAR *DNs;
    int i;

   //
   // pre-process dn before displaying
   //
    switch(m_GenOptDlg->m_DnProc){
        case CGenOpt::GEN_DN_NONE:
            strDN = dn;
            break;
        case CGenOpt::GEN_DN_EXPLD:
            DNs = ldap_explode_dn(dn, FALSE);
            strDN.Empty();
            for(i=0; DNs!= NULL && DNs[i] != NULL; i++){
                strDN += CString(DNs[i]) + "; ";
            }
            ldap_value_free(DNs);
            break;
        case CGenOpt::GEN_DN_NOTYPE:
            DNs = ldap_explode_dn(dn, TRUE);
            strDN.Empty();
            for(i=0; DNs!= NULL && DNs[i] != NULL; i++){
                strDN += CString(DNs[i]) + "; ";
            }
            ldap_value_free(DNs);
            break;
        case CGenOpt::GEN_DN_UFN:
            strDN = ldap_dn2ufn(dn);
            break;
        default:
            strDN.Empty();
    }

    return strDN;
}






/*+++
Function   :
Description: UI handlers
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnBrowseAdd()
{

    bAdd = TRUE;
    if(GetContextActivation()){
        m_AddDlg->m_Dn = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        m_AddDlg->m_Dn = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }
    m_AddDlg->Create(IDD_ADD);

}



void CLdpDoc::OnUpdateBrowseAdd(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bAdd && bConnected) || !m_bProtect);

}


void CLdpDoc::OnAddEnd(){
    bAdd = FALSE;
}










/*+++
Function   : OnAddGo
Description: Response to ADd request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnAddGo(){

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }

    Out("***Calling Add...", CP_PRN);


    int nMaxEnt = m_AddDlg->GetEntryCount();
    int res;
    LDAPMod *attr[MAXLIST];
    char *p[MAXLIST], *pTok;
    int i, j;
    CString str;
    LPTSTR dn, lpBERVals;

   //
   // traverse & setup attributes
   //
    for(i = 0,
           Out("i=0;", CP_ONLY|CP_SRC);
            i<nMaxEnt;
            i++,
            Out("i++;", CP_ONLY | CP_SRC)){


        attr[i] = (LDAPMod *)malloc(sizeof(LDAPMod));
        ASSERT(attr[i] != NULL);
        Out("mods[i] = (struct ldapmod*)malloc(sizeof(LDAPMod));", CP_ONLY|CP_SRC);

      //
      // add a std value
      //
        if(NULL == (lpBERVals = strstr(LPCTSTR(m_AddDlg->GetEntry(i)), "\\BER(")) &&
         NULL == (lpBERVals = strstr(LPCTSTR(m_AddDlg->GetEntry(i)), "\\UNI"))){

            attr[i]->mod_values =   (char**)malloc(sizeof(char*)*MAXLIST);
            ASSERT(attr[i]->mod_values != NULL);
            Out("mods[i]->mod_values = (char**)malloc(sizeof(char*)*MAXLIST);", CP_ONLY|CP_SRC);

            attr[i]->mod_op = 0;
            Out("mods[i]->mod_op = 0;", CP_ONLY|CP_SRC);

            p[i] = _strdup(LPCTSTR(m_AddDlg->GetEntry(i)));
            ASSERT(p[i] != NULL);
            attr[i]->mod_type = strtok(p[i], ":\n");
            str.Format("mods[i]->mod_type = _strdup(\"%s\");",   attr[i]->mod_type);
            Out(str, CP_ONLY|CP_SRC);

            for(j=0, pTok = strtok(NULL, ";\n");
                            pTok;
                            pTok= strtok(NULL, ";\n"), j++){

                                attr[i]->mod_values[j] = pTok;
                                str.Format("mods[i]->mod_values[%d] = _strdup(\"%s\");",
                                                                                            j, pTok);
                                Out(str, CP_ONLY|CP_SRC);
            }

            attr[i]->mod_values[j] = NULL;
            str.Format("mods[i]->mod_values[%d] = NULL", j);
            Out(str, CP_ONLY|CP_SRC);
        }
        else{
            //
            // Add BER values
            //

            //
            // allocate value array buffer
            //
            attr[i]->mod_bvalues =  (struct berval**)malloc(sizeof(struct berval*)*MAXLIST);
            ASSERT(attr[i]->mod_values != NULL);
            Out("mods[i]->mod_bvalues = (struct berval**)malloc(sizeof(struct berval*)*MAXLIST);",
                                                                                CP_ONLY|CP_SRC);

            //
            // initialize operand
            //
            attr[i]->mod_op = LDAP_MOD_BVALUES;
            Out("mods[i]->mod_op = LDAP_MOD_BVALUES;", CP_ONLY|CP_SRC);

            //
            // set entry attribute
            //
            p[i] = _strdup(LPCTSTR(m_AddDlg->GetEntry(i)));
            ASSERT(p[i] != NULL);
            attr[i]->mod_type = strtok(p[i], ":\n");
            str.Format("mods[i]->mod_type = _strdup(\"%s\");",   attr[i]->mod_type);
            Out(str, CP_ONLY|CP_SRC);

            //
            // parse values
            //
            for(j=0, pTok = strtok(NULL, ";\n");
                            pTok;
                            pTok= strtok(NULL, ";\n"), j++){

                                char fName[MAXSTR];
                                char szVal[MAXSTR];
                                attr[i]->mod_bvalues[j] = (struct berval*)malloc(sizeof(struct berval));
                                ASSERT(attr[i]->mod_bvalues[j] != NULL);

                                if(1 == sscanf(pTok, "\\UNI:%s", szVal)){
                           //
                           // UNICODE
                           //
                           LPWSTR lpWStr=NULL;
                           //
                           // Get UNICODE str size
                           //
                           int cblpWStr = MultiByteToWideChar(CP_ACP,                  // code page
                                                              MB_ERR_INVALID_CHARS,    // return err
                                                              (LPCSTR)szVal,           // input
                                                              -1,                      // null terminated
                                                              lpWStr,                  // converted
                                                              0);                      // calc size
                           if(cblpWStr == 0){
                              attr[i]->mod_bvalues[j]->bv_len = 0;
                              attr[i]->mod_bvalues[j]->bv_val = NULL;
                              Out("Internal Error: MultiByteToWideChar(1): %lu", GetLastError());
                           }
                           else{
                             //
                             // Get UNICODE str
                             //
                             lpWStr = (LPWSTR)malloc(sizeof(WCHAR)*cblpWStr);
                             cblpWStr = MultiByteToWideChar(CP_ACP,                  // code page
                                                            MB_ERR_INVALID_CHARS,    // return err
                                                            (LPCSTR)szVal,           // input
                                                            -1,                      // null terminated
                                                            lpWStr,                  // converted
                                                            cblpWStr);               // size
                             if(cblpWStr == 0){
                                 free(lpWStr);
                                 attr[i]->mod_bvalues[j]->bv_len = 0;
                                 attr[i]->mod_bvalues[j]->bv_val = NULL;
                                 Out("Internal Error: MultiByteToWideChar(2): %lu", GetLastError());
                             }
                             else{
                                //
                                // assign unicode to mods.
                                //
                                attr[i]->mod_bvalues[j]->bv_len = (cblpWStr-1)*2;
                                attr[i]->mod_bvalues[j]->bv_val = (LPTSTR)lpWStr;
                             }
                           }
                        }

                        //
                        // if improper format, just get the string value
                        //
                                else if(1 != sscanf(pTok, "\\BER(%*lu): %s", fName)){
                                    attr[i]->mod_bvalues[j]->bv_len = strlen(pTok);
                                    attr[i]->mod_bvalues[j]->bv_val = _strdup(pTok);

                                }
                                else{
                           //
                           // Get contents from file
                           //
                                    HANDLE hFile;
                                    DWORD dwLength, dwRead;
                                    LPVOID ptr;

                                    hFile = CreateFile(fName,
                                                        GENERIC_READ,
                                                        FILE_SHARE_READ,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                                                        NULL);

                                    if(hFile == INVALID_HANDLE_VALUE){
                                        str.Format("Error <%lu>: Cannot open %s value file. "
                                                    "BER Value %s set to zero.",
                                                                            GetLastError(),
                                                                            fName,
                                                                            attr[i]->mod_type);
                                        AfxMessageBox(str);
                                        attr[i]->mod_bvalues[j]->bv_len = 0;
                                        attr[i]->mod_bvalues[j]->bv_val = NULL;
                                    }
                                    else{

                              //
                              // Read file in
                              //
                                        dwLength = GetFileSize(hFile, NULL);
                                        ptr = malloc(dwLength * sizeof(BYTE));
                                        ASSERT(p != NULL);
                                        if(!ReadFile(hFile, ptr, dwLength, &dwRead, NULL)){
                                            str.Format("Error <%lu>: Cannot read %s value file. "
                                                        "BER Value %s set to zero.",
                                                                            GetLastError(),
                                                                            fName,
                                                                            attr[i]->mod_type);
                                            AfxMessageBox(str);

                                            free(ptr);
                                            ptr = NULL;
                                            attr[i]->mod_bvalues[j]->bv_len = 0;
                                            attr[i]->mod_bvalues[j]->bv_val = NULL;
                                        }
                                        else{
                                            attr[i]->mod_bvalues[j]->bv_len = dwRead;
                                            attr[i]->mod_bvalues[j]->bv_val = (PCHAR)ptr;
                                        }
                                        CloseHandle(hFile);
                                    }
                                    str.Format("mods[i]->mod_bvalues.bv_len = %lu",
                                                    attr[i]->mod_bvalues[j]->bv_len);
                                    Out(str, CP_ONLY|CP_CMT);
                                }
            }


            //
            // finalize values array
            //
            attr[i]->mod_bvalues[j] = NULL;
            str.Format("mods[i]->mod_bvalues[%d] = NULL", j);
            Out(str, CP_ONLY|CP_SRC);
        }

    }

    //
    // Finalize attribute array
    //
    attr[i]  = NULL;
    str.Format("mods[%d] = NULL", i);
    Out(str, CP_ONLY|CP_SRC);


    //
    // prepare dn
    //
    dn = m_AddDlg->m_Dn.IsEmpty() ? NULL : (char*)LPCTSTR(m_AddDlg->m_Dn);
    if(dn != NULL){
        str.Format("dn = _strdup(\"%s\");", dn);
    }
    else
        str = "dn = NULL;";
    Out(str, CP_ONLY|CP_SRC);



    //
    // Execute ldap_add & friends
    //
    if(m_AddDlg->m_Sync){

        //
        //  Sync add
        //
            BeginWaitCursor();
            if(m_AddDlg->m_bExtended){
                PLDAPControl *SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
                PLDAPControl *ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);

                str.Format("ldap_add_ext_s(ld, '%s',[%d] attrs, SvrCtrls, ClntCtrls);", dn, i);
                Out(str);
                res = ldap_add_ext_s(hLdap, dn, attr, SvrCtrls, ClntCtrls);

                FreeControls(SvrCtrls);
                FreeControls(ClntCtrls);
            }
            else{
                str.Format("ldap_add_s(ld, \"%s\", [%d] attrs)", dn, i);
                Out(str);
                res = ldap_add_s(hLdap, dn, attr);
            }
            EndWaitCursor();
            if(res != LDAP_SUCCESS){
                str.Format("Error: Add: %s. <%ld>", ldap_err2string(res), res);
                Out(str, CP_CMT);
                Out(CString("Expected: ") + str, CP_PRN|CP_ONLY);
            }
            else{
                str.Format("Added {%s}.", dn);
                Out(str, CP_PRN);
            }
    }
    else{

        //
        // Async add
        //
            res = ldap_add(hLdap,
                                            dn,
                                            attr);
            Out("ldap_add(ld, dn, mods);", CP_ONLY|CP_SRC);

            if(res == -1){
                str.Format("Error: ldap_add(\"%s\"): %s. <%d>",
                                        dn,
                                        ldap_err2string(res), res);
                Out(str, CP_CMT);
                Out(CString("Expected: ") + str, CP_PRN|CP_ONLY);
            }
            else{
            //
            // add to pending list
            //
                CPend pnd;
                pnd.mID = res;
                pnd.OpType = CPend::P_ADD;
                pnd.ld = hLdap;
                str.Format("%4d: ldap_add: dn={%s}",
                                        res,
                                        dn);
                Out(str, CP_PRN|CP_ONLY);
                pnd.strMsg = str;
                m_PendList.AddTail(pnd);
                m_PndDlg->Refresh(&m_PendList);
                Out("\tPending.", CP_PRN);
            }
    }


    //
    // restore memory
    //
    for(i=0; i<nMaxEnt; i++){
        int k;

        free(p[i]);
        if(attr[i]->mod_op & LDAP_MOD_BVALUES){
            for(k=0; attr[i]->mod_bvalues[k] != NULL; k++){
                if(attr[i]->mod_bvalues[k]->bv_len != 0L)
                    free(&(attr[i]->mod_bvalues[k]->bv_val[0]));
                free(attr[i]->mod_bvalues[k]);
                str.Format("free(mods[%d]->mod_bvalues[%d]);", i,k);
                Out(str, CP_ONLY|CP_SRC);
            }
        }
        else{
            for(k=0; attr[i]->mod_values[k] != NULL; k++){
                str.Format("free(mods[%d]->mod_values[%d]);", i,k);
                Out(str, CP_ONLY|CP_SRC);
            }
        }


        if(attr[i]->mod_op & LDAP_MOD_BVALUES){
            free(attr[i]->mod_bvalues);
        }
        else{
            free(attr[i]->mod_values);
            str.Format("free(mods[%d]->mod_values);", i);
            Out(str, CP_ONLY|CP_SRC);
        }

        free(attr[i]);
        str.Format("free(mods[%d]);", i);
        Out(str, CP_ONLY|CP_SRC);
    }

    Out("-----------", CP_PRN);

}






/*+++
Function   : OnBrowseDelete
Description: response to delete request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnBrowseDelete()
{
    DelDlg dlg;
    char *dn;
    CString str;
    int res;

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }


    if(GetContextActivation()){
        dlg.m_Dn = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        dlg.m_Dn = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }


    if(IDOK == dlg.DoModal()){
        // Try to delete entry
        dn = dlg.m_Dn.IsEmpty() ? NULL : (char*)LPCTSTR(dlg.m_Dn);

        //
        // RM: remove for invalid validation
        //
        if(dn == NULL && m_bProtect){
            AfxMessageBox("Cannot execute ldap_delete() on a NULL dn."
                                              "Please specify a valid dn.");
            return;
        }


      if(dlg.m_Recursive){
            str.Format("deleting \"%s\"...", dn);
            Out(str);
             m_ulDeleted = 0;
            BeginWaitCursor();
                RecursiveDelete(hLdap, dn);
            EndWaitCursor();
            str.Format("\tdeleted %lu entries", m_ulDeleted);
            Out(str);

      }
        else if(dlg.m_Sync){

         //
         // sync delete
         //
            BeginWaitCursor();
            if(dlg.m_bExtended){
                //
                // get controls
                //
                PLDAPControl *SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
                PLDAPControl *ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);

                str.Format("ldap_delete_ext_s(ld, '%s', SvrCtrls, ClntCtrls);", dn);
                Out(str);

                // do ext delete
                res = ldap_delete_ext_s(hLdap, dn, SvrCtrls, ClntCtrls);

                FreeControls(SvrCtrls);
                FreeControls(ClntCtrls);
            }
            else{
                str.Format("ldap_delete_s(ld, \"%s\");", dn);
                Out(str);
                // do delete
                res = ldap_delete_s(hLdap, dn);
            }
            EndWaitCursor();

            if(res != LDAP_SUCCESS){
                str.Format("Error: Delete: %s. <%ld>", ldap_err2string(res), res);
                Out(str, CP_CMT);
                Out(CString("Expected: ") + str, CP_PRN|CP_ONLY);
            }
            else{
                str.Format("Deleted \"%s\"", dn);
                Print(str);
            }
        }
        else{

         //
         // async delete
         //
            res = ldap_delete(hLdap, dn);
            str.Format("ldap_delete(ld, \"%s\");", dn);
            Out(str, CP_SRC);

            if(res == -1){
                str.Format("Error: ldap_delete(\"%s\"): %s. <%d>",
                                        dn,
                                        ldap_err2string(res), res);
                Out(str, CP_CMT);
                Out(CString("Expected: ") + str, CP_PRN|CP_ONLY);
            }
            else{

            //
            // add to pending
            //
                CPend pnd;
                pnd.mID = res;
                pnd.OpType = CPend::P_DEL;
                pnd.ld = hLdap;
                str.Format("%4d: ldap_delete: dn= {%s}",    res, dn);
                Out(str, CP_PRN|CP_ONLY);
                pnd.strMsg = str;
                m_PendList.AddTail(pnd);
                m_PndDlg->Refresh(&m_PendList);
                Out("\tPending.", CP_PRN);
            }


        }
    }
    Out("-----------", CP_PRN);
}

void CLdpDoc::OnUpdateBrowseDelete(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(bConnected || !m_bProtect);

}



/*+++
Function   : RecursiveDelete
Description: delete a subtree based on lpszDN
Parameters : ld: a bound ldap handle, lpszDN: base from which to start deletion
Return     :
Remarks    : none.
---*/
BOOL CLdpDoc::RecursiveDelete(LDAP* ld, LPTSTR lpszDN){


   ULONG err;
   PCHAR attrs[] = { "Arbitrary Invalid Attribute", NULL };
   PLDAPMessage result;
   PLDAPMessage entry;
   CString str;
   BOOL bRet = TRUE;


   //
   // get entry's immediate children
   //
   err = ldap_search_s(ld,
                       lpszDN,
                       LDAP_SCOPE_ONELEVEL,
                       "objectClass=*",
                       attrs,
                       FALSE,
                       &result);

   if(LDAP_SUCCESS != err){


         //
         // report failure
         //
         str.Format("Error <%lu>: failed to search '%s'. {%s}.\n", err, lpszDN, ldap_err2string(err));
         Out(str);
         return FALSE;
   }




   //
   // recursion end point and actual deletion
   //
   if(0 == ldap_count_entries(ld, result)){

      //
      // delete entry
      //
      err = ldap_delete_s(ld, lpszDN);

      if(err != LDAP_SUCCESS){


         //
         // report failure
         //
         str.Format("Error <%lu>: failed to delete '%s'. {%s}.", err, lpszDN, ldap_err2string(err));
         Out(str);

      }
      else{
         m_ulDeleted++;
         if((m_ulDeleted % 10) == 0 && m_ulDeleted != 0){
            str.Format("\t>> %lu...", m_ulDeleted);
            Out(str);
         }

      }

      //
      // done
      //
      ldap_msgfree(result);
      return TRUE;
   }


   //
   // proceeding down the subtree recursively
   // traverse children
   //
   for(entry = ldap_first_entry(ld, result);
      entry != NULL;
      entry = ldap_next_entry(ld, entry)){

         if(!RecursiveDelete(ld, ldap_get_dn(ld, entry))){

            ldap_msgfree(result);
            return FALSE;
         }
   }


   //
   // now delete current node
   //

   err = ldap_delete_s(ld, lpszDN);

   if(err != LDAP_SUCCESS){



     //
     // report failure
     //
     str.Format("Error <%lu>: failed to delete '%s'. {%s}.\n", err, lpszDN, ldap_err2string(err));
     Out(str);

  }
  else{
     m_ulDeleted++;
     if((m_ulDeleted % 10) == 0 && m_ulDeleted != 0){
        str.Format("\t>> %lu...", m_ulDeleted);
        Out(str);
     }
  }

   ldap_msgfree(result);

   return TRUE;
}




/*+++
Function   : OnModRdnEnd
Description: UI response
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnModRdnEnd(){
    bModRdn = FALSE;
}





/*+++
Function   : OnModRdnGo
Description: response to modRDN request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnModRdnGo(){

    if((m_ModRdnDlg->m_Old.IsEmpty() ||
        m_ModRdnDlg->m_Old.IsEmpty()) &&
        !m_bProtect){
            AfxMessageBox("Please enter a valid dn for both fields. Empty strings are invalid");
            return;
    }

   //
   // get DNs to process
   //
    char *oldDn = (char*)LPCTSTR(m_ModRdnDlg->m_Old);
    char * newDn = (char*)LPCTSTR(m_ModRdnDlg->m_New);
    BOOL bRename = m_ModRdnDlg->m_rename;
    int res;
    CString str;

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }



    if(m_ModRdnDlg->m_Sync){
         //
         // do sync
         //
                        BeginWaitCursor();
                        if(bRename){
                                //
                                // parse new DN & break into RDN & new parent
                                //
                                LPTSTR szParentDn = strchr(newDn, ',');

                                for (;;) {
                                    if (NULL == szParentDn) {
                                        // There are no comma's
                                        break;
                                    }
                                    if (szParentDn == newDn) {
                                        // The first character is a comma.
                                        // This shouldn't happen.
                                        break;
                                    }
                                    if ('\\' != *(szParentDn - 1)) {
                                        //
                                        // Found it!  And it's not escaped either.
                                        //
                                        break;
                                    }
                                    //
                                    // Must have been an escaped comma, continue
                                    // looking.
                                    //
                                    szParentDn = strchr(szParentDn + 1, ',');
                                }

                                if(szParentDn != NULL){
                                        LPTSTR p = szParentDn;
                                        if(&(szParentDn[1]) != NULL && szParentDn[1] != '\0')
                                                szParentDn++;
                                        *p = '\0';
                                }
                                LPTSTR szRdn = newDn;

                //
                // get controls
                //
                PLDAPControl *SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
                PLDAPControl *ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);
                // execute
                res = ldap_rename_ext_s(hLdap,
                                        oldDn,
                                        szRdn,
                                        szParentDn,
                                        m_ModRdnDlg->m_bDelOld,
                                        SvrCtrls,
                                        ClntCtrls);
                str.Format("0x%x = ldap_rename_ext_s(ld, %s, %s, %s, %s, svrCtrls, ClntCtrls)",
                    res, oldDn, szRdn, szParentDn,
                    m_ModRdnDlg->m_bDelOld?"TRUE":FALSE);
                Out(str);

                FreeControls(SvrCtrls);
                FreeControls(ClntCtrls);
            }
            else{

                res = ldap_modrdn2_s(hLdap,
                                            oldDn,
                                            newDn,
                                            m_ModRdnDlg->m_bDelOld);
                str.Format("0x%x = ldap_modrdn2_s(ld, %s, %s, %s)",
                    res, oldDn, newDn,
                    m_ModRdnDlg->m_bDelOld?"TRUE":FALSE);
            Out(str);
            }
            EndWaitCursor();

            if(res != LDAP_SUCCESS){
                str.Format("Error: ModifyRDN: %s. <%ld>", ldap_err2string(res), res);
                Print(str);\
            }
            else{
                str.Format("Rdn \"%s\" modified to \"%s\"", oldDn, newDn);
                Print(str);
            }
    }
    else{

         //
         // do async
         //

                if(bRename){
                        //
                        // parse new DN & break into RDN & new parent
                        //
                        LPTSTR szParentDn = strchr(newDn, ',');

                        for (;;) {
                            if (NULL == szParentDn) {
                                // There are no comma's
                                break;
                            }
                            if (szParentDn == newDn) {
                                // The first character is a comma.
                                // This shouldn't happen.
                                break;
                            }
                            if ('\\' != *(szParentDn - 1)) {
                                //
                                // Found it!  And it's not escaped either.
                                //
                                break;
                            }
                            //
                            // Must have been an escaped comma, continue
                            // looking.
                            //
                            szParentDn = strchr(szParentDn + 1, ',');
                        }
                        if(szParentDn != NULL){
                                LPTSTR p = szParentDn;
                                if(&(szParentDn[1]) != NULL && szParentDn[1] != '\0')
                                        szParentDn++;
                                *p = '\0';
                        }
                        LPTSTR szRdn = newDn;

            //
            // get controls
            //
            PLDAPControl *SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
            PLDAPControl *ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);
            ULONG ulMsgId=0;
            // execute
            res = ldap_rename_ext(hLdap,
                                    oldDn,
                                    szRdn,
                                    szParentDn,
                                    m_ModRdnDlg->m_bDelOld,
                                    SvrCtrls,
                                    ClntCtrls,
                                    &ulMsgId);
            str.Format("0x%x = ldap_rename_ext(ld, %s, %s, %s, %s, svrCtrls, ClntCtrls, 0x%x)",
                res, oldDn, szRdn, szParentDn,
                m_ModRdnDlg->m_bDelOld?"TRUE":FALSE, ulMsgId);
            Out(str);
            FreeControls(SvrCtrls);
            FreeControls(ClntCtrls);

            if(res == -1){
                ULONG err = LdapGetLastError();
                str.Format("Error: ldap_rename_ext(\"%s\", \"%s\", %d): %s. <%d>",
                                        oldDn, newDn, m_ModRdnDlg->m_bDelOld,
                                        ldap_err2string(err), err);
                Print(str);
            }
            else
                res = (int)ulMsgId;
        }
        else{
            res = ldap_modrdn2(hLdap,
                                        oldDn,
                                        newDn,
                                        m_ModRdnDlg->m_bDelOld);
            str.Format("0x%x = ldap_modrdn2(ld, %s, %s, )",
                res, oldDn, newDn, m_ModRdnDlg->m_bDelOld?"TRUE":FALSE);
            Out(str);
            if(res == -1){
                ULONG err = LdapGetLastError();
                str.Format("Error: ldap_modrdn2(\"%s\", \"%s\", %d): %s. <%d>",
                                        oldDn, newDn, m_ModRdnDlg->m_bDelOld,
                                        ldap_err2string(err), err);
                Print(str);
            }
        }

        //
        // insert into pending list
        //


        if(res != -1){

            CPend pnd;
            pnd.mID = res;
            pnd.OpType = CPend::P_MODRDN;
            pnd.ld = hLdap;
            str.Format("%4d: ldap_modrdn: dn=\"%s\"",   res, oldDn);
            pnd.strMsg = str;
            m_PendList.AddTail(pnd);
            m_PndDlg->Refresh(&m_PendList);
            Print("\tPending.");
        }
    }


    Print("-----------");
}




/*+++
Function   : UI handlers
Description:
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnBrowseModifyrdn()
{
    bModRdn = TRUE;

    if(GetContextActivation()){
        m_ModRdnDlg->m_Old = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        m_ModRdnDlg->m_Old = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }

    m_ModRdnDlg->Create(IDD_MODRDN);

}

void CLdpDoc::OnUpdateBrowseModifyrdn(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bModRdn && bConnected) || !m_bProtect);
}




void CLdpDoc::OnModEnd(){

    bMod = FALSE;

}







/*+++
Function   : OnModGo
Description: Handle Modify request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnModGo(){

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }

    Print("***Call Modify...");


    int nMaxEnt = m_ModDlg->GetEntryCount();
    LDAPMod *attr[MAXLIST];
    char *p[MAXLIST], *pTok;
    int i, j, k;
    CString str;
    CString  sAttr, sVals;
    int Op, res;
    LPTSTR dn;

   //
   // traverse entries
   //
    for(i = 0; i<nMaxEnt; i++){

      //
      // fix to fit document format (as opposed to dialog format)
      //
        m_ModDlg->FormatListString(i, sAttr, sVals, Op);

      //
      // alloc mem
      //
        attr[i] = (LDAPMod *)malloc(sizeof(LDAPMod));
        if(NULL == attr[i]){
            AfxMessageBox("Error: Out of memory", MB_ICONHAND);
            ASSERT(attr[i] != NULL);
            return;
        }

      //
      // add string values
      //
        if(NULL == strstr(LPCTSTR(m_ModDlg->GetEntry(i)), "\\BER(") &&
         NULL == strstr(LPCTSTR(m_ModDlg->GetEntry(i)), "\\UNI")){

            attr[i]->mod_values =   (char**)malloc(sizeof(char*)*MAXLIST);
            ASSERT(attr[i]->mod_values != NULL);

            attr[i]->mod_op = Op == MOD_OP_ADD ? LDAP_MOD_ADD :
                                                 Op == MOD_OP_DELETE ? LDAP_MOD_DELETE :
                                                 LDAP_MOD_REPLACE;
            attr[i]->mod_type = _strdup(LPCTSTR(sAttr));
            if(sVals.IsEmpty())
                p[i] = NULL;
            else{
                p[i] = _strdup(LPCTSTR(sVals));
                ASSERT(p[i] != NULL);
            }
            if(p[i] == NULL){
                free(attr[i]->mod_values);
                attr[i]->mod_values = NULL;
            }
            else{
                for(j=0, pTok = strtok(p[i], ";\n");
                                pTok;
                                pTok= strtok(NULL, ";\n"), j++){

                                    attr[i]->mod_values[j] = pTok;
                }
                attr[i]->mod_values[j] = NULL;
            }
        }
        else{
            //
            // BER values
            //

            //
            // allocate value array buffer
            //
            attr[i]->mod_bvalues =  (struct berval**)malloc(sizeof(struct berval*)*MAXLIST);
            ASSERT(attr[i]->mod_values != NULL);
            Out("mods[i]->mod_bvalues = (struct berval**)malloc(sizeof(struct berval*)*MAXLIST);",
                                                                                CP_ONLY|CP_SRC);

            //
            // initialize operand
            //
            attr[i]->mod_op = Op == MOD_OP_ADD ? LDAP_MOD_ADD :
                                                 Op == MOD_OP_DELETE ? LDAP_MOD_DELETE :
                                                 LDAP_MOD_REPLACE;
            attr[i]->mod_op |= LDAP_MOD_BVALUES;
            str.Format("mods[i]->mod_op = %d;", attr[i]->mod_op);
            Out(str, CP_ONLY|CP_SRC);

            //
            // Fill attribute type
            //
            attr[i]->mod_type = _strdup(LPCTSTR(sAttr));

            //
            // Null out values if empty
            //
            if(sVals.IsEmpty())
                p[i] = NULL;
            else{
                p[i] = _strdup(LPCTSTR(sVals));
                ASSERT(p[i] != NULL);
            }
            if(p[i] == NULL){
                free(attr[i]->mod_bvalues);
                attr[i]->mod_bvalues = NULL;
            }
            else{
                for(j=0, pTok = strtok(p[i], ";\n");
                                pTok;
                                pTok= strtok(NULL, ";\n"), j++){

                                    attr[i]->mod_values[j] = pTok;

                                char fName[MAXSTR];
                                char szVal[MAXSTR];
                                attr[i]->mod_bvalues[j] = (struct berval*)malloc(sizeof(struct berval));
                                ASSERT(attr[i]->mod_bvalues[j] != NULL);

                                if(1 == sscanf(pTok, "\\UNI:%s", szVal)){
                           //
                           // UNICODE?
                           //
                           LPWSTR lpWStr=NULL;
                           //
                           // Get UNICODE str size
                           //
                           int cblpWStr = MultiByteToWideChar(CP_ACP,                  // code page
                                                              MB_ERR_INVALID_CHARS,    // return err
                                                              (LPCSTR)szVal,           // input
                                                              -1,                      // null terminated
                                                              lpWStr,                  // converted
                                                              0);                      // calc size
                           if(cblpWStr == 0){
                              attr[i]->mod_bvalues[j]->bv_len = 0;
                              attr[i]->mod_bvalues[j]->bv_val = NULL;
                              Out("Internal Error: MultiByteToWideChar(1): %lu", GetLastError());
                           }
                           else{
                             //
                             // Get UNICODE str
                             //
                             lpWStr = (LPWSTR)malloc(sizeof(WCHAR)*cblpWStr);
                             cblpWStr = MultiByteToWideChar(CP_ACP,                  // code page
                                                            MB_ERR_INVALID_CHARS,    // return err
                                                            (LPCSTR)szVal,           // input
                                                            -1,                      // null terminated
                                                            lpWStr,                  // converted
                                                            cblpWStr);               // size
                             if(cblpWStr == 0){
                                 free(lpWStr);
                                 attr[i]->mod_bvalues[j]->bv_len = 0;
                                 attr[i]->mod_bvalues[j]->bv_val = NULL;
                                 Out("Internal Error: MultiByteToWideChar(2): %lu", GetLastError());
                             }
                             else{
                                //
                                // assign unicode to mods.
                                //
                                attr[i]->mod_bvalues[j]->bv_len = (cblpWStr-1)*2;
                                attr[i]->mod_bvalues[j]->bv_val = (LPTSTR)lpWStr;
                             }
                           }
                        }
                        //
                        // if improper format get string equiv
                        //
                                else if(1 != sscanf(pTok, "\\BER(%*lu): %s", fName)){
                                    attr[i]->mod_bvalues[j]->bv_len = strlen(pTok);
                                    attr[i]->mod_bvalues[j]->bv_val = _strdup(pTok);

                                }
                                else{
                           //
                           // open file
                           //
                                    HANDLE hFile;
                                    DWORD dwLength, dwRead;
                                    LPVOID ptr;

                                    hFile = CreateFile(fName,
                                                        GENERIC_READ,
                                                        FILE_SHARE_READ,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                                                        NULL);

                                    if(hFile == INVALID_HANDLE_VALUE){
                                        str.Format("Error <%lu>: Cannot open %s value file. "
                                                    "BER Value %s set to zero.",
                                                                            GetLastError(),
                                                                            fName,
                                                                            attr[i]->mod_type);
                                        AfxMessageBox(str);
                                        attr[i]->mod_bvalues[j]->bv_len = 0;
                                        attr[i]->mod_bvalues[j]->bv_val = NULL;
                                    }
                                    else{

                              //
                              // read file
                              //
                                        dwLength = GetFileSize(hFile, NULL);
                                        ptr = malloc(dwLength * sizeof(BYTE));
                                        ASSERT(p != NULL);
                                        if(!ReadFile(hFile, ptr, dwLength, &dwRead, NULL)){
                                            str.Format("Error <%lu>: Cannot read %s value file. "
                                                        "BER Value %s set to zero.",
                                                                            GetLastError(),
                                                                            fName,
                                                                            attr[i]->mod_type);
                                            AfxMessageBox(str);

                                            free(ptr);
                                            ptr = NULL;
                                            attr[i]->mod_bvalues[j]->bv_len = 0;
                                            attr[i]->mod_bvalues[j]->bv_val = NULL;
                                        }
                                        else{
                                            attr[i]->mod_bvalues[j]->bv_len = dwRead;
                                            attr[i]->mod_bvalues[j]->bv_val = (PCHAR)ptr;
                                        }
                                        CloseHandle(hFile);
                                    }
                                    str.Format("mods[i]->mod_bvalues.bv_len = %lu",
                                                    attr[i]->mod_bvalues[j]->bv_len);
                                    Out(str, CP_ONLY|CP_CMT);
                                }
                }       // for all values loop


                //
                // finalize values array
                //
                attr[i]->mod_bvalues[j] = NULL;
                str.Format("mods[i]->mod_bvalues[%d] = NULL", j);
                Out(str, CP_ONLY|CP_SRC);
            }       // else of empty attr spec
        }           // BER values
    }               // for all attributes

    //
    // finalize attribute array
    //
    attr[i]  = NULL;


   //
   // Execute modify calls
   //
    dn = m_ModDlg->m_Dn.IsEmpty() ? NULL : (char*)LPCTSTR(m_ModDlg->m_Dn);
    if(m_ModDlg->m_Sync){
            BeginWaitCursor();
            if(m_ModDlg->m_bExtended){
                //
                // get controls
                //
                PLDAPControl *SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
                PLDAPControl *ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);

                str.Format("ldap_modify_ext_s(ld, '%s',[%d] attrs, SvrCtrls, ClntCtrls);", dn, i);
                Out(str);
                res = ldap_modify_ext_s(hLdap, dn, attr, SvrCtrls, ClntCtrls);

                FreeControls(SvrCtrls);
                FreeControls(ClntCtrls);
            }
            else{
                str.Format("ldap_modify_s(ld, '%s',[%d] attrs);", dn, i);
                Print(str);
                res = ldap_modify_s(hLdap,dn,attr);
            }

            EndWaitCursor();

            if(res != LDAP_SUCCESS){
                str.Format("Error: Modify: %s. <%ld>", ldap_err2string(res), res);
                Print(str);

            }
            else{
                str.Format("Modified \"%s\".", m_ModDlg->m_Dn);
                Print(str);
            }
    }
    else{

         //
         // async call
         //
            res = ldap_modify(hLdap,
                                                    dn,
                                                    attr);
            if(res == -1){
                str.Format("Error: ldap_modify(\"%s\"): %s. <%d>",
                                        dn,
                                        ldap_err2string(res), res);
                Print(str);
            }
            else{

            //
            // add to pending
            //
                CPend pnd;
                pnd.mID = res;
                pnd.OpType = CPend::P_MOD;
                pnd.ld = hLdap;
                str.Format("%4d: ldap_modify: dn=\"%s\"",   res, dn);
                pnd.strMsg = str;
                m_PendList.AddTail(pnd);
                m_PndDlg->Refresh(&m_PendList);
                Print("\tPending.");
            }

    }



   //
   // restore memory
   //
    for(i=0; i<nMaxEnt; i++){
        if(p[i] != NULL)
            free(p[i]);
        if(attr[i]->mod_type != NULL)
            free(attr[i]->mod_type );
        if(attr[i]->mod_op & LDAP_MOD_BVALUES){
            for(k=0; attr[i]->mod_bvalues[k] != NULL; k++){
                if(attr[i]->mod_bvalues[k]->bv_len != 0L)
                    free(&(attr[i]->mod_bvalues[k]->bv_val[0]));
                free(attr[i]->mod_bvalues[k]);
                str.Format("free(mods[%d]->mod_bvalues[%d]);", i,k);
                Out(str, CP_ONLY|CP_SRC);
            }
            free(attr[i]->mod_bvalues);
        }
        else{
            if(attr[i]->mod_values != NULL)
                free(attr[i]->mod_values);
        }
        free(attr[i]);
    }

    Print("-----------");
}





/*+++
Function   :
Description: UI handlers
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnBrowseModify()
{

    bMod = TRUE;
    if(GetContextActivation()){
        m_ModDlg->m_Dn = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        m_ModDlg->m_Dn = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }

    m_ModDlg->Create(IDD_MODIFY);

}

void CLdpDoc::OnUpdateBrowseModify(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bMod && bConnected) || !m_bProtect);

}

void CLdpDoc::OnOptionsSearch()
{

    if(IDOK == SrchOptDlg.DoModal())
        SrchOptDlg.UpdateSrchInfo(SrchInfo, TRUE);

}

void CLdpDoc::OnBrowsePending()
{
    bPndDlg = TRUE;
    m_PndDlg->Create(IDD_PEND);

}

void CLdpDoc::OnUpdateBrowsePending(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bPndDlg && (bConnected || !m_BndOpt->m_bSync)) || !m_bProtect);

}



void CLdpDoc::OnPendEnd(){

    bPndDlg = FALSE;
}





void CLdpDoc::OnOptionsPend()
{
    PndOpt dlg;
    if(IDOK == dlg.DoModal()){
        PndInfo.All = dlg.m_bAllSearch;
        PndInfo.bBlock = dlg.m_bBlock;
        PndInfo.tv.tv_sec = dlg.m_Tlimit_sec;
        PndInfo.tv.tv_usec = dlg.m_Tlimit_usec;
    }
}








/*+++
Function   : OnProcPend
Description: Process pending requests
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnProcPend(){


    Out("*** Processing Pending...", CP_CMT);
    if(m_PndDlg->posPending != NULL){
      //
      // Get current pending from dialog storage
      //
        CPend pnd  = m_PendList.GetAt(m_PndDlg->posPending);
        CString str;
        int res;
        LDAPMessage *msg;

        str.Format("ldap_result(ld, %d, %d, &tv, &msg)", pnd.mID, PndInfo.All);
        Out(str, CP_SRC);
      //
      // execute ldap result
      //
        BeginWaitCursor();
        res = ldap_result(hLdap,
                          pnd.mID,
                          PndInfo.All,
                          &PndInfo.tv,
                          &msg);
        EndWaitCursor();

      //
      // process result
      //
        HandleProcResult(res, msg, &pnd);
    }
    else{
        AfxMessageBox("Error: Tried to process an invalid pending request");
    }
}



/*+++
Function   : OnPendAny
Description: Process any pending result
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnPendAny()
{

    CString str;
    int res;
    LDAPMessage *msg;

    Out("*** Processing Pending...", CP_CMT);
    str.Format("ldap_result(ld, %d, %d, &tv, &msg)", LDAP_RES_ANY, PndInfo.All);
    Out(str, CP_SRC);
    BeginWaitCursor();
    res = ldap_result(hLdap,
                                        (ULONG)LDAP_RES_ANY,
                                        PndInfo.All,
                                        &PndInfo.tv,
                                        &msg);
    EndWaitCursor();

    HandleProcResult(res, msg);

}




/*+++
Function   : OnPendAbandon
Description: execute abandon request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnPendAbandon(){


    Out("*** Abandon pending", CP_CMT);
    CPend pnd;
    CString str;
    int mId;

    if(m_PndDlg->posPending == NULL)
        mId = 0;
    else{
        pnd = m_PendList.GetAt(m_PndDlg->posPending);
        mId = pnd.mID;
    }

    str.Format("ldap_abandon(ld, %d)", mId);
    Out(str);
    if (LDAP_SUCCESS != ldap_abandon(hLdap, mId))
        AfxMessageBox("ldap_abandon() failed!");

}










/*+++
Function   : HandleProcResults
Description: Process executed pending request
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::HandleProcResult(int res, LDAPMessage *msg, CPend *pnd){


    CString str;


    ParseResults(msg);

    switch(res){

    case 0:
        Out(">Timeout", CP_PRN);
        ldap_msgfree(msg);
        break;

    case -1:
        res = ldap_result2error(hLdap, msg, TRUE);
        str.Format("Error: ldap_result: %s <%X>", ldap_err2string(res), res);
        Out(str);
        break;

    default:
        str.Format("result code: %s <%X>",
                                                            res == LDAP_RES_BIND ? "LDAP_RES_BIND" :
                                                            res ==  LDAP_RES_SEARCH_ENTRY ? "LDAP_RES_SEARCH_ENTRY" :
                                                            res ==  LDAP_RES_SEARCH_RESULT ? "LDAP_RES_SEARCH_RESULT" :
                                                            res ==  LDAP_RES_MODIFY ? "LDAP_RES_MODIFY" :
                                                            res ==  LDAP_RES_ADD ? "LDAP_RES_ADD" :
                                                            res ==  LDAP_RES_DELETE ? "LDAP_RES_DELETE" :
                                                            res ==  LDAP_RES_MODRDN ? "LDAP_RES_MODRDN" :
                                                            res ==  LDAP_RES_COMPARE ? "LDAP_RES_COMPARE": "UNKNOWN!",
                                                            res);
        Out(str, CP_PRN);

        switch(res){
            case LDAP_RES_BIND:
                res = ldap_result2error(hLdap, msg, TRUE);
                if(res != LDAP_SUCCESS){
                    str.Format("Error:  %s <%d>", ldap_err2string(res), res);
                    Out(str, CP_PRN);
                }
                else{
                    str.Format("Authenticated bind request #%lu.", pnd != NULL ? pnd->mID : LDAP_RES_ANY);
                    Out(str, CP_PRN);
//                  AfxMessageBox("Connection established.");
                }
                break;
            case LDAP_RES_SEARCH_ENTRY:
            case LDAP_RES_SEARCH_RESULT:
                DisplaySearchResults(msg);
                break;
            case LDAP_RES_ADD:
                res = ldap_result2error(hLdap, msg, TRUE);
                if(res != LDAP_SUCCESS){
                    str.Format("Error:  %s <%d>", ldap_err2string(res), res);
                    Out(str, CP_PRN);
                }
                str.Format(">completed: %s", pnd != NULL ? pnd->strMsg : "ANY");
                Print(str);
                break;
            case LDAP_RES_DELETE:
                res = ldap_result2error(hLdap, msg, TRUE);
                if(res != LDAP_SUCCESS){
                    str.Format("Error:  %s <%d>", ldap_err2string(res), res);
                    Out(str, CP_PRN);
                }
                str.Format(">completed: %s", pnd != NULL ? pnd->strMsg : "ANY");
                Out(str, CP_PRN);
                break;
            case LDAP_RES_MODIFY:
                res = ldap_result2error(hLdap, msg, TRUE);
                if(res != LDAP_SUCCESS){
                    str.Format("Error:  %s <%d>", ldap_err2string(res), res);
                    Out(str, CP_PRN);
                }
                str.Format(">completed: %s", pnd != NULL ? pnd->strMsg : "ANY");
                Out(str, CP_PRN);
                break;
            case LDAP_RES_MODRDN:
                res = ldap_result2error(hLdap, msg, TRUE);
                if(res != LDAP_SUCCESS){
                    str.Format("Error:  %s <%d>", ldap_err2string(res), res);
                    Out(str, CP_PRN);
                }
                str.Format(">completed: %s", pnd != NULL ? pnd->strMsg : "ANY");
                Out(str, CP_PRN);
                break;
            case LDAP_RES_COMPARE:
                res = ldap_result2error(hLdap, msg, TRUE);
                if(res == LDAP_COMPARE_TRUE){
                    str.Format("Results: TRUE. <%lu>", res);
                    Out(str, CP_PRN);
                }
                else if(res == LDAP_COMPARE_FALSE){
                    str.Format("Results: FALSE. <%lu>", res);
                    Out(str, CP_PRN);
                }
                else{
                    str.Format("Error: ldap_compare(): %s. <%lu>", ldap_err2string(res), res);
                    Out(str, CP_PRN);

                }
                break;
        }

    }
}







/*+++
Function   : PrintHeader
Description: Print C header for source view
Parameters :
Return     :
Remarks    : Source view is unsupported anymore
---*/
void CLdpDoc::PrintHeader(void){

        if(m_SrcMode){
            Out("/**********************************************/");
            Out("/* Ldap Automated Scenario Recording */");
            Out("/**********************************************/");
            Out("");
            Out("includes", CP_CMT);
            Out("#include <stdio.h>");
            Out("#include \"lber.h\"");
            Out("#include \"ldap.h\"");
            Out("");
            Out("definitions", CP_CMT);
            Out("#define MAXSTR\t\t512");
            Out("");
            Out("Global Variables", CP_CMT);
            Out("LDAP *ld;\t\t//ldap connection handle");
            Out("int res;\t\t//generic return variable");
            Out("char *attrList[MAXSTR];\t//generic attributes list (search)");
            Out("LDAPMessage *msg;\t//generic ldap message place holder");
            Out("struct timeval tm;\t//for time limit on search");
            Out("char *dn;\t//generic 'dn' place holder");
            Out("void *ptr;\t//generic pointer");
            Out("char *attr, **val;\t//a pointer to list of attributes, & values traversal helper");
            Out("LDAPMessage *nxt;\t//result traversal helper");
            Out("int i;\t//generic index traversal");
            Out("LDAPMod *mods[MAXLIST];\t//global LDAPMod space");
            Out("");
            Out("");
            Out("int main(void){");
            Out("");
        }
}





/*+++
Function   : UI handlers
Description:
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnViewSource()
{
    m_SrcMode = ~m_SrcMode;

}

void CLdpDoc::OnUpdateViewSource(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_SrcMode ? 1 : 0);
}

void CLdpDoc::OnOptionsBind()
{
    m_BndOpt->DoModal();
}

void CLdpDoc::OnOptionsProtections()
{
    m_bProtect = !m_bProtect;

}

void CLdpDoc::OnUpdateOptionsProtections(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bProtect ? 1 : 0);

}


void CLdpDoc::OnOptionsGeneral()
{
    m_GenOptDlg->DoModal();

}




void CLdpDoc::OnCompEnd(){

    bCompDlg = FALSE;


}




/*+++
Function   : OnCompGo
Description: ldap_compare execution
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnCompGo(){

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }


    PCHAR dn, attr, val;
    ULONG res;
    CString str;


   //
   // get properties from dialog
   //
    dn = m_CompDlg->m_dn.IsEmpty() ? NULL : (char*)LPCTSTR(m_CompDlg->m_dn);
    attr = m_CompDlg->m_attr.IsEmpty() ? NULL : (char*)LPCTSTR(m_CompDlg->m_attr);
    val = m_CompDlg->m_val.IsEmpty() ? NULL : (char*)LPCTSTR(m_CompDlg->m_val);

    if(m_CompDlg->m_sync){
         //
         // do sync
         //
            str.Format("ldap_compare_s(0x%x, \"%s\", \"%s\", \"%s\")", hLdap, dn, attr, val);
            Print(str);
            BeginWaitCursor();
            res = ldap_compare_s(hLdap, dn, attr, val);
            EndWaitCursor();

            if(res == LDAP_COMPARE_TRUE){
                str.Format("Results: TRUE. <%lu>", res);
                Out(str, CP_PRN);
            }
            else if(res == LDAP_COMPARE_FALSE){
                str.Format("Results: FALSE. <%lu>", res);
                Out(str, CP_PRN);
            }
            else{
                str.Format("Error: ldap_compare(): %s. <%lu>", ldap_err2string(res), res);
                Out(str, CP_PRN);

            }
    }
    else{

         //
         // async call
         //
            str.Format("ldap_compare(0x%x, \"%s\", \"%s\", \"%s\")", hLdap, dn, attr, val);
            Print(str);
            res = ldap_compare(hLdap, dn, attr, val);
            if(res == -1){
                str.Format("Error: ldap_compare(): %s. <%lu>", ldap_err2string(res), res);
                Out(str, CP_PRN);
            }
            else{

            //
            // add to pending
            //
                CPend pnd;
                pnd.mID = res;
                pnd.OpType = CPend::P_COMP;
                pnd.ld = hLdap;
                str.Format("%4d: ldap_comp: dn=\"%s\"", res, dn);
                pnd.strMsg = str;
                m_PendList.AddTail(pnd);
                m_PndDlg->Refresh(&m_PendList);
                Out("\tCompare Pending...", CP_PRN);
            }

    }

    Out("-----------", CP_PRN);
}




void CLdpDoc::OnBrowseCompare()
{
    bCompDlg = TRUE;
    if(GetContextActivation()){
        m_CompDlg->m_dn = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        m_CompDlg->m_dn = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }

    m_CompDlg->Create(IDD_COMPARE);

}

void CLdpDoc::OnUpdateBrowseCompare(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bCompDlg && bConnected) || !m_bProtect);
}

void CLdpDoc::OnOptionsDebug()
{
    CString str;
    if(IDOK == m_DbgDlg.DoModal()){
#ifdef WINLDAP
        ldap_set_dbg_flags(m_DbgDlg.ulDbgFlags);
        str.Format("ldap_set_dbg_flags(0x%x);", m_DbgDlg.ulDbgFlags);
        Out(str);
#endif
    }
}


void CLdpDoc::OnViewTree()
{


    if(IDOK == m_TreeViewDlg->DoModal()){
        UpdateAllViews(NULL);
    }

}

void CLdpDoc::OnUpdateViewTree(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(bConnected);

}



void CLdpDoc::OnViewLiveEnterprise()
{
    bLiveEnterprise = TRUE;
    m_EntTreeDlg->SetLd(hLdap);
    Out(_T("* Use the Refresh button to load currently live enterprise configuration"));
    Out(_T("* Attention: This may take several minutes!"));
    m_EntTreeDlg->Create(IDD_ENTERPRISE_TREE);


}

void CLdpDoc::OnUpdateViewLiveEnterprise(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bLiveEnterprise && bConnected) || !m_bProtect);
}



void CLdpDoc::OnLiveEntTreeEnd(){

    bLiveEnterprise = FALSE;

}




/*+++
Function   : GetOwnView
Description: get requested pane
Parameters :
Return     :
Remarks    : none.
---*/
CView* CLdpDoc::GetOwnView(LPCTSTR rtszName)
{

    POSITION pos;
    CView *pTmpVw = NULL;


    pos = GetFirstViewPosition();
    while(pos != NULL){
        pTmpVw = GetNextView(pos);
        if((CString)pTmpVw->GetRuntimeClass()->m_lpszClassName == rtszName)
            break;
    }

//  ASSERT(pTmpVw != NULL);

    return pTmpVw;
}



/*+++
Function   : GetTreeView
Description: Get a pointer to the DSTree view pane
Parameters :
Return     :
Remarks    : none.
---*/
CDSTree *CLdpDoc::TreeView(void){

    return (CDSTree*)GetOwnView(_T("CDSTree"));
}




BOOL CLdpDoc::GetContextActivation(void){

    CDSTree* tv = TreeView();

    if (tv) {
        return tv->GetContextActivation();
    }
    else{
        // see bug 447444
        ASSERT(tv);
        AfxMessageBox("Internal Error in CLdpDoc::GetContextActivation", MB_ICONHAND);
        return FALSE;
    }
}



void CLdpDoc::SetContextActivation(BOOL bFlag){

    CDSTree* tv = TreeView();

    ASSERT(tv);
    if ( tv ) {
        // prefix is happier with this check.
        tv->SetContextActivation(bFlag);
    }

}



/*+++
Function   : OnBindOptOK
Description: UI response to closing bind options
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnBindOptOK(){

    if((m_BndOpt->GetAuthMethod() == LDAP_AUTH_SSPI ||
       m_BndOpt->GetAuthMethod() == LDAP_AUTH_NTLM ||
       m_BndOpt->GetAuthMethod() == LDAP_AUTH_DIGEST) &&
       m_BndOpt->m_API == CBndOpt::BND_GENERIC_API)
        m_BindDlg.m_bSSPIdomain = TRUE;
    else
        m_BindDlg.m_bSSPIdomain = FALSE;

    if(NULL != m_BindDlg.m_hWnd &&
        ::IsWindow(m_BindDlg.m_hWnd))
        m_BindDlg.UpdateData(FALSE);

}





/*+++
Function   : OnSSPIDomainShortcut
Description: response to novice user shortcut UI checkbox
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpDoc::OnSSPIDomainShortcut(){
        //
        // sync bind & bind options dialog info such that advanced options
        // map to novice user usage. Triggered by Bind dlg shortcut checkbox
        //
        if(m_BindDlg.m_bSSPIdomain){
            m_BndOpt->m_Auth = BIND_OPT_AUTH_SSPI;
            m_BndOpt->m_API = CBndOpt::BND_GENERIC_API;
            m_BndOpt->m_bAuthIdentity = TRUE;
            m_BndOpt->m_bSync = TRUE;
        }
        else{
            m_BndOpt->m_Auth = BIND_OPT_AUTH_SIMPLE;
            m_BndOpt->m_API = CBndOpt::BND_SIMPLE_API;
            m_BndOpt->m_bAuthIdentity = FALSE;
            m_BndOpt->m_bSync = TRUE;
        }


}





/*+++
Function   : ParseResults
Description: shells ldap_parse_result
Parameters : LDAPMessage to pass on to ldap call
Return     : nothing. output to screen
---*/
void CLdpDoc::ParseResults(LDAPMessage *msg){


   PLDAPControl *pResultControls = NULL;
   BOOL bstatus;
   CString str;
   DWORD TimeCore=0, TimeCall=0, Threads=0;
   PSVRSTATENTRY pStats=NULL;


   if(hLdap->ld_version == LDAP_VERSION3){

      ULONG ulRetCode=0;
      PCHAR pMatchedDNs=NULL;
      PCHAR pErrMsg=NULL;
      ULONG err = ldap_parse_result(hLdap,
                                     msg,
                                     &ulRetCode,
                                     &pMatchedDNs,
                                     &pErrMsg,
                                     NULL,
                                     &pResultControls,
                                     FALSE);
      if(err != LDAP_SUCCESS){
        str.Format("Error<%lu>: ldap_parse_result failed: %s", err, ldap_err2string(err));
        Out(str);
      }
      else{
         str.Format("Result <%lu>: %s", ulRetCode, pErrMsg);
         Out(str);
         str.Format("Matched DNs: %s", pMatchedDNs);
         Out(str);
         if (pResultControls &&
             pResultControls[0])
         {
            //
            // If we requested stats, get it
            //
            pStats = GetServerStatsFromControl ( pResultControls[0] );

            if ( pStats)
            {
               Out("Stats:");
               for (INT i=0; i < MAXSVRSTAT; i++)
               {
                  switch (pStats[i].index)
                  {
                  case 0:
                     break;

                  case PARSE_THREADCOUNT:
#ifdef DBG
                     str.Format("\tThread Count:\t%lu", pStats[i].val);
                     Out(str);
#endif
                     break;
                  case PARSE_CALLTIME:
                     str.Format("\tCall Time:\t%lu (ms)", pStats[i].val);
                     Out(str);
                     break;
                  case PARSE_RETURNED:
                     str.Format("\tEntries Returned:\t%lu", pStats[i].val);
                     Out(str);
                     break;
                  case PARSE_VISITED:
                     str.Format("\tEntries Visited:\t%lu", pStats[i].val);
                     Out(str);
                     break;
                  case PARSE_FILTER:
                      str.Format("\tUsed Filter:\t%s", pStats[i].val_str);
                      free (pStats[i].val_str);
                      pStats[i].val_str = 0;
                      Out(str);
                      break;
                  case PARSE_INDEXES:
                      str.Format("\tUsed Indexes:\t%s", pStats[i].val_str);
                      free (pStats[i].val_str);
                      pStats[i].val_str = 0;
                      Out(str);
                      break;

                  default:
                     break;
                  }
               }
            }

            ldap_controls_free(pResultControls);
         }

         ldap_memfree(pErrMsg);
         ldap_memfree(pMatchedDNs);
      }
   }
}





CLdpDoc::PSVRSTATENTRY CLdpDoc::GetServerStatsFromControl( PLDAPControl pControl )
{
    BYTE *pVal, Tag;
    DWORD len, tmp;
    DWORD val;
    BOOL bstatus=TRUE;
    INT i;
    static SVRSTATENTRY pStats[MAXSVRSTAT];
    char *pszFilter = NULL;
    char *pszIndexes = NULL;
    PDWORD pdwRet=NULL;

    BYTE *pVal_str;
    DWORD val_str_len;

    //
    // init stats
    //
    for (i=0;i<MAXSVRSTAT;i++)
    {
       pStats[i].index = 0;
       pStats[i].val = 0;
       pStats[i].val_str = NULL;
    }


    pVal = (PBYTE)pControl->ldctl_value.bv_val;
    len = pControl->ldctl_value.bv_len;

    // Parse out the ber value
    if(strcmp(pControl->ldctl_oid, "1.2.840.113556.1.4.970")) {
        return NULL;
    }

    if (!GetBerTagLen (&pVal,&len,&Tag,&tmp)) {
        return NULL;
    }

    if (Tag != 0x30) {
        return NULL;
    }

    for (i=0; i<MAXSVRSTAT && len; i++)
    {
       //
       // get stat index
       //
        if ( !GetBerDword(&pVal,&len,&val) )
           return NULL;

        //
        // get stat value
        //
        if (val == PARSE_FILTER || val == PARSE_INDEXES) {
            bstatus = GetBerOctetString ( &pVal, &len, &pVal_str, &val_str_len);
            if (!bstatus)
            {
            return NULL;
            }
            pStats[i].val_str = (LPSTR) malloc (val_str_len + 1);
            if (pStats[i].val_str) {
                memcpy (pStats[i].val_str, pVal_str, val_str_len);
                pStats[i].val_str[val_str_len] = '\0';
            }
        }
        else {
            bstatus = GetBerDword(&pVal, &len, &(pStats[i].val));
            if (!bstatus)
            {
            return NULL;
            }
        }

        pStats[i].index = val;
    }

    return (PSVRSTATENTRY)pStats;
}

BOOL
CLdpDoc::GetBerTagLen (
        BYTE **ppVal,
        DWORD *pLen,
        BYTE  *Tag,
        DWORD *pObjLen)
{
    BYTE *pVal = *ppVal;
    DWORD Len = *pLen;
    BYTE sizeLen;
    DWORD i;

    if (!Len) {
        return FALSE;
    }

    // Get the tag.
    *Tag = *pVal++;
    Len--;

    if (!Len) {
        return FALSE;
    }

    // Get the Length.
    if (*pVal < 0x7f) {
        *pObjLen = *pVal++;
        Len--;
    } else {
        if (*pVal > 0x84) {
            // We don't handle lengths bigger than a DWORD.
            return FALSE;
        }
        sizeLen = *pVal & 0xf;
        *pVal++; Len--;
        if (Len < sizeLen) {
            return FALSE;
        }

        *pObjLen = *pVal++;
        Len--;
        for (i = 1; i < sizeLen; i++) {
            *pObjLen = (*pObjLen << 8) | *pVal++;
            Len--;
        }
    }

    *ppVal = pVal;
    *pLen = Len;

    return TRUE;
}

BOOL
CLdpDoc::GetBerOctetString (
        BYTE **ppVal,
        DWORD *pLen,
        BYTE  **ppOctetString,
        DWORD *cbOctetString)
{
    BYTE *pVal = *ppVal;
    BYTE Tag;
    DWORD Len = *pLen;

    if (!GetBerTagLen(&pVal, &Len, &Tag, cbOctetString)) {
        return FALSE;
    }
    if (Len < *cbOctetString || Tag != 0x04) {
        return FALSE;
    }

    *ppOctetString = pVal;
    pVal += *cbOctetString;
    Len -= *cbOctetString;
    *ppVal = pVal;
    *pLen = Len;

    return TRUE;
}

BOOL
CLdpDoc::GetBerDword (
        BYTE **ppVal,
        DWORD *pLen,
        DWORD *pRetVal)
{
    BYTE *pVal = *ppVal;
    DWORD i, num;

    *pRetVal = 0;

    if(! (*pLen)) {
        return FALSE;
    }

    // We are expecting to parse a number.  Next byte is magic byte saying this
    // is a number.
    if(*pVal != 2) {
        return FALSE;
    }

    pVal++;
    *pLen = *pLen - 1;

    if(! (*pLen)) {
        return FALSE;
    }

    // Next is the number of bytes the number contains.
    i=*pVal;
    pVal++;
    if((*pLen) < (i + 1)) {
        return FALSE;
    }
    *pLen = *pLen - i - 1;

    num = 0;
    while(i) {
        num = (num << 8) | *pVal;
        pVal++;
        i--;
    }

    *pRetVal = num;
    *ppVal = pVal;

    return TRUE;
}



/*++
Routine Description: Dumps the buffer content on to the debugger output.
Arguments:
    Buffer: buffer pointer.
    BufferSize: size of the buffer.
Return Value: none
Author: borrowed from MikeSw
--*/
VOID CLdpDoc::DumpBuffer(PVOID Buffer, DWORD BufferSize, CString &outStr){
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = (LPBYTE)Buffer;
    CString tmp;


    outStr.FormatMessage("%n%t%t");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            tmp.Format("%02x ", BufferPtr[i]);
            outStr += tmp;

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            tmp.Format("  ");
            outStr += tmp;
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            tmp.FormatMessage("  %1!s!%n%t%t", TextBuffer);
            outStr += tmp;
        }

    }

    tmp.FormatMessage("------------------------------------%n");
    outStr += tmp;
}





void CLdpDoc::OnOptionsServeroptions()
{
    SvrOpt dlg(this);
    dlg.DoModal();
}



void CLdpDoc::OnOptionsControls()
{

    if(IDOK == m_CtrlDlg->DoModal()){

    }

}

void CLdpDoc::FreeControls(PLDAPControl *ctrl){

    if(ctrl == NULL)
        return;

    for(INT i=0; ctrl[i] != NULL; i++){
        PLDAPControl c = ctrl[i];       // for convinience
        delete c->ldctl_oid;
        delete c->ldctl_value.bv_val;
        delete c;
    }
    delete ctrl;

}





void CLdpDoc::OnOptionsSortkeys()
{
    if(IDOK == m_SKDlg->DoModal()){

    }

}

void CLdpDoc::OnOptionsSetFont()
{
    POSITION pos;
    CView *pTmpVw;

    pos = GetFirstViewPosition();
    while(pos != NULL){

        pTmpVw = GetNextView(pos);
        if((CString)(pTmpVw->GetRuntimeClass()->m_lpszClassName) == _T("CLdpView")){
            CLdpView* pView = (CLdpView* )pTmpVw;
            pView->SelectFont();
        }
    }
}




void CLdpDoc::OnBrowseExtendedop()
{
    bExtOp = TRUE;
    m_ExtOpDlg->Create( IDD_EXT_OPT );

}

void CLdpDoc::OnUpdateBrowseExtendedop(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((!bExtOp && bConnected) || !m_bProtect);

}


void CLdpDoc::OnExtOpEnd(){

    bExtOp = FALSE;

}



void CLdpDoc::OnExtOpGo(){


    ULONG ulMid=0, ulErr;
    struct berval data;
    DWORD dwVal=0;
    CString str= m_ExtOpDlg->m_strData;
    PCHAR pOid = (PCHAR) LPCTSTR(m_ExtOpDlg->m_strOid);

    PLDAPControl *SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
    PLDAPControl *ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);


//  data.bv_len = pStr == NULL ? 0 : (strlen(pStr) * sizeof(TCHAR));
//  data.bv_val = pStr;

    if(0 != (dwVal = atol(str)) ||
        (!str.IsEmpty() && str[0] == '0')){

        data.bv_val = (PCHAR)&dwVal;
        data.bv_len = sizeof(DWORD);
    }
    else if(str.IsEmpty()){
        data.bv_val = NULL;
        data.bv_len = 0;
    }
    else{
        data.bv_val = (PCHAR) LPCTSTR(str);
        data.bv_len = str.GetLength()+1;
    }

    BeginWaitCursor();
        ulErr = ldap_extended_operation(hLdap, pOid, &data, NULL, NULL, &ulMid);
    EndWaitCursor();

    str.Format("0x%X = ldap_extended_operation(ld, '%s', &data, svrCtrl, clntCtrl, %lu);",
                        ulErr, pOid, ulMid);
    Out(str);

    if(LDAP_SUCCESS == ulErr){
        //
        // add to pending
        //
        CPend pnd;
        pnd.mID = ulMid;
        pnd.OpType = CPend::P_EXTOP;
        pnd.ld = hLdap;
        str.Format("%4d: ldap_extended_op: Oid=\"%s\"", ulMid, pOid);
        pnd.strMsg = str;
        m_PendList.AddTail(pnd);
        m_PndDlg->Refresh(&m_PendList);
        Print("\tPending.");
    }
    else{
        str.Format("Error <0x%X>: %s", ulErr, ldap_err2string(ulErr));
        Out(str);
    }

    FreeControls(SvrCtrls);
    FreeControls(ClntCtrls);
}








/////////////////////// SECURITY EXTENSIONS HANDLER & FRIENDS //////////////////////////



void CLdpDoc::OnBrowseSecuritySd()
{
    SecDlg dlg;
    char *dn;
    CString str;
    int res;

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }

    if(GetContextActivation()){
        dlg.m_Dn = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        dlg.m_Dn = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }


    Out("***Calling Security...", CP_PRN);

    if (IDOK == dlg.DoModal())
    {
        // Try to query security for entry
        dn = dlg.m_Dn.IsEmpty() ? NULL : (char*)LPCTSTR(dlg.m_Dn);

        //
        // RM: remove for invalid validation
        //
        if (dn == NULL && m_bProtect){
            AfxMessageBox("Cannot query security on a NULL dn."
                                              "Please specify a valid dn.");
            return;
        }

        /* & we execute only in synchronous mode */

        BeginWaitCursor();

        res = SecDlgGetSecurityData(
                dn,
                dlg.m_Sacl,
                NULL,       // No account, we just want a security descriptor dump
                str
                );

        EndWaitCursor();

        // str.Format("ldap_delete_s(ld, \"%s\");", dn);
        // Out(str, CP_SRC);

        if (res != LDAP_SUCCESS)
        {
            str.Format("Error: Security: %s. <%ld>", ldap_err2string(res), res);
            Out(str, CP_CMT);
            Out(CString("Expected: ") + str, CP_PRN|CP_ONLY);
        }
        else
        {
            str.Format("Security for \"%s\"", dn);
            Print(str);
        }
    }

    Out("-----------", CP_PRN);
}

void CLdpDoc::OnBrowseSecurityEffective()
{
    RightDlg dlg;
    char *dn, *account;
    CString str;
    int res;
    TRUSTEE     t;
    TRUSTEE_ACCESS      ta = { 0 }; // ENOUGH for our use

    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }

    AfxMessageBox("Not implemented yet");

    return;

    Out("***Calling EffectiveRights...", CP_PRN);

    if (IDOK == dlg.DoModal())
    {
        // Try to find the effective rights for an entry

        dn = dlg.m_Dn.IsEmpty() ? NULL : (char*)LPCTSTR(dlg.m_Dn);

        //
        // RM: remove for invalid validation
        //
        if (dn == NULL && m_bProtect){
            AfxMessageBox("Cannot query security on a NULL dn."
                                              "Please specify a valid dn.");
            return;
        }

        account = dlg.m_Account.IsEmpty() ? NULL : (char*)LPCTSTR(dlg.m_Account);

        //
        // RM: remove for invalid validation
        //
        if (account == NULL && m_bProtect){
            AfxMessageBox("Cannot query security for a NULL account."
                                              "Please specify a valid account.");
            return;
        }

        /* & we execute only in synchronous mode */

        // BeginWaitCursor();
#if 0
        res = SecDlgGetSecurityData(
                dn,
                FALSE,         // Dont bother about SACL
                account,
                str
                );
#endif
        t.pMultipleTrustee = NULL;
        t.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        t.TrusteeForm = TRUSTEE_IS_NAME;
        t.TrusteeType = TRUSTEE_IS_UNKNOWN; // could be a group, alias, user etc.
        t.ptstrName = account;

        ta.fAccessFlags = TRUSTEE_ACCESS_ALLOWED;

        res = TrusteeAccessToObject(
                    dn,
                    SE_DS_OBJECT_ALL,
                    NULL, // Provider
                    &t,
                    1,
                    & ta
                    );

        if (res)
        {
            str.Format("TrusteeAccessToObject Failed %d", res);
        }
        else
        {
            str.Format("Access Rights %s has to %s are:", account, dn);
            Print(str);

            DebugBreak();



        }


        // EndWaitCursor();

    }

    Out("-----------", CP_PRN);
}



void CLdpDoc::OnUpdateBrowseSecuritySd(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(bConnected);

}

void CLdpDoc::OnUpdateBrowseSecurityEffective(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(bConnected);

}



/////////////////////// REPLICATION METADATA HANDLER & FRIENDS //////////////////////////


void CLdpDoc::OnUpdateBrowseReplicationViewmetadata(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(bConnected);

}





void CLdpDoc::OnBrowseReplicationViewmetadata()
{
    CString str;
    metadlg dlg;
    CLdpView *pView;

    pView = (CLdpView*)GetOwnView(_T("CLdpView"));


    if(!bConnected && m_bProtect){
        AfxMessageBox("Please re-connect session first");
        return;
    }


    if(GetContextActivation()){
        dlg.m_ObjectDn = TreeView()->GetDn();
        TreeView()->SetContextActivation(FALSE);
    }
    else if (m_vlvDlg && m_vlvDlg->GetContextActivation()) {
        dlg.m_ObjectDn = m_vlvDlg->GetDN();
        m_vlvDlg->SetContextActivation(FALSE);
    }


    if (IDOK == dlg.DoModal())
    {
        LPTSTR dn = dlg.m_ObjectDn.IsEmpty() ? NULL : (LPTSTR)LPCTSTR(dlg.m_ObjectDn);

        if(!dn){
            AfxMessageBox("Please enter a valid object DN string");
            return;
        }

        str.Format("Getting '%s' metadata...", dn);
        Out(str);

        BeginWaitCursor();

        int             ldStatus;
        LDAPMessage *   pldmResults;
        LDAPMessage *   pldmEntry;
        LPSTR           rgpszRootAttrsToRead[] = { "replPropertyMetaData", NULL };
        LDAPControl     ctrlShowDeleted = { LDAP_SERVER_SHOW_DELETED_OID };
        LDAPControl *   rgpctrlServerCtrls[] = { &ctrlShowDeleted, NULL };

        ldStatus = ldap_search_ext_s(
                        hLdap,
                        dn,
                        LDAP_SCOPE_BASE,
                        "(objectClass=*)",
                        rgpszRootAttrsToRead,
                        0,
                        rgpctrlServerCtrls,
                        NULL,
                        NULL,
                        0,
                        &pldmResults
                        );

        if ( LDAP_SUCCESS == ldStatus )
        {
            pldmEntry = ldap_first_entry( hLdap, pldmResults );

            //
            // disable redraw
            //
            pView->SetRedraw(FALSE);
            pView->CacheStart();

            if ( NULL == pldmEntry )
            {
                ldStatus = hLdap->ld_errno;
            }
            else
            {
                struct berval **    ppberval;
                int                 cVals;

                ppberval = ldap_get_values_len( hLdap, pldmEntry, "replPropertyMetaData" );

                cVals = ldap_count_values_len( ppberval );

                if ( 1 != cVals )
                {
                    str.Format( "%d values returned for replPropertyMetaData attribute; 1 expected.\n", cVals );
                    Out( str );

                    ldStatus = LDAP_OTHER;
                }
                else
                {
                    DWORD                       iprop;
                    PROPERTY_META_DATA_VECTOR * pmetavec = (PROPERTY_META_DATA_VECTOR *) ppberval[ 0 ]->bv_val;

                    if (VERSION_V1 != pmetavec->dwVersion)
                    {
                        str.Format("Meta Data Version is not %d!! Format unrecognizable!", VERSION_V1);
                        Out(str);
                    }
                    else
                    {
                        str.Format( "%d entries.", pmetavec->V1.cNumProps );
                        Out( str );

                        str.Format(
                            "%6s\t%6s\t%8s\t%33s\t\t\t%8s\t%18s",
                            "AttID",
                            "Ver",
                            "Loc.USN",
                            "Originating DSA",
                            "Org.USN",
                            "Org.Time/Date"
                            );
                        Out( str );

                        str.Format(
                            "%6s\t%6s\t%8s\t%33s\t\t%8s\t%18s",
                            "=====",
                            "===",
                            "=======",
                            "===============",
                            "=======",
                            "============="
                            );
                        Out( str );

                        for ( iprop = 0; iprop < pmetavec->V1.cNumProps; iprop++ )
                        {
                            CHAR        szTime[ SZDSTIME_LEN ];
                            struct tm * ptm;
                            UCHAR *     pszUUID = NULL;

                            UuidToString(&pmetavec->V1.rgMetaData[ iprop ].uuidDsaOriginating,
                                         &pszUUID);

                            str.Format(
                                "%6x\t%6x\t%8I64d\t%33s\t%8I64d\t%18s",
                                pmetavec->V1.rgMetaData[ iprop ].attrType,
                                pmetavec->V1.rgMetaData[ iprop ].dwVersion,
                                pmetavec->V1.rgMetaData[ iprop ].usnProperty,
                                pszUUID ? pszUUID : (UCHAR *) "<conv err>",
                                pmetavec->V1.rgMetaData[ iprop ].usnOriginating,
                                DSTimeToDisplayString(pmetavec->V1.rgMetaData[iprop].timeChanged, szTime)
                                );
                            Out( str );

                            if (NULL != pszUUID) {
                                RpcStringFree(&pszUUID);
                            }
                        }
                    }
                }

                ldap_value_free_len( ppberval );
            }

            ldap_msgfree( pldmResults );
            //
            // now allow refresh
            //
            pView->CacheEnd();
            pView->SetRedraw();
        }

        EndWaitCursor();

        if ( LDAP_SUCCESS != ldStatus )
        {
            str.Format( "Error: %s. <%ld>", ldap_err2string( ldStatus ), ldStatus );
            Out( str );
        }

        Out("-----------", CP_PRN);
    }
}







//
// Functions to process GeneralizedTime for DS time values (whenChanged kinda strings)
// Mostly taken & sometimes modified from \nt\private\ds\src\dsamain\src\dsatools.c
//


//
// MemAtoi - takes a pointer to a non null terminated string representing
// an ascii number  and a character count and returns an integer
//

int CLdpDoc::MemAtoi(BYTE *pb, ULONG cb)
{
#if (1)
    int res = 0;
    int fNeg = FALSE;

    if (*pb == '-') {
        fNeg = TRUE;
        pb++;
    }
    while (cb--) {
        res *= 10;
        res += *pb - '0';
        pb++;
    }
    return (fNeg ? -res : res);
#else
    char ach[20];
    if (cb >= 20)
        return(INT_MAX);
    memcpy(ach, pb, cb);
    ach[cb] = 0;

    return atoi(ach);
#endif
}





DWORD
CLdpDoc::GeneralizedTimeStringToValue(LPSTR IN szTime,
                                      PLONGLONG OUT pllTime)
/*++
Function   : GeneralizedTimeStringToValue
Description: converts Generalized time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
   DWORD status = ERROR_SUCCESS;
   SYSTEMTIME  tmConvert;
   FILETIME    fileTime;
   LONGLONG tempTime;
   ULONG       cb;
   int         sign    = 1;
   DWORD       timeDifference = 0;
   char        *pLastChar;
   int         len=0;

    //
    // param sanity
    //
    if (!szTime || !pllTime)
    {
       return STATUS_INVALID_PARAMETER;
    }


    // Intialize pLastChar to point to last character in the string
    // We will use this to keep track so that we don't reference
    // beyond the string

    len = strlen(szTime);
    pLastChar = szTime + len - 1;

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(&tmConvert, 0, sizeof(SYSTEMTIME));
    *pllTime = 0;

    // Set up and convert all time fields

    // year field
    cb=4;
    tmConvert.wYear = (USHORT)MemAtoi((LPBYTE)szTime, cb) ;
    szTime += cb;
    // month field
    tmConvert.wMonth = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // day of month field
    tmConvert.wDay = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // hours
    tmConvert.wHour = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // minutes
    tmConvert.wMinute = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // seconds
    tmConvert.wSecond = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    //  Ignore the 1/10 seconds part of GENERALISED_TIME_STRING
    szTime += 2;


    // Treat the possible deferential, if any
    if (szTime <= pLastChar) {
        switch (*szTime++) {

          case '-':               // negative differential - fall through
            sign = -1;
          case '+':               // positive differential

            // Must have at least 4 more chars in string
            // starting at pb

            if ( (szTime+3) > pLastChar) {
                // not enough characters in string
                return STATUS_INVALID_PARAMETER;
            }

            // hours (convert to seconds)
            timeDifference = (MemAtoi((LPBYTE)szTime, (cb=2))* 3600);
            szTime += cb;

            // minutes (convert to seconds)
            timeDifference  += (MemAtoi((LPBYTE)szTime, (cb=2)) * 60);
            szTime += cb;
            break;


          case 'Z':               // no differential
          default:
            break;
        }
    }

    if (SystemTimeToFileTime(&tmConvert, &fileTime)) {
       *pllTime = (LONGLONG) fileTime.dwLowDateTime;
       tempTime = (LONGLONG) fileTime.dwHighDateTime;
       *pllTime |= (tempTime << 32);
       // this is 100ns blocks since 1601. Now convert to
       // seconds
       *pllTime = *pllTime/(10*1000*1000L);
    }
    else {
       return GetLastError();
    }


    if(timeDifference) {
        // add/subtract the time difference
        switch (sign) {
        case 1:
            // We assume that adding in a timeDifference will never overflow
            // (since generalised time strings allow for only 4 year digits, our
            // maximum date is December 31, 9999 at 23:59.  Our maximum
            // difference is 99 hours and 99 minutes.  So, it won't wrap)
            *pllTime += timeDifference;
            break;
        case -1:
            if(*pllTime < timeDifference) {
                // differential took us back before the beginning of the world.
                status = STATUS_INVALID_PARAMETER;
            }
            else {
                *pllTime -= timeDifference;
            }
            break;
        default:
            status = STATUS_INVALID_PARAMETER;
        }
    }

    return status;

}


DWORD
CLdpDoc::GeneralizedTimeToSystemTime(LPSTR IN szTime,
                                      PSYSTEMTIME OUT psysTime)
/*++
Function   : GeneralizedTimeStringToValue
Description: converts Generalized time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
   DWORD status = ERROR_SUCCESS;
   ULONG       cb;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }


    // Intialize pLastChar to point to last character in the string
    // We will use this to keep track so that we don't reference
    // beyond the string

    len = strlen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cb=4;
    psysTime->wYear = (USHORT)MemAtoi((LPBYTE)szTime, cb) ;
    szTime += cb;
    // month field
    psysTime->wMonth = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // day of month field
    psysTime->wDay = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // hours
    psysTime->wHour = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // minutes
    psysTime->wMinute = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // seconds
    psysTime->wSecond = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));

    return status;

}

DWORD
CLdpDoc::DSTimeToSystemTime(LPSTR IN szTime,
                                      PSYSTEMTIME OUT psysTime)
/*++
Function   : DSTimeStringToValue
Description: converts UTC time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
   ULONGLONG   ull;
   FILETIME    filetime;
   BOOL        ok;

   ull = _atoi64 (szTime);

   filetime.dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
   filetime.dwHighDateTime = (DWORD) (ull >> 32);

   // Convert FILETIME to SYSTEMTIME,
   if (!FileTimeToSystemTime(&filetime, psysTime)) {
       return !ERROR_SUCCESS;
   }

   return ERROR_SUCCESS;
}


/*++
Function   : OnOptionsStartTLS
Description: initiate Transport Level Security on an LDAP connection.
Parameters : none
Return     : none
Remarks    : none.
--*/
void CLdpDoc::OnOptionsStartTls()
{
	ULONG retValue, err;
	CString str;
	PLDAPControl *SvrCtrls;
	PLDAPControl *ClntCtrls;
	PLDAPMessage    result = NULL;

	str.Format("ldap_start_tls_s(ld, &retValue, result, SvrCtrls, ClntCtrls)");
	Out(str);

	
	// controls
	SvrCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
	ClntCtrls = m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);

	err = ldap_start_tls_s(hLdap, &retValue, &result, SvrCtrls, ClntCtrls);

	if(err == 0){
		str.Format("result <0>");
		Out(str);

	}
    else{
		str.Format("Error <0x%X>:ldap_start_tls_s() failed: %s", err, ldap_err2string(err));
		Out(str);
		str.Format("Server Returned: 0x%X: %s", retValue, ldap_err2string(retValue));
		Out(str);

		// If the server returned a referal, check the returned message and print.		
		if(result != NULL){
			str.Format("Checking return message for referal...");
			Out(str);
			// if there was a referal then the referal will be in the message.
			DisplaySearchResults(result);
		}
	}


	ldap_msgfree(result);


}
/*++
Function   : OnOptionsStopTLS
Description: Terminate Transport Level Security on an LDAP connection.
Parameters : none
Return     : none
Remarks    : none.
--*/
void CLdpDoc::OnOptionsStopTls()
{
	ULONG retValue, err;
	CString str;


	str.Format("ldap_stop_tls_s( ld )");
	Out(str);
	
	err = ldap_stop_tls_s( hLdap );

	if(err == 0){
		str.Format("result <0>");
		Out(str);
	}
	else{
		str.Format("Error <0x%X>:ldap_stop_tls_s() failed:%s", err, ldap_err2string(err));
		Out(str);
	}
}


/*


*/
void CLdpDoc::OnGetLastError()
{
	CString str;

	str.Format(_T("0x%X=LdapGetLastError() %s"), LdapGetLastError(), ldap_err2string(LdapGetLastError()) );
	Out(str, CP_CMT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\lidlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lidlg.cpp
//
//--------------------------------------------------------------------------

// LiDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "LiDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// LargeIntDlg dialog


LargeIntDlg::LargeIntDlg(CWnd* pParent /*=NULL*/)
	: CDialog(LargeIntDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(LargeIntDlg)
	m_StrVal = _T("");
	m_HighInt = 0;
	m_LowInt = 0;
	//}}AFX_DATA_INIT
}


void LargeIntDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(LargeIntDlg)
	DDX_Text(pDX, IDC_STRING_INT, m_StrVal);
	DDX_Text(pDX, IDC_HIGH_INT, m_HighInt);
	DDX_Text(pDX, IDC_LOW_INT, m_LowInt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(LargeIntDlg, CDialog)
	//{{AFX_MSG_MAP(LargeIntDlg)
	ON_BN_CLICKED(IDRUN, OnRun)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// LargeIntDlg message handlers




//------------------------------------------------------
//    Member: LargeIntDlg::StringToLI

//    Synopsis: A utility routine to convert a string to a 
//              LARGE_INTEGER

//    Arguments: pValue -> the string to be converted
//               li -> space for storing the LARGE_INTEGER obtained
//               cbValue -> how many contiguous bytes of pValue
//               (starting pValue[0]) are to be considered

//    Modifies: none
    
//    Returns:  true on success

//    History:  18-Jun-1997  t-naraa  Created
//				10/14/97	 eyals    Imported as is from t-naraa's code

//------------------------------------------------------  
bool LargeIntDlg::StringToLI(IN LPCTSTR pValue, 
					   OUT LARGE_INTEGER& li, 
					   IN ULONG cbValue)
{
  LARGE_INTEGER temp;

  LONG sign=1;
  unsigned i=0;
  
  temp.QuadPart = 0;

  if(pValue[i] == '-') {
    sign = -1;
    i++;
  }

  if(i==cbValue) {
    // No length or just a '-'
    return false;
  }
            
  for(;i<cbValue;i++) {
    // Parse the string one character at a time to detect any
    // non-allowed characters.
    if((pValue[i] < '0') || (pValue[i] > '9'))
      return false;

    temp.QuadPart = ((temp.QuadPart * 10) + pValue[i] - '0');
  }
  temp.QuadPart *= sign;
  
  li.HighPart = (LONG)((temp.QuadPart)>>32);
  li.LowPart = (DWORD)((temp.QuadPart));

  return true;
}





void LargeIntDlg::OnRun() 
{


	LARGE_INTEGER liTmp = { 0, 0};

	UpdateData(TRUE);
	if(!m_StrVal.IsEmpty()){
		BOOL bRet = StringToLI(LPCTSTR(m_StrVal), liTmp, m_StrVal.GetLength());
		if(bRet){
			m_LowInt = liTmp.LowPart;
			m_HighInt = liTmp.HighPart;
			UpdateData(FALSE);
		}
		else
			AfxMessageBox("Error: Cannot convert value");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ldpdoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldpdoc.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// LdpDoc.h : interface of the CLdpDoc class
//
/////////////////////////////////////////////////////////////////////////////

#ifdef WINLDAP
//
//  Microsoft winldap.dll implementation
//
#include "winldap.h"


#else
//
// Umich ldap32.dll implementation
//
#include "lber.h"
#include "ldap.h"
#include "proto-ld.h"

// fix incompatibilities
#define LDAP_TIMEVAL              struct timeval

#endif



#include "srchdlg.h"
#include "adddlg.h"
#include "moddlg.h"
#include "deldlg.h"
#include "compdlg.h"
#include "srchopt.h"
#include "GenOpt.h"
#include "BndOpt.h"
#include "rdndlg.h"
#include "pnddlg.h"
#include "pndopt.h"
#include "TreeVw.h"
#include "pend.h"
#include "dbgdlg.h"
#include "BindDlg.h"
#include "SvrOpt.h"
#include "ctrldlg.h"
#include "sortkdlg.h"
#include "secdlg.h"
#include "rightdlg.h"
#include "metadlg.h"
#include "extopdlg.h"
#include "dstree.h"
#include "entTree.h"
#include "VlvDialog.h"

#define MAX_BER_SHOW                4096        // maximum length of BER value for display

#define CP_NON                    0x0
#define CP_CMT                    0x1
#define CP_PRN                    0x2
#define CP_SRC                    0x4
#define CP_ONLY                0x8

typedef  struct berelement **BERPTRTYPE;


//////////////////////////////////////////////////////////
// class CLdpDoc
//

class CLdpDoc : public CDocument
{
    friend class CVLVDialog;

protected: // create from serialization only
    CLdpDoc();
    DECLARE_DYNCREATE(CLdpDoc)


// Attributes
private:

typedef struct _svrstatentry{
   INT      index;
   DWORD    val;
   LPSTR    val_str;
}
SVRSTATENTRY, *PSVRSTATENTRY;


    char **m_ServerSupportedControls;   // the connected server supported controls

public:
    //
    // search and pending information storage
    //
    SearchInfo  SrchInfo;
    struct PndInfoStruct{
        BOOL All;
        BOOL bBlock;
        LDAP_TIMEVAL tv;
    } PndInfo;
    PLDAPSearch hPage;
    BOOL bPagedMode;



    //
    // connection global info
    //
    CString BindDn;
    CString BindPwd;
    CString BindDomain;
    CString Svr;
    CString DefaultContext;
    CString SchemaNC;
    CString ConfigNC;
    LDAP *hLdap;


    //
    // Dialogs
    //
    SrchDlg *SearchDlg;
    AddDlg *m_AddDlg;
    CEntTree *m_EntTreeDlg;
    ModDlg *m_ModDlg;
    ModRDNDlg *m_ModRdnDlg;
    SrchOpt SrchOptDlg;
    PndDlg *m_PndDlg;
    CCompDlg *m_CompDlg;
    CDbgDlg m_DbgDlg;
    TreeVwDlg *m_TreeViewDlg;
    CGenOpt *m_GenOptDlg;
    CBndOpt *m_BndOpt;
    CBindDlg m_BindDlg;
    ctrldlg *m_CtrlDlg;
    SortKDlg *m_SKDlg;
    ExtOpDlg *m_ExtOpDlg;
    CVLVDialog *m_vlvDlg;


    //
    // misc flags
    //
    BOOL bConnected;
    BOOL bSrch;
    BOOL bAdd;
    BOOL bLiveEnterprise;
    BOOL bExtOp;
    BOOL bMod;
    BOOL bModRdn;
    BOOL bPndDlg;
    BOOL bCompDlg;
    BOOL m_SrcMode;
    BOOL m_bCnctless;
    BOOL m_bProtect;
    ULONG m_ulDeleted;

    BOOL bServerVLVcapable;
    //
    // list of pending requests
    //
    CList<CPend, CPend&> m_PendList;


// Operations
private:

    void OnOptionsStopTls();
    void OnOptionsStartTls();
    void OnGetLastError();
    CDSTree *TreeView(void);
    BOOL GetContextActivation(void);
    void SetContextActivation(BOOL bFlag);
    void Print(CString str);
    void CodePrint(CString str, int type = CP_SRC);
    VOID FormatValue(CString attr, PLDAP_BERVAL pbval, CString& str);
    void DisplayValues(LDAPMessage *entry, char *attr);
    void DisplayBERValues(LDAPMessage *entry, char *attr);
    void DumpBuffer(PVOID Buffer, DWORD BufferSize, CString &outStr);
    void PrintHeader(void);
    void HandleProcResult(int res, LDAPMessage *msg, CPend *pnd = NULL);
    CString DNProcess(PCHAR dn);
    CView* GetOwnView(LPCTSTR rtszName);
    void ParseResults(LDAPMessage *msg);
    PSVRSTATENTRY GetServerStatsFromControl( PLDAPControl pControl );
    BOOL GetBerDword( BYTE **ppVal, DWORD *pLen, DWORD *pRetVal);
    BOOL GetBerTagLen(IN OUT BYTE **ppVal, IN OUT DWORD *pLen, OUT BYTE  *Tag, OUT DWORD *pObjLen);
    BOOL GetBerOctetString ( IN OUT BYTE **ppVal, IN OUT DWORD *pLen, OUT BYTE **ppOctetString, OUT DWORD *cbOctetString);


    int MemAtoi(BYTE *pb, ULONG cb);
    DWORD GeneralizedTimeStringToValue(LPSTR IN szTime, PLONGLONG OUT pllTime);
    DWORD GeneralizedTimeToSystemTime(LPSTR IN szTime, PSYSTEMTIME OUT psysTime);
    DWORD DSTimeToSystemTime (LPSTR IN szTime, PSYSTEMTIME OUT psysTime);


    void SetSupportedServerControls (int cnt, char **val);

    void FreeControls(PLDAPControl *ctrl);
    BOOL RecursiveDelete(LDAP* ld, LPTSTR lpszDN);
    BOOL SetSecurityPrivilege(BOOL bOn = TRUE);
    void Connect(CString Svr, INT port = LDAP_PORT);
    void PrintStringSecurityDescriptor(PSECURITY_DESCRIPTOR pSd);

    static ULONG __cdecl CLdpDoc::SecDlgPrintSDFunc(char *, ...);

    void SecDlgDumpSD(
        PSECURITY_DESCRIPTOR    input,
        CString                 str
        );

    void SecDlgPrintSd(
        PSECURITY_DESCRIPTOR    input,
        CString                 str
        );

    int SecDlgGetSecurityData(
        CHAR            *dn,
        BOOL            sacl,
        CHAR            *account,               // OPTIONAL
        CString         str
        );
public:

    void DisplaySearchResults(LDAPMessage *msg);
    void Out(CString str, int type = CP_SRC);
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLdpDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CLdpDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    void ShowVLVDialog (const char *strDN, BOOL runQuery = FALSE );

    void AddGuidToCache(GUID *pGuid, CHAR *name);
    char *FindNameByGuid (GUID *pGuid);

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CLdpDoc)
    afx_msg void OnConnectionBind();
    afx_msg void OnConnectionConnect();
    afx_msg void OnConnectionDisconnect();
    afx_msg void OnBrowseSearch();
    afx_msg void OnUpdateBrowseSearch(CCmdUI* pCmdUI);
    afx_msg void OnBrowseAdd();
    afx_msg void OnUpdateBrowseAdd(CCmdUI* pCmdUI);
    afx_msg void OnBrowseDelete();
    afx_msg void OnUpdateBrowseDelete(CCmdUI* pCmdUI);
    afx_msg void OnBrowseModifyrdn();
    afx_msg void OnUpdateBrowseModifyrdn(CCmdUI* pCmdUI);
    afx_msg void OnBrowseModify();
    afx_msg void OnUpdateBrowseModify(CCmdUI* pCmdUI);
    afx_msg void OnOptionsSearch();
    afx_msg void OnBrowsePending();
    afx_msg void OnUpdateBrowsePending(CCmdUI* pCmdUI);
    afx_msg void OnOptionsPend();
    afx_msg void OnUpdateConnectionConnect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateConnectionDisconnect(CCmdUI* pCmdUI);
    afx_msg void OnViewSource();
    afx_msg void OnUpdateViewSource(CCmdUI* pCmdUI);
    afx_msg void OnOptionsBind();
    afx_msg void OnOptionsProtections();
    afx_msg void OnUpdateOptionsProtections(CCmdUI* pCmdUI);
    afx_msg void OnOptionsGeneral();
    afx_msg void OnBrowseCompare();
    afx_msg void OnUpdateBrowseCompare(CCmdUI* pCmdUI);
    afx_msg void OnOptionsDebug();
    afx_msg void OnViewTree();
    afx_msg void OnUpdateViewTree(CCmdUI* pCmdUI);
    afx_msg void OnOptionsServeroptions();
    afx_msg void OnOptionsControls();
    afx_msg void OnOptionsSortkeys();
    afx_msg void OnOptionsSetFont();
    afx_msg void OnBrowseSecuritySd();
    afx_msg void OnBrowseSecurityEffective();
    afx_msg void OnUpdateBrowseSecuritySd(CCmdUI* pCmdUI);
    afx_msg void OnUpdateBrowseSecurityEffective(CCmdUI* pCmdUI);
    afx_msg void OnBrowseReplicationViewmetadata();
    afx_msg void OnUpdateBrowseReplicationViewmetadata(CCmdUI* pCmdUI);
    afx_msg void OnBrowseExtendedop();
    afx_msg void OnUpdateBrowseExtendedop(CCmdUI* pCmdUI);
    afx_msg void OnViewLiveEnterprise();
    afx_msg void OnUpdateViewLiveEnterprise(CCmdUI* pCmdUI);
    afx_msg void OnBrowseBrowse();
    afx_msg void OnBrowseVlvsearch();
    afx_msg void OnUpdateBrowseVlvsearch(CCmdUI* pCmdUI);
    afx_msg void OnEditCopy();
    //}}AFX_MSG
    afx_msg void OnSrchEnd();
    afx_msg void OnSrchGo();
    afx_msg void OnAddEnd();
    afx_msg void OnAddGo();
    afx_msg void OnModEnd();
    afx_msg void OnModGo();
    afx_msg void OnModRdnEnd();
    afx_msg void OnModRdnGo();
    afx_msg void OnPendEnd();
    afx_msg void OnProcPend();
    afx_msg void OnPendAny();
    afx_msg void OnPendAbandon();
    afx_msg void OnCompEnd();
    afx_msg void OnCompGo();
    afx_msg void OnBindOptOK();
    afx_msg void OnSSPIDomainShortcut();
    afx_msg void OnExtOpEnd();
    afx_msg void OnExtOpGo();
    afx_msg void OnLiveEntTreeEnd();
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\lidlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lidlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_LIDLG_H__1B050962_44B8_11D1_A9E3_0000F803AA83__INCLUDED_)
#define AFX_LIDLG_H__1B050962_44B8_11D1_A9E3_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LiDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// LargeIntDlg dialog

class LargeIntDlg : public CDialog
{
// Construction
public:
	LargeIntDlg(CWnd* pParent = NULL);   // standard constructor
	virtual void OnCancel()		{DestroyWindow();}
	virtual void OnOK()				{	OnRun(); }
	bool StringToLI(IN LPCTSTR pValue, OUT LARGE_INTEGER& li, IN ULONG cbValue);



// Dialog Data
	//{{AFX_DATA(LargeIntDlg)
	enum { IDD = IDD_LARGE_INT };
	CString	m_StrVal;
	long	m_HighInt;
	DWORD	m_LowInt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(LargeIntDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(LargeIntDlg)
	afx_msg void OnRun();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LIDLG_H__1B050962_44B8_11D1_A9E3_0000F803AA83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\metadlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       metadlg.cpp
//
//--------------------------------------------------------------------------

// metadlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "metadlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// metadlg dialog


metadlg::metadlg(CWnd* pParent /*=NULL*/)
	: CDialog(metadlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(metadlg)
	m_ObjectDn = _T("");
	//}}AFX_DATA_INIT
}


void metadlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(metadlg)
	DDX_Text(pDX, IDC_OBJ_DN, m_ObjectDn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(metadlg, CDialog)
	//{{AFX_MSG_MAP(metadlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// metadlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\mainfrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mainfrm.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "Ldp.h"
#include "dstree.h"
#include "MainFrm.h"
#include "htmlhelp.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define HELP_FILE_NAME  _T("w2krksupp.chm")





/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_HELP_READMEFIRST, OnHelpReadmefirst)
	ON_WM_SIZE()
	ON_COMMAND(ID_UTILITIES_LARGEINTEGERCONVERTER, OnUtilitiesLargeintegerconverter)
	ON_UPDATE_COMMAND_UI(ID_UTILITIES_LARGEINTEGERCONVERTER, OnUpdateUtilitiesLargeintegerconverter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	



	dims.left = 50;
   dims.right = 550;
   dims.bottom = 450;
   dims.top = 50;
   iSplitterPos = (INT)( (double)(dims.right - dims.left) * 0.25 );

	dims.left = app->GetProfileInt("Environment",  "PosLeft", dims.left);
	dims.right = app->GetProfileInt("Environment",  "PosRight", dims.right);
	dims.bottom = app->GetProfileInt("Environment",  "PosBottom", dims.bottom);
	dims.top = app->GetProfileInt("Environment",  "PosTop", dims.top);
	iSplitterPos = app->GetProfileInt("Environment",  "PosSplitter", iSplitterPos);



}

CMainFrame::~CMainFrame()
{

   INT iDummy=0;
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Environment",  "PosLeft", dims.left);
	app->WriteProfileInt("Environment",  "PosRight", dims.right);
	app->WriteProfileInt("Environment",  "PosBottom", dims.bottom);
	app->WriteProfileInt("Environment",  "PosTop", dims.top);

   m_wndSplitter.GetColumnInfo(0, iSplitterPos, iDummy);
	app->WriteProfileInt("Environment",  "PosSplitter", iSplitterPos);

}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	SetIcon(AfxGetApp()->LoadIcon(IDI_LDP), TRUE);
	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	cs.style &= ~FWS_ADDTOTITLE;
	if(dims.left >= 0 && dims.right > 0){
		cs.y = dims.top;
		cs.x = dims.left;
		cs.cy = dims.bottom - dims.top;
		cs.cx = dims.right - dims.left;
	}
	

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

/*+++
Function   : GetDefaultBrowser
Description: returns a string pointing to user default browser
             by finding the http shell association
Parameters : none
Return     : "new" allocated buffer w/ string, NULL on error
Remarks    : none.
---*/
LPTSTR CMainFrame::GetDefaultBrowser(void){
   HKEY hKey;
   ULONG ulStatus=STATUS_SUCCESS;
   PUCHAR pBuffer = new UCHAR[MAXSTR];
   DWORD cbBuffer = MAXSTR;

   const TCHAR szHttpKey[] = _T("SOFTWARE\\CLASSES\\http\\shell\\open\\command");

   ulStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szHttpKey,
                           0,
                           KEY_READ,
                           &hKey);
   if(ulStatus == STATUS_SUCCESS){
      ulStatus = RegQueryValueEx(hKey,
                                NULL,
                                0,
                                NULL,
                                pBuffer,
                                &cbBuffer);
   }
   if(ulStatus != STATUS_SUCCESS){
      delete pBuffer, pBuffer = NULL;
   }

   return (LPTSTR)pBuffer;
}



void CMainFrame::OnHelpReadmefirst() {

	CString str;


    AfxMessageBox(ID_STR_HELPMSG);
}

//**** Attempts at calling into help file. Left for reference ****
//
//void CMainFrame::OnHelpReadmefirst() {
//	CString str;
//	BOOL bSucc = FALSE;
//	PROCESS_INFORMATION pi;
//	TCHAR sysDir[MAXSTR];
//   TCHAR currDir[MAXSTR];
//   LPTSTR pHelpFullName=NULL;
//   DWORD dwStatus=0;
//
//
//
//
//	GetSystemDirectory(sysDir, MAXSTR);
//   dwStatus = GetCurrentDirectory(MAXSTR-1, currDir);
//   if(dwStatus <= 0){
//      AfxMessageBox("Cannot get current Directory inforamtion!\n");
//      return;
//   }
//
//   pHelpFullName = new TCHAR[dwStatus+strlen(HELP_FILE_NAME)+2];
//   sprintf(pHelpFullName, "%s\\%s", currDir, HELP_FILE_NAME);
//
//	BeginWaitCursor();
//
//   /** tried to use IE but didn't work so far:
//   LPTSTR pCmd=NULL;
//   pCmd = GetDefaultBrowser();
//   if(pCmd){
//      str.Format(_T("%s %s"), pCmd, HELP_FILE_NAME);
//      // etc...
//      delete pCmd;
//   **/
//
//   /**
//   STARTUPINFO si;
//   si.cb = sizeof(STARTUPINFO);
//   si.lpReserved = NULL;
//   si.lpDesktop = NULL;
//   si.lpTitle = NULL;
//   si.dwFlags = 0;
//   si.cbReserved2 = 0;
//   si.lpReserved2 = NULL;
//
//   str.Format(_T("%s\\winhlp32.exe  %s"), sysDir, HELP_FILE_NAME);
//   bSucc = CreateProcess(NULL,
//                    (LPTSTR)LPCTSTR(str),
//                    NULL,
//                    NULL,
//                    TRUE,
//                    DETACHED_PROCESS,
//                    NULL,
//                    NULL,
//                    &si,
//                    &pi);
//
//   if(!bSucc){
//      str.Format(_T("Error <%lu>: Could not open %s'."),
//                           GetLastError(), HELP_FILE_NAME);
//      AfxMessageBox(str);
//   }
//
//   **/
//   // try htmlhelp api
//
//   HWND hWnd=NULL;
//   hWnd = HtmlHelp(NULL, pHelpFullName, HH_DISPLAY_TOPIC, NULL);
//   if(NULL == hWnd){
//      str.Format(_T("Error <%lu>: Could not open %s'."),
//                           GetLastError(), HELP_FILE_NAME);
//      AfxMessageBox(str);
//   }
//
//
//
//	EndWaitCursor();
//
//   delete pHelpFullName;
//}
//******************************************************/





void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
	CFrameWnd::OnSize(nType, cx, cy);
	
	GetWindowRect(&dims);
}






BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext)
{
	
	// create a splitter with 1 row, 2 columns
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
	{
		TRACE0("Failed to CreateStaticSplitter\n");
		return FALSE;
	}

	// add the second splitter pane - the default view in column 1
	if (!m_wndSplitter.CreateView(0, 1,
		pContext->m_pNewViewClass, CSize(dims.right-dims.left-iSplitterPos, 0), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the first splitter pane - an input view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		RUNTIME_CLASS(CDSTree), CSize(iSplitterPos, 0), pContext))
	{
		TRACE0("Failed to create second pane\n");
		return FALSE;
	}


	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	return TRUE;
}


void CMainFrame::OnUtilitiesLargeintegerconverter()
{
	if(m_LiConverter.GetSafeHwnd( ) == NULL)
		m_LiConverter.Create(IDD_LARGE_INT);
	
}

void CMainFrame::OnUpdateUtilitiesLargeintegerconverter(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	pCmdUI->Enable(m_LiConverter.GetSafeHwnd( ) == NULL);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ldpview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldpview.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// LdpView.cpp : implementation of the CLdpView class
//

#include "stdafx.h"
#include "Ldp.h"

#include "LdpDoc.h"
#include "LdpView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLdpView

IMPLEMENT_DYNCREATE(CLdpView, CEditView)

BEGIN_MESSAGE_MAP(CLdpView, CEditView)
    //{{AFX_MSG_MAP(CLdpView)
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CEditView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CEditView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CEditView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLdpView construction/destruction

CLdpView::CLdpView()
{

   buffer.Empty();
   nbuffer = 0;
   bCache = FALSE;
}

CLdpView::~CLdpView()
{
}



void CLdpView::SelectFont( ) {
    CHOOSEFONT cf;
    CLdpApp *app = (CLdpApp*)AfxGetApp();

    // Initialize members of the CHOOSEFONT structure.

    cf.lStructSize = sizeof(CHOOSEFONT);
    cf.hwndOwner = m_hWnd;
    cf.hDC = (HDC)NULL;
    cf.lpLogFont = &lf;
    cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT;
    cf.lCustData = 0L;
    cf.lpfnHook = (LPCFHOOKPROC)NULL;
    cf.lpTemplateName = (LPSTR)NULL;
    cf.hInstance = (HINSTANCE) NULL;
    cf.lpszStyle = (LPSTR)NULL;
    cf.nFontType = SCREEN_FONTTYPE;
    cf.nSizeMin = 0;
    cf.nSizeMax = 0;

    // Display the CHOOSEFONT common-dialog box.

    if (!ChooseFont(&cf)) {
        return;
    }
    font.CreateFontIndirect(&lf);
    GetEditCtrl().SetFont(&font, TRUE);

    app->WriteProfileString("Font", "Face", lf.lfFaceName);
    app->WriteProfileInt("Font", "Height", lf.lfHeight);
    app->WriteProfileInt("Font", "Weight", lf.lfWeight);
    app->WriteProfileInt("Font", "Italic", lf.lfItalic);
}


/*+++
Function   : OnInitialUpdate
Description: One time view init.
Parameters : none
Return     : none
Remarks    : Used to launch automatic test
---*/
void CLdpView::OnInitialUpdate( ){

    CString fontName;

    CLdpApp *app = (CLdpApp*)AfxGetApp();

    memset(&lf, 0, sizeof(lf));
    fontName = app->GetProfileString("Font", "Face", "Arial");
    lf.lfHeight = app->GetProfileInt("Font", "Height", -12);
    lf.lfWeight = app->GetProfileInt("Font", "Weight", FW_DONTCARE);
    lf.lfItalic = (BYTE)app->GetProfileInt("Font", "Italic", 0);
    lstrcpy(lf.lfFaceName, fontName);

    font.CreateFontIndirect(&lf);

    GetEditCtrl().SetReadOnly();
    GetEditCtrl().SetFont(&font);

    CView::OnInitialUpdate();
}

BOOL CLdpView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    BOOL bPreCreated = CEditView::PreCreateWindow(cs);
    cs.style &= ~(ES_AUTOHSCROLL|WS_HSCROLL);   // Enable word-wrapping

    return bPreCreated;
}

/////////////////////////////////////////////////////////////////////////////
// CLdpView drawing

void CLdpView::OnDraw(CDC* pDC)
{
    CLdpDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CLdpView printing

BOOL CLdpView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default CEditView preparation
    return CEditView::OnPreparePrinting(pInfo);
}

void CLdpView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
{
    // Default CEditView begin printing.
    CEditView::OnBeginPrinting(pDC, pInfo);
}

void CLdpView::OnEndPrinting(CDC* pDC, CPrintInfo* pInfo)
{
    // Default CEditView end printing
    CEditView::OnEndPrinting(pDC, pInfo);
}

/////////////////////////////////////////////////////////////////////////////
// CLdpView diagnostics

#ifdef _DEBUG
void CLdpView::AssertValid() const
{
    CEditView::AssertValid();
}

void CLdpView::Dump(CDumpContext& dc) const
{
    CEditView::Dump(dc);
}

CLdpDoc* CLdpView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CLdpDoc)));
    return (CLdpDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLdpView message handlers



/*+++
Function   : PrintLog
Description: Modify edit buffer to include next line
Parameters : format & params
Return     : none
Remarks    : none.
---*/
void CLdpView::PrintArg(LPCTSTR lpszFormat, ...){

   //
   // argument list
   //
    va_list argList;
    va_start(argList, lpszFormat);


    TCHAR szBuff[MAXSTR];                       // generic
    CString tmpstr, CurrStr, NewStr;            // string helpers
    CLdpDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    INT iMaxPageSize = pDoc->m_GenOptDlg->MaxPageSize();
    INT iMaxLineSize = pDoc->m_GenOptDlg->MaxLineSize();

   //
   // format into buffer
   //

    vsprintf(szBuff, lpszFormat, argList);

   //
   // Get current # of lines in edtctrl
   //
    int nLines = GetEditCtrl( ).GetLineCount();

   //
    // get current contents
   //
    GetEditCtrl( ).GetWindowText(CurrStr);
    TCHAR *pStr = CurrStr.GetBuffer(0);
    TCHAR *pTmp = pStr;
   //
    // see if we need to truncate begining
   //
    if(iMaxPageSize < nLines){
      //
        // find EOL
      //
        for(pTmp = pStr; *pTmp != '\0' && *pTmp != '\n'; pTmp++);
        pTmp++;
    }

   //
    // now append to content
   //
    tmpstr.FormatMessage(_T("%1!s!%n"),szBuff);
    CString NewText = CString(pTmp) + tmpstr;
    CurrStr.ReleaseBuffer();
   //
    // and restore edit control
   //
    GetEditCtrl( ).SetWindowText(NewText);
    //
    // scroll max lines
    //
    GetEditCtrl( ).LineScroll(iMaxPageSize);
    va_end(argList);
}





#if 0
/*+++
Function   : PrintLog
Description: Modify edit buffer to include next line
Parameters : format & params
Return     : none
Remarks    : none.
---*/
void CLdpView::Print(LPCTSTR szBuff){

    CString tmpstr, CurrStr, NewStr;            // string helpers

    CLdpDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    INT iMaxPageSize = pDoc->m_GenOptDlg->MaxPageSize();
    INT iMaxLineSize = pDoc->m_GenOptDlg->MaxLineSize();

    //
    // Get current # of lines in edtctrl
    //
    int nLines = GetEditCtrl( ).GetLineCount();

    //
    // get current contents
    //
    GetEditCtrl( ).GetWindowText(CurrStr);
    TCHAR *pStr = CurrStr.GetBuffer(0);
    TCHAR *pTmp = pStr;
   //
    // see if we need to truncate begining
   //
    if(iMaxPageSize < nLines){
      //
        // find EOL
      //
        for(pTmp = pStr; *pTmp != '\0' && *pTmp != '\n'; pTmp++);
        pTmp++;
    }

   //
    // now append to content
   //
    tmpstr.FormatMessage(_T("%1!s!%n"),szBuff);
    CString NewText = CString(pTmp) + tmpstr;
    CurrStr.ReleaseBuffer();
   //
    // and restore edit control
   //
    GetEditCtrl( ).SetWindowText(NewText);
    //
    // scroll max lines
    //
    GetEditCtrl( ).LineScroll(iMaxPageSize);
}
#endif


/*+++
Function   :
Description: Modify edit buffer to include next line
Parameters : format & params
Return     : none
Remarks    : none.
---*/
void CLdpView::Print(LPCTSTR szBuff){


   if (bCache)
   {
      CachePrint(szBuff);
   }
   else{


    CString tmpstr, CurrStr, NewStr;            // string helpers

    CLdpDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    INT iMaxPageSize = pDoc->m_GenOptDlg->MaxPageSize();
    INT iMaxLineSize = pDoc->m_GenOptDlg->MaxLineSize();

    //
       // Get current # of lines in edtctrl
       //
    int nLines = GetEditCtrl( ).GetLineCount();

       //
    // get current contents
       //
    GetEditCtrl( ).GetWindowText(CurrStr);
    TCHAR *pStr = CurrStr.GetBuffer(0);
    TCHAR *pTmp = pStr;
      //
    // see if we need to truncate begining
      //
    if(iMaxPageSize < nLines){
         //
        // find EOL
         //
        for(pTmp = pStr; *pTmp != '\0' && *pTmp != '\n'; pTmp++);
        pTmp++;
    }

      //
    // now append to content
      //
    tmpstr.FormatMessage(_T("%1!s!%n"),szBuff);
    CString NewText = CString(pTmp) + tmpstr;
    CurrStr.ReleaseBuffer();
      //
    // and restore edit control
      //
    GetEditCtrl( ).SetWindowText(NewText);
    //
    // scroll max lines
    //
    GetEditCtrl( ).LineScroll(iMaxPageSize);

   }
}





void CLdpView::CacheStart(void){

   //
   // cleanup
   //
   buffer.Empty();

   //
   // mark caching state
   //
   bCache = TRUE;

    //
   // Get current # of lines in edtctrl
   //
    int nbuffer = GetEditCtrl( ).GetLineCount();

   //
    // get current contents
   //
    GetEditCtrl( ).GetWindowText(buffer);
   //
   // And clear window contents
   //
    GetEditCtrl( ).SetWindowText("");


}







/*+++
Function   : CachePrint
Description:
Parameters :
Return     :
Remarks    : none.
---*/
void CLdpView::CachePrint(LPCTSTR szBuff){

    CString tmpstr, CurrStr, NewStr;            // string helpers

    CLdpDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
   INT iMaxPageSize = pDoc->m_GenOptDlg->MaxPageSize();

    TCHAR *pStr = buffer.GetBuffer(0);
    TCHAR *pTmp = pStr;
   //
    // see if we need to truncate begining
   //
    if(iMaxPageSize < nbuffer){
      //
        // find EOL
      //
        for(pTmp = pStr; *pTmp != '\0' && *pTmp != '\n'; pTmp++);
        pTmp++;
    }
   else{
      nbuffer++;
   }

   //
    // now append to content
   //
    tmpstr.FormatMessage(_T("%1!s!%n"),szBuff);
    CString NewText = CString(pTmp) + tmpstr;
    buffer.ReleaseBuffer();
   buffer = NewText;
}



void CLdpView::CacheEnd(void){

    CLdpDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
   INT iMaxPageSize = pDoc->m_GenOptDlg->MaxPageSize();
   //
    // and restore edit control
   //
    GetEditCtrl( ).SetWindowText(buffer);
   buffer.Empty();
    //
    // scroll max lines
    //
    GetEditCtrl( ).LineScroll(iMaxPageSize);

   //
   // clear up
   //
   nbuffer = 0;
   bCache = FALSE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\ldpview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldpview.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// LdpView.h : interface of the CLdpView class
//
/////////////////////////////////////////////////////////////////////////////




class CLdpView : public CEditView
{

private:

   CString buffer;
   INT  nbuffer;
   BOOL bCache;
   CFont font;
   LOGFONT lf;

protected: // create from serialization only
    CLdpView();
    virtual void OnInitialUpdate( );

    DECLARE_DYNCREATE(CLdpView)

// Attributes
public:
    CLdpDoc* GetDocument();
    void PrintArg(LPCTSTR lpszFormat, ...);   // export interface for updating buffer (variable args)
    void Print(LPCTSTR szBuff);           // export interface for updating buffer
    void CachePrint(LPCTSTR szBuff);              // export interface for updating buffer
    void CacheStart(void);
    void CacheEnd(void);

    void SelectFont();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLdpView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CLdpView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CLdpView)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LdpView.cpp
inline CLdpDoc* CLdpView::GetDocument()
   { return (CLdpDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\mainfrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mainfrm.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#include "LiDlg.h"


// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
private:
	RECT dims;
   INT iSplitterPos;
	CDSTree *DSTree;
	LargeIntDlg m_LiConverter;


   LPTSTR GetDefaultBrowser(void);

protected: // create from serialization only
	CSplitterWnd m_wndSplitter;
	CMainFrame();


	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif


protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnHelpReadmefirst();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUtilitiesLargeintegerconverter();
	afx_msg void OnUpdateUtilitiesLargeintegerconverter(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\pend.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pend.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

//
// Pending Info Class
//



#ifndef PEND_H
#define PEND_H

class CPend{

public:

	enum PendType{
						P_BIND,
						P_SRCH,
						P_ADD,
						P_DEL,
						P_MOD,
						P_COMP,
						P_EXTOP,
						P_MODRDN
	};

	int mID;								 // message ID for the
	CString strMsg;					// any string message
	PendType OpType;
	LDAP *ld;

};







#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\moddlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       moddlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// ModDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// ModDlg dialog


#define MOD_OP_ADD			0
#define MOD_OP_DELETE		1
#define MOD_OP_REPLACE		2





class ModDlg : public CDialog
{
// Construction
private:
	int iChecked;
	void FormatListString(int i)		{FormatListString(i, m_Attr, m_Vals, m_Op); }

public:
	ModDlg(CWnd* pParent = NULL);   // standard constructor
	~ModDlg();
	CString GetEntry(int i);
	int GetEntryCount()					{ return m_AttrList.GetCount(); }
	void FormatListString(int i, CString& _attr, CString& _vals, int& _op);

	virtual void OnOK()				{ OnRun(); }

// Dialog Data
	//{{AFX_DATA(ModDlg)
	enum { IDD = IDD_MODIFY };
	CButton	m_RmAttr;
	CButton	m_EnterAttr;
	CButton	m_EditAttr;
	CListBox	m_AttrList;
	CString	m_Attr;
	CString	m_Dn;
	CString	m_Vals;
	int		m_Op;
	BOOL	m_Sync;
	BOOL	m_bExtended;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ModDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(ModDlg)
	virtual void OnCancel();
	afx_msg void OnRun();
	afx_msg void OnModEditattr();
	afx_msg void OnModEnterattr();
	afx_msg void OnModRmattr();
	afx_msg void OnModInsber();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\pnddlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pnddlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// PndDlg.h : header file
//

//#include "lber.h"
//#include "ldap.h"
#ifdef WINLDAP

#include "winldap.h"

#else

#include "lber.h"
#include "ldap.h"
#include "proto-ld.h"
#endif

#include  "pend.h"



/////////////////////////////////////////////////////////////////////////////
// PndDlg dialog

class PndDlg : public CDialog
{
// Construction
private:
CList<CPend, CPend&> *m_PendList;
public:
	POSITION posPending;
	BOOL bOpened;

	
	virtual  BOOL OnInitDialog( );
	PndDlg(CWnd* pParent = NULL);   // standard constructor
	PndDlg(CList<CPend, CPend&> *_PendList, CWnd* pParent =NULL);
	void Refresh(CList<CPend, CPend&> *_PendList) { m_PendList = _PendList; Refresh(); }
	void Refresh();
	BOOL CurrentSelection();


// Dialog Data
	//{{AFX_DATA(PndDlg)
	enum { IDD = IDD_PEND };
	CListBox	m_List;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(PndDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PndDlg)
	afx_msg void OnPendOpt();
	afx_msg void OnDblclkPendlist();
	virtual void OnCancel();
	afx_msg void OnPendRm();
	afx_msg void OnPendExec();
	afx_msg void OnPendAbandon();
	//}}AFX_MSG
	afx_msg void OnPendAny();
	DECLARE_MESSAGE_MAP()
};





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\pnddlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pnddlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// PndDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "PndDlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// PndDlg dialog


PndDlg::PndDlg(CWnd* pParent /*=NULL*/)
	: CDialog(PndDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(PndDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
}



PndDlg::PndDlg(CList<CPend, CPend&> *_PendList,
									CWnd* pParent /*=NULL*/)
	: CDialog(PndDlg::IDD, pParent)
{

	m_PendList = _PendList;
	posPending = NULL;
	bOpened = FALSE;

}





void PndDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(PndDlg)
	DDX_Control(pDX, IDC_PENDLIST, m_List);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PndDlg, CDialog)
	//{{AFX_MSG_MAP(PndDlg)
	ON_BN_CLICKED(ID_PEND_OPT, OnPendOpt)
	ON_LBN_DBLCLK(IDC_PENDLIST, OnDblclkPendlist)
	ON_BN_CLICKED(ID_PEND_RM, OnPendRm)
	ON_BN_CLICKED(ID_PEND_EXEC, OnPendExec)
	ON_BN_CLICKED(ID_PEND_ABANDON, OnPendAbandon)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(ID_PEND_ANY, OnPendAny)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PndDlg message handlers


BOOL PndDlg::OnInitDialog( ){

	BOOL bRet = CDialog::OnInitDialog();
	POSITION pos;
	CPend pnd;

	if(bRet){
		
	m_List.AddString(LPCTSTR("Null"));

	pos = m_PendList->GetHeadPosition();
	while(pos != NULL){
		pnd= m_PendList->GetNext(pos);
		m_List.AddString(LPCTSTR(pnd.strMsg));
	}
	m_List.SetCurSel(0);
	bOpened = TRUE;

	}
	return bRet;
}





void PndDlg::OnPendOpt()
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_OPTIONS_PEND);	
}



void PndDlg::OnDblclkPendlist()
{
	
	if(CurrentSelection())
		AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_PROCPEND);
}




void PndDlg::OnCancel()
{
	
	bOpened = FALSE;
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_PENDEND);
	DestroyWindow();
}


void PndDlg::Refresh(){

	if(bOpened && !m_PendList->IsEmpty()){
		m_List.AddString(LPCTSTR(m_PendList->GetTail().strMsg));
	}
}







void PndDlg::OnPendRm()
{
	
	CString str;
	POSITION pos;	
	CPend pnd;
	BOOL bGotIt;

	bGotIt = FALSE;
	int i = m_List.GetCurSel();
	pos = m_PendList->GetHeadPosition();
	while(pos != NULL){
		posPending = pos;
		pnd= m_PendList->GetNext(pos);
			if(i != LB_ERR){
				m_List.GetText(i, str);
				if(pnd.strMsg == str){
					bGotIt = TRUE;
					break;
				}
			}
	}
	if(bGotIt){
		m_List.DeleteString(i);
		if (LDAP_SUCCESS != ldap_abandon(pnd.ld, pnd.mID))
			AfxMessageBox("ldap_abandon() failed!");
		m_PendList->RemoveAt(posPending);
		posPending = NULL;
		m_List.SetCurSel(i > 0 ? i-1 : 0);
	}
}





void PndDlg::OnPendExec()
{
	if(CurrentSelection())
		AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_PROCPEND);
}



void PndDlg::OnPendAny(){
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_PENDANY);
}




void PndDlg::OnPendAbandon()
{
	CurrentSelection();
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_PENDABANDON);
}




BOOL PndDlg::CurrentSelection(){

	CString str;
	POSITION pos;	
	CPend pnd;
	BOOL bGotIt;

	bGotIt = FALSE;
	int i = m_List.GetCurSel();
	pos = m_PendList->GetHeadPosition();
	while(pos != NULL){
		posPending = pos;
		pnd = m_PendList->GetNext(pos);
			if(i != LB_ERR){
				m_List.GetText(i, str);
				if(pnd.strMsg == str){
					bGotIt = TRUE;
					break;
				}
			}
	}
	if(!bGotIt){
		posPending = NULL;
	}

	return bGotIt;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\pndopt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pndopt.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// PndOpt.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "PndOpt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// PndOpt dialog


PndOpt::PndOpt(CWnd* pParent /*=NULL*/)
	: CDialog(PndOpt::IDD, pParent)
{

	//{{AFX_DATA_INIT(PndOpt)
	m_bBlock = TRUE;
	m_bAllSearch = TRUE;
	m_Tlimit_sec = 0;
	m_Tlimit_usec = 0;
	//}}AFX_DATA_INIT

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	m_bBlock = app->GetProfileInt("Operations",  "PendingBlocked", m_bBlock);
	m_bAllSearch = app->GetProfileInt("Operations",  "PendingGetAllSearchReply", m_bAllSearch);
	m_Tlimit_sec = app->GetProfileInt("Operations",  "PendingTimeLimit(sec)", m_Tlimit_sec);
	m_Tlimit_usec = app->GetProfileInt("Operations",  "PendingTimeLimit(usec)", m_Tlimit_usec);
}



PndOpt::~PndOpt(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Operations",  "PendingBlocked", m_bBlock);
	app->WriteProfileInt("Operations",  "PendingGetAllSearchReply", m_bAllSearch);
	app->WriteProfileInt("Operations",  "PendingTimeLimit(sec)", m_Tlimit_sec);
	app->WriteProfileInt("Operations",  "PendingTimeLimit(usec)", m_Tlimit_usec);
}


void PndOpt::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(PndOpt)
	DDX_Check(pDX, IDC_BLOCK, m_bBlock);
	DDX_Check(pDX, IDC_COMPLETE_SRCH_RES, m_bAllSearch);
	DDX_Text(pDX, IDC_TLIMIT_SEC, m_Tlimit_sec);
	DDX_Text(pDX, IDC_TLIMIT_USEC, m_Tlimit_usec);
	//}}AFX_DATA_MAP

}


BEGIN_MESSAGE_MAP(PndOpt, CDialog)
	//{{AFX_MSG_MAP(PndOpt)
	ON_BN_CLICKED(IDC_BLOCK, OnBlock)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PndOpt message handlers



void PndOpt::OnBlock()
{
	UpdateData(TRUE);
	if(m_bBlock){
		CWnd *tWnd = GetDlgItem(IDC_TLIMIT_SEC);
		tWnd->EnableWindow(FALSE);
		tWnd = GetDlgItem(IDC_TLIMIT_USEC);
		tWnd->EnableWindow(FALSE);
		m_Tlimit_sec = 0;
		m_Tlimit_usec = 0;
	}
	else{
		CWnd *tWnd = GetDlgItem(IDC_TLIMIT_SEC);
		tWnd->EnableWindow(TRUE);
		tWnd = GetDlgItem(IDC_TLIMIT_USEC);
		tWnd->EnableWindow(TRUE);
	}
}

BOOL PndOpt::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	OnBlock();	
	return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\pndopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pndopt.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// PndOpt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PndOpt dialog

class PndOpt : public CDialog
{
// Construction
public:
	PndOpt(CWnd* pParent = NULL);   // standard constructor
	~PndOpt();

// Dialog Data
	//{{AFX_DATA(PndOpt)
	enum { IDD = IDD_PEND_OPT };
	BOOL	m_bBlock;
	BOOL	m_bAllSearch;
	long	m_Tlimit_sec;
	long	m_Tlimit_usec;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(PndOpt)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PndOpt)
	afx_msg void OnBlock();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\moddlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       moddlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// ModDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "ModDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// ModDlg dialog


ModDlg::ModDlg(CWnd* pParent /*=NULL*/)
	: CDialog(ModDlg::IDD, pParent)
{
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	//{{AFX_DATA_INIT(ModDlg)
	m_Attr = _T("");
	m_Dn = _T("");
	m_Vals = _T("");
	m_Op = MOD_OP_ADD;
	m_Sync = TRUE;
	m_bExtended = FALSE;
	//}}AFX_DATA_INIT
	iChecked = -1;

	m_Sync = app->GetProfileInt("Operations", "ModSync", m_Sync);
	m_bExtended = app->GetProfileInt("Operations", "ModExtended", m_bExtended);

}




ModDlg::~ModDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Operations", "ModSync", m_Sync);
	app->WriteProfileInt("Operations", "ModExtended", m_bExtended);
}




void ModDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ModDlg)
	DDX_Control(pDX, IDC_MOD_RMATTR, m_RmAttr);
	DDX_Control(pDX, IDC_MOD_ENTERATTR, m_EnterAttr);
	DDX_Control(pDX, IDC_MOD_EDITATTR, m_EditAttr);
	DDX_Control(pDX, IDC_MOD_ATTRLIST, m_AttrList);
	DDX_Text(pDX, IDC_MOD_ATTR, m_Attr);
	DDX_Text(pDX, IDC_MOD_DN, m_Dn);
	DDX_Text(pDX, IDC_MOD_VALS, m_Vals);
	DDX_Radio(pDX, IDC_MODADD, m_Op);
	DDX_Check(pDX, IDC_MOD_SYNC, m_Sync);
	DDX_Check(pDX, IDC_MOD_EXTENDED, m_bExtended);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ModDlg, CDialog)
	//{{AFX_MSG_MAP(ModDlg)
	ON_BN_CLICKED(IDRUN, OnRun)
	ON_BN_CLICKED(IDC_MOD_EDITATTR, OnModEditattr)
	ON_BN_CLICKED(IDC_MOD_ENTERATTR, OnModEnterattr)
	ON_BN_CLICKED(IDC_MOD_RMATTR, OnModRmattr)
	ON_BN_CLICKED(IDC_MOD_INSBER, OnModInsber)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ModDlg message handlers

void ModDlg::OnCancel()
{
		AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_MODEND);
		DestroyWindow();
}


void ModDlg::OnRun()
{
	UpdateData(TRUE);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_MODGO);
}



CString ModDlg::GetEntry(int i){

	CString str;

	m_AttrList.GetText(i, str);
	return str;
}



void ModDlg::OnModEditattr()
{
	int i;
	if((i= m_AttrList.GetCurSel()) != LB_ERR){
		iChecked = i;
		FormatListString(i);
		UpdateData(FALSE);
	}
	

	
}





void ModDlg::OnModEnterattr()
{
	UpdateData(TRUE);

	CString Op = m_Op == 0 ? "[Add]" :
							   m_Op == 1 ? "[Delete]":
								"[Replace]";

	CString str = Op + m_Attr + ":" + m_Vals;
	if(iChecked >= 0){
		m_AttrList.DeleteString(iChecked);
		iChecked = -1;
	}
	m_AttrList.AddString(LPCTSTR(str));
}

void ModDlg::OnModRmattr()
{
	int i;
	if((i = m_AttrList.GetCurSel()) != LB_ERR){
		m_AttrList.DeleteString(i);
		if(i == iChecked)
			iChecked = -1;
	}
	
}



void ModDlg::FormatListString(int i, CString& _attr, CString& _vals, int& _op){

	CString attrVal, str;
	int k, j;

	m_AttrList.GetText(i,  attrVal);
	if(!strncmp(LPCTSTR(attrVal), "[Add]", CString("[Add]").GetLength()))
		_op = MOD_OP_ADD;
	else if(!strncmp(LPCTSTR(attrVal), "[Delete]", CString("[Delete]").GetLength()))
		_op = MOD_OP_DELETE;
	else if(!strncmp(LPCTSTR(attrVal), "[Replace]", CString("[Replace]").GetLength()))
		_op = MOD_OP_REPLACE;

	j = attrVal.Find(']');
	ASSERT(j>0);
	str = attrVal.Right(attrVal.GetLength() - j-1);
	k = str.Find(':');
	ASSERT(k>=0);
	_attr = str.Left(k);
	_vals = str.Right(str.GetLength() - k -1);
}







void ModDlg::OnModInsber()
{
	CFileDialog	FileDlg(TRUE);

	if(FileDlg.DoModal() == IDOK){

		CString fname = FileDlg.GetPathName();
		CFile tmpFile(fname, CFile::modeRead|CFile::shareDenyNone);
		CString str;
		DWORD dwLength;

		try{
			dwLength = tmpFile.GetLength();
		}
		catch(CFileException *e){
			dwLength = 0;
			e->Delete();
		}

		str.Format("\\BER(%lu): %s", dwLength, fname);
		UpdateData(TRUE);
		m_Vals += str;
		UpdateData(FALSE);
	}
	

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\metadlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       metadlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_METADLG_H__72F918B1_E72D_11D0_A9A9_0000F803AA83__INCLUDED_)
#define AFX_METADLG_H__72F918B1_E72D_11D0_A9A9_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// metadlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// metadlg dialog

class metadlg : public CDialog
{
// Construction
public:
	metadlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(metadlg)
	enum { IDD = IDD_REPL_METADATA };
	CString	m_ObjectDn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(metadlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(metadlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_METADLG_H__72F918B1_E72D_11D0_A9A9_0000F803AA83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\secdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       secdlg.cpp
//
//--------------------------------------------------------------------------

// SecDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "SecDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SecDlg dialog


SecDlg::SecDlg(CWnd* pParent /*=NULL*/)
	: CDialog(SecDlg::IDD, pParent)
{
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	//{{AFX_DATA_INIT(SecDlg)
	m_Dn = _T("");
	m_Sacl = FALSE;
	//}}AFX_DATA_INIT

	m_Dn = app->GetProfileString("Operations", "SecurityDN", m_Dn);
	m_Sacl = app->GetProfileInt("Operations", "SaclSecuritySync", m_Sacl);
}



SecDlg::~SecDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileString("Operations", "SecurityDN", m_Dn);
	app->WriteProfileInt("Operations", "SaclSecuritySync", m_Sacl);
}



void SecDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SecDlg)
	DDX_Text(pDX, IDC_SECURITYDN, m_Dn);
	DDX_Check(pDX, IDC_SECURITYSACL, m_Sacl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SecDlg, CDialog)
	//{{AFX_MSG_MAP(SecDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// SecDlg message handlers

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\rightdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rightdlg.cpp
//
//--------------------------------------------------------------------------

// RightDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "RightDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// RightDlg dialog


RightDlg::RightDlg(CWnd* pParent /*=NULL*/)
	: CDialog(RightDlg::IDD, pParent)
{
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	//{{AFX_DATA_INIT(RightDlg)
	m_Account = _T("");
	m_Dn = _T("");
	//}}AFX_DATA_INIT

	m_Dn = app->GetProfileString("Operations", "EffectiveDN", m_Dn);
	m_Account = app->GetProfileString("Operations", "EffectiveAccount", m_Account);
}



RightDlg::~RightDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileString("Operations", "EffectiveDN", m_Dn);
	app->WriteProfileString("Operations", "EffectiveAccount", m_Account);
}


void RightDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(RightDlg)
	DDX_Text(pDX, IDC_EFFECTIVEACCOUNT, m_Account);
	DDX_Text(pDX, IDC_EFFECTIVEDN, m_Dn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(RightDlg, CDialog)
	//{{AFX_MSG_MAP(RightDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// RightDlg message handlers

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\rightdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rightdlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_RIGHTDLG_H__2AF725D5_E359_11D0_A9A9_0000F803AA83__INCLUDED_)
#define AFX_RIGHTDLG_H__2AF725D5_E359_11D0_A9A9_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RightDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// RightDlg dialog

class RightDlg : public CDialog
{
// Construction
public:
	RightDlg(CWnd* pParent = NULL);   // standard constructor
    ~RightDlg();
// Dialog Data
	//{{AFX_DATA(RightDlg)
	enum { IDD = IDD_EFFECTIVE };
	CString	m_Account;
	CString	m_Dn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(RightDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(RightDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RIGHTDLG_H__2AF725D5_E359_11D0_A9A9_0000F803AA83__INCLUDED_)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Ldp.rc
//
#define IDRUN                           3
#define ID_PEND_OPT                     3
#define IDOPTS                          3
#define ID_PEND_RM                      4
#define ID_PEND_EXEC                    5
#define ID_PEND_ANY                     6
#define ID_PEND_ABANDON                 7
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_LDPTYPE                     129
#define IDD_BIND                        130
#define IDD_Connect                     131
#define IDD_SRCH                        132
#define IDI_LDP                         133
#define IDD_ADD                         134
#define IDD_DELETE                      135
#define IDD_HISTORY                     137
#define IDD_MODRDN                      138
#define IDD_MODIFY                      139
#define IDD_SRCH_OPT                    140
#define IDD_PEND                        141
#define IDD_PEND_OPT                    142
#define IDD_BINDOPT                     143
#define IDD_GENOPT                      148
#define IDD_COMPARE                     149
#define IDD_DBGFLAGS                    150
#define IDD_TREE_VIEW                   152
#define IDD_CONNECTIONOPT               153
#define IDD_CONTROLS                    156
#define IDD_SORTKDLG                    157
#define IDD_SECURITY                    158
#define IDD_EFFECTIVE                   159
#define IDD_REPL_METADATA               160
#define IDD_EXT_OPT                     161
#define IDD_LARGE_INT                   162
#define IDR_TREE_CONTEXT                163
#define IDD_ENTERPRISE_TREE             164
#define IDI_COMPUTER                    166
#define IDI_DOMAIN                      169
#define IDI_LDP_TREE_ERROR              170
#define IDB_COMP1                       174
#define IDB_TREE_ERROR                  175
#define IDB_DOMAIN                      176
#define IDD_VLV                         178
#define IDD_VLV_DLG                     180
#define IDB_FOLDER_UP                   183
#define IDC_BindDn                      1000
#define IDC_BindPwd                     1001
#define IDC_Svr                         1001
#define IDC_FILTER                      1002
#define IDC_PORT                        1002
#define IDC_BASEDN                      1003
#define IDC_BASE                        1004
#define IDC_ONELEVEL                    1005
#define IDC_SUBTREE                     1006
#define IDC_ADD_DN                      1008
#define IDC_ADD_ATTR                    1009
#define IDC_ADD_VALS                    1010
#define IDC_ADD_ATTRLIST                1011
#define IDC_ADD_ENTERATTR               1014
#define IDC_ADD_EDITATTR                1015
#define IDC_DELDN                       1015
#define IDC_ADD_RMATTR                  1016
#define IDC_HISTORY                     1016
#define IDC_NEWDN                       1017
#define IDC_ADD_INSBER                  1017
#define IDC_OLDDN                       1018
#define IDC_DelOld                      1019
#define IDC_MOD_DN                      1020
#define IDC_MOD_ATTR                    1021
#define IDC_MOD_VALS                    1022
#define IDC_MOD_ENTERATTR               1023
#define IDC_MOD_ATTRLIST                1024
#define IDC_MOD_EDITATTR                1025
#define IDC_MOD_RMATTR                  1026
#define IDC_MODADD                      1027
#define IDC_MODDELETE                   1028
#define IDC_MODREPLACE                  1029
#define IDC_MOD_INSBER                  1030
#define IDC_SRCH_ATTRONLY               1031
#define IDC_DEREF_GRP                   1036
#define IDC_ASYNC                       1037
#define IDC_TSYNC                       1038
#define IDC_SYNC                        1039
#define IDC_SRCH_GRP                    1040
#define IDC_AUTH_IDENTITY               1040
#define IDC_SRCH_TLIMIT                 1041
#define IDC_SRCH_SLIMIT                 1042
#define IDC_PENDLIST                    1042
#define IDC_SRCH_ATTLIST                1043
#define IDC_SRCH_TOUT                   1044
#define IDC_COMPLETE_SRCH_RES           1044
#define IDC_SRCH_MTOUT                  1045
#define IDC_SRCH_EXTS                   1046
#define IDC_BLOCK                       1047
#define IDC_SRCH_PAGED                  1047
#define IDC_TLIMIT_USEC                 1048
#define IDC_SRCH_PAGESIZE               1048
#define IDC_TLIMIT_SEC                  1049
#define IDC_ADD_SYNC                    1049
#define IDC_DEL_SYNC                    1050
#define IDC_ADD_EXTENDED                1050
#define IDC_MODRDN_SYNC                 1051
#define IDC_DEL_EXTENDED                1051
#define IDC_MOD_SYNC                    1052
#define IDC_CNCTLESS                    1053
#define IDC_MOD_EXTENDED                1053
#define IDC_AUTH                        1056
#define IDC_SIMPLE                      1058
#define IDC_BER                         1064
#define IDC_STR                         1065
#define IDC_DN_NONE                     1066
#define IDC_EXPLODED                    1067
#define IDC_UFN                         1068
#define IDC_                            1069
#define IDC_COMP_DN                     1070
#define IDC_COMP_ATTR                   1071
#define IDC_COMP_VAL                    1072
#define ID_COMP_RUN                     1073
#define IDC_DBG_FILTER                  1076
#define IDC_DBG_BIND                    1077
#define IDC_DBG_NET_ERR                 1078
#define IDC_DBG_SCRATCH                 1079
#define IDC_API_TYPE                    1079
#define IDC_DBG_TDI                     1080
#define IDC_RADIO2                      1080
#define IDC_BindDmn                     1080
#define IDC_DBG_REF                     1081
#define IDC_RADIO3                      1081
#define IDC_TREE_BASE_DN                1081
#define IDC_DBG_REQ                     1082
#define IDC_INIT_TREE                   1082
#define IDC_DBG_SRCH                    1083
#define IDC_SSPI_DOMAIN                 1083
#define IDC_DBG_CONN                    1084
#define IDC_DBG_INIT_TERM               1085
#define IDC_VER2                        1085
#define IDC_DBG_API_ERR                 1086
#define IDC_VER3                        1086
#define IDC_DBG_STOP_ON_ERR             1087
#define IDC_DBG_ERR2                    1088
#define IDC_DBG_ERR                     1089
#define IDC_DISP_RESULTS                1090
#define IDC_CHASE_REFERRALS             1093
#define IDC_RETURN_REFERRALS            1094
#define IDC_RUN                         1095
#define IDC_OPTLIST                     1098
#define IDC_OPTVAL                      1099
#define IDC_SVROPT                      1100
#define IDC_SVRCTRL                     1102
#define IDC_CLNTCTRL                    1103
#define IDC_CRITICAL                    1105
#define IDC_CTRLVAL                     1106
#define IDC_DESCRIPTION                 1107
#define IDC_ACTIVELIST                  1108
#define IDC_CTRLADD                     1109
#define IDC_CTRLRM                      1110
#define IDC_OID                         1112
#define IDC_DATA                        1113
#define IDC_ATTRTYPE                    1114
#define IDC_MATCHRULE                   1115
#define IDC_REVERSE                     1117
#define IDC_ADD                         1119
#define IDC_REMOVE                      1120
#define IDC_BUTTON1                     1121
#define IDC_CTRL                        1121
#define IDC_VLV_PGUP                    1121
#define IDC_BTN_UP                      1121
#define IDC_SECURITYDN                  1122
#define IDC_VLV_PGDN                    1122
#define IDC_SECURITYSACL                1123
#define IDC_VLV_ONEUP                   1123
#define IDC_EFFECTIVEDN                 1124
#define IDC_VLV_ONEDN                   1124
#define IDC_EFFECTIVEACCOUNT            1125
#define IDC_OBJ_DN                      1125
#define IDSEND                          1126
#define IDC_RECURSIVE                   1128
#define IDC_RENAME                      1129
#define IDC_STRING_INT                  1130
#define IDC_HIGH_INT                    1131
#define IDC_LOW_INT                     1132
#define IDC_PAGESIZE                    1134
#define IDC_LINESIZE                    1135
#define IDREFRESH                       1136
#define IDC_TREE1                       1137
#define IDC_LIVEENT_TREE                1137
#define IDC_AUTO_SEC                    1138
#define IDC_SRCH_VLV                    1139
#define IDC_VLV_VIEWSIZE                1140
#define IDC_VLV_LISTSIZE                1141
#define IDC_VLV_CURRPOS                 1142
#define IDC_VLV_LIST                    1142
#define IDC_VLV_CURRCNT                 1143
#define IDC_FINDSTR                     1143
#define IDC_VLV_BFRCNT                  1144
#define IDC_EST_SIZE                    1144
#define IDC_VLV_AFTRCNT                 1145
#define IDC_BROWSE_CONT                 1145
#define IDC_VLV_SEEKVAL                 1146
#define IDC_CONT_THRESHOLD              1146
#define IDC_PREDEF_CONTROL              1147
#define IDC_CHECK_BINDDEFAULT           1147
#define IDC_BINDDEFAULT                 1147
#define ID_CONNECTION_BIND              32771
#define ID_CONNECTION_CONNECT           32772
#define ID_CONNECTION_DISCONNECT        32773
#define ID_BROWSE_ADD                   32774
#define ID_BROWSE_DELETE                32775
#define ID_BROWSE_MODIFY                32776
#define ID_BROWSE_MODIFYRDN             32777
#define ID_BROWSE_SEARCH                32778
#define ID_OPTIONS_HISTORY              32779
#define ID_OPTIONS_SEARCH               32780
#define ID_OPTIONS_PEND                 32781
#define ID_BROWSE_PENDING               32782
#define ID_HELP_READMEFIRST             32783
#define ID_OPTIONS_SOURCE               32784
#define ID_VIEW_SOURCE                  32785
#define ID_OPTIONS_BIND                 32786
#define ID_OPTIONS_PROTECTIONS          32787
#define ID_OPTIONS_GENERAL              32788
#define ID_BROWSE_COMPARE               32789
#define ID_OPTIONS_DEBUG                32790
#define ID_VIEW_TREE                    32791
#define ID_OPTIONS_SERVEROPTIONS        32792
#define ID_OPTIONS_CONTROLS             32793
#define ID_OPTIONS_SORTKEYS             32794
#define ID_BROWSE_SECURITY_SD           32796
#define ID_BROWSE_SECURITY_EFFECTIVE    32797
#define ID_BROWSE_REPLICATION_VIEWMETADATA 32798
#define ID_BROWSE_EXTENDEDOP            32799
#define ID_UTILITIES_LARGEINTEGERCONVERTER 32800
#define ID_VIEW_LIVEENTERPRISE          32813
#define ID_ENT_TREE_END                 32814
#define ID_STR_HELPMSG                  32815
#define ID_BROWSE_BROWSE                32815
#define ID_BROWSE_VLVSEARCH             32816
#define ID_EDIT_COPYDN                  32818
#define ID_OPTIONS_SETFONT              32819
#define ID_OPTIONS_START_TLS            32820
#define ID_OPTIONS_STOP_TLS             32821
#define ID_BROWSE_GetError		32822

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        184
#define _APS_NEXT_COMMAND_VALUE         32822
#define _APS_NEXT_CONTROL_VALUE         1148
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\secmisc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       secmisc.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : secmisc.cpp
*    Author      : Eyal Schwartz
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



// includes


#include "stdafx.h"


#include "Ldp.h"
#include "LdpDoc.h"
#include "LdpView.h"
#include "string.h"
#include <ntldap.h>

extern "C" {
    #include "checkacl.h"
}


#pragma optimize("", off)


#if(_WIN32_WINNT < 0x0500)

// Currently due to some MFC issues, even on a 5.0 system this is left as a 4.0

#undef _WIN32_WINNT

#define _WIN32_WINNT 0x500

#endif

#include <aclapi.h>         // for Security Stuff
#include <sddl.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SECINFO_ALL  OWNER_SECURITY_INFORMATION |  \
                     GROUP_SECURITY_INFORMATION |  \
                     SACL_SECURITY_INFORMATION  |  \
                     DACL_SECURITY_INFORMATION



//
// The List of GUID Controls used in DS
//

typedef struct GuidCache
{
    CHAR                *name;
    GUID                guid;
    int                 type;
} GuidCache;

                                         
GuidCache guidCache[] = {
    #include "..\aclguids\guidcache.h"
};

#define NUM_KNOWN_GUIDS  (sizeof (guidCache) / sizeof (GuidCache) -1 )

typedef struct DynGuidCache
{
    struct DynGuidCache *pNext;
    GUID                guid;
    CHAR                name[1];
} DynGuidCache;


DynGuidCache  *gDynGuidCache = NULL;            // class name <==> GUID cache

/////////////////////// SECURITY NON-UI HELPERS ////////////////////


void CLdpDoc::PrintStringSecurityDescriptor(PSECURITY_DESCRIPTOR pSd){


   BOOL bRet=TRUE;
   PCHAR pSD=NULL;
   DWORD cbSD = 0;

   bRet = ConvertSecurityDescriptorToStringSecurityDescriptor(pSd,
                                                              SDDL_REVISION,
                                                              SECINFO_ALL,
                                                              &pSD,
                                                              &cbSD);
   if(bRet && cbSD > 0 && pSD){
      Print("String Format:");
      Print(CString(pSD));
      Print("---");
      LocalFree((PVOID)pSD);
   }
   else{
      CString sErr;
      sErr.Format("Error<0x%x>: Could not get SD string\n", GetLastError());
      Print(sErr);
   }
}

CString  tStr;
CString  *pStr = NULL;
CLdpDoc  *pDoc = NULL;

// this is a callback function used from DumpSD
// translate the var arg arguments into a CString and
// make it so as to compatible with our printing capabilities
//
// for more comments look in SecDlgDumpSD
//
ULONG __cdecl CLdpDoc::SecDlgPrintSDFunc(char *fmt, ...)
{
    int newline=0;
    va_list ap;
    va_start (ap, fmt);

    tStr.FormatV(fmt, ap);

    va_end (ap);
    
    if (pDoc && pStr) {

        int len=tStr.GetLength();
        for (int i=0; i<len; i++) {
            if (tStr.GetAt(i) == '\n') {
                tStr.SetAt(i, '\r');
                newline = i;
            }
        }

        if (newline) {
            *pStr += tStr.Left (newline);
            pDoc->Print (*pStr);
            *pStr = tStr.Mid (newline+1);
        }
        else {
            *pStr += tStr;
        }
    }

    return 0;
}


CHAR * __stdcall
LookupSid(
    PSID    pSID        // IN
    )
{
    static CHAR     retVal[2048];
    SID_NAME_USE    snu;
    CHAR            user[64];
    CHAR            domain[64];
    DWORD           cUser = sizeof(user);
    DWORD           cDomain = sizeof(domain);
    CHAR            *pszTmp;
    DWORD           i;

    if ( !pSID )
    {
        strcpy(retVal, "<NULL>");
        return(retVal);
    }
    else if ( !RtlValidSid(pSID) )
    {
        strcpy(retVal, "Not an RtlValidSid()");
        return(retVal);
    }
    else if ( LookupAccountSid(NULL, pSID, user, &cUser,
                               domain, &cDomain, &snu) )
    {
        if ( cDomain )
        {
            strcpy(retVal, domain);
            strcat(retVal, "\\");
            strcat(retVal, user);
        }
        else
        {
            strcpy(retVal, user);
        }

        strcat(retVal, " ");
    }
    else
    {
        retVal[0] = L'\0';
    }

    // Always concatenate S-xxx form of SID for reference.

    if ( ConvertSidToStringSidA(pSID, &pszTmp) )
    {
        strcat(retVal, pszTmp);
        LocalFree(pszTmp);
    }

    if ( L'\0' != retVal[0] )
    {
        // Already have symbolic name, S-xxx form, or both - done.
        return(retVal);
    }

    // Dump binary as a last resort.

    for ( i = 0; i < RtlLengthSid(pSID); i++ )
    {
        sprintf(&retVal[2*i], "%02x", ((CHAR *) pSID)[i]);
    }

    retVal[2*i] = '\0';
    return(retVal);
}


void  __stdcall
LookupGuid(
    GUID    *pg,            // IN
    CHAR    **ppName,       // OUT
    CHAR    **ppLabel,      // OUT
    BOOL    *pfIsClass      // OUT
    )
{
    static CHAR         name[1024];
    static CHAR         label[1024];
    CHAR                *p;

    *pfIsClass = FALSE;
    *ppName = name;
    *ppLabel = label;

    p = pDoc->FindNameByGuid (pg);

    if (p) {
        strcpy (label, p);
    }
    else {
        strcpy(label, "???");
    }
    
    PUCHAR  pszGuid = NULL;

    DWORD err = UuidToString((GUID*)pg, &pszGuid);
    if(err != RPC_S_OK){
       sprintf(name, "<UuidFromString failure: 0x%x>", err);
    }
    if ( pszGuid )
    {
        strcpy (name, (char *)pszGuid);
        RpcStringFree(&pszGuid);
    }
    else
    {
        strcpy (name, "<invalid Guid>");
    }
}

//
// Add a class name/guid pair to the cache.
//

void CLdpDoc::AddGuidToCache(
    GUID    *pGuid,
    CHAR    *name
    )
{
    DynGuidCache  *p, *pTmp;

    for ( p = gDynGuidCache; NULL != p; p = p->pNext )
    {
        if ( !_stricmp(p->name, name) )
        {
            return;
        }
    }

    p = (DynGuidCache *) malloc(sizeof(DynGuidCache) + strlen(name));
    p->guid = *pGuid;
    strcpy(p->name, name);
    p->pNext = gDynGuidCache;
    gDynGuidCache = p;
}

int __cdecl CompareGuidCache(const void * pv1, const void * pv2)
{
    return memcmp ( &((GuidCache *)pv1)->guid, &((GuidCache *)pv2)->guid, sizeof (GUID));
}

char *CLdpDoc:: FindNameByGuid (GUID *pGuid) 
{
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[3];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;
    DynGuidCache            *p;
    UCHAR                   *pg;
    CHAR                    filter[1024];
    PLDAP_BERVAL            *sd_value = NULL;
    PUCHAR                  pszGuid = NULL;
    GuidCache               *pGuidCache;
    GuidCache               Key;


    Key.guid = *pGuid;

    // check the sorted array first
    if (pGuidCache = (GuidCache *)bsearch(&Key, 
                                          guidCache, 
                                          NUM_KNOWN_GUIDS-1, 
                                          sizeof(GuidCache),
                                          CompareGuidCache)) {

        return pGuidCache->name;
    }

    // then check the cache
    for ( p = gDynGuidCache; NULL != p; p = p->pNext )
    {
        if ( RtlEqualMemory(&p->guid, pGuid, sizeof (GUID)) )
        {
            return(p->name);
        }
    }

    if (SchemaNC.GetLength() == 0 || ConfigNC.GetLength()==0) {
        goto InsertUndefined;
    }

    // Now go find the right classSchema object.

    pg = (unsigned char *)pGuid;

    attrs[0] = "ldapDisplayName";
    attrs[1] = "objectClass";
    attrs[2] = NULL;
    sprintf(filter,
            "(schemaIdGuid="
            "\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x"
            "\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x"
            ")", 
            pg[0], pg[1], pg[2], pg[3], pg[4], pg[5], pg[6], pg[7], 
            pg[8], pg[9], pg[10], pg[11], pg[12], pg[13], pg[14], pg[15]
    );

    dwErr = ldap_search_ext_s(hLdap,
                               (LPTSTR)LPCTSTR(SchemaNC),
                               LDAP_SCOPE_ONELEVEL,
                               filter,
                               attrs,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               10000,
                               &ldap_message);
    
    if ( LDAP_SUCCESS != dwErr )
    {
        goto InsertUndefined;
    }

    if (    !(entry = ldap_first_entry(hLdap, ldap_message))
         || !(values = ldap_get_valuesA(hLdap, entry, attrs[0]))
         || !(cVals = ldap_count_valuesA(values))
         || !(sd_value = ldap_get_values_lenA(hLdap, entry, attrs[0])) )
    {
        ldap_msgfree(ldap_message);
        goto FindControlRight;
    }

    AddGuidToCache(pGuid,  (char*)(*sd_value)->bv_val);
    ldap_value_free_len(sd_value);
    ldap_value_freeA(values);
    ldap_msgfree(ldap_message);

    return(gDynGuidCache->name);

FindControlRight:

    dwErr = UuidToString(pGuid, &pszGuid);
    if(dwErr != RPC_S_OK ||  !pszGuid ){
        goto InsertUndefined;
    }
    
    attrs[0] = "displayName";
    attrs[1] = NULL;
    sprintf(filter,
            "(&(objectCategory=controlAccessRight)"
            "(rightsGUID=%s))", 
            pszGuid
    );
    
    RpcStringFree(&pszGuid);

    dwErr = ldap_search_ext_s(hLdap,
                               (LPTSTR)LPCTSTR(ConfigNC),
                               LDAP_SCOPE_SUBTREE,
                               filter,
                               attrs,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               10000,
                               &ldap_message);
    
    if ( LDAP_SUCCESS != dwErr )
    {
        goto InsertUndefined;
    }

    if (    !(entry = ldap_first_entry(hLdap, ldap_message))
         || !(values = ldap_get_valuesA(hLdap, entry, attrs[0]))
         || !(cVals = ldap_count_valuesA(values))
         || !(sd_value = ldap_get_values_lenA(hLdap, entry, attrs[0])) )
    {
        ldap_msgfree(ldap_message);
        goto InsertUndefined;
    }

    AddGuidToCache(pGuid,  (char*)(*sd_value)->bv_val);
    ldap_value_free_len(sd_value);
    ldap_value_freeA(values);
    ldap_msgfree(ldap_message);

    return(gDynGuidCache->name);

InsertUndefined:
    
    AddGuidToCache(pGuid,  "Unknown");

    return(gDynGuidCache->name);
}


// there is library function (DumpSD) that dumps a security descriptor.
// in order todo this, it takes as an agrument the SD and thress callback
// functions, one for printing, one that takes care of finding the SID of a user
// and one for finding the real name of a particular GUID.
//
// since we didn't want to change this lib function to learn about CStrings
// and all the rest for ldp, we hacked the way the whole thing works,
// as a result we have a global vars that are used to transform the output
// from the DumpSD into reasonable strings
//
void CLdpDoc::SecDlgDumpSD(
    PSECURITY_DESCRIPTOR    input,
    CString                 str)
{

    pStr = &str;
    pDoc = this;

    DumpSD ((SECURITY_DESCRIPTOR *)input, SecDlgPrintSDFunc, LookupGuid, LookupSid);

    pStr = NULL;
    pDoc = NULL;
}

void CLdpDoc::SecDlgPrintSd(
    PSECURITY_DESCRIPTOR    input,
    CString                 str
    )
{
    SECURITY_DESCRIPTOR     *sd = (SECURITY_DESCRIPTOR *)input;
    CLdpView *pView;


    pView = (CLdpView*)GetOwnView(_T("CLdpView"));

    str.Format("Security Descriptor:");
    Print(str);


    if (sd == NULL)
    {
        str.Format("... is NULL");
        Print(str);
        return;
    }

    PrintStringSecurityDescriptor(sd);

    pView->SetRedraw(FALSE);
    pView->CacheStart();

    SecDlgDumpSD (input, str);

    //
    // now allow refresh
    //
    pView->CacheEnd();
    pView->SetRedraw();
}

int CLdpDoc::SecDlgGetSecurityData(
    CHAR            *dn,
    BOOL            sacl,
    CHAR            *account,               // OPTIONAL
    CString         str
    )
{
    PLDAPMessage    ldap_message = NULL;
    PTSTR           attributes[2];
    int             res = LDAP_SUCCESS;
    SECURITY_INFORMATION        info;
    BYTE            berValue[2*sizeof(ULONG)];


#ifdef SEC_DLG_ENABLE_SECURITY_PRIVILEGE

    HANDLE          token = NULL;
    TOKEN_PRIVILEGES    previous_state;

#endif

    LDAPControl     se_info_control =
                    {
                        TEXT(LDAP_SERVER_SD_FLAGS_OID),   // magic from SECURITY\NTMARTA
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };
    LDAPControl     ctrlShowDeleted = { LDAP_SERVER_SHOW_DELETED_OID };
    PLDAPControl    server_controls[] =
                    {
                        &se_info_control,
                        &ctrlShowDeleted,
                        NULL
                    };

    if (dn == NULL)
    {
        str.Format("DN specified is NULL");
        Print(str);

        return LDAP_INVALID_DN_SYNTAX; // the best I can find
    }

    /* First decide on the maximum security informaiton needed for our purpose */

    info = DACL_SECURITY_INFORMATION; // needed in all the cases

    if (! account)  // we want a security descriptor dump
    {
        info |= (GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION);

        if (sacl)
        {
            info |= SACL_SECURITY_INFORMATION;

#ifdef SEC_DLG_ENABLE_SECURITY_PRIVILEGE

            /* We don't know whether the bind was to a remote machine or local */
            /* So enable the local privilege & warn if it is not there */

            if (! OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                &token
                ))
            {
                str.Format("WARNING: Can't open your process token to adjust privilege, %u", GetLastError());
                Print(str);
                str.Format("WANRING: If your ldap_bind is to the local machine, Sacl can't be looked up");
                Print(str);
            }
            else
            {
                TOKEN_PRIVILEGES    t;
                DWORD               return_size;

// Stolen from NTSEAPI.H
#define SE_SECURITY_PRIVILEGE             (8L)

                t.PrivilegeCount = 1;
                t.Privileges[0].Luid.HighPart = 0;
                t.Privileges[0].Luid.LowPart = SE_SECURITY_PRIVILEGE;
                t.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                if (! AdjustTokenPrivileges(
                            token,
                            FALSE,  // no disabling of all
                            & t,
                            sizeof(previous_state),
                            & previous_state,
                            & return_size
                            ))
                {
                    str.Format("WARNING: Can't enable privilege to read SACL, %u", GetLastError());
                    Print(str);
                    str.Format("WANRING: If your ldap_bind is to the local machine, Sacl can't be looked up");
                    Print(str);

                    CloseHandle(token);
                    token = NULL;
                }

#undef SE_SECURITY_PRIVILEGE
            }

#endif
        }
    }

    attributes[0] = TEXT("nTSecurityDescriptor");
    attributes[1] = NULL;

    //
    //!!! The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)info & 0xF);

    res = ldap_search_ext_s(hLdap,
                              dn,
                              LDAP_SCOPE_BASE,
                              TEXT("(objectClass=*)"),
                              attributes,
                              0,
                              (PLDAPControl *)&server_controls,
                              NULL,
                              NULL,
                              10000,
                              &ldap_message);

    if(res == LDAP_SUCCESS)
    {
        LDAPMessage *entry = NULL;
        entry = ldap_first_entry(hLdap,
                                  ldap_message);

        if(entry == NULL)
        {
            res = hLdap->ld_errno;
        }
        else
        {
            //
            // Now, we'll have to get the values
            //
            PTSTR *values = ldap_get_values(hLdap,
                                                 entry,
                                                 attributes[0]);
            if(values == NULL)
            {
                res = hLdap->ld_errno;
            }
            else
            {
                PLDAP_BERVAL *sd_value = ldap_get_values_len(hLdap,
                                                          ldap_message,
                                                          attributes[0]);
                if(sd_value == NULL)
                {
                    res = hLdap->ld_errno;
                }
                else
                {
                    PSECURITY_DESCRIPTOR        sd = (PSECURITY_DESCRIPTOR)((*sd_value)->bv_val);

                    if (! account) // we just want a dump in this case
                    {
                        SecDlgPrintSd(
                             sd,
                             str
                             );
                    }
                    else // Effective rights dump
                    {
                        PACL            dacl;
                        BOOL            present, defaulted;

                        if (! GetSecurityDescriptorDacl(sd, &present, &dacl, &defaulted))
                        {
                            str.Format("Can't get DACL from the security descriptor, %u", GetLastError());
                            Print(str);

                            res = LDAP_INVALID_CREDENTIALS; // BEST I can find
                        }
                        else
                        {
                            TRUSTEE         t;
                            ACCESS_MASK     allowed_rights;
                            DWORD           error;

                            t.pMultipleTrustee = NULL;
                            t.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
                            t.TrusteeForm = TRUSTEE_IS_NAME;
                            t.TrusteeType = TRUSTEE_IS_UNKNOWN; // could be a group, alias, user etc.
                            t.ptstrName = account;

                            error = GetEffectiveRightsFromAcl(dacl, &t, &allowed_rights);
                            if (error)
                            {
                                str.Format("Can't get Effective Rights, %u", error);
                                Print(str);

                                res = LDAP_INVALID_CREDENTIALS; // BEST I can find
                            }
                            else
                            {
                                str.Format("%s is allowed 0x%08lx for %s", account, allowed_rights, dn);
                                Print(str);
                            }
                        }
                    }

                    ldap_value_free_len(sd_value);
                    ldap_value_free(values);
                }
            }
        }

        ldap_msgfree(ldap_message);
    }

#ifdef SEC_DLG_ENABLE_SECURITY_PRIVILEGE

    if ((! account) && sacl && token)
    {
        TOKEN_PRIVILEGES    trash;
        DWORD               return_size;

        if (! AdjustTokenPrivileges(
                    token,
                    FALSE,  // no disabling of all
                    & previous_state,
                    sizeof(trash),
                    & trash,
                    & return_size
                    ))
        {
            str.Format("WARNING: Can't reset the privilege to read SACL, %u", GetLastError());
            Print(str);

            CloseHandle(token);
            token = NULL;
        }
    }

#endif

    return res;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\secdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       secdlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SECDLG_H__2AF725D3_E359_11D0_A9A9_0000F803AA83__INCLUDED_)
#define AFX_SECDLG_H__2AF725D3_E359_11D0_A9A9_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SecDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// SecDlg dialog

class SecDlg : public CDialog
{
// Construction
public:
	SecDlg(CWnd* pParent = NULL);   // standard constructor
    ~SecDlg();
// Dialog Data
	//{{AFX_DATA(SecDlg)
	enum { IDD = IDD_SECURITY };
	CString	m_Dn;
	BOOL	m_Sacl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(SecDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(SecDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECDLG_H__2AF725D3_E359_11D0_A9A9_0000F803AA83__INCLUDED_)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\rdndlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rdndlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// RDNDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "rdndlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ModRDNDlg d;ialog


ModRDNDlg::ModRDNDlg(CWnd* pParent /*=NULL*/)
	: CDialog(ModRDNDlg::IDD, pParent)
{
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	//{{AFX_DATA_INIT(ModRDNDlg)
	m_bDelOld = TRUE;
	m_Old = _T("");
	m_New = _T("");
	m_Sync = TRUE;
	m_rename = FALSE;
	//}}AFX_DATA_INIT

	m_Sync = app->GetProfileInt("Operations", "ModRDNSync", m_Sync);
	m_rename = app->GetProfileInt("Operations", "ModRDNRename", m_rename);
}




ModRDNDlg::~ModRDNDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileInt("Operations", "ModRDNSync", m_Sync);
	app->WriteProfileInt("Operations", "ModRDNRename", m_rename);
}





void ModRDNDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ModRDNDlg)
	DDX_Check(pDX, IDC_DelOld, m_bDelOld);
	DDX_Text(pDX, IDC_OLDDN, m_Old);
	DDX_Text(pDX, IDC_NEWDN, m_New);
	DDX_Check(pDX, IDC_MODRDN_SYNC, m_Sync);
	DDX_Check(pDX, IDC_RENAME, m_rename);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ModRDNDlg, CDialog)
	//{{AFX_MSG_MAP(ModRDNDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ModRDNDlg message handlers

void ModRDNDlg::OnCancel()
{
	// TODO: Add extra cleanup here
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_MODRDNEND);
	DestroyWindow();
	
}

void ModRDNDlg::OnOK()
{
	UpdateData(TRUE);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_MODRDNGO);
	
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\rdndlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rdndlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// RDNDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// ModRDNDlg dialog

class ModRDNDlg : public CDialog
{
// Construction
public:
	ModRDNDlg(CWnd* pParent = NULL);   // standard constructor
	~ModRDNDlg();

// Dialog Data
	//{{AFX_DATA(ModRDNDlg)
	enum { IDD = IDD_MODRDN };
	BOOL	m_bDelOld;
	CString	m_Old;
	CString	m_New;
	BOOL	m_Sync;
	BOOL	m_rename;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ModRDNDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(ModRDNDlg)
	virtual void OnCancel();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\srchdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       srchdlg.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// SrchDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "SrchDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SrchDlg dialog


SrchDlg::SrchDlg(CWnd* pParent /*=NULL*/)
	: CDialog(SrchDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(SrchDlg)
	m_BaseDN = _T("");
	m_Filter = _T("");
	m_Scope = 1;
	//}}AFX_DATA_INIT

	CLdpApp *app = (CLdpApp*)AfxGetApp();


	m_BaseDN = app->GetProfileString("Operations",  "SearchBaseDn");
	m_Filter = app->GetProfileString("Operations",  "SearchFilter", "(objectclass=*)");
}


void SrchDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SrchDlg)
	DDX_Text(pDX, IDC_BASEDN, m_BaseDN);
	DDX_Text(pDX, IDC_FILTER, m_Filter);
	DDX_Radio(pDX, IDC_BASE, m_Scope);
	//}}AFX_DATA_MAP
	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileString("Operations",  "SearchBaseDn", m_BaseDN);
	app->WriteProfileString("Operations",  "SearchFilter", m_Filter);



}


BEGIN_MESSAGE_MAP(SrchDlg, CDialog)
	//{{AFX_MSG_MAP(SrchDlg)
	ON_BN_CLICKED(IDRUN, OnRun)
	ON_BN_CLICKED(IDD_SRCH_OPT, OnSrchOpt)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// SrchDlg message handlers


void SrchDlg::OnRun()
{
	UpdateData(TRUE);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_SRCHGO);
	
}

void SrchDlg::OnCancel()
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_SRCHEND);
	DestroyWindow();
}

void SrchDlg::OnSrchOpt()
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND,   ID_OPTIONS_SEARCH);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\srchopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       srchopt.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// SrchOpt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// SrchOpt dialog

class SearchInfo{
public:
		long lTlimit;
		long lSlimit;
		long lToutSec;
		long lToutMs;
		long lPageSize;
		BOOL bChaseReferrals;
		char *attrList[MAXLIST];
		BOOL bAttrOnly;
		int fCall;
};





class SrchOpt : public CDialog
{
// Construction


public:
	SrchOpt(CWnd* pParent = NULL);   // standard constructor
	SrchOpt(SearchInfo& Info, CWnd*pParent = NULL);
	void UpdateSrchInfo(SearchInfo&Info, BOOL Dir);
					

// Dialog Data
	//{{AFX_DATA(SrchOpt)
	enum { IDD = IDD_SRCH_OPT };
	int		m_SrchCall;
	CString	m_AttrList;
	BOOL	m_bAttrOnly;
	long	m_ToutMs;
	long	m_Tlimit;
	long	m_ToutSec;
	long	m_Slimit;
	BOOL	m_bDispResults;
	BOOL	m_bChaseReferrals;
	int		m_PageSize;
	//}}AFX_DATA
//	int		m_SrchDeref;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(SrchOpt)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(SrchOpt)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	Ldp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\srchdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       srchdlg.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// SrchDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// SrchDlg dialog



class SrchDlg : public CDialog
{
// Construction
public:
	SrchDlg(CWnd* pParent = NULL);   // standard constructor
	virtual void OnOK()			{	OnRun(); }


// Dialog Data
	//{{AFX_DATA(SrchDlg)
	enum { IDD = IDD_SRCH };
	CString	m_BaseDN;
	CString	m_Filter;
	int		m_Scope;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(SrchDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(SrchDlg)
	afx_msg void OnRun();
	virtual void OnCancel();
	afx_msg void OnSrchOpt();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\sortkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sortkdlg.cpp
//
//--------------------------------------------------------------------------

// SortKDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "SortKDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SortKDlg dialog


SortKDlg::SortKDlg(CWnd* pParent /*=NULL*/)
	: CDialog(SortKDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(SortKDlg)
	m_AttrType = _T("");
	m_MatchedRule = _T("");
	m_bReverse = FALSE;
	//}}AFX_DATA_INIT


	INT i, cbKList = 0;
	CLdpApp *app = (CLdpApp*)AfxGetApp();
	CString str;


	KList = NULL;


	// count controls
	cbKList = app->GetProfileInt("SortKeys",  "SortKeysCount", 0);

	if(cbKList!= 0){
		// alloc ControlInfoList
		KList = new PLDAPSortKey[cbKList+1];

		for(i = 0; i<cbKList; i++){

			LDAPSortKey *sk = KList[i] = new LDAPSortKey;

			str.Format("AttributeType_%d", i);
			str = app->GetProfileString("SortKeys",  str);
			sk->sk_attrtype = str.IsEmpty() ? NULL : _strdup(str);

         if(sk->sk_attrtype == NULL){
            //
            // no more sort keys
            //
            i++;
            break;
         }

			str.Format("MatchRuleOid_%d", i);
			str = app->GetProfileString("SortKeys",  str);
			sk->sk_matchruleoid = str.IsEmpty() ? NULL : _strdup(str);

			str.Format("ReverseOrder_%d", i);
			sk->sk_reverseorder = (UCHAR)app->GetProfileInt("SortKeys",  str, (INT)FALSE);
		}
		KList[i] = NULL;
	}

}




SortKDlg::~SortKDlg(){
	CString str;
	CLdpApp *app = (CLdpApp*)AfxGetApp();
   INT i;

   //
   // write count
   //
	for(i=0; KList!= NULL && KList[i] != NULL; i++);

	app->WriteProfileInt("SortKeys",  "SortKeysCount", i);


	for(i=0; KList!= NULL && KList[i] != NULL; i++){
		LDAPSortKey *sk = KList[i];

		str.Format("AttributeType_%d", i);
		app->WriteProfileString("SortKeys",  str, sk->sk_attrtype);

		str.Format("MatchRuleOid_%d", i);
		app->WriteProfileString("SortKeys",  str, sk->sk_matchruleoid);

		str.Format("ReverseOrder_%d", i);
		app->WriteProfileInt("SortKeys",  str, sk->sk_reverseorder);
		delete KList[i];
	}
	delete KList;
}



void SortKDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SortKDlg)
	DDX_Control(pDX, IDC_ACTIVELIST, m_ActiveList);
	DDX_Text(pDX, IDC_ATTRTYPE, m_AttrType);
	DDX_Text(pDX, IDC_MATCHRULE, m_MatchedRule);
	DDX_Check(pDX, IDC_REVERSE, m_bReverse);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SortKDlg, CDialog)
	//{{AFX_MSG_MAP(SortKDlg)
	ON_LBN_DBLCLK(IDC_ACTIVELIST, OnDblclkActivelist)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// SortKDlg message handlers

void SortKDlg::OnDblclkActivelist()
{
	OnRemove();
	
}

void SortKDlg::OnAdd()
{
	INT index;

	UpdateData(TRUE);
	if(m_AttrType.IsEmpty()){
		MessageBox("Please provide Attribute Type string", "Usage Error", MB_ICONHAND|MB_OK);
	}
	else{
		if(LB_ERR == (index = m_ActiveList.FindStringExact(0, m_AttrType))){
			index = m_ActiveList.AddString(m_AttrType);
			PLDAPSortKey sk = new LDAPSortKey;
			sk->sk_attrtype = _strdup(m_AttrType);
			sk->sk_matchruleoid = m_MatchedRule.IsEmpty()? NULL : _strdup(m_MatchedRule);
			sk->sk_reverseorder = (UCHAR)m_bReverse;

			m_ActiveList.SetItemDataPtr(index, (PVOID)sk);
		}
		else{
			PLDAPSortKey sk = (PLDAPSortKey)m_ActiveList.GetItemDataPtr(index);

			m_AttrType = sk->sk_attrtype;
			m_MatchedRule = sk->sk_matchruleoid != NULL ? sk->sk_matchruleoid : "";
			m_bReverse = sk->sk_reverseorder;
		}
        // commit addition (see bug 447445 for history)
        UpdateData(FALSE);
        m_ActiveList.SetCurSel(index);
	}
}




void SortKDlg::OnRemove()
{
	UpdateData(TRUE);
	INT index = m_ActiveList.GetCurSel();
	if(index == LB_ERR){
		MessageBox("Please select Active SortKey to remove", "Usage Error",MB_ICONHAND|MB_OK);
	}
	else{
		PLDAPSortKey sk = (PLDAPSortKey)m_ActiveList.GetItemDataPtr(index);
		m_AttrType = sk->sk_attrtype;
		m_MatchedRule = sk->sk_matchruleoid != NULL ? sk->sk_matchruleoid : "";
		m_bReverse = sk->sk_reverseorder;
		delete sk;
		m_ActiveList.DeleteString(index);

		UpdateData(FALSE);
	}
	
}






void SortKDlg::OnOK()
{

	INT i;
	
   if(m_ActiveList.GetCount() == 0)
      KList = NULL;
   else{
   	KList = new LDAPSortKey * [m_ActiveList.GetCount()+1];
   	for(i=0; i< m_ActiveList.GetCount(); i++){
   		KList[i] = (LDAPSortKey*)m_ActiveList.GetItemDataPtr(i);
   	}
   	KList[i] = NULL;
   }
	
	CDialog::OnOK();
}




BOOL SortKDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	for(INT i=0; KList!= NULL && KList[i] != NULL; i++){
		LDAPSortKey *sk = KList[i];
		INT index = m_ActiveList.AddString(sk->sk_attrtype);
		m_ActiveList.SetItemDataPtr(index, (PVOID)sk);
	}
	delete KList;
	KList= NULL;
	if(m_ActiveList.GetCount() > 0)
		m_ActiveList.SetCurSel(0);


	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\srchopt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       srchopt.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// SrchOpt.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "SrchOpt.h"

//#include "lber.h"
//#include "ldap.h"
#ifdef  WINLDAP

#include "winldap.h"

#else
#include "lber.h"
#include "ldap.h"
#include "proto-ld.h"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif




#define LIST_DELIMITER        0x1
#define DELIMITERS_STRING     "\01"



/////////////////////////////////////////////////////////////////////////////
// SrchOpt dialog


SrchOpt::SrchOpt(CWnd* pParent /*=NULL*/)
	: CDialog(SrchOpt::IDD, pParent)
{
	//{{AFX_DATA_INIT(SrchOpt)
	m_SrchCall = 1;
	m_AttrList = _T("");
	m_bAttrOnly = FALSE;
	m_ToutMs = 0;
	m_Tlimit = 0;
	m_ToutSec = 0;
	m_Slimit = 0;
	m_bDispResults = TRUE;
	m_bChaseReferrals = FALSE;
	m_PageSize = 0;
	//}}AFX_DATA_INIT


	CLdpApp *app = (CLdpApp*)AfxGetApp();



/**
	m_SrchCall = app->GetProfileInt("Search_Operations",  "SearchSync", m_SrchCall);
	m_AttrList = app->GetProfileString("Search_Operations",  "SearchAttrList", m_AttrList);
	m_bAttrOnly = app->GetProfileInt("Search_Operations",  "SearchAttrOnly", m_bAttrOnly);
	m_ToutMs = app->GetProfileInt("Search_Operations",  "SearchToutMs", m_ToutMs);
	m_Tlimit = app->GetProfileInt("Search_Operations",  "SearchTlimit", m_Tlimit);
	m_ToutSec = app->GetProfileInt("Search_Operations",  "SearchToutSec", m_ToutSec);
	m_Slimit = app->GetProfileInt("Search_Operations",  "SearchSlimit", m_Slimit);
**/

}


SrchOpt::SrchOpt(SearchInfo& Info, CWnd* pParent /*=NULL*/)
	: CDialog(SrchOpt::IDD, pParent)
{

	UpdateSrchInfo(Info, FALSE);
}




void SrchOpt::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SrchOpt)
 	DDX_Radio(pDX, IDC_ASYNC, m_SrchCall);
	DDX_Text(pDX, IDC_SRCH_ATTLIST, m_AttrList);
	DDX_Check(pDX, IDC_SRCH_ATTRONLY, m_bAttrOnly);
	DDX_Text(pDX, IDC_SRCH_MTOUT, m_ToutMs);
	DDV_MinMaxLong(pDX, m_ToutMs, 0, 999999999);
	DDX_Text(pDX, IDC_SRCH_TLIMIT, m_Tlimit);
	DDV_MinMaxLong(pDX, m_Tlimit, 0, 999999999);
	DDX_Text(pDX, IDC_SRCH_TOUT, m_ToutSec);
	DDV_MinMaxLong(pDX, m_ToutSec, 0, 999999999);
	DDX_Text(pDX, IDC_SRCH_SLIMIT, m_Slimit);
	DDV_MinMaxLong(pDX, m_Slimit, 0, 999999999);
	DDX_Check(pDX, IDC_DISP_RESULTS, m_bDispResults);
	DDX_Check(pDX, IDC_CHASE_REFERRALS, m_bChaseReferrals);
	DDX_Text(pDX, IDC_SRCH_PAGESIZE, m_PageSize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SrchOpt, CDialog)
	//{{AFX_MSG_MAP(SrchOpt)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// SrchOpt message handlers


void SrchOpt::UpdateSrchInfo(SearchInfo& Info, BOOL Dir = TRUE){

	int i;
	static BOOL FirstCall = TRUE;

	if(Dir){				// TRUE: Update given struct with current info
		Info.fCall = m_SrchCall;
		Info.bChaseReferrals = m_bChaseReferrals;
		Info.bAttrOnly = m_bAttrOnly;
		Info.lToutMs = m_ToutMs;
		Info.lTlimit = m_Tlimit;
		Info.lToutSec = m_ToutSec;
		Info.lSlimit = m_Slimit;
		Info.lPageSize= m_PageSize;

      //
      // now handle attrList:
      //  - free prev
      //  - parse UI format
      //  - insert to list
      //
      if(Info.attrList[0] != NULL){
         free(Info.attrList[0]);
         Info.attrList[0] = NULL;
      }

      //
      // replace attrList delimiter list so that we can
      // escape the UI delimiter ';'
      //
      LPTSTR p = _strdup(LPCTSTR(m_AttrList));
      LPTSTR t;
      for(t = p; t != NULL && *t != '\0'; t++){

         if(*t == '"'){
            t = strchr(++t, '"');
         }
         if(!t)
            break;
         if(*t == ';')
            *t = LIST_DELIMITER;
      }
      //
      // pack string out of '"'
      //
      for(t=p; t!= NULL && *t != '\0'; t++){
         if (*t=='"') {
            for(LPTSTR v = t;
                  NULL != v && '\0' != *v;
                  *v = *(v+1), v++);
            v = NULL;
         }
      }

      //
      // parse out attrList
      //
      for(i=0, Info.attrList[i] = strtok(p, DELIMITERS_STRING);
          Info.attrList[i]!= NULL;
          Info.attrList[++i] = strtok(NULL, DELIMITERS_STRING));

	}
	else{					// FALSE: Update current info with struct
		m_SrchCall = Info.fCall;
		m_bChaseReferrals = Info.bChaseReferrals;
		m_bAttrOnly = Info.bAttrOnly;
		m_ToutMs = Info.lToutMs;
		m_Tlimit = Info.lTlimit;
		m_ToutSec = Info.lToutSec;
		m_Slimit = Info.lSlimit;
		m_PageSize = Info.lPageSize;

		m_AttrList.Empty();
		for(i=0; Info.attrList != NULL && Info.attrList[i] != NULL; i++)
				m_AttrList += CString(Info.attrList[i]) + _T(";");
	}
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\sortkdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sortkdlg.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SORTKDLG_H__1BD80CD9_E1A5_11D0_A9A8_0000F803AA83__INCLUDED_)
#define AFX_SORTKDLG_H__1BD80CD9_E1A5_11D0_A9A8_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SortKDlg.h : header file
//


#include <winldap.h>

/////////////////////////////////////////////////////////////////////////////
// SortKDlg dialog

class SortKDlg : public CDialog
{
// data
public:

	PLDAPSortKey *KList;

// Construction
public:
	SortKDlg(CWnd* pParent = NULL);   // standard constructor
	~SortKDlg();
// Dialog Data
	//{{AFX_DATA(SortKDlg)
	enum { IDD = IDD_SORTKDLG };
	CListBox	m_ActiveList;
	CString	m_AttrType;
	CString	m_MatchedRule;
	BOOL	m_bReverse;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(SortKDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(SortKDlg)
	afx_msg void OnDblclkActivelist();
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SORTKDLG_H__1BD80CD9_E1A5_11D0_A9A8_0000F803AA83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

extern "C" {
#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

}

#ifdef __cplusplus
}
#endif



// ASSERT is redefined in afx.h -- use the MFC version.
#ifdef ASSERT
#   undef ASSERT
#endif

#define NOFLATSBAPIS
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>		// Template support
#include <afxcview.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT



#define MAXSTR			2048
#define MAXLIST			2048
#define ID_SRCHEND		500
#define ID_SRCHGO		501
#define ID_ADDEND		502
#define ID_ADDGO		503
#define ID_MODRDNEND	504
#define ID_MODRDNGO		505
#define ID_MODEND		506
#define ID_MODGO		507
#define ID_PENDEND		508
#define ID_PROCPEND 	509
#define ID_PENDANY	 	510
#define ID_PENDABANDON	511
#define ID_COMPGO		512
#define ID_COMPEND		513
#define ID_SHOWVALS		514
#define ID_BIND_OPT_OK	515
#define ID_SSPI_DOMAIN_SHORTCUT	516
#define ID_EXTOPEND		517
#define ID_EXTOPGO		518

// common

#define CALL_ASYNC		0
#define CALL_SYNC		1
#define CALL_TSYNC		2
#define CALL_EXTS		3
#define CALL_PAGED		4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\vlvdialog.h ===
#if !defined(AFX_VLVDIALOG_H__5519735E_947C_4914_B2C9_2313041E84F9__INCLUDED_)
#define AFX_VLVDIALOG_H__5519735E_947C_4914_B2C9_2313041E84F9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// VLVDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVLVDialog dialog

class CVLVListItem
{
public:
    CVLVListItem (ULONG numCols);
    ~CVLVListItem ();
    void Destroy ();
    void SetCol (int col, const char *sz);
    char *GetCol(int col)
    {
        if (col > m_numCols) {
            return NULL;
        }
        else {
            return m_ppData[col];
        }
    }

protected:
    ULONG m_numCols;
    char **m_ppData;
};

class  CVLVListCache
{
public:
    CVLVListCache(ULONG cacheSize, ULONG numcols = 1) ;
    ~CVLVListCache();

    void Destroy();
    void FlushCache(void); 

    CVLVListItem *GetCacheRow (ULONG row);
    BOOL  IsWindowVisible (ULONG from, ULONG to);
    ULONG SetCacheWindow (ULONG from, ULONG to);
    
    ULONG m_From;
    ULONG m_To;

    ULONG m_numCols;
    ULONG m_cCache;
    CVLVListItem **m_pCachedItems;
};


class CVLVDialog : public CDialog
{
// Construction
public:
	CVLVDialog(CWnd* pParent = NULL);   // standard constructor
    ~CVLVDialog();

	void SetContextActivation(BOOL bFlag=TRUE) {
		// sets the state w/ default TRUE
		m_bContextActivated = bFlag;
	}
	BOOL GetContextActivation(void) {
		// sets & returns the state w/ default TRUE
		return m_bContextActivated;
	}
    CString GetDN(void)   { return m_dn; }
    BOOL    GetState()    { return m_RunState; }

    void    RunQuery ();

// Dialog Data
	//{{AFX_DATA(CVLVDialog)
	enum { IDD = IDD_VLV_DLG };
	CListCtrl	m_listctrl;
	CString	m_BaseDN;
	int		m_Scope;
	CString	m_Filter;
	CString	m_FindStr;
	long	m_EstSize;
	//}}AFX_DATA

    CLdpDoc    *pldpdoc;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVLVDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation

    BOOL   m_RunState;
    CString m_dn;             // used for cut & paste, popup menu
    
    ULONG m_contentCount;
    ULONG m_currentPos;
    ULONG m_beforeCount;
    ULONG m_afterCount;

    ULONG m_numCols;

    PBERVAL m_vlvContext;

    RECT m_origSize;
    BOOL m_DoFindStr;
    BOOL m_bContextActivated;

    WNDPROC m_OriginalRichEditWndProc;
    SCROLLINFO m_Si;

    CVLVListCache *m_pCache;
    int    m_CntColumns;
    char **m_pszColumnNames;

protected:

	// Generated message map functions
	//{{AFX_MSG(CVLVDialog)
	afx_msg void OnClose();
	afx_msg void OnGetdispinfoVlvList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnOdcachehintVlvList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnOdfinditemVlvList(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnRun();
	afx_msg void OnSrchOpt();
	afx_msg void OnRclickVlvList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateFindstr();
	afx_msg void OnKillfocusFindstr();
	afx_msg void OnBtnUp();
	afx_msg void OnDblclkVlvList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    afx_msg void OnContextMenu(CWnd* /*pWnd*/, CPoint point);

    static LRESULT CALLBACK _ListCtrlWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    void DoVlvSearch();
    void StopSearch();
    void ParseSearchResults (LDAPMessage *msg);
    void FreeColumns();
    ULONG CreateColumns();
    ULONG MapAttributeToColumn(const char *pAttr);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VLVDIALOG_H__5519735E_947C_4914_B2C9_2313041E84F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\vlvdialog.cpp ===
// VLVDialog.cpp : implementation file
//
#include "stdafx.h"
#include "Ldp.h"
#include "LdpDoc.h"
#include "VLVDialog.h"

#ifdef _DEBUG_MEMLEAK
#include <crtdbg.h>
#endif

#ifdef _DEBUG_MEMLEAK
   _CrtMemState vlv_s1, vlv_s2, vlv_s3;      // detect mem leaks
   static int whichTurn = 0;

#endif


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVLVDialog dialog


CVLVDialog::CVLVDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CVLVDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CVLVDialog)
	m_BaseDN = _T("");
	m_Scope = 1;
	m_Filter = _T("");
	m_FindStr = _T("");
	m_EstSize = 0;
	//}}AFX_DATA_INIT

    m_contentCount = 0;
    m_currentPos = 1;
    m_vlvContext = NULL;
    m_afterCount = 1;
    m_beforeCount = 0;
    m_numCols = 0;

    m_RunState = FALSE;
    m_DoFindStr = FALSE;
    m_bContextActivated = FALSE;

    m_CntColumns = 0;
    m_pszColumnNames = NULL;
    m_pCache = NULL;

	CLdpApp *app = (CLdpApp*)AfxGetApp();
	m_BaseDN = app->GetProfileString("Operations",  "SearchVLVBaseDn");
	m_Filter = app->GetProfileString("Operations",  "SearchVLVFilter", "(objectclass=*)");
}

CVLVDialog::~CVLVDialog() 
{
    StopSearch();
    FreeColumns();
    if (m_pCache) {
        delete m_pCache;
    }
}

void CVLVDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVLVDialog)
	DDX_Control(pDX, IDC_VLV_LIST, m_listctrl);
	DDX_Text(pDX, IDC_BASEDN, m_BaseDN);
	DDX_Radio(pDX, IDC_BASE, m_Scope);
	DDX_Text(pDX, IDC_FILTER, m_Filter);
	DDX_Text(pDX, IDC_FINDSTR, m_FindStr);
	DDX_Text(pDX, IDC_EST_SIZE, m_EstSize);
	//}}AFX_DATA_MAP

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileString("Operations",  "SearchVLVBaseDn", m_BaseDN);
	app->WriteProfileString("Operations",  "SearchVLVFilter", m_Filter);
}


BEGIN_MESSAGE_MAP(CVLVDialog, CDialog)
	//{{AFX_MSG_MAP(CVLVDialog)
	ON_BN_CLICKED(IDCANCEL, OnClose)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_VLV_LIST, OnGetdispinfoVlvList)
	ON_NOTIFY(LVN_ODCACHEHINT, IDC_VLV_LIST, OnOdcachehintVlvList)
	ON_NOTIFY(LVN_ODFINDITEM, IDC_VLV_LIST, OnOdfinditemVlvList)
	ON_BN_CLICKED(IDRUN, OnRun)
	ON_BN_CLICKED(IDD_SRCH_OPT, OnSrchOpt)
	ON_NOTIFY(NM_RCLICK, IDC_VLV_LIST, OnRclickVlvList)
	ON_WM_SIZE()
	ON_EN_UPDATE(IDC_FINDSTR, OnUpdateFindstr)
	ON_EN_KILLFOCUS(IDC_FINDSTR, OnKillfocusFindstr)
	ON_BN_CLICKED(IDC_BTN_UP, OnBtnUp)
	ON_NOTIFY(NM_DBLCLK, IDC_VLV_LIST, OnDblclkVlvList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVLVDialog message handlers

BOOL CVLVDialog::OnInitDialog() 
{
    CDialog::OnInitDialog();  // let the base class do the default work

    DWORD exStyle = m_listctrl.GetExtendedStyle();
    m_listctrl.SetExtendedStyle (exStyle | LVS_EX_FULLROWSELECT | LVS_SINGLESEL);

	UpdateData(TRUE);  // bring the information from the dialog.	

    SetWindowLongPtr( HWND(m_listctrl), GWLP_USERDATA, (LONG_PTR) this);
    m_OriginalRichEditWndProc = (WNDPROC) SetWindowLongPtr(HWND(m_listctrl),
                                                   GWLP_WNDPROC,
                                                   (LONG_PTR)_ListCtrlWndProc);

    GetClientRect(&m_origSize);

    //CBitmap *pImage= new CBitmap;
    //pImage->LoadBitmap(IDB_FOLDER_UP); 

    //CButton* pBtnUp;
    //pBtnUp = (CButton*) GetDlgItem(IDC_BTN_UP);
    //pBtnUp->SetBitmap(::LoadBitmap(NULL, MAKEINTRESOURCE(IDB_FOLDER_UP)));
    //pBtnUp->SetBitmap(HBITMAP (pImage));
    //pImage->DeleteObject();

    //pBtnUp->SetButtonStyle (BS_CENTER | BS_BITMAP, TRUE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//
// post the search options dialog
//
void CVLVDialog::OnSrchOpt() 
{
	AfxGetMainWnd()->PostMessage(WM_COMMAND,   ID_OPTIONS_SEARCH);
}


//
// A virtual list view control maintains very little item information on its own. 
// As a result, it often sends the LVN_GETDISPINFO notification message to request
// item information. This message is handled in much the same way as callback items
// in a standard list control. Because the number of items supported by the control 
// can be very large, caching item data improves performance. 
//
// When handling LVN_GETDISPINFO, the owner of the control first attempts to supply
// requested item information from the cache. If the requested item is not cached, 
// the owner must be prepared to supply the information by other means.
//
void CVLVDialog::OnGetdispinfoVlvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	LV_ITEM* pItem= &(pDispInfo)->item;
	int iItemIndx = pItem->iItem;

	*pResult = 0;

    if (!m_RunState) {    
        return;
    }

	if (pItem->mask & LVIF_TEXT) //valid text buffer?
	{
        CVLVListItem *pVLVItem;
        char *pStr = NULL;

        pVLVItem = m_pCache->GetCacheRow(iItemIndx + 1);

		if (pVLVItem) {
			pStr = pVLVItem->GetCol (pItem->iSubItem+1);
        }

		if (!pStr) {
            //pItem->pszText = "";
            lstrcpy (pItem->pszText, "");
        }
        else {
            lstrcpy (pItem->pszText, pStr);
        }
	}
}

//
// A virtual list view sends the LVN_ODCACHEHINT notification message to
// assist in optimizing the cache. The notification message provides inclusive
// index values for a range of items that it recommends be cached. 
// Upon receiving the notification message, the owner must be prepared 
// to load the cache with item information for the requested range so that 
// the information will be readily available when an LVN_GETDISPINFO 
// message is sent. 
//
void CVLVDialog::OnOdcachehintVlvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NMLVCACHEHINT* pCacheHint = (NMLVCACHEHINT*)pNMHDR;
    int iFrom, iTo;

	*pResult = 0;

    if (!m_RunState || m_DoFindStr) {    
        return;
    }

    if (!pldpdoc) {
        return;
    }
    
    iFrom = pCacheHint->iFrom;
    iTo =  pCacheHint->iTo;

    // check if we need data
    if (!m_pCache->IsWindowVisible (iFrom+1, iTo+1)) {
        m_currentPos = iFrom + 1;
        ASSERT (m_afterCount >= (iTo-iFrom));
        DoVlvSearch();
    }
}


//
// The LVN_ODFINDITEM notification message is sent by a virtual list view control 
// when the control needs the owner to find a particular callback item. 
// The notification message is sent when the list view control receives 
// quick key access or when it receives an LVM_FINDITEM message. 
// Search information is sent in the form of an LVFINDINFO structure, 
// which is a member of the NMLVFINDITEM structure. 
//
// The owner must be prepared to search for an item that matches the
// information given by the list view control. 
// The owner returns the index of the item if successful, 
// or -1 if no matching item is found
//

void CVLVDialog::OnOdfinditemVlvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	*pResult = -1;
    
    if (!m_RunState) {    
        return;
    }

    NMLVFINDITEM* pFindInfo = (NMLVFINDITEM*)pNMHDR;
	
    if (pldpdoc) {
        CString findStr = pFindInfo->lvfi.psz;
        if (findStr.GetLength()==1) {
            m_FindStr += findStr;
        }
        else {
            m_FindStr = findStr;
        }
        UpdateData (FALSE);

        CEdit* pFindStr;
        pFindStr = (CEdit*) GetDlgItem(IDC_FINDSTR);
        GotoDlgCtrl(pFindStr);
        pFindStr->SetSel (-1, 0, TRUE); 
    }
}


//
// handle double clicking on the VLV list
// this updates the base DN and does a new search
//
void CVLVDialog::OnDblclkVlvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	*pResult = 0;
    
    if (!m_RunState) {    
        return;
    }

    NMITEMACTIVATE *pItemActivate = (NMITEMACTIVATE *)pNMHDR;
    
    if (pItemActivate->iItem != -1) {
        
        CVLVListItem *pVLVItem;
        pVLVItem = m_pCache->GetCacheRow(pItemActivate->iItem + 1);
        
        if (pVLVItem) {
            m_dn = pVLVItem->GetCol (0);
            m_BaseDN =  m_dn;
            UpdateData (FALSE);
            
            OnRun() ;
        }
    }
}

//
// handle right click on the VLV list
// this posts the context sensitive menu
//
void CVLVDialog::OnRclickVlvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NMITEMACTIVATE *pItemActivate = (NMITEMACTIVATE *)pNMHDR;

	*pResult = 0;

    if (!m_RunState) {    
        return;
    }

    if (pItemActivate->iItem != -1) {
        POINT Point;
        if ( m_listctrl.GetItemPosition(pItemActivate->iItem, &Point)) {
            
            CVLVListItem *pVLVItem;
            pVLVItem = m_pCache->GetCacheRow(pItemActivate->iItem + 1);

            if (pVLVItem) {
                m_dn = pVLVItem->GetCol (0);
            }

			CPoint local = Point;
			ClientToScreen(&local);
			OnContextMenu(this, local);
        }
    }
}

//
// display the context sensitive menu
//
void CVLVDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // make sure window is active
    GetParentFrame()->ActivateFrame();

    CPoint local = point;
    ScreenToClient(&local);

    CMenu menu;
    if (menu.LoadMenu(IDR_TREE_CONTEXT)){
       CMenu* pContextMenu = menu.GetSubMenu(0);
       ASSERT(pContextMenu!= NULL);

	   SetContextActivation(TRUE);
       pContextMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					          point.x, point.y,
							  AfxGetMainWnd()); // use main window for cmds
    }
}

//
// free all the stored column names
//
void CVLVDialog::FreeColumns()
{
    if (m_pszColumnNames) {
        for (int i=0; i<m_CntColumns; i++) {
            if (m_pszColumnNames[i]) {
                free (m_pszColumnNames[i]);
            }
        }
        free (m_pszColumnNames);
    }
    m_pszColumnNames = NULL;
}

//
// copy all the column names from the search option dialog
//
ULONG CVLVDialog::CreateColumns()
{
    FreeColumns();

    SearchInfo *pSrchInfo = &pldpdoc->SrchInfo;
    int i, cnt;

	for(cnt=0; ;cnt++) {
        if (!pSrchInfo->attrList[cnt]) 
            break;
    }
    if (cnt==0) {
        cnt=1;
    }

    m_CntColumns = 0;
    m_pszColumnNames = (char **)malloc (sizeof (char *) * (cnt + 1));
    if (!m_pszColumnNames) {
        return 0;
    }

    for (i=0; i<cnt; i++) {
        if (!pSrchInfo->attrList[i]) {
            m_pszColumnNames[i] = _strdup ("name");
        }
        else {
            m_pszColumnNames[i] = _strdup (pSrchInfo->attrList[i]);
        }
    }
    m_pszColumnNames[cnt]=NULL;

    m_CntColumns = cnt;

    return m_CntColumns;
}

//
// map an attribute returned by the ldap call to the correct column
//
ULONG CVLVDialog::MapAttributeToColumn(const char *pAttr)
{
    for (int i=0; i<m_CntColumns; i++) {
        if (_stricmp (m_pszColumnNames[i], pAttr) == 0) {
            return i+1;
        }
    }
    return 0;
}

void CVLVDialog::OnClose() 
{
    StopSearch();
    if (m_pCache) {
        delete m_pCache;
        m_pCache = NULL;
    }

    m_FindStr = "";
    UpdateData(FALSE);   
    CDialog::OnOK();
}

void CVLVDialog::RunQuery ()
{
    OnRun() ;
}

void CVLVDialog::OnRun() 
{
    CRect rect;
    int cnt, i;

    if (m_RunState) {
        StopSearch();
        UpdateData(TRUE);   
        m_FindStr = "";
        UpdateData(FALSE);   
    }

    m_RunState = TRUE; 

    UpdateData(TRUE);   

    if (!pldpdoc) {
        return;
    }
    
    cnt = CreateColumns();

    // delete all columns from the list control
    // if we delete the col0, all the rest are shifted.
    while (m_listctrl.DeleteColumn(0))
        ;

    // populate list control with columns
	m_listctrl.GetWindowRect(&rect);
    for (i=0; i<cnt; i++) {
        m_listctrl.InsertColumn(i, m_pszColumnNames[i], LVCFMT_LEFT, rect.Width() / cnt, 0);
    }

    m_EstSize = m_contentCount = 0;
    m_listctrl.SetItemCount (m_contentCount);

    m_currentPos = 1;
    m_beforeCount = m_afterCount = m_listctrl.GetCountPerPage() + 1;

    // create a new cache (if needed) to hold all the entries
    m_numCols = cnt;

    if (!m_pCache || (m_pCache && m_pCache->m_numCols != (m_numCols + 1))) {

        if (m_pCache) {
            delete m_pCache;
        }

        m_pCache = new CVLVListCache ((m_afterCount+1) * 2, m_numCols + 1);
    }

    m_pCache->FlushCache();
    DoVlvSearch();

#ifdef _DEBUG_MEMLEAK
    if (whichTurn == 0) {
        _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
        _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
        _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_DEBUG );
        
        _CrtMemCheckpoint (&vlv_s1);
		whichTurn=1;
    }
    else if (whichTurn == 1) {
        _CrtMemCheckpoint (&vlv_s2);

       _CrtMemDifference( &vlv_s3, &vlv_s1, &vlv_s2 );

        _CrtMemDumpStatistics( &vlv_s3 );
        whichTurn=2;
    }
    else if (whichTurn == 2) {
        _CrtMemCheckpoint (&vlv_s1);

       _CrtMemDifference( &vlv_s3, &vlv_s2, &vlv_s1 );

        _CrtMemDumpStatistics( &vlv_s3 );
        whichTurn=1;
    }
#endif
}

void CVLVDialog::StopSearch()
{
    m_listctrl.DeleteAllItems();
    m_EstSize = m_contentCount = 0;
    m_listctrl.SetItemCount (m_contentCount);

    if (m_vlvContext) {
        ber_bvfree (m_vlvContext);        
        m_vlvContext = NULL;
    }
    m_RunState = FALSE;
}


void CVLVDialog::DoVlvSearch ()
{
    if (!pldpdoc || !m_RunState) {
        return;
    }

    LDAP *hLdap = pldpdoc->hLdap;
    PLDAPSortKey *SortKeys = pldpdoc->m_SKDlg->KList;
    LDAPSortKey  sortkey = {"Name", NULL, FALSE};
    PLDAPSortKey localSortKey[2];

    PLDAPControl *SvrCtrls = pldpdoc->m_CtrlDlg->AllocCtrlList(ctrldlg::CT_SVR);
    PLDAPControl *ClntCtrls = pldpdoc->m_CtrlDlg->AllocCtrlList(ctrldlg::CT_CLNT);
    LDAPControl SortCtrl;
    PLDAPControl *CombinedCtrl = NULL;
    ULONG err, MsgId;
    int i, cbCombined;
    CString str;
    LDAPMessage *msg;

    LDAPVLVInfo     vlvInfo;
    PLDAPControl    pvlvctrl;
    LDAP_BERVAL     attrVal;
    char            seekVal[MAXSTR+1];
    LDAP_TIMEVAL    tm;
    ULONG           old_contentCount = m_contentCount;

    // DN
    LPTSTR dn = m_BaseDN.IsEmpty()? NULL :  (LPTSTR)LPCTSTR(m_BaseDN);

    // Scope
    int scope = m_Scope == 0 ? LDAP_SCOPE_BASE :
                m_Scope == 1 ? LDAP_SCOPE_ONELEVEL :
                LDAP_SCOPE_SUBTREE;

    // filter
    if(m_Filter.IsEmpty())
    {
        AfxMessageBox("Please enter a valid filter string (such as objectclass=*). Empty string is invalid.");
        return;
    }
    LPTSTR filter = (LPTSTR)LPCTSTR(m_Filter);


    //
    // init local time struct
    //
    tm.tv_sec = pldpdoc->SrchInfo.lToutSec;
    tm.tv_usec = pldpdoc->SrchInfo.lToutMs;

    if (SortKeys == NULL) {
        localSortKey[0] = &sortkey;
        localSortKey[1] = NULL;
        SortKeys = localSortKey;
    }

    if(SortKeys != NULL)
    {
        err = ldap_encode_sort_controlA(hLdap,
                                        SortKeys,
                                        &SortCtrl,
                                        FALSE);
        if(err != LDAP_SUCCESS)
        {
            str.Format("Error <0x%X>: ldap_create_encode_control returned: %s", err, ldap_err2string(err));
            pldpdoc->Out(str);
            SortKeys = NULL;
        }
    }

    CombinedCtrl = NULL;

    //
    // count total controls
    //
    for(i=0, cbCombined=0; SvrCtrls != NULL && SvrCtrls[i] != NULL; i++)
        cbCombined++;
    CombinedCtrl = new PLDAPControl[cbCombined+3];
    //
    // set combined
    //
    for(i=0; SvrCtrls != NULL && SvrCtrls[i] != NULL; i++)
        CombinedCtrl[i] = SvrCtrls[i];
    if(SortKeys != NULL)
        CombinedCtrl[i++] = &SortCtrl;


    vlvInfo.ldvlv_before_count = m_beforeCount;
    vlvInfo.ldvlv_after_count = m_afterCount;
    vlvInfo.ldvlv_offset = m_currentPos;
    vlvInfo.ldvlv_count = m_contentCount;
    if (!m_FindStr.IsEmpty() && m_DoFindStr) {
        strncpy (seekVal, LPCTSTR(m_FindStr), MAXSTR);
        vlvInfo.ldvlv_attrvalue = &attrVal;
        vlvInfo.ldvlv_attrvalue->bv_len = strlen (seekVal);
        vlvInfo.ldvlv_attrvalue->bv_val = seekVal;
    }
    else {
        vlvInfo.ldvlv_attrvalue = NULL;
    }
    vlvInfo.ldvlv_context = m_vlvContext;
    vlvInfo.ldvlv_extradata = NULL;
    vlvInfo.ldvlv_version = LDAP_VLVINFO_VERSION;


    err = ldap_create_vlv_control( hLdap,
                                   &vlvInfo,
                                   TRUE,
                                   &pvlvctrl);

    if(err != LDAP_SUCCESS)
    {
        str.Format("Error <0x%X>: ldap_create_vlv_control returned: %s", err, ldap_err2string(err));
        pldpdoc->Out(str);
        pvlvctrl = NULL;
    }

    if(pvlvctrl != NULL)
        CombinedCtrl[i++] = pvlvctrl;

    CombinedCtrl[i] = NULL;


    //
    // call search
    //
    BeginWaitCursor();
    err = ldap_search_ext_s(hLdap,
                            dn,
                            scope,
                            filter,
                            m_pszColumnNames,
                            pldpdoc->SrchInfo.bAttrOnly,
                            CombinedCtrl,
                            ClntCtrls,
                            &tm,
                            pldpdoc->SrchInfo.lSlimit,
                            &msg);
    EndWaitCursor();

    //
    // cleanup
    //
    if(SortKeys != NULL)
    {
        ldap_memfree(SortCtrl.ldctl_value.bv_val);
        ldap_memfree(SortCtrl.ldctl_oid);
    }
    if(pvlvctrl != NULL) {
        ldap_control_free (pvlvctrl);
    }
    delete CombinedCtrl;
    pldpdoc->FreeControls(SvrCtrls);
    pldpdoc->FreeControls(ClntCtrls);

    if(err != LDAP_SUCCESS)
    {
        str.Format("Error: Search: %s. <%ld>", ldap_err2string(err), err);
        pldpdoc->Out(str, CP_PRN);
    }

    PLDAPControl    *pvlvresponse = NULL;

    err = ldap_parse_result( hLdap,
                             msg,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &pvlvresponse,
                             FALSE
                            );

    if(err != LDAP_SUCCESS)
    {
        str.Format("Error <0x%X>: ldap_parse_result returned: %s", err, ldap_err2string(err));
        pldpdoc->Out(str);
    }
    else {
        int errcode = LDAP_SUCCESS;

        if (m_vlvContext) {
            ber_bvfree (m_vlvContext);
            m_vlvContext = NULL;
        }

        err = ldap_parse_vlv_control( hLdap,
                                      pvlvresponse,
                                      &m_currentPos,
                                      &m_contentCount,
                                      &m_vlvContext,
                                      &errcode
                                     );

        if (errcode) {
            str.Format("VLV specific Error <0x%X>: %s", errcode, ldap_err2string(errcode));
            pldpdoc->Out(str);
        }

        ldap_controls_free(pvlvresponse);
    }

    // Parse results 
    //
    ParseSearchResults(msg);

    ldap_msgfree(msg);

    // update display count
    if (old_contentCount != m_contentCount) {
        m_listctrl.SetItemCount (m_contentCount);
        m_EstSize = m_contentCount;
        UpdateData(FALSE);
    }
    
    if (!m_DoFindStr) {
        m_listctrl.EnsureVisible (m_currentPos-1, TRUE);
        m_listctrl.SetItemState (m_currentPos-1, LVIS_FOCUSED, LVIS_FOCUSED);
    }

}


void CVLVDialog::ParseSearchResults(LDAPMessage *msg)
{
    LDAP *hLdap = pldpdoc->hLdap;
	CString str, strDN;
	char *dn;
	void *ptr;
	char *attr;
	LDAPMessage *nxt;
    ULONG nEntries, colNum;

    CVLVListItem *pVLVItem;
	LDAP_BERVAL **bval;
    int i;

    ULONG start;
    if (m_currentPos <= m_beforeCount) {
        start = 1;
    }
    else {
        start = m_currentPos - m_beforeCount;
    }

    nEntries = ldap_count_entries(hLdap, msg);

    //str.Format("Reading Data: %d - %d", start, start + nEntries );
    //pldpdoc->Out(str);

    m_pCache->SetCacheWindow (start, start + nEntries);

    // traverse entries
    //
	for(nxt = ldap_first_entry(hLdap, msg), nEntries = 0;
			nxt != NULL;
			nxt = ldap_next_entry(hLdap, nxt), nEntries++) {

        // get dn text & process
        //
        dn = ldap_get_dn(hLdap, nxt);
		strDN = pldpdoc->DNProcess(dn);

        pVLVItem = m_pCache->GetCacheRow(start + nEntries);
				
        if (!pVLVItem) {
            break;
        }
        
        pVLVItem->SetCol (0, LPCTSTR(strDN));

        // traverse attributes
        //
        for(attr = ldap_first_attribute(hLdap, nxt, (BERPTRTYPE)&ptr);
            attr != NULL;
            attr = ldap_next_attribute(hLdap, nxt, (struct berelement*)ptr)) {

            bval = ldap_get_values_len(hLdap, nxt, attr);

            str = "";

            for(i=0; bval != NULL && bval[i] != NULL; i++){
                pldpdoc->FormatValue(attr, bval[i], str);
                if (bval[i+1]) {
                    str = str + ";";
                }
            }

            colNum = MapAttributeToColumn (attr);

            if (colNum) {
                pVLVItem->SetCol (colNum, LPCTSTR(str));
            }

            // free up mem
            //
            if(bval != NULL){
                ldap_value_free_len(bval);
            }
        }
    }
}

void CVLVDialog::OnSize(UINT nType, int cx, int cy) 
{
      CDialog::OnSize(nType, cx, cy);

      RECT rect;
      int before = m_listctrl.GetCountPerPage();
      m_listctrl.GetWindowRect (&rect);
      ScreenToClient (&rect);
      m_listctrl.SetWindowPos (NULL, 0, 0, cx-rect.left*2, cy-rect.top-20, SWP_NOMOVE | SWP_NOZORDER);

      if (m_RunState) {
        m_beforeCount = m_afterCount = m_listctrl.GetCountPerPage() + 1;

        if (m_afterCount > before) {
            int iFrom = m_listctrl.GetTopIndex() + 1;

            if (!m_pCache->IsWindowVisible (iFrom, iFrom + m_afterCount)) {
                DoVlvSearch();
            }
        }
      }
}

void CVLVDialog::OnUpdateFindstr() 
{
    CString Str;

    Str = m_FindStr;
    UpdateData(TRUE);

    if (Str != m_FindStr) {
        m_DoFindStr = TRUE;
        DoVlvSearch();

        int pos = m_currentPos - m_afterCount / 2;
        if (pos < 0) {
            pos = 0;
        }

        m_listctrl.EnsureVisible (pos, TRUE);
        m_listctrl.EnsureVisible (pos + m_afterCount, TRUE);
        

        // LVIS_SELECTED ?
        m_listctrl.SetItemState (m_currentPos - 1, LVIS_FOCUSED, LVIS_FOCUSED);
        m_listctrl.EnsureVisible (m_currentPos - 1, TRUE);
        m_DoFindStr = FALSE;

        int iFrom, iTo;
        iFrom = m_listctrl.GetTopIndex();
        iTo = iFrom + m_listctrl.GetCountPerPage();

        m_listctrl.RedrawItems (iFrom , iTo);
    }
}

void CVLVDialog::OnKillfocusFindstr() 
{
	m_DoFindStr = FALSE;
}

void CVLVDialog::OnBtnUp() 
{
    PCHAR *val = ldap_explode_dn ((char *)LPCTSTR (m_BaseDN), FALSE);

    if (val) {
        CString dn;

        if (val[1]) {
            dn = val[1];

            if (val[2]) {
                for (int i=2; val[i]; i++) {
                    dn += ",";
                    dn += val[i];
                }
            }
        }

        m_BaseDN = dn;

        UpdateData (FALSE);

        OnRun();
    }
    ldap_value_free (val);
}

LRESULT CALLBACK CVLVDialog::_ListCtrlWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lResult = 0;
    BOOL            fCallWinProc = TRUE;
    CVLVDialog      *pThis =
        reinterpret_cast<CVLVDialog *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (msg)
    {
    case WM_VSCROLL:

        if (LOWORD (wParam) == SB_THUMBTRACK) {
            fCallWinProc = FALSE; // don't want original wndproc to see this msg

            // Initialize SCROLLINFO structure
            ZeroMemory(&pThis->m_Si, sizeof(SCROLLINFO));
            pThis->m_Si.cbSize = sizeof(SCROLLINFO);
            pThis->m_Si.fMask = SIF_TRACKPOS;
 
            // Call GetScrollInfo to get current tracking 
            //    position in si.nTrackPos
 
            if (!::GetScrollInfo(hwnd, SB_VERT, &pThis->m_Si) )
                return 1; // GetScrollInfo failed
        }
        else if (LOWORD (wParam) == SB_THUMBPOSITION ) {
        
            RECT rect;
            int  cnt = pThis->m_listctrl.GetCountPerPage();
            if (cnt==0) {
                cnt = 1;
            }
            pThis->m_listctrl.GetWindowRect (&rect);

            int topIndex = pThis->m_listctrl.GetTopIndex();

            CSize size;
            size.cy = (pThis->m_Si.nTrackPos - topIndex) * (rect.bottom - rect.top) / cnt;
            size.cx = 0;
            pThis->m_listctrl.Scroll (size);
        }
        break;
    }

    if (fCallWinProc)
    {
        lResult = CallWindowProc(pThis->m_OriginalRichEditWndProc,
                                 hwnd,
                                 msg,
                                 wParam,
                                 lParam);
    }
    return lResult;
}

//====================================================================

CVLVListItem :: CVLVListItem (ULONG numCols)
{ 
    //_RPT0(_CRT_WARN, "Creating CVLVListItem\n");

    m_numCols = numCols;

    m_ppData = new char *[m_numCols];
    if (!m_ppData) {
        m_numCols = 0;
        return;
    }

    for (int i=0; i<m_numCols; i++) {
        m_ppData[i] = NULL;
    }
}

CVLVListItem :: ~CVLVListItem ()
{
    //_RPT0(_CRT_WARN, "Destroying CVLVListItem\n");
    if (m_ppData) {
        for (int i=0; i<m_numCols; i++) {
			if (m_ppData [i]) {
                //_RPT1(_CRT_WARN, "Destroying Col%d\n", i);
                delete [] m_ppData[i];
            }
        }
        delete [] m_ppData;

        m_ppData = NULL;
    }
    m_numCols = 0;
}

void CVLVListItem :: SetCol (int col, const char *sz)
{
    if (col >= m_numCols || col < 0) {
        return;
    }

    if (m_ppData[col]) {
        delete [] m_ppData[col];
    }

    int len = strlen (sz) + 1;

    m_ppData[col] = new char [len + 1];

    if (m_ppData[col]) {
        strcpy (m_ppData[col], sz);
    }
}


CVLVListCache::CVLVListCache(ULONG cacheSize, ULONG numcols) 
{
    //_RPT0(_CRT_WARN, "Creating CVLVListCache\n");
    m_numCols = numcols;

    m_From = 0;
    m_To = 0;

    m_cCache = cacheSize;
    m_pCachedItems = new CVLVListItem *[m_cCache];
    if (!m_pCachedItems) {
        m_cCache = 0;
        return;
    }
    int i = 0;
    try {
        for (i=0; i<m_cCache; i++) {
            m_pCachedItems[i] = new CVLVListItem(m_numCols);
        }
    }
    catch (...) {
        int j;
        for (j=0; j<=i; j++) {
            if (m_pCachedItems[j]) {
                delete m_pCachedItems[j];
                m_pCachedItems[j] = NULL;
            }
        }                    
        delete [] m_pCachedItems;
        m_pCachedItems = NULL;
        // throw the same exception again
        throw;
    }

}

CVLVListCache::~CVLVListCache()
{
    //_RPT0(_CRT_WARN, "Destroying CVLVListCache\n");
    if (m_pCachedItems) {
        Destroy();
        delete [] m_pCachedItems;
    }
}

void CVLVListCache::Destroy()
{
    for (int i=0; i<m_cCache; i++) {
        if (m_pCachedItems[i]) {
            delete m_pCachedItems[i];
            m_pCachedItems[i] = NULL;
        }
    }
}
void CVLVListCache::FlushCache(void)
{
    m_From = m_To = 0;
}

CVLVListItem *CVLVListCache::GetCacheRow (ULONG row)
{

    if (row < m_From || row > m_To) {
        return NULL;
    }
    
    ULONG Row = row - m_From;
    if (Row < m_cCache) {

        if (!m_pCachedItems[Row]) {
            m_pCachedItems[Row] = new CVLVListItem(m_numCols);
        }
        return m_pCachedItems[Row];
    }
    else {
        return NULL;
    }
}


BOOL CVLVListCache::IsWindowVisible (ULONG from, ULONG to)
{
    // check if this window is a subWindow from what we already have
    if ((from >= m_From) && (to <= m_To)) {
        // no need to read anything
        return TRUE;
    }

    return FALSE;
}

ULONG CVLVListCache::SetCacheWindow (ULONG from, ULONG to)
{
    // check if this window is a subWindow from what we already have
    if ((from >= m_From) && (to <= m_To)) {
        // no need to read anything
        return 0;
    }

    // we need to resize the cache
    if ((to - from + 1) > m_cCache) {
        Destroy();
        delete [] m_pCachedItems;

        m_cCache = (to - from + 1) * 2;;
        m_pCachedItems = new CVLVListItem *[m_cCache];

        if (!m_pCachedItems) {
            m_cCache = 0;
            return FALSE;
        }

        for (int i=0; i<m_cCache; i++) {
            m_pCachedItems[i] = new CVLVListItem(m_numCols);
        }

        // reread everything
        m_To = to;
        m_From = from;

        return to - from + 1;
    }

    // check to see if have overlapping
    int size = to - from;

    if (  ( (from < m_From) && ( to < m_From ) ) ||
          ( (to > m_To)     && ( from > m_To ) ) || 
          ( (from < m_From) && (to > m_To)     ) ) {

        // no overlapping or full overlapping

        m_From = from;
        m_To = to;

        // force to reread everything
        Destroy();

        return to - from + 1;
    }

/*
    // we have overlapping and we need to append in the start of the list
    if ( (from < m_From) && (to > m_From) ) {
        int delta = m_From - from;
        int i, last;

        for (last = m_cCache-1,i=0; (i<delta) && last; i++, last--) {
            if (m_pCachedItems[last]) {
                delete m_pCachedItems[last];
            }

            ASSERT((last - delta) >=0);

            m_pCachedItems[last] = m_pCachedItems[last - delta];
            m_pCachedItems[last - delta] = NULL;
        }
        
        m_From = from;
        m_To = m_To - delta;

        return delta;
    }
    // we need to append in the end of the list
    else if ( (to > m_To) && (from < m_To) ) {
        int delta = to - m_To;
        int i;

        for ( i=0; i<delta; i++) {
            if (m_pCachedItems[i]) {
                delete m_pCachedItems[i];
            }

            ASSERT((i + delta) <= m_cCache);
            m_pCachedItems[i] = m_pCachedItems[i + delta];
            m_pCachedItems[i + delta] = NULL;
        }

        m_To = to;
        m_From =  m_From + delta;

        return delta;
    }
*/
    // reread everything
    m_From = from;
    m_To = to;
        
    Destroy();
    return to - from;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\treevw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       treevw.cpp
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// TreeVw.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
#include "TreeVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// TreeVwDlg dialog


TreeVwDlg::TreeVwDlg(CWnd* pParent /*=NULL*/)
	: CDialog(TreeVwDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(TreeVwDlg)
	m_BaseDn = _T("");
	//}}AFX_DATA_INIT

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	m_BaseDn = app->GetProfileString("TreeView",  "BaseDn", m_BaseDn);
}



TreeVwDlg::~TreeVwDlg(){

	CLdpApp *app = (CLdpApp*)AfxGetApp();

	app->WriteProfileString("TreeView",  "BaseDn", m_BaseDn);

}





void TreeVwDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(TreeVwDlg)
	DDX_Text(pDX, IDC_TREE_BASE_DN, m_BaseDn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(TreeVwDlg, CDialog)
	//{{AFX_MSG_MAP(TreeVwDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// TreeVwDlg message handlers

void TreeVwDlg::OnOK()
{
	CDialog::OnOK();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\svropt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       svropt.cpp
//
//--------------------------------------------------------------------------

// SvrOpt.cpp : implementation file
//

#include "stdafx.h"
#include "Ldp.h"
//#include "SvrOpt.h"
#include "ldpdoc.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SvrOpt dialog


SvrOpt::SvrOpt(CLdpDoc *doc_, CWnd* pParent /*=NULL*/)
	: CDialog(SvrOpt::IDD, pParent)
{
	//{{AFX_DATA_INIT(SvrOpt)
	m_OptVal = _T("");
	//}}AFX_DATA_INIT
	doc = doc_;

}

BOOL SvrOpt::OnInitDialog(){

	BOOL bRet = CDialog::OnInitDialog();
	
	if(bRet){
		InitList();
	}
	return bRet;
}





void SvrOpt::InitList(){

	m_SvrOpt.SetItemData(0, LDAP_OPT_DESC);
	m_SvrOpt.SetItemData(1, LDAP_OPT_DEREF);
	m_SvrOpt.SetItemData(2, LDAP_OPT_SIZELIMIT);
	m_SvrOpt.SetItemData(3, LDAP_OPT_TIMELIMIT);
	m_SvrOpt.SetItemData(4, LDAP_OPT_THREAD_FN_PTRS);
	m_SvrOpt.SetItemData(5, LDAP_OPT_REBIND_FN);
	m_SvrOpt.SetItemData(6, LDAP_OPT_REBIND_ARG);
	m_SvrOpt.SetItemData(7, LDAP_OPT_REFERRALS);
	m_SvrOpt.SetItemData(8, LDAP_OPT_RESTART);
	m_SvrOpt.SetItemData(9, LDAP_OPT_SSL);
	m_SvrOpt.SetItemData(10, LDAP_OPT_IO_FN_PTRS);
	m_SvrOpt.SetItemData(11, LDAP_OPT_CACHE_FN_PTRS);
	m_SvrOpt.SetItemData(12, LDAP_OPT_CACHE_STRATEGY);
	m_SvrOpt.SetItemData(13, LDAP_OPT_CACHE_ENABLE);
	m_SvrOpt.SetItemData(14, LDAP_OPT_REFERRAL_HOP_LIMIT);
	m_SvrOpt.SetItemData(15, LDAP_OPT_VERSION);
	m_SvrOpt.SetItemData(16, LDAP_OPT_ERROR_STRING);

	m_SvrOpt.SetItemData(17, LDAP_OPT_HOST_NAME);
	m_SvrOpt.SetItemData(18, LDAP_OPT_ERROR_NUMBER);
	m_SvrOpt.SetItemData(19, LDAP_OPT_HOST_REACHABLE);
	m_SvrOpt.SetItemData(20, LDAP_OPT_PING_KEEP_ALIVE);
	m_SvrOpt.SetItemData(21, LDAP_OPT_PING_WAIT_TIME);
	m_SvrOpt.SetItemData(22, LDAP_OPT_PING_LIMIT);
	m_SvrOpt.SetItemData(23, LDAP_OPT_DNSDOMAIN_NAME);
	m_SvrOpt.SetItemData(24, LDAP_OPT_GETDSNAME_FLAGS);
	m_SvrOpt.SetItemData(25, LDAP_OPT_PROMPT_CREDENTIALS);
	m_SvrOpt.SetItemData(26, LDAP_OPT_AUTO_RECONNECT);
	m_SvrOpt.SetItemData(27, LDAP_OPT_SSPI_FLAGS);
	m_SvrOpt.SetItemData(28, LDAP_OPT_SSL_INFO);

	m_SvrOpt.SetItemData(29, LDAP_OPT_SERVER_ERROR);

	m_SvrOpt.SetItemData(30, LDAP_OPT_SIGN);
	m_SvrOpt.SetItemData(31, LDAP_OPT_ENCRYPT);
}



void SvrOpt::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SvrOpt)
	DDX_Control(pDX, IDC_SVROPT, m_SvrOpt);
	DDX_Text(pDX, IDC_OPTVAL, m_OptVal);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SvrOpt, CDialog)
	//{{AFX_MSG_MAP(SvrOpt)
	ON_BN_CLICKED(IDC_RUN, OnRun)
	ON_CBN_SELCHANGE(IDC_SVROPT, OnSelchangeSvropt)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// SvrOpt message handlers



void SvrOpt::OnRun()
{
	SetOptions();		
}




void SvrOpt::SetOptions() {
    DWORD dwLdapOpt;
    LONG lVal = 0;
    CString str;
    LPVOID pVal;
    ULONG err;

    UpdateData(TRUE);
    INT i = m_SvrOpt.GetCurSel();

    if (i != CB_ERR) {

        dwLdapOpt = m_SvrOpt.GetItemData(i);

        switch (dwLdapOpt) {
            case LDAP_OPT_HOST_NAME:
            case LDAP_OPT_DNSDOMAIN_NAME:
            case LDAP_OPT_GETDSNAME_FLAGS:
            case LDAP_OPT_ERROR_STRING:
            case LDAP_OPT_SERVER_ERROR:
                pVal = (PVOID)LPCTSTR(m_OptVal);
                // see bug 424435 for history
                err = ldap_set_option(doc->hLdap, dwLdapOpt, &pVal);
                str.Format("0x%X = ldap_set_option(ld, 0x%X, %s)", err, dwLdapOpt, (LPCTSTR)m_OptVal);
                doc->Out(str);
                break;
            default:
                lVal = atol(m_OptVal);
                err = ldap_set_option(doc->hLdap, dwLdapOpt, (PVOID)&lVal);
                str.Format("0x%X = ldap_set_option(ld, 0x%X, %ld)", err, dwLdapOpt, lVal);
                doc->Out(str);
        }
    }

}



void SvrOpt::OnSelchangeSvropt()
{

	DWORD dwLdapOpt;
	LONG lVal = 0;
	CString str;
	ULONG err;
    LPTSTR pStr = NULL;

	UpdateData(TRUE);
	INT i = m_SvrOpt.GetCurSel();

	if(i != CB_ERR){

		dwLdapOpt = m_SvrOpt.GetItemData(i);

		switch(dwLdapOpt){

		case LDAP_OPT_HOST_NAME:
		case LDAP_OPT_DNSDOMAIN_NAME:
		case LDAP_OPT_GETDSNAME_FLAGS:
		case LDAP_OPT_ERROR_STRING:
      case LDAP_OPT_SERVER_ERROR:
			err = ldap_get_option(doc->hLdap, dwLdapOpt, (LPVOID)&pStr);
			str.Format("%lu = ldap_get_option(ld, 0x%X, %s)", err, dwLdapOpt, pStr?pStr:"<empty>");
			doc->Out(str);
			m_OptVal = pStr?pStr:"<empty>";
			break;
		default:
			err = ldap_get_option(doc->hLdap, dwLdapOpt, (PVOID)&lVal);
			str.Format("<0x%X> = ldap_get_option(ld, 0x%X, %ld)", err, dwLdapOpt, lVal);
			doc->Out(str);
			m_OptVal.Format("%ld", lVal);
		}
		UpdateData(FALSE);
	}
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\svropt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       svropt.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_SVROPT_H__42B3E607_E0DD_11D0_A9A6_0000F803AA83__INCLUDED_)
#define AFX_SVROPT_H__42B3E607_E0DD_11D0_A9A6_0000F803AA83__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SvrOpt.h : header file
//

class CLdpDoc;
/////////////////////////////////////////////////////////////////////////////
// SvrOpt dialog

class SvrOpt : public CDialog
{
private:
	CLdpDoc *doc;

	void SetOptions();
	void InitList();
// Construction
public:
	SvrOpt(CLdpDoc *doc_, CWnd* pParent = NULL);   // standard constructor


	virtual  BOOL OnInitDialog( );

  

// Dialog Data
	//{{AFX_DATA(SvrOpt)
	enum { IDD = IDD_CONNECTIONOPT };
	CComboBox	m_SvrOpt;
	CString	m_OptVal;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(SvrOpt)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(SvrOpt)
	afx_msg void OnRun();
	afx_msg void OnSelchangeSvropt();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVROPT_H__42B3E607_E0DD_11D0_A9A6_0000F803AA83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldp\treevw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       treevw.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 10/21/1996
*    Description : implementation of class CldpDoc
*
*    Revisions   : <date> <name> <description>
*******************************************************************/

// TreeVwh : header file
//

/////////////////////////////////////////////////////////////////////////////
// TreeVwDlg dialog

class TreeVwDlg : public CDialog
{
// Construction
public:
	TreeVwDlg(CWnd* pParent = NULL);   // standard constructor
	~TreeVwDlg();

// Dialog Data
	//{{AFX_DATA(TreeVwDlg)
	enum { IDD = IDD_TREE_VIEW };
	CString	m_BaseDn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(TreeVwDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(TreeVwDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\movetree\dll\movetree.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    MOVETREE.C

Abstract:

    This file is used to implement a high level backtracking depth first
    search algorithm to move a tree from one domain to another 

Author:

    12-Oct-98 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    12-Oct-98 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma  hdrstop


#include "movetree.h"





//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Global Variables                                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Top Level Algorithm                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


ULONG
MtCreateNecessaryDn(
    PMT_CONTEXT MtContext,
    LDAP    *SrcLdapHandle 
    )
/*++
Routine Description:

    This is will create Move Container's DS Name and Orphans Container's
    DS Name and store them in MtContext

Parameters:

    MtContext - pointer to MT_CONTEXT  

    SrcLdapHandle - Ldap Handle

Return Values:

    Windows Error Code
    
--*/
{
    ULONG   WinError = NO_ERROR;
    PWCHAR  LostAndFound = NULL;
    
    
    MT_TRACE(("\nMtCreateNecessaryDn \n"));
    
    
    // 
    // Get the LostAndFound Container DN
    // 
    
    WinError = MtGetLostAndFoundDn(MtContext, 
                                   SrcLdapHandle,
                                   &LostAndFound
                                   );
            
    if ((NO_ERROR != WinError) || (NULL == LostAndFound))
    {
        MtWriteError(MtContext, 
                     MT_ERROR_GET_LOSTANDFOUND_DN, 
                     WinError, 
                     NULL, 
                     NULL
                     );
                     
        return WinError;
    }
    
    
    // 
    // Create MoveContainer DN = RootObjectGuid + LostAndFound
    // 
            
    MtContext->MoveContainer = MtAlloc(sizeof(WCHAR) * 
                                       (wcslen(LostAndFound) + 
                                        wcslen(MtContext->RootObjGuid) + 
                                        5)
                                       );
    
    if (NULL == MtContext->MoveContainer)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    swprintf(MtContext->MoveContainer, 
             L"cn=%s,%s", 
             MtContext->RootObjGuid, 
             LostAndFound
             );
              
              
    //
    // Create the Orphans Container DN under MoveContainer
    // 
    
    MtContext->OrphansContainer = MtAlloc(sizeof(WCHAR) *
                                          (wcslen(MtContext->MoveContainer) +
                                           wcslen(MT_ORPHAN_CONTAINER_RDN) +
                                           2)
                                         );

    if (NULL == MtContext->OrphansContainer)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    swprintf(MtContext->OrphansContainer, 
             L"%s,%s", 
             MT_ORPHAN_CONTAINER_RDN, 
             MtContext->MoveContainer
             );
              
Error:

    MtFree(LostAndFound);
    
    return WinError;    
}


ULONG
MtPrepare(
    PMT_CONTEXT MtContext,
    LDAP   *SrcLdapHandle, 
    PWCHAR SrcDsa, 
    PWCHAR DstDsa, 
    PWCHAR SrcDn,
    PWCHAR DstDn
    )
{
    ULONG   WinError = NO_ERROR;
    PWCHAR  Guid = NULL;
    
    
    MT_TRACE(("\nMtPrepare SrcDsa:%ls DstDsa:%ls SrcDn:%ls DstParent:%ls DstRdn:%ls\n", 
             SrcDsa, DstDsa, SrcDn, DstDn));
    
    //
    // get the root object's GUID, which is used to construct the 
    // move container's DN. MoveContainerDN = Root's GUID + LostAndFound
    // 
    
    WinError = MtGetGuidFromDn(MtContext, 
                               SrcLdapHandle,
                               SrcDn, 
                               &Guid
                               );
    
    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_GET_GUID_FROM_DN, 
                     WinError, 
                     SrcDn, 
                     NULL
                     );
        
        dbprint(("MtPrepare Cann't Get Root Object's GUID 0x%x\n", WinError));
        goto Error;
    }
    
    MtContext->RootObjGuid = Guid;
    
    dbprint(("Root's GUID is %ls\n", MtContext->RootObjGuid));
    
    WinError = MtCreateNecessaryDn(MtContext, 
                                   SrcLdapHandle 
                                   );
    
    if (NO_ERROR != WinError)
    {
        goto Error;
    }
    
    //
    // Create the Move Container
    // store the Move Tree Version Number, Move Container Tag
    // and Source Domain DSA name and Destination Domain DSA
    // name in one Binary Blob as moveTreeState in MoveContainer
    // 
    
    WinError = MtCreateMoveContainer(MtContext, 
                                     SrcLdapHandle, 
                                     SrcDsa, 
                                     DstDsa
                                     );
                                     
    if (ERROR_ALREADY_EXISTS == WinError ||
        ERROR_DS_OBJ_STRING_NAME_EXISTS == WinError)
    {
        WinError = MtCheckMoveContainer(MtContext, 
                                        SrcLdapHandle, 
                                        SrcDsa, 
                                        DstDsa
                                        );

        if (NO_ERROR != WinError)
        {
            MtWriteError(MtContext, 
                         MT_ERROR_CHECK_MOVECONTAINER, 
                         WinError, 
                         MtContext->MoveContainer, 
                         NULL
                         );
            goto Error;
        }
    }
    
    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CREATE_MOVECONTAINER, 
                     WinError, 
                     MtContext->MoveContainer, 
                     NULL
                     );
                     
        goto Error;
    }
    
    //
    // Create the Orphans Container
    // 
    
    WinError = MtAddEntry(MtContext, 
                          SrcLdapHandle,
                          MtContext->OrphansContainer
                          );
    
    if (ERROR_ALREADY_EXISTS == WinError ||
        ERROR_DS_OBJ_STRING_NAME_EXISTS == WinError)
    {
        WinError = NO_ERROR;
    }
    
    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CREATE_ORPHANSCONTAINER, 
                     WinError, 
                     MtContext->OrphansContainer,
                     NULL
                     ) 
    }
    
    
Error:

    return WinError; 
}



ULONG
MoveTreePhase2(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle, 
    LDAP    *DstLdapHandle, 
    PWCHAR  DstDsa,
    BOOLEAN Continue
    )
{
    ULONG   WinError = NO_ERROR;
    ULONG   IgnoreError = NO_ERROR;
    MT_STACK ProxyStack;
    PWCHAR  ProxyContainer = NULL;
    PWCHAR  NewParent = NULL;
    PWCHAR  CurrentObjDn = NULL;
    PWCHAR  CurrentObjGuid = NULL; 
    PWCHAR  CurrentObjProxy = NULL;
    BOOLEAN fSearchNext = TRUE;
    BOOLEAN fPush = FALSE; 
    BOOLEAN fFinished = TRUE;
    BOOLEAN fExist = TRUE;
    LDAPMessage * Results = NULL;
    LDAPMessage * Entry = NULL;
    LDAPMessage * NextEntry = NULL;
    
    
    MT_TRACE(("\nMoveTreePhase2 \nDstDsa:\t%ls \n", DstDsa));
             
    //
    // initialize stack
    // 
    
    MtInitStack(&ProxyStack);
    
    NewParent = MtDupString(MtContext->RootObjNewDn);
    
    ProxyContainer = MtDupString(MtContext->RootObjProxyContainer);

    if (NULL == NewParent || NULL == ProxyContainer)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    WinError = MtObjectExist(MtContext, SrcLdapHandle, ProxyContainer, &fExist);

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_OBJECT_EXIST, 
                     WinError, 
                     ProxyContainer, 
                     NULL
                     );

        goto Error;
    }
    else if (!fExist)
    {
        //
        // Proxy Container doesn't exist. It means we all objects has been moved.
        // 
        goto Error;
    }
    
    
    WinError = MtPush(&ProxyStack, 
                      NewParent, 
                      ProxyContainer, 
                      NULL,         // Results
                      NULL          // Entry 
                      );
                      
    if (NO_ERROR != WinError)
    {
        goto Error;
    }
    
    //
    // Execute
    // 
    
    while (!MtStackIsEmpty(ProxyStack))
    {
        MtPop(&ProxyStack, &NewParent, &ProxyContainer, &Results, &Entry);
        
        if (NULL == NewParent)
        {
            // 
            // if NewParent is NULL, try to find it in either destination
            // domain or source (local) domain
            // 
            WinError = MtGetNewParentDnFromProxyContainer(
                                                MtContext, 
                                                SrcLdapHandle, 
                                                DstLdapHandle,
                                                ProxyContainer, 
                                                &NewParent
                                                );
            
            //
            // if the original parent has been deleted or gone.
            // put its children to Orphanes Container
            //                                                 
            if (ERROR_FILE_NOT_FOUND == WinError)
            {
                NewParent = MtDupString(MtContext->OrphansContainer);
                
                if (NULL == NewParent)
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                    goto Error;
                }
                else
                    WinError = NO_ERROR;
            }
            
            if (NO_ERROR != WinError)
            {
                MtWriteError(MtContext, 
                             MT_ERROR_GET_NEW_PARENT_DN, 
                             WinError, 
                             ProxyContainer, 
                             NULL
                             );
                goto Error;
            }
        } 
        
        // 
        // we have the ProxyContainer DN and NewParent DN, 
        // I'm going to Move / X-Move the children under the 
        // ProxyContainer to NewParent 
        // 
        do
        {
            fSearchNext = TRUE;
            fPush = FALSE;
            
            if (NULL == Results) 
            {
                WinError = MtSearchChildren(MtContext, 
                                            SrcLdapHandle,
                                            ProxyContainer, 
                                            &Results
                                            );
                
                if (NO_ERROR != WinError && ERROR_MORE_DATA != WinError)
                {
                    MtWriteError(MtContext, 
                                 MT_ERROR_SEARCH_CHILDREN, 
                                 WinError, 
                                 ProxyContainer, 
                                 NULL
                                 );
                               
                    goto Error;
                }
                
                if (NULL != Results)
                {
                    Entry = MtGetFirstEntry(MtContext, 
                                            SrcLdapHandle, 
                                            Results
                                            );
                }
                else
                {
                    Entry = NULL;
                }
            }
            else
            {
                NextEntry = MtGetNextEntry(MtContext, 
                                           SrcLdapHandle, 
                                           Entry
                                           );
                
                if (NULL == NextEntry)
                {
                    ldap_msgfree(Results);
                    
                    Results = NULL;
                    
                    WinError = MtSearchChildren(MtContext, 
                                                SrcLdapHandle, 
                                                ProxyContainer, 
                                                &Results
                                                );
                    
                    if (NO_ERROR != WinError && ERROR_MORE_DATA != WinError)
                    {
                        MtWriteError(MtContext, 
                                     MT_ERROR_SEARCH_CHILDREN, 
                                     WinError, 
                                     ProxyContainer, 
                                     NULL
                                     );
                        goto Error;
                    }
                    
                    if (NULL != Results)
                    {
                        NextEntry = MtGetFirstEntry(MtContext, 
                                                    SrcLdapHandle, 
                                                    Results
                                                    );
                    }
                }
                
                Entry = NextEntry;
            }
            
            
            // 
            // Now the Entry should either point to an child under the 
            // ProxyContainer, or Entry is NULL which means that there is
            // no more child under the ProxyContainer
            // 
            
            if (NULL != Entry)
            {
            
                CurrentObjDn = MtGetDnFromEntry(MtContext, 
                                                SrcLdapHandle, 
                                                Entry
                                                ); 
                                                
                if (NULL == CurrentObjDn)
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                    goto Error;
                }
                
                dbprint(("the CurrentObjDn is %ls\n", CurrentObjDn));
                
                
                // 
                // i should use another api to retrieve GUID, since 
                // when we search all children, we read the objectGUID
                // at the same time. MtGetGuidFromEntry would be a 
                // good choice. For now, still use the following one.
                // 
                WinError = MtGetGuidFromDn(MtContext, 
                                           SrcLdapHandle,
                                           CurrentObjDn, 
                                           &CurrentObjGuid);
                
                if (NO_ERROR != WinError)
                {
                    MtWriteError(MtContext, 
                                 MT_ERROR_GET_GUID_FROM_DN, 
                                 WinError, 
                                 CurrentObjDn, 
                                 NULL
                                 ); 
                    goto Error;
                }
                
                //
                // If the client wants to continue a previous X-move tree, 
                // then check the class of the child, otherwise skip it.
                // 
                if (Continue)
                {
                    BOOLEAN fIsProxyContainer = FALSE;
                    
                    WinError = MtIsProxyContainer(MtContext, 
                                                  SrcLdapHandle, 
                                                  Entry, 
                                                  &fIsProxyContainer
                                                  );
                                                  
                    if (NO_ERROR != WinError)
                    {
                        MtWriteError(MtContext, 
                                     MT_ERROR_IS_PROXY_CONTAINER, 
                                     WinError, 
                                     NULL, 
                                     NULL
                                     );               
                        goto Error;
                    }
                
                    // 
                    // If this child is a ProxyContainer.
                    // 
                    if (fIsProxyContainer)
                    {
                        fSearchNext = FALSE;
                        
                        //
                        // save current state info
                        // 
                        WinError = MtPush(&ProxyStack, 
                                          NewParent, 
                                          ProxyContainer, 
                                          Results, 
                                          Entry );
                                       
                        if (NO_ERROR != WinError)
                            goto Error;     // only would be ERROR_NOT_ENOUGH_MEMORY
                            
                        NewParent = NULL;
                        ProxyContainer = NULL;
                        
                        WinError = MtPush(&ProxyStack, 
                                          NULL,         // do not know original parent DN yet. 
                                          CurrentObjDn, // next ProxyContainer to work on.
                                          NULL, 
                                          NULL );
                                      
                        if (NO_ERROR != WinError)
                            goto Error;
                        
                        MtFree(CurrentObjGuid);
                        CurrentObjGuid = NULL;
                        CurrentObjDn = NULL;
                        
                        continue;
                    }
                }
                
                // 
                // This child is a normal object which should be moved
                // under the NewParent.  The NewParent could be either 
                // in destination domain, or in the local domain. 
                // In the later case it means that the NewParent is under
                // Orphans Container or just gone. 
                // 
                do
                {
                    ULONG   TempErr = NO_ERROR;
                    BOOLEAN fExist = TRUE;
                    
                    WinError = MtXMoveObjectWithOrgRdn(MtContext, 
                                                       SrcLdapHandle,
                                                       DstDsa, 
                                                       CurrentObjDn, 
                                                       NewParent, 
                                                       MT_DELETE_OLD_RDN
                                                       );    
                    
                    switch (WinError)
                    {
                    case NO_ERROR:
                        fFinished = TRUE;
                        break;
                        
                    case ERROR_DS_CHILDREN_EXIST:
                    
                        // Having children, create corresponding
                        // ProxyContainer, and move all children
                        // under the new ProxyContainer, then
                        // try again.
                        
                        fFinished = FALSE; 
                        fPush = TRUE;
                    
                        TempErr = MtCreateProxyContainer(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjDn, 
                                                    CurrentObjGuid,
                                                    &CurrentObjProxy);
                                                          
                        if (NO_ERROR != TempErr && 
                            ERROR_ALREADY_EXISTS != TempErr)
                        {
                            WinError = TempErr;

                            MtWriteError(MtContext, 
                                         MT_ERROR_CREATE_PROXY_CONTAINER, 
                                         TempErr, 
                                         CurrentObjDn, 
                                         NULL
                                         );
                            goto Error;
                        }
                            
                        TempErr = MtMoveChildrenToAnotherContainer(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjDn, 
                                                    CurrentObjProxy
                                                    ); 
                        
                        if (NO_ERROR != TempErr)
                        {
                            WinError = TempErr;

                            MtWriteError(MtContext, 
                                         MT_ERROR_MOVE_CHILDREN_TO_ANOTHER_CONTAINER, 
                                         TempErr, 
                                         CurrentObjDn, 
                                         CurrentObjProxy
                                         );
                            goto Error; 
                        }
                            
                        break;    
                        
                    case ERROR_DS_SRC_AND_DST_NC_IDENTICAL:
                    
                        // in the same domain, try local version of 
                        // rename 
                    
                        fFinished = TRUE;
                        
                        WinError = MtMoveObjectWithOrgRdn(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjDn, 
                                                    NewParent, 
                                                    TRUE ); 
                        
                        if (ERROR_ALREADY_EXISTS == WinError)
                        {
                            // if failed because of RDN conflict, 
                            // try to use GUID as the RDN 
                            WinError = MtMoveObject(MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjDn, 
                                                    CurrentObjGuid, 
                                                    NewParent,
                                                    TRUE );
                        }
                        
                        if (NO_ERROR != WinError)
                        {
                            MtWriteError(MtContext, 
                                         MT_ERROR_LOCAL_MOVE, 
                                         WinError, 
                                         CurrentObjDn, 
                                         NewParent
                                         );
                            goto Error; 
                        }
                    
                        break;
                        
                    case ERROR_DS_NO_PARENT_OBJECT:
                    
                        fFinished = FALSE;
                        MtFree(NewParent);
                        NewParent = NULL;
                        
                        TempErr = MtGetNewParentDnFromProxyContainer(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    DstLdapHandle, 
                                                    ProxyContainer, 
                                                    &NewParent
                                                    );
                                                    
                        if (NO_ERROR == TempErr && NULL != NewParent)
                        {
                            // found the renamed Parent
                            // try again.
                            break;
                        }
                        else
                        {
                            // If cann't find the parent.
                            // move the current child to Orphans Container, 
                            // otherwise, fail out.
                            
                            if (ERROR_FILE_NOT_FOUND != TempErr)
                            {
                                WinError = TempErr; 
                                
                                MtWriteError(MtContext, 
                                             MT_ERROR_GET_NEW_PARENT_DN, 
                                             TempErr, 
                                             ProxyContainer, 
                                             NULL
                                             );
                                             
                                goto Error;
                            }
                        }
                    
                    case ERROR_DS_DRA_NAME_COLLISION:
                    case ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION:
                    case ERROR_USER_EXISTS:
                    
                        // Destination Constrains, then we should
                        // move the current child (including all its 
                        // children, if any) to Orphans Container. 
                    
                        fFinished = TRUE;
                    
                        if (NULL == CurrentObjProxy)
                        {
                            TempErr = MtCreateProxyContainerDn(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjDn, 
                                                    CurrentObjGuid,         
                                                    &CurrentObjProxy
                                                    ); 
                        
                            if (NO_ERROR != TempErr || NULL == CurrentObjProxy)
                            {
                                WinError = TempErr;
                                
                                MtWriteError(MtContext, 
                                             MT_ERROR_CREATE_PROXY_CONTAINER_DN, 
                                             TempErr, 
                                             CurrentObjDn, 
                                             NULL
                                             );
                                             
                                goto Error;
                            }
                        }
                        
                        TempErr = MtObjectExist(MtContext, 
                                                SrcLdapHandle, 
                                                CurrentObjProxy, 
                                                &fExist
                                                );  
                        
                        if (NO_ERROR != TempErr)
                        {
                            WinError = TempErr;
                            MtWriteError(MtContext, 
                                         MT_ERROR_OBJECT_EXIST, 
                                         TempErr, 
                                         CurrentObjProxy, 
                                         NULL
                                         );
                                         
                            goto Error;
                        }
                            
                        if (fExist)
                        {
                            // if the current child has a ProxyContainer, 
                            // then move all its children back from the 
                            // ProxContainer
                            TempErr = MtMoveChildrenToAnotherContainer(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjProxy, 
                                                    CurrentObjDn);
                                                    
                            if (NO_ERROR != TempErr)
                            {
                                WinError = TempErr;
                                
                                MtWriteError(MtContext, 
                                             MT_ERROR_MOVE_CHILDREN_TO_ANOTHER_CONTAINER, 
                                             TempErr, 
                                             CurrentObjProxy, 
                                             CurrentObjDn
                                             );
                                             
                                goto Error;
                            }
                            TempErr = MtDeleteEntry(MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjProxy
                                                    );
                            
                            if (NO_ERROR != TempErr)
                            {
                                WinError = TempErr;
                                
                                MtWriteError(MtContext, 
                                             MT_ERROR_DELETE_ENTRY, 
                                             TempErr, 
                                             CurrentObjProxy, 
                                             NULL
                                             );
                                goto Error;
                            }
                        }
                        
                        MtFree(CurrentObjProxy);
                        CurrentObjProxy = NULL;
                        
                        TempErr = MtMoveObjectWithOrgRdn(
                                                    MtContext, 
                                                    SrcLdapHandle, 
                                                    CurrentObjDn, 
                                                    MtContext->OrphansContainer, 
                                                    TRUE );
                                                    
                        if (ERROR_ALREADY_EXISTS == TempErr)
                        {
                            TempErr = MtMoveObject(MtContext, 
                                                   SrcLdapHandle, 
                                                   CurrentObjDn, 
                                                   CurrentObjGuid, 
                                                   MtContext->OrphansContainer,
                                                   TRUE );
                        }
                        
                        if (NO_ERROR != TempErr)
                        {
                            WinError = TempErr;
                            
                            MtWriteError(MtContext, 
                                         MT_ERROR_LOCAL_MOVE, 
                                         TempErr, 
                                         CurrentObjDn, 
                                         MtContext->OrphansContainer
                                         );
                                
                            goto Error; 
                        }
                        else
                        {
                            MtWriteError(MtContext, 
                                         MT_WARNING_MOVE_TO_ORPHANSCONTAINER, 
                                         WinError, 
                                         CurrentObjDn, 
                                         MtContext->OrphansContainer
                                         ); 

                            MtContext->ErrorType &= !MT_ERROR_FATAL;
                            MtContext->ErrorType |= MT_ERROR_ORPHAN_LEFT;
                        }
                    
                        break;
                        
                    default:  // other Error, we can't handle it
                        MtWriteError(MtContext, 
                                     MT_ERROR_CROSS_DOMAIN_MOVE, 
                                     WinError, 
                                     CurrentObjDn, 
                                     NewParent
                                     );
                        goto Error;
                        
                    }
                    
                } while ( !fFinished );
                
                if (fPush && NULL != CurrentObjProxy)
                {
                    PWCHAR  Rdn = NULL;
                    PWCHAR  NewName = NULL;
                    
                    fSearchNext = FALSE;
                    
                    Rdn = MtGetRdnFromDn(CurrentObjDn, FALSE);
                    if (NULL == Rdn)
                    {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        goto Error;
                    }
                        
                    NewName = MtPrependRdn(Rdn, NewParent);
                    
                    MtFree(Rdn);
                    
                    if (NULL == NewName)
                    {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        goto Error;
                    }
                                        
                    WinError = MtPush(&ProxyStack, 
                                      NewParent, 
                                      ProxyContainer, 
                                      Results,
                                      Entry);
                                      
                    if (NO_ERROR != WinError)
                    {
                        MtFree(NewName);
                        goto Error;
                    }
                    
                    NewParent = NULL;
                    ProxyContainer = NULL;

                    WinError = MtPush(&ProxyStack, 
                                      NewName, 
                                      CurrentObjProxy, 
                                      NULL, 
                                      NULL );
                                      
                    if (NO_ERROR != WinError)
                    {
                        MtFree(NewName);
                        goto Error;
                    }
                    
                    CurrentObjProxy = NULL;
                }
                
            }
            else
            {
                // This ProxyContainer is Empty, need to delet the 
                // ProxyContainer
                ULONG   LdapError = LDAP_SUCCESS; 
                
                
                WinError = MtDeleteEntry(MtContext, 
                                         SrcLdapHandle, 
                                         ProxyContainer
                                         );
                
                LdapError = MtGetLastLdapError();
                
                if (NO_ERROR == WinError)
                {
                
                    fSearchNext = FALSE;
                    
                    ldap_msgfree(Results);
                    Results = NULL;
                    
                    MtFree(NewParent);
                    NewParent = NULL;
                    
                    MtFree(ProxyContainer);
                    ProxyContainer = NULL;
                    
                }
                else if (LDAP_NOT_ALLOWED_ON_NONLEAF != LdapError) 
                {
                    MtWriteError(MtContext, 
                                 MT_ERROR_DELETE_ENTRY, 
                                 WinError, 
                                 ProxyContainer, 
                                 NULL
                                 );
                    goto Error;    
                }
            }
            
            MtFree(CurrentObjDn);
            CurrentObjDn = NULL;
            
            MtFree(CurrentObjGuid);
            CurrentObjGuid = NULL;
            
            MtFree(CurrentObjProxy);
            CurrentObjGuid = NULL;
            
        } while (fSearchNext);  
    }
    
Error:    
    
    dbprint(("The object currently been manupleted is %ls\n", CurrentObjDn));

    ldap_msgfree(Results);
    
    MtFree(ProxyContainer);
    MtFree(NewParent);
    MtFree(CurrentObjDn);
    MtFree(CurrentObjGuid);
    MtFree(CurrentObjProxy);

    MtFreeStack(&ProxyStack);
    
    return WinError;
}




ULONG
MoveTreeCheck(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle, 
    LDAP    *DstLdapHandle, 
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa, 
    PWCHAR  SrcDn, 
    PWCHAR  DstDn
    )
{
    ULONG   WinError = NO_ERROR;
    ULONG   Status = LDAP_SUCCESS;
    LDAPMessage * Results = NULL;
    LDAPMessage * Entry = NULL;
    LDAPSearch  * Search = NULL;
    PWCHAR      AttrList[3];
    PWCHAR      * SamAccountName = NULL;
    

    MT_TRACE(("MoveTreeCheck\n"));


    //
    // Make Sure Destination Domain is in Native Mode
    // 
    WinError = MtCheckDstDomainMode(MtContext, 
                                    DstLdapHandle
                                    ); 

    if (NO_ERROR != WinError)
    {
        return WinError;
    }

    //
    // Check RDN conflict only for the root of the tree
    // 

    WinError = MtCheckRdnConflict(MtContext, 
                                  DstLdapHandle, 
                                  SrcDn, 
                                  DstDn
                                  );

    if (NO_ERROR != WinError)
    {
        return WinError;         
    }


    AttrList[0] = MT_SAMACCOUNTNAME;
    AttrList[1] = MT_GPLINK;
    AttrList[2] = NULL;

    Search = ldap_search_init_pageW(SrcLdapHandle, 
                                    SrcDn, 
                                    LDAP_SCOPE_SUBTREE, // whole tree
                                    L"(objectClass=*)", // filte all objects
                                    &AttrList[0],       // Attributes List 
                                    FALSE,              // attribute only ? 
                                    NULL,               // server control
                                    NULL,               // client control 
                                    0,                  // time out 
                                    MT_PAGED_SEARCH_LIMIT,    // maximum number of entries
                                    NULL                // sort key 
                                    );


    dbprint(("ldap_search_init_pageW ==> 0x%x Status ==> 0x%x\n", Search, LdapGetLastError() ));

    if (NULL == Search)
    {
        Status = LdapGetLastError();
        MtGetWinError(SrcLdapHandle, Status, WinError);
        return WinError;
    }

    
    while ((LDAP_SUCCESS == Status) && (NULL != Search))
    {
        ULONG   TotalCount = 0;

        Status = ldap_get_next_page_s(SrcLdapHandle, 
                                      Search, 
                                      NULL,         // time out
                                      MT_PAGE_SIZE, // Page Size - number 
                                                    // of entries in one page
                                      &TotalCount, 
                                      &Results
                                      );

        dbprint(("ldap_get_next_page_s returns ==> 0x%x Results 0x%p\n", Status, Results));

        //
        // Get Win32 Error
        // 

        MtGetWinError(SrcLdapHandle, Status, WinError);

        //
        // No more Entry to return.
        // 

        if (LDAP_NO_RESULTS_RETURNED == Status)
        {
            WinError = NO_ERROR;
            goto Error;
        }


        //
        // Status should be in sync with Results
        // test only one would be good enough
        // 

        if ((LDAP_SUCCESS == Status) && Results)
        {
            Entry = ldap_first_entry(SrcLdapHandle, Results);

            while (Entry)
            {
                SamAccountName = ldap_get_valuesW(SrcLdapHandle, 
                                                  Entry, 
                                                  MT_SAMACCOUNTNAME
                                                  );

                //
                // Examine the Current Entry
                // 

                WinError = MtXMoveObjectCheck(MtContext, 
                                              SrcLdapHandle, 
                                              DstLdapHandle, 
                                              DstDsa, 
                                              DstDn, 
                                              Entry,
                                              SamAccountName ? *SamAccountName:NULL
                                              );

                ldap_value_freeW(SamAccountName);

                if (NO_ERROR != WinError)
                {
                    ldap_msgfree(Results);
                    goto Error;
                }

                //
                // Get Next Entry
                // 
                Entry = ldap_next_entry(SrcLdapHandle, Entry);
            }

            ldap_msgfree( Results );
            Results = NULL;
        }
    }

Error:

    ldap_search_abandon_page(SrcLdapHandle, Search);

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CHECK_SOURCE_TREE,
                     WinError, 
                     SrcDn, 
                     NULL
                     );
    }

    return WinError;
}





ULONG
MoveTreeStart(
    PMT_CONTEXT MtContext,
    LDAP   *SrcLdapHandle, 
    LDAP   *DstLdapHandle,
    PWCHAR SrcDsa, 
    PWCHAR DstDsa, 
    PWCHAR SrcDn,
    PWCHAR DstDn 
    )
/*++
Routine Description:

    This routine tries to move the sub-tree to the destination domain.

Parameters:

    MtContext - pointer to this MT_CONTEXT, containers session related info
    
    SrcLdapHandle - Ldap Handle (source domain)
    
    DstLdapHandle - Ldap Handle (Destination domain)
    
    SrcDsa - source domain DSA name
    
    DstDsa - destination domain DSA name
    
    SrcDn - ds name of the root object of the sub-tree at source side
    
    DstDn - root object's new ds name at destination side.

Return Values:

    Windows Error Code

--*/
{
    ULONG   WinError = NO_ERROR;
    ULONG   IgnoreError = NO_ERROR;
    PWCHAR  TempRdn = NULL;      // the Src object's RDN
    PWCHAR  TempDn = NULL;       // the DN in the source side
    PWCHAR  DstParent = NULL;    
    PWCHAR  DstRdn = NULL;
    PWCHAR  OldParent = NULL;
    BOOLEAN Revertable = TRUE;   // indicate can we roll back when failure
    

    MT_TRACE(("\nMoveTreeStart \nSrcDsa:\t%ls \nDstDsa:\t%ls \nSrcDn:\t%ls \nDstDn:\t%ls\n", 
             SrcDsa, DstDsa, SrcDn, DstDn));
             
             
    DstParent = MtGetParentFromDn(DstDn, FALSE);        // with type
    DstRdn = MtGetRdnFromDn(DstDn, FALSE);              // with type
    
    if (NULL == DstParent || NULL == DstRdn)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
   
    // 
    // trying to move the root of the sub-tree without 
    // any preparation.  
    //  
    
    WinError = MtXMoveObject(MtContext, 
                             SrcLdapHandle,
                             DstDsa, 
                             SrcDn, 
                             DstRdn, 
                             DstParent, 
                             MT_DELETE_OLD_RDN
                             );
                             
    
    if (ERROR_DS_CHILDREN_EXIST != WinError)
    {
        if (NO_ERROR != WinError)
        {
            MtWriteError(MtContext, 
                         MT_ERROR_CROSS_DOMAIN_MOVE, 
                         WinError, 
                         SrcDn, 
                         DstParent
                         );
        }
        goto Error;
    }
    
    // 
    // Create MoveContainer and OrphansContainer objects, 
    // MoveContainer DN = sub-tree Root's GUID + LostAndFound
    // OrphansContainer DN = MT_ORPHANS_CONTAINER_RDN + MoveContainer  
    // 
    WinError = MtPrepare(MtContext, 
                         SrcLdapHandle, 
                         SrcDsa, 
                         DstDsa, 
                         SrcDn, 
                         DstDn
                         );      
    
    if (NO_ERROR != WinError)
    {
        goto Error;    
    }

    // 
    // Move the sub tree to the Move Container
    // 
    TempRdn = MtGetRdnFromDn(SrcDn, FALSE);
    
    if (NULL == TempRdn)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    TempDn = MtPrependRdn(TempRdn, 
                          MtContext->MoveContainer
                          );
                          
    //
    // TempRnd is the Root Object's RDN.
    // TempDn = TempRdn + MoveContainerDN
    // that's the root object's new DN under MoveContainer.
    //                           
    
    if (NULL == TempDn)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    WinError = MtMoveObject(MtContext, 
                            SrcLdapHandle,
                            SrcDn, 
                            TempRdn, 
                            MtContext->MoveContainer, 
                            TRUE
                            );
    
    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_LOCAL_MOVE, 
                     WinError, 
                     SrcDn,  
                     MtContext->MoveContainer, 
                     );
                     
        goto Error;
    }
    
    ASSERT(MtContext->RootObjGuid 
           && "RootOjectGuid should not be NULL\n");
    
    WinError = MtCreateProxyContainer(MtContext, 
                                      SrcLdapHandle,
                                      TempDn, 
                                      MtContext->RootObjGuid, 
                                      &(MtContext->RootObjProxyContainer)
                                      );
    
    if (NO_ERROR != WinError && ERROR_ALREADY_EXISTS != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CREATE_PROXY_CONTAINER, 
                     WinError, 
                     TempDn, 
                     NULL
                     );
        goto Error;
    }
    
    WinError = MtMoveChildrenToAnotherContainer(MtContext, 
                                                SrcLdapHandle,
                                                TempDn, 
                                                MtContext->RootObjProxyContainer
                                                );
    
    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_MOVE_CHILDREN_TO_ANOTHER_CONTAINER,
                     WinError, 
                     TempDn, 
                     MtContext->RootObjProxyContainer
                     );
                     
        goto Error;
    }
    
    // 
    // Store the destination DN
    // 
    
    MtContext->RootObjNewDn = MtDupString(DstDn);
                             
    if (NULL == MtContext->RootObjNewDn)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    WinError = MtXMoveObject(MtContext, 
                             SrcLdapHandle,
                             DstDsa, 
                             TempDn, 
                             DstRdn, 
                             DstParent, 
                             MT_DELETE_OLD_RDN
                             );
    
    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CROSS_DOMAIN_MOVE, 
                     WinError, 
                     TempDn, 
                     DstParent
                     );
        goto Error;
    }
    
    Revertable = FALSE;
    
    WinError = MoveTreePhase2(MtContext, 
                              SrcLdapHandle, 
                              DstLdapHandle, 
                              DstDsa,
                              FALSE
                              );
                                    
Error:

    if (NO_ERROR == WinError)
    {
        if (NULL != MtContext->OrphansContainer)
        {
            IgnoreError = MtDeleteEntry(MtContext, 
                                    SrcLdapHandle, 
                                    MtContext->OrphansContainer
                                    );
            dbprint(("Delete OrphansContainer ==> 0x%x\n", IgnoreError));
        }
        
        if (NULL != MtContext->MoveContainer)
        {
            IgnoreError = MtDeleteEntry(MtContext, 
                                    SrcLdapHandle, 
                                    MtContext->MoveContainer
                                    );
            dbprint(("Delete MoveContainer ==> 0x%x\n", IgnoreError));
        }
    }
    else if (NO_ERROR != WinError && Revertable)
    {
        if (ERROR_NOT_ENOUGH_MEMORY == WinError)
        {
            MtWriteError(MtContext, 
                         MT_ERROR_NOT_ENOUGH_MEMORY, 
                         WinError, 
                         NULL,
                         NULL
                         ); 
        }
        if (NULL != TempDn)
        {
            OldParent = MtGetParentFromDn(SrcDn, 
                                          FALSE
                                          );
            
            if (NULL != OldParent)
            {
                IgnoreError = MtMoveObject(MtContext, 
                                           SrcLdapHandle, 
                                           TempDn, 
                                           TempRdn, 
                                           OldParent, 
                                           TRUE
                                           );
            }                                            
        }
        
        if (NULL != MtContext->RootObjProxyContainer)
        {
            IgnoreError = MtMoveChildrenToAnotherContainer(MtContext, 
                                                           SrcLdapHandle, 
                                                           MtContext->RootObjProxyContainer,
                                                           SrcDn
                                                           );
                                                           
            IgnoreError = MtDeleteEntry(MtContext, 
                                        SrcLdapHandle, 
                                        MtContext->RootObjProxyContainer
                                        );                                                           
            dbprint(("Delete RootObjProxyContainer ==> 0x%x\n", IgnoreError));
        }                                                                                            
        
        if (NULL != MtContext->OrphansContainer)
        {
            IgnoreError = MtDeleteEntry(MtContext, 
                                        SrcLdapHandle, 
                                        MtContext->OrphansContainer
                                        );
            dbprint(("Delete OrphansContainer ==> 0x%x\n", IgnoreError));
        }
        
        if (NULL != MtContext->MoveContainer)
        {
            IgnoreError = MtDeleteEntry(MtContext, 
                                        SrcLdapHandle, 
                                        MtContext->MoveContainer
                                        );
            dbprint(("Delete MoveContainer ==> 0x%x\n", IgnoreError));
        }
    }
    
    
    MtFree(DstParent);
    MtFree(DstRdn);
    MtFree(TempRdn);
    MtFree(TempDn);
    MtFree(OldParent);

    return WinError;
}





ULONG
MoveTreeContinue(
    PMT_CONTEXT MtContext,
    LDAP   *SrcLdapHandle,
    LDAP   *DstLdapHandle, 
    PWCHAR SrcDsa, 
    PWCHAR DstDsa, 
    PWCHAR Identifier
    )
/*++
Routine Description

    This routine continues a previous failed move tree operation
    
Parameters:

    MtContext - Pointer to MT_CONTEXT, session related info
    SrcLdapHandle - Ldap Handle, to the source domain
    DstLdapHandle - Ldap Handle, to the destination domain
    SrcDsa - Source domain dsa name
    DstDsa - Destination domain dsa name
    Identifier - root object's ds name at destination side

Return Values:

    Windows Error Code

--*/
{
    ULONG   WinError = NO_ERROR;
    
    //
    // We need to find the MoveContainer, Orphaned Objects Container 
    // and the root ProxyContainer
    // Once we have the MoveContainer, we should check the consistence of
    // SrcDsa and DstDsa ...
    // 
    
    MT_TRACE(("\nMoveTreeContinue \nSrcDsa:\t%ls \nDstDsa:\t%ls \nIdentifier:\t%ls \n", 
             SrcDsa, DstDsa, Identifier));
             
        
    if (MtContext->Flags & MT_CONTINUE_BY_GUID)
    {
        MtContext->RootObjGuid = MtDupString(Identifier);
                                   
        if (NULL == MtContext->RootObjGuid)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            return WinError;
        }
        
        WinError = MtGetDnFromGuid(MtContext, 
                                   DstLdapHandle, 
                                   Identifier, 
                                   &(MtContext->RootObjNewDn)
                                   );
                                   
        if (NO_ERROR != WinError)
        {
            MtWriteError(MtContext, 
                         MT_ERROR_GET_DN_FROM_GUID, 
                         WinError, 
                         Identifier, 
                         NULL
                         );
            return WinError;
        }
    }
    else if (MtContext->Flags & MT_CONTINUE_BY_DSTROOTOBJDN)
    {
        MtContext->RootObjNewDn = MtDupString( Identifier );
        
        if (NULL == MtContext->RootObjNewDn)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            return WinError;
        }
        
        WinError = MtGetGuidFromDn(MtContext, 
                                   DstLdapHandle, 
                                   Identifier, 
                                   &(MtContext->RootObjGuid)
                                   );
                                  
        if (NO_ERROR != WinError)
        {
            MtWriteError(MtContext, 
                         MT_ERROR_GET_GUID_FROM_DN, 
                         WinError, 
                         Identifier, 
                         NULL
                         );
            return WinError;
        }
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    WinError = MtCreateNecessaryDn(MtContext, 
                                   SrcLdapHandle
                                   );
    
    if (NO_ERROR != WinError)
    {
        return WinError;
    }
    
    MtContext->RootObjProxyContainer = MtAlloc(sizeof(WCHAR) * 
                                               (wcslen(MtContext->RootObjGuid) + 
                                                wcslen(MtContext->MoveContainer) + 
                                                5)
                                               );
                                         
    if (NULL == MtContext->RootObjProxyContainer)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        return WinError;
    }
        
    swprintf(MtContext->RootObjProxyContainer, 
             L"cn=%s,%s", 
             MtContext->RootObjGuid, 
             MtContext->MoveContainer
             );
              
    //
    // Should check whether these parameters match previous call or not
    // and should check object existance
    //               
    WinError = MtCheckMoveContainer(MtContext, 
                                    SrcLdapHandle, 
                                    SrcDsa, 
                                    DstDsa
                                    );

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CHECK_MOVECONTAINER, 
                     WinError, 
                     MtContext->MoveContainer, 
                     NULL
                     );

        return WinError;
    }

    //
    // Enter Phase2 
    // 

    WinError = MoveTreePhase2(MtContext, 
                              SrcLdapHandle, 
                              DstLdapHandle, 
                              DstDsa, 
                              TRUE
                              );

    if (NO_ERROR == WinError)
    {
        if (NULL != MtContext->OrphansContainer)
        {
            MtDeleteEntry(MtContext, 
                          SrcLdapHandle, 
                          MtContext->OrphansContainer
                          );
        }
        if (NULL != MtContext->MoveContainer)
        {
            MtDeleteEntry(MtContext, 
                          SrcLdapHandle, 
                          MtContext->MoveContainer
                          );
        }
    }
    else if (ERROR_NOT_ENOUGH_MEMORY == WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_NOT_ENOUGH_MEMORY, 
                     WinError, 
                     NULL, 
                     NULL 
                     );                
    }

    return WinError;
}


ULONG
MtCreateLogFiles(
    PMT_CONTEXT  MtContext, 
    PWCHAR       LogFileName, 
    PWCHAR       ErrorFileName, 
    PWCHAR       CheckFileName
    )
{
    ULONG   WinError = NO_ERROR;


    MT_TRACE(("\nMtCreateLogFiles\n"));    
    
    if (!(MtContext->Flags & MT_NO_LOG_FILE) && LogFileName)
    {
        MtContext->LogFile = _wfopen(LogFileName, L"w");
        
        if (NULL == MtContext->LogFile)
        {
            WinError = GetLastError();
        }
    }
    
    if (!(MtContext->Flags & MT_NO_ERROR_FILE) && ErrorFileName)
    {
        MtContext->ErrorFile = _wfopen(ErrorFileName, L"w");
        
        if (NULL == MtContext->ErrorFile)
        {
            WinError = GetLastError();
        }
    }

    if (!(MtContext->Flags & MT_NO_CHECK_FILE) && CheckFileName)
    {
        MtContext->CheckFile = _wfopen(CheckFileName, L"w");

        if (NULL == MtContext->CheckFile)
        {
            WinError = GetLastError();
        }
    }
    
    return WinError;                                   
}
    




ULONG
MoveTree(
    PWCHAR   SrcDsa, 
    PWCHAR   DstDsa, 
    PWCHAR   SrcDn,
    PWCHAR   DstDn,
    SEC_WINNT_AUTH_IDENTITY_EXW *Credentials OPTIONAL,
    PWCHAR   LogFileName, 
    PWCHAR   ErrorFileName, 
    PWCHAR   Identifier, 
    ULONG    Flags,
    PMT_ERROR MtError
    )
/*++

Routine Description:

    This routine calls either MoveTreeStart or MoveTreeContinue
    to finish the job

Parameters: 

    srcDsa -- Pointer to the source DSA name
    dstDsa -- Pointer to the destination DSA name

Return Value:

    Win32 Error Code

--*/    
{
    ULONG   WinError = NO_ERROR; 
    ULONG   IgnoreError = NO_ERROR;
    LDAP    *SrcLdapHandle = NULL;
    LDAP    *DstLdapHandle = NULL;
    MT_CONTEXT MoveContext; 
    
/*   
    MT_TRACE(("\nMoveTreeStart\n")); 
    

    // 
    // Validate Parameters
    // 

    if (NULL == SrcDsa || NULL == DstDsa)
    {
        return ERROR_INVALID_PARAMETER;
    }

    
    __try    
    {
        // 
        // init variables
        // 
        
        memset(&MoveContext, 0, sizeof(MT_CONTEXT));
        
        MoveContext.Flags = Flags;
        
        //
        // Our Default is to create Log file and Error file.
        // If the client really does not want to have it.
        // do it as requried.    
        // 
        
        if ( !(Flags & MT_NO_LOG_FILE) || !(Flags & MT_NO_ERROR_FILE) )
        {
            WinError = MtCreateLogFiles(&MoveContext, 
                                        LogFileName?LogFileName:DEFAULT_LOG_FILE_NAME, 
                                        ErrorFileName?ErrorFileName:DEFAULT_ERROR_FILE_NAME
                                        );

       
            if (NO_ERROR != WinError)
            {
                MtWriteError((&MoveContext), 
                             MT_ERROR_CREATE_LOG_FILES, 
                             WinError, 
                             LogFileName?LogFileName:DEFAULT_LOG_FILE_NAME, 
                             ErrorFileName?ErrorFileName:DEFAULT_ERROR_FILE_NAME
                             );
                              
                __leave;
            }
        }
        
        // 
        // Set up session 
        //  
        WinError = MtSetupSession(&MoveContext, 
                                  &SrcLdapHandle, 
                                  &DstLdapHandle,
                                  SrcDsa, 
                                  DstDsa, 
                                  Credentials
                                  );
    
        dbprint(("MtSetupSession ==> 0x%x\n", WinError));
    
        if (NO_ERROR != WinError)
        {
            //
            // Log Error: Failed to set session
            // 
            __leave;
        }
        
        // 
        // call the worker routine
        // 

        if (Flags & MT_CHECK)
        {
            WinError = MoveTreeCheck(&MoveContext, 
                                     SrcLdapHandle, 
                                     DstLdapHandle, 
                                     SrcDsa, 
                                     DstDsa, 
                                     SrcDn, 
                                     DstDn
                                     );

            dbprint(("MoveTreeCheck ==> 0x%x\n", WinError));                                        
        }
        else if (Flags & MT_CONTINUE_MASK)
        {
            WinError = MoveTreeContinue(&MoveContext,
                                        SrcLdapHandle, 
                                        DstLdapHandle,
                                        SrcDsa, 
                                        DstDsa, 
                                        Identifier
                                        );
                                        
            dbprint(("MoveTreeContinue ==> 0x%x\n", WinError));                                        
        }
        else if (Flags & MT_START)
        {
            WinError = MoveTreeStart(&MoveContext,
                                     SrcLdapHandle, 
                                     DstLdapHandle, 
                                     SrcDsa, 
                                     DstDsa, 
                                     SrcDn, 
                                     DstDn
                                     );
                                     
            dbprint(("MoveTreeStart ==> 0x%x\n", WinError));  
        }                                   
        else
        {
            WinError = ERROR_INVALID_PARAMETER;
        }
    
    }
    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("\nMOVETREE in MoveTree() Exception Happened ==> 0x%x\n", GetExceptionCode());
        WinError = ERROR_EXCEPTION_IN_SERVICE; 
    }


Error:

    MtDisconnect(&SrcLdapHandle);
    MtDisconnect(&DstLdapHandle);
    
    
    MtFree(MoveContext.MoveContainer);
    MtFree(MoveContext.OrphansContainer);
    MtFree(MoveContext.RootObjProxyContainer);
    MtFree(MoveContext.RootObjNewDn);
    MtFree(MoveContext.RootObjGuid);
    
    if (MoveContext.LogFile)
    {
        fclose(MoveContext.LogFile);
    }
    if (MoveContext.ErrorFile)
    {
        fclose(MoveContext.ErrorFile); 
    }

    MtError->ErrorType = MoveContext.ErrorType;
    
    dbprint(("MoveTree() ==> 0x%x\n", WinError));
*/


    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\movetree\dll\movetree.h ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    MOVETREE.H

Abstract:

    This is the header file for MoveTree Operaion. Including some 
    global variables and declareation. 

Author:

    12-Oct-98 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    12-Oct-98 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Global Variables and Private Routines                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#ifndef _MOVETREE_
#define _MOVETREE_



#include <ntldap.h>
#include <winldap.h>
#include <lmaccess.h>


#define SECURITY_WIN32  // Needed for sspi.h
#include <sspi.h>
#include <secext.h>


#include "mtmsgs.h"




// 
// Debug output switch
//

#define MOVETREE_DBG    0
#define MOVETREE_TRACE  0

#if (MOVETREE_DBG == 1)
#define dbprint(x) printf x
#else
#define dbprint(x)
#endif


#if (MOVETREE_TRACE == 1)
#define MT_TRACE(x)  printf x
#else
#define MT_TRACE(x)
#endif


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Type Define and Global Variables                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


// 
// keep a list of state information
//
 
typedef struct _MT_STACK_ITEM {
    PWCHAR  MoveProxyContainer;
    PWCHAR  NewParent;
    LDAPMessage *Results;
    LDAPMessage *Entry;
    struct _MT_STACK_ITEM  * Next;
} MT_STACK, * PMT_STACK;




//
// return useful information to client
// 

typedef struct _MT_ERROR {
    ULONG   ErrorType;
    PWCHAR  ErrorObjDn;
} MT_ERROR, * PMT_ERROR; 


//
// Move Tree Private Information
//

typedef struct _MT_CONTEXT {
    PWCHAR  MoveContainer;
    PWCHAR  OrphansContainer;
    PWCHAR  RootObjProxyContainer;
    PWCHAR  RootObjGuid; 
    PWCHAR  RootObjNewDn;
    PWCHAR  DstDomainBaseDn;
    ULONG   Flags; 
    FILE    *LogFile; 
    FILE    *ErrorFile;
    FILE    *CheckFile;
    ULONG   ErrorType;
} MT_CONTEXT, * PMT_CONTEXT;



//
// define different kind of error
// 

#define MT_NO_ERROR                 0x00000000
#define MT_ERROR_ORPHAN_LEFT        0x00000001
#define MT_ERROR_BEFORE_START       0x00000002 
#define MT_ERROR_BEFORE_CONTINUE    0x00000004
#define MT_ERROR_FATAL              0x00000008
#define MT_ERROR_CHECK              0x00000010



//
// Control MoveTree behaviors  
// 


#define MT_START                    0x00000001
#define MT_CONTINUE_BY_GUID         0x00000002
#define MT_CONTINUE_BY_DSTROOTOBJDN 0x00000004 
#define MT_CHECK                    0x00000008
#define MT_NO_LOG_FILE              0x00000010
#define MT_NO_ERROR_FILE            0x00000020
#define MT_NO_CHECK_FILE            0x00000040
#define MT_VERBOSE                  0x00000080


#define MT_CONTINUE_MASK        (MT_CONTINUE_BY_GUID | MT_CONTINUE_BY_DSTROOTOBJDN )


#define MT_DELETE_OLD_RDN           0x00000001
#define MT_XMOVE_CHECK_ONLY         0x00000002





//
// Log File Name 
// 
 
#define DEFAULT_LOG_FILE_NAME       L"movetree.log"
#define DEFAULT_ERROR_FILE_NAME     L"movetree.err"
#define DEFAULT_CHECK_FILE_NAME     L"movetree.chk"


//
// moveTreeState Tag
// 
#define MOVE_TREE_STATE_VERSION             0x1
#define MOVE_TREE_STATE_MOVECONTAINER_TAG   L"MoveContainer"
#define MOVE_TREE_STATE_PROXYCONTAINER_TAG  L"ProxyContainer"
#define MOVE_TREE_STATE_SRCDSA_TAG          L"SrcDSA:"
#define MOVE_TREE_STATE_DSTDSA_TAG          L"DstDSA:"
#define MOVE_TREE_STATE_GUID_TAG            L"GUID:" 

//
// LDAP Attributes
// 
 
#define MT_ORPHAN_CONTAINER_RDN     L"CN=Orphaned Objects"
#define MT_LOSTANDFOUND_CLASS       L"lostAndFound"
#define MT_DEFAULTNAMINGCONTEXT     L"defaultNamingContext"
#define MT_MOVETREESTATE            L"moveTreeState"
#define MT_OBJECTCLASS              L"objectClass"
#define MT_OBJECTGUID               L"objectGUID"
#define MT_SRCDSANAME               L"sourceDsaName"
#define MT_DSTDSANAME               L"destinationDsaName"
#define MT_SAMACCOUNTNAME           L"samAccountName"
#define MT_CN                       L"cn"
#define MT_GPLINK                   L"gPLink"
#define MT_NTMIXEDDOMAIN            L"nTMixedDomain"


//
// Search Limitation
// 

#ifdef  DBG
    #define MT_SEARCH_LIMIT       50 
#else
    #define MT_SEARCH_LIMIT      100 
#endif


#ifdef  DBG
    #define MT_PAGED_SEARCH_LIMIT      50 
#else
    #define MT_PAGED_SEARCH_LIMIT     100
#endif



#ifdef DBG
    #define MT_PAGE_SIZE         10        
#else
    #define MT_PAGE_SIZE         20 
#endif







//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Published Routines                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
MoveTree(
    PWCHAR   SrcDsa, 
    PWCHAR   DstDsa, 
    PWCHAR   SrcDn,
    PWCHAR   DstDn,
    SEC_WINNT_AUTH_IDENTITY_EXW *Credentials,  
    PWCHAR   LogFileName, 
    PWCHAR   ErrorFileName,
    PWCHAR   Identifier, 
    ULONG    Flags, 
    PMT_ERROR MtError
    );


ULONG
MoveTreeCheck(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle,
    LDAP    *DstLdapHandle,
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa, 
    PWCHAR  SrcDn, 
    PWCHAR  DstDn
    );
    

ULONG
MoveTreeStart(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle, 
    LDAP    *DstLdapHandle,
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa, 
    PWCHAR  SrcDn,
    PWCHAR  DstDn
    );
    
    
ULONG
MoveTreeContinue(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle, 
    LDAP    *DstLdapHandle,
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa, 
    PWCHAR  Identifier
    ); 


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Private Utility Routines (LDAP Calls)                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

ULONG
MtCreateLogFiles(
    PMT_CONTEXT  MtContext, 
    PWCHAR  LogFileName, 
    PWCHAR  ErrorFileName,
    PWCHAR  CheckFileName
    );


VOID
MtLogMessage(
    FILE    *FileToLog,
    ULONG   MessageId, 
    ULONG   WinError, 
    PWCHAR  Parm1, 
    PWCHAR  Parm2, 
    ULONG   Flags
    ); 
    
    
#define MtWriteLog(MtContext, MessageId, WinError, Parm1, Parm2)    \
{                                                                   \
    if (!(MtContext->Flags & MT_NO_LOG_FILE) && MtContext->LogFile) \
    {                                                               \
        MtLogMessage(MtContext->LogFile,                            \
                     MessageId,                                     \
                     WinError,                                      \
                     Parm1,                                         \
                     Parm2,                                         \
                     MtContext->Flags                               \
                     );                                             \
    }                                                               \
}

#define MtWriteError(MtContext, MessageId, WinError, Parm1, Parm2)  \
{                                                                   \
    MtContext->ErrorType |= MT_ERROR_FATAL;                         \
    if (!(MtContext->Flags & MT_NO_ERROR_FILE) &&                   \
        MtContext->ErrorFile)                                       \
    {                                                               \
        MtLogMessage(MtContext->ErrorFile,                          \
                     MessageId,                                     \
                     WinError,                                      \
                     Parm1,                                         \
                     Parm2,                                         \
                     MtContext->Flags                               \
                     );                                             \
    }                                                               \
}

#define MtWriteCheck(MtContext, MessageId, WinError, Parm1, Parm2)  \
{                                                                   \
    if (NO_ERROR != WinError)                                       \
    {                                                               \
        MtContext->ErrorType |= MT_ERROR_CHECK;                     \
    }                                                               \
    if (!(MtContext->Flags & MT_NO_CHECK_FILE) &&                   \
        MtContext->CheckFile)                                       \
    {                                                               \
        MtLogMessage(MtContext->CheckFile,                          \
                     MessageId,                                     \
                     WinError,                                      \
                     Parm1,                                         \
                     Parm2,                                         \
                     MtContext->Flags                               \
                     );                                             \
    }                                                               \
}

#define MtGetWinError(LdapHandle, Status, WinError)                 \
{                                                                   \
    if (LDAP_SUCCESS != Status)                                     \
    {                                                               \
        if (LDAP_UNAVAILABLE == ldap_get_optionW(LdapHandle,        \
                                        LDAP_OPT_SERVER_EXT_ERROR,  \
                                        &WinError ))                \
        {                                                           \
            WinError = LdapMapErrorToWin32(Status);                 \
        }                                                           \
    }                                                               \
    else                                                            \
    {                                                               \
        WinError = NO_ERROR;                                        \
    }                                                               \
    dbprint(("Status==> 0x%x WinError==> 0x%x\n",Status,WinError)); \
}



ULONG
MtSetupSession(
    PMT_CONTEXT MtContext, 
    LDAP    **SrcLdapHandle, 
    LDAP    **DstLdapHandle,
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa, 
    SEC_WINNT_AUTH_IDENTITY_EXW *Credentials
    );

VOID
MtDisconnect( 
    LDAP    **LdapHandle
    );


ULONG
MtGetLastLdapError(
    VOID
    );



ULONG
MtSearchChildren(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  Dn, 
    LDAPMessage **Results
    );


PLDAPMessage
MtGetFirstEntry(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle,
    LDAPMessage *Results 
    );
    
    
PLDAPMessage
MtGetNextEntry(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle,
    LDAPMessage *Entry
    );
    

ULONG
MtDeleteEntry(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn
    );


PWCHAR
MtGetDnFromEntry(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle,
    LDAPMessage *Entry 
    );


ULONG  
MtGetGuidFromDn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn,
    PWCHAR  *Guid 
    );


ULONG
MtGetDnFromGuid(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Guid, 
    PWCHAR  *Dn
    );

    
ULONG
MtGetNewParentDnFromProxyContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle,
    LDAP    *DstLdapHandle,
    PWCHAR  ProxyContainer, 
    PWCHAR  *NewParentDn
    );


ULONG
MtGetLostAndFoundDn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  *LostAndFound
    );


ULONG
MtAddEntry(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn
    );


ULONG
MtAddEntryWithAttrs(
    PMT_CONTEXT MtContext, 
    LDAP     *LdapHandle,
    PWCHAR   Dn,
    LDAPModW *Attributes[]
    );
    
    
ULONG
MtXMoveObjectA(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  DstDsa,   
    PWCHAR  Dn,  
    PWCHAR  NewRdn,         // should with type info
    PWCHAR  NewParent, 
    INT     DeleteOldRdn
    );
    

ULONG
MtXMoveObject(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  DstDsa,   
    PWCHAR  Dn,  
    PWCHAR  NewRdn,         // should with type info
    PWCHAR  NewParent, 
    ULONG   Flags
    );


ULONG
MtXMoveObjectWithOrgRdn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  DstDsa, 
    PWCHAR  Dn, 
    PWCHAR  NewParent, 
    ULONG   Flags
    );


ULONG
MtXMoveObjectCheck(
    PMT_CONTEXT MtContext, 
    LDAP * SrcLdapHandle, 
    LDAP * DstLdapHandle, 
    PWCHAR  DstDsa, 
    PWCHAR  DstDn, 
    LDAPMessage * Entry,
    PWCHAR  SamAccountName 
    );

ULONG
MtCheckDupSamAccountName(
    PMT_CONTEXT MtContext, 
    LDAP * LdapHandle, 
    PWCHAR SamAccountName
    );


ULONG
MtCheckRdnConflict(
    PMT_CONTEXT MtContext, 
    LDAP * LdapHandle, 
    PWCHAR SrcDn, 
    PWCHAR DstDn
    );


ULONG
MtCheckDstDomainMode(
    PMT_CONTEXT MtContext, 
    LDAP * LdapHandle
    );


ULONG
MtMoveObject(
    PMT_CONTEXT MtContext, 
    LDAP     *LdapHandle,
    PWCHAR   Dn, 
    PWCHAR   NewRdn, 
    PWCHAR   NewParent,
    INT      DeleteOldRdn
    );


ULONG
MtMoveObjectWithOrgRdn(
    PMT_CONTEXT MtContext, 
    LDAP     *LdapHandle, 
    PWCHAR   Dn, 
    PWCHAR   NewParent, 
    INT      DeleteOldRdn
    );


ULONG
MtCreateProxyContainerDn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    PWCHAR  Guid,
    PWCHAR  *ProxyContainer
    );

    
ULONG
MtCreateProxyContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    PWCHAR  Guid,
    PWCHAR  *ProxyContainer
    );


ULONG
MtIsProxyContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    LDAPMessage *Entry, 
    BOOLEAN *fIsProxyContainer
    );


ULONG   
MtObjectExist(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    BOOLEAN *fExist
    );



ULONG
MtHavingChild(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    BOOLEAN *HavingChild
    );
    

ULONG
MtMoveChildrenToAnotherContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    PWCHAR  DstContainer
    );
    
    
ULONG
MtCreateMoveContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa
    );


ULONG
MtCheckMoveContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa
    );


//
// Utility Routines which does not require MT_CONTEXT
//

PWCHAR   
MtGetRdnFromDn(
    PWCHAR  Dn, 
    ULONG   NoTypes
    );


PWCHAR
MtGetParentFromDn(
    PWCHAR  Dn, 
    ULONG   NoTypes
    );


PWCHAR
MtPrependRdn(
    PWCHAR  Rdn, 
    PWCHAR  Parent
    );
    
    
    

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Private Utility Routines                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



PVOID
MtAlloc( 
    SIZE_T size 
    );


VOID
MtCopyMemory( 
    VOID  *Destination, 
    CONST VOID  *Source, 
    SIZE_T  Length
    );


VOID
MtFree(
    PVOID BaseAddress
    );
    
PWCHAR
StringToWideString(
    PCHAR src
    );


PCHAR
WideStringToString(
    PWCHAR  src
    );


PWCHAR
MtDupString(
    PWCHAR  src
    );
    

VOID
MtInitStack( 
    MT_STACK *Stack 
    );


ULONG
MtPush(
    MT_STACK *Stack,
    PWCHAR  NewParent,
    PWCHAR  MoveProxyContainer, 
    LDAPMessage *Results, 
    LDAPMessage *Entry
    );
    

VOID
MtPop(
    MT_STACK *Stack,
    PWCHAR  *NewParent,
    PWCHAR  *MoveProxyContainer, 
    LDAPMessage **Results, 
    LDAPMessage **Entry
    );


VOID
MtTop(
    MT_STACK Stack,
    PWCHAR  *NewParent,
    PWCHAR  *MoveProxyContainer, 
    LDAPMessage **Results, 
    LDAPMessage **Entry
    );


BOOLEAN
MtStackIsEmpty(
    MT_STACK Stack
    );


VOID
MtFreeStack(
    MT_STACK   *Stack
    ); 



#endif  // _MOVETREE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\movetree\dll\mtutil.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    MTUTIL.C

Abstract:

    This file contains couple of utility routines.

Author:

    12-Oct-98 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    12-Oct-98 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Include                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma  hdrstop


#include "movetree.h"




PWCHAR   
MtGetRdnFromDn(
    PWCHAR  Dn, 
    ULONG   NoTypes
    )
/*++
Routine Description: 

    The routine will strip the RDN from a whole DN. 
    The Caller should release the returned result by calling MtFree()
    
Parameters: 

    Dn -- pointer to the DN
    NoTypes -- TURE, indicates to strip tag like CN=... OU=.. as well
               FALSE, not

Return Values:

    Pointer to the RDN, NULL means error

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    PWCHAR  *ExplodedDn = NULL; 
    PWCHAR  Rdn = NULL;
    
    MT_TRACE(("\nMtGetRdnFromDn %ls %x\n", Dn, NoTypes));
    
    ExplodedDn = ldap_explode_dnW(Dn, NoTypes); 
    
    if (NULL == ExplodedDn)
    {

        // ldap_get_optionW(ldapHandleSrc, 
        //                  LDAP_OPT_ERROR_NUMBER,
        //                  &Status
        //                  );
                         
        dbprint(("ldap_explode_dnW ==> 0x%x\n", Status));
    }
    else
    {
        Rdn = MtAlloc( sizeof(WCHAR)*(wcslen(ExplodedDn[0]) + 1) );
        
        if (NULL != Rdn)
        {
            wcscpy(Rdn, ExplodedDn[0]);
        }
        
        ldap_value_freeW(ExplodedDn);
    }
    
    dbprint(("MtGetRdnFromDn Dn: %ls Rdn %ls\n", Dn, Rdn));
    
    return Rdn;
}




PWCHAR
MtGetParentFromDn(
    PWCHAR  Dn, 
    ULONG   NoTypes
    )
/*++
Routine Description: 
    
    This routine will strip the parent DN from the object's DN. 
    the caller should free the return result by calling MtFree()

Parameters: 
    
    Dn -- pointer to the object DN
    NoTypes -- TRUE, no CN= or OU= like tages
               FALSE

Return Values:

    Pointer to the Parent DN if succeed, otherwise NULL

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   Index = 0;
    ULONG   ValuesCount = 0;
    ULONG   RequiredSize = 0;
    PWCHAR  *ExplodedDn = NULL;
    PWCHAR  Parent = NULL;
    
    MT_TRACE(("\nMtGetParentFromDn Dn %ls %x\n", Dn, NoTypes));
    
    ExplodedDn = ldap_explode_dnW(Dn, NoTypes);
    
    if (NULL == ExplodedDn)
    {
    //    ldap_get_option(ldapHandleSrc, 
    //                    LDAP_OPT_ERROR_NUMBER,
    //                    &Status
    //                    );
    }
    else
    {
        ValuesCount = ldap_count_valuesW(ExplodedDn);
        
        if (ValuesCount > 1)
        {
            for (Index = 1; Index < ValuesCount; Index++)
            {
                RequiredSize += (wcslen(ExplodedDn[Index]) + 1);
            }
        
            Parent = MtAlloc(RequiredSize * sizeof(WCHAR));
            
            if (NULL != Parent)
            {
                for (Index = 1; Index < ValuesCount; Index++)
                {
                    wcscat(Parent, ExplodedDn[Index]);    
                    
                    if (Index != ValuesCount - 1)
                    {
                        wcscat(Parent, L",");
                    }
                }
            }
            
            dbprint(("Parent ==> %ls\n", Parent));
        }
        else
        {
            Status = LDAP_OTHER;
        }
        
        ldap_value_freeW(ExplodedDn);    
    }
    
    return Parent;
}




PWCHAR
MtPrependRdn(
    PWCHAR  Rdn, 
    PWCHAR  Parent
    )
/*++
Routine Description: 

    This routine appends Parent to Rdn, thus create a full DN.
    the caller should release the result by calling MtFree().

Parameters: 

    Rdn -- Pointer to RDN
    Parent -- Pointer to Parent DN

Return Values:
    
    Pointer to new DN if succeed, NULL otherwise.

--*/
{
    PWCHAR  NewDn = NULL;
    
    MT_TRACE(("\nMtPrependRdn Rdn:%ls Parent:%ls\n", Rdn, Parent));
    
    NewDn = MtAlloc(sizeof(WCHAR) * (wcslen(Rdn) + wcslen(Parent) + 2));
    
    if (NULL != NewDn)
    {
        swprintf(NewDn, L"%s,%s", Rdn, Parent);
    }
    
    return NewDn;
}



/*++

    The following routines provide a wrapper for memory 
    allocation, release and copy 
    
--*/

PVOID
MtAlloc(
    SIZE_T size
    )
{
    PVOID temp = NULL;
    
    temp = RtlAllocateHeap(RtlProcessHeap(), 
                          0, 
                          size
                          );
    if (NULL != temp)
    {
        RtlZeroMemory(temp, size);
    }
    
    return temp;
}


VOID
MtCopyMemory(
    VOID *Destination, 
    CONST VOID *Source, 
    SIZE_T  Length
    )
{
    RtlCopyMemory(Destination, Source, Length);
    return;
}


VOID
MtFree(
    PVOID BaseAddress
    )
{    
    if (NULL != BaseAddress)
        RtlFreeHeap(RtlProcessHeap(), 0, BaseAddress);
    
    return;
}
    
    

   
PWCHAR
StringToWideString(
    PCHAR src
    )
/*++

Description:
    
    Convert an ascii string to wide char string, and allocate memory
    for the wide char string. The Caller should free the result by
    calling MtFree().
    
Parameter:

    src - pointer to ascii string
    
Return Value: 

    dst - pointer to Wide char string.  
          NULL if no memory
          
--*/
{

    PWCHAR dst = NULL;
    ULONG  cWB = 0;
    
    if (NULL == src)
    {
        return NULL;
    }
    
    cWB = MultiByteToWideChar(CP_ACP, 
                             0,
                             src,
                             strlen(src),
                             NULL,
                             0);
                             
    dst = MtAlloc((cWB + 1) * sizeof(WCHAR));
    
    if (NULL != dst)
    {
        MultiByteToWideChar(CP_ACP,
                            0, 
                            src, 
                            strlen(src),
                            dst,
                            cWB);
                            
        dst[cWB] = 0;           // NULL terminator                                  
                                  
    }
    
    return dst;
}




PCHAR
WideStringToString(
    PWCHAR  src
    )
/*++

Description:
    
    Convert wide char string to single byte char string, and allocate memory
    for the ascii char string. The Caller should free the result by MtFree()
    
Parameter:

    src - pointer to wide char string
    
Return Value: 

    dst - pointer to single byte char string.  
          NULL if no memory
          
--*/
{
    PCHAR   dst = NULL;
    ULONG   cb = 0;
    
    if (NULL == src)
    {
        return NULL;
    }
    
    cb = WideCharToMultiByte(CP_UTF8,
                             0,
                             src, 
                             wcslen(src),
                             NULL,
                             0, 
                             NULL, 
                             NULL);

    dst = MtAlloc(cb + 1);
    if (NULL != dst)
    {
        WideCharToMultiByte(CP_UTF8,
                            0, 
                            src, 
                            wcslen(src),
                            dst, 
                            cb, 
                            NULL, 
                            NULL);
        dst[cb] = 0;                            

    }
    
    return dst;
}



PWCHAR
MtDupString(
    PWCHAR  src
    )
/*++

Routine Description: 

    Duplicate an wide char string, allocate memory for it. 
    The caller should release the memory by MtFree().
    
    Return NULL is no memory.
    
--*/
{
    PWCHAR  dst = NULL;
    
    MT_TRACE(("\nMtDupString %ls\n", src));
    
    dst = MtAlloc( (wcslen(src) + 1) * sizeof(WCHAR));
    
    if (NULL != dst)
    {
        MtCopyMemory(dst, src, wcslen(src) * sizeof(WCHAR));
    }
    
    return dst;
}
     


VOID
MtInitStack( 
    MT_STACK *Stack 
    )
/*++

Routine Description: 

    Initiate a stack. Actually, the head of link-list.

--*/
    
{
    MT_TRACE(("\nMtInitStack\n"));
    
    Stack->NewParent = NULL;
    Stack->MoveProxyContainer = NULL;
    Stack->Results = NULL;
    Stack->Entry = NULL;
    Stack->Next = NULL;
    return;
}


ULONG
MtPush(
    MT_STACK *Stack,
    PWCHAR  NewParent,
    PWCHAR  MoveProxyContainer, 
    LDAPMessage *Results, 
    LDAPMessage *Entry
    )
/*++

Routine Description

    Put an item in front of the link-list, fill the item. 
    
--*/
{
    MT_STACK   *Temp = NULL;
    
    MT_TRACE(("\nMtPush NewParent:\t%ls \nMoveProxyCon:\t%ls\n", NewParent, MoveProxyContainer));
    
    Temp = MtAlloc(sizeof(MT_STACK));
    
    if (NULL == Temp)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    Temp->NewParent = NewParent;
    Temp->MoveProxyContainer = MoveProxyContainer;
    Temp->Results = Results;
    Temp->Entry = Entry;
    Temp->Next = Stack->Next;
    
    Stack->Next = Temp;

    return NO_ERROR;
}
    

VOID
MtPop(
    MT_STACK *Stack,
    PWCHAR  *NewParent,
    PWCHAR  *MoveProxyContainer, 
    LDAPMessage **Results, 
    LDAPMessage **Entry
    )
/*++

Routine Description: 

    Get the first item from stack (link-list).
    
--*/
{
    MT_STACK   *Temp = NULL;    
    
    MT_TRACE(("\nMtPop\n"));

    Temp = Stack->Next;
    
    if (NULL == Temp)
    {
        return;
    }
    
    *NewParent = Temp->NewParent;
    *MoveProxyContainer = Temp->MoveProxyContainer;
    *Results = Temp->Results;
    *Entry = Temp->Entry;
    
    Stack->Next = Temp->Next;
    
    MtFree(Temp);
    
    dbprint(("MtPop NewParent: %ls MoveProxy: %ls \n", *NewParent, *MoveProxyContainer));
    return;
}


VOID
MtTop(
    MT_STACK Stack,
    PWCHAR  *NewParent,
    PWCHAR  *MoveProxyContainer, 
    LDAPMessage **Results, 
    LDAPMessage **Entry
    )
/*++

Routine Description: 

    Get the first item from stack (link-list).
    
--*/
{
    MT_STACK   *Temp = NULL;    

    MT_TRACE(("\nMtTop"));
    
    Temp = Stack.Next;
    
    if (NULL == Temp)
    {
        return;
    }
    
    *NewParent = Temp->NewParent;
    *MoveProxyContainer = Temp->MoveProxyContainer;
    *Results = Temp->Results;
    *Entry = Temp->Entry;
    
    dbprint(("MtTop NewParent: %ls MoveProxy: %ls \n", *NewParent, *MoveProxyContainer));
    return; 
}


BOOLEAN
MtStackIsEmpty(
    MT_STACK Stack
    )
/*++

Routine Description: 

    Check whether the stack has any item. 
    
--*/
{
    MT_TRACE(("\nMtStackIsEmpty\n"));

    dbprint(("MtStackIsEmpty: %p\n", Stack.Next));

    if (NULL == Stack.Next)
        return TRUE;
    else
        return FALSE;
}

VOID
MtFreeStack(
    MT_STACK   *Stack
    )
/*++

Routine Description:

    Free the resource in the Stack.

--*/
{
    MT_STACK   *Temp = NULL;
    MT_STACK   *Next = NULL;
    
    MT_TRACE(("\nMtFreeStack\n"));
    
    Next = Stack->Next;
    
    while(NULL != Next)
    {
        if (NULL != Next->NewParent)
        {
            MtFree(Next->NewParent);
        }
        if (NULL != Next->MoveProxyContainer)
        {
            MtFree(Next->MoveProxyContainer);
        }
        if (NULL != Next->Results)
        {
            ldap_msgfree(Next->Results);
        }
        
        Temp = Next->Next;
         
        MtFree(Next);
        
        Next = Temp;
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\movetree\dll\mtldap.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    MTLDAP.C

Abstract:

    This file contains utility routines to finish low level task through LDAP, 
    make connection, bind, create objects, delete objects, 
    search and single object cross domain move. 

Author:

    12-Oct-98 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    12-Oct-98 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Include                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma  hdrstop


#include "movetree.h"


#define MAX_STRING_SIZE         8000


VOID
MtLogMessage(
    FILE  *FileToLog,
    ULONG MessageId, 
    ULONG WinError, 
    PWCHAR Parm1, 
    PWCHAR Parm2, 
    ULONG  Flags
    )
{
    ULONG   Length;
    WCHAR   WinErrCode[20];        // for _ultow
    WCHAR   *WinErrStr = NULL;
    WCHAR   *MessageStr = NULL;
    WCHAR   *ArgArray[5];
    HMODULE ResourceDLL;
    
    MT_TRACE(("\nMtLogMessage\n"));


    _ultow(WinError, WinErrCode, 16);

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                            NULL,    // resource DLL
                            WinError, 
                            0,       // using caller's language
                            (LPWSTR) &WinErrStr, 
                            0, 
                            NULL
                            );

    if ((0 == Length) || (NULL == WinErrStr))
    {
        return;
    }

    // 
    //  Messages from a message file have a cr and lf appended to the end
    // 

    WinErrStr[Length - 2] = L'\0';

    ArgArray[0] = WinErrCode;
    ArgArray[1] = WinErrStr;
    ArgArray[2] = Parm1;
    ArgArray[3] = Parm2;
    ArgArray[4] = NULL;
    
    ResourceDLL = (HMODULE) LoadLibraryW(L"movetree.dll");
   
    if (NULL == ResourceDLL) {
        LocalFree(WinErrStr);
        return;
    }

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            ResourceDLL, 
                            MessageId, 
                            0, 
                            (LPWSTR) &MessageStr, 
                            0,
                            (va_list *) &(ArgArray)
                            );

    if ((0 == Length) || (NULL == MessageStr))
    {
        LocalFree(WinErrStr);
        return;
    }

    FreeLibrary(ResourceDLL);

    MessageStr[Length - 2] = L'\0';
                           
    fwprintf(FileToLog, L"%s", MessageStr);
    fwprintf(FileToLog, L"\n");
    fflush(FileToLog);

    if (Flags & MT_VERBOSE)
    {
        printf("%ls\n\n", MessageStr);
    }

    LocalFree(WinErrStr);
    LocalFree(MessageStr);

    return;
}




ULONG
MtSetupSession(
    PMT_CONTEXT MtContext, 
    LDAP    **SrcLdapHandle, 
    LDAP    **DstLdapHandle, 
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa,
    SEC_WINNT_AUTH_IDENTITY_EXW *Credentials
    )
/*++
Routine Description

    This routine will create two ldap sessions, one with the source DSA
    the second one with the destination DSA
    
    Set the security-delegation flag for the source DSA ldap session. 
    
Parameters: 

    SrcDsa - pointer to the Source DSA name
    DstDsa - pointer to the destination DSA name
    MtContext - pointer to some globally used info.
    
Returne Values: 

    WinError
    
--*/    
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    ULONG   CurrentFlags = 0;
    PWCHAR  ErrorServer = SrcDsa;
    
    MT_TRACE(("\nMtSetupSession srcDsa:%ls, dstDsa:%ls\n", SrcDsa, DstDsa));
    
    *SrcLdapHandle = ldap_openW(SrcDsa, LDAP_PORT);
    
    if (NULL == *SrcLdapHandle)
    {
        Status = LdapGetLastError();
        if (LDAP_SUCCESS == Status)
        {
            WinError = ERROR_BAD_NETPATH;
        }
        else
        {
            WinError = LdapMapErrorToWin32(Status);
        }
        goto Error;
    }
    
    Status = ldap_get_optionW(*SrcLdapHandle,
                              LDAP_OPT_SSPI_FLAGS,
                              &CurrentFlags
                              );
    
    // 
    // Set the security-delegation flag, so that the LDAP client's
    // credentials are used in the inter-DC connection, when moving
    // the object from one DC to another.
    // 
    
    MtGetWinError(*SrcLdapHandle, Status, WinError);

    if (NO_ERROR != WinError)
    {
        goto Error;
    }
    
    CurrentFlags |= ISC_REQ_DELEGATE;
    
    Status = ldap_set_optionW(*SrcLdapHandle, 
                              LDAP_OPT_SSPI_FLAGS,
                              &CurrentFlags
                              );
                             
    MtGetWinError(*SrcLdapHandle, Status, WinError);

    if (NO_ERROR != WinError)
    {
        goto Error;
    }
    

    Status = ldap_bind_sW(*SrcLdapHandle, 
                          NULL,  
                          (VOID *)Credentials,
                          LDAP_AUTH_SSPI
                          );

    if (LDAP_SUCCESS != Status)
    {
        WinError = GetLastError();
        if (NO_ERROR == WinError)
        {
            MtGetWinError(*SrcLdapHandle, Status, WinError);
        }
        goto Error;
    }
                          
    ErrorServer = DstDsa;

    *DstLdapHandle = ldap_openW(DstDsa, LDAP_PORT);
    
    if (NULL == *DstLdapHandle)
    {
        Status = LdapGetLastError();
        if (LDAP_SUCCESS == Status)
        {
            WinError = ERROR_CONNECTION_REFUSED;
        }
        else
        {
            WinError = LdapMapErrorToWin32(Status);
        }
        goto Error;
    }
    
    CurrentFlags = 0;

    Status = ldap_get_optionW(*DstLdapHandle, 
                              LDAP_OPT_REFERRALS,
                              &CurrentFlags
                              );

    CurrentFlags = PtrToUlong(LDAP_OPT_OFF);

    Status = ldap_set_optionW(*DstLdapHandle, 
                              LDAP_OPT_REFERRALS, 
                              &CurrentFlags
                              );

    if (LDAP_SUCCESS != Status)
    {
        goto Error;
    }
    
                          
    Status = ldap_bind_sW(*DstLdapHandle, 
                          NULL,
                          (VOID *)Credentials,
                          LDAP_AUTH_SSPI
                          );

    if (LDAP_SUCCESS != Status)
    {
        WinError = GetLastError();
        if (NO_ERROR == WinError)
        {
            MtGetWinError(*SrcLdapHandle, Status, WinError);
        }
        goto Error;
    }

Error:    

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_SETUP_SESSION, 
                     WinError, 
                     ErrorServer, 
                     NULL
                     );
    }
    
    MtWriteLog(MtContext, 
               MT_INFO_SETUP_SESSION, 
               WinError, 
               NULL,
               NULL
               );   

    return (WinError);    
}



VOID
MtDisconnect( 
    LDAP    **LdapHandle 
    )
/*++
Routine Description: 

    Disconnect the two ldap sessions.    

Parameters: 

    None

Return Values:

    none

--*/
{
    MT_TRACE(("\nMtDisconnect\n"));

    if (NULL == *LdapHandle)
    {
        return;
    }

    ldap_unbind_s(*LdapHandle);
    
    *LdapHandle = NULL;
    
    return;
    
}




ULONG
MtGetLastLdapError(
    VOID
    )
/*++
Routine Description: 

    Get the last ldap error code

Parameters: 

    None

Return Values:

    last ldap error code
--*/
{
    MT_TRACE(("\nMtGetLastLdapError\n"));
    return(LdapGetLastError());
}



ULONG
MtSearchChildren(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    LDAPMessage **Results
    )
/*++
Routine Description:

    This routine searches all one-level children of object (Dn). 
    
Parameters: 

    Dn - pointer to the DN of the base object
    Results - pointer to LDAPMessage. 
    
Return Values: 
    
    Win32 Error Code
    
--*/    
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    PWCHAR  AttrList[4];
    
    MT_TRACE(("\nMtSearchChildren %ls\n", Dn));
    
    *Results = NULL;
    
    AttrList[0] = MT_OBJECTCLASS;
    AttrList[1] = MT_OBJECTGUID;
    AttrList[2] = MT_MOVETREESTATE;
    AttrList[3] = NULL;
    
    Status = ldap_search_ext_sW(LdapHandle,
                                Dn, 
                                LDAP_SCOPE_ONELEVEL,
                                L"(objectClass=*)",
                                &AttrList[0], 
                                0, 
                                NULL,       // server control
                                NULL,       // client control
                                NULL,       // time out
                                MT_SEARCH_LIMIT, 
                                Results
                                ); 
                                
    MtGetWinError(LdapHandle, Status, WinError);

    if (NO_ERROR != Status && LDAP_SIZELIMIT_EXCEEDED != Status)
    {
        ldap_msgfree(*Results);
        *Results = NULL;
    }

    /*
    MtWriteLog(MtContext, 
               MT_INFO_SEARCH_CHILDREN, 
               WinError, 
               Dn, 
               NULL
               );
    */

    return( WinError );
}



PLDAPMessage
MtGetFirstEntry(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle, 
    LDAPMessage *Results 
    )
/*++
Routine Description: 

    Find the first entry from the results entries from ldap_search_ext_s() 
    
Parameter: 
    
    Results - pointer to LDAPMessage, hold all entries.
    
Return Value: 

    first entry
    
--*/
{
    MT_TRACE(("\nMtGetFirstEntry\n"));
    
    return(ldap_first_entry(LdapHandle, Results ));
}



PLDAPMessage
MtGetNextEntry(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle, 
    LDAPMessage *Entry
    )
/*++
Routine Description:

    Find next entry in the entry list
    
Parameter:

    Entry - Pointer to LDAPMessage
    
Return Value:
    
    pointer to next entry
    
--*/
{
    MT_TRACE(("\nMtGetNextEntry\n"));
    
    return(ldap_next_entry(LdapHandle, Entry));
}



ULONG
MtDeleteEntry(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn
    )
/*++
Routine Description: 

    call ldap_delete_s to delete an entry. 

Parameters: 

    Dn - pointer to the DN of the object to be removed.

Return Values:

    Win32 Error code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    
    MT_TRACE(("\nMtDeleteEntry\n"));
    
    Status = ldap_delete_sW(LdapHandle, Dn); 
    
    MtGetWinError(LdapHandle, Status, WinError);


    MtWriteLog(MtContext, 
               MT_INFO_DELETE_ENTRY, 
               WinError, 
               Dn, 
               NULL
               );

    return WinError;
                                
}




PWCHAR
MtGetDnFromEntry(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle,
    LDAPMessage *Entry 
    )
/*++
Routine Description: 

    This routine retrieve the DN from the object. 
    the caller should call MtFree() to release the result
    
Parameters: 

    Entry -- Pointer to the object. 

Return Values:

    Pointer the DN of the object if succeed, NULL otherwise.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    PWCHAR  Temp = NULL;
    PWCHAR  Dn = NULL;
    
    MT_TRACE(("\nMtGetDnFromEntry\n"));
    
    Temp = ldap_get_dnW(LdapHandle, Entry);
    
    if (NULL != Temp)
    {
        Dn = MtAlloc(sizeof(WCHAR) * (wcslen(Temp) + 1));
        
        if (NULL != Dn)
        {   
            wcscpy(Dn, Temp);
        }
        
        ldap_memfreeW(Temp);
    }
    
    return Dn; 
}




ULONG  
MtGetGuidFromDn(
    PMT_CONTEXT MtContext, 
    LDAP    * LdapHandle,
    PWCHAR  Dn,
    PWCHAR  *Guid 
    )
/*++
Routine Description: 

    This routine will read the object and retrieve the objectGUID from 
    the result. The caller should call MtFree() release the memory returned 
    by Guid 

Parameters: 
    
    Dn -- pointer to the DN of the desired object
    Guid -- used to return the result

Return Values:

    Win32 Error Code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR; 
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR  AttrList[2];
    struct berval **ppbvGuid = NULL;
    GUID    *pGuid = NULL;
    PWCHAR  value = NULL;
    
    MT_TRACE(("\nMtGetGuidFromDn Dn %ls\n", Dn));
    
    AttrList[0] = MT_OBJECTGUID;
    AttrList[1] = NULL;
    
    Status = ldap_search_sW(LdapHandle, 
                            Dn, 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)", 
                            &AttrList[0],
                            0, 
                            &Result
                            );
    
    MtGetWinError(LdapHandle, Status, WinError);

    dbprint(("ldap_search_sW ==> 0x%x\n", Status));                            
    

    if (NO_ERROR != WinError)
    {
        goto Error;
    }
    
    if (NULL != Result)
    {
        Entry = ldap_first_entry(LdapHandle, Result);
        
        if (NULL != Entry)
        {
            ppbvGuid = ldap_get_values_lenW(LdapHandle, 
                                            Entry, 
                                            MT_OBJECTGUID
                                            );
            if (NULL != ppbvGuid)
            {
                pGuid = (GUID *) ppbvGuid[0]->bv_val;
                
                if (RPC_S_OK == UuidToStringW(pGuid, &value))
                {
                    *Guid = MtDupString(value);
                    
                    if (NULL == *Guid)
                    {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                    }
                        
                    RpcStringFreeW(&value);                        
                }
                else
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                }
                
                ldap_value_free_len(ppbvGuid);
            }
            else
            {
                WinError = LdapMapErrorToWin32(LdapGetLastError());
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError());
        }
    }
    
Error:
    
    ldap_msgfree(Result);
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_GET_GUID_FROM_DN, 
               WinError, 
               *Guid,
               Dn 
               );
    */

    return (WinError);    
}


ULONG
MtGetDnFromGuid(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Guid, 
    PWCHAR  *Dn
    )
/*++
Routine Description: 
    
    This routine searches the object by its GUID in certain domain, 
    which is indicated by the LdapHandle.

Parameters: 

    LdapHandle -- an ldap session handle.
    Guid -- pointer to the stringlized GUID of the questioned object.
    Dn -- used to returned the object's DN if search succeed.   

Return Values:

    Win32 Error Code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    PWCHAR  GuidBasedDn = NULL;
    PWCHAR  AttrList = NULL;
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    
    MT_TRACE(("\nMtGetDnFromGuid \nGuid:\t%ls\n", Guid));
    
    
    GuidBasedDn = MtAlloc(sizeof(WCHAR) * (wcslen(Guid) + 9));
    
    if (NULL == GuidBasedDn)
    {
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    swprintf(GuidBasedDn, L"<GUID=%s>", Guid);


    Status = ldap_search_sW(LdapHandle,         // passed in ldap session handle
                            GuidBasedDn, 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            &AttrList,
                            0, 
                            &Result
                            );
                            
    dbprint(("ldap_search_sW in MtGetDnFromGuid ==> 0x%x\n", Status));                            

    MtGetWinError(LdapHandle, Status, WinError);
    
    if (NO_ERROR != WinError)
    {
        goto Error;
    }
        
    if (NULL != Result)
    {
        Entry = ldap_first_entry(LdapHandle, Result);
            
        if (NULL != Entry)
        {
            *Dn = MtGetDnFromEntry(MtContext, LdapHandle, Entry);
                
            if (NULL == *Dn)
            {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError());
        }
    }    

Error:

    ldap_msgfree(Result);
    
    MtFree(GuidBasedDn);
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_GET_DN_FROM_GUID, 
               WinError, 
               *Dn, 
               Guid
               );
    */           

    return(WinError);

}


    
ULONG
MtGetNewParentDnFromProxyContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *SrcLdapHandle,
    LDAP    *DstLdapHandle,
    PWCHAR  ProxyContainer, 
    PWCHAR  *NewParentDn
    )
/*++
Routine Description: 

    This routine reads the ProxyContainer's attributes, gets OriginalParentGuid
    value. The value of this attribute keeps the GUID of an object in the other 
    domain which is the original parent for all the children under the 
    ProxyContainer. Then this routine tries to find the DN of that object 
    by its GUID. 
    
    Note: the original parent should exist either in the destination domain
          or the source domain. In destination domain, the parent has been 
          X-moved successfully, even it might have been rename locally in the
          destination domain. In source domain, the original parent must be 
          move to the Orphans Container. If the parent object has been X-moved
          to yet another domain (say a third domain) after it been x-moved to 
          the destination domain, sorry, we can not chased it.
          
          Remember that, when we bind the two ldap sessions, we use standard
          LDAP_PORT, so even the source or destination domains are GC, they 
          will not point us to a third domain. This will ensure us just 
          search inside these two domains - source and destination. 

Parameters: 

    ProxyContainer -- pointer to the DN of the proxy container
    NewParentDn -- used to return the new DN of original parent

Return Values:

    Win32 error code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    struct berval **ppbvMoveTreeState = NULL;
    PWCHAR  AttrList[2];
    PWCHAR  ParentGuid = NULL;
    
    
    MT_TRACE(("\nMtGetNewParentFromProxyContainer \nDn:\t%ls\n", ProxyContainer));
    
    AttrList[0] = MT_MOVETREESTATE;
    AttrList[1] = NULL;
    
    Status = ldap_search_sW(SrcLdapHandle, 
                            ProxyContainer, 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)", 
                            &AttrList[0],
                            0, 
                            &Result
                            );
    
    dbprint(("ldap_search_sW ==> 0x%x\n", Status));                            

    MtGetWinError(SrcLdapHandle, Status, WinError);
    
    if (NO_ERROR != WinError)
    {
        goto Error;
    }
    
    if (NULL != Result)
    {
        Entry = ldap_first_entry(SrcLdapHandle, Result);
        
        if (NULL != Entry)
        {
            // 
            // Get the original parent's GUID from this proxyContainer's
            // attribute -- "moveTreeState"
            // 
            ppbvMoveTreeState = ldap_get_values_lenW(SrcLdapHandle, 
                                                     Entry, 
                                                     MT_MOVETREESTATE 
                                                     );
            if (NULL != ppbvMoveTreeState)
            {
                ULONG   Index = 0;
                ULONG   Count = 0;
                ULONG   Size = 0;

                Count = ldap_count_values_len(ppbvMoveTreeState);

                for (Index = 0; Index < Count; Index++)
                {
                    if ( ppbvMoveTreeState[Index]->bv_len > 
                         sizeof(WCHAR) * wcslen(MOVE_TREE_STATE_GUID_TAG) ) 
                    {
                        if (!_wcsnicmp(MOVE_TREE_STATE_GUID_TAG, 
                                       (LPWSTR)ppbvMoveTreeState[Index]->bv_val, 
                                        wcslen(MOVE_TREE_STATE_GUID_TAG) ) )
                        {
                            Size = ppbvMoveTreeState[Index]->bv_len - 
                                   (wcslen(MOVE_TREE_STATE_GUID_TAG) - 1) * sizeof(WCHAR);

                            ParentGuid = MtAlloc( Size );

                            if (NULL == ParentGuid)
                            {
                                WinError = ERROR_NOT_ENOUGH_MEMORY;
                                goto Error;
                            }

                            MtCopyMemory(ParentGuid, 
                                     ppbvMoveTreeState[Index]->bv_val + 
                                     wcslen(MOVE_TREE_STATE_GUID_TAG) * sizeof(WCHAR), 
                                     Size - sizeof(WCHAR)
                                     );

                            break;
                        }
                    }
                }

                if (NULL == ParentGuid)
                {
                    // no such attribute or value
                    WinError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
                    goto Error;
                }

                //
                // Search the object in the Destination Domain first
                // 
                WinError = MtGetDnFromGuid(MtContext, 
                                           DstLdapHandle,
                                           ParentGuid, 
                                           NewParentDn
                                           );
                                           
                //
                // if not found, search it in the source (local) domain
                // 
                if (ERROR_FILE_NOT_FOUND == WinError ||
                    ERROR_DS_OBJ_NOT_FOUND == WinError)
                {
                    WinError = MtGetDnFromGuid(MtContext,
                                               SrcLdapHandle, 
                                               ParentGuid, 
                                               NewParentDn
                                               );
                }
                
            }
            else
            {
                WinError = LdapMapErrorToWin32(LdapGetLastError()); 
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError()); 
        }
    }
    
Error:
    
    ldap_value_free_len(ppbvMoveTreeState);

    ldap_msgfree(Result);
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_GET_NEW_PARENT_DN, 
               WinError, 
               ProxyContainer, 
               *NewParentDn
               );
    */ 

    return WinError;
}



ULONG
MtGetLostAndFoundDn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  *LostAndFound
    )
/*++
Routine Description: 

    This routine tries to get the root domain's DN first, then search 
    the object of LostAndFound container by its well-known GUID.

Parameters: 

    LostAndFound -- used to return the DN of LostAndFound Container
                    caller is responsible for releasing it by calling
                    MtFree()

Return Values:

    Win32 error code. 0 for success.

--*/
{
    ULONG       Status = LDAP_SUCCESS;
    ULONG       WinError = NO_ERROR;
    LDAPMessage *Result1 = NULL;
    LDAPMessage *Result2 = NULL;
    LDAPMessage *Entry1 = NULL;
    LDAPMessage *Entry2 = NULL;
    PWCHAR      AttrList[2];
    PWCHAR      *DomainName = NULL;
    PWCHAR      SearchBase = NULL;
    
    MT_TRACE(("\nMtGetLostAndFoundDn\n"));
    
    // 
    // Getting the domain name 
    // 
    AttrList[0] = MT_DEFAULTNAMINGCONTEXT;
    AttrList[1] = NULL;
     
    Status = ldap_search_sW(LdapHandle, 
                            L"", 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            &AttrList[0],
                            0, 
                            &Result1
                            );
                            
    MtGetWinError(LdapHandle, Status, WinError);

    if (NO_ERROR != WinError)
    {
        goto Error;
    }
   
    if (NULL != Result1)
    {
        Entry1 = ldap_first_entry(LdapHandle, Result1);
        
        if (NULL != Entry1)
        {
            DomainName = ldap_get_valuesW(LdapHandle, 
                                          Entry1, 
                                          MT_DEFAULTNAMINGCONTEXT 
                                          );
            if (NULL != DomainName)
            {
                dbprint(("Domain Name ==> %ls\n", *DomainName));
                
                SearchBase = MtAlloc(sizeof(WCHAR) * (wcslen(*DomainName) + 
                                                      wcslen(GUID_LOSTANDFOUND_CONTAINER_W) +
                                                      11) );
                
                if (NULL != SearchBase)
                {
                    swprintf(SearchBase, L"<WKGUID=%s,%s>", GUID_LOSTANDFOUND_CONTAINER_W, *DomainName); 
                    
                    dbprint(("SearchBase ==> %ls\n", SearchBase));
                    
                    AttrList[0] = MT_CN;
                    AttrList[1] = NULL;
                    
                    Status = ldap_search_sW(LdapHandle, 
                                            SearchBase, 
                                            LDAP_SCOPE_BASE, 
                                            L"(objectClass=*)", 
                                            &AttrList[0], 
                                            0, 
                                            &Result2
                                            );

                    MtGetWinError(LdapHandle, Status, WinError);
                                            
                    if (LDAP_SUCCESS == Status && NULL!= Result2)
                    {
                        Entry2 = ldap_first_entry(LdapHandle, Result2);
                        
                        if (NULL != Entry2)
                        {
                            *LostAndFound = MtGetDnFromEntry(MtContext, 
                                                             LdapHandle, 
                                                             Entry2);

                            if (NULL == *LostAndFound)
                            {
                                WinError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        else
                        {
                            WinError = LdapMapErrorToWin32(LdapGetLastError());
                        }
                        
                        ldap_msgfree(Result2);
                    }
                    
                    MtFree(SearchBase);
                }
                else
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                }
                ldap_value_freeW(DomainName);
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError());
        }
        ldap_msgfree(Entry1);
    }
    
Error:

    /*
    MtWriteLog(MtContext, 
               MT_INFO_GET_LOSTANDFOUND_DN, 
               WinError, 
               *LostAndFound, 
               NULL
               );
    */            

    return (WinError);
}



ULONG
MtAddEntry(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn
    )
/*++
Routine Description: 

   This routine calls ldap_add_s to add a new object in DS. 
   Since in MoveTree utility, the only object class we used is LostAndFound, 
   so just hard coded in this routine. 

Parameters: 

    Dn -- pointer to the DN of the added object.

Return Values:

    Win32 error code

--*/
{
    ULONG    Status = LDAP_SUCCESS;
    ULONG    WinError = NO_ERROR;
    LDAPModW *attrs[2];
    LDAPModW attr_1;
    PWCHAR   Pointers1[2];
    
    MT_TRACE(("\nMtAddEntry Dn %ls\n", Dn));
    
    attr_1.mod_values = Pointers1;
    
    attrs[0] = &attr_1;
    attrs[1] = NULL;
    
    attrs[0]->mod_op = LDAP_MOD_ADD;
    attrs[0]->mod_type = MT_OBJECTCLASS;
    attrs[0]->mod_values[0] = MT_LOSTANDFOUND_CLASS;
    attrs[0]->mod_values[1] = NULL;
    
    Status = ldap_add_sW(LdapHandle, 
                         Dn, 
                         &attrs[0]
                         ); 
                         
    dbprint(("ldap_add_sW ==> 0x%x\n", Status));                         

    MtGetWinError(LdapHandle, Status, WinError);
    

    /*
    MtWriteLog(MtContext,
               MT_INFO_ADD_ENTRY, 
               WinError, 
               Dn, 
               NULL
               );
    */
               
    return (WinError);               
}


ULONG
MtAddEntryWithAttrs(
    PMT_CONTEXT MtContext, 
    LDAP     *LdapHandle,
    PWCHAR   Dn,
    LDAPModW *Attributes[]
    )
/*++
Routine Description: 

    This routine will create an objec with attributes specified by 
    caller.

Parameters: 
    
    Dn -- pointer to the object DN
    Attributes -- caller specified attributes

Return Values:

    Win32 error code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    
    MT_TRACE(("\nMtAddEntryWithAttrs \nDn:\t%ls\n", Dn));

    Status = ldap_add_sW(LdapHandle, 
                         Dn, 
                         Attributes 
                         );
                         
    dbprint(("ldap_add_sW ==> 0x%x\n", Status));

    MtGetWinError(LdapHandle, Status, WinError);
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_ADD_ENTRY, 
               WinError,
               Dn, 
               NULL
               );
    */           

    return (WinError);              
                         
}
    
    
ULONG
MtXMoveObject(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  DstDsa,   
    PWCHAR  Dn,  
    PWCHAR  NewRdn,         // should come with type info
    PWCHAR  NewParent, 
    ULONG   Flags
    )
/*++
Routine Description: 

    This routine calls ldap_rename_ext_s to move a single object  
    to another domain. Note, need to use extended support.

Parameters: 

    DstDsa -- pointer to the Destination Domain DSA
    Dn -- pointer to the object to be moved.
    NewRdn -- new RDN after the rename.
    NewParent -- new Parent DN
    Flags -- Flags control the behavior of this function
        DeletedOldRdn -- TRUE will delete the old object

Return Values:

    Win32 error code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   IgnoreStatus = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    PWCHAR  ExtendedError = NULL;
    PCHAR   pDstDsa = NULL;
    LDAPControlW ServerControl;
    LDAPControlW *ServerControls[2];   
    LDAPControlW *ClientControls = NULL; 
    LDAP_BERVAL Value;
    INT     DeleteOldRdn = (Flags & MT_DELETE_OLD_RDN); 
    
    MT_TRACE(("\nMtXMoveObject \nDstDsa:\t%ls \nDn:\t%ls \nNewRdn:\t%ls \nNewParent:\t%ls\n", 
             DstDsa, Dn, NewRdn, NewParent));
             
             
    pDstDsa = WideStringToString(DstDsa);
    if (!pDstDsa || (Flags & MT_XMOVE_CHECK_ONLY))
    {
        Value.bv_val = NULL;
        Value.bv_len = 0;
    }
    else
    {
        Value.bv_val = (PCHAR) pDstDsa;
        Value.bv_len = strlen(pDstDsa);
    }


    // Value.bv_val = (PCHAR) pDstDsa, 
    
    ServerControl.ldctl_oid = LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W;
    ServerControl.ldctl_value = Value;
    ServerControl.ldctl_iscritical = TRUE;
    
    ServerControls[0] = &ServerControl;
    ServerControls[1] = NULL;
    
    Status = ldap_rename_ext_sW(LdapHandle, 
                                Dn, 
                                NewRdn, 
                                NewParent, 
                                DeleteOldRdn,
                                ServerControls, 
                                &ClientControls
                                );
                                
    dbprint(("ldap_rename_ext_sw in MtXMoveObject ==> 0x%x\n", Status));
    
    MtGetWinError(LdapHandle, Status, WinError);

    if (NO_ERROR != WinError && ERROR_DS_CHILDREN_EXIST != WinError) 
    {
        IgnoreStatus = ldap_get_optionW(LdapHandle,
                                        LDAP_OPT_SERVER_ERROR,
                                        (void *)&ExtendedError
                                        );
                                            
        if ((LDAP_SUCCESS == IgnoreStatus) && (NULL != ExtendedError))
        {
            MtWriteError(MtContext, 
                         MT_ERROR_CROSS_DOMAIN_MOVE_EXTENDED_ERROR,
                         WinError,
                         ExtendedError,
                         NULL
                         );

        }
    }

    
    MtFree(pDstDsa);
    
    if (!(Flags & MT_XMOVE_CHECK_ONLY))
    {
        MtWriteLog(MtContext, 
                   MT_INFO_CROSS_DOMAIN_MOVE, 
                   WinError, 
                   Dn, 
                   NewParent
                   );
    }
    
    return WinError;
}


ULONG
MtXMoveObjectWithOrgRdn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  DstDsa, 
    PWCHAR  Dn, 
    PWCHAR  NewParent, 
    ULONG   Flags
    )
/*++
Routine Description: 

    same as above. The only different is that this routine will use the 
    original RDN as the new RDN

Parameters: 

    same as above.

Return Values:

    Win32 error code.
--*/
{
    ULONG   WinError = NO_ERROR;
    PWCHAR  NewRdn = NULL;
    
    MT_TRACE(("\nMtXMoveObjectWithOrgRdn DstDsa:%ls Dn:%ls NewParent:%ls\n", 
             DstDsa, Dn, NewParent));
    
    NewRdn = MtGetRdnFromDn(Dn, FALSE); // with Types,
    
    if (NULL == NewRdn)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    WinError = MtXMoveObject(MtContext, 
                             LdapHandle, 
                             DstDsa, 
                             Dn, 
                             NewRdn, 
                             NewParent, 
                             Flags
                             );
    
    MtFree(NewRdn);
    
    return WinError;
}


     
ULONG
MtXMoveObjectCheck(
    PMT_CONTEXT MtContext, 
    LDAP * SrcLdapHandle, 
    LDAP * DstLdapHandle, 
    PWCHAR  DstDsa, 
    PWCHAR  DstDn, 
    LDAPMessage * Entry,
    PWCHAR  SamAccountName 
    )
{
    ULONG   WinError = NO_ERROR;
    ULONG   Status = LDAP_SUCCESS;
    PWCHAR  Dn = NULL;
    PWCHAR  DstRdn = NULL;
    PWCHAR  DstParent = NULL;
    PWCHAR  * GPLink = NULL;


    MT_TRACE(("MtXMoveObjectCheck\n"));

    //
    // First, try the check only MtXMoveObject, 
    // do all the check on the Source Domain Side
    // 
    // 

    Dn = MtGetDnFromEntry(MtContext, SrcLdapHandle, Entry);
    DstRdn = MtGetRdnFromDn(DstDn, FALSE);     // With Type
    DstParent =  MtGetParentFromDn(DstDn, FALSE); // with type

    if (!Dn || !DstRdn || !DstParent)
    {
        MtFree(Dn);
        MtFree(DstRdn);
        MtFree(DstParent);
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    WinError = MtXMoveObject(MtContext,
                             SrcLdapHandle,
                             DstDsa,// MT_EMPTY_STRING,
                             Dn, 
                             DstRdn, 
                             DstParent, 
                             MT_XMOVE_CHECK_ONLY | MT_DELETE_OLD_RDN
                             );

    //
    // Log The Result into the Check File
    // 
    MtWriteCheck(MtContext,
                 MT_CHECK_CROSS_DOMAIN_MOVE,
                 WinError, 
                 Dn, 
                 NULL
                 );

    //
    // Write it into Error Log File if Error
    // 

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_CROSS_DOMAIN_MOVE_CHECK,
                     WinError, 
                     Dn, 
                     NULL
                     );

        if (ERROR_DS_BUSY != WinError)
        {
            WinError = NO_ERROR;
        }
    }

    //
    // Second, check the duplicate Sam Account Name
    // if the SamAccountName is passed in
    //  

    if ((NO_ERROR == WinError) && (NULL != SamAccountName))
    {
        WinError = MtCheckDupSamAccountName(MtContext,
                                            DstLdapHandle, 
                                            SamAccountName
                                            );

        //
        // Log the Result into Check File
        // 

        MtWriteCheck(MtContext, 
                     MT_CHECK_SAM_ACCOUNT_NAME,
                     WinError, 
                     Dn, 
                     NULL
                     );

        //
        // Write it into Error Log File if Error
        //

        if (NO_ERROR != WinError)
        {
            MtWriteError(MtContext, 
                         MT_ERROR_DUP_SAM_ACCOUNT_NAME,
                         WinError,
                         Dn, 
                         DstDsa 
                         );

            WinError = NO_ERROR;
        }
    }

    if (NO_ERROR == WinError)
    {
        GPLink = ldap_get_valuesW(SrcLdapHandle, 
                                  Entry, 
                                  MT_GPLINK
                                  );

        if (NULL != GPLink)
        {
            MtWriteCheck(MtContext,
                         MT_WARNING_GPLINK,
                         NO_ERROR,
                         Dn,
                         NULL
                         );
        }

        ldap_value_freeW(GPLink);
    }

    return WinError;
}


ULONG
MtCheckDupSamAccountName(
    PMT_CONTEXT MtContext, 
    LDAP    * LdapHandle, 
    PWCHAR  SamAccountName
    )
{
    ULONG       Status = LDAP_SUCCESS;
    ULONG       WinError = NO_ERROR;
    LDAPMessage *Result1 = NULL;
    LDAPMessage *Result2 = NULL;
    LDAPMessage *Entry1 = NULL;
    LDAPMessage *Entry2 = NULL;
    PWCHAR      AttrList[2];
    PWCHAR      *DomainName = NULL;
    PWCHAR      SearchFilter = NULL;
    
    MT_TRACE(("\nMtCheckDupSamAccountName\n"));
    
    // 
    // Getting the domain name 
    // 
    AttrList[0] = MT_DEFAULTNAMINGCONTEXT;
    AttrList[1] = NULL;
     
    Status = ldap_search_sW(LdapHandle, 
                            L"", 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            &AttrList[0],
                            0, 
                            &Result1
                            );
                            
    MtGetWinError(LdapHandle, Status, WinError);

    if (NO_ERROR != WinError)
    {
        goto Error;
    }
   
    if (NULL != Result1)
    {
        Entry1 = ldap_first_entry(LdapHandle, Result1);
        
        if (NULL != Entry1)
        {
            DomainName = ldap_get_valuesW(LdapHandle, 
                                          Entry1, 
                                          MT_DEFAULTNAMINGCONTEXT 
                                          );
            if (NULL != DomainName)
            {
                SearchFilter = MtAlloc(sizeof(WCHAR) * (wcslen(MT_SAMACCOUNTNAME) + 
                                                        wcslen(SamAccountName) +
                                                        4 ) );
                
                if (NULL != SearchFilter)
                {
                    swprintf(SearchFilter, L"(%s=%s)", 
                             MT_SAMACCOUNTNAME, SamAccountName ); 
                    
                    AttrList[0] = NULL;

                    Status = ldap_search_sW(LdapHandle, 
                                            *DomainName,
                                            LDAP_SCOPE_SUBTREE, 
                                            SearchFilter,
                                            &AttrList[0], 
                                            0, 
                                            &Result2
                                            );

                    MtGetWinError(LdapHandle, Status, WinError);
                                            
                    if (LDAP_SUCCESS == Status && NULL!= Result2)
                    {
                        Entry2 = ldap_first_entry(LdapHandle, Result2);
                        
                        if (NULL != Entry2)
                        {
                            WinError = ERROR_USER_EXISTS;
                        }
                        ldap_msgfree(Result2);
                    }
                    
                    MtFree(SearchFilter);
                }
                else
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                }
                ldap_value_freeW(DomainName);
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError());
        }
        ldap_msgfree(Entry1);
    }
    
Error:

    /*
    MtWriteLog(MtContext, 
               MT_INFO_GET_LOSTANDFOUND_DN, 
               WinError, 
               SamAccountName, 
               NULL
               );
    */           

    return (WinError);

}


ULONG
MtCheckRdnConflict(
    PMT_CONTEXT MtContext, 
    LDAP * LdapHandle, 
    PWCHAR SrcDn,
    PWCHAR DstDn
    )
{
    ULONG   WinError = NO_ERROR;
    ULONG   Status = LDAP_SUCCESS;
    LDAPMessage * Result = NULL;
    LDAPMessage * Entry = NULL;
    PWCHAR      AttrList[1];
    

    MT_TRACE(("MtCheckRdnConflict\n"));


    AttrList[0] = NULL;

    Status = ldap_search_sW(LdapHandle, 
                            DstDn, 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            &AttrList[0],
                            0, 
                            &Result
                            );

    MtGetWinError(LdapHandle, Status, WinError);

    if ( (NO_ERROR == WinError) && (NULL != Result) )
    { 
        WinError = ERROR_DS_DRA_NAME_COLLISION;
    }
    else if (ERROR_DS_OBJ_NOT_FOUND == WinError)
    {
        WinError = NO_ERROR;
    }

    MtWriteCheck(MtContext, 
                 MT_CHECK_RDN_CONFLICT,
                 WinError, 
                 SrcDn, 
                 NULL
                 );

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_RDN_CONFLICT,
                     WinError, 
                     DstDn, 
                     NULL
                     );

        WinError = NO_ERROR;
    }

    ldap_msgfree(Result);

    return WinError;
}


ULONG
MtCheckDstDomainMode(
    PMT_CONTEXT MtContext, 
    LDAP * LdapHandle
    )
/*++

--*/
{
    ULONG       Status = LDAP_SUCCESS;
    ULONG       WinError = NO_ERROR;
    LDAPMessage *Result1 = NULL;
    LDAPMessage *Result2 = NULL;
    LDAPMessage *Entry1 = NULL;
    LDAPMessage *Entry2 = NULL;
    PWCHAR      AttrList[2];
    PWCHAR      *DomainName = NULL;
    
    MT_TRACE(("\nMtCheckDstDomainMode\n"));
    
    // 
    // Getting the domain name 
    // 
    AttrList[0] = MT_DEFAULTNAMINGCONTEXT;
    AttrList[1] = NULL;
     
    Status = ldap_search_sW(LdapHandle, 
                            L"", 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            &AttrList[0],
                            0, 
                            &Result1
                            );
                            
    MtGetWinError(LdapHandle, Status, WinError);

    if (NO_ERROR != WinError)
    {
        goto Error;
    }
   
    if (NULL != Result1)
    {
        Entry1 = ldap_first_entry(LdapHandle, Result1);
        
        if (NULL != Entry1)
        {
            DomainName = ldap_get_valuesW(LdapHandle, 
                                          Entry1, 
                                          MT_DEFAULTNAMINGCONTEXT 
                                          );
            if (NULL != DomainName)
            {
                AttrList[0] = MT_NTMIXEDDOMAIN;

                Status = ldap_search_sW(LdapHandle, 
                                        *DomainName,
                                        LDAP_SCOPE_BASE, 
                                        L"(objectClass=*)",
                                        &AttrList[0], 
                                        0, 
                                        &Result2
                                        );

                MtGetWinError(LdapHandle, Status, WinError);

                if (LDAP_NO_SUCH_ATTRIBUTE == Status)
                {
                    WinError = NO_ERROR;
                }
                else if (LDAP_SUCCESS == Status)
                {
                    if (NULL != Result2)
                    {
                        Entry2 = ldap_first_entry(LdapHandle, Result2);
                        
                        if (NULL != Entry2)
                        {
                            PLDAP_BERVAL    *nTMixedDomain = NULL;
                            LONG            asciiValue = 0;
                            LONG            value = 0;

                            nTMixedDomain = ldap_get_values_lenW(LdapHandle, 
                                                                 Entry2, 
                                                                 MT_NTMIXEDDOMAIN
                                                                 );
                            if (NULL != nTMixedDomain)
                            {
                                memcpy((PUCHAR)&asciiValue, (*nTMixedDomain)->bv_val, (*nTMixedDomain)->bv_len);
                                value = atoi((PUCHAR)&asciiValue);
                                if (TRUE == (BOOLEAN)value)
                                {
                                    WinError = ERROR_DS_DST_DOMAIN_NOT_NATIVE; 
                                }
                                ldap_value_free_len(nTMixedDomain);
                            }
                        }
                        else
                        {
                            WinError = LdapMapErrorToWin32(LdapGetLastError());
                        }
                        ldap_msgfree(Result2);
                    }
                    else
                    {
                        WinError = LdapMapErrorToWin32(LdapGetLastError());
                    }
                }
                ldap_value_freeW(DomainName);
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError());
        }
        ldap_msgfree(Entry1);
    }
    
Error:

    if (NO_ERROR != WinError)
    {
        MtWriteError(MtContext, 
                     MT_ERROR_DST_DOMAIN_NOT_NATIVE,
                     WinError, 
                     NULL,
                     NULL
                     );
    }

    return (WinError);
}





ULONG
MtMoveObject(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    PWCHAR  NewRdn, 
    PWCHAR  NewParent,
    INT     DeleteOldRdn
    )
/*++
Routine Description: 

    This routine will rename a object's DN locally.

Parameters: 

    Dn -- pointer to the DN of the object.
    NewRdn -- pointer the new RDN 
    NewParent -- new parent'd DN
    DeleteOldRnd -- TRUE will delete the old object.

Return Values:

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    LDAPControlW  *ServerControls = NULL;
    LDAPControlW  *ClientControls = NULL;
    
    MT_TRACE(("\nMtMoveObject Dn:%ls NewRdn:%ls NewParent:%ls\n", 
             Dn, NewRdn, NewParent));
    
    Status = ldap_rename_ext_sW(LdapHandle, 
                                Dn, 
                                NewRdn, 
                                NewParent, 
                                DeleteOldRdn, 
                                &ServerControls,
                                &ClientControls 
                                );    
                                
    dbprint(("ldap_rename_ext_sW ==> 0x%x\n", Status));                                
    
    MtGetWinError(LdapHandle, Status, WinError);
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_LOCAL_MOVE, 
               WinError, 
               Dn, 
               NewParent
               );
    */ 

    return (WinError);               
}




ULONG
MtMoveObjectWithOrgRdn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    PWCHAR  NewParent, 
    INT     DeleteOldRdn
    )
/*++
Routine Description: 

    Same as above, except using the original RDN as the new RDN

Parameters: 

    Samse as above

Return Values:

    Win32 error code.

--*/
{
    ULONG   WinError = NO_ERROR;
    PWCHAR  NewRdn = NULL;
    
    MT_TRACE(("\nMtMoveObjectWithOrgRdn Dn:%ls NewParent%ls\n", 
             Dn, NewParent));
    
    NewRdn = MtGetRdnFromDn(Dn, FALSE);    // with Types     
    
    if (NULL == NewRdn)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    WinError = MtMoveObject(MtContext, 
                            LdapHandle, 
                            Dn, 
                            NewRdn, 
                            NewParent, 
                            DeleteOldRdn
                            );
    
    MtFree(NewRdn);
    
    return WinError;
}




ULONG
MtCreateProxyContainerDn(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  Dn, 
    PWCHAR  Guid,
    PWCHAR  *ProxyContainer
    )
/*++
Routine Description: 

    This routine creates the proxy container's DN for a parent object. 
    The RDN of the proxy container would be CN=GUID of the parent object, 
    The proxy container and the parent object are under the same container.
    
Parameters: 

    Dn -- pointer to the parent object
    Guid -- the parent object's GUID, (optional)
    ProxyContainer -- used to return the ProxyContainer's DN
                      no actually creation work.

Return Values:
    
    Win32 error code.

--*/
{
    ULONG   WinError = NO_ERROR;
    PWCHAR  Parent = NULL;
    PWCHAR  pGuid = NULL;
    BOOLEAN fGuidPassedIn = TRUE;
    
    MT_TRACE(("\nMtGetProxyContainerDn \nCurrentDn:\t%ls \nGuid:\t%ls\n", 
             Dn, Guid));
             
    if (NULL == Guid)
    {
        WinError = MtGetGuidFromDn(MtContext, 
                                   LdapHandle, 
                                   Dn, 
                                   &pGuid);
        
        if (NO_ERROR != WinError)
        {
            return WinError;
        }
        
        fGuidPassedIn = FALSE;
    }
    else
    {
        pGuid = Guid;
    }
    
    dbprint(("Guid for MoveProxyContainer is: %ls\n", pGuid));
    
    Parent = MtGetParentFromDn(Dn, FALSE); 
    
    if (NULL == Parent)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    *ProxyContainer = MtAlloc(sizeof(WCHAR) * (wcslen(pGuid) + wcslen(Parent) + 5));
    
    if (NULL == *ProxyContainer)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    
    swprintf(*ProxyContainer, L"cn=%s,%s", pGuid, Parent);

    dbprint(("ProxyContain is ==> %ls\n", *ProxyContainer));

Error:

    if (!fGuidPassedIn)
    {
        MtFree(pGuid);
    }
    
    MtFree(Parent);
    
    if (NO_ERROR != WinError)
    {
        MtFree(*ProxyContainer);
        *ProxyContainer = NULL;
    }
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_CREATE_PROXY_CONTAINER_DN, 
               WinError, 
               *ProxyContainer, 
               Dn
               ); 
    */           
    
    return WinError;
}



    
ULONG
MtCreateProxyContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle,
    PWCHAR  Dn, 
    PWCHAR  Guid,
    PWCHAR  *ProxyContainer
    )
/*++
Routine Description: 

    First this routine will try to create the proxycontainer's DN 
    accorinding to our rule (list in above routine). Then creates the 
    object with specified attributes.
    

Parameters: 

    Dn -- pointer to the parent object's DN
    Guid -- pointer to the guid of the parent object (optional)
    ProxyContainer -- used to return the newly created ProxyContainer'd DN

Return Values:

    win32 error code

--*/
{
    ULONG   WinError = NO_ERROR;
    ULONG   MoveTreeStateVersion = MOVE_TREE_STATE_VERSION;
    LDAPModW *Attrs[3];
    LDAPModW attr_1;
    LDAPModW attr_2;
    PWCHAR  Pointers1[2];
    PLDAP_BERVAL BValues[4];
    LDAP_BERVAL bValue_1;
    LDAP_BERVAL bValue_2;
    LDAP_BERVAL bValue_3;
    PWCHAR  pGuid = NULL;
    PWCHAR  pGuidValue = NULL;
    BOOLEAN fGuidPassedIn = TRUE;
    
    MT_TRACE(("\nMtCreateProxyContainer \nDn:\t%ls \nGUID:\t%ls\n", Dn, Guid));
    
    if (NULL == Guid)
    {
        WinError = MtGetGuidFromDn(MtContext, 
                                   LdapHandle, 
                                   Dn, 
                                   &pGuid);
        
        if (NO_ERROR != WinError)
        {
            return WinError;
        }
        
        fGuidPassedIn = FALSE;
    }
    else
    {   
        pGuid = Guid;
    }
    
    WinError = MtCreateProxyContainerDn(MtContext, 
                                        LdapHandle,
                                        Dn, 
                                        pGuid, 
                                        ProxyContainer); 
    
    if ((NO_ERROR != WinError) || (NULL == *ProxyContainer))
    {
        goto Error;
    }

    pGuidValue = MtAlloc(sizeof(WCHAR) * (wcslen(pGuid) +
                                          wcslen(MOVE_TREE_STATE_GUID_TAG) +
                                          1));

    if (NULL == pGuidValue)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    swprintf(pGuidValue, L"%s%s", MOVE_TREE_STATE_GUID_TAG, pGuid);
    
    BValues[0] = &bValue_1;
    BValues[1] = &bValue_2;
    BValues[2] = &bValue_3;
    BValues[3] = NULL;
    
    attr_1.mod_values = Pointers1;
    attr_2.mod_bvalues = BValues;
    
    Attrs[0] = &attr_1;
    Attrs[1] = &attr_2;
    Attrs[2] = NULL;
    
    Attrs[0]->mod_op = LDAP_MOD_ADD;
    Attrs[0]->mod_type = MT_OBJECTCLASS;
    Attrs[0]->mod_values[0] = MT_LOSTANDFOUND_CLASS;
    Attrs[0]->mod_values[1] = NULL;
    
    Attrs[1]->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    Attrs[1]->mod_type = MT_MOVETREESTATE;
    Attrs[1]->mod_bvalues[0]->bv_len = sizeof(MoveTreeStateVersion);
    Attrs[1]->mod_bvalues[0]->bv_val = (PCHAR) &MoveTreeStateVersion;
    Attrs[1]->mod_bvalues[1]->bv_len = sizeof(WCHAR) * wcslen(MOVE_TREE_STATE_PROXYCONTAINER_TAG);
    Attrs[1]->mod_bvalues[1]->bv_val = (PCHAR) MOVE_TREE_STATE_PROXYCONTAINER_TAG;
    Attrs[1]->mod_bvalues[2]->bv_len = sizeof(WCHAR) * wcslen(pGuidValue);
    Attrs[1]->mod_bvalues[2]->bv_val = (PCHAR) pGuidValue;
    
    WinError = MtAddEntryWithAttrs(MtContext, 
                                   LdapHandle,
                                   *ProxyContainer, 
                                   Attrs
                                   );
                                   
Error:

    if (!fGuidPassedIn)
    {
        MtFree(pGuid);
    }

    MtFree(pGuidValue);

    MtWriteLog(MtContext, 
               MT_INFO_CREATE_PROXY_CONTAINER, 
               WinError, 
               *ProxyContainer, 
               Dn
               ); 
    
    if (NO_ERROR != WinError)
    {
        MtFree(*ProxyContainer);
        *ProxyContainer = NULL;    
    }
    
    return (WinError);    
}



ULONG
MtIsProxyContainer(
    PMT_CONTEXT MtContext, 
    LDAP        *LdapHandle, 
    LDAPMessage *Entry, 
    BOOLEAN *fIsProxyContainer
    )
/*++
Routine Description: 

    This routine examines whether the object is a proxycontainer or not. 
    ProxyContainer should satisfy the following criteria:
        objecClass --- LostAndFound
        has value of originalParentObject 

Parameters: 

    Entry -- Pointer to questionable object
    fIsProxyContainer -- used to return the result
                         TRUE - yes, it is a ProxyContainer
                         FALSE - no.

Return Values:

    Win32 Error code

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    PWCHAR  Value = NULL;    
    struct berval **ppValue = NULL;
    ULONG   Count = 0;
    
    MT_TRACE(("\nMtIsProxyContainer\n"));
   
    ppValue = ldap_get_values_lenW(LdapHandle, 
                                   Entry, 
                                   MT_OBJECTCLASS
                                   );
                                   
    if (NULL != ppValue)
    {
        Count = ldap_count_values_len(ppValue);
        
        Value = StringToWideString(ppValue[Count - 1]->bv_val); 

        if (NULL == Value)
        {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }
        
        if ( !_wcsnicmp(Value, MT_LOSTANDFOUND_CLASS, wcslen(Value)) )
        {
            *fIsProxyContainer = TRUE;
        }
        else 
        {
            *fIsProxyContainer = FALSE;
        }
        
        ldap_value_free_len(ppValue);
    }
    else 
    {
        WinError = LdapMapErrorToWin32(LdapGetLastError());
    }
    
    dbprint(("MtIsProxyContainer Status ==> 0x%x Results: %d\n", Status, *fIsProxyContainer));
    
    /*
    MtWriteLog(MtContext, 
               MT_INFO_IS_PROXY_CONTAINER, 
               WinError, 
               NULL,
               NULL
               );
    */
               
    return (WinError);                
}


ULONG   
MtObjectExist(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  Dn, 
    BOOLEAN *fExist
    )
/*++
Routine Description: 

    Checks whether the object exists in the source domain or not.

Parameters: 

    Dn -- pointer to the DN of the questionable object.
    fExist -- used to return result. TRUE -- exist

Return Values:

    Win32 error code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    PWCHAR  AttrList = NULL;
    LDAPMessage *Result = NULL;
    
    MT_TRACE(("\nMtObjectExist %ls\n", Dn));
    
    Status = ldap_search_sW(LdapHandle, 
                            Dn, 
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            &AttrList, 
                            0, 
                            &Result
                            ); 
                            
    dbprint(("ldap_search_sW in MtObjectExist ==> 0x%x\n", Status));                            

    if (LDAP_SUCCESS == Status)
    {
        *fExist = TRUE;
    }
    else if (LDAP_NO_SUCH_OBJECT == Status)
    {
        Status = LDAP_SUCCESS;
        *fExist = FALSE;
    }

    MtGetWinError(LdapHandle, Status, WinError);
    

    /*
    MtWriteLog(MtContext, 
               MT_INFO_OBJECT_EXIST, 
               WinError, 
               Dn, 
               NULL
               );
    */           

    return WinError;               
}



ULONG
MtHavingChild(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  Dn, 
    BOOLEAN *HavingChild
    )
/*++
Routine Description: 

    Checks whether the object has children or not.

Parameters:
    
    Dn -- pointer to the DN of questionable object
    HavingChild -- used to return result. TRUE -- yes, has at least one child.

Return Values:

    Win32 Error

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   WinError = NO_ERROR;
    PWCHAR  AttrList = NULL;
    LDAPMessage *Results = NULL;
    LDAPMessage *Entry = NULL;
    
    MT_TRACE(("\nMtHavingChild Dn:%ls\n", Dn));
    
    *HavingChild = FALSE;
    
    Status = ldap_search_ext_sW(LdapHandle, 
                                Dn, 
                                LDAP_SCOPE_ONELEVEL,
                                L"(objectClass=*)", 
                                &AttrList, 
                                0, 
                                NULL,       // serverl control
                                NULL,       // client control
                                NULL,       // time out
                                MT_SEARCH_LIMIT,
                                &Results
                                );

    MtGetWinError(LdapHandle, Status, WinError);
                                
    if (NULL != Results && LDAP_SUCCESS == Status)
    {
        Entry = ldap_first_entry(LdapHandle, Results);
           
        if (NULL != Entry)
        {
            *HavingChild = TRUE;
        }
    }
        
    ldap_msgfree(Results);
    
    dbprint(("MtHavingChild %x\n", *HavingChild));
    
    return (WinError);
}
    

ULONG
MtMoveChildrenToAnotherContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  Dn, 
    PWCHAR  DstContainer
    )
/*++
Routine Description: 

    This routine moves all children under the source container to the 
    destinatio container

Parameters: 

    Dn -- pointer to the DN of the source container.
    DstContainer -- pointer to the DN of the destination container.

Return Values:

    Win32 error code.

--*/
{
    ULONG   Status = LDAP_SUCCESS;
    ULONG   MoveError = NO_ERROR;
    ULONG   WinError = NO_ERROR;
    PWCHAR  ChildDn = NULL;
    PWCHAR  AttrList = NULL ;
    LDAPMessage *Results = NULL;
    LDAPMessage *Entry = NULL; 
    
    MT_TRACE(("\nMtMoveChildrenToAnotherContainer \nSrcDn:\t%ls \nDstContainer:\t%ls\n", 
            Dn, DstContainer));
    
    
    do
    {
        Status = ldap_search_ext_sW(LdapHandle, 
                                    Dn, 
                                    LDAP_SCOPE_ONELEVEL,    
                                    L"(objectClass=*)",
                                    &AttrList, 
                                    0, 
                                    NULL,       // server control
                                    NULL,       // client control 
                                    NULL,       // time out
                                    MT_SEARCH_LIMIT,
                                    &Results
                                    ); 
                                    
        dbprint(("ldap_search_ext_sW in MoveChildren==> 0x%x\n", Status));                                    

        MtGetWinError(LdapHandle, Status, WinError);
        
        if (LDAP_SUCCESS != Status && LDAP_SIZELIMIT_EXCEEDED != Status)
        {
            goto Error;
        }
        
        if (NULL != Results)
        {
            Entry = ldap_first_entry(LdapHandle, Results);
        
            while (NULL != Entry)
            {
                ChildDn = ldap_get_dnW(LdapHandle, Entry);
            
                if (NULL != ChildDn)
                {
                    MoveError = MtMoveObjectWithOrgRdn(MtContext, 
                                                       LdapHandle, 
                                                       ChildDn, 
                                                       DstContainer, 
                                                       TRUE);  // Delete old Rdn
                     
                    if (NO_ERROR != MoveError && 
                        ERROR_DS_NO_SUCH_OBJECT != MoveError)
                    {
                        // if error, bailout.
                        WinError = MoveError;
                        goto Error;
                    }

                    ldap_memfreeW(ChildDn);
                    ChildDn = NULL;
                }
                else
                {
                    WinError = LdapMapErrorToWin32(LdapGetLastError());
                    goto Error;
                }
            
                Entry = ldap_next_entry(LdapHandle, Entry);
            }
        
            ldap_msgfree(Results);
            Results = NULL;
        }
                                    
    } while (LDAP_SIZELIMIT_EXCEEDED == Status);
    
Error:    

    if (NULL != ChildDn)
    {
        ldap_memfreeW(ChildDn);
    }
    
    if (NULL != Results)
    {
        ldap_msgfree(Results);
    }
    

    
    MtWriteLog(MtContext,   
               MT_INFO_MOVE_CHILDREN_TO_ANOTHER_CONTAINER, 
               WinError, 
               Dn, 
               DstContainer
               );
   
    
    return (WinError);
}



ULONG
MtCreateMoveContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa
    )
/*++
Routine Description: 

    This routine will create the Move Container, which is an object of class 
    of LostAndFound with moveTreeState attribute. The attribute is a binary
    blob including the following information: Move Tree Version Number, Move 
    Container Tag to distinguish Move Proxy object and Move Container object, 
    Source Domain DSA name and Destination Domaon DSA name. 
    
Parameters:

    MtContext - pointer to the context information
    LdapHandle - used to do ldap call, add entry
    SrcDsa - Source Domain DSA name 
    DstDsa - Destination Domain DSA name. 
    
Return Value: 

    Win Error Code

--*/    

{
    ULONG   WinError = NO_ERROR;
    ULONG   MoveTreeStateVersion = MOVE_TREE_STATE_VERSION;
    LDAPModW *Attrs[3];
    LDAPModW attr_1;
    LDAPModW attr_2;
    PWCHAR  Pointers1[2];
    PLDAP_BERVAL BValues[5];
    LDAP_BERVAL bValue_1;
    LDAP_BERVAL bValue_2;
    LDAP_BERVAL bValue_3;
    LDAP_BERVAL bValue_4;
    PWCHAR  SrcDsaValue = NULL;
    PWCHAR  DstDsaValue = NULL;
     
     
    MT_TRACE(("\nMtCreateMoveContainer\n"));
    
    BValues[0] = &bValue_1;
    BValues[1] = &bValue_2;
    BValues[2] = &bValue_3;
    BValues[3] = &bValue_4;
    BValues[4] = NULL;
    
    attr_1.mod_values = Pointers1;
    attr_2.mod_bvalues = BValues;
    
    Attrs[0] = &attr_1;
    Attrs[1] = &attr_2;
    Attrs[2] = NULL;
    
    //
    // attribute 1: object class
    // 
    
    Attrs[0]->mod_op = LDAP_MOD_ADD;
    Attrs[0]->mod_type = MT_OBJECTCLASS;
    Attrs[0]->mod_values[0] = MT_LOSTANDFOUND_CLASS;
    Attrs[0]->mod_values[1] = NULL;
    
    // 
    // attribute 2: move tree state 
    // 

    SrcDsaValue = MtAlloc(sizeof(WCHAR) * (wcslen(SrcDsa) + 
                                           wcslen(MOVE_TREE_STATE_SRCDSA_TAG) + 
                                           1));

    if (NULL == SrcDsaValue)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        return WinError;
    }

    DstDsaValue = MtAlloc(sizeof(WCHAR) * (wcslen(DstDsa) +
                                           wcslen(MOVE_TREE_STATE_DSTDSA_TAG) +
                                           1));
    if (NULL == DstDsaValue)
    {
        MtFree(SrcDsaValue);
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        return WinError;
    }

    swprintf(SrcDsaValue, L"%s%s", MOVE_TREE_STATE_SRCDSA_TAG, SrcDsa);
    swprintf(DstDsaValue, L"%s%s", MOVE_TREE_STATE_DSTDSA_TAG, DstDsa);

    Attrs[1]->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    Attrs[1]->mod_type = MT_MOVETREESTATE;
    Attrs[1]->mod_bvalues[0]->bv_len = sizeof(MoveTreeStateVersion);
    Attrs[1]->mod_bvalues[0]->bv_val = (PCHAR) &MoveTreeStateVersion;
    Attrs[1]->mod_bvalues[1]->bv_len = sizeof(WCHAR) * wcslen(MOVE_TREE_STATE_MOVECONTAINER_TAG); 
    Attrs[1]->mod_bvalues[1]->bv_val = (PCHAR) MOVE_TREE_STATE_MOVECONTAINER_TAG;
    Attrs[1]->mod_bvalues[2]->bv_len = sizeof(WCHAR) * wcslen(SrcDsaValue);
    Attrs[1]->mod_bvalues[2]->bv_val = (PCHAR) SrcDsaValue;
    Attrs[1]->mod_bvalues[3]->bv_len = sizeof(WCHAR) * wcslen(DstDsaValue);
    Attrs[1]->mod_bvalues[3]->bv_val = (PCHAR) DstDsaValue;

    
    //
    // add the entry
    //     
    
    WinError = MtAddEntryWithAttrs(MtContext, 
                                   LdapHandle, 
                                   MtContext->MoveContainer, 
                                   Attrs
                                   );
    
    MtWriteLog(MtContext, 
               MT_INFO_CREATE_MOVECONTAINER, 
               WinError, 
               MtContext->MoveContainer, 
               NULL
               );   
     
    MtFree(SrcDsaValue);
    MtFree(DstDsaValue);

    return WinError;

}




ULONG
MtCheckMoveContainer(
    PMT_CONTEXT MtContext, 
    LDAP    *LdapHandle, 
    PWCHAR  SrcDsa, 
    PWCHAR  DstDsa
    )
{
    ULONG   WinError = NO_ERROR;
    ULONG   Status = LDAP_SUCCESS;
    PWCHAR  AttrList[2];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    struct berval **ppbvMoveTreeState = NULL;
    BOOLEAN fSrcDsaMatch = FALSE;
    BOOLEAN fDstDsaMatch = FALSE;



    MT_TRACE(("MtCheckMoveContainer\n"));

     
    AttrList[0] = MT_MOVETREESTATE;
    AttrList[1] = NULL;

    Status = ldap_search_sW(LdapHandle, 
                            MtContext->MoveContainer, 
                            LDAP_SCOPE_BASE, 
                            L"(objectClass=*)",
                            &AttrList[0], 
                            0, 
                            &Result
                            );

    MtGetWinError(LdapHandle, Status, WinError);

    if (NO_ERROR != WinError)
    {
        goto Error;
    }

    if (NULL != Result)
    {
        Entry = ldap_first_entry(LdapHandle, Result);

        if (NULL != Entry)
        {
            //
            // get the MoveTreeState attribute
            // 
            ppbvMoveTreeState = ldap_get_values_lenW(LdapHandle, 
                                                     Entry, 
                                                     MT_MOVETREESTATE
                                                     );

            if (NULL != ppbvMoveTreeState)
            {
                PWCHAR  Temp = NULL;
                ULONG   Index = 0;
                ULONG   Count = 0;

                Count = ldap_count_values_len(ppbvMoveTreeState);

                for (Index = 0; Index < Count; Index ++)
                {
                    if (ppbvMoveTreeState[Index]->bv_len > 
                        sizeof(WCHAR) * wcslen(MOVE_TREE_STATE_SRCDSA_TAG))
                    {
                        if (!_wcsnicmp(MOVE_TREE_STATE_SRCDSA_TAG, 
                                       (LPWSTR) ppbvMoveTreeState[Index]->bv_val, 
                                       wcslen(MOVE_TREE_STATE_SRCDSA_TAG)))
                        {
                            if (!_wcsnicmp(SrcDsa, 
                                           (LPWSTR)(ppbvMoveTreeState[Index]->bv_val +
                                                    wcslen(MOVE_TREE_STATE_SRCDSA_TAG)*
                                                    sizeof(WCHAR)),
                                           wcslen(SrcDsa)))
                            {
                                fSrcDsaMatch = TRUE;
                            }
                        }

                        if (!_wcsnicmp(MOVE_TREE_STATE_DSTDSA_TAG,
                                       (LPWSTR) ppbvMoveTreeState[Index]->bv_val, 
                                       wcslen(MOVE_TREE_STATE_DSTDSA_TAG)))
                        {
                            if (!_wcsnicmp(DstDsa, 
                                           (LPWSTR)(ppbvMoveTreeState[Index]->bv_val +
                                                    wcslen(MOVE_TREE_STATE_DSTDSA_TAG)*
                                                    sizeof(WCHAR)),
                                           wcslen(DstDsa)))
                            {
                                fDstDsaMatch = TRUE;
                            }
                        }
                    }
                }

                if (!fSrcDsaMatch || !fDstDsaMatch)
                {
                    WinError = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                WinError = LdapMapErrorToWin32(LdapGetLastError());
            }
        }
        else
        {
            WinError = LdapMapErrorToWin32(LdapGetLastError());
        }
    }


Error:

    ldap_value_free_len(ppbvMoveTreeState);

    ldap_msgfree(Result);

    MtWriteLog(MtContext, 
               MT_INFO_CHECK_MOVECONTAINER, 
               WinError, 
               MtContext->MoveContainer, 
               NULL
               );

    return WinError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\movetree\exe\main.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    Main.C

Abstract:

    This file shows a simple usage of movetree utility

Author:

    12-Oct-98 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    12-Oct-98 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma  hdrstop

#include <locale.h>
#include "movetree.h"


#define MAX_NT_PASSWORD     PWLEN 


#define CR                  0xD
#define BACKSPACE           0x8


VOID
PrintHelp()
{
    printf("\n");
    printf("THE SYNTAX OF THIS COMMAND IS:\n");
    printf("\n");
    printf("MoveTree [/start | /continue | /check] [/s SrcDSA] [/d DstDSA]\n");
    printf("         [/sdn SrcDN] [/ddn DstDN] [/u Domain\\Username] [/p Password] [/verbose]\n"); 
    printf("\n");
    printf("  /start\t: Start a move tree operation with /check option by default.\n");
    printf("  \t\t: Instead, you could be able to use /startnocheck to start a move\n");
    printf("  \t\t: tree operation without any check.\n");
    printf("  /continue\t: Continue a failed move tree operation.\n");
    printf("  /check\t: Check the whole tree before actually move any object.\n");
    printf("  /s <SrcDSA>\t: Source server's fully qualified primary DNS name. Required\n");
    printf("  /d <DstDSA>\t: Destination server's fully qualified primary DNS name. Required\n");
    printf("  /sdn <SrcDN>\t: Source sub-tree's root DN.\n");
    printf("              \t: Required in Start and Check case. Optional in Continue case\n");
    printf("  /ddn <DstDN>\t: Destination sub-tree's root DN. RDN plus Destinaton Parent DN. Required\n");
    printf("  /u <Domain\\UserName>\t: Domain Name and User Account Name. Optional\n");
    printf("  /p <Password>\t: Password. Optional\n");
    printf("  /verbose\t: Verbose Mode. Pipe anything onto screen. Optional\n");
    printf("\n");
    printf("EXAMPLES:\n");
    printf("\n");
    printf("  movetree /check /s Server1.Dom1.Com /d Server2.Dom2.Com /sdn OU=foo,DC=Dom1,DC=Com\n");
    printf("           /ddn OU=foo,DC=Dom2,DC=Com /u Dom1\\administrator /p *\n");
    printf("\n");
    printf("  movetree /start /s Server1.Dom1.Com /d Server2.Dom2.Com /sdn OU=foo,DC=Dom1,DC=Com\n");
    printf("           /ddn OU=foo,DC=Dom2,DC=Com /u Dom1\\administrator /p MySecretPwd\n");
    printf("\n");
    printf("  movetree /startnocheck /s Server1.Dom1.Com /d Server2.Dom2.Com /sdn OU=foo,DC=Dom1,DC=Com\n");
    printf("           /ddn OU=foo,DC=Dom2,DC=Com /u Dom1\\administrator /p MySecretPwd\n");
    printf("\n");
    printf("  movetree /continue /s Server1.Dom1.Com /d Server2.Dom2.Com /ddn OU=foo,DC=Dom1,DC=Com\n");
    printf("           /u Dom1\\administrator /p * /verbose\n");

    return;
}


ULONG
GetPasswordFromConsole(
    IN PWCHAR UserInfo, 
    IN OUT PWCHAR Buffer, 
    IN USHORT BufferLength
    )
{
    ULONG WinError = NO_ERROR;
    ULONG Error; 
    WCHAR CurrentChar;
    WCHAR * CurrentBufPtr = Buffer; 
    HANDLE InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    DWORD OriginalMode = 0;
    DWORD Length = 0;
    DWORD Read = 0;



    printf("\nType the password for %ls:", UserInfo);

    //
    // Always leave one WCHAR for NULL terminator
    //
    BufferLength --;  

    //
    // Change the console setting. Disable echo input
    // 
    GetConsoleMode(InputHandle, &OriginalMode);
    SetConsoleMode(InputHandle, 
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & OriginalMode);

    while (TRUE)
    {
        CurrentChar = 0;
        //
        // ReadConsole return NULL if failed
        // 
        Error = ReadConsole(InputHandle, 
                               &CurrentChar, 
                               1, 
                               &Read, 
                               NULL
                               );
        if (!Error)
        {
            WinError = GetLastError();
            break;
        }

        if ((CR == CurrentChar) || (1 != Read))   // end of the line 0xd
            break;

        if (BACKSPACE == CurrentChar)             // back up one or two 0x8
        {
            if (Buffer != CurrentBufPtr)
            {
                CurrentBufPtr--;
                Length--;
            }
        }
        else
        {
            if (Length == BufferLength)
            {
                printf("\nInvalid password - exceeds password length limitation.\n"); 
                WinError = ERROR_BUFFER_OVERFLOW;
                break;
            }
            *CurrentBufPtr = CurrentChar;
            CurrentBufPtr++;
            Length++;
        }
    }

    SetConsoleMode(InputHandle, OriginalMode);
    *CurrentBufPtr = L'\0';
    putchar(L'\n');


    return WinError;
}



ULONG
ValidateMoveTreeParameters(
    IN ULONG Flags, 
    IN PWCHAR SrcDsa, 
    IN PWCHAR DstDsa, 
    IN PWCHAR SrcDn, 
    IN PWCHAR DstDn,
    IN PWCHAR UserInfo, 
    IN PWCHAR Password, 
    OUT PSEC_WINNT_AUTH_IDENTITY_EXW * ppCredentials
    )
{
    ULONG    WinError = NO_ERROR;
    PWCHAR   position = NULL;
    PWCHAR   Domain = NULL;
    PWCHAR   UserName = NULL;
    PWCHAR   Pwd = NULL;


    //
    // Client should as least specify one operation to perform
    // 

    if ( !(Flags & (MT_CHECK | MT_START | MT_CONTINUE_MASK)) )
    {
        printf("Invalid Parameter. Please specify at least one operation to execute.\n");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Client should specify either Start or Continue, but not both. 
    // Both Source DSA and Destination DSA should be presented.
    // 

    if (((Flags & MT_START) && (Flags & MT_CONTINUE_MASK)) 
        || (NULL == SrcDsa) 
        || (NULL == DstDsa) )
    {
        printf("Invalid Operation. Can't do both start and continue at the same time.\n");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Can not do check in continue operation case
    // 
    if ((Flags & MT_CHECK) && (Flags & MT_CONTINUE_MASK))
    {
        printf("Invalid Operation. Can't do checking with continue operation\n");
    }

    //
    // In Start, preCheck and Continue cases, 
    // both Source DSA, Destination DSA and DstDn should be presented.
    //
    if (Flags & (MT_START | MT_CHECK | MT_CONTINUE_MASK))
    {
        if ((NULL == SrcDsa) || (NULL == DstDsa) || (NULL == DstDn))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // only password without User Name is not acceptable. 
    // 
    if ((NULL != Password) && (NULL == UserInfo))
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // handle the credentials the client passed in.
    // 

    if (NULL == UserInfo)
    {
        *ppCredentials = NULL;
    }
    else        // fill the credentials
    {
        //
        // Separate Domain Name and User Name from UserInfo
        // 
        position = wcschr(UserInfo, L'\\');

        if (NULL != position)
        {
            Domain = MtAlloc( (position - UserInfo + 1) * sizeof(WCHAR) );

            if (NULL == Domain)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            wcsncpy(Domain, 
                    UserInfo, 
                    (ULONG) (position - UserInfo) 
                    );

            UserName = MtAlloc( (wcslen(UserInfo) - (position - UserInfo)) * sizeof(WCHAR) );

            if (NULL == UserName)
            {
                MtFree(Domain);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            wcscpy(UserName, position + 1 );
        }
        else
        {
            UserName = MtDupString(UserInfo);

            if (NULL == UserName)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Get the password
        // 
        

        if ( (NULL == Password) || !_wcsicmp(Password, L"*") )
        {
            //
            // Get the password from console
            // 
            Pwd = MtAlloc( (MAX_NT_PASSWORD + 1) * sizeof(WCHAR) );

            if (NULL == Pwd)
            {
                MtFree(Domain);
                MtFree(UserName);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            WinError = GetPasswordFromConsole(UserInfo, 
                                              Pwd, 
                                              MAX_NT_PASSWORD + 1
                                              ); 

            if (NO_ERROR != WinError)
            {
                MtFree(Domain);
                MtFree(UserName);
                MtFree(Pwd);
                return (WinError);
            }
        }
        else
        {
            //
            // Get the password from passed in parameter 
            // 
            Pwd = MtDupString(Password);

            if (NULL == Pwd)
            {
                MtFree(Domain);
                MtFree(UserName);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Should have Domain Name, User Name, Pwd well filled
        // at this point
        // 

        *ppCredentials = (PSEC_WINNT_AUTH_IDENTITY_EXW) 
                            MtAlloc( sizeof(SEC_WINNT_AUTH_IDENTITY_EXW) );
        if (NULL == *ppCredentials)
        {
            MtFree(Domain);
            MtFree(UserName);
            MtFree(Pwd);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        (*ppCredentials)->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        (*ppCredentials)->Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
        (*ppCredentials)->PackageList = L"Kerberos";
        (*ppCredentials)->PackageListLength = wcslen(L"Kerberos");
        (*ppCredentials)->Domain = Domain;
        (*ppCredentials)->DomainLength = Domain ? wcslen(Domain):0;
        (*ppCredentials)->User = UserName;
        (*ppCredentials)->UserLength = wcslen(UserName);
        (*ppCredentials)->Password = Pwd;
        (*ppCredentials)->PasswordLength = wcslen(Pwd);
        (*ppCredentials)->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }

    return WinError;
}



void
__cdecl wmain(
    int      cArgs, 
    LPWSTR * pArgs
    )
{
    int     ReturnCode = 0;
    ULONG   WinError = NO_ERROR;
    LDAP    *SrcLdapHandle = NULL;
    LDAP    *DstLdapHandle = NULL;
    MT_CONTEXT  MoveContext;
    int     i = 0;
    ULONG   Flags = 0;
    SEC_WINNT_AUTH_IDENTITY_EXW * pCredentials = NULL; 
    PWCHAR  SrcDsa = NULL;
    PWCHAR  DstDsa = NULL;
    PWCHAR  SrcDn = NULL;
    PWCHAR  DstDn = NULL;
    PWCHAR  Identifier = NULL;
    PWCHAR  UserInfo = NULL;
    PWCHAR  Password = NULL;



    // set locale to the default
    setlocale(LC_ALL,"");

    if (cArgs <= 1)
    {
        PrintHelp();
        exit (1);
    }


    //
    //  initialize variables
    // 
    RtlZeroMemory(&MoveContext, sizeof(MT_CONTEXT));


    //
    // collect all the arguments 
    // 
    for (i = 1; i < cArgs; i++)
    {
        if ( !_wcsicmp(pArgs[i], L"/start") ||
             !_wcsicmp(pArgs[i], L"-start") )
        {
            Flags |= (MT_START | MT_CHECK);
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/startnocheck") ||
             !_wcsicmp(pArgs[i], L"-startnocheck") )
        {
            Flags |= MT_START;
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/continue") ||
             !_wcsicmp(pArgs[i], L"-continue") )
        {
            Flags |= MT_CONTINUE_BY_DSTROOTOBJDN;
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/check") ||
             !_wcsicmp(pArgs[i], L"-check") )
        {
            Flags |= MT_CHECK;
            continue;
        }
        
        if ( !_wcsicmp(pArgs[i], L"/verbose") ||
             !_wcsicmp(pArgs[i], L"-verbose") )
        {
            Flags |= MT_VERBOSE;
            continue;
        }
        
        if ( !_wcsicmp(pArgs[i], L"/s") ||
             !_wcsicmp(pArgs[i], L"-s") )
        {
            if (++i >= cArgs)
            {
                PrintHelp();
                ReturnCode = 1;
                goto Finish; 
            }
            SrcDsa = pArgs[i];
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/d") ||
             !_wcsicmp(pArgs[i], L"-d") )
        {
            if (++i >= cArgs)
            {
                PrintHelp();
                ReturnCode = 1;
                goto Finish; 
            }
            DstDsa = pArgs[i];
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/sdn") ||
             !_wcsicmp(pArgs[i], L"-sdn") )
        {
            if (++i >= cArgs)
            {
                PrintHelp();
                ReturnCode = 1;
                goto Finish; 
            }
            SrcDn = pArgs[i];
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/ddn") ||
             !_wcsicmp(pArgs[i], L"-ddn") )
        {
            if (++i >= cArgs)
            {
                PrintHelp();
                ReturnCode = 1;
                goto Finish;
            }
            DstDn = pArgs[i];
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/u") ||
             !_wcsicmp(pArgs[i], L"-u") )
        {
            if (++i >= cArgs)
            {
                PrintHelp();
                ReturnCode = 1;
                goto Finish;
            }
            UserInfo = pArgs[i];
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/p") ||
             !_wcsicmp(pArgs[i], L"-p") )
        {
            if (++i >= cArgs)
            {
                PrintHelp();
                ReturnCode = 1;
                goto Finish;
            }
            Password = pArgs[i];
            continue;
        }

        PrintHelp();
        ReturnCode = 1;
        goto Finish;
    }

    printf("\n\n");

    //
    // Validate Parameters and Construct the Credentials
    // if the client provided them.
    // 

    WinError = ValidateMoveTreeParameters(Flags,
                                          SrcDsa, 
                                          DstDsa, 
                                          SrcDn, 
                                          DstDn, 
                                          UserInfo, 
                                          Password,
                                          &pCredentials
                                          );



    if (NO_ERROR != WinError)
    {
        PrintHelp();
        ReturnCode = 1;
        goto Finish;
    }


    MoveContext.Flags = Flags;

    WinError = MtCreateLogFiles(&MoveContext, 
                                DEFAULT_LOG_FILE_NAME, 
                                DEFAULT_ERROR_FILE_NAME, 
                                DEFAULT_CHECK_FILE_NAME
                                );

    if (NO_ERROR != WinError)
    {
        printf("MOVETREE FAILED. 0x%x CAN NOT CREATE LOG FILES.\n", WinError);
        goto Cleanup;
    }

    WinError = MtSetupSession(&MoveContext, 
                              &SrcLdapHandle, 
                              &DstLdapHandle, 
                              SrcDsa, 
                              DstDsa, 
                              pCredentials
                              );

    if (NO_ERROR != WinError)
    {
        //
        // Should Write Log File
        // 
        printf("MOVETREE FAILED. 0x%x CAN NOT MAKE CONNECTION.\n", WinError);
        printf("READ %ls FOR DETAILS.\n", DEFAULT_ERROR_FILE_NAME);
        goto Cleanup;
    }

    if (Flags & MT_CHECK)
    {
        WinError = MoveTreeCheck(&MoveContext, 
                                 SrcLdapHandle, 
                                 DstLdapHandle, 
                                 SrcDsa, 
                                 DstDsa, 
                                 SrcDn, 
                                 DstDn
                                 );

        if (NO_ERROR != WinError)
        {
            printf("MOVETREE PRE-CHECK FAILED. 0x%x \n", WinError);
            printf("READ %ls FOR DETAILS.\n", DEFAULT_ERROR_FILE_NAME);

            goto Cleanup;
        }
        else
        {
            printf("MOVETREE PRE-CHECK FINISHED.\n");

            if (MoveContext.ErrorType & MT_ERROR_CHECK)
            {
                printf("MOVETREE DETECTED THERE ARE SOME OBJECTS CAN NOT BE MOVED.\n");
                printf("PLEASE CLEAN THEM UP FIRST BEFORE TRYING TO START THE MOVE TREE OPERATION.\n");
                printf("READ %ls FOR DETAILS.\n", DEFAULT_CHECK_FILE_NAME);

                goto Cleanup;
            }
            else
            {
                printf("MOVETREE IS READY TO START THE MOVE OPERATION.\n\n");
            }
        }
    }

    if (Flags & MT_START)
    {
        WinError = MoveTreeStart(&MoveContext, 
                                 SrcLdapHandle, 
                                 DstLdapHandle, 
                                 SrcDsa, 
                                 DstDsa, 
                                 SrcDn, 
                                 DstDn
                                 );

    }
    else if (Flags & MT_CONTINUE_MASK)
    {
        WinError = MoveTreeContinue(&MoveContext, 
                                    SrcLdapHandle, 
                                    DstLdapHandle, 
                                    SrcDsa, 
                                    DstDsa, 
                                    DstDn
                                    );
    }
    else 
    {
        WinError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (NO_ERROR != WinError)
    {
        printf("MOVETREE FAILED. 0x%x\n", WinError);
        printf("READ %ls FOR DETAILS.\n", DEFAULT_ERROR_FILE_NAME);
    }
    else 
    {
        //
        // if orphan container is not empty
        // 
        if (MoveContext.ErrorType & MT_ERROR_ORPHAN_LEFT)
        {
            printf("MOVETREE FINISHED.\n");
            printf("THERE ARE ORPHAN OBJECTS LEFT DURING THE MOVE OPERATION.\n");
            printf("PLEASE CHECK %ls AND %ls\n", 
                   DEFAULT_LOG_FILE_NAME, DEFAULT_ERROR_FILE_NAME);
            printf("OR CONTAINER %ls FOR DETAILS.\n", MoveContext.OrphansContainer);
        }
        else
        {
            printf("MOVETREE FINISHED SUCCESSFULLY.\n"); 
        }
    }


Cleanup:

    if (NO_ERROR == WinError)
    {
        if (MoveContext.ErrorType & MT_ERROR_ORPHAN_LEFT)
        {
            ReturnCode = 2;
        }
        else
        {
            ReturnCode = 0;
        }
    }
    else
    {
        ReturnCode = 1;
    }

    if (NULL != SrcLdapHandle)
        MtDisconnect(&SrcLdapHandle);
    if (NULL != DstLdapHandle)
        MtDisconnect(&DstLdapHandle);

    if (MoveContext.LogFile)
        fclose(MoveContext.LogFile);
    if (MoveContext.ErrorFile)
        fclose(MoveContext.ErrorFile);
    if (MoveContext.CheckFile)
        fclose(MoveContext.CheckFile);

    MtFree(MoveContext.MoveContainer);
    MtFree(MoveContext.OrphansContainer);
    MtFree(MoveContext.RootObjGuid);
    MtFree(MoveContext.RootObjNewDn);
    MtFree(MoveContext.RootObjProxyContainer);

    if (pCredentials)
    {
        MtFree(pCredentials->Domain);
        MtFree(pCredentials->User);
        MtFree(pCredentials->Password);
        MtFree(pCredentials);
    }

Finish:

    exit( ReturnCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ndnc\ndnc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndnc.c

Abstract:

    This is a user mode LDAP client that manipulates the Non-Domain
    Naming Contexts (NDNC) Active Directory structures.  NDNCs are
    also known as Application Directory Partitions.

Author:

    Brett Shirley (BrettSh) 20-Feb-2000

Environment:

    User mode LDAP client.

Revision History:

    21-Jul-2000     BrettSh

        Moved this file and it's functionality from the ntdsutil
        directory to the new a new library ndnc.lib.  This is so
        it can be used by ntdsutil and tapicfg commands.  The  old
        source location: \nt\ds\ds\src\util\ntdsutil\ndnc.c.

--*/

#include <NTDSpch.h>
#pragma hdrstop

#define UNICODE 1

#include <windef.h>
#include <winerror.h>
#include <stdio.h>
#include <winldap.h>
#include <ntldap.h>

#include <sspi.h>


#include <assert.h>
#include <sddl.h>
#include "ndnc.h"

WCHAR wszPartition[] = L"cn=Partitions,";
#define  SITES_RDN L"CN=Sites,"

LONG ChaseReferralsFlag = LDAP_CHASE_EXTERNAL_REFERRALS;
LDAPControlW ChaseReferralsControlFalse = {LDAP_CONTROL_REFERRALS_W,
                                           {4, (PCHAR)&ChaseReferralsFlag},
                                           FALSE};
LDAPControlW ChaseReferralsControlTrue = {LDAP_CONTROL_REFERRALS_W,
                                           {4, (PCHAR)&ChaseReferralsFlag},
                                           TRUE};
LDAPControlW *   gpServerControls [] = { NULL };
LDAPControlW *   gpClientControlsNoRefs [] = { &ChaseReferralsControlFalse, NULL };
LDAPControlW *   gpClientControlsRefs [] = { &ChaseReferralsControlTrue, NULL };


// --------------------------------------------------------------------------
//
// Helper Routines.
//

ULONG
GetRootAttr(
    IN  LDAP *       hld,
    IN  WCHAR *      wszAttr,
    OUT WCHAR **     pwszOut
    )
/*++

Routine Description:

    This grabs an attribute specifed by wszAttr from the
    rootDSE of the server connected to by hld.

Arguments:

    hld (IN) - A connected ldap handle
    wszAttr (IN) - The attribute to grab from the root DSE.
    pwszOut (OUT) - A LocalAlloc()'d result. 

Return value:

    ldap error code                 
                 
--*/
{
    ULONG            ulRet = LDAP_SUCCESS;
    WCHAR *          pwszAttrFilter[2];
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR **         pwszTempAttrs = NULL;

    assert(pwszConfigDn);
    assert(pwszOut);

    *pwszOut = NULL;
    __try{

        pwszAttrFilter[0] = wszAttr;
        pwszAttrFilter[1] = NULL;

        ulRet = ldap_search_sW(hld,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(ulRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
            __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry, 
                                         wszAttr);
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_RESULTS_RETURNED;
            __leave;
        }
 
        *pwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                               sizeof(WCHAR) * (wcslen(pwszTempAttrs[0]) + 2));
        if(*pwszOut == NULL){
            ulRet = LDAP_NO_MEMORY;
            __leave;
        }

        wcscpy(*pwszOut, pwszTempAttrs[0]);

    } __finally {

        if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
        if(pwszTempAttrs != NULL){ ldap_value_freeW(pwszTempAttrs); }
    
    }
    
    if(!ulRet && *pwszOut == NULL){
        // Catch the default error case.
        ulRet = LDAP_NO_SUCH_ATTRIBUTE;
    }
    return(ulRet);
}

ULONG
GetConfigDN(
    IN  LDAP *       hld,
    OUT WCHAR **     pwszConfigDn
    )
// NOTE: It'd be better if this was just a call to GetRootAttr().
{
    ULONG            ulRet;
    WCHAR *          pwszAttrFilter[2];
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR **         pwszTempAttrs = NULL;

    assert(pwszConfigDn);

    *pwszConfigDn = NULL;

    __try {
        pwszAttrFilter[0] = LDAP_OPATT_CONFIG_NAMING_CONTEXT_W;
        pwszAttrFilter[1] = NULL;

        ulRet = ldap_search_sW(hld,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(ulRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
            __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry,
                                         LDAP_OPATT_CONFIG_NAMING_CONTEXT_W);
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_RESULTS_RETURNED;
            __leave;
        }

        *pwszConfigDn = (WCHAR *) LocalAlloc(LMEM_FIXED,
                               sizeof(WCHAR) * (wcslen(pwszTempAttrs[0]) + 2));
        if(*pwszConfigDn == NULL){
            ulRet = LDAP_NO_MEMORY;
            __leave;
        }

        wcscpy(*pwszConfigDn, pwszTempAttrs[0]);

    } __finally {

        if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
        if(pwszTempAttrs != NULL){ ldap_value_freeW(pwszTempAttrs); }

    }

    if(!ulRet && *pwszConfigDn == NULL){
        ulRet = LDAP_NO_SUCH_ATTRIBUTE;
    }

    return(ulRet);
}

ULONG
GetPartitionsDN(
    IN  LDAP *       hld,
    OUT WCHAR **     pwszPartitionsDn
    )
{
    ULONG            ulRet;
    WCHAR *          wszConfigDn = NULL;

    assert(pwszPartitionsDn);

    *pwszPartitionsDn = NULL;

    ulRet = GetConfigDN(hld, &wszConfigDn);
    if(ulRet){
        assert(!wszConfigDn);
        return(ulRet);
    }
    assert(wszConfigDn);

    *pwszPartitionsDn = (WCHAR *) LocalAlloc(LMEM_FIXED,
                                   sizeof(WCHAR) *
                                   (wcslen(wszConfigDn) +
                                    wcslen(wszPartition) + 2));
    if(*pwszPartitionsDn == NULL){
        if(wszConfigDn != NULL){ LocalFree(wszConfigDn); }
        return(LDAP_NO_MEMORY);
    }

    wcscpy(*pwszPartitionsDn, wszPartition);
    wcscat(*pwszPartitionsDn, wszConfigDn);

    if(wszConfigDn != NULL){ LocalFree(wszConfigDn); }

    return(ulRet);
}

ULONG
GetDomainNamingDns(
    IN  LDAP *       hld,
    OUT WCHAR **     pwszDomainNamingFsmo
    )
/*++

Routine Description:

   This function takes a connected ldap handle to read the DS to
   find the current location of the Domain Naming FSMO.  This function
   does not yet do a recursive search for this FSMO.

Arguments:

    hld (IN) - A connected ldap handle
    pwszDomainNamingFsmo (OUT) - A LocalAlloc()'d DNS name of the
        Domain Naming FSMO.

Return value:

    ldap error code                 
                 
--*/
{
    ULONG            ulRet = ERROR_SUCCESS;
    WCHAR *          wszPartitionDn = NULL;
    WCHAR *          pwszAttrFilter[2];
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR **         pwszTempAttrs = NULL;

    assert(pwszDomainNamingFsmo);
    *pwszDomainNamingFsmo = NULL;

    __try{

        ulRet = GetPartitionsDN(hld, &wszPartitionDn);
        if(ulRet){
            __leave;
        }


        pwszAttrFilter[0] = L"fSMORoleOwner";
        pwszAttrFilter[1] = NULL;

        ulRet = ldap_search_sW(hld,
                               wszPartitionDn,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(ulRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
            __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry, 
                                         L"fSMORoleOwner");
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_RESULTS_RETURNED;
            __leave;
        }
 
        ulRet = GetServerDnsFromServerNtdsaDn(hld, 
                                              pwszTempAttrs[0],
                                              pwszDomainNamingFsmo);
        if(ulRet){
            __leave;
        }

     } __finally {

         if(wszPartitionDn) { LocalFree(wszPartitionDn); }
         if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
         if(pwszTempAttrs != NULL){ ldap_value_freeW(pwszTempAttrs); }

     }

     return(ulRet);
}

ULONG
GetCrossRefDNFromNCDN(
    IN  LDAP *       hld,
    IN  WCHAR *      wszNCDN,
    OUT WCHAR **     pwszCrossRefDn
    )
{
    ULONG            ulRet;
    WCHAR *          pwszAttrFilter [2];
    WCHAR *          wszPartitionsDn = NULL;
    WCHAR *          wszFilter = NULL;
    WCHAR **         pwszTempAttrs = NULL;
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR *          wszFilterBegin = L"(& (objectClass=crossRef) (nCName=";
    WCHAR *          wszFilterEnd = L") )";

    assert(wszNCDN);

    *pwszCrossRefDn = NULL;

    __try {

        ulRet = GetPartitionsDN(hld, &wszPartitionsDn);
        if(ulRet != LDAP_SUCCESS){
            __leave;
        }
        assert(wszPartitionsDn);

        pwszAttrFilter[0] = L"distinguishedName";
        pwszAttrFilter[1] = NULL;

        wszFilter = LocalAlloc(LMEM_FIXED,
                               sizeof(WCHAR) *
                               (wcslen(wszFilterBegin) +
                                wcslen(wszFilterEnd) +
                                wcslen(wszNCDN) + 3));
        if(wszFilter == NULL){
            ulRet = LDAP_NO_MEMORY;
            __leave;
        }
        wcscpy(wszFilter, wszFilterBegin);
        wcscat(wszFilter, wszNCDN);
        wcscat(wszFilter, wszFilterEnd);

        ulRet = ldap_search_sW(hld,
                               wszPartitionsDn,
                               LDAP_SCOPE_ONELEVEL,
                               wszFilter,
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(ulRet){
            __leave;
        }
        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
           __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry,
                                         L"distinguishedName");
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_SUCH_OBJECT;
           __leave;
        }

        *pwszCrossRefDn = LocalAlloc(LMEM_FIXED,
                               sizeof(WCHAR) * (wcslen(pwszTempAttrs[0]) + 2));
        if(*pwszCrossRefDn == NULL){
            ulRet = LDAP_NO_MEMORY;
            __leave;
        }

        wcscpy(*pwszCrossRefDn, pwszTempAttrs[0]);

    } __finally {

        if(wszPartitionsDn){ LocalFree(wszPartitionsDn); }
        if(wszFilter) { LocalFree(wszFilter); }
        if(pldmResults){ ldap_msgfree(pldmResults); }
        if(pwszTempAttrs){ ldap_value_freeW(pwszTempAttrs); }

    }

    if(!ulRet && *pwszCrossRefDn == NULL){
        ulRet = LDAP_NO_SUCH_OBJECT;
    }

    return(ulRet);
}

ULONG
GetServerNtdsaDnFromServerDns(
    IN LDAP *        hld,
    IN WCHAR *       wszServerDNS,
    OUT WCHAR **     pwszServerDn
    )
{
    WCHAR *          wszConfigDn = NULL;
    WCHAR *          wszSitesDn = NULL;
    DWORD            dwRet = ERROR_SUCCESS;
    WCHAR *          wszFilter = NULL;
    WCHAR *          wszFilterBegin = L"(& (objectCategory=server) (dNSHostName=";
    WCHAR *          wszFilterEnd = L") )";
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmResults2 = NULL;
    LDAPMessage *    pldmEntry = NULL;
    LDAPMessage *    pldmEntry2 = NULL;
    WCHAR *          wszFilter2 = L"(objectCategory=ntdsDsa)";
    WCHAR *          wszDn = NULL;
    WCHAR *          wszFoundDn = NULL;
    WCHAR *          pwszAttrFilter[2];

    *pwszServerDn = NULL;

    __try{
        dwRet = GetConfigDN(hld, &wszConfigDn);
        if(dwRet){
            __leave;
        }

        wszSitesDn = LocalAlloc(LMEM_FIXED,
                                sizeof(WCHAR) *
                                (wcslen(SITES_RDN) + wcslen(wszConfigDn) + 1));
        if(wszSitesDn == NULL){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }
        wcscpy(wszSitesDn, SITES_RDN);
        wcscat(wszSitesDn, wszConfigDn);

        wszFilter = LocalAlloc(LMEM_FIXED,
                               sizeof(WCHAR) *
                               (wcslen(wszFilterBegin) + wcslen(wszFilterEnd) +
                               wcslen(wszServerDNS) + 2));
        if(wszFilter == NULL){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }
        wcscpy(wszFilter, wszFilterBegin);
        wcscat(wszFilter, wszServerDNS);
        wcscat(wszFilter, wszFilterEnd);

        pwszAttrFilter[0] = NULL;

        // Do an ldap search
        dwRet = ldap_search_sW(hld,
                               wszSitesDn,
                               LDAP_SCOPE_SUBTREE,
                               wszFilter,
                               pwszAttrFilter,
                               0,
                               &pldmResults);
        if(dwRet){
            __leave;
        }

        for(pldmEntry = ldap_first_entry(hld, pldmResults);
            pldmEntry != NULL;
            pldmEntry = ldap_next_entry(hld, pldmResults)){

            wszDn = ldap_get_dn(hld, pldmEntry);
            if(wszDn == NULL){
                continue;
            }

            dwRet = ldap_search_sW(hld,
                                   wszDn,
                                   LDAP_SCOPE_ONELEVEL,
                                   wszFilter2,
                                   pwszAttrFilter,
                                   0,
                                   &pldmResults2);
            if(dwRet == LDAP_NO_SUCH_OBJECT){
                dwRet = LDAP_SUCCESS;
                ldap_memfree(wszDn);
                wszDn = NULL;
                continue;
            } else if(dwRet){
                __leave;
            }

            ldap_memfree(wszDn);
            wszDn = NULL;

            pldmEntry2 = ldap_first_entry(hld, pldmResults2);
            if(pldmEntry2 == NULL){
                dwRet = ldap_result2error(hld, pldmResults2, FALSE);
                if(dwRet == LDAP_NO_SUCH_OBJECT || dwRet == LDAP_SUCCESS){
                    dwRet = LDAP_SUCCESS;
                    ldap_memfree(wszDn);
                    wszDn = NULL;
                    continue;
                }
                __leave;

            }

            wszDn = ldap_get_dn(hld, pldmEntry2);
            if(wszDn == NULL){
                dwRet = LDAP_NO_SUCH_OBJECT;
                __leave;
            }

            assert(!ldap_next_entry(hld, pldmResults2));

            // If we've gotten here we've got a DN that we're going to consider.
            if(wszFoundDn){
                // We've already found and NTDSA object, this is really bad ... so
                // lets clean up and return an error.  Using the below error code
                // to return the fact that there was more than one NTDSA object.
                dwRet = LDAP_MORE_RESULTS_TO_RETURN;
                __leave;
            }
            wszFoundDn = wszDn;
            wszDn = NULL;

        }



        if(!wszFoundDn){
            dwRet = LDAP_NO_SUCH_OBJECT;
            __leave;

        }

        *pwszServerDn = LocalAlloc(LMEM_FIXED,
                                   (wcslen(wszFoundDn)+1) * sizeof(WCHAR));
        if(!pwszServerDn){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }

        // pwszTempAttrs[0] should be the DN of the NTDS Settings object.
        wcscpy(*pwszServerDn, wszFoundDn);
        // WooHoo we're done!

    } __finally {

        if(wszConfigDn) { LocalFree(wszConfigDn); }
        if(wszSitesDn) { LocalFree(wszSitesDn); }
        if(wszFilter) { LocalFree(wszFilter); }
        if(pldmResults) { ldap_msgfree(pldmResults); }
        if(pldmResults2) { ldap_msgfree(pldmResults2); }
        if(wszDn) { ldap_memfree(wszDn); }
        if(wszFoundDn) { ldap_memfree(wszFoundDn); }

    }

    if(!dwRet && *pwszServerDn == NULL){
        // Default error.
        dwRet = LDAP_NO_SUCH_OBJECT;
    }

    return(dwRet);
}

ULONG
GetServerDnsFromServerNtdsaDn(
    IN LDAP *        hld,                   
    IN WCHAR *       wszNtdsaDn,
    OUT WCHAR **     pwszServerDNS
    )
/*++

Routine Description:

    This function takes the DN of an NTDSA object, and simply
    trims off one RDN and looks at the dns attribute on the
    server object.

Arguments:

    hld (IN) - A connected ldap handle
    wszNtdsaDn (IN) - The DN of the NTDSA object that we
        want the DNS name for.
    pwszServerDNS (OUT) - A LocalAlloc()'d DNS name of the
        server.

Return value:

    ldap error code                 
                 
--*/
{
    WCHAR *          wszServerDn = wszNtdsaDn;
    ULONG            ulRet = ERROR_SUCCESS;
    WCHAR *          pwszAttrFilter[2];
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR **         pwszTempAttrs = NULL;
    
    assert(hld && wszNtdsaDn && pwszServerDNS);
    *pwszServerDNS = NULL;

    // First Trim off one AVA/RDN.
    while(*wszServerDn != L','){
        wszServerDn++;
    }
    wszServerDn++;
    __try{ 

        pwszAttrFilter[0] = L"dNSHostName";
        pwszAttrFilter[1] = NULL;
        ulRet = ldap_search_sW(hld,
                               wszServerDn,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);
        if(ulRet != LDAP_SUCCESS){
            __leave;
        }
        
        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
            assert(ulRet);
            __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry,
                                         pwszAttrFilter[0]);
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_RESULTS_RETURNED;
            __leave;
        }
        
        *pwszServerDNS = LocalAlloc(LMEM_FIXED,
                                    ((wcslen(pwszTempAttrs[0])+1) * sizeof(WCHAR)));
        if(*pwszServerDNS == NULL){
            ulRet = LDAP_NO_MEMORY;
            __leave;
        }

        wcscpy(*pwszServerDNS, pwszTempAttrs[0]);
        assert(ulRet == ERROR_SUCCESS);

    } __finally {
        if(pldmResults) { ldap_msgfree(pldmResults); }
        if(pwszTempAttrs) { ldap_value_freeW(pwszTempAttrs); }
    }

    return(ulRet);
}

BOOL
SetIscReqDelegate(
    LDAP *  hld
    )
/*++

    Function returns TRUE on successful setting of the option.

--*/
{
    DWORD                   dwCurrentFlags = 0;
    DWORD                   dwErr;

    // This call to ldap_get/set_options, is so that the this
    // ldap connection's binding allows the client credentials
    // to be emulated.  This is needed because the ldap_add
    // operation for CreateNDNC, may need to remotely create
    // a crossRef on the Domain Naming FSMO.

    dwErr = ldap_get_optionW(hld,
                             LDAP_OPT_SSPI_FLAGS,
                             &dwCurrentFlags
                             );

    if (LDAP_SUCCESS != dwErr){
        return(FALSE);
    }

    //
    // Set the security-delegation flag, so that the LDAP client's
    // credentials are used in the inter-DC connection, when moving
    // the object from one DC to another.
    //
    dwCurrentFlags |= ISC_REQ_DELEGATE;

    dwErr = ldap_set_optionW(hld,
                             LDAP_OPT_SSPI_FLAGS,
                             &dwCurrentFlags
                             );

    if (LDAP_SUCCESS != dwErr){
//        RESOURCE_PRINT2(IDS_CONNECT_LDAP_SET_OPTION_ERROR, dwErr, GetLdapErr(dwErr));
        return(FALSE);
    }

    // Now a ldap_bind can be done.  The ldap_bind calls InitializeSecurityContextW(),
    // and the ISC_REQ_DELEGATE flag above must be set before this function
    // is called.

    return(TRUE);
}

LDAP *
GetNdncLdapBinding(
    WCHAR *          pszServer,
    DWORD *          pdwRet,
    BOOL             fReferrals,
    SEC_WINNT_AUTH_IDENTITY_W   * pCreds
    )
{
    LDAP *           hLdapBinding = NULL;
    DWORD            dwRet;
    ULONG            ulOptions;

    // Open LDAP connection.
    hLdapBinding = ldap_initW(pszServer, LDAP_PORT);
    if(hLdapBinding == NULL){
        *pdwRet = GetLastError();
        return(NULL);
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hLdapBinding, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    ulOptions = PtrToUlong((fReferrals ? LDAP_OPT_ON : LDAP_OPT_OFF));
    // Set LDAP referral option to no.
    dwRet = ldap_set_option(hLdapBinding,
                            LDAP_OPT_REFERRALS,
                            &ulOptions);
    if(dwRet != LDAP_SUCCESS){
        *pdwRet = LdapMapErrorToWin32(dwRet);
        ldap_unbind(hLdapBinding);
        return(NULL);
    }

    if(!SetIscReqDelegate(hLdapBinding)){
        // Error was printed by the function.
        ldap_unbind(hLdapBinding);
        return(NULL);
    }

    // Perform LDAP bind
    dwRet = ldap_bind_sW(hLdapBinding,
                         NULL,
                         (WCHAR *) pCreds,
                         LDAP_AUTH_SSPI);
    if(dwRet != LDAP_SUCCESS){
        *pdwRet = LdapMapErrorToWin32(dwRet);
        ldap_unbind(hLdapBinding);
        return(NULL);
    }

    // Return LDAP binding.
    return(hLdapBinding);
}

BOOL
CheckDnsDn(
    IN   WCHAR       * wszDnsDn
    )
/*++

Description:

    A validation function for a DN that can be cleanly converted to a DNS
    name through DsCrackNames().

Parameters:

    A DN of a DNS convertible name.  Ex: DC=brettsh-dom,DC=nttest,DC=com
    converts to brettsh-dom.nttest.com.

Return Value:

    TRUE if the DN looks OK, FALSE otherwise.

--*/
{
    DS_NAME_RESULTW *  pdsNameRes = NULL;
    BOOL               fRet = TRUE;
    DWORD              dwRet;

    if(wszDnsDn == NULL){
        return(FALSE);
    }

    if((DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                      DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                      1, &wszDnsDn, &pdsNameRes) != ERROR_SUCCESS) ||
       (pdsNameRes == NULL) ||
       (pdsNameRes->cItems < 1) ||
       (pdsNameRes->rItems == NULL) ||
       (pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR) ||
       (pdsNameRes->rItems[0].pName == NULL) ){
        fRet = FALSE;
    } else {

       if( (wcslen(pdsNameRes->rItems[0].pName) - 1) !=
           (ULONG) (wcschr(pdsNameRes->rItems[0].pName, L'/') - pdsNameRes->rItems[0].pName)){
           fRet = FALSE;
       }

    }

    if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }
    return(fRet);
}



// --------------------------------------------------------------------------
//
// Main Routines.
//
//
// Each of these functions below is designed to appoximately match a
// corresponding NTDSUtil.exe command from the domain management menu.
// These LDAP operations are the supported way of modify Non-Domain
// Naming Context's behaviour and control parameters.
//


ULONG
CreateNDNC(
    IN LDAP *        hldNDNCDC,
    const IN WCHAR * wszNDNC,
    const IN WCHAR * wszShortDescription 
    )
/*++

Routine Description:

    This function creates and NDNC.

Arguments:

    hldNDNCDC - An LDAP binding to the server which should instantiate
        the first instance of this new NDNC.
    wszNDNC - The DN on the NDNC

Return value:

    LDAP RESULT.

--*/
{
    ULONG            ulRet;
    LDAPModW *       pMod[8];

    // Instance Type
    WCHAR            buffer[30]; // needs to hold largest potential 32 bit int.
    LDAPModW         instanceType;
    WCHAR *          instanceType_values [2];

    // Object Class
    LDAPModW         objectClass;
    WCHAR *          objectClass_values [] = { L"domainDNS", NULL };

    // Description 
    LDAPModW         shortDescription;
    WCHAR *          shortDescription_values [2];

    assert(hldNDNCDC);
    assert(wszNDNC);
    assert(wszShortDescription);
    
    // Setup the instance type of this object, which we are
    // specifiying to be an NC Head.
    _itow(DS_INSTANCETYPE_IS_NC_HEAD | DS_INSTANCETYPE_NC_IS_WRITEABLE, buffer, 10);
    instanceType.mod_op = LDAP_MOD_ADD;
    instanceType.mod_type = L"instanceType";
    instanceType_values[0] = buffer;
    instanceType_values[1] = NULL;
    instanceType.mod_vals.modv_strvals = instanceType_values;

    // Setup the object class, which is basically the type.
    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = L"objectClass";
    objectClass.mod_vals.modv_strvals = objectClass_values;

    // Setup the Short Description
    shortDescription.mod_op = LDAP_MOD_ADD;
    shortDescription.mod_type = L"description";
    shortDescription_values[0] = (WCHAR *) wszShortDescription;
    shortDescription_values[1] = NULL;
    shortDescription.mod_vals.modv_strvals = shortDescription_values;

    // Setup the Mod array
    pMod[0] = &instanceType;
    pMod[1] = &objectClass;
    pMod[2] = &shortDescription;
    pMod[3] = NULL;

    // Adding NDNC to DS.
    ulRet = ldap_add_ext_sW(hldNDNCDC,
                            (WCHAR *) wszNDNC,
                            pMod,
                            gpServerControls,
                            gpClientControlsNoRefs);

    return(ulRet);
}

ULONG
RemoveNDNC(
    IN LDAP *        hldDomainNamingFSMO,
    IN WCHAR *       wszNDNC
    )
/*++

Routine Description:

    This routine removes the NDNC specified.  This basically means to remove
    the Cross-Ref object of the NDNC.  This will only succeed if all of the
    NDNC's replicas have been removed, and this fact has replicated back to
    the Domain Naming FSMO.

Arguments:

    ldapDomainNamingFSMO - An LDAP binding of the Domain Naming FSMO.
    wszNDNC - The FQDN of the NDNC to remove.

Return value:

    LDAP RESULT.

--*/
{
    ULONG            ulRet;
    WCHAR *          wszNDNCCrossRefDN = NULL;

    assert(hldDomainNamingFSMO);
    assert(wszNDNC);

    ulRet = GetCrossRefDNFromNCDN(hldDomainNamingFSMO,
                                  wszNDNC,
                                  &wszNDNCCrossRefDN);
    if(ulRet != LDAP_SUCCESS){
        assert(wszNDNCCrossRefDN == NULL);
        return(ulRet);
    }
    assert(wszNDNCCrossRefDN);

    ulRet = ldap_delete_ext_sW(hldDomainNamingFSMO,
                               wszNDNCCrossRefDN,
                               gpServerControls,
                               gpClientControlsRefs);

    if(wszNDNCCrossRefDN) { LocalFree(wszNDNCCrossRefDN); }

    return(ulRet);
}

ULONG
ModifyNDNCReplicaSet(
    IN LDAP *        hldDomainNamingFSMO,
    IN WCHAR *       wszNDNC,
    IN WCHAR *       wszReplicaNtdsaDn,
    IN BOOL          fAdd // Else it is considered a delete
    )
/*++

Routine Description:

    This routine Modifies the Replica Set to include or remove a
    server (depending on the fAdd flag).

Arguments:

    hldDomainNamingFSMO - LDAP binding to the Naming FSMO.
    wszNDNC - The NDNC of which to change the replica set of.
    wszReplicaNtdsaDn - The DN of the NTDS settings object of the
        replica to add or remove.
    fAdd - TRUE if we should add wszReplicaDC to the replica set,
        FALSE if we should remove wszReplicaDC from the replica set for
        wszNDNC.

Return value:

    LDAP RESULT.

--*/
{
    ULONG            ulRet;

    LDAPModW *       pMod[4];
    LDAPModW         ncReplicas;
    WCHAR *          ncReplicas_values [] = {NULL, NULL, NULL};

    WCHAR *          wszNdncCr = NULL;

    assert(wszNDNC);
    assert(wszRepliaNtdsaDn);

    ulRet = GetCrossRefDNFromNCDN(hldDomainNamingFSMO,
                                  wszNDNC,
                                  &wszNdncCr);
    if(ulRet != LDAP_SUCCESS){
        assert(wszNdncCr == NULL);
        return(ulRet);
    }

    // Set operation.
    if(fAdd){
        // Flag indicates we want to add this DC to the replica set.
        ncReplicas.mod_op = LDAP_MOD_ADD;
    } else {
        // Else the we want to delete this DC from the replica set.
        ncReplicas.mod_op = LDAP_MOD_DELETE;
    }

    // Set value.
    ncReplicas_values[0] = wszReplicaNtdsaDn;
    ncReplicas.mod_type = L"msDS-NC-Replica-Locations";
    ncReplicas_values[1] = NULL;
    ncReplicas.mod_vals.modv_strvals = ncReplicas_values;

    pMod[0] = &ncReplicas;
    pMod[1] = NULL;

    // Perform LDAP add value to NDNC's nCReplicaLocations attribute.

    // Note: In an entirely Win2k+1 or Whistler Enterprise with Link Value
    //   Replication enabled the replica can be added on any DC in the
    //   enterprise.  Otherwise, the replica must be added on the Domain
    //   Naming FSMO.

    ulRet = ldap_modify_ext_sW(hldDomainNamingFSMO,
                               wszNdncCr,
                               pMod,
                               gpServerControls,
                               gpClientControlsRefs);

    if(wszNdncCr) { LocalFree(wszNdncCr); }

	    return(ulRet);
}


ULONG
SetNDNCSDReferenceDomain(
    IN LDAP *        hldDomainNamingFsmo,
    IN WCHAR *       wszNDNC,
    IN WCHAR *       wszReferenceDomain
    )
/*++

Routine Description:


--*/
{
    ULONG            ulRet;

    LDAPModW *       pMod[4];
    LDAPModW         modRefDom;
    WCHAR *          pwszRefDom[2];
    WCHAR *          wszNDNCCR = NULL;


    assert(wszNDNC);
    assert(wszReferenceDomain);

    modRefDom.mod_op = LDAP_MOD_REPLACE;
    modRefDom.mod_type = L"msDS-SDReferenceDomain";
    pwszRefDom[0] = wszReferenceDomain;
    pwszRefDom[1] = NULL;
    modRefDom.mod_vals.modv_strvals = pwszRefDom;

    pMod[0] = &modRefDom;
    pMod[1] = NULL;

    ulRet = GetCrossRefDNFromNCDN(hldDomainNamingFsmo,
                                  wszNDNC, &wszNDNCCR);
    if(ulRet){
        return(ulRet);
    }
    assert(wszNDNCCR);

    ulRet = ldap_modify_ext_sW(hldDomainNamingFsmo,
                               wszNDNCCR,
                               pMod,
                               gpServerControls,
                               gpClientControlsRefs);

    if(wszNDNCCR) { LocalFree(wszNDNCCR); }

    return(ulRet);
}

ULONG
SetNCReplicationDelays(
    IN LDAP *        hldDomainNamingFsmo,
    IN WCHAR *       wszNC,
    IN INT           iFirstDSADelay,       // -1 is no value, less than -1 is delete value
    IN INT           iSubsequentDSADelay   // -1 is no value, less than -1 is delete value
    )
/*++

Routine Description:

    This sets the first and subsequent DSA notification delays.

Arguments:

    hldWin2kDC - Any Win2k DC.
    wszNC - THe NC to change the repl delays for.
    iFirstDSADelay - The

Return value:

    LDAP RESULT.

--*/
{
    ULONG            ulRet = ERROR_SUCCESS;
    ULONG            ulWorst = 0;
    LDAPModW *       ModArr[3];
    LDAPModW         FirstDelayMod;
    LDAPModW         SecondDelayMod;
    WCHAR            wszFirstDelay[30];
    WCHAR            wszSecondDelay[30];
    WCHAR *          pwszFirstDelayVals[2];
    WCHAR *          pwszSecondDelayVals[2];
    WCHAR *          wszCrossRefDN = NULL;
    ULONG            iMod = 0;

    assert(wszNC);
    assert(hldWin2kDC);

    ulRet = GetCrossRefDNFromNCDN(hldDomainNamingFsmo,
                                  wszNC,
                                  &wszCrossRefDN);
    if(ulRet != ERROR_SUCCESS){
        assert(wszCrossRefDN == NULL);
        return(ulRet);
    }
    assert(wszCrossRefDN);

    //
    // DO First DSA Notification Delay.
    //
    FirstDelayMod.mod_type = L"msDS-Replication-Notify-First-DSA-Delay";
    FirstDelayMod.mod_vals.modv_strvals = pwszFirstDelayVals;
    if(iFirstDSADelay > -1){
        // Some valid real number, so set the value
        ModArr[iMod] = &FirstDelayMod;
        iMod++;
        FirstDelayMod.mod_op = LDAP_MOD_REPLACE;
        _itow(iFirstDSADelay, wszFirstDelay, 10);
        pwszFirstDelayVals[0] = wszFirstDelay;
        pwszFirstDelayVals[1] = NULL;
    } else if(iFirstDSADelay < -1) {
        // Some negative number less than -1, so delete this value.
        ModArr[iMod] = &FirstDelayMod;
        iMod++;
        FirstDelayMod.mod_op = LDAP_MOD_DELETE;
        pwszFirstDelayVals[0] = NULL;
    } // else it equals -1, so don't replace or delete the value.

    //
    // DO Subsequent DSA Notification Delay.
    //
    SecondDelayMod.mod_type = L"msDS-Replication-Notify-Subsequent-DSA-Delay";
    SecondDelayMod.mod_vals.modv_strvals = pwszSecondDelayVals;
    if(iSubsequentDSADelay > -1){
        // Some valid real number, so set the value
        ModArr[iMod] = &SecondDelayMod;
        iMod++;
        SecondDelayMod.mod_op = LDAP_MOD_REPLACE;
        _itow(iSubsequentDSADelay, wszSecondDelay, 10);
        pwszSecondDelayVals[0] = wszSecondDelay;
        pwszSecondDelayVals[1] = NULL;
    } else if(iSubsequentDSADelay < -1) {
        // Some negative number less than -1, so delete this value.
        ModArr[iMod] = &SecondDelayMod;
        iMod++;
        SecondDelayMod.mod_op = LDAP_MOD_DELETE;
        pwszSecondDelayVals[0] = NULL;
    } // else it equals -1, so don't replace or delete the value.

    // NULL terminate the Mod List
    ModArr[iMod] = NULL;

    //
    // DO the actual modify
    //
    if(ModArr[0]){
        // There was at least one mod to do.
        ulRet = ldap_modify_ext_sW(hldDomainNamingFsmo,
                                   wszCrossRefDN,
                                   ModArr,
                                   gpServerControls,
                                   gpClientControlsRefs);
    }

    if(wszCrossRefDN) { LocalFree(wszCrossRefDN); }

    return(ulRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\clsfactory.cxx ===
#include <ntdspchx.h>
#pragma  hdrstop

#include "debug.h"
#define DEBSUB "CLSFACTORY:"


#include "NTDScript.h"
#include <tchar.h>



////////////////////////////
// helpers

HRESULT
FindDllPathFromCLSID( LPCTSTR pszCLSID, LPTSTR pBuf, DWORD cbBuf)
{
    HRESULT hr = S_OK;

    HKEY hCatalog   = NULL;
    HKEY hCLSID     = NULL;
    HKEY hInProc    = NULL;
    DWORD dwType;
    DWORD cbSize;

    if (ERROR_SUCCESS != ::RegOpenKeyEx( HKEY_CLASSES_ROOT, _T("CLSID"), 0, KEY_READ, &hCatalog))
    {
        DPRINT (0, "Unable to access registry\n");
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hCatalog, pszCLSID, 0, KEY_READ, &hCLSID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\CLSID\\%s\n", pszCLSID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hCLSID, _T("InProcServer32"), 0, KEY_READ, &hInProc))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    cbSize = cbBuf;
    if (ERROR_SUCCESS != ::RegQueryValueEx( hInProc, NULL, NULL, &dwType, (LPBYTE)pBuf, &cbSize))
    {
        DPRINT1 (0, "Unable to read registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    switch (dwType)
    {
    case REG_EXPAND_SZ:
        {
            TCHAR rgchTemp[1024];
            memcpy( rgchTemp, pBuf, cbSize*sizeof(TCHAR));
            ExpandEnvironmentStrings( rgchTemp, pBuf, sizeof(rgchTemp)/sizeof(rgchTemp[0]));
        }
        break;

    case REG_SZ:
        break;

    default:
        DPRINT1 (0, "Unable to understand registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    goto Cleanup;

Fail:
    ::RegCloseKey( hCatalog);
    ::RegCloseKey( hCLSID);
    ::RegCloseKey( hInProc);

    hr = E_FAIL;

Cleanup:
    return hr;
}


HRESULT
FindDllPathFromPROGID( LPCTSTR pszPROGID, LPTSTR pBuf, DWORD cbBuf)
{
    HRESULT hr = S_OK;

    HKEY hPROGID   = NULL;
    HKEY hCLSID     = NULL;
    TCHAR rgchCLSID[128];
    DWORD dwType;
    DWORD cbSize;

    if (ERROR_SUCCESS != ::RegOpenKeyEx( HKEY_CLASSES_ROOT, pszPROGID, 0, KEY_READ, &hPROGID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\%s \n", pszPROGID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hPROGID, _T("CLSID"), 0, KEY_READ, &hCLSID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\%s\\CLSID\n", pszPROGID);
        goto Fail;
    }

    cbSize = sizeof(rgchCLSID)/sizeof(rgchCLSID[0]);
    if (ERROR_SUCCESS != ::RegQueryValueEx( hCLSID, NULL, NULL, &dwType, (LPBYTE)rgchCLSID, &cbSize))
    {
        DPRINT1 (0, "Unable to read registry key HKCR\\%s\\CLSID \n", pszPROGID);
        goto Fail;
    }

    if (dwType != REG_SZ)
    {
        DPRINT1 (0, "Unable to understand registry key HKCR\\%s\\CLSID\n", pszPROGID);
        goto Fail;
    }

    hr = FindDllPathFromCLSID( rgchCLSID, pBuf, cbBuf);

    goto Cleanup;

Fail:
    ::RegCloseKey( hCLSID);
    ::RegCloseKey( hPROGID);

    hr = E_FAIL;

Cleanup:
    return hr;
}


class CClassFactoryWrapper : public IClassFactory
{
private:
    ULONG _ulRefs;
    HINSTANCE _hLibrary;
    IClassFactory * _pWrapped;

public:
    CClassFactoryWrapper( HINSTANCE hLibrary, IClassFactory * pWrap)
        : _ulRefs( 1), _hLibrary( hLibrary), _pWrapped( pWrap)
    {
    }

    ~CClassFactoryWrapper()
    {
        if (_pWrapped)
            _pWrapped->Release();
        ::FreeLibrary( _hLibrary);
    }

public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void ** ppv)
    {
        if (iid == IID_IUnknown || iid == IID_IClassFactory) 
        {
            *ppv = this;
            AddRef();
            return S_OK;    
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (ULONG)InterlockedIncrement((LPLONG)&_ulRefs);
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        ULONG ul = (ULONG)InterlockedDecrement((LPLONG)&_ulRefs);
        if (0 == ul)
            delete this;
        return ul;
    }

    // IClassFactory methods
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock)
    {
        if (_pWrapped)
            return _pWrapped->LockServer( fLock);
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE CreateInstance(
            IUnknown *pUnkOuter,
            REFIID iid,
            void **ppvObj)
    {
        if (_pWrapped)
            return _pWrapped->CreateInstance( pUnkOuter, iid, ppvObj);
        return E_FAIL;
    }
};

typedef HRESULT (__stdcall *FN_DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);

HRESULT GetClassFactory( REFCLSID clsid, IClassFactory ** ppFactory)
{
    HRESULT hr;
    TCHAR rgchDllPath[1024];
#ifdef UNICODE
    WCHAR rgszCLSID[128];
#else
    WCHAR rgwszCLSID[128];
    TCHAR rgszCLSID[128];
#endif

    HINSTANCE hLibrary = NULL;
    FN_DLLGETCLASSOBJECT fnDllGetClassObject = NULL;
    IClassFactory * pFactory = NULL;


#ifdef UNICODE
    StringFromGUID2( clsid, rgszCLSID, sizeof(rgszCLSID)/sizeof(rgszCLSID[0]));
#else
    StringFromGUID2( clsid, rgwszCLSID, sizeof(rgwszCLSID)/sizeof(rgwszCLSID[0]));
    ::WideCharToMultiByte( CP_ACP, NULL, rgwszCLSID, -1, rgszCLSID, sizeof(rgszCLSID)/sizeof(rgszCLSID[0]), NULL, NULL);
#endif

    if (FAILED(hr = FindDllPathFromCLSID( rgszCLSID, rgchDllPath, sizeof(rgchDllPath)/sizeof(rgchDllPath[0]))))
    {
        goto Failed;
    }

    hLibrary = ::LoadLibrary( rgchDllPath);
    if ( !hLibrary)
    {
        DPRINT1 (0, "failed to load dll: %s\n", rgchDllPath);
        hr = E_FAIL;
        goto Failed;
    }

    fnDllGetClassObject = (FN_DLLGETCLASSOBJECT)::GetProcAddress( hLibrary, "DllGetClassObject");
    if ( !fnDllGetClassObject)
    {
        DPRINT1 (0, "Unable to find \"DllGetClassObject\" export in dll: %s\n", rgchDllPath);
        hr = E_FAIL;
        goto Failed;
    }

    if (FAILED(hr = (*fnDllGetClassObject)( clsid, IID_IClassFactory, (void**)&pFactory)))
    {
        goto Failed;
    }

    *ppFactory = new CClassFactoryWrapper( hLibrary, pFactory);
    hr = S_OK;

    goto Cleanup;

Failed:
    if (hLibrary)
    {
        if (pFactory)
        {
            pFactory->Release();
            pFactory = NULL;
        }

        ::FreeLibrary( hLibrary);
        hLibrary = NULL;
    }

Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\ntdscript.h ===
//+-----------------------------------------------------------------------------
//
// NTDSriptUtils.hxx
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
//------------------------------------------------------------------------------
#ifndef __NTDSCRIPT_H
#define __NTDSCRIPT_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <list>

#include "ole2.h"
#include "msxml2.h"

#endif // __NTDSCRIPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\log.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Definitions and globals for internal only debug and support routines

Author:

Revision History:

--*/
#ifndef __DSLOG_H__
#define __DSLOG_H__

#define LOGFILE_NAME L"\\debug\\DEFAULTLOG.LOG"
#define BAKFILE_NAME L"\\debug\\DEFAULTLOG.BAK"

#define SCRIPT_LOGFILE_NAME L"\\debug\\SCRIPTLOG.LOG"
#define SCRIPT_BAKFILE_NAME L"\\debug\\SCRIPTLOG.BAK"


//
// This class implements the logging functionality 
//
// The user cannot instantiate an object of this class
// He has to go through the Factory Classes that expose 
// this functionality (ScriptLogger, etc)
// This is to control access / instantiation of objects of this class
//
class DsLogger 
{
friend class ScriptLogger;

public:
    DWORD Flush(void);
    VOID  Print(IN DWORD DebugFlag, IN LPSTR Format, ...);

private:
    DsLogger( WCHAR *LogFileName = LOGFILE_NAME, WCHAR *BakFileName = BAKFILE_NAME);
    ~DsLogger();

    DWORD Initialize(void);
    DWORD InitializeLogHelper(DWORD TimesCalled);
    void LockLogFile(void )   { RtlEnterCriticalSection( &LogFileCriticalSection ); }
    void UnlockLogFile (void) { RtlLeaveCriticalSection( &LogFileCriticalSection ); }
    DWORD Close(void);
    VOID  Print(IN DWORD DebugFlag, IN LPWSTR Format, va_list arglist);

    HANDLE m_LogFile;
    WCHAR  m_LogFileName[ MAX_PATH + 1 ];
    WCHAR  m_BakFileName[ MAX_PATH + 1 ];

    BOOL   m_BeginningOfLine;

    CRITICAL_SECTION LogFileCriticalSection;
};

// 
// This class implements the logging functionality for the Script Engine
// It controls access to the real logger
// It uses the Sigleton pattern to control access  (see Gamma et al)
// It uses the Factory pattern to control creation of DsLogger objects 
//
class ScriptLogger
{
public:
        static DsLogger * getInstance(void)
        {
            if (m_Logger) {
                return m_Logger;
            }
            else {
                return createLogger();
            }
        }

        static void Close() 
        {
          if (m_Logger) {
                delete m_Logger;
                m_Logger = NULL;
          }
        }

private:
    static DsLogger * m_Logger;

    ScriptLogger() {};
    static DsLogger *createLogger(void);
};


#define DS_VERBOSE_LOGGING

#define DSLOG_ERROR 0x00000001
#define DSLOG_WARN  0x00000002
#define DSLOG_TRACE 0x00000004

#ifdef DS_VERBOSE_LOGGING

extern "C" {
    extern ULONG gulScriptLoggerLogLevel;
}

#define DisplayOptional( y ) y ? y : L"(NULL)"
#define LogOnFailure( z, a ) if ( z != ERROR_SUCCESS ) a
#define LogOptional( z, a ) if ( z ) a

#ifdef DBG
#define ScriptLogLevel( z, a ) if ( z >= gulScriptLoggerLogLevel ) a
#else
#define ScriptLogLevel( z, a )
#endif

#define ScriptLogFlush() (ScriptLogger::getInstance())->Flush()
#define ScriptLogPrint( x )  (ScriptLogger::getInstance())->Print x
#define ScriptLogGuid( l, t, g )  g == NULL ? (ScriptLogger::getInstance())->Print( l, "%S (NULL)\n", t ) :       \
        (ScriptLogger::getInstance())->Print( l, "%S %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",          \
                        t,(g)->Data1,(g)->Data2,(g)->Data3,(g)->Data4[0],                       \
                        (g)->Data4[1],(g)->Data4[2],(g)->Data4[3],(g)->Data4[4],                \
                        (g)->Data4[5],(g)->Data4[6],(g)->Data4[7])

#define ScriptLogSid( l, t, s )                                                                 \
{ LPWSTR sidstring;                                                                             \
  ConvertSidToStringSidW( s, &sidstring );                                                      \
  (ScriptLogger::getInstance())->Print( l, "%S %ws\n", t, sidstring );                          \
  LocalFree(sidstring);                                                                         \
}


#else

#define DisplayOptional( y )
#define LogOnFailure( z, a )
#define LogOptional( z, a )
#define ScriptLogLevel( z, a )

#define ScriptLogFlush()
#define ScriptLogPrint( x )
#define ScriptLogGuid( l, t, g )
#define ScriptLogSid( l, t, s )
#define ScriptSetAndClearLog()
#define ScriptUnicodestringtowstr( s, u )
#endif

#endif // __SCRIPTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\log.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.cxx

Abstract:

    Implementation of the internal debug and support routines

Author:

    Marios Zikos

Environment:

    User Mode

Revision History:

    originally based on code from Colin Brace from DCPROMO

--*/

#include <ntdspchx.h>
#pragma  hdrstop

#include "log.h"

#include "debug.h"
#define DEBSUB "LOG:"
#define FILENO FILENO_LOG

#ifndef FLAG_ON
#define FLAG_ON(x, y)  ((y)==((x)&(y)))
#endif

#define UNICODE_BYTE_ORDER_MARK 0xFEFF

// initialize the static variable
//
DsLogger * ScriptLogger :: m_Logger = NULL;


// we need a crit sect for initialization purposes. use a well known one
extern "C" {
CRITICAL_SECTION csLoggingUpdate;
}

DsLogger *ScriptLogger :: createLogger(void)
{
    DsLogger *scriptLogger = NULL;

     if (!m_Logger) {
         EnterCriticalSection(&csLoggingUpdate);
         if (!m_Logger) {
             scriptLogger = new DsLogger (SCRIPT_LOGFILE_NAME, SCRIPT_BAKFILE_NAME);
             scriptLogger->Initialize();
             m_Logger = scriptLogger;
         }
         LeaveCriticalSection(&csLoggingUpdate);
     }
     return m_Logger;
}


DsLogger :: DsLogger (WCHAR *LogFileName, WCHAR *BakFileName)
{
    m_LogFile = NULL;
    m_BeginningOfLine = TRUE;

    if (LogFileName) {
        wcscpy (m_LogFileName, LogFileName);
    }
    else {
        wcscpy (m_LogFileName, LOGFILE_NAME);
    }

    if (BakFileName) {
        wcscpy (m_BakFileName, BakFileName);
    }
    else {
        wcscpy (m_BakFileName, LOGFILE_NAME);
    }

    InitializeCriticalSectionAndSpinCount(&LogFileCriticalSection, 4000);
}

DsLogger :: ~DsLogger ()
{
    Close();

    DeleteCriticalSection (&LogFileCriticalSection);
}

/*++

Routine Description:

    Initializes the debugging log file 
    
    N.B. This will not delete a previous log file; rather it will continue
    to use the same one.

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
DWORD DsLogger :: InitializeLogHelper(DWORD TimesCalled)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR LogFileName[ MAX_PATH + 1 ];
    WCHAR bakLogFileName[ MAX_PATH + 1 ];
    WCHAR cBOM = UNICODE_BYTE_ORDER_MARK;
    BOOLEAN fSuccess;

    Assert (TimesCalled <= 2 && L"MoveFile failed to move file but reported success.");

    if (TimesCalled > 2) {
        DPRINT1 (0, "MoveFile failed to move file but reported success.\n", dwErr );
        return ERROR_GEN_FAILURE;
    }

    LockLogFile();

    //
    // Construct the log file name
    //
    if ( !GetWindowsDirectoryW( LogFileName,
                                sizeof( LogFileName )/sizeof( WCHAR ) ) ) {

        dwErr = GetLastError();
        DPRINT1 (0, "GetWindowsDirectory failed with %lu\n", dwErr );
        goto Exit;
    }

    wcscat( LogFileName, m_LogFileName );
    DPRINT1 (0, "Logfile name: %ws\n", LogFileName );

    //
    // Open the file
    //
    m_LogFile = CreateFileW( LogFileName,
                             GENERIC_WRITE | GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if ( m_LogFile == INVALID_HANDLE_VALUE ) {

        dwErr = GetLastError();

        DPRINT2 ( 0, "CreateFile on %ws failed with %lu\n", LogFileName, dwErr );
        m_LogFile = NULL;
        goto Exit;
    }

    if ( ERROR_ALREADY_EXISTS != GetLastError() ) {
        // This is a unicode file so if it was just
        // created the Byte-order Mark needs to be
        // added to the beginning of the file.

        DWORD lpNumberOfBytesWritten = 0;

        if ( !WriteFile(m_LogFile,
                        (LPCVOID)&cBOM,
                        sizeof(WCHAR), 
                        &lpNumberOfBytesWritten,
                        NULL) )
        {
            dwErr = GetLastError();
            DPRINT2 (0, "WriteFile on %ws failed with %lu\n", LogFileName, dwErr );
            goto Exit;
        }

        Assert (lpNumberOfBytesWritten == sizeof(WCHAR));

    } else {
        // See if the opened file is UNICODE
        // if not move it and create a new file.
        WCHAR wcBuffer = 0;
        DWORD lpNumberOfBytesRead = 0;

        if ( !ReadFile(m_LogFile,
                       (LPVOID)&wcBuffer,
                       sizeof(WCHAR),
                       &lpNumberOfBytesRead,
                       NULL) ) 
        {
            dwErr = GetLastError();
            DPRINT2 (0, "ReadFile on %ws failed with %lu\n", LogFileName, dwErr );
            goto Exit;    
        }

        Assert (lpNumberOfBytesRead == sizeof(WCHAR));

        if (cBOM != wcBuffer) {
            // This is not a UNICODE FILE Move it.
            // Create a New Log

            //
            // Construct the bak log file name
            //
            if ( !GetWindowsDirectoryW( bakLogFileName,
                                        sizeof( bakLogFileName )/sizeof( WCHAR ) ) ) {
        
                dwErr = GetLastError();
                DPRINT1 (0, "GetWindowsDirectory failed with %lu\n", dwErr );
                goto Exit;
            }
            wcscat( bakLogFileName, m_BakFileName );
            DPRINT1 (0, "Logfile name: %ws\n", bakLogFileName );

            if ( m_LogFile ) {
        
                 CloseHandle( m_LogFile );
                 m_LogFile = NULL;
                
            }

            // move the file
            if ( !MoveFileW(LogFileName,                           
                           bakLogFileName) )
            {
                 dwErr = GetLastError();
                 DPRINT3 (0, "MoveFile From %ws to %ws failed with %lu\n",
                              LogFileName, bakLogFileName, dwErr);
                 goto Exit;
            }

            UnlockLogFile();

            return InitializeLogHelper(TimesCalled+1);
        
        }
    }

    // No longer need read access so reopen the file
    // with just write access.

    if ( m_LogFile ) {
        
         CloseHandle( m_LogFile );
         m_LogFile = NULL;
        
    }

    m_LogFile = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

    //
    // Goto to the end of the file
    //
    if( SetFilePointer( m_LogFile,
                        0, 0,
                        FILE_END ) == 0xFFFFFFFF ) {

        dwErr = GetLastError();
        DPRINT1 (0, "SetFilePointer failed with %lu\n", dwErr );
        goto Exit;
    }

    //
    // That's it
    //
    Assert( ERROR_SUCCESS == dwErr );

Exit:

    if ( (ERROR_SUCCESS != dwErr)
      && (NULL != m_LogFile)   ) {

        CloseHandle( m_LogFile );
        m_LogFile = NULL;
        
    }

    UnlockLogFile();

    return( dwErr );
}


DWORD DsLogger :: Initialize(void)
{
    DWORD dwErr;
    dwErr =  InitializeLogHelper(1);

    if (!dwErr) {
        Print (DSLOG_TRACE, "+++++++++++ Start Of Log Session ++++++++++++++++\n");
    }

    return dwErr;
}

DWORD DsLogger :: Close(void)
{
    DWORD dwErr = ERROR_SUCCESS;

    DPRINT (0, "Logging Close\n");

    LockLogFile();

    if (m_LogFile) {
        CloseHandle( m_LogFile );
        m_LogFile = NULL;
    }

    UnlockLogFile();

    return( dwErr );
}


VOID DsLogger :: Print (IN DWORD DebugFlag, 
                        IN LPWSTR Format, 
                        va_list arglist
                        )
{
    #define DebugDumpRoutine_BUFFERSIZE 1024

    WCHAR OutputBuffer[DebugDumpRoutine_BUFFERSIZE];
    ULONG length;
    DWORD BytesWritten;
    SYSTEMTIME SystemTime;
    //va_list arglist;


    //
    // If we don't have an open log file, just bail
    //
    if ( m_LogFile == NULL ) {

        return;
    }

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //


    if ( m_BeginningOfLine ) {

        CHAR  *Prolog;

        if ( FLAG_ON( DebugFlag, DSLOG_ERROR ) ) {
            Prolog = "[ERROR] ";
        } else if ( FLAG_ON( DebugFlag, DSLOG_WARN ) ) {
            Prolog = "[WARNING] ";
        } else if (  FLAG_ON( DebugFlag, DSLOG_TRACE ) ) {
            Prolog = "[INFO] ";
        } else {
            Prolog = "";
        }

        //
        // Put the timestamp at the begining of the line.
        //
        GetLocalTime( &SystemTime );
        length += (ULONG) _snwprintf( &OutputBuffer[length],
                                       DebugDumpRoutine_BUFFERSIZE-length-1,
                                     L"%02u/%02u %02u:%02u:%02u %S",
                                     SystemTime.wMonth,
                                     SystemTime.wDay,
                                     SystemTime.wHour,
                                     SystemTime.wMinute,
                                     SystemTime.wSecond,
                                     Prolog );
    }

    //
    // Put a the information requested by the caller onto the line
    //

    //va_start(arglist, Format);

    length += (ULONG) _vsnwprintf(&OutputBuffer[length],
                                 DebugDumpRoutine_BUFFERSIZE-length-1,
                                 Format, 
                                 arglist);
    

    m_BeginningOfLine = (length > 0 && OutputBuffer[length-1] == L'\n' );
    if ( m_BeginningOfLine ) {

        OutputBuffer[length-1] = L'\r';
        OutputBuffer[length] = L'\n';
        OutputBuffer[length+1] = L'\0';
        length++;
    }

    //va_end(arglist);

    Assert ( length <= sizeof( OutputBuffer ) / sizeof( WCHAR ) );

    //
    // Grab the lock
    //
    LockLogFile();

    //
    // Write the debug info to the log file.
    //
    if ( !WriteFile( m_LogFile,
                     OutputBuffer,
                     length*sizeof(WCHAR),
                     &BytesWritten,
                     NULL ) ) {

        DPRINT2 (0, "Log write of %ws failed with %lu\n", 
                 OutputBuffer, 
                 GetLastError());
    }

    DPRINT1(0, "%ws", OutputBuffer );

    //
    // Release the lock
    //
    UnlockLogFile();

    return;

}

VOID DsLogger :: Print(IN DWORD DebugFlag, 
                       IN LPSTR Format,
                       ...)
{
    PWCHAR WFormat = NULL;
    va_list arglist;
    DWORD WinErr = ERROR_SUCCESS;
    DWORD Bufsize = strlen(Format)+1;

    WFormat = (PWCHAR) malloc(Bufsize*sizeof(WCHAR));
    if ( WFormat ) {
        MultiByteToWideChar(CP_ACP,
                            0,
                            Format,
                            -1,
                            WFormat,
                            Bufsize
                            );
    } else {
        DPRINT1 (0, "Log write failed with %lu\n", ERROR_NOT_ENOUGH_MEMORY );
    }

    va_start(arglist, Format);

    if ( WFormat ) {
        Print( DebugFlag, WFormat, arglist );
    }
    
    va_end(arglist);

    if (WFormat) {
        free(WFormat);
    }
}

DWORD DsLogger :: Flush (void)
{
    DWORD dwErr = ERROR_SUCCESS;

    LockLogFile();

    if ( m_LogFile != NULL ) {

        if( SetFilePointer( m_LogFile,
                            0, 0,
                            FILE_END ) == 0xFFFFFFFF ) {

            dwErr = GetLastError();
        }

        if( FlushFileBuffers( m_LogFile ) == FALSE ) {

            dwErr = GetLastError();
        }
    }

    UnlockLogFile();

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\ntdscontent.h ===
// MyContent.h: interface for the MyContent class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _NTDSCONTENT_H
#define _NTDSCONTENT_H


#include <list>
#include "SAXContentHandlerImpl.h"

#define MAX_SCRIPT_NESTING_LEVEL 10
#define MAX_ATTRIBUTE_NAME_SIZE 128

#define SCRIPT_VERSION_WHISTLER 1
#define SCRIPT_VERSION_MAX_SUPPORTED SCRIPT_VERSION_WHISTLER
// the order of the enumerations is important
enum ScriptElementType {
    SCRIPT_ELEMENT_ATTRIBUTE = 0,
    SCRIPT_ELEMENT_NTDSASCRIPT = 1,
    SCRIPT_ELEMENT_ACTION,
    SCRIPT_ELEMENT_INSTR_START,   // mark start of instructions
    SCRIPT_ELEMENT_PREDICATE,
    SCRIPT_ELEMENT_CONDITION,
    SCRIPT_ELEMENT_CREATE,
    SCRIPT_ELEMENT_MOVE,
    SCRIPT_ELEMENT_UPDATE,
    SCRIPT_ELEMENT_INSTR_END     // mark end of instructions
};

enum ScriptElementStatus {
    SCRIPT_STATUS_NOT_SET = 0,
    SCRIPT_STATUS_PARSE_OK
};

// the mode the parse is executing
enum ScriptProcessMode {
    SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS = 0,
    SCRIPT_PROCESS_PREPROCESS_PASS = 1,
    SCRIPT_PROCESS_EXECUTE_PASS
};

// the names of all the nodes
#define NTDSASCRIPT_NTDSASCRIPT L"NTDSAscript"
#define NTDSASCRIPT_ACTION      L"action"
#define NTDSASCRIPT_PREDICATE   L"predicate"
#define NTDSASCRIPT_CONDITION   L"condition"
#define NTDSASCRIPT_IF          L"if"
#define NTDSASCRIPT_THEN        L"then"
#define NTDSASCRIPT_ELSE        L"else"
#define NTDSASCRIPT_CREATE      L"create"
#define NTDSASCRIPT_MOVE        L"move"
#define NTDSASCRIPT_UPDATE      L"update"
#define NTDSASCRIPT_TO          L"to"

// the names of all the attributes
#define NTDSASCRIPT_ATTR_ATTR          L"attribute"
#define NTDSASCRIPT_ATTR_ATTRVAL       L"attrval"
#define NTDSASCRIPT_ATTR_CARDINALITY   L"cardinality"
#define NTDSASCRIPT_ATTR_DEFAULTVAL    L"defaultvalue"
#define NTDSASCRIPT_ATTR_ERRMSG        L"errMessage"
#define NTDSASCRIPT_ATTR_FILTER        L"filter"
#define NTDSASCRIPT_ATTR_METADATA      L"metadata"
#define NTDSASCRIPT_ATTR_NAME          L"name"
#define NTDSASCRIPT_ATTR_OPERATION     L"op"
#define NTDSASCRIPT_ATTR_PATH          L"path"
#define NTDSASCRIPT_ATTR_RETCODE       L"returnCode"
#define NTDSASCRIPT_ATTR_STAGE         L"stage"
#define NTDSASCRIPT_ATTR_TESTTYPE      L"test"
#define NTDSASCRIPT_ATTR_SEARCHTYPE    L"type"
#define NTDSASCRIPT_ATTR_VERSION       L"version"

// the possible values of the attributes
#define NTDSASCRIPT_ACTION_STAGE_PREPROCESS   L"preprocess"
#define NTDSASCRIPT_ACTION_STAGE_EXECUTE      L"execute"

#define NTDSASCRIPT_ATTRVAL_SEARCHTYPE_BASE     L"base"
#define NTDSASCRIPT_ATTRVAL_SEARCHTYPE_ONELEVEL L"oneLevel"
#define NTDSASCRIPT_ATTRVAL_SEARCHTYPE_SUBTREE  L"subTree"

#define NTDSASCRIPT_ATTRVAL_TESTTYPE_AND          L"and"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_OR           L"or"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_NOT          L"not"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_TRUE         L"true"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_FALSE        L"false"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_COMPARE      L"compare"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_INSTANCIATED L"instantiated"
#define NTDSASCRIPT_ATTRVAL_TESTTYPE_CARDINALITY  L"cardinality"

#define NTDSASCRIPT_ATTRVAL_OPERATION_APPEND      L"append"
#define NTDSASCRIPT_ATTRVAL_OPERATION_REPLACE     L"replace"
#define NTDSASCRIPT_ATTRVAL_OPERATION_DELETE      L"delete"

// macros to set errors
#define ScriptParseError(x)  \
    ( ScriptParseErrorGen(DSID(FILENO,__LINE__), (x), 0))
     
#define ScriptParseErrorExt(x, d) \
    ( ScriptParseErrorGen(DSID(FILENO,__LINE__), (x), (d)))

#define ScriptParseErrorExtMsg(x, d, m) \
    ( ScriptParseErrorGen(DSID(FILENO,__LINE__), (x), (d), (m)))

// ============================================================================


//
// ScriptElement
//
// Abstract Base class for all script elements
//
class ScriptElement
{
public:
    ScriptElement(ScriptElementType type) 
                : m_type(type), 
                  m_characters(NULL), 
                  m_status(SCRIPT_STATUS_NOT_SET) { }
    virtual ~ScriptElement();

    // Event when we have characters for this element
    virtual DWORD SetCharacters (const WCHAR *pwchChars, int cchChars) = 0;

    // Event when we Push self onto stack of elements. 
    // pElement if the previous element on the stack
    virtual DWORD Push (ScriptElement *pElement) = 0;

    // Event when we Pop self from stack
    virtual DWORD Pop (void) = 0;

    // Event when an element is added under this element
    virtual DWORD AddElement (ScriptElement *pElement) = 0;

    // Event when we want to process the particular element
    virtual DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage) = 0;

    // get the class type of this element
    ScriptElementType getType()         { return m_type; }
        
public:
    ScriptElementType   m_type;         // the class type of this element 
    DWORD               m_status;       // the parse status of each element
    WCHAR              *m_characters;   // the characters included in this element
       
#if DBG
    void ptr(void);                     // dump the name of the element
#endif
};


//
// ScriptAttribute
//
// Encapsulates all the script elements that represent attributes
//
class ScriptAttribute : public ScriptElement
{
public:
    enum ScriptOperationType {
        SCRIPT_OPERATION_APPEND = 1,
        SCRIPT_OPERATION_REPLACE,
        SCRIPT_OPERATION_DELETE
    };

public:
    ScriptAttribute(const WCHAR *pwchLocalName, int cchLocalName, ISAXAttributes *pAttributes);

    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars);
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);
    DWORD AddElement (ScriptElement *pElement)   { return E_FAIL; }
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage) { return E_FAIL; }

    WCHAR               m_name[MAX_ATTRIBUTE_NAME_SIZE+1];  // the name of this attribute
    ScriptOperationType m_operation_type;   // type of operation (append, replace, delete)
};
typedef std::list<ScriptAttribute *> ScriptAttributeList;


//
// ScriptInstruction
//
// Acts as a common superclass of all the script elements that 
// represent instructions. 
// 
class ScriptInstruction : public ScriptElement
{
protected:
    // we don't want direct instantiation
    ScriptInstruction(ScriptElementType type) : ScriptElement(type) {}

public:
    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return E_FAIL; }
    DWORD Push (ScriptElement *pElement)         { return E_FAIL; }
    DWORD Pop (void)                             { return E_FAIL; }
    DWORD AddElement (ScriptElement *pElement)   { return E_FAIL; }
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage) { return E_FAIL; }
};
typedef std::list<ScriptInstruction *> ScriptInstructionList;


//
// ScriptPredicate
//
// Encapsulates the Predicate instruction
//
class ScriptPredicate : public ScriptInstruction
{
    enum ScriptSearchType {
        SCRIPT_SEARCH_TYPE_BASE = 0,    // SE_CHOICE_BASE_ONLY,
        SCRIPT_SEARCH_TYPE_ONE_LEVEL,   // SE_CHOICE_IMMED_CHLDRN,
        SCRIPT_SEARCH_TYPE_SUBTREE      // SE_CHOICE_WHOLE_SUBTREE
    };

    // NOTE if you change the order or add a new enumeration,
    // you should also fix testTypeNames array in ntdscontent.cxx
    enum ScriptTestType {
        SCRIPT_TEST_TYPE_UNDEFINED = 0,
        SCRIPT_TEST_TYPE_TRUE = 1,
        SCRIPT_TEST_TYPE_FALSE,
        SCRIPT_TEST_TYPE_AND,
        SCRIPT_TEST_TYPE_OR,
        SCRIPT_TEST_TYPE_NOT,
        SCRIPT_TEST_TYPE_COMPARE,
        SCRIPT_TEST_TYPE_INSTANCIATED,
        SCRIPT_TEST_TYPE_CARDINALITY
    };

public:
    ScriptPredicate(ISAXAttributes *pAttributes);
    virtual ~ScriptPredicate();

    // no op cause we get the newlines
    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);
    DWORD AddElement (ScriptElement *pElement);

    BOOL   GetResult();

public:
    ScriptTestType    m_test_type;   // type of test (compare, instantiated, cardinality)

    // the following are used by all tests
    WCHAR *m_search_path;            // the search path (DN)
    DSNAME *m_search_pathDN;         // the search path in DS format

    // the following are used for the cardinality test
    ScriptSearchType  m_search_type; // type of search (base, oneLevel, subTree)
    WCHAR *m_search_filter;          // the filter needed
    FILTER *m_search_filterDS;       // the filter in DS format
    DWORD  m_expected_cardinality;   // the expected number of entries that the filter
                                     // should find

    // the following are used for the compare test
    WCHAR *m_search_attribute;       // the attribute name involved (in compare)
    WCHAR *m_expected_attrval;       // the expected attribute value
    WCHAR *m_default_value;          // the default value if not present
    

    WCHAR *m_errMessage;             // the error message that should be logged
    DWORD  m_returnCode;             // the return code for the condition
    BOOL   m_result;                 // whether the condition evaluated to TRUE / FALSE
    
    ScriptInstructionList  m_predicates;
};


//
// ScriptMove
//
// Encapsulates the Move instruction
//
class ScriptMove : public ScriptInstruction
{
public:
    ScriptMove(ISAXAttributes *pAttributes);
    virtual ~ScriptMove();

    // no op cause we get the newlines
    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);

    DWORD ProcessTo(ISAXAttributes *pAttributes);
    
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);


    WCHAR  *m_path;         // the source path
    DSNAME *m_pathDN;       // the source path in DS format
    
    WCHAR  *m_topath;       // the destination path 
    DSNAME *m_topathDN;     // the destination path in DS format

    BOOL  m_metadata;      // flag whether to update metadata
};

//
// ScriptUpdate
//
// Encapsulates the Update instruction
//
class ScriptUpdate : public ScriptInstruction
{
public:
    ScriptUpdate(ISAXAttributes *pAttributes);
    virtual ~ScriptUpdate();

    // no op cause we get the newlines
    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);

    DWORD AddElement (ScriptElement *pElement);
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);

    ScriptAttributeList   m_attributes;
    WCHAR  *m_path;
    DSNAME *m_pathDN;
    BOOL  m_metadata;
};


//
// ScriptCreate
//
// Encapsulates the Update instruction
//
class ScriptCreate : public ScriptInstruction
{
public:
    ScriptCreate(ISAXAttributes *pAttributes);
    virtual ~ScriptCreate();

    // no op cause we get the newlines
    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);

    DWORD AddElement (ScriptElement *pElement);
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);

    ScriptAttributeList   m_attributes;
    WCHAR  *m_path;
    DSNAME *m_pathDN;
};



//
// ScriptAction
//
// Encapsulates the Action instruction
//
class ScriptAction : public ScriptElement
{
public:
    ScriptAction(ISAXAttributes *pAttributes);
    virtual ~ScriptAction();
    
    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);
    DWORD AddElement (ScriptElement *pElement);
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);

public:
    ScriptInstructionList  m_instructions;
    WCHAR                 *m_name;
    ScriptProcessMode      m_stage;     // the mode that this action is 
                                        // supposed to execute on.
};
typedef std::list<ScriptAction *> ScriptActionList;




//
// ScriptCondition
//
// Encapsulates the Condition instruction
//
class ScriptCondition : public ScriptInstruction
{
    enum ScriptIfState
    {
        SCRIPT_IFSTATE_NONE = 0,
        SCRIPT_IFSTATE_IF,
        SCRIPT_IFSTATE_THEN,
        SCRIPT_IFSTATE_ELSE
    };

public:
    ScriptCondition();
    ~ScriptCondition();

    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);

    DWORD ProcessIf(bool start, ISAXAttributes *pAttributes = NULL);
    DWORD ProcessThen(bool start, ISAXAttributes *pAttributes = NULL);
    DWORD ProcessElse(bool start, ISAXAttributes *pAttributes = NULL);

    DWORD AddElement (ScriptElement *pElement);
    
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);

public:
    ScriptPredicate   *m_predicate;
    ScriptAction      *m_thenAction;
    ScriptAction      *m_elseAction;

private:
    // used to track in what state of processing the condition is in
    //
    ScriptIfState m_ifstate;
};


//
// NTDSAscript
//
// Encapsulates the script
//
class NTDSAscript : public ScriptElement 
{
public:
    NTDSAscript (ISAXAttributes *pAttributes);
    ~NTDSAscript();

    DWORD SetCharacters (const WCHAR *pwchChars, int cchChars)  { return S_OK; }
    DWORD Push (ScriptElement *pElement);
    DWORD Pop (void);
    DWORD AddElement (ScriptElement *pElement);
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);

public:
    ScriptActionList m_actions;        // the list of all the actions in the script
    DWORD m_version;
};


//
// NTDSContent
//
// Implements the SAX Handler interface
// 
class NTDSContent : public SAXContentHandlerImpl  
{
public:
    NTDSContent();
    virtual ~NTDSContent();
    DWORD Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage);
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
        
        virtual HRESULT STDMETHODCALLTYPE endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName);

        virtual HRESULT STDMETHODCALLTYPE startDocument();

        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);

private:
        ScriptElement * getScriptElement (void);
        DWORD pushScriptElement (ScriptElement *pElement);
        DWORD popScriptElement (void);
        
        ScriptElement *m_Element[MAX_SCRIPT_NESTING_LEVEL];
        int m_lastElement;

        NTDSAscript *m_script;

public:        
        DWORD       m_error;
};


// Error handling function
DWORD ScriptParseErrorGen (DWORD dsid, DWORD dwErr, DWORD data, WCHAR *pmessage=NULL);

// The DS implementation of these requests
DWORD ScriptInstantiatedRequest (DSNAME *pObjectDN, BOOL *pfisInstantiated);
DWORD ScriptCompareRequest (DSNAME *pObjectDN, WCHAR *pAttribute, WCHAR *pAttrVal, WCHAR *pDefaultVal, BOOL *pfMatch);
DWORD ScriptCardinalityRequest (DSNAME *pObjectDN, DWORD searchType, FILTER *pFIlter, DWORD *pCardinality);
DWORD ScriptUpdateRequest (DSNAME *pObjectDN, ScriptAttributeList &attributeList, BOOL metadataUpdate);
DWORD ScriptCreateRequest (DSNAME *pObjectDN, ScriptAttributeList &attributeList);
DWORD ScriptMoveRequest (DSNAME *pObjectDN, DSNAME *pDestDN, BOOL metadataUpdate);


#endif // _NTDSCONTENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\ntdscriptutil.h ===
//+-----------------------------------------------------------------------------
//
// NTDSriptUtil.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
//------------------------------------------------------------------------------
#ifndef __NTDSCRIPTUTIL_H
#define __NTDSCRIPTUTIL_H

#include <ntdsa.h>

HRESULT GetClassFactory( REFCLSID clsid, IClassFactory ** ppFactory);

extern "C" {
    void *ScriptAlloc (size_t size);
    void ScriptFree (void *ptr);
    DWORD ScriptNameToDSName (WCHAR *pUfn, DWORD ccUfn, DSNAME **ppDN);
    DWORD ScriptStringToDSFilter (WCHAR *m_search_filter, FILTER **ppFilter);
}

#endif // __NTDSCRIPTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\ntdscontent.cxx ===
#include <ntdspchx.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <fileno.h>

#include "debug.h"
#define DEBSUB "NTDSCONTENT:"
#define FILENO FILENO_NTDSCRIPT_NTDSCONTENT

#include "NTDScript.h"
#include "NTDScriptUtil.h"
#include "NTDSContent.h"
#include <stdio.h>
#include "log.h"

#ifdef DBG
    int ntdscript_idnt;
#endif


// ============================================================================
//

ScriptElement :: ~ScriptElement()
{
    if (m_characters) {
        ScriptFree (m_characters);
        m_characters = NULL;
    }
}

#if DBG
void ScriptElement :: ptr (void) 
{
    switch (m_type) {
    case SCRIPT_ELEMENT_PREDICATE:
        DPRINT(1, "<Predicate/>\n");
        break;

    case SCRIPT_ELEMENT_CONDITION:
        DPRINT(1, "<Condition/>\n");
        break;

    case SCRIPT_ELEMENT_MOVE:
        DPRINT(1, "<Move/>\n");
        break;

    case SCRIPT_ELEMENT_UPDATE:
        DPRINT(1, "<Update/>\n");
        break;

    case SCRIPT_ELEMENT_CREATE:
        DPRINT(1, "<Create/>\n");
        break;

    default:
        DPRINT1(1, "<Instruction Type=\"%d\"/>\n", m_type);
        break;
    }
}
#endif

// ============================================================================
//

NTDSAscript :: NTDSAscript (ISAXAttributes *pAttributes) : ScriptElement(SCRIPT_ELEMENT_NTDSASCRIPT)
{
    int    num;
    WCHAR *pVal = NULL, *pStopVal;

    m_status = SCRIPT_STATUS_PARSE_OK;
    m_version = SCRIPT_VERSION_WHISTLER;

    // parse attributes
    pAttributes->getLength(&num);
    for ( int i=0; i<num; i++ ) {
        const wchar_t * name, * value; 
        int nameLen, valueLen;

        pAttributes->getLocalName(i, &name, &nameLen); 
        pAttributes->getValue(i, &value, &valueLen);       

        pVal = (WCHAR *)ScriptAlloc ((valueLen+1)*sizeof (WCHAR));
        if (pVal) {
            memcpy (pVal, value, valueLen*sizeof (WCHAR));
            pVal[valueLen]=0;
        }
        else {
            m_status = ScriptParseError(ERROR_OUTOFMEMORY);
            break;
        }

        if (wcsncmp(NTDSASCRIPT_ATTR_VERSION, name, nameLen) == 0) {

            m_version = wcstol (value, &pStopVal, 10);
            ScriptFree (pVal); pVal = NULL;

        }
        else {
            #if DBG
                WCHAR tname[100];

                wcsncpy( tname, name, nameLen > 100 ? 99 : nameLen ); 
                tname[nameLen > 100 ? 99 : nameLen] = 0;

                ScriptLogPrint ( (DSLOG_ERROR, "Unknown XML Attribute: %ws\n", tname));
            #endif
            
            m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            break;
        }

        Assert (!pVal);
    }

    if (pVal) {
        ScriptFree (pVal);
    }

    DPRINT1 (1, "NTDSAscript: version: %d\n", m_version);
}


NTDSAscript :: ~NTDSAscript()
{
    DPRINT (1, "Destroying NTDSAscript\n");
    ScriptActionList::iterator it = m_actions.begin();
    ScriptAction *pAction;

    while (it != m_actions.end()) {

        pAction = *it;
        m_actions.erase ( it++ );

        delete pAction;
    }
}

DWORD NTDSAscript :: Push (ScriptElement *pElement)
{
    DPRINT2 (1, "<NTDSAScript>%*s\n", (ntdscript_idnt = 1) , "");

    // this should be first level element
    if (pElement != NULL) {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

DWORD NTDSAscript :: Pop (void) 
{
    DPRINT2 (1, "/<NTDSAScript>%*s\n", (ntdscript_idnt = 0) , "");

    return S_OK;
}

DWORD NTDSAscript :: AddElement (ScriptElement *pElement)
{
    ScriptElementType type = pElement->getType();

    // we accept only Action elements
    if (type == SCRIPT_ELEMENT_ACTION) {

        ScriptAction *pAction = (ScriptAction *)pElement;

        m_actions.push_back (pAction);
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}


DWORD NTDSAscript :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "NTDSAScript: Processing\n") ) );

    DWORD err = S_OK;
    ScriptActionList::iterator it = m_actions.begin();
    ScriptAction *pAction;

    returnCode = 0;

    if (m_version > SCRIPT_VERSION_MAX_SUPPORTED) {
        
        ScriptLogPrint ( (DSLOG_ERROR, "Script Version (%d) Not Supported. Max Supported (%d) \n", 
                          m_version, SCRIPT_VERSION_MAX_SUPPORTED) );        
        
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    // iterate over all actions
    while (it != m_actions.end()) {
        
        pAction = *it++;

        // execute each one
        if ((err = pAction->Process(fMode, returnCode, ppErrorMessage)) || returnCode) {
            // and bail if one failed
            break;
        }
    }

    return err;
}

// ============================================================================
//

ScriptAttribute :: ScriptAttribute(const WCHAR *pwchName, 
                                   int cchName, 
                                   ISAXAttributes *pAttributes) : 
                    ScriptElement(SCRIPT_ELEMENT_ATTRIBUTE)
{
    int    num;
    m_status = SCRIPT_STATUS_PARSE_OK;

    // default operation should be append
    m_operation_type = SCRIPT_OPERATION_APPEND;

    // parse attributes
    pAttributes->getLength(&num);
    for ( int i=0; i<num; i++ ) {
        const wchar_t * name, * value; 
        int nameLen, valueLen;

        pAttributes->getLocalName(i, &name, &nameLen); 
        pAttributes->getValue(i, &value, &valueLen);       

        if (wcsncmp(NTDSASCRIPT_ATTR_OPERATION, name, nameLen) == 0) {

            if (wcsncmp(NTDSASCRIPT_ATTRVAL_OPERATION_APPEND, value, valueLen) == 0) {
                m_operation_type = SCRIPT_OPERATION_APPEND;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_OPERATION_REPLACE, value, valueLen) == 0) {
                m_operation_type = SCRIPT_OPERATION_REPLACE;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_OPERATION_DELETE, value, valueLen) == 0) {
                m_operation_type = SCRIPT_OPERATION_DELETE;
            }
            else {
                #if DBG
                    WCHAR tname[100];
                
                    wcsncpy( tname, name, nameLen > 100 ? 99 : nameLen ); 
                    tname[nameLen > 100 ? 99 : nameLen] = 0;

                    ScriptLogPrint ( (DSLOG_ERROR, "Unknown XML Attribute: %ws\n", tname));

                #endif

                m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }
        }
        else {
            #if DBG
                WCHAR tname[100];

                wcsncpy( tname, name, nameLen > 100 ? 99 : nameLen ); 
                tname[nameLen > 100 ? 99 : nameLen] = 0;

                ScriptLogPrint ( (DSLOG_ERROR, "Unknown XML Attribute: %ws\n", tname));
            
            #endif
            
            m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            break;
        }
    }

    cchName = cchName > MAX_ATTRIBUTE_NAME_SIZE ? MAX_ATTRIBUTE_NAME_SIZE : cchName;
    wcsncpy( m_name, pwchName, cchName ); m_name[cchName] = 0;
}

DWORD ScriptAttribute :: Push (ScriptElement *pElement)
{
    DPRINT3 (1,  "%*s<%ws>\n",3 * ntdscript_idnt++, "", m_name);
    return S_OK;
}

DWORD ScriptAttribute :: Pop (void)
{
    DPRINT3 (1,  "%*s</%ws>\n",3 * --ntdscript_idnt, "", m_name);
    return S_OK;
}

DWORD ScriptAttribute :: SetCharacters (const WCHAR *pwchChars, int cchChars)
{
    Assert (!m_characters);
    
    if (!m_characters) {
        m_characters = (WCHAR *)ScriptAlloc ((cchChars+1)*sizeof (WCHAR));

        if (m_characters) {
            memcpy (m_characters, pwchChars, cchChars*sizeof (WCHAR)); 
            m_characters[cchChars]=0;
        }
    }

    if (m_characters) {
        return S_OK;
    }
    return ScriptParseError(ERROR_OUTOFMEMORY);
}

// ============================================================================
//

ScriptAction :: ScriptAction(ISAXAttributes *pAttributes)
                    : ScriptElement(SCRIPT_ELEMENT_ACTION)
{
	int num;

    m_name = NULL;
    m_status = SCRIPT_STATUS_PARSE_OK;
    m_stage = SCRIPT_PROCESS_EXECUTE_PASS;

	pAttributes->getLength(&num);
	for ( int i=0; i<num; i++ ) {
        const wchar_t * name, * value; 
        int nameLen, valueLen;

		pAttributes->getLocalName(i, &name, &nameLen); 
		pAttributes->getValue(i, &value, &valueLen);       

        if (wcsncmp(NTDSASCRIPT_ATTR_NAME, name, nameLen) == 0 && !m_name) {

            m_name = (WCHAR *)ScriptAlloc ((valueLen+1)*sizeof (WCHAR));
            if (m_name) {
                memcpy (m_name, value, valueLen*sizeof (WCHAR));
                m_name[valueLen]=0;
            }
            else {
                m_status = ScriptParseError(ERROR_OUTOFMEMORY);
                break;
            }
        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_STAGE, name, nameLen) == 0) {

            if (wcsncmp(NTDSASCRIPT_ACTION_STAGE_PREPROCESS, value, valueLen) == 0) {
                m_stage = SCRIPT_PROCESS_PREPROCESS_PASS;
            }
            else if (wcsncmp(NTDSASCRIPT_ACTION_STAGE_EXECUTE, value, valueLen) == 0) {
                m_stage = SCRIPT_PROCESS_EXECUTE_PASS;
            }
            else {
                m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }
        }
        else {
            #if DBG
                WCHAR tname[100];

                wcsncpy( tname, name, nameLen > 100 ? 99 : nameLen ); 
                tname[nameLen > 100 ? 99 : nameLen] = 0;

                ScriptLogPrint ( (DSLOG_ERROR, "Unknown XML Attribute: %ws\n", tname));
            #endif
            
            m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            break;
        }
	}
}

ScriptAction :: ~ScriptAction()
{
    ScriptInstructionList::iterator it = m_instructions.begin();
    ScriptInstruction *pInstr;

    while (it != m_instructions.end()) {

        pInstr = *it;
        m_instructions.erase ( it++ );

        delete pInstr;
    }

    ScriptFree (m_name);
}

DWORD ScriptAction :: Push (ScriptElement *pElement)
{
    DPRINT2 (1,  "%*s<action>\n",3 * ntdscript_idnt++, "");

    return S_OK;
}

DWORD ScriptAction :: Pop (void)
{
    DPRINT2 (1, "%*s</action>\n",3 * --ntdscript_idnt, "");

    return S_OK;
}

DWORD ScriptAction :: AddElement (ScriptElement *pElement)
{
    // an action can contain only ScriptInstructions
    ScriptElementType type = pElement->getType();

    // we could do the following if we enable run type type checking /GR option
    // the dynamic_cast does the trick of testing for the correct class
    // ScriptInstruction *pInstr = dynamic_cast<ScriptInstruction *>(pElement);
    // until then:

    if (type > SCRIPT_ELEMENT_INSTR_START && 
        type < SCRIPT_ELEMENT_INSTR_END) {

        ScriptInstruction *pInstr = (ScriptInstruction *)pElement;

        m_instructions.push_back (pInstr);
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }
    
    return S_OK;
}

DWORD ScriptAction :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    DWORD err = S_OK;
    ScriptInstructionList::iterator it = m_instructions.begin();
    ScriptInstruction *pInstr;

    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Action Processing (%ws)\n", m_name) ) );

    // no processing done  if this action only for the preprocessing pass
    if (fMode == SCRIPT_PROCESS_EXECUTE_PASS &&
        m_stage == SCRIPT_PROCESS_PREPROCESS_PASS) {
        return err;
    }

    // iterate over all instructions
    while (it != m_instructions.end()) {

        pInstr = *it++;

        // execute each one
        if ((err = pInstr->Process(fMode, returnCode, ppErrorMessage)) || returnCode) {
            // and bail if one failed
            break;
        }
    }

    return err;
}

// ============================================================================
//

ScriptCondition :: ScriptCondition() : 
                    ScriptInstruction(SCRIPT_ELEMENT_CONDITION)
{
    m_thenAction = m_elseAction = NULL;
    m_predicate = NULL;
    m_ifstate = SCRIPT_IFSTATE_NONE;
}

ScriptCondition :: ~ScriptCondition()
{
    DPRINT (1, "Destroying Condition\n");
    if (m_predicate) delete m_predicate;
    if (m_thenAction) delete m_thenAction;
    if (m_elseAction) delete m_elseAction;
}

DWORD ScriptCondition :: Push (ScriptElement *pElement)
{
    DPRINT2 (1, "%*s<condition>\n",3 * ntdscript_idnt++, "");

    return S_OK;
}

DWORD ScriptCondition :: AddElement (ScriptElement *pElement)
{
    ScriptElementType type = pElement->getType();

    if (type == SCRIPT_ELEMENT_ACTION) {
        if ((m_ifstate == SCRIPT_IFSTATE_THEN) && 
            (m_thenAction == NULL) ) {

            m_thenAction = (ScriptAction *)pElement;

        }
        else if ((m_ifstate == SCRIPT_IFSTATE_ELSE) && 
                 (m_elseAction == NULL)) {

            m_elseAction = (ScriptAction *)pElement;

        }
        else {
            return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }

    } else if ((type == SCRIPT_ELEMENT_PREDICATE) && 
               (m_ifstate == SCRIPT_IFSTATE_IF) &&
               (m_predicate == NULL) ) {

        m_predicate = (ScriptPredicate *)pElement;

    } else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    } 

    return S_OK;
}

DWORD ScriptCondition :: Pop (void)
{
    DPRINT2 (1, "%*s</condition>\n", 3 * --ntdscript_idnt, "");

    return S_OK;
}

DWORD ScriptCondition :: ProcessIf(bool start, ISAXAttributes *pAttributes)
{
    DPRINT3 (1, "%*s<if%c>\n",3 * ntdscript_idnt, "", start ? ' ' : '/');

    if (m_ifstate == SCRIPT_IFSTATE_NONE && start) {
        m_ifstate = SCRIPT_IFSTATE_IF;
    }
    else if (m_ifstate == SCRIPT_IFSTATE_IF && !start) {
        m_ifstate = SCRIPT_IFSTATE_NONE;
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

DWORD ScriptCondition :: ProcessThen(bool start, ISAXAttributes *pAttributes)
{
    DPRINT3 (1, "%*s<then%c>\n",3 * ntdscript_idnt, "", start ? ' ' : '/');

    if (m_ifstate == SCRIPT_IFSTATE_NONE && start) {
        m_ifstate = SCRIPT_IFSTATE_THEN;
    }
    else if (m_ifstate == SCRIPT_IFSTATE_THEN && !start) {
        m_ifstate = SCRIPT_IFSTATE_NONE;
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

DWORD ScriptCondition :: ProcessElse(bool start, ISAXAttributes *pAttributes)
{
    DPRINT3 (1, "%*s<else%c>\n",3 * ntdscript_idnt, "", start ? ' ' : '/');

    if (m_ifstate == SCRIPT_IFSTATE_NONE && start) {
        m_ifstate = SCRIPT_IFSTATE_ELSE;
    }
    else if (m_ifstate == SCRIPT_IFSTATE_ELSE && !start) {
        m_ifstate = SCRIPT_IFSTATE_NONE;
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

DWORD ScriptCondition :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Condition Processing\tIF/%s%s\n", m_thenAction?"THEN":"",m_elseAction?"/ELSE":"") ) );

    DWORD err = S_OK;
    DWORD fakeRetCode;
    const WCHAR *pFakeErrMessage = NULL;

    Assert (m_ifstate == SCRIPT_IFSTATE_NONE);

    do {
        // we need to have a condition, a then, and not be in the middle of processing
        if (m_ifstate != SCRIPT_IFSTATE_NONE || !m_predicate || !m_thenAction) {
            err = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            break;
        }

        // we are not interested in the returnCode in the IF case
        // we just want to succeed processing it
        if (err = m_predicate->Process(fMode, fakeRetCode, &pFakeErrMessage)) {
            ScriptLogLevel (0, ScriptLogPrint ( (DSLOG_TRACE, "Error Processing IF Predicate: %d\n", err) ) );
            break;
        }

        // just validating
        if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS) {

            // while validating we have to do both parts (then/else)

            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Processing Condition: THEN\n") ) );
            if ((err = m_thenAction->Process(fMode, returnCode, ppErrorMessage)) || returnCode) {
                break;
            }
            if (m_elseAction) {
                ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Processing Condition: ELSE\n") ) );
                if ((err = m_elseAction->Process(fMode, returnCode, ppErrorMessage)) || returnCode) {
                    break;
                }
            }
        }
        else {
            // process the if - then - else
            if (m_predicate->GetResult()) {
                ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Processing Condition: THEN\n") ) );

                if ((err = m_thenAction->Process(fMode, returnCode, ppErrorMessage)) || returnCode) {
                    break;
                }
            }
            else if (m_elseAction) {
                ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Processing Condition: ELSE\n") ) );

                if ((err = m_elseAction->Process(fMode, returnCode, ppErrorMessage)) || returnCode) {
                    break;
                }
            }
        }

    } while ( 0 );

    return err;
}

// ============================================================================
//

ScriptPredicate :: ScriptPredicate(ISAXAttributes *pAttributes) : 
                    ScriptInstruction(SCRIPT_ELEMENT_PREDICATE)
{
	int    num;
    WCHAR *pVal = NULL, *pStopVal;

    m_status = SCRIPT_STATUS_PARSE_OK;
    m_result = FALSE;

    // initialize data
    m_search_type = SCRIPT_SEARCH_TYPE_BASE;
    m_test_type = SCRIPT_TEST_TYPE_UNDEFINED;
    m_search_path = m_search_filter = m_search_attribute = 
        m_expected_attrval = m_default_value = m_errMessage = NULL;
    m_expected_cardinality = 0;
    m_returnCode = 0;

    // parse attributes
	pAttributes->getLength(&num);

	for ( int i=0; i<num; i++ ) {
        const wchar_t * name, * value; 
        int nameLen, valueLen;

		pAttributes->getLocalName(i, &name, &nameLen); 
		pAttributes->getValue(i, &value, &valueLen);       

        pVal = (WCHAR *)ScriptAlloc ((valueLen+1)*sizeof (WCHAR));
        if (pVal) {
            memcpy (pVal, value, valueLen*sizeof (WCHAR));
            pVal[valueLen]=0;
        }
        else {
            m_status = ScriptParseError(ERROR_OUTOFMEMORY);
            break;
        }

        if (wcsncmp(NTDSASCRIPT_ATTR_SEARCHTYPE, name, nameLen) == 0) {

            if (wcsncmp(NTDSASCRIPT_ATTRVAL_SEARCHTYPE_BASE, value, valueLen) == 0) {
                m_search_type = SCRIPT_SEARCH_TYPE_BASE;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_SEARCHTYPE_ONELEVEL, value, valueLen) == 0) {
                m_search_type = SCRIPT_SEARCH_TYPE_ONE_LEVEL;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_SEARCHTYPE_SUBTREE, value, valueLen) == 0) {
                m_search_type = SCRIPT_SEARCH_TYPE_SUBTREE;
            }
            else {
                m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }

            ScriptFree (pVal); pVal = NULL;
        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_TESTTYPE, name, nameLen) == 0) {

            if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_COMPARE, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_COMPARE;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_INSTANCIATED, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_INSTANCIATED;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_CARDINALITY, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_CARDINALITY;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_TRUE, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_TRUE;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_FALSE, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_FALSE;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_AND, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_AND;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_OR, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_OR;
            }
            else if (wcsncmp(NTDSASCRIPT_ATTRVAL_TESTTYPE_NOT, value, valueLen) == 0) {
                m_test_type = SCRIPT_TEST_TYPE_NOT;
            }
            else {
                m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }
            ScriptFree (pVal); pVal = NULL;
        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_PATH, name, nameLen) == 0 && !m_search_path) {

            m_search_path = pVal; pVal = NULL;

            if (ScriptNameToDSName (m_search_path, valueLen, &m_search_pathDN)) {
                m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }
            
        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_FILTER, name, nameLen) == 0 && !m_search_filter) {
            
            m_search_filter = pVal; pVal = NULL;

            if (ScriptStringToDSFilter (m_search_filter, &m_search_filterDS)) {
                m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }

        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_ATTR, name, nameLen) == 0 && !m_search_attribute) {

            m_search_attribute = pVal; pVal = NULL;

        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_ATTRVAL, name, nameLen) == 0 && !m_expected_attrval) {

            m_expected_attrval = pVal; pVal = NULL;

        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_DEFAULTVAL, name, nameLen) == 0 && !m_default_value) {

            m_default_value = pVal; pVal = NULL;

        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_ERRMSG, name, nameLen) == 0 && !m_errMessage) {

            m_errMessage = pVal; pVal = NULL;

        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_CARDINALITY, name, nameLen) == 0 && !m_expected_cardinality) {

             m_expected_cardinality = wcstol (pVal, &pStopVal, 10);
             ScriptFree (pVal); pVal = NULL;

        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_RETCODE, name, nameLen) == 0) {

            m_returnCode = wcstol (pVal, &pStopVal, 10);
            ScriptFree (pVal); pVal = NULL;

        }
        else {
            #if DBG
                WCHAR tname[100];

                wcsncpy( tname, name, nameLen > 100 ? 99 : nameLen ); 
                tname[nameLen > 100 ? 99 : nameLen] = 0;

                ScriptLogPrint ( (DSLOG_ERROR, "Unknown XML Attribute: %ws\n", tname));

            #endif

            m_status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            break;
        }

        Assert (!pVal);
	}

    if (pVal) {
        ScriptFree (pVal);
    }
}

ScriptPredicate :: ~ScriptPredicate()
{
    DPRINT (1, "Destroying Predicate\n");
    ScriptFree (m_search_path);
    ScriptFree (m_search_filter);
    ScriptFree (m_search_attribute);
    ScriptFree (m_expected_attrval);
    ScriptFree (m_default_value);
    ScriptFree (m_errMessage);

    //m_search_pathDN
    //m_search_filterDS
}

DWORD ScriptPredicate :: Push (ScriptElement *pElement)
{
    DPRINT2 (1, "%*s<predicate>\n",3 * ntdscript_idnt++, "");
    
    return S_OK;
}

DWORD ScriptPredicate :: Pop (void)
{
    DPRINT2 (1, "%*s</predicate>\n",3 * --ntdscript_idnt, "");

    return S_OK;
}

DWORD ScriptPredicate :: AddElement (ScriptElement *pElement)
{
    ScriptElementType type = pElement->getType();

    // we accept only Predicate elements
    if (type == SCRIPT_ELEMENT_PREDICATE) {

        // handle nesting of predicates
        if (m_test_type == SCRIPT_TEST_TYPE_AND ||
            m_test_type == SCRIPT_TEST_TYPE_OR ||
            m_test_type == SCRIPT_TEST_TYPE_NOT) {
            
            // the NOT can only have one nested statement
            if (m_test_type == SCRIPT_TEST_TYPE_NOT) {
                if (m_predicates.size() > 0) {
                    return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                }
            }

            ScriptPredicate *pPredicate = (ScriptPredicate *)pElement;

            m_predicates.push_back (pPredicate);
        }
        else {
            return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

#ifdef DBG

WCHAR *testTypeNames[] = {
        L"UNDEFINED",
        L"TRUE",
        L"FALSE",
        L"AND",
        L"OR",
        L"NOT",
        L"COMPARE",
        L"INSTANCIATED",
        L"CARDINALITY"
};

#endif

//
// ScriptPredicate :: Process
//
//
// every predicate that we support returns TRUE or FALSE in the m_result
// which is retrieved by calling GetResult()
//
// TRUE means that the operation succeeded:
//   compare (value matches specified value or default if value not exists)
//   cardinality (number of objects that the search evaluates equals supplied number) 
//   instantiated (object supplied is instantiated)
//   true (the always true predicate).
//   
// FALSE means that the operation failed the evaluation (or was a false predicate)
//   in this case, the m_result member is set to the user supplied value
//
// The combination of the simple predicates (compare, cardinality, instantiated, true, false)
// with the AND, OR, NOT gives you more flexibility to express the expression 
// you want.
//
// If the expression evaluates to FALSE, the corresponding m_result is set
// to the value supplied by the user for the particular predicate, or if not supplied
// to the one that propagated up from the evaluation of the nested predicates.
//
DWORD ScriptPredicate :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    DWORD err = S_OK;
    m_result = FALSE;
    returnCode = 0;
    *ppErrorMessage = NULL;

    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, 
            "Predicate: Processing\n\t\t\ttype: %ws\n\t\t\tpath:%ws\n\t\t\tfilter:%ws\n\t\t\tattribute:%ws\n\t\t\tattrval:%ws\n\t\t\tdefaultValue:%ws\n\t\t\terrMsg:%ws\n\t\t\tcardinal:%d\n\t\t\tretCode:%d\n",
            testTypeNames[m_test_type],
            m_search_path, 
            m_search_filter ? m_search_filter : L"",
            m_search_attribute ? m_search_attribute : L"",
            m_expected_attrval ? m_expected_attrval : L"",
            m_default_value ? m_default_value : L"", 
            m_errMessage ? m_errMessage : L"",
            m_expected_cardinality,
            m_returnCode
           ) ) );


    if (m_test_type == SCRIPT_TEST_TYPE_UNDEFINED) {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    switch (m_test_type) {

    case SCRIPT_TEST_TYPE_TRUE:
        ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: TRUE" ) ) );
        m_result = TRUE;
        // we don't set the returnCode for a TRUE statement

        break;

    case SCRIPT_TEST_TYPE_FALSE:
        ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: FALSE" ) ) );
        m_result = FALSE;
        returnCode = m_returnCode;
        *ppErrorMessage = m_errMessage;
        break;

    case SCRIPT_TEST_TYPE_AND:
        {
            ScriptInstructionList::iterator it = m_predicates.begin();
            ScriptPredicate *pPred;
            BOOL            andResult = TRUE;
            
            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: AND" ) ) );

            // iterate over all instructions
            while (it != m_predicates.end()) {

                pPred = (ScriptPredicate *)*it++;

                // execute each one. if one fails, will set the m_result to false
                // and possibly set the returnCode
                if (err = pPred->Process(fMode, returnCode, ppErrorMessage)) {
                    // and bail if one failed
                    andResult = FALSE;
                    m_result = FALSE;
                    break;
                }

                // this is an AND. if one fails, we bail with FALSE
                if (pPred->GetResult() == FALSE) {
                    m_result = FALSE;
                    andResult = FALSE;

                    // the error code we provide takes precedence
                    if (m_returnCode) {
                        returnCode = m_returnCode;
                        *ppErrorMessage = m_errMessage;
                    }
                    break;
                }
            }
            // so we succeeded. we don't set the returnCode
            if (andResult) {
                m_result = TRUE;
                returnCode = 0;
                *ppErrorMessage = NULL;
            }
            if (err) {
                ScriptParseErrorExtMsg (err, returnCode, m_errMessage);
            }
            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: AND. res=%d retCode=%d(0x%x) ", m_result, returnCode, returnCode ) ) );
        }
        break;

    case SCRIPT_TEST_TYPE_OR:
        {
            ScriptInstructionList::iterator it = m_predicates.begin();
            ScriptPredicate *pPred;
            BOOL            orResult = FALSE;

            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: OR" ) ) );
            
            // iterate over all instructions
            while (it != m_predicates.end()) {

                pPred = (ScriptPredicate *)*it++;

                // execute each one. if one fails, will set the m_result to false
                // and possibly set the returnCode
                if (err = pPred->Process(fMode, returnCode, ppErrorMessage)) {
                    // and bail if one failed
                    break;
                }

                // this is an OR. if one succeeds, we bail with TRUE
                //
                if (pPred->GetResult() == TRUE) {
                    m_result = TRUE;
                    orResult = TRUE;
                    break;
                }
            }

            // so we didn't succeed. we set the returnCode
            if (!orResult) {
                m_result = FALSE;
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
            }
            else {
                returnCode = 0;
                *ppErrorMessage = NULL;
            }

            if (err) {
                ScriptParseErrorExtMsg (err, returnCode, m_errMessage);
            }

            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: OR. res=%d retCode=%d(0x%x) ", m_result, returnCode, returnCode ) ) );
        }
        break;

    case SCRIPT_TEST_TYPE_NOT:
        {
            ScriptInstructionList::iterator it = m_predicates.begin();
            ScriptPredicate *pPred;

            pPred = (ScriptPredicate *)*it;

            if (err = pPred->Process(fMode, returnCode, ppErrorMessage)) {
                // bail with the error later
                m_result = TRUE;
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
            }
            else if (pPred->GetResult() == TRUE) {
                m_result = FALSE;
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
            }
            else {
                m_result = TRUE;
                returnCode = 0;
            }
            if (err) {
                ScriptParseErrorExtMsg (err, m_returnCode, m_errMessage);
            }

            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Processing: NOT. res=%d retCode=%d(0x%x) ", m_result, returnCode, returnCode ) ) );
        }
        break;


    case SCRIPT_TEST_TYPE_COMPARE:
        {
            BOOL bMatch = FALSE;

            if (!m_search_path || !m_search_pathDN) {
                
                ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_ERROR, "Compare Path Missing\n" ) ) );
                
                return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            }

            if (!m_search_attribute || !m_expected_attrval) {

                ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_ERROR, "Compare Test Attribute Missing\n" ) ) );

                err = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }
            // just validating
            if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS) {
                break;
            }

            err = ScriptCompareRequest (m_search_pathDN, m_search_attribute, m_expected_attrval, m_default_value, &bMatch);

            // did it match ?
            if (bMatch) {
                m_result = TRUE;
            }
            else {
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
            }

            if (err) {
                ScriptParseErrorExtMsg (err, m_returnCode, m_errMessage);
            }
            
            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Compare (%ws)=%d retCode=%d(0x%x)\n", m_search_path, bMatch, returnCode, returnCode ) ) );
        }
        break;

    case SCRIPT_TEST_TYPE_INSTANCIATED:
        {
            BOOL bIsIntantiated = FALSE;

            if (!m_search_path || !m_search_pathDN) {
                return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            }

            // just validating
            if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS) {
                break;
            }

            err = ScriptInstantiatedRequest (m_search_pathDN, &bIsIntantiated);

            // was it instantiated ?
            if (bIsIntantiated) {
                m_result = TRUE;
            }
            else {
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
            }
            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Instantiated (%ws)=%d retCode=%d(0x%x)\n", m_search_path, bIsIntantiated, returnCode, returnCode ) ) );

            if (err) {
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
                ScriptParseErrorExtMsg (err, m_returnCode, m_errMessage);
            }
        }
        break;


    case SCRIPT_TEST_TYPE_CARDINALITY:
        {
            DWORD dwCardinality = 0;

            if (!m_search_path || !m_search_pathDN || !m_search_filter || !m_search_filterDS) {
                err = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }

            // just validating
            if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS) {
                break;
            }

            err = ScriptCardinalityRequest (m_search_pathDN, m_search_type, m_search_filterDS, &dwCardinality);

            // did we find the number we were expecting ?
            if (dwCardinality == m_expected_cardinality) {
                m_result = TRUE;
            }
            else {
                returnCode = m_returnCode;
                *ppErrorMessage = m_errMessage;
            }
            ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Cardinality (%ws) Found (%d) retCode=%d(0x%x)\n", m_search_path, dwCardinality, returnCode, returnCode ) ) );
        
            if (err) {
                ScriptParseErrorExtMsg (err, m_returnCode, m_errMessage);
            }
        }
        break;

    }

    // when we succeed, we should not have a returnCode set
    // the returnCode (if set) should be set only on failure
    Assert ( (m_result == FALSE) || ((m_result == TRUE) && (returnCode == 0)) || err);

    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Predicate Result: %ws %d %d(0x%x) dwErr(0x%x)\n", 
             testTypeNames[m_test_type],
             m_result, 
             returnCode, returnCode, err ) ) );

    return err;
}

BOOL ScriptPredicate :: GetResult()
{
    return m_result;
}

// ============================================================================
//

DWORD DirCommandAttributeParse (ISAXAttributes *pAttributes,
                                              WCHAR **ppPath,
                                              DSNAME **ppPathDN,
                                              BOOL *pMetadata)
{
	int    num;
    WCHAR *pVal=NULL, *pStopVal;

    DWORD status = SCRIPT_STATUS_PARSE_OK;

    // initialize data
    if (ppPath) {
        *ppPath = NULL;
    }

    if (ppPathDN) {
        *ppPathDN = NULL;
    }

    if (pMetadata) {
        *pMetadata = TRUE;
    }

    // process attributes
	pAttributes->getLength(&num);
	for ( int i=0; i<num; i++ ) {
        const wchar_t * name, * value; 
        int nameLen, valueLen;

		pAttributes->getLocalName(i, &name, &nameLen); 
		pAttributes->getValue(i, &value, &valueLen);       

        pVal = (WCHAR *)ScriptAlloc ((valueLen+1)*sizeof (WCHAR));
        if (pVal) {
            memcpy (pVal, value, valueLen*sizeof (WCHAR));
            pVal[valueLen]=0;
        }
        else {
            status = ScriptParseError(ERROR_OUTOFMEMORY);
            break;
        }

        if (wcsncmp(NTDSASCRIPT_ATTR_PATH, name, nameLen) == 0 && ppPath && (! *ppPath)) {

            *ppPath = pVal; pVal = NULL;

            if (ScriptNameToDSName (*ppPath, valueLen, ppPathDN)) {
                status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
                break;
            }
        }
        else if (wcsncmp(NTDSASCRIPT_ATTR_METADATA, name, nameLen) == 0 && pMetadata) {

             if (wcstol (pVal, &pStopVal, 10)) {
                 *pMetadata = TRUE;
             } else {
                 *pMetadata = FALSE;
             }
             ScriptFree (pVal); pVal = NULL;

        }
        else {
            #if DBG
                WCHAR tname[100];
                
                wcsncpy( tname, name, nameLen > 100 ? 99 : nameLen ); 
                tname[nameLen > 100 ? 99 : nameLen] = 0;

                ScriptLogPrint ( (DSLOG_ERROR, "Unknown XML Attribute: %ws\n", tname));

            #endif
            
            status = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
            break;
        }

        Assert (!pVal);
	}

    if (pVal) {
        ScriptFree (pVal);
    }

    return status;
}

// ============================================================================
//

ScriptMove :: ScriptMove(ISAXAttributes *pAttributes) 
                : ScriptInstruction(SCRIPT_ELEMENT_MOVE)
{
    m_topath = NULL;
    m_topathDN = NULL;

    m_status = DirCommandAttributeParse (pAttributes, 
                                         &m_path, 
                                         &m_pathDN, 
                                         &m_metadata);
}

ScriptMove :: ~ScriptMove()
{
    DPRINT(2, "Destroying Move\n");
    ScriptFree (m_path);
    ScriptFree (m_topath);
    //m_pathDN
}

DWORD ScriptMove :: Push (ScriptElement *pElement)
{
    DPRINT2 (1, "%*s<move>\n",3 * ntdscript_idnt++, "" );
    
    return S_OK;
}

DWORD ScriptMove :: Pop (void)
{
    DPRINT2 (1, "%*s</move>\n",3 * --ntdscript_idnt, "" );

    return S_OK;
}


DWORD ScriptMove :: ProcessTo(ISAXAttributes *pAttributes)
{
    DPRINT2 (1, "%*s<to/>\n",3 * (ntdscript_idnt+1), "" );

    if (m_topath) {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }
    else if (DirCommandAttributeParse (pAttributes, 
                                       &m_topath, 
                                       &m_topathDN, 
                                       NULL) != SCRIPT_STATUS_PARSE_OK) {

        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}


DWORD ScriptMove :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    DWORD err = S_OK;
    returnCode = 0;
    *ppErrorMessage = NULL;

    DPRINT2 (1, "Move %ws ==> %ws\n", m_path, m_topath );

    if (!m_topath) {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }
    
    // syntax validating or read only processing
    if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS || 
        fMode == SCRIPT_PROCESS_PREPROCESS_PASS) {
        return err;
    }

    err = ScriptMoveRequest (m_pathDN, m_topathDN, m_metadata);
    returnCode = err;

    if (err) {
        ScriptParseError (err);
    }
    
    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Move %ws ==> %ws: %d(0x%x)\n", m_path, m_topath, returnCode, returnCode ) ) );

    return err;
}

// ============================================================================
//

ScriptUpdate :: ScriptUpdate(ISAXAttributes *pAttributes)
                     : ScriptInstruction(SCRIPT_ELEMENT_UPDATE)
{
    m_status = DirCommandAttributeParse (pAttributes, 
                                         &m_path, 
                                         &m_pathDN, 
                                         &m_metadata);
}


ScriptUpdate :: ~ScriptUpdate()
{
    DPRINT(2, "Destroying Update\n");

    ScriptAttributeList::iterator it = m_attributes.begin();
    ScriptAttribute *pElement;

    while (it != m_attributes.end()) {

        pElement = *it;
        m_attributes.erase ( it++ );

        delete pElement;
    }

    ScriptFree (m_path);
    //m_pathDN
}

DWORD ScriptUpdate :: Push (ScriptElement *pElement)
{
    DPRINT2 (1, "%*s<update>\n",3 * ntdscript_idnt++, "" );
    
    return S_OK;
}

DWORD ScriptUpdate :: Pop (void)
{
    DPRINT2 (1, "%*s</update>\n",3 * --ntdscript_idnt, "" );

    return S_OK;
}

DWORD ScriptUpdate :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    DWORD err = S_OK;
    returnCode = 0;
    *ppErrorMessage = NULL;

    DPRINT2 (1, "Update: Processing\n\t\t\tpath:%ws\n\t\t\tmetadata:%d\n", m_path, m_metadata );

    // syntax validating or read only processing
    if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS || 
        fMode == SCRIPT_PROCESS_PREPROCESS_PASS) {
        return err;
    }

    err = ScriptUpdateRequest (m_pathDN, m_attributes, m_metadata);
    returnCode = err;

    if (err) {
        ScriptParseError (err);
    }
    
    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Update %ws = %d(0x%x)\n", m_path, returnCode, returnCode ) ) );

    return err;
}


DWORD ScriptUpdate :: AddElement (ScriptElement *pElement)
{
    ScriptElementType type = pElement->getType();

    if (type == SCRIPT_ELEMENT_ATTRIBUTE) {

        ScriptAttribute *pEl = (ScriptAttribute *)pElement;

        m_attributes.push_back (pEl);

    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

// ============================================================================
//

ScriptCreate :: ScriptCreate(ISAXAttributes *pAttributes) 
        : ScriptInstruction(SCRIPT_ELEMENT_CREATE) 
{
    m_status = DirCommandAttributeParse (pAttributes, &m_path, &m_pathDN, NULL);
}

ScriptCreate :: ~ScriptCreate()
{
    DPRINT(2, "Destroying Create\n");
    ScriptAttributeList::iterator it = m_attributes.begin();
    ScriptAttribute *pElement;

    while (it != m_attributes.end()) {

        pElement = *it;
        m_attributes.erase ( it++ );

        delete pElement;
    }

    ScriptFree (m_path);
    //m_pathDN
}

DWORD ScriptCreate :: Push (ScriptElement *pElement)
{
    DPRINT2(1, "%*s<create>\n",3 * ntdscript_idnt++, "");
    
    return S_OK;
}

DWORD ScriptCreate :: Pop (void)
{
    DPRINT2(1, "%*s</create>\n",3 * --ntdscript_idnt, "");

    return S_OK;
}

DWORD ScriptCreate :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    DWORD err = S_OK;
    returnCode = 0;
    *ppErrorMessage = NULL;

    DPRINT(1, "Create: Processing\n");

    // syntax validating or read only processing
    if (fMode == SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS || 
        fMode == SCRIPT_PROCESS_PREPROCESS_PASS) {
        return err;
    }

    err = ScriptCreateRequest (m_pathDN, m_attributes);
    returnCode = err;
    
    if (err) {
        ScriptParseError (err);
    }
    
    ScriptLogLevel (1, ScriptLogPrint ( (DSLOG_TRACE, "Create %ws = %d(0x%x)\n", m_path, returnCode, returnCode ) ) );

    return err;
}


DWORD ScriptCreate :: AddElement (ScriptElement *pElement)
{
    ScriptElementType type = pElement->getType();

    if (type == SCRIPT_ELEMENT_ATTRIBUTE) {

        ScriptAttribute *pEl = (ScriptAttribute *)pElement;

        m_attributes.push_back (pEl);

    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
    }

    return S_OK;
}

// ============================================================================
//


NTDSContent :: NTDSContent()
{
    m_script = NULL;
    m_lastElement = 0;
    m_error = 0;

    ScriptElement **p = &m_Element[0];
    for (int i=0; i<MAX_SCRIPT_NESTING_LEVEL; i++) {
        *p++ = NULL;
    }
}

NTDSContent :: ~NTDSContent()
{
    if (m_script) delete m_script;
}

DWORD NTDSContent :: Process (ScriptProcessMode fMode, DWORD &returnCode, const WCHAR **ppErrorMessage)
{
    DWORD err;

    if (!m_script) {
        err = ScriptParseError(ERROR_DS_NTDSCRIPT_PROCESS_ERROR);
    }
    else {
        err = m_script->Process(fMode, returnCode, ppErrorMessage); 
    }

    return err;
}

ScriptElement * NTDSContent :: getScriptElement (void)
{
    if (m_lastElement) {
        return m_Element[m_lastElement-1];
    }

    return NULL;
}

DWORD NTDSContent :: pushScriptElement (ScriptElement *pElement)
{
    ScriptElement *lastElement = NULL;
    DWORD err;

    if (m_lastElement) {

        lastElement = m_Element[m_lastElement-1];

        m_lastElement++;
        if (m_lastElement >= MAX_SCRIPT_NESTING_LEVEL) {
            return ScriptParseError(ERROR_DS_NTDSCRIPT_PROCESS_ERROR);
        }

        m_Element[m_lastElement-1] = pElement;
    }
    else {
        m_lastElement = 1;

        m_Element[0] = pElement;
    }

    err = pElement->Push(lastElement);

    if (err == S_OK && lastElement) {
        err = lastElement->AddElement (pElement);
    }
    return err;
}

DWORD NTDSContent :: popScriptElement (void)
{
    if (m_lastElement) {

        ScriptElement *lastElement = m_Element[m_lastElement-1];

        m_lastElement--;

        return lastElement->Pop();
    }
    else {
        return ScriptParseError(ERROR_DS_NTDSCRIPT_PROCESS_ERROR);
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE NTDSContent::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    ScriptElement *pElement = NULL;

    if (wcscmp(NTDSASCRIPT_NTDSASCRIPT, pwchLocalName) == 0) {

        // we accept only one, at the start
        if (m_script || m_lastElement) {
            m_error = ScriptParseError(ERROR_DS_NTDSCRIPT_PROCESS_ERROR);
        }
        else {
            pElement = m_script = new NTDSAscript(pAttributes);
        
            if (pElement) {
                m_error = pushScriptElement (pElement);
            }
            else {
                m_error = ScriptParseError(ERROR_OUTOFMEMORY);
            }
        }
    }
    else if (wcsncmp(NTDSASCRIPT_ACTION, pwchLocalName, cchLocalName) == 0) {
        ScriptAction *pAction;
        pElement = pAction = new ScriptAction(pAttributes);
        
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(ERROR_OUTOFMEMORY);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_PREDICATE, pwchLocalName, cchLocalName) == 0) {
        ScriptPredicate *pPredicate;
        pElement = pPredicate = new ScriptPredicate(pAttributes);
        
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(ERROR_OUTOFMEMORY);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_CONDITION, pwchLocalName, cchLocalName) == 0) {
        ScriptCondition *pCondition;

        pElement = pCondition = new ScriptCondition();
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(ERROR_OUTOFMEMORY);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_IF, pwchLocalName, cchLocalName) == 0) {

        pElement = getScriptElement();
        if (pElement && pElement->getType() == SCRIPT_ELEMENT_CONDITION) {

            ScriptCondition *pCondition = (ScriptCondition *)pElement;

            m_error = pCondition->ProcessIf (true, pAttributes);
        }
        else {
            m_error = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }

    }
    else if (wcsncmp(NTDSASCRIPT_THEN, pwchLocalName, cchLocalName) == 0) {

        pElement = getScriptElement();
        if (pElement && pElement->getType() == SCRIPT_ELEMENT_CONDITION) {

            ScriptCondition *pCondition = (ScriptCondition *)pElement;

            m_error = pCondition->ProcessThen (true, pAttributes);
        }
        else {
            m_error = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_ELSE, pwchLocalName, cchLocalName) == 0) {

        pElement = getScriptElement();
        if (pElement && pElement->getType() == SCRIPT_ELEMENT_CONDITION) {

            ScriptCondition *pCondition = (ScriptCondition *)pElement;

            m_error = pCondition->ProcessElse (true, pAttributes);
        }
        else {
            m_error = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_CREATE, pwchLocalName, cchLocalName) == 0) {
        ScriptCreate *pCreate;

        pElement = pCreate = new ScriptCreate(pAttributes);
        
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(0);
        }
    } 
    else if (wcsncmp(NTDSASCRIPT_MOVE, pwchLocalName, cchLocalName) == 0) {
        ScriptMove *pMove;

        pElement = pMove = new ScriptMove(pAttributes);
        
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(ERROR_OUTOFMEMORY);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_TO, pwchLocalName, cchLocalName) == 0) {
        pElement = getScriptElement();
        if (pElement && pElement->getType() == SCRIPT_ELEMENT_MOVE) {

            ScriptMove *pMove = (ScriptMove *)pElement;

            m_error = pMove->ProcessTo (pAttributes);
        }
        else {
            m_error = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }
    }
    else if (wcsncmp(NTDSASCRIPT_UPDATE, pwchLocalName, cchLocalName) == 0) {
        ScriptUpdate *pUpdate;

        pElement = pUpdate = new ScriptUpdate(pAttributes);
        
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(ERROR_OUTOFMEMORY);
        }
    }
    else {
        ScriptAttribute *pGeneral;

        pElement = pGeneral = new ScriptAttribute(pwchLocalName, cchLocalName, pAttributes);
        
        if (pElement) {
            m_error = pushScriptElement (pElement);
        }
        else {
            m_error = ScriptParseError(ERROR_OUTOFMEMORY);
        }
    }

    if (pElement && pElement->m_status != SCRIPT_STATUS_PARSE_OK) {
        m_error = pElement->m_status;
    }

    if (m_error) {
        return E_FAIL;
    }

    return S_OK;
}
        
       
HRESULT STDMETHODCALLTYPE NTDSContent::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
	HRESULT hr;
    ScriptElement *pElement = getScriptElement();

    // we process these differently
    if ( wcsncmp(NTDSASCRIPT_IF, pwchLocalName, cchLocalName) == 0) {

        if (pElement && pElement->getType() == SCRIPT_ELEMENT_CONDITION) {

            ScriptCondition *pCondition = (ScriptCondition *)pElement;

            hr = pCondition->ProcessIf (false);
        }
        else {
            hr = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }

    } else if (wcsncmp(NTDSASCRIPT_THEN, pwchLocalName, cchLocalName) == 0) {
        if (pElement && pElement->getType() == SCRIPT_ELEMENT_CONDITION) {

            ScriptCondition *pCondition = (ScriptCondition *)pElement;

            hr = pCondition->ProcessThen (false);
        }
        else {
            hr = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }

    } else if (wcsncmp(NTDSASCRIPT_ELSE, pwchLocalName, cchLocalName) == 0) {
        if (pElement && pElement->getType() == SCRIPT_ELEMENT_CONDITION) {

            ScriptCondition *pCondition = (ScriptCondition *)pElement;

            hr = pCondition->ProcessElse (false);
        }
        else {
            hr = ScriptParseError(ERROR_DS_NTDSCRIPT_SYNTAX_ERROR);
        }
    } else if (wcsncmp(NTDSASCRIPT_TO, pwchLocalName, cchLocalName) == 0) {
        hr = S_OK;
    }
    else {
        hr = popScriptElement();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE NTDSContent::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    ScriptElement *pElement = getScriptElement();
	HRESULT hr = S_OK;

    if (pElement) {
        hr = pElement->SetCharacters (pwchChars, cchChars);
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE NTDSContent::startDocument()
{
    if (m_script) {
        delete m_script;
        m_script = NULL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\saxerrorhandlerimpl.h ===
// ******************************************************************
//
// SAXErrorHandler.h: interface for the SAXErrorHandler class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _SAXERRORHANDLER_H
#define _SAXERRORHANDLER_H


class SAXErrorHandlerImpl : public ISAXErrorHandler  
{
public:
	SAXErrorHandlerImpl();
	virtual ~SAXErrorHandlerImpl();

		// This must be correctly implemented, if your handler must be a COM Object (in this example it does not)
		long __stdcall QueryInterface(const struct _GUID &,void ** );
		unsigned long __stdcall AddRef(void);
		unsigned long __stdcall Release(void);

        virtual HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ ISAXLocator  *pLocator,
            /* [in] */ const wchar_t *pError,
			/* [in] */ HRESULT errCode);
        
        virtual HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pError,
			/* [in] */ HRESULT errCode);
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pError,
			/* [in] */ HRESULT errCode);

private:
    long    _cRef;
};

#endif //_SAXERRORHANDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\saxcontenthandlerimpl.cxx ===
#include "NTDScript.h"
#include "SAXContentHandlerImpl.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


SAXContentHandlerImpl::SAXContentHandlerImpl()
{
    _cRef = 1;
}

SAXContentHandlerImpl::~SAXContentHandlerImpl()
{
}


//+-----------------------------------------------------------------------------
//
// ISAXContentHandler implementation
//
//------------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator
            )
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startDocument()
{
    return S_OK;
}
        

        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endDocument( void)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix)
{
    return S_OK;
}
        

        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    return S_OK;
}
        
       
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchVal,
            /* [in] */ int cchVal)
{
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
// IUnknown implementation
//
//------------------------------------------------------------------------------

long __stdcall SAXContentHandlerImpl::QueryInterface(const struct _GUID &riid,void ** ppvObject)
{
    if (riid == IID_IUnknown || riid == IID_ISAXContentHandler)
    {
        *ppvObject = static_cast<ISAXContentHandler *>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

unsigned long __stdcall SAXContentHandlerImpl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

unsigned long __stdcall SAXContentHandlerImpl::Release()
{
    if (InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\test\parsermain.cxx ===
#include <ntdspchx.h>
#pragma  hdrstop

#include <ntdsa.h>
#include "debug.h"
#define DEBSUB "PARSEMAIN:"


#include <NTDScript.h>
#include <NTDScriptUtil.h>
#include <NTDSContent.h>
#include <SAXErrorHandlerImpl.h>
#include <log.h>


extern "C" {
extern CRITICAL_SECTION csLoggingUpdate;
ULONG gulScriptLoggerLogLevel;
}

#ifdef DBG
extern "C" {
extern DEBUGARG DebugInfo;

}
#endif

DWORD ScriptParseErrorGen (DWORD dsid, DWORD dwErr, DWORD data, WCHAR *pMSG)
{ 
     return dsid;
}


void *ScriptAlloc (size_t size)
{
    return calloc (1, size);
}

void ScriptFree (void *ptr)
{
    free (ptr);
}

DWORD ScriptCompareRequest (DSNAME *pObjectDN, WCHAR *pAttribute, WCHAR *pAttrVal, WCHAR *pDefaultVal, BOOL *pfMatch)
{
    *pfMatch = FALSE;

    return 0;
}

DWORD ScriptCardinalityRequest (DSNAME *pObjectDN, DWORD searchType, FILTER *pFIlter, DWORD *pCardinality)
{
    *pCardinality = 0;

    return 0;
}

DWORD ScriptInstantiatedRequest (DSNAME *pObjectDN, BOOL *pfisInstantiated)
{
    *pfisInstantiated = TRUE;

    return 0;
}

DWORD ScriptCreateRequest (DSNAME *m_pathDN, ScriptAttributeList &m_attributes)
{
    return 0;
}

DWORD ScriptUpdateRequest (DSNAME *m_pathDN, ScriptAttributeList &m_attributes, BOOL m_metadata)
{
    return 0;
}

DWORD ScriptMoveRequest (DSNAME *m_pathDN, DSNAME *m_topathDN, BOOL m_metadata)
{
    return 0;
}


DWORD
ScriptNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        )
/*++

    Take a string name and generate a DSName from it.

    if the string starts with:
        dn:
        guid:
        sid:
    we parse out the needed info.

--*/
{
    BYTE  ObjGuid[sizeof(GUID)];
    BYTE  ObjSid[sizeof(NT4SID)];
    DWORD SidLen = 0,j;
    WCHAR acTmp[3];
    BOOL  bDone;
    DWORD dnstructlen;
#define foundGUID   1
#define foundSID    2
#define foundString 3
    DWORD dwContents= foundString;

    memset(ObjGuid, 0, sizeof(GUID));
    memset(ObjSid,0,sizeof(NT4SID));

    if (!ppDN || !pUfn) {
        // Urk. No place to put the answer, or no source to build the answer
        // from
        return 1;
    }
    DPRINT1(2, "ParsingDN:%ws\n",pUfn); 

    // Skip leading spaces.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (*pUfn) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            pUfn++;
            ccUfn--;
            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Now, skip trailing whitespace also.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (pUfn[ccUfn-1]) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            if( (ccUfn > 1) && (pUfn[ccUfn-2] == L'\\') ) {
                //There is a '\\' in front of the space. Need to count the
                // number of consequtive '\\' to determine if ' ' is escaped
                DWORD cc = 1;

                while( (ccUfn > (cc+1)) && (pUfn[ccUfn-cc-2] == L'\\') )
                    cc++;

                if( ! (cc & 0x1) ) //Even number of '\\'. Space is not escaped
                    ccUfn--;

                bDone = TRUE; //Either way, exit the loop.
            }
            else
                ccUfn--;

            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }


    if (ccUfn > 3 && _wcsnicmp(pUfn, L"dn:", 3) == 0) {

        ccUfn -=3;
        pUfn += 3;

    }
    else if (ccUfn > 5 && _wcsnicmp(pUfn, L"guid:", 5) == 0) {

        // We have some characters which have to be a guid
        if( (ccUfn!=37)  &&     // 5 for guid: , 32 for the GUID
            (ccUfn != 41)) {    // same plus 4 '-'s for formatted guid
                // Invalidly formatted
                return 1;
        }
        pUfn += 5;
        dwContents = foundGUID;

        if (37 == ccUfn) {
            // Hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
            for(j=0;j<16;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }
        }
        else {
            // Formatted guid (e.g., 38145c62-5a26-11d2-b388-0000f87a46c8).
            WCHAR szGuid[36+1];

            wcsncpy(szGuid, pUfn, 36);
            szGuid[36] = L'\0';

            if (UuidFromStringW(szGuid, (GUID *) ObjGuid)) {
                // Incorrect format.
                return 1;
            }
        }
        ccUfn = 0;
        // We must have correctly parsed out a guid.  No string name left.

    }
    else if (ccUfn > 4 && _wcsnicmp(pUfn, L"sid:", 3) == 0) {
        SidLen= (ccUfn - 4)/2; // Number of bytes that must be in the SID,
                               // if this is indeed a Sid. Subtract 4 for
                               // "SID:", leaving only the characters
                               // which encode the string.  Divide by two
                               // because each byte is encoded by two
                               // characters.

        if((ccUfn<6) ||   // at least 2 for val, 4 for "SID:"
            (ccUfn & 1) || // Must be an even number of characters
            (SidLen > sizeof(NT4SID)) ){  // Max size for a SID
                // Invalidly formatted
                return 1;
        }
        pUfn+=4;
        dwContents = foundSID;
        for(j=0;j<SidLen;j++) {
            acTmp[0] = towlower(pUfn[0]);
            acTmp[1] = towlower(pUfn[1]);
            if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                ObjSid[j] = (char) wcstol(acTmp, NULL, 16);
                pUfn+=2;
            }
            else {
                // Invalidly formatted name.
                return 1;
            }
        }

        // We must have correctly parsed out a sid.  No string name left.
        ccUfn=0;
    }

    // We may have parsed out either a GUID or a SID.  Build the DSNAME
    dnstructlen = DSNameSizeFromLen(ccUfn);
    *ppDN = (DSNAME *)ScriptAlloc(dnstructlen);

    // Null out the DSName
    memset(*ppDN, 0, dnstructlen);

    (*ppDN)->structLen = dnstructlen;

    switch(dwContents) {

    case foundString:
        // Just a string name

        if(ccUfn) {
            WCHAR *pString = (*ppDN)->StringName;   // destination string
            WCHAR *p = pUfn;         // original string
            DWORD cc = ccUfn;        // num chars to process
            BOOL  fDoItFast = TRUE;

            // this loop is a substitute for
            // memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
            // we try to find out whether the DN passed in has an escaped constant
            while (cc > 0) {

                if (*p == L'"' || *p== L'\\') {
                    fDoItFast = FALSE;
                    break;
                }

                *pString++ = *p++;
                cc--;
            }
            
            (*ppDN)->NameLen = ccUfn;
            
            // if we have an escaped constant in the DN
            // we convert it to blockname and back to DN so as to
            // put escaping into a standardized form which will help
            // future comparisons
            //
            if (!fDoItFast) {
                Assert (FALSE);
            }
            
        }
        break;

    case foundGUID:
        // we found a guid
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        break;
        
    case foundSID:
        // we found a sid.
        if(SidLen) {
            // We must have found a SID

            // First validate the SID

            if ((RtlLengthSid(ObjSid) != SidLen) || (!RtlValidSid(ObjSid)))
            {
                return(1);
            }
            memcpy(&(*ppDN)->Sid, ObjSid, SidLen);
            (*ppDN)->SidLen = SidLen;
        }
        break;
    }

    // Null terminate the string if we had one (or just set the string to '\0'
    // if we didn't).
    (*ppDN)->StringName[ccUfn] = L'\0';

    return 0;
}



DWORD ScriptStringToDSFilter (WCHAR *m_search_filter, FILTER **ppFilter)
{
    *ppFilter = (FILTER *)ScriptAlloc (sizeof (FILTER));

    return S_OK;
}


int 
MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCSTR psz)
{
    int i;
    i=MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
    if (!i)
    {
        //DBG_WARN("MyStrToOleStrN string too long; truncated");
        pwsz[cchWideChar-1]=0;
    }
    else
    {
        ZeroMemory(pwsz+i, sizeof(OLECHAR)*(cchWideChar-i));
    }
    return i;
}

WCHAR * 
Convert2WChars(char * pszStr)
{
    WCHAR * pwszStr = (WCHAR *)LocalAlloc(LMEM_FIXED, ((sizeof(WCHAR))*(strlen(pszStr) + 2)));
    if (pwszStr)
    {
        HRESULT hr = MyStrToOleStrN(pwszStr, (strlen(pszStr) + 1), pszStr);
        if (FAILED(hr))
        {
            LocalFree(pwszStr);
            pwszStr = NULL;
        }
    }
    return pwszStr;
}


int __cdecl 
main(int argc, char ** argv)
{
    HRESULT             hr;
    ISAXXMLReader *     pReader = NULL;
    NTDSContent*        pHandler = NULL; 
    IClassFactory *     pFactory = NULL;

    VARIANT          varText;
    char            *pszText;
    WCHAR           *pwszText;

    FILE             *fpScript;
    DWORD             dwFileLen;

    BSTR             bstrText = NULL;

    const WCHAR *pErrMessage = NULL;

    //::CoInitialize(NULL);

    InitializeCriticalSectionAndSpinCount(&csLoggingUpdate, 4000);

    DEBUGINIT(argc, argv, "TEST");

#ifdef DBG
    DebugInfo.severity = 1;
#endif
    gulScriptLoggerLogLevel=1;

	if (argc<2) {
		printf("\nTry something like\n\ttestSax drive:/path/file.xml\n\n");
        goto CleanUp;
	}

    ScriptLogPrint ( (DSLOG_TRACE, "Starting Parser Test: %ws \n", L"TRUE") );

    // read the string in memory
    //

    VariantInit(&varText);
    varText.vt = VT_BYREF|VT_BSTR;

    fpScript = fopen (argv[1], "r+");
    if (!fpScript) {
		printf("\nCould not open file: %s\n\n", argv[1]);
        goto CleanUp;
    }

    if (fseek (fpScript, 0, SEEK_END)) {
        printf("\nCould not position to end of file\n\n");
        fclose (fpScript);
        goto CleanUp;
    }

    dwFileLen = ftell (fpScript);

    pszText = (char *)malloc (dwFileLen+1);
    if (!pszText) {
        printf("\nMemory Alloc problem");
        fclose (fpScript);
        goto CleanUp;
    }

    fseek (fpScript, 0, SEEK_SET);
    fread (pszText, dwFileLen, 1, fpScript);
    fclose (fpScript);

    pszText[dwFileLen] = 0;
    pwszText = Convert2WChars (pszText);
    if (!pwszText) {
        printf("\nString Conversion Failed");
        goto CleanUp;
    }
    


    bstrText = SysAllocString(  pwszText );
    
    varText.pbstrVal = &bstrText; 

    free (pszText); pszText = NULL;
    LocalFree(pwszText); pwszText = NULL;

    
    // 
    //

    GetClassFactory( CLSID_SAXXMLReader, &pFactory);
	
	hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

	if(!FAILED(hr)) 
	{
		pHandler = new NTDSContent();
		hr = pReader->putContentHandler(pHandler);

		SAXErrorHandlerImpl * pEc = new SAXErrorHandlerImpl();
		hr = pReader->putErrorHandler(pEc);

		static wchar_t URL[1000];
		mbstowcs( URL, argv[1], 999 );
		wprintf(L"\nParsing document: %s\n", URL);
		
		//hr = pReader->parseURL(URL);
        hr = pReader->parse(varText);
		printf("\nParse result code: %08x\n\n",hr);

        if (!FAILED(hr)) {
            DWORD retCode, err;
            err = pHandler->Process (SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS, retCode, &pErrMessage);

            printf("\n\nValidate Processing: %08X  %d (0x%x)   %ws\n\n\n\n", err, retCode, retCode, pErrMessage);

            if (!err) {
                err = pHandler->Process (SCRIPT_PROCESS_EXECUTE_PASS, retCode, &pErrMessage);

                printf("\n\nExecute Processing: %08X  %d (0x%x)    %ws\n\n\n\n", err, retCode, retCode, pErrMessage);
            }
        }
	}
	else 
	{
		printf("\nError %08X\n\n", hr);
	}

CleanUp:

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    if (bstrText) {
        SysFreeString(bstrText);   
    }

    //::CoUninitialize();

    DEBUGTERM();

    ScriptLogger::Close();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\config.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.h

Abstract:

    This module contains the function declarations for routines to set the
    initial ds parameters in the registry.


Author:

    ColinBr  04-06-1998

Environment:

    User Mode - Nt

Revision History:

    04-06-1998 ColinBr
        Created initial file.

--*/

DWORD
NtdspConfigRegistry(
    IN  NTDS_INSTALL_INFO *UserInfo,
    IN  NTDS_CONFIG_INFO  *DiscoveredInfo
    );

DWORD
NtdspConfigRegistryUndo(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\config.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Contains function definitions for utilities relating to setting the
    directory service registry parameters

Author:

    ColinBr  30-Sept-1997

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <NTDSpch.h>
#pragma  hdrstop

#include <ntsecapi.h>

#include <dsconfig.h>    // for regsitry key names

#include <lmcons.h>      // for DNLEN
#include <dns.h>         // for DNS_MAX_NAME_BUFFER_LENGTH

#include <drs.h>         // for ntdsa.h

#include <winldap.h>     // for LDAP

#include <dsevent.h>     // for DS_EVENT_SEV_ALWAYS

#include <scesetup.h>    // for STR_DEFAULT_DOMAIN_GPO_GUID

#include "ntdsetup.h"    // for PNTDS_INSTALL_INFO

#include "setuputl.h"    // for PNTDS_CONFIG_INFO

#include "config.h"

#include "dsrolep.h"

#include <mdglobal.h>    // for DS_BEHAVIOR_VERSION_CURRENT

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
NtdspConfigDsParameters(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    );

DWORD
NtdspConfigFiles(
    IN  PNTDS_INSTALL_INFO UserInstallInfo
    );

BOOL
NtdspGetUniqueRDN(
    IN OUT WCHAR *Rdn,
    IN     ULONG RdnLength
    );

DWORD
NtdspConfigPerfmon(
    VOID
    );

DWORD
NtdspConfigLanguages(
    VOID
    );

DWORD
NtdspConfigMisc(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    );

DWORD
NtdspConfigEventLogging(
    VOID
    );

DWORD
NtdspConfigEventCategories(
    VOID
    );

DWORD
NtdspSetSecurityProvider(
    WCHAR *Name
    );

DWORD
NtdspHandleStackOverflow(
    DWORD ExceptionCode
    );

DWORD
NtdspSetGPOAttributes(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exported (from this source file) function definitions                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
NtdspConfigRegistry(
   IN  PNTDS_INSTALL_INFO UserInstallInfo,
   IN  PNTDS_CONFIG_INFO  DiscoveredInfo
   )
/*++

Routine Description:

    This routine sets all the ds configuration parameters in the registry.

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError = ERROR_SUCCESS;

    ASSERT(UserInstallInfo);
    ASSERT(DiscoveredInfo);

    //
    // The purpose of this try is to catch stack overflows caused by
    // alloca, thus functions called within this block is safe to use
    // alloca().  Recursive functions are hence discourged here since endless
    // recursions would be masked by ERROR_NOT_ENOUGH_MEMORY
    //

    try {

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspConfigDsParameters(UserInstallInfo,
                                               DiscoveredInfo);

        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspConfigFiles(UserInstallInfo);

        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspConfigPerfmon();

        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspConfigLanguages();

        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspConfigEventCategories();

        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspConfigMisc( UserInstallInfo,
                                        DiscoveredInfo );
        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspSetSecurityProvider( L"pwdssp.dll" );
        }

        if (ERROR_SUCCESS == WinError) {

            WinError = NtdspSetGPOAttributes( UserInstallInfo,
                                              DiscoveredInfo );
        }

    } except ( NtdspHandleStackOverflow(GetExceptionCode()) ) {

        WinError = ERROR_NOT_ENOUGH_MEMORY;

    }

    return WinError;

}



DWORD
NtdspConfigRegistryUndo(
   VOID
   )
/*++

Routine Description:


Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{
   return NtdspRegistryDelnode( L"\\Registry\\Machine\\" MAKE_WIDE(DSA_CONFIG_ROOT) );
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private function definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



DWORD
NtdspHandleStackOverflow(
    DWORD ExceptionCode
    )
{
    if (ExceptionCode == STATUS_STACK_OVERFLOW) {
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


DWORD
NtdspConfigMisc(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    )
/*++

Routine Description:

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG Index;
    DWORD LogFileSize;

    WCHAR *IniDefaultConfigNCDit = NULL;
    WCHAR *IniDefaultSchemaNCDit = NULL;
    WCHAR *IniDefaultRootDomainNCDit = NULL;
    WCHAR *IniDefaultLocalConnection = NULL;
    WCHAR *IniDefaultRemoteConnection = NULL;
    WCHAR *IniDefaultNewDomainCrossRef = NULL;
    WCHAR *IniDefaultMachine = NULL;

    struct
    {
        WCHAR*  Key;
        WCHAR** Value;

    } ActionArray[] =
    {
        { TEXT(INIDEFAULTSCHEMANCDIT),  &IniDefaultSchemaNCDit},
        { TEXT(INIDEFAULTCONFIGNCDIT),  &IniDefaultConfigNCDit},
        { TEXT(INIDEFAULTROOTDOMAINDIT),  &IniDefaultRootDomainNCDit},
        { TEXT(INIDEFAULTNEWDOMAINCROSSREF),  &IniDefaultNewDomainCrossRef},
        { TEXT(INIDEFAULTMACHINE),  &IniDefaultMachine},
        { TEXT(INIDEFAULTLOCALCONNECTION),  &IniDefaultLocalConnection},
        { TEXT(INIDEFAULTREMOTECONNECTION),  &IniDefaultRemoteConnection}
    };

    struct
    {
        WCHAR* Key;
        DWORD  Value;

    } ActionDwordArray[] =
    {
        { TEXT(SERVER_THREADS_KEY),  DEFAULT_SERVER_THREADS },
        { TEXT(HIERARCHY_PERIOD_KEY),  DEFAULT_HIERARCHY_PERIOD}

    };


    if ( UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE )
    {
        IniDefaultConfigNCDit       = L"DEFAULTCONFIGNC";
        IniDefaultSchemaNCDit       = L"SCHEMA";
        IniDefaultRootDomainNCDit   = L"DEFAULTROOTDOMAIN";
        IniDefaultNewDomainCrossRef = L"DEFAULTENTERPRISECROSSREF";
        IniDefaultMachine           = L"DEFAULTFIRSTMACHINE";
    }
    else
    {
        if ( UserInstallInfo->Flags & NTDS_INSTALL_DOMAIN )
        {
            IniDefaultRootDomainNCDit   = L"DEFAULTROOTDOMAIN";
            if ( UserInstallInfo->Flags & NTDS_INSTALL_NEW_TREE  )
            {
                IniDefaultNewDomainCrossRef = L"DEFAULTNEWTREEDOMAINCROSSREF";
            }
            else
            {
                IniDefaultNewDomainCrossRef = L"DEFAULTNEWCHILDDOMAINCROSSREF";
            }

            IniDefaultMachine           = L"DEFAULTADDLMACHINE";

        } else {

            // Replica install
            IniDefaultMachine           = L"DEFAULTADDLMACHINEREPLICA";

        }
        IniDefaultLocalConnection   = L"DEFAULTLOCALCONNECTION";
        IniDefaultRemoteConnection  = L"DEFAULTREMOTECONNECTION";

    }

    //
    // Open the parent key
    //
    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_CONFIG_SECTION),
                            &KeyHandle);

    if (WinError != ERROR_SUCCESS) {

        return WinError;

    }


    for (Index = 0; Index < sizeof(ActionArray)/sizeof(ActionArray[0]); Index++)
    {

        if ( *ActionArray[Index].Value )
        {
            WinError = RegSetValueEx(KeyHandle,
                                     ActionArray[Index].Key,
                                     0,  // reserved
                                     REG_SZ,
                                     (BYTE*) *ActionArray[Index].Value,
                                     (wcslen(*ActionArray[Index].Value)+1)*sizeof(WCHAR));

            if (WinError != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    for (Index = 0; Index < sizeof(ActionDwordArray)/sizeof(ActionDwordArray[0]); Index++)
    {
        WinError = RegSetValueEx(KeyHandle,
                                 ActionDwordArray[Index].Key,
                                 0,  // reserved
                                 REG_DWORD,
                                 (BYTE*) &ActionDwordArray[Index].Value,
                                 sizeof(ActionDwordArray[Index].Value));

        if (WinError != ERROR_SUCCESS)
        {
            break;
        }
    }

    //
    // Database recovery
    //
    WinError =  RegSetValueEx(KeyHandle,
                              TEXT(RECOVERY_KEY),
                              0,
                              REG_SZ,
                              (BYTE*) TEXT(RECOVERY_ON),
                              (wcslen(TEXT(RECOVERY_ON)) + 1)*sizeof(WCHAR));
    if (WinError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

Cleanup:

    RegCloseKey( KeyHandle );

    return WinError;
}


DWORD
NtdspConfigFiles(
    IN  PNTDS_INSTALL_INFO UserInstallInfo
    )
/*++

Routine Description:

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    WCHAR System32Dir[MAX_PATH];
    LPWSTR BaseDir;

    struct
    {
        WCHAR *Suffix;
        WCHAR *RegKey;
        BOOL  fSystemDir;
    } SuffixArray[] =
    {
        { L"\0",            TEXT(JETSYSTEMPATH_KEY), FALSE },
        { L"\\ntds.dit",    TEXT(FILEPATH_KEY), FALSE },
        { L"\\schema.ini",  TEXT(NTDSINIFILE), TRUE },
        { L"\\dsadata.bak", TEXT(BACKUPPATH_KEY), FALSE }
    };

    ULONG SuffixCount = sizeof(SuffixArray) / sizeof(SuffixArray[0]);
    ULONG Index, Size, Length;
    HKEY KeyHandle = NULL;

    //
    // Open the parent key
    //

    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_CONFIG_SECTION),
                            &KeyHandle);

    if (WinError != ERROR_SUCCESS) {

        return WinError;

    }

    // Determine the system root
    if (!GetEnvironmentVariable(L"windir",
                                System32Dir,
                                ARRAY_COUNT(System32Dir) ) )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    wcscat( System32Dir, L"\\system32" );

    for ( Index = 0; Index < SuffixCount; Index++ )
    {

        WCHAR *Value;

        if ( SuffixArray[Index].fSystemDir )
        {
            BaseDir = System32Dir;
        }
        else
        {
            BaseDir = UserInstallInfo->DitPath;
        }

        if ( *SuffixArray[Index].Suffix == L'\0' )
        {
            Value = BaseDir;
        }
        else
        {
            Length =  wcslen(BaseDir)
                   +  wcslen(SuffixArray[Index].Suffix)
                   +  1;

            if ( Length > MAX_PATH )
            {
                return ERROR_BAD_PATHNAME;
            }

            Value = alloca( Length*sizeof(WCHAR) );
            RtlZeroMemory( Value, Length*sizeof(WCHAR) );
            wcscpy( Value, BaseDir );
            wcscat( Value, SuffixArray[Index].Suffix );
        }


        WinError = RegSetValueEx(KeyHandle,
                                 SuffixArray[Index].RegKey,
                                 0,  // reserved
                                 REG_SZ,
                                 (BYTE*) Value,
                                 (wcslen(Value)+1)*sizeof(WCHAR));


        if (WinError != ERROR_SUCCESS) {

            goto Cleanup;

        }
    }

    //
    // Set the log file location
    //
    WinError = RegSetValueEx(KeyHandle,
                             TEXT(LOGPATH_KEY),
                             0,  // reserved
                             REG_SZ,
                             (BYTE*) UserInstallInfo->LogPath,
                             (wcslen(UserInstallInfo->LogPath)+1)*sizeof(WCHAR));


    if (WinError != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // That's it - fall through to cleanup
    //

Cleanup:

    RegCloseKey(KeyHandle);

    return WinError;
}


DWORD
NtdspConfigEventCategories(
    VOID
    )
/*++

Routine Description:

    This function will add the NTDS Diagnositics key.  If the key
    already exists then it will leave the values unchanged and 
    add only the values that don't exist.

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    HKEY  KeyHandle = NULL;
    ULONG Index = 0 ;
    DWORD lpdwDisposition = 0;

    struct {

        WCHAR *Name;
        ULONG  Severity;

     } Categories[] =
     {
        {TEXT(KCC_KEY),                    DS_EVENT_SEV_ALWAYS},
        {TEXT(SECURITY_KEY),               DS_EVENT_SEV_ALWAYS},
        {TEXT(XDS_INTERFACE_KEY),          DS_EVENT_SEV_ALWAYS},
        {TEXT(MAPI_KEY),                   DS_EVENT_SEV_ALWAYS},
        {TEXT(REPLICATION_KEY),            DS_EVENT_SEV_ALWAYS},
        {TEXT(GARBAGE_COLLECTION_KEY),     DS_EVENT_SEV_ALWAYS},
        {TEXT(INTERNAL_CONFIGURATION_KEY), DS_EVENT_SEV_ALWAYS},
        {TEXT(DIRECTORY_ACCESS_KEY),       DS_EVENT_SEV_ALWAYS},
        {TEXT(INTERNAL_PROCESSING_KEY),    DS_EVENT_SEV_ALWAYS},
        {TEXT(PERFORMANCE_KEY),            DS_EVENT_SEV_ALWAYS},
        {TEXT(STARTUP_SHUTDOWN_KEY),       DS_EVENT_SEV_ALWAYS},
        {TEXT(SERVICE_CONTROL_KEY),        DS_EVENT_SEV_ALWAYS},
        {TEXT(NAME_RESOLUTION_KEY),        DS_EVENT_SEV_ALWAYS},
        {TEXT(BACKUP_KEY),                 DS_EVENT_SEV_ALWAYS},
        {TEXT(FIELD_ENGINEERING_KEY),      DS_EVENT_SEV_ALWAYS},
        {TEXT(LDAP_INTERFACE_KEY),         DS_EVENT_SEV_ALWAYS},
        {TEXT(SETUP_KEY),                  DS_EVENT_SEV_ALWAYS},
        {TEXT(GC_KEY),                     DS_EVENT_SEV_ALWAYS},
        {TEXT(ISM_KEY),                    DS_EVENT_SEV_ALWAYS},
        {TEXT(GROUP_CACHING_KEY),          DS_EVENT_SEV_ALWAYS},
        {TEXT(LVR_KEY),                    DS_EVENT_SEV_ALWAYS},
        {TEXT(DS_RPC_CLIENT_KEY),          DS_EVENT_SEV_ALWAYS},
        {TEXT(DS_RPC_SERVER_KEY),          DS_EVENT_SEV_ALWAYS},
        {TEXT(DS_SCHEMA_KEY),              DS_EVENT_SEV_ALWAYS}
    };
    ULONG CategoryCount = sizeof(Categories) / sizeof(Categories[0]);

    //
    // Open registry key
    //
    WinError = RegCreateKeyEx(
                      HKEY_LOCAL_MACHINE,
                      TEXT(DSA_EVENT_SECTION),
                      0,
                      NULL,
                      0,
                      KEY_WRITE | KEY_READ,
                      NULL,
                      &KeyHandle,
                      &lpdwDisposition
                    );

    if ((WinError == ERROR_SUCCESS) && (REG_CREATED_NEW_KEY == lpdwDisposition)) {

        for (Index = 0;
                Index < CategoryCount && (WinError == ERROR_SUCCESS);
                    Index++)
        {
            WinError = RegSetValueEx(KeyHandle,
                                     Categories[Index].Name, // no value name
                                     0,
                                     REG_DWORD,
                                     (BYTE*)&Categories[Index].Severity,
                                     sizeof(Categories[Index].Severity));
            if (ERROR_SUCCESS != WinError) {
                goto cleanup;
            }

        }

    } else {
        for (Index = 0;
                Index < CategoryCount && (WinError == ERROR_SUCCESS);
                    Index++)
        {
            DWORD Value = 0;
            DWORD cbValue = sizeof(DWORD);
            DWORD type = 0;

            WinError = RegQueryValueEx(KeyHandle,
                                       Categories[Index].Name,
                                       0,
                                       &type,
                                       (BYTE*)&Value,
                                       &cbValue
                                       );

            if ( ERROR_FILE_NOT_FOUND == WinError ) {
            
                WinError = RegSetValueEx(KeyHandle,
                                         Categories[Index].Name, // no value name
                                         0,
                                         REG_DWORD,
                                         (BYTE*)&Categories[Index].Severity,
                                         sizeof(Categories[Index].Severity));

                if (ERROR_SUCCESS != WinError) {
                    goto cleanup;
                }

            }  else {
                if (ERROR_SUCCESS != WinError) {
                    goto cleanup;
                }
            }

        }
    }

    cleanup:

    if (KeyHandle) {
        RegCloseKey(KeyHandle);
    }

    return WinError;

}





DWORD
NtdspConfigPerfmon(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError;

    HKEY  KeyHandle;

    WCHAR *OpenEP    = L"OpenDsaPerformanceData";
    WCHAR *CollectEP = L"CollectDsaPerformanceData";
    WCHAR *CloseEP   = L"CloseDsaPerformanceData";
    WCHAR *PerfDll = TEXT(DSA_PERF_DLL);

    //
    // Open the key
    //
    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_PERF_SECTION),
                            &KeyHandle);

    if (ERROR_SUCCESS == WinError) {

        WinError = RegSetValueEx(KeyHandle,
                                 TEXT("Open"),
                                 0,
                                 REG_SZ,
                                 (BYTE*) OpenEP,
                                 (wcslen(OpenEP)+1)*sizeof(WCHAR));

        if (WinError == ERROR_SUCCESS) {

            WinError = RegSetValueEx(KeyHandle,
                                     TEXT("Collect"),
                                     0,
                                     REG_SZ,
                                     (BYTE*) CollectEP,
                                     (wcslen(CollectEP)+1)*sizeof(WCHAR));

        }


        if (WinError == ERROR_SUCCESS) {

            WinError = RegSetValueEx(KeyHandle,
                                     TEXT("Close"),
                                     0,
                                     REG_SZ,
                                     (BYTE*) CloseEP,
                                     (wcslen(CloseEP)+1)*sizeof(WCHAR));

        }

        if (WinError == ERROR_SUCCESS) {

            WinError = RegSetValueEx(KeyHandle,
                                     TEXT("Library"),
                                     0,
                                     REG_SZ,
                                     (BYTE*) PerfDll,
                                     (wcslen(PerfDll)+1)*sizeof(WCHAR));

        }

        RegCloseKey(KeyHandle);

    }

    return WinError;



}


DWORD
NtdspConfigLanguages(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError;

    HKEY  KeyHandle;
    WCHAR LanguageName[20];  // large enough to hold the string below

    DWORD LanguageId = GetUserDefaultLangID();

    //
    // Prepare the strings
    //
    wsprintf(LanguageName,L"Language %08X", LanguageId );

    //
    // Set the keys
    //
    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_LOCALE_SECTION),
                            &KeyHandle);

    if (WinError == ERROR_SUCCESS) {

        WinError = RegSetValueEx(KeyHandle,
                                 LanguageName,
                                 0, // reserved
                                 REG_DWORD,
                                 (LPBYTE) &LanguageId,
                                 sizeof(LanguageId));


        // close key

        RegCloseKey(KeyHandle);

    }

    return WinError;

}


DWORD
NtdspConfigDsParameters(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    )
/*++

Routine Description:

Parameters:

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    WCHAR *DomainDN = NULL, *ConfigDN = NULL, *SchemaDN = NULL;
    WCHAR *CrossRefDN = NULL, *SiteName = NULL, *LocalMachineDN = NULL;
    WCHAR *RemoteMachineDN = NULL, *RemoteConnectionDN = NULL;
    WCHAR *LocalConnectionDN = NULL, *NetbiosName = NULL, *DnsRoot = NULL;
    WCHAR *ConfigSourceServer = NULL, *DomainSourceServer = NULL;
    WCHAR *InstallSiteDN = NULL;
    WCHAR *RootDomainDnsName = NULL;
    WCHAR *TrustedCrossRef = NULL;
    WCHAR *SourceDomainName = NULL;
    WCHAR *LocalMachineAccountDN = NULL;
    WCHAR ForestBehaviorVersionBuffer[16];
    WCHAR *ForestBehaviorVersion = ForestBehaviorVersionBuffer;
    ULONG ForestBehaviorVersionValue = 0;

    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 3]; // +1 for +2 for possible quotes
    ULONG Length, Size;

    WCHAR UniqueRDN[ MAX_RDN_SIZE ];

    BOOL fStatus;

    ULONG Index;

    struct
    {
        WCHAR *Key;
        WCHAR **Value;

    } ActionArray[] =
    {
        { TEXT(ROOTDOMAINDNNAME),        &DomainDN },
        { TEXT(CONFIGNCDNNAME),          &ConfigDN },
        { TEXT(SCHEMADNNAME),            &SchemaDN },
        { TEXT(NEWDOMAINCROSSREFDNNAME), &CrossRefDN },
        { TEXT(REMOTEMACHINEDNNAME),     &RemoteMachineDN },
        { TEXT(INSTALLSITENAME),         &SiteName },
        { TEXT(NETBIOSNAME),             &NetbiosName },
        { TEXT(DNSROOT),                 &DnsRoot },
        { TEXT(MACHINEDNNAME),           &LocalMachineDN },
        { TEXT(REMOTECONNECTIONDNNAME),  &RemoteConnectionDN },
        { TEXT(LOCALCONNECTIONDNNAME),   &LocalConnectionDN },
        { TEXT(SRCROOTDOMAINSRV),        &DomainSourceServer },
        { TEXT(INSTALLSITEDN),           &InstallSiteDN },
        { TEXT(SRCCONFIGNCSRV),          &ConfigSourceServer },
        { TEXT(TRUSTEDCROSSREF),         &TrustedCrossRef },
        { TEXT(SOURCEDSADNSDOMAINNAME),  &SourceDomainName },
        { TEXT(LOCALMACHINEACCOUNTDN),   &LocalMachineAccountDN },
        { TEXT(FORESTBEHAVIORVERSION),   &ForestBehaviorVersion },
        { TEXT(ROOTDOMAINDNSNAME),       &RootDomainDnsName }
    };

    ULONG ActionCount = sizeof(ActionArray) / sizeof(ActionArray[0]);

    //
    // Open the parent key
    //

    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_CONFIG_SECTION),
                            &KeyHandle);

    if (WinError != ERROR_SUCCESS) {

        return WinError;

    }

    //
    // Set the behavior version
    //
    if (UserInstallInfo->Flags & NTDS_INSTALL_SET_FOREST_CURRENT) {
        ASSERT(UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE);
        ForestBehaviorVersionValue = DS_BEHAVIOR_VERSION_CURRENT;
    }
    _itow(ForestBehaviorVersionValue,
          ForestBehaviorVersion, 
          10);

    //
    // Set the source domain dns name (can be NULL)
    //
    SourceDomainName = UserInstallInfo->SourceDomainName;

    //
    // Set the root domain's dns name
    //
    RootDomainDnsName = DiscoveredInfo->RootDomainDnsName;

    //
    // Set the dn's of the three naming contexts to create or
    // replicate and all other dn's derived from these
    //
    if ( UserInstallInfo->Flags & NTDS_INSTALL_REPLICA ) {

        // We have all the information
        DomainDN = DiscoveredInfo->DomainDN;
        ConfigDN = DiscoveredInfo->ConfigurationDN;
        SchemaDN = DiscoveredInfo->SchemaDN;

        ASSERT( DiscoveredInfo->LocalMachineAccount );
        LocalMachineAccountDN = DiscoveredInfo->LocalMachineAccount;

    }
    else {
        // Need the domain dn
        Length = 0;
        DiscoveredInfo->DomainDN = NULL;
        WinError = NtdspDNStoRFC1779Name( DiscoveredInfo->DomainDN,
                                          &Length,
                                          UserInstallInfo->DnsDomainName );

        if ( ERROR_INSUFFICIENT_BUFFER == WinError )
        {
            DiscoveredInfo->DomainDN = NtdspAlloc( Length * sizeof(WCHAR) );
            if ( DiscoveredInfo->DomainDN )
            {
                WinError = NtdspDNStoRFC1779Name( DiscoveredInfo->DomainDN,
                                                  &Length,
                                                  UserInstallInfo->DnsDomainName );

            }
            else
            {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        if (WinError != ERROR_SUCCESS) {

            return WinError;

        }

        DomainDN = DiscoveredInfo->DomainDN;

        if  ( UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE )
        {
            // Construct the config and schema dn
            Length  = (wcslen( DomainDN ) * sizeof( WCHAR ))
                      + sizeof(L"CN=Configuration,");

            DiscoveredInfo->ConfigurationDN = NtdspAlloc( Length );
            if ( !DiscoveredInfo->ConfigurationDN )
            {
                 return ERROR_NOT_ENOUGH_MEMORY;
            }

            RtlZeroMemory(DiscoveredInfo->ConfigurationDN, Length );
            wcscpy(DiscoveredInfo->ConfigurationDN, L"CN=Configuration");
            wcscat(DiscoveredInfo->ConfigurationDN, L",");
            wcscat(DiscoveredInfo->ConfigurationDN, DomainDN);

            // schema
            Length  = (wcslen( DiscoveredInfo->ConfigurationDN ) *
                        sizeof( WCHAR ) )
                      + sizeof(L"CN=Schema,");
            DiscoveredInfo->SchemaDN = NtdspAlloc( Length );
            RtlZeroMemory(DiscoveredInfo->SchemaDN, Length );
            wcscpy(DiscoveredInfo->SchemaDN, L"CN=Schema");
            wcscat(DiscoveredInfo->SchemaDN, L",");
            wcscat(DiscoveredInfo->SchemaDN, DiscoveredInfo->ConfigurationDN);
        }

        ConfigDN = DiscoveredInfo->ConfigurationDN;
        SchemaDN = DiscoveredInfo->SchemaDN;

    }


    ASSERT(DomainDN && DomainDN[0] != L'\0');
    ASSERT(ConfigDN && ConfigDN[0] != L'\0');
    ASSERT(SchemaDN && SchemaDN[0] != L'\0');

    // Site Name
    if ( UserInstallInfo->SiteName != NULL )
    {
        ULONG Length, Size;
        WCHAR *QuotedSiteName = NULL;

        Length = wcslen( UserInstallInfo->SiteName );
        Size = (Length+2)*sizeof(WCHAR);
        QuotedSiteName = (WCHAR*) alloca( Size );

        QuoteRDNValue( UserInstallInfo->SiteName,
                       Length,
                       QuotedSiteName,
                       Size / sizeof(WCHAR) );

        SiteName = QuotedSiteName;

    }
    else
    {
        //
        // No given site name?  Assume the site from the server that
        // we are replicating from
        //
        ULONG  Size;
        DSNAME *src, *dst, *QuotedSite;
        WCHAR  *Terminator;


        if ( *DiscoveredInfo->ServerDN == L'\0' )
        {
            return ERROR_INVALID_PARAMETER;
        }

        Size = (ULONG)DSNameSizeFromLen( wcslen(DiscoveredInfo->ServerDN) );

        src = alloca(Size);
        RtlZeroMemory(src, Size);
        src->structLen = Size;

        dst = alloca(Size);
        RtlZeroMemory(dst, Size);
        dst->structLen = Size;

        src->NameLen = wcslen(DiscoveredInfo->ServerDN);
        wcscpy(src->StringName, DiscoveredInfo->ServerDN);

        if (  0 == TrimDSNameBy(src, 3, dst) )
        {
            SiteName = wcsstr(dst->StringName, L"=");
            if (SiteName)
            {
                //
                // One more character and we will have the site name
                //
                SiteName++;

                // now go to the end
                Terminator = wcsstr(SiteName, L",");
                if (Terminator)
                {
                    *Terminator = L'\0';
                    Length = (wcslen( SiteName ) + 1) + sizeof(WCHAR);
                    DiscoveredInfo->SiteName = NtdspAlloc( Length );
                    if ( DiscoveredInfo->SiteName )
                    {
                        wcscpy(DiscoveredInfo->SiteName, SiteName);
                        SiteName = DiscoveredInfo->SiteName;
                    }
                    else
                    {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }
                }
            }
        }

        if ( *DiscoveredInfo->SiteName == L'\0' )
        {
            WinError = ERROR_NO_SITENAME;
            goto Cleanup;
        }

        //
        // Make the site name is propery quoted
        //
        {
            ULONG Length, Size;
            WCHAR *QuotedSiteName = NULL;

            Length = wcslen( SiteName );
            Size = (Length+2)*sizeof(WCHAR);
            QuotedSiteName = (WCHAR*) alloca( Size );

            QuoteRDNValue( SiteName,
                           Length,
                           QuotedSiteName,
                           Size / sizeof(WCHAR) );

            SiteName = QuotedSiteName;
        }
    }
    ASSERT(SiteName && SiteName[0] != L'\0');


    // msft-dsa object dn
    Length = sizeof( ComputerName ) / sizeof( ComputerName[0] );
    if (!GetComputerName(ComputerName, &Length))
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    {
        ULONG Length, Size;
        WCHAR *QuotedComputerName = NULL;

        Length = wcslen( ComputerName );
        Size = (Length+2)*sizeof(WCHAR);
        QuotedComputerName = (WCHAR*) alloca( Size );

        QuoteRDNValue( ComputerName,
                       Length,
                       QuotedComputerName,
                       Size / sizeof(WCHAR) );

        wcscpy( ComputerName, QuotedComputerName );

    }


    Size  = (wcslen(L"CN=NTDS Settings") +
             wcslen(L"CN=Sites")         +
             wcslen(L"CN=Servers")       +
             wcslen(L"CN=CN=,,,,")       +
             wcslen(ComputerName)        +
             wcslen(SiteName)            +
             wcslen(ConfigDN)            +
             + 1) * sizeof(WCHAR);

    LocalMachineDN = alloca(Size);
    RtlZeroMemory(LocalMachineDN, Size);

    wsprintf(LocalMachineDN,L"CN=NTDS Settings,CN=%ws,CN=Servers,CN=%ws,CN=Sites,%ws",
             ComputerName, SiteName, ConfigDN);

    ASSERT(LocalMachineDN && LocalMachineDN[0] != L'\0');

    if ( !DiscoveredInfo->LocalServerDn ) {

        //
        // For first DC in forest case, we need to set this value
        // so we can add an ACE to the object later on.
        //
        DWORD cBytes;
        DSNAME *dst, *src;

        cBytes = (DWORD)DSNameSizeFromLen(wcslen(LocalMachineDN));
        src = alloca( cBytes );
        dst = alloca( cBytes );
        memset(src, 0, cBytes);
        memset(dst, 0, cBytes);
        src->structLen = cBytes;
        src->NameLen = wcslen(LocalMachineDN);
        wcscpy( src->StringName, LocalMachineDN );
        TrimDSNameBy(src, 1, dst);

        DiscoveredInfo->LocalServerDn = LocalAlloc( LMEM_ZEROINIT,
                                                    (dst->NameLen+1) * sizeof(WCHAR) );
        if ( DiscoveredInfo->LocalServerDn ) {
            wcscpy( DiscoveredInfo->LocalServerDn, dst->StringName );
        } else {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

    }


    //
    // Derive the site name
    //
    Size  = (wcslen(L"CN=Sites")         +
             wcslen(L"CN=CN=,,")         +
             wcslen(SiteName)            +
             wcslen(ConfigDN)            +
             + 1) * sizeof(WCHAR);

    InstallSiteDN = alloca(Size);
    RtlZeroMemory(InstallSiteDN, Size);
    wsprintf(InstallSiteDN, L"CN=%ws,CN=Sites,%ws", SiteName, ConfigDN);


    //
    // Items when creating a new domain
    //

    // cross-ref dn
    if ( !(UserInstallInfo->Flags & NTDS_INSTALL_REPLICA) )
    {

        WCHAR *QuotedCrossRef = NULL;

        //
        //  We're installing a new partition
        //
        ASSERT( UserInstallInfo->FlatDomainName );

        {
            ULONG Length, Size;

            Length = wcslen( UserInstallInfo->FlatDomainName );
            Size = (Length+2)*sizeof(WCHAR);
            QuotedCrossRef = (WCHAR*) alloca( Size );

            QuoteRDNValue( UserInstallInfo->FlatDomainName,
                           Length,
                           QuotedCrossRef,
                           Size / sizeof(WCHAR) );

        }

        Size  = (wcslen(L"CN=Partitions")  +
                 wcslen(L"CN=,,")          +
                 wcslen(QuotedCrossRef) +
                 wcslen(SiteName)          +
                 wcslen(ConfigDN)          +
                 + 1) * sizeof(WCHAR);

        CrossRefDN = alloca(Size);
        RtlZeroMemory(CrossRefDN, Size);

        wsprintf(CrossRefDN, L"CN=%ws,CN=Partitions,%ws",
                 QuotedCrossRef,
                 ConfigDN);


        NetbiosName = UserInstallInfo->FlatDomainName;
        ASSERT( NetbiosName );

        DnsRoot = UserInstallInfo->DnsDomainName;
        ASSERT( DnsRoot );

    }

    {
        GUID ZeroGuid;
        ZeroMemory((PUCHAR)&ZeroGuid,sizeof(GUID));

        //store the source srv Guid if there is one
        if( (!IsEqualGUID(&DiscoveredInfo->ServerGuid,&ZeroGuid)))
        {
            WinError = RegSetValueEx(KeyHandle,
                                     TEXT(SOURCEDSAOBJECTGUID),
                                     0,
                                     REG_BINARY,
                                     (LPBYTE)&DiscoveredInfo->ServerGuid,
                                     sizeof (GUID)
                                     );
            if (ERROR_SUCCESS != WinError) {
                goto Cleanup;
            }
        }
    }

    //
    // Items when any version of install involving replication
    //

    if ( !(UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE) ) {

        //
        // This is a replicated install - there are three more
        // dn's to create and a config source server
        //
        ASSERT( UserInstallInfo->ReplServerName );
        ConfigSourceServer = UserInstallInfo->ReplServerName;

        // The reciprocal replication code assumes this reg value exists
        DomainSourceServer = L"";

        // source server's msft-dsa object dn
        RemoteMachineDN = DiscoveredInfo->ServerDN;

        // remote connection dn
        RtlZeroMemory( UniqueRDN, sizeof(UniqueRDN) );
        fStatus = NtdspGetUniqueRDN( UniqueRDN,
                                     sizeof(UniqueRDN)/sizeof(UniqueRDN[0]) );
        if ( !fStatus )
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        Size  = (wcslen(UniqueRDN)      +
                 wcslen(RemoteMachineDN) +
                 wcslen(L"CN=,")
                 + 1) * sizeof(WCHAR);

        RemoteConnectionDN = alloca(Size);
        RtlZeroMemory(RemoteConnectionDN, Size);
        wsprintf( RemoteConnectionDN,
                  L"CN=%ls,%ls",
                  UniqueRDN,
                  RemoteMachineDN );


        // local connection dn
        RtlZeroMemory( UniqueRDN, sizeof(UniqueRDN) );
        fStatus = NtdspGetUniqueRDN( UniqueRDN,
                                     sizeof(UniqueRDN)/sizeof(UniqueRDN[0]) );
        if ( !fStatus )
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        Size  = (wcslen(UniqueRDN)      +
                 wcslen(LocalMachineDN) +
                 wcslen(L"CN=,")
                 + 1) * sizeof(WCHAR);

        LocalConnectionDN = alloca(Size);
        RtlZeroMemory(LocalConnectionDN, Size);
        wsprintf( LocalConnectionDN,
                  L"CN=%ls,%ls",
                  UniqueRDN,
                  LocalMachineDN );


    }

    //check to see if we are doing an install from media and if so make it so.
    if ( FLAG_ON (UserInstallInfo->Flags, NTDS_INSTALL_REPLICA) &&
         UserInstallInfo->RestorePath &&
            *(UserInstallInfo->RestorePath)) {

        WinError = RegSetValueExW(KeyHandle,
                                 TEXT(RESTOREPATH),
                                 0,
                                 REG_SZ,
                                 (LPBYTE)(UserInstallInfo->RestorePath),
                                 sizeof(WCHAR)*wcslen(UserInstallInfo->RestorePath)
                                 );

        if (WinError != ERROR_SUCCESS) {
            goto Cleanup;
        }



        WinError = RegSetValueEx(KeyHandle,
                                 TEXT(TOMB_STONE_LIFE_TIME),
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&DiscoveredInfo->TombstoneLifeTime,
                                 sizeof (DWORD)
                                 );
        if (WinError != ERROR_SUCCESS) {
            goto Cleanup;
        }
        
    }

    //
    // Items for new domain install
    //
    if ( FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_DOMAIN ) )
    {
        ASSERT( DiscoveredInfo->TrustedCrossRef );
        TrustedCrossRef = DiscoveredInfo->TrustedCrossRef;
    } 
        
    //
    // Lastly, Items when on for replica install
    //
    if ( UserInstallInfo->Flags & NTDS_INSTALL_REPLICA )
    {
        ASSERT( UserInstallInfo->ReplServerName );
        DomainSourceServer = UserInstallInfo->ReplServerName;

    }

    for ( Index = 0;
            Index < ActionCount && ERROR_SUCCESS == WinError;
                Index++ )
    {

        if ( *ActionArray[Index].Value )
        {
            WinError = RegSetValueEx(KeyHandle,
                                     ActionArray[Index].Key,
                                     0,
                                     REG_SZ,
                                     (BYTE*)*ActionArray[Index].Value,
                                     (wcslen(*ActionArray[Index].Value)+1)*sizeof(WCHAR));
        }
    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Write the root domain sid out, too
    //
    if ( DiscoveredInfo->RootDomainSid )
    {
        WinError = RegSetValueEx(KeyHandle,
                                 TEXT(ROOTDOMAINSID),
                                 0,
                                 REG_BINARY,
                                 DiscoveredInfo->RootDomainSid,
                                 RtlLengthSid(DiscoveredInfo->RootDomainSid));

    }

Cleanup:

    RegCloseKey( KeyHandle );

    return WinError;

}

BOOL
NtdspGetUniqueRDN(
    IN OUT WCHAR*  Rdn,
    IN ULONG       RdnSize
    )
{
    BOOL        fStatus = FALSE;
    RPC_STATUS  rpcStatus;
    UUID        Uuid;
    WCHAR       *UuidString;

    ASSERT( Rdn );
    ASSERT( RdnSize > 0 );

    rpcStatus = UuidCreate( &Uuid );

    if (    ( RPC_S_OK              == rpcStatus )
         || ( RPC_S_UUID_LOCAL_ONLY == rpcStatus )
       )
    {
        rpcStatus = UuidToString( &Uuid, &UuidString );

        if ( RPC_S_OK == rpcStatus )
        {
            wcsncpy( Rdn, UuidString, RdnSize );
            RpcStringFree( &UuidString );
            fStatus = TRUE;
        }
    }

    return fStatus;
}

DWORD
NtdspSetSecurityProvider(
    WCHAR *Name
    )
{

    ULONG WinError = ERROR_SUCCESS;
    HKEY  KeyHandle = 0;

    WCHAR *SecurityProviderList = NULL;
    WCHAR *NewSecurityProviderList = NULL;
    DWORD ValueType = REG_SZ;
    ULONG Size = 0;

    WCHAR* SecurityProvidersKey   =
                       L"System\\CurrentControlSet\\Control\\SecurityProviders";
    WCHAR* SecurityProvidersValue = L"SecurityProviders";

    WinError = RegCreateKeyW( HKEY_LOCAL_MACHINE,
                             SecurityProvidersKey,
                             &KeyHandle );

    if ( WinError != ERROR_SUCCESS )
    {
        return WinError;
    }

    Size = 0;
    SecurityProviderList = NULL;
    WinError =  RegQueryValueExW( KeyHandle,
                                 SecurityProvidersValue,
                                 0, // reserved,
                                 &ValueType,
                                 (VOID*) SecurityProviderList,
                                 &Size);

    if ( WinError == ERROR_SUCCESS )
    {
        SecurityProviderList = (WCHAR*) alloca( Size );
        WinError =  RegQueryValueExW( KeyHandle,
                                     SecurityProvidersValue,
                                     0, // reserved,
                                     &ValueType,
                                     (VOID*) SecurityProviderList,
                                     &Size);

        if ( WinError == ERROR_SUCCESS )
        {

            if ( wcsstr( SecurityProviderList, Name ) == NULL )
            {
                Size += (wcslen( Name ) + 1)*sizeof(WCHAR);

                NewSecurityProviderList = (WCHAR*) alloca( Size );
                RtlZeroMemory( NewSecurityProviderList, Size );

                wcscpy( NewSecurityProviderList, SecurityProviderList );
                wcscat( NewSecurityProviderList, L", ");
                wcscat( NewSecurityProviderList, Name);
                Size = (wcslen( NewSecurityProviderList ) + 1)*sizeof(WCHAR);

                WinError = RegSetValueExW( KeyHandle,
                                          SecurityProvidersValue,
                                          0,
                                          ValueType,
                                          (VOID*) NewSecurityProviderList,
                                          Size );
            }
        }
    }

    RegCloseKey( KeyHandle );

    return WinError;

}


DWORD
NtdspSetGPOAttributes(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    )
/*++

Routine Description:

    This routine sets the attributes for the GPO object in the schema.

Parameters:

    UserInstallInfo : user supplied param's

    DiscoveredInfo : derived param's

Return Values:

    An error from the win32 error space resulting from a failed system
    service call

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    HKEY  KeyHandle = NULL;
    WCHAR *DomainFilePath, *DomainLink = NULL;
    WCHAR *DcFilePath = NULL, *DcLink = NULL;

    WCHAR FilePathString[] = L"\\\\%ls\\sysvol\\%ls\\Policies\\{%ls}";
    WCHAR LinkString[]     = L"[LDAP://CN={%ls},CN=Policies,CN=System,%ls;0]";

    WCHAR DomainGPOGuid[] =  STR_DEFAULT_DOMAIN_GPO_GUID;
    WCHAR DcGPOGuid[]     =  STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID;

    WCHAR *GpoUserName = L"User";

    ULONG  Size;
    ULONG  Index;


    struct
    {
        WCHAR *Key;
        WCHAR **Value;

    } ActionArray[] =
    {
        { TEXT(GPO_USER_NAME),        &GpoUserName },
        { TEXT(GPO_DOMAIN_FILE_PATH), &DomainFilePath },
        { TEXT(GPO_DOMAIN_LINK),      &DomainLink },
        { TEXT(GPO_DC_FILE_PATH),     &DcFilePath },
        { TEXT(GPO_DC_LINK),          &DcLink }
    };

    ULONG ActionCount = sizeof(ActionArray) / sizeof(ActionArray[0]);

    //
    // Not necessary on replica installs
    //
    if ( UserInstallInfo->Flags & NTDS_INSTALL_REPLICA  )
    {
        return ERROR_SUCCESS;
    }

    // Parameter check
    ASSERT( UserInstallInfo->DnsDomainName );
    ASSERT( DiscoveredInfo->DomainDN[0] != '0' );

    //
    // Open the parent key
    //
    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_CONFIG_SECTION),
                            &KeyHandle);

    if (WinError != ERROR_SUCCESS) {

        return WinError;

    }

    //
    // Create the values
    //
    Size =   (wcslen( FilePathString ) * sizeof( WCHAR ))
           + (2 * wcslen( UserInstallInfo->DnsDomainName ) * sizeof(WCHAR) )
           + (wcslen( DomainGPOGuid ) * sizeof( WCHAR ) )
           + sizeof( WCHAR );  // good ol' NULL

    DomainFilePath = (WCHAR*) alloca( Size );
    DcFilePath = (WCHAR*) alloca( Size );

    Size =   (wcslen( LinkString ) * sizeof( WCHAR ))
           + (wcslen( DiscoveredInfo->DomainDN ) * sizeof(WCHAR) )
           + (wcslen( DomainGPOGuid ) * sizeof( WCHAR ) )
           + sizeof( WCHAR );  // good ol' NULL

    DomainLink = (WCHAR*) alloca( Size );
    DcLink     = (WCHAR*) alloca( Size );

    // Domain File path
    wsprintf( DomainFilePath, FilePathString,
                              UserInstallInfo->DnsDomainName,
                              UserInstallInfo->DnsDomainName,
                              STR_DEFAULT_DOMAIN_GPO_GUID );

    // Domain link
    wsprintf( DomainLink, LinkString,
                          STR_DEFAULT_DOMAIN_GPO_GUID,
                          DiscoveredInfo->DomainDN );

    // Dc File path
    wsprintf( DcFilePath, FilePathString,
                          UserInstallInfo->DnsDomainName,
                          UserInstallInfo->DnsDomainName,
                          STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID );


    // Domain link
    wsprintf( DcLink, LinkString,
                      STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID,
                      DiscoveredInfo->DomainDN );

    //
    // Apply the values
    //

    for ( Index = 0;
            Index < ActionCount && ERROR_SUCCESS == WinError;
                Index++ )
    {

        if ( *ActionArray[Index].Value )
        {
            WinError = RegSetValueEx(KeyHandle,
                                     ActionArray[Index].Key,
                                     0,
                                     REG_SZ,
                                     (BYTE*)*ActionArray[Index].Value,
                                     (wcslen(*ActionArray[Index].Value)+1)*sizeof(WCHAR));
        }
    }

    RegCloseKey( KeyHandle );

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\saxerrorhandlerimpl.cxx ===
// SAXErrorHandler.cpp: implementation of the SAXErrorHandler class.
//
//////////////////////////////////////////////////////////////////////

#include "NTDScript.h"
#include "SAXErrorHandlerImpl.h"
#include <stdio.h>

#include <ntdsa.h>
#include <fileno.h>

#include "debug.h"
#define DEBSUB "NTDSCONTENT:"
#define FILENO FILENO_NTDSCRIPT_NTDSCONTENT


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

SAXErrorHandlerImpl::SAXErrorHandlerImpl()
{
    _cRef = 1;
}

SAXErrorHandlerImpl::~SAXErrorHandlerImpl()
{

}

HRESULT STDMETHODCALLTYPE SAXErrorHandlerImpl::error( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pError,
			/* [in] */ HRESULT errCode)
{
    int nColumn=0, nLine=0;

    if (pLocator) {
        pLocator->getColumnNumber ( &nColumn );
        pLocator->getLineNumber ( &nLine );

        DPRINT2 (0, "Error: column %d  line %d \n", nColumn,  nLine);
    }

    if (pError) {
        DPRINT1 (0, "Error: %ws\n", pError);
    }

	return S_FALSE;
}
        
HRESULT STDMETHODCALLTYPE SAXErrorHandlerImpl::fatalError( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pError,
			/* [in] */ HRESULT errCode)
{
    int nColumn=0, nLine=0;

    if (pLocator) {
        pLocator->getColumnNumber ( &nColumn );
        pLocator->getLineNumber ( &nLine );

        DPRINT2 (0, "Error: column %d  line %d \n", nColumn,  nLine);
    }

    if (pError) {
        DPRINT1 (0, "Error: %ws\n", pError);
    }

	return S_FALSE;
}
        
HRESULT STDMETHODCALLTYPE SAXErrorHandlerImpl::ignorableWarning( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pError,
			/* [in] */ HRESULT errCode)
{
    int nColumn=0, nLine=0;

    if (pLocator) {
        pLocator->getColumnNumber ( &nColumn );
        pLocator->getLineNumber ( &nLine );

        DPRINT2 (0, "Warning: column %d  line %d \n", nColumn,  nLine);
    }

    if (pError) {
        DPRINT1 (0, "Warning: %ws\n", pError);
    }
    
	return S_OK;
}

long __stdcall SAXErrorHandlerImpl::QueryInterface(const struct _GUID &riid,void ** ppvObject)
{
    if (riid == IID_IUnknown || riid == IID_ISAXErrorHandler)
    {
        *ppvObject = static_cast<ISAXErrorHandler *>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

unsigned long __stdcall SAXErrorHandlerImpl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

unsigned long __stdcall SAXErrorHandlerImpl::Release()
{
    if (InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdscript\src\saxcontenthandlerimpl.h ===
// SAXContentHandlerImpl.h: interface for the SAXContentHandlerImpl class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _SAXCONTENTHANDLERIMPL_H
#define _SAXCONTENTHANDLERIMPL_H


class SAXContentHandlerImpl : public ISAXContentHandler  
{
public:
    SAXContentHandlerImpl();
    virtual ~SAXContentHandlerImpl();

public: // IUnknown
        long __stdcall QueryInterface(const struct _GUID &,void ** );
        unsigned long __stdcall AddRef(void);
        unsigned long __stdcall Release(void);

public: // ISAXContentHandler
            virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator);
        
        virtual HRESULT STDMETHODCALLTYPE startDocument( void);
        
        virtual HRESULT STDMETHODCALLTYPE endDocument( void);
        
        virtual HRESULT STDMETHODCALLTYPE startPrefixMapping(
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri);
        
        virtual HRESULT STDMETHODCALLTYPE endPrefixMapping(
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix);
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
        
        virtual HRESULT STDMETHODCALLTYPE endElement(
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName);
        
        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData);
        
        virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName);

private:
    long    _cRef;
};

#endif //  _SAXCONTENTHANDLERIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\demote.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    demote.c

Abstract:

    Contains function headers for demote utilities used in ntdsetup.dll

Author:

    ColinBr  24-11-1997

Environment:

    User Mode - Nt

Revision History:

    24-11-1997 ColinBr
        Created initial file.


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <NTDSpch.h>
#pragma  hdrstop

#include <rpcdce.h>   // for SEC_WINNT_AUTH_IDENTITY

#include <ntsam.h>    // for lsaisrv.h
#include <lsarpc.h>   // for lsaisrv.h
#include <lsaisrv.h>  // for internal LSA calls
#include <samrpc.h>   // for samisrv.h
#include <samisrv.h>  // for internal SAM call

#include <winldap.h>  // for setputl.h
#include <drs.h>      // for ntdsa.h
#include <ntdsa.h>    // for setuputl.h
#include <dnsapi.h>   // for setuputl.h
#include <lmcons.h>   // for setuputl.h
#include <ntdsetup.h> // for setuputl.h
#include <mdcodes.h>  // for DIRMSG's
#include "setuputl.h" // for NtdspRegistryDelnode
#include <cryptdll.h> // for CDGenerateRandomBits
#include <debug.h>    // DPRINT
#include <attids.h>   // ATT_SUB_REFS
#include <rpc.h>
#include "config.h"
#include <lmaccess.h>
#include <filtypes.h> // for building ds filters
#include "status.h"
#include "sync.h"


#include <dsconfig.h> // for DSA_CONFIG_ROOT

#include <lmapibuf.h> // for NetApiBufferFree
#include <dsaapi.h>   // for DirReplicaDemote / DirReplicaGetDemoteTarget
#include <certca.h>   // CADeleteLocalAutoEnrollmentObject
#include <fileno.h>
#include <dsevent.h>  // for logging support

#include "demote.h"

#define DEBSUB "DEMOTE:"
#define FILENO FILENO_NTDSETUP_NTDSETUP


                
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
DWORD
NtdspGetDomainStatus(
    OUT BOOLEAN* fDomainHasChildren
    );

DWORD
NtdspGetServerStatus(
    OUT BOOLEAN* fLastDcInEnterprise
    );

DWORD
NtdspValidateCredentials(
    IN HANDLE ClientToken,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN WCHAR                   *DemoteHelperDc
    );

DWORD
NtdspDisableDs(
    VOID
    );

DWORD
NtdspDisableDsUndo(
    VOID
    );

DWORD
NtdspCreateNewServerAccountDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO NewAccountDomainInfo
    );

DWORD
NtdspDemoteSam(
    IN BOOLEAN                     fLastDcInDomain,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO NewAccountDomainInfo,
    IN LPWSTR                      AdminPassword OPTIONAL
    );

DWORD
NtdspDemoteSamUndo(
    IN BOOLEAN            fLastDcInDomain
    );

DWORD
NtdspDemoteLsaInfo(
    IN  BOOLEAN fLastDcInDomain,
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO NewAccountSid,
    OUT PLSAPR_POLICY_INFORMATION  *ppAccountDomainInfo,
    OUT PLSAPR_POLICY_INFORMATION  *ppDnsDomainInfo
    );

DWORD
NtdspDemoteLsaInfoUndo(
    IN PLSAPR_POLICY_INFORMATION pAccountDomainInfo,
    IN PLSAPR_POLICY_INFORMATION pDnsDomainInfo
    );

DWORD
NtdspUpdateExternalReferences(
    IN BOOLEAN                     fLastDcInDomain,
    IN ULONG                     Flags,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE                   ClientToken,
    IN WCHAR                   *DemoteHelperDc
    );

DWORD
NtdspShutdownExternalDsInterfaces(
    VOID
    );

DWORD
NtdspGetSourceServerDn(
    IN LPWSTR ServerName,
    IN HANDLE ClientToken,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    OUT DSNAME **SourceServerDn 
    );

DWORD
NtdspDemoteAllNCReplicas(
    IN  LPWSTR   pszDemoteTargetDSADNSName,
    IN  DSNAME * pDemoteTargetDSADN,
    IN  ULONG    Flags
    );

DWORD
NtdspGetDomainFSMOServer(
    LPWSTR  Server,
    IN HANDLE ClientToken,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    LPWSTR *DomainFSMOServer
    );

DWORD
NtdspCheckServerInDomainStatus(
    BOOLEAN *fLastDCInDomain
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exported (from this source file) function definitions                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
NtdspDemote(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials, OPTIONAL
    IN HANDLE                   ClientToken,
    IN LPWSTR                   AdminPassword, OPTIONAL
    IN DWORD                    Flags,
    IN LPWSTR                   ServerName
    )
/*++

Routine Description:

    This routine manages all the actions of the DS and SAM demote operations.

Parameters:

    Credentials:   pointer, credentials that will enable us to
                   change the account object

    ClientToken:   the token of the client; used for impersonation
    
    AdminPassword: pointer, to admin password of new account database

    Flags        : supported flags are:
                     NTDS_LAST_DC_IN_DOMAIN  Last dc in domain 
                     NTDS_LAST_DOMAIN_IN_ENTERPRISE Last dc in enterprise 
                     NTDS_DONT_DELETE_DOMAIN           

    ServerName   : the server to remove ourselves from

Return Values:

    a value from the win32 error space

--*/
{
    DWORD    WinError = ERROR_SUCCESS;
    DWORD    IgnoreWinError;
    NTSTATUS NtStatus, IgnoreNtStatus;

    BOOLEAN fLastDcInDomain  = FALSE;
    BOOLEAN fDomainHasChildren = FALSE;

    BOOLEAN fSamDemoted     = FALSE;
    BOOLEAN fLsaSet         = FALSE;
    BOOLEAN fProductTypeSet = FALSE;

    BOOLEAN fPasswordEncoded = FALSE;
    UCHAR   Seed = 0;
    UNICODE_STRING EPassword;

    HRESULT hResult = S_OK;


    //
    // Resources to be released
    //
    POLICY_ACCOUNT_DOMAIN_INFO NewAccountDomainInfo;
    PLSAPR_POLICY_INFORMATION  pAccountDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION  pDnsDomainInfo     = NULL;


    RtlZeroMemory( &NewAccountDomainInfo, sizeof(POLICY_ACCOUNT_DOMAIN_INFO) );

    //
    // Encrypt the password
    //
    if ( Credentials )
    {
        RtlInitUnicodeString( &EPassword, Credentials->Password );
        RtlRunEncodeUnicodeString( &Seed, &EPassword );
        fPasswordEncoded = TRUE;
    }


    //
    // Make sure we can remove this domain if necessary
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_ENTERPRISE_VALIDATE );

    fLastDcInDomain = (BOOLEAN) (Flags & NTDS_LAST_DC_IN_DOMAIN);

    if ( fLastDcInDomain )
    {
        if ( !(Flags & NTDS_LAST_DOMAIN_IN_ENTERPRISE) )
        {
            WinError = NtdspGetDomainStatus( &fDomainHasChildren );
            if ( ERROR_SUCCESS != WinError )
            {

                NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                          DIRLOG_DEMOTE_DS_DOMAIN_STATUS );
                return WinError;
            }
        }
        else
        {
            fDomainHasChildren = FALSE;
        }
    }


    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Perform some logic
    //
    if ( fLastDcInDomain && fDomainHasChildren )
    {
        WinError = ERROR_DS_CANT_DELETE;
        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRLOG_DEMOTE_IS_OPERATION_VALID );
        goto Cleanup;
    }

    if ( !fLastDcInDomain || fDomainHasChildren )
    {
    
        // caller should have passed this in
        Assert( ServerName );
        if ( !ServerName )
        {
            WinError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // N.B. This routine validates the credentials via ldap
        // early on.
        //

        NTDSP_SET_STATUS_MESSAGE0( DIRMSG_AUTHENTICATING );

        if ( fPasswordEncoded )
        {
            RtlRunDecodeUnicodeString( Seed, &EPassword );
            fPasswordEncoded = FALSE;
        }

        WinError = NtdspValidateCredentials( ClientToken,
                                             Credentials,
                                             ServerName );
    
        if ( ERROR_SUCCESS != WinError )
        {
            
            NTDSP_SET_ERROR_MESSAGE1( WinError, 
                                      DIRMSG_INSTALL_FAILED_BIND,
                                      ServerName );

            goto Cleanup;
        }

        if ( Credentials )
        {
            RtlRunEncodeUnicodeString( &Seed, &EPassword );
            fPasswordEncoded = TRUE;
        }

    }

    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Ok, the enviroment looks ok and we have found a server to help out
    // if we need one. Prepare to demote
    //

    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_NEW_ACCOUNT_INFO );

    //
    // Create the account database identification (lsa policy);
    //
    WinError = NtdspCreateNewServerAccountDomainInfo( &NewAccountDomainInfo );
    if ( ERROR_SUCCESS != WinError )
    {
        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRLOG_INSTALL_FAILED_CREATE_NEW_ACCOUNT_INFO );

        goto Cleanup;
    }

    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Prepare the sam database to be a server
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_SAM );

    WinError = NtdspDemoteSam( fLastDcInDomain,
                               &NewAccountDomainInfo,
                               AdminPassword );
    if ( ERROR_SUCCESS != WinError )
    {

        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRLOG_DEMOTE_SAM_FAILED );

        goto Cleanup;
    }
    fSamDemoted = TRUE;

    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Set the LSA sid information
    //

    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_LSA );

    WinError = NtdspDemoteLsaInfo( fLastDcInDomain,
                                   &NewAccountDomainInfo,
                                   &pAccountDomainInfo,
                                   &pDnsDomainInfo );

    if ( ERROR_SUCCESS != WinError )
    {

        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRLOG_DEMOTE_LSA_FAILED );

        goto Cleanup;
    }
    fLsaSet = TRUE;

    if (TEST_CANCELLATION())
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Set the product type
    //
    WinError = NtdspSetProductType( NtProductServer );
    if ( ERROR_SUCCESS != WinError )
    {

        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRMSG_FAILED_SET_PRODUCT_TYPE );

        goto Cleanup;
    }
    fProductTypeSet = TRUE;

    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // N.B.  At this point, the machine is demoted.  On reboot the machine
    // will be a server.
    //

    //
    // We have prepare the local machine for demote;
    // Now remove ourselves from the enterprise if necessary
    //
    if ( ServerName )
    {

        NTDSP_SET_STATUS_MESSAGE1( DIRMSG_DEMOTE_REMOVING_EXTERNAL_REFS,
                                   ServerName );

        if ( fPasswordEncoded )
        {
            RtlRunDecodeUnicodeString( Seed, &EPassword );
            fPasswordEncoded = FALSE;
        }

        WinError = NtdspUpdateExternalReferences( fLastDcInDomain,
                                                  Flags,
                                                  Credentials,
                                                  ClientToken,
                                                  ServerName );

        if ( ERROR_SUCCESS != WinError )
        {
            //
            // We should have already set the string.
            //
            ASSERT( NtdspErrorMessageSet() );

            goto Cleanup;
        }

        if ( Credentials )
        {
            RtlRunEncodeUnicodeString( &Seed, &EPassword );
            fPasswordEncoded = TRUE;
        }
    }

    //
    // At this point we cannot go back, so do not perform any more
    // critical operations
    //


    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_SHUTTING_DOWN_INTERFACES );

    // Try to tear external heads on to the ds
    IgnoreWinError = NtdspShutdownExternalDsInterfaces();


    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_COMPLETING );

    // Remove the ds's registry settings
    IgnoreWinError = NtdspConfigRegistryUndo();

    //
    // Remove the autoenrollment object
    //
    hResult = CADeleteLocalAutoEnrollmentObject(wszCERTTYPE_DC,  // DC certificate
                                                NULL,            // any CA
                                                NULL,            // reserved
                                                CERT_SYSTEM_STORE_LOCAL_MACHINE
                                               );  
    if (FAILED(hResult) && (hResult != CRYPT_E_NOT_FOUND)) {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hResult)) {
            // Error is an encoded Win32 status -- decode back to Win32.
            IgnoreWinError = HRESULT_CODE(hResult);
        }
        else {
            // Error is in some other facility.  For lack of a better plan,
            // pass the HRESULT off as a Win32 code.
            IgnoreWinError = hResult;
        }

        //
        // Log the error
        //
        LogEvent8WithData( DS_EVENT_CAT_SETUP,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_DEMOTE_REMOVE_CA_ERROR,
                           NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                           sizeof(DWORD), &IgnoreWinError );

    }


    //
    // Fall through to Cleanup
    //

Cleanup:

    if ( WinError != ERROR_SUCCESS )
    {
        // If the operation failed, see if the user cancelled, in which
        // we can fail with cancel

        if ( TEST_CANCELLATION() )
        {
            WinError = ERROR_CANCELLED;
        }
    }

    if ( WinError != ERROR_SUCCESS && fProductTypeSet )
    {
        IgnoreWinError = NtdspSetProductType( NtProductLanManNt );
        ASSERT( IgnoreWinError == ERROR_SUCCESS );
    }

    if ( WinError != ERROR_SUCCESS && fLsaSet )
    {
        IgnoreWinError = NtdspDemoteLsaInfoUndo( pAccountDomainInfo,
                                                 pDnsDomainInfo );
        ASSERT( IgnoreWinError == ERROR_SUCCESS );
    }

    if ( WinError != ERROR_SUCCESS && fSamDemoted )
    {
        IgnoreWinError = NtdspDemoteSamUndo( fLastDcInDomain );
        ASSERT( IgnoreWinError == ERROR_SUCCESS );
    }

    if ( fPasswordEncoded )
    {
        RtlRunDecodeUnicodeString( Seed, &EPassword );
        fPasswordEncoded = FALSE;
    }

    if ( NewAccountDomainInfo.DomainSid )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NewAccountDomainInfo.DomainSid );
    }

    if ( NewAccountDomainInfo.DomainName.Buffer )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NewAccountDomainInfo.DomainName.Buffer );
    }

    if ( pAccountDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) pAccountDomainInfo );
    }

    if ( pDnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) pDnsDomainInfo );
    }

    return WinError;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private function definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
NtdspGetDomainStatus(
    OUT BOOLEAN* fDomainHasChildren
    )
/*++

Routine Description:

    This routine iterates through the subrefs of a domain and it if finds
    domain naming contexts, fDomainHasChildren returns FALSE.

Parameters:

    fDomainHasChildren: TRUE if the domain has children

Return Values:

    a value from the win32 error space

--*/
{

    NTSTATUS      NtStatus = STATUS_SUCCESS;
    DWORD         WinError = ERROR_SUCCESS;
    DWORD         DirError;

    READARG       ReadArg;
    READRES      *ReadRes = 0;

    ENTINFSEL     EntryInfoSelection;
    ATTR          Attr[1];

    ATTRBLOCK    *pAttrBlock;
    ATTR         *pAttr;
    ATTRVALBLOCK *pAttrVal;

    BOOLEAN       fChildDomainFound = FALSE;
    ULONG         Size, cAttrVal;

    DSNAME        *DomainDsName = NULL,
                  *SchemaDsName = NULL,
                  *ConfigDsName = NULL,
                  *SubRefDsName = NULL;

    //
    // Create a thread state
    //
    if ( THCreate( CALLERTYPE_INTERNAL ) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    SampSetDsa( TRUE );

    try {

        Size = 0;
        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         DomainDsName );

        if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
        {
            DomainDsName = (DSNAME*) alloca( Size );

            NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                             &Size,
                                             DomainDsName );
        }

        if ( !NT_SUCCESS( NtStatus ) )
        {
            WinError = RtlNtStatusToDosError( NtStatus );
            leave;
        }


        Size = 0;
        NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                         &Size,
                                         ConfigDsName );

        if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
        {
            ConfigDsName = (DSNAME*) alloca( Size );

            NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                             &Size,
                                             ConfigDsName );
        }

        Size = 0;
        if ( !NT_SUCCESS( NtStatus ) )
        {
            WinError = RtlNtStatusToDosError( NtStatus );
            leave;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_DMD,
                                         &Size,
                                         SchemaDsName );

        if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
        {
            SchemaDsName = (DSNAME*) alloca( Size );

            NtStatus = GetConfigurationName( DSCONFIGNAME_DMD,
                                             &Size,
                                             SchemaDsName );
        }

        if ( !NT_SUCCESS( NtStatus ) )
        {
            WinError = RtlNtStatusToDosError( NtStatus );
            leave;
        }

        //
        // Start to set up the read parameters
        //

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        ReadArg.pObject = DomainDsName;

        //
        // Set up the selection info for the read argument
        //
        RtlZeroMemory( &EntryInfoSelection, sizeof(EntryInfoSelection) );
        EntryInfoSelection.attSel = EN_ATTSET_LIST;
        EntryInfoSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
        EntryInfoSelection.AttrTypBlock.attrCount = 1;
        EntryInfoSelection.AttrTypBlock.pAttr = &(Attr[0]);

        RtlZeroMemory(Attr, sizeof(Attr));
        Attr[0].attrTyp = ATT_SUB_REFS;

        ReadArg.pSel    = &EntryInfoSelection;

        //
        // Setup the common arguments
        //
        InitCommarg(&ReadArg.CommArg);

        //
        // We are now ready to read!
        //
        DirError = DirRead(&ReadArg,
                           &ReadRes);


        if ( DirError == 0 )
        {
            ASSERT( ReadRes );

            pAttrBlock = &(ReadRes->entry.AttrBlock);
            ASSERT( pAttrBlock->attrCount == 1 );

            pAttr = &(pAttrBlock->pAttr[0]);
            ASSERT( pAttr->attrTyp == ATT_SUB_REFS );

            pAttrVal = &(pAttr->AttrVal);

            for ( cAttrVal = 0; cAttrVal < pAttrVal->valCount; cAttrVal++ )
            {

                SubRefDsName = (DSNAME*) pAttrVal->pAVal[cAttrVal].pVal;
                ASSERT( SubRefDsName );

                if ( memcmp(&SubRefDsName->Guid, &ConfigDsName->Guid, sizeof(GUID))
                  && memcmp(&SubRefDsName->Guid, &SchemaDsName->Guid, sizeof(GUID)) )
                {
                    fChildDomainFound = TRUE;
                    break;
                }

            }
        }
        else
        {
            DPRINT1( 0, "DirRead returned unexpected error %d in NtdspGetDomainStatus\n", DirError );
        }

    }
    finally
    {
        THDestroy();
    }

    if ( WinError == ERROR_SUCCESS )
    {
        if ( fDomainHasChildren )
        {
            *fDomainHasChildren = fChildDomainFound;
        }

    }
    return WinError;
}


DWORD
NtdspValidateCredentials(
    IN HANDLE ClientToken,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN WCHAR                   *ServerName
    )
/*++

Routine Description:

    This routine makes sure the credentials can be authenticated.

Parameters:

    ClientToken: the token of the user requesting this change
                              
    Credentials: NULL, or a pointer to credentials to use.

    ServerName: the server to authenticate against

Return Values:

    a value from the win32 error space

--*/
{
    DWORD WinError;
    DWORD LdapError;

    LDAP  *hLdap;

    ASSERT( ServerName  );

    hLdap = ldap_openW( ServerName,
                        LDAP_PORT );

    if ( !hLdap )
    {
        WinError = GetLastError();

        if (WinError == ERROR_SUCCESS)
        {
            // This works around a bug in the ldap client
            WinError = ERROR_CONNECTION_INVALID;
        }

        return WinError;
    }

    //
    // Bind
    //
    LdapError = impersonate_ldap_bind_sW(ClientToken,
                                         hLdap,
                                         NULL,  // use credentials instead
                                         (VOID*)Credentials,
                                         LDAP_AUTH_SSPI);

    WinError = LdapMapErrorToWin32( LdapError );

    if (ERROR_GEN_FAILURE == WinError ||
        ERROR_WRONG_PASSWORD == WinError )  {
        // This does not help anyone.  AndyHe needs to investigate
        // why this returning when invalid credentials are passed in.
        WinError = ERROR_NOT_AUTHENTICATED;
    }

    ldap_unbind_s( hLdap );

    return WinError;
}


DWORD
NtdspDisableDs(
    VOID
    )
/*++

Routine Description:

    This routine simply turns off updates in the ds.

Parameters:

    None.


Return Values:

    ERROR_SUCCESS

--*/
{
    DsaDisableUpdates();

    return ERROR_SUCCESS;
}

DWORD
NtdspDisableDsUndo(
    VOID
    )
/*++

Routine Description:

    This routine simply turns on updates in the ds.

Parameters:

    None.


Return Values:

    ERROR_SUCCESS

--*/
{
    DsaEnableUpdates();

    return ERROR_SUCCESS;
}


DWORD
NtdspDemoteSam(
    IN BOOLEAN                     fLastDcInDomain,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO NewAccountDomainInfo,
    IN LPWSTR                      AdminPassword  OPTIONAL
    )
/*++

Routine Description:

    This routine calls into the SAM dll via SamIDemote() so SAM can prepare
    itself to be a server upon reboot.

    The effects of this routine can be undone via NtdspDemoteSamUndo.

Parameters:

    fLastDcInDomain:  TRUE if this is the last dc in the domain

    NewAccountDomainInfo: the account domain info to use

    AdminPassword:        the admin password of the new domain

Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus;
    DWORD    WinError;
    ULONG    DemoteFlags = 0;

    //
    // Call into SAM
    //
    if ( fLastDcInDomain )
    {
        DemoteFlags |= SAMP_DEMOTE_STANDALONE;
    }
    else
    {
        DemoteFlags |= SAMP_DEMOTE_MEMBER;
    }

    NtStatus = SamIDemote( DemoteFlags,
                           NewAccountDomainInfo,
                           AdminPassword );

    WinError = RtlNtStatusToDosError( NtStatus );

    return WinError;
}


DWORD
NtdspDemoteSamUndo(
    IN BOOLEAN            fLastDcInDomain
    )
/*++

Routine Description:

    Undoes NtdspDemoteSam


Parameters:

    fLastDcInDomain - not currently used

Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus;
    DWORD    WinError;

    NtStatus = SamIDemoteUndo();

    WinError = RtlNtStatusToDosError( NtStatus );

    return WinError;
}


DWORD
NtdspDemoteLsaInfo(
    IN  BOOLEAN fLastDcInDomain,
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO   NewAccountDomainInfo,
    OUT PLSAPR_POLICY_INFORMATION *ppAccountDomainInfo,
    OUT PLSAPR_POLICY_INFORMATION *ppDnsDomainInfo
    )
/*++

Routine Description:

    This routine sets the account and primary domain information in the lsa
    to prepare for the demotion.

Parameters:

    fLastDcInDomain : TRUE if this is the last dc in the domain

    NewAccountSid   : the sid of the new account domain

    ppAccountDomainInfo: pointer, the account info before this function is called

    ppDnsDomainInfo : pointer, the dns info before this function is called

Return Values:

    a value from the win32 error space

--*/
{
    DWORD    WinError;
    NTSTATUS NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES  PolicyObject;
    HANDLE             hPolicyObject = INVALID_HANDLE_VALUE;

    POLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    BOOLEAN                fAccountDomainInfoSet = FALSE;

    //
    // Some parameter checking
    //
    ASSERT( NewAccountDomainInfo );
    ASSERT( ppAccountDomainInfo );
    ASSERT( ppDnsDomainInfo );

    //
    //  Clear the out parameters
    //
    *ppAccountDomainInfo = NULL;
    *ppDnsDomainInfo = NULL;

    //
    // First get a copy of the existing policy information
    //
    NtStatus = LsaIQueryInformationPolicyTrusted(
                            PolicyAccountDomainInformation,
                            ppAccountDomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
       goto Cleanup;
    }

    NtStatus = LsaIQueryInformationPolicyTrusted(
                            PolicyDnsDomainInformation,
                            ppDnsDomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Now set the new values; first we must open a handle to the
    // policy object
    //
    RtlZeroMemory(&PolicyObject, sizeof(PolicyObject));
    NtStatus = LsaOpenPolicy(NULL,
                             &PolicyObject,
                             POLICY_ALL_ACCESS,
                             &hPolicyObject);
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }

    //
    // Set the information
    //
    NtStatus = LsaSetInformationPolicy( hPolicyObject,
                                        PolicyAccountDomainInformation,
                                        NewAccountDomainInfo );
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fAccountDomainInfoSet =  TRUE;

    if ( fLastDcInDomain )
    {
        //
        // Set the workgroup to "Workgroup"
        //
        RtlZeroMemory( &DnsDomainInfo, sizeof( DnsDomainInfo ) );

        RtlInitUnicodeString( (UNICODE_STRING*) &DnsDomainInfo.Name,
                              L"WORKGROUP" );

        NtStatus = LsaSetInformationPolicy( hPolicyObject,
                                            PolicyDnsDomainInformation,
                                            &DnsDomainInfo );

        if ( !NT_SUCCESS(NtStatus) ) {
            goto Cleanup;
        }

    }

    //
    // That's it - fall through to cleanup.
    //

Cleanup:


    if ( !NT_SUCCESS( NtStatus ) )
    {

        if ( fAccountDomainInfoSet )
        {
            IgnoreStatus = LsaSetInformationPolicy( hPolicyObject,
                                                    PolicyAccountDomainInformation,
                                                    *ppAccountDomainInfo );
        }


        if ( *ppAccountDomainInfo )
        {
            LsaIFree_LSAPR_POLICY_INFORMATION( PolicyAccountDomainInformation,
                                               (PLSAPR_POLICY_INFORMATION) *ppAccountDomainInfo );
            *ppAccountDomainInfo = NULL;
        }

        if ( *ppDnsDomainInfo )
        {
            LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                               (PLSAPR_POLICY_INFORMATION) *ppDnsDomainInfo );
            *ppDnsDomainInfo = NULL;
        }
    }

    if ( hPolicyObject != INVALID_HANDLE_VALUE )
    {
        LsaClose( hPolicyObject );
    }


    return RtlNtStatusToDosError( NtStatus );
}


DWORD
NtdspDemoteLsaInfoUndo(
    IN PLSAPR_POLICY_INFORMATION pAccountDomainInfo,
    IN PLSAPR_POLICY_INFORMATION pDnsDomainInfo
    )
/*++

Routine Description:

    This routine undoes the effect of DemoteLsa by setting the saved values
    as passed in.

Parameters:

    pAccountDomainInfo : the saved account domain info

    pDnsDomainInfo: the save dns domain info


Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus, NtStatus2;
    DWORD    WinError;


    OBJECT_ATTRIBUTES  PolicyObject;
    HANDLE             hPolicyObject = INVALID_HANDLE_VALUE;

    //
    // Parameter check
    //
    ASSERT( pAccountDomainInfo );
    ASSERT( pDnsDomainInfo );

    //
    // Open the policy
    //
    RtlZeroMemory( &PolicyObject, sizeof(PolicyObject) );
    NtStatus = LsaOpenPolicy(NULL,
                             &PolicyObject,
                             POLICY_ALL_ACCESS,
                             &hPolicyObject);
    if ( !NT_SUCCESS(NtStatus) ) {
        WinError = RtlNtStatusToDosError(NtStatus);
        return WinError;
    }

    //
    // Set the information
    //
    NtStatus = LsaSetInformationPolicy( hPolicyObject,
                                        PolicyAccountDomainInformation,
                                        pAccountDomainInfo );

    NtStatus2 = LsaSetInformationPolicy( hPolicyObject,
                                         PolicyDnsDomainInformation,
                                         pDnsDomainInfo );

    if ( NT_SUCCESS( NtStatus )  && !NT_SUCCESS( NtStatus2 ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus2 );
    }
    else
    {
        WinError = RtlNtStatusToDosError( NtStatus );
    }

    LsaClose( hPolicyObject );

    return WinError;
}


DWORD
NtdspUpdateExternalReferences(
    IN BOOLEAN                   fLastDcInDomain,
    IN ULONG                     Flags,
    IN SEC_WINNT_AUTH_IDENTITY  *Credentials,
    IN HANDLE                    ClientToken,
    IN WCHAR                    *GivenServerName
    )
/*++

Routine Description:

    This routine removes all references to the server and domain
    , if necessary, from the enterprise ds (ie config container)

Parameters:

    fLastDcInDomain:  if true the domain will be removed

    Credentials:  the credentials to use
    
    ClientToken:  the client token; to be used for impersonation

    ServerName: the server name to connect to to remove these values


Return Values:

    a value from the win32 error space

--*/
{
    DWORD    WinError = ERROR_SUCCESS, IgnoreError;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE   hDs = 0;
    ULONG    Size;
    DSNAME   *LocalDsa, *Domain;

    BOOLEAN fMachineAccountSet = FALSE;
    WCHAR   MachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG   Length;
    PDSNAME LocalServerDn = NULL;
    HANDLE  SystemToken = 0;
    BOOLEAN fImpersonate = FALSE;
    WCHAR   *OldAccountDn = NULL;

    LPWSTR  DomainFSMOServer = NULL;

    LPWSTR  ServerName = GivenServerName;


    if ( NULL == Credentials )
    {
        //
        // No credentials - impersonate the caller
        //
        WinError = NtdspImpersonation( ClientToken,
                                       &SystemToken );
        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }
        fImpersonate = TRUE;
    }

    //
    // Get the machine account name
    //
    RtlZeroMemory( MachineAccountName, sizeof( MachineAccountName ) );

    Length = sizeof( MachineAccountName ) / sizeof( MachineAccountName[0] );
    if ( !GetComputerName( MachineAccountName, &Length ) )
    {
        WinError = GetLastError();
        goto Cleanup;
    }
    wcscat( MachineAccountName, L"$" );

    //
    // Try to update the server's account control field
    //
    if ( !fLastDcInDomain )
    {
        WinError = NtdsSetReplicaMachineAccount( Credentials,
                                                 ClientToken,
                                                 ServerName,
                                                 MachineAccountName,
                                                 UF_WORKSTATION_TRUST_ACCOUNT,
                                                 &OldAccountDn );
    
        if ( ERROR_SUCCESS != WinError )
        {
            NTDSP_SET_ERROR_MESSAGE2( WinError, 
                                      DIRLOG_DEMOTE_SET_MACHINE_ACC_FAILED,
                                      MachineAccountName,
                                      ServerName );
    
            goto Cleanup;
        }
        fMachineAccountSet = TRUE;
    }
    else
    {
        if ( !FLAG_ON( Flags, NTDS_DONT_DELETE_DOMAIN ) )
        {
            //
            // This is the last dc in domain - we need to find the domain 
            // naming FSMO master
            //
            WinError = NtdspGetDomainFSMOServer( ServerName,
                                                 ClientToken,
                                                 Credentials,
                                                 &DomainFSMOServer );
            if ( ERROR_SUCCESS != WinError )
            {
                Assert( NtdspErrorMessageSet() );
                goto Cleanup;
            }
    
            ServerName = DomainFSMOServer;
            DomainFSMOServer = NULL;
        }
    }

    //
    // Get the current server's name
    //
    Size = 0;
    LocalDsa = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                     &Size,
                                     LocalDsa );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        LocalDsa = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                         &Size,
                                         LocalDsa );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    LocalServerDn = alloca( LocalDsa->structLen );
    memset( LocalServerDn, 0, LocalDsa->structLen );
    TrimDSNameBy( LocalDsa, 1, LocalServerDn );


    Size = 0;
    Domain = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     Domain );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        Domain = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         Domain );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Connect to the remote server
    //
    WinError = ImpersonateDsBindWithCredW( ClientToken,
                                           ServerName,
                                           NULL,
                                           (RPC_AUTH_IDENTITY_HANDLE) Credentials,
                                           &hDs );

    if ( WinError != ERROR_SUCCESS )
    {
        NTDSP_SET_ERROR_MESSAGE1( WinError, 
                                  DIRMSG_INSTALL_FAILED_BIND,
                                  ServerName );
        goto Cleanup;
    }

    WinError = DsRemoveDsServer( hDs,
                                 LocalServerDn->StringName,
                                 Domain->StringName,
                                 NULL,
                                 TRUE );  // commit


    if ( WinError != ERROR_SUCCESS)
    {
        DPRINT1( 0, "DsRemoveDsServer returned %d\n", WinError );
        if ( ERROR_DS_CANT_FIND_DSA_OBJ == WinError )
        {
            // That's fine
            WinError = ERROR_SUCCESS;
        }
        else
        {

            NTDSP_SET_ERROR_MESSAGE2( WinError, 
                                      DIRLOG_INSTALL_FAILED_TO_DELETE_SERVER,
                                      ServerName,
                                      LocalServerDn->StringName );

            goto Cleanup;

        }
    }

    if (  (WinError == ERROR_SUCCESS)
       && fLastDcInDomain 
       && !FLAG_ON( Flags, NTDS_DONT_DELETE_DOMAIN ) )
    {

        //
        // Remove the domain, too
        //
        WinError = DsRemoveDsDomain( hDs,
                                     Domain->StringName );

        if ( WinError != ERROR_SUCCESS)
        {
            DPRINT1( 0, "DsRemoveDsDomain returned %d\n", WinError );
            if ( ERROR_DS_NO_CROSSREF_FOR_NC == WinError )
            { 
                WinError = ERROR_SUCCESS;
            }
            else
            {
                NTDSP_SET_ERROR_MESSAGE2( WinError, 
                                          DIRLOG_INSTALL_FAILED_TO_DELETE_DOMAIN,
                                          ServerName,
                                          Domain->StringName );
                goto Cleanup;
    
            }
        }
    }


    //
    // That's it; fall through to cleanup
    //

Cleanup:

    if ( ERROR_SUCCESS != WinError && fMachineAccountSet )
    {
        IgnoreError = NtdsSetReplicaMachineAccount( Credentials,
                                                    ClientToken,
                                                    ServerName,
                                                    MachineAccountName,
                                                    UF_SERVER_TRUST_ACCOUNT,
                                                    &OldAccountDn );
    }

    if ( ServerName && ServerName != GivenServerName )
    {
        NtdspFree( ServerName );
    }

    if ( hDs )
    {
        DsUnBind( &hDs );
    }

    if ( fImpersonate )
    {
        IgnoreError = NtdspImpersonation( SystemToken,
                                          NULL );
    }

    
    if ( WinError == ERROR_DS_SECURITY_CHECKING_ERROR )
    {
        WinError = ERROR_ACCESS_DENIED;
    }

    if ( WinError != ERROR_SUCCESS )
    {
        //
        // A general catch all error message
        //

        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRLOG_DEMOTE_FAILED_TO_UPDATE_EXTN );
    }

    if ( OldAccountDn )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, OldAccountDn );
    }


    return WinError;

}

NTSTATUS
NtdspCreateSid(
    OUT PSID *NewSid
    )
/*++

Routine Description

    This routine creates a new sid.  Typically this routine will be called
    when creating a new domain.

Parameters

    NewSid  : Pointer to a pointer to sid

Return Values

    STATUS_SUCCESS or STATUS_NO_MEMORY

--*/
{
    //
    // This value can be moved up to 8
    //
    #define NEW_DOMAIN_SUB_AUTHORITY_COUNT  4

    NTSTATUS  NtStatus;
    BOOLEAN   fStatus;

    SID_IDENTIFIER_AUTHORITY  IdentifierAuthority;
    ULONG                     SubAuthority[8];

    int       i;

    ASSERT(NewSid);

    //
    // Set up the IdentifierAuthority
    //
    RtlZeroMemory(&IdentifierAuthority, sizeof(IdentifierAuthority));
    IdentifierAuthority.Value[5] = 5;

    //
    // Set up the subauthorities
    //
    RtlZeroMemory(SubAuthority, sizeof(SubAuthority));

    //
    // The first sub auth for every account domain is
    // SECURITY_NT_NON_UNIQUE
    //
    SubAuthority[0] = SECURITY_NT_NON_UNIQUE;

    for (i = 1; i < NEW_DOMAIN_SUB_AUTHORITY_COUNT; i++) {

        fStatus = CDGenerateRandomBits( (PUCHAR) &SubAuthority[i],
                                        sizeof(ULONG) );

        ASSERT( fStatus == TRUE );
    }

    //
    // Create the sid
    //
    NtStatus = RtlAllocateAndInitializeSid(&IdentifierAuthority,
                                           NEW_DOMAIN_SUB_AUTHORITY_COUNT,
                                           SubAuthority[0],
                                           SubAuthority[1],
                                           SubAuthority[2],
                                           SubAuthority[3],
                                           SubAuthority[4],
                                           SubAuthority[5],
                                           SubAuthority[6],
                                           SubAuthority[7],
                                           NewSid);
    if ( NT_SUCCESS(NtStatus) )
    {
        ASSERT( *NewSid );
        ASSERT( RtlValidSid( *NewSid ) );
    }

    return NtStatus;
}


DWORD
NtdspCreateNewServerAccountDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo
    )
/*++

Routine Description:

    This routine completely fills in am account domain information
    with a new sid and the account domain name (the computer name)

Parameters:

    AccountDomainInfo : pointer, to structure to be filled in

Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus;

    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG ComputerNameLength = sizeof(ComputerName)/sizeof(ComputerName[0]);
    ULONG Size;

    WCHAR *ComputerName2 = NULL;

    //
    // Some parameter checking
    //
    ASSERT( AccountDomainInfo );
    RtlZeroMemory( AccountDomainInfo, sizeof( POLICY_ACCOUNT_DOMAIN_INFO ) );


    // Set up the sid
    NtStatus = NtdspCreateSid( &AccountDomainInfo->DomainSid );

    if ( NT_SUCCESS( NtStatus ) )
    {
        // Set up the name
        if ( GetComputerName( ComputerName, &ComputerNameLength ) )
        {
            Size = (ComputerNameLength+1) * sizeof(WCHAR);
            ComputerName2 = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(),
                                                      0,
                                                      Size );
            if ( ComputerName2 )
            {
                RtlZeroMemory( ComputerName2, Size );
                wcscpy( ComputerName2, ComputerName );
                RtlInitUnicodeString( &AccountDomainInfo->DomainName, ComputerName2 );
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    if ( NT_SUCCESS( NtStatus ) )
    {
        DPRINT1( 0, "New account name is %ls\n", AccountDomainInfo->DomainName.Buffer );
    }

    return RtlNtStatusToDosError( NtStatus );

}


DWORD
NtdspShutdownExternalDsInterfaces(
    VOID
    )
/*++

Routine Description:

    This routine calls into the ds to shutdown external interfaces, like
    LDAP and RPC.

Parameters:

    None.

Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus;

    NtStatus = DsUninitialize( TRUE ); // only shutdown external clients

    return  RtlNtStatusToDosError( NtStatus );
}


DWORD
NtdspPrepareForDemotion(
    IN ULONG Flags,
    IN LPWSTR ServerName,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN HANDLE                   ClientToken,
    OUT PNTDS_DNS_RR_INFO *pDnsRRInfo
    )
/*++

Routine Description:

    This routine attempts to remove all FSMO's from the current machine
    
    NOTE: This call is made while impersonated; the Dir call is expected
    to do the Access check.

Parameters:

    Flags - Indicates what kind of demote this is
    
    ServerName - the server that is helping with the demotion 

    ClientToken - the token of the client; used for impersonation
    pDnsRRInfo - structure that caller uses to deregister the dns records
                 of this DC
                
Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD WinError = ERROR_SUCCESS;
    DWORD DirError = 0;

    BOOLEAN fLastDcInEnterprise = FALSE;
    BOOLEAN fLastDcInDomain     = FALSE;
    BOOLEAN fDsDisabled         = FALSE;

    DSNAME*  ServerHelperDn = NULL;
    DSNAME*  LocalDsa = NULL;
    DSNAME*  LocalDomain = NULL;
    ULONG    Size;

    PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo = NULL;
    PNTDS_DNS_RR_INFO pInfo = NULL;


    // Parameter check and initialization
    Assert( pDnsRRInfo );
    (*pDnsRRInfo) = NULL;

    //
    // Now, stop any originating write to the DS
    //
    WinError = NtdspDisableDs();
    if ( ERROR_SUCCESS != WinError )
    {
        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRLOG_DEMOTE_IS_PARTIAL_SHUTDOWN );

        goto Cleanup;
    }
    fDsDisabled = TRUE;

    // Give us a thread state
    if ( THCreate( CALLERTYPE_INTERNAL ) )
    {
        NTDSP_SET_ERROR_MESSAGE0( ERROR_NOT_ENOUGH_MEMORY, 
                                  DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS );
        WinError = ERROR_NOT_ENOUGH_MEMORY;

        goto Cleanup;
    }

    //
    // Credentials to demote (which are checked at the Demote API level is 
    // sufficent to give FSMO's away.
    //
    SampSetDsa( TRUE );
    
    _try
    {
        //
        // First determine if we are the last dc in the enterprise; 
        // if so there is nothing to do
        //
        WinError = NtdspGetServerStatus( &fLastDcInEnterprise );
        if ( ERROR_SUCCESS != WinError )
        {
            // this must have been a resource error
            NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                      DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS );
            _leave;
        }

        if ( fLastDcInEnterprise
          && !(Flags & NTDS_LAST_DC_IN_DOMAIN) ) {

            //
            // This is a mismatch -- fail the call
            //
            WinError = ERROR_DS_UNWILLING_TO_PERFORM;
            NTDSP_SET_ERROR_MESSAGE0( ERROR_DS_UNWILLING_TO_PERFORM, 
                                      DIRLOG_DEMOTE_LAST_DC_MISMATCH );
            _leave;

            
        }

        if ( !fLastDcInEnterprise )
        {
            //
            // Do networked operations
            //

            //
            // Verify the "last DC in domain" bit with reality
            //
            // BUGBUG 2000-05-10 JeffParh - Need similar check for NDNCs?
            // Currently always assume not last replica of NDNC.
            //
            WinError = NtdspCheckServerInDomainStatus( &fLastDcInDomain );
            if ( ERROR_SUCCESS != WinError )
            {
                // this must have been a resource error
                NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                          DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS );
                _leave;
            }
    
    
            if ( fLastDcInDomain && !(Flags & NTDS_LAST_DC_IN_DOMAIN) ) { 
    
                //
                // This is a mismatch -- fail the call
                //
                WinError = ERROR_DS_UNWILLING_TO_PERFORM;
                NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                          DIRLOG_DEMOTE_LAST_DC_MISMATCH );
                _leave;
    
            }
    
            if ( !fLastDcInDomain && (Flags & NTDS_LAST_DC_IN_DOMAIN) ) {
    
                //
                // This is a mismatch -- fail the call
                //
                WinError = ERROR_DS_UNWILLING_TO_PERFORM;
                NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                          DIRLOG_DEMOTE_NOT_LAST_DC_MISMATCH );
                _leave;
    
            }
    
            // Get the dn of the server we want to give FSMOs/replicate changes to
            WinError = NtdspGetSourceServerDn( ServerName,
                                               ClientToken,
                                               Credentials,
                                               &ServerHelperDn );
            if ( ERROR_SUCCESS != WinError )
            {
                NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                          DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS );
                goto Cleanup;
            }
        
            //
            // Ok -- we are good to go
            //
                
            WinError = NtdspDemoteAllNCReplicas( ServerName,
                                                 ServerHelperDn,
                                                 Flags );
    
            if ( ERROR_SUCCESS != WinError )
            {
                // Error message already set.
                Assert(NtdspErrorMessageSet());
                _leave;
            }

        }

        
        //
        // Get the DNS RR info
        //
        // BUGBUG 2000-05-11 JeffParh - Does this need to be extended for NDNCs,
        // multiple domains, etc?
        //
        pInfo = NtdspAlloc( sizeof(NTDS_DNS_RR_INFO) );
        if ( !pInfo ) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            _leave;
        }
        *pDnsRRInfo = pInfo;
        RtlZeroMemory( pInfo, sizeof(NTDS_DNS_RR_INFO) );


        // DSA GUID
        Size = 0;
        LocalDsa = NULL;
        NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                         &Size,
                                         LocalDsa );
        if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
        {
           LocalDsa = (DSNAME*) alloca( Size );
        
           NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                            &Size,
                                            LocalDsa );
        
        }
        Assert( NT_SUCCESS( NtStatus ) );
        RtlCopyMemory( &pInfo->DsaGuid, &LocalDsa->Guid, sizeof(GUID) );

        // Domain GUID
        Size = 0;
        LocalDomain = NULL;
        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                        &Size,
                                         LocalDomain );
        if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
        {
           LocalDomain = (DSNAME*) alloca( Size );
        
           NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                            &Size,
                                            LocalDomain );
        
        }
        Assert( NT_SUCCESS( NtStatus ) );
        RtlCopyMemory( &pInfo->DomainGuid, &LocalDomain->Guid, sizeof(GUID) );


        // Dns HostName
        Size = 0;
        GetComputerNameExW( ComputerNameDnsFullyQualified,
                            NULL,
                            &Size );
        pInfo->DnsHostName = NtdspAlloc( Size * sizeof(WCHAR) );
        if ( !pInfo->DnsHostName ) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            _leave;
        }

        if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                                  pInfo->DnsHostName,
                                  &Size ) ) {

            NtdspFree( pInfo->DnsHostName );
            pInfo->DnsHostName = NULL;
        }

        // Domain DNS name
        NtStatus = LsaIQueryInformationPolicyTrusted(
                        PolicyDnsDomainInformation,
                        (PLSAPR_POLICY_INFORMATION*) &pDnsDomainInfo);

        if ( NT_SUCCESS( NtStatus ) ) {

            Assert( pDnsDomainInfo->DnsDomainName.Length > 0 );
            pInfo->DnsDomainName = NtdspAlloc( pDnsDomainInfo->DnsDomainName.Length + sizeof(WCHAR) );
            if ( !pInfo->DnsDomainName ) {

                WinError = ERROR_NOT_ENOUGH_MEMORY;
                _leave;
            }
            RtlZeroMemory( pInfo->DnsDomainName, pDnsDomainInfo->DnsDomainName.Length + sizeof(WCHAR) );
            RtlCopyMemory( pInfo->DnsDomainName, pDnsDomainInfo->DnsDomainName.Buffer, pDnsDomainInfo->DnsDomainName.Length );
        }


        //
        // That's it
        //

    }
    _finally
    { 
        THDestroy();
    }

Cleanup:

    if ( ERROR_SUCCESS != WinError )
    {
        if ( fDsDisabled )
        {
            DWORD IgnoreError;
            IgnoreError = NtdspDisableDsUndo();
            Assert( ERROR_SUCCESS == IgnoreError );
        }

        if ( (*pDnsRRInfo) ) {

            NtdsFreeDnsRRInfo ( (*pDnsRRInfo) );
            *pDnsRRInfo = NULL;

        }
    }

    if ( pDnsDomainInfo ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)pDnsDomainInfo );
        
    }


    if (NULL != ServerHelperDn) {
        NtdspFree(ServerHelperDn);
    }
    
    return WinError;

}

DWORD
NtdspPrepareForDemotionUndo(
    VOID
    )
/*++

Routine Description:
    
    This routine undoes the effect of NtdsPrepareForDemotion

Parameters:

    None.

Return Values:

    a value from the win32 error space

--*/
{
    DWORD WinError  = ERROR_SUCCESS;

    WinError = NtdspDisableDsUndo();

    Assert( ERROR_SUCCESS == WinError );

    return WinError;
}


DWORD
NtdspGetServerStatus(
    OUT BOOLEAN* fLastDcInEnterprise
    )
/*++

Routine Description:

    This routine determines if the server is the last dc in the enterprise

Parameters:

    fLastDcInEnterprise: 

Return Values:

    a value from the win32 error space

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD DirError;

    NTSTATUS NtStatus;

    SEARCHARG  SearchArg;
    SEARCHRES  *SearchRes;

    DWORD      dwNtdsDsaClass = CLASS_NTDS_DSA;
    DSNAME     *SearchBase, *Configuration;
    WCHAR      SitesKeyword[] = L"Sites";

    DWORD      Size;
    FILTER     ObjClassFilter;

    ASSERT( fLastDcInEnterprise );
    *fLastDcInEnterprise = FALSE;

    //
    // Default the return parameter
    //
    Size = 0;
    Configuration = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                     &Size,
                                     Configuration );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        Configuration = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                         &Size,
                                         Configuration );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        return WinError;
    }

    Size = 0;
    SearchBase = NULL;
    Size = AppendRDN(Configuration,
                     SearchBase,
                     Size,
                     SitesKeyword,
                     0,
                     ATT_COMMON_NAME);
    Assert( Size > 0 );
    if (Size > 0)
    {
        // need to realloc
        SearchBase = (DSNAME *) alloca( Size );
        Size = AppendRDN(Configuration,
                         SearchBase,
                         Size,
                         SitesKeyword,
                         0,
                         ATT_COMMON_NAME);
        Assert( 0 == Size);

    }


    //
    // Setup the filter
    //
    RtlZeroMemory( &ObjClassFilter, sizeof( ObjClassFilter ) );

    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwNtdsDsaClass );
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &dwNtdsDsaClass;
    ObjClassFilter.pNextFilter = NULL;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = SearchBase;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &ObjClassFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( SearchRes )
    {
        WinError = DirErrorToWinError( DirError, &SearchRes->CommRes );
    
        if ( ERROR_SUCCESS == WinError )
        {
            if ( SearchRes->count == 1 )
            {
                *fLastDcInEnterprise = TRUE;
            }
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return WinError;
}

DWORD
NtdspGetSourceServerDn(
    IN LPWSTR ServerName,
    IN HANDLE                   ClientToken,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    OUT DSNAME **SourceServerDn
    )
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG LdapError = 0;

    NTDS_CONFIG_INFO ConfigInfo;
    LDAP *hLdap = NULL;
    DWORD ServerDNLen;
    DWORD Size;

    // Parameter check
    Assert( ServerName );
    Assert( SourceServerDn );

    // Stack clearing
    RtlZeroMemory( &ConfigInfo, sizeof( ConfigInfo ) );

    //
    // Open an ldap connection to source server
    //
    hLdap = ldap_openW(ServerName, LDAP_PORT);

    if (!hLdap) {

        WinError = GetLastError();

        if (WinError == ERROR_SUCCESS) {
            //
            // This works around a bug in the ldap client
            //
            WinError = ERROR_CONNECTION_INVALID;
        }

        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_INSTALL_FAILED_LDAP_CONNECT,
                                  ServerName );

        goto Cleanup;
    }

    //
    // Bind
    //
    LdapError = impersonate_ldap_bind_sW(ClientToken,
                                         hLdap,
                                         NULL,  // use credentials instead
                                         (VOID*)Credentials,
                                         LDAP_AUTH_SSPI);

    WinError = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS != WinError) {
        if (ERROR_GEN_FAILURE == WinError ||
            ERROR_WRONG_PASSWORD == WinError )  {
            WinError = ERROR_NOT_AUTHENTICATED;
        }

        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_INSTALL_FAILED_BIND,
                                  ServerName );

        goto Cleanup;
    }

    WinError = NtdspQueryConfigInfo( hLdap,
                                     &ConfigInfo );


    if (ERROR_SUCCESS != WinError) {

        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG,
                                  ServerName );
        goto Cleanup;

    }

    // Transfer the goods
    ServerDNLen = wcslen(ConfigInfo.ServerDN);
    Size = DSNameSizeFromLen(ServerDNLen);
    *SourceServerDn = NtdspAlloc(Size);
    if (NULL == *SourceServerDn) {
        WinError = ERROR_OUTOFMEMORY;
        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG,
                                  ServerName );
        goto Cleanup;
    }

    memset(*SourceServerDn, 0, Size);
    (*SourceServerDn)->structLen = Size;
    (*SourceServerDn)->NameLen = ServerDNLen;
    wcscpy((*SourceServerDn)->StringName, ConfigInfo.ServerDN);

    //
    // That's it - fall through to cleanup
    //

Cleanup:

    if ( hLdap )
    {
        ldap_unbind_s(hLdap);
    }

    NtdspReleaseConfigInfo( &ConfigInfo );

    return WinError;
}

DWORD
NtdspDemoteAllNCReplicas(
    IN  LPWSTR   pszDemoteTargetDSADNSName,
    IN  DSNAME * pDemoteTargetDSADN,
    IN  ULONG    Flags
    )
{
    DWORD err = 0;
    DWORD errLastDemote = 0;
    DWORD errLastTargetSearch = 0;
    DWORD rgNCTypes[] = {
        DSCNL_NCS_SCHEMA  | DSCNL_NCS_LOCAL_MASTER,
        DSCNL_NCS_CONFIG  | DSCNL_NCS_LOCAL_MASTER,
        DSCNL_NCS_DOMAINS | DSCNL_NCS_LOCAL_MASTER,
        DSCNL_NCS_NDNCS   | DSCNL_NCS_LOCAL_MASTER
    };
    DWORD iNCType;
    NTSTATUS ntStatus = 0;
    DWORD cbNCList = 1024;
    DSNAME ** ppNCList = NULL;
    DSNAME ** ppNewNCList = NULL;
    DSNAME ** ppNC;
    DSNAME * pLastDSADN = NULL;
    LPWSTR pszLastDSADNSName = NULL;
    BOOL fCancelled = FALSE;

    Assert(NULL != pDemoteTargetDSADN);
    Assert(NULL != pszDemoteTargetDSADNSName);

    __try {
        // Pre-allocate a buffer big enough to handle most NC lists.
        ppNCList = (DSNAME **) NtdspAlloc(cbNCList);
        if (NULL == ppNCList) {
            err = ERROR_OUTOFMEMORY;
            NTDSP_SET_ERROR_MESSAGE0(
                err,
                DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS);
            __leave;
        }
    
        // For each class of NC...
        for (iNCType = 0; iNCType < ARRAY_COUNT(rgNCTypes); iNCType++) {
            // No need to demote domain NC if this is the last DC in the domain.
            if ((DSCNL_NCS_DOMAINS & rgNCTypes[iNCType])
                && (Flags & NTDS_LAST_DC_IN_DOMAIN)) {
                continue;
            }

            // Enumerate the NCs of this type.
            ntStatus = GetConfigurationNamesList(DSCONFIGNAMELIST_NCS,
                                                 rgNCTypes[iNCType],
                                                 &cbNCList,
                                                 ppNCList);
            if (STATUS_BUFFER_TOO_SMALL == ntStatus) {
                ppNewNCList = (DSNAME **) NtdspReAlloc(ppNCList, cbNCList);
    
                if (NULL != ppNewNCList) {
                    ppNCList = ppNewNCList;
                    ntStatus = GetConfigurationNamesList(DSCONFIGNAMELIST_NCS,
                                                         rgNCTypes[iNCType],
                                                         &cbNCList,
                                                         ppNCList);
                }
            }
    
            if (!NT_SUCCESS(ntStatus)) {
                err = RtlNtStatusToDosError(ntStatus);
                Assert(err);
                NTDSP_SET_ERROR_MESSAGE0(
                    err,
                    DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS);
                __leave;
            }

            // We now have a NULL-terminated list of 0 or more NCs of this NC
            // type.  Demote each of them in turn.
            for (ppNC = ppNCList; NULL != *ppNC; ppNC++) {
                DRS_DEMOTE_TARGET_SEARCH_INFO DTSInfo = {0};
                DWORD iAttempt = 0;
                DSNAME * pDSADN = NULL;
                LPWSTR pszDSADNSName = NULL;

                do {
                    // First determine which replica we should transfer changes/
                    // FSMO roles to.
                    pDSADN = NULL;
                    pszDSADNSName = NULL;

                    NTDSP_SET_STATUS_MESSAGE1(DIRMSG_DEMOTE_NC_GETTING_TARGET,
                                              (*ppNC)->StringName);
    
                    if (DSCNL_NCS_NDNCS & rgNCTypes[iNCType]) {
                        // The caller-specified target does not necessarily
                        // hold a replica of this non-domain NC.  Ask the DS to
                        // find a suitable candidate for us.
                        err = DirReplicaGetDemoteTarget(*ppNC,
                                                        &DTSInfo,
                                                        &pszDSADNSName,
                                                        &pDSADN);
                        if (0 != err) {
                            Assert(NULL == pDSADN);
                            Assert(NULL == pszDSADNSName);
                            
                            // Remember error code so we can report it below
                            // should we have found no demotion targets.
                            errLastTargetSearch = err;
                        }
                    } else {
                        // Use the caller-specified target (first pass only).
                        if (0 == iAttempt) {
                            pDSADN = pDemoteTargetDSADN;
                            pszDSADNSName = pszDemoteTargetDSADNSName;
                        } else {
                            Assert(NULL == pDSADN);
                            Assert(NULL == pszDSADNSName);
                        }
                    }
    
                    if (NULL != pDSADN) {
                        // We found a potential demotion target -- try it.
                        Assert(NULL != pszDSADNSName);
                        iAttempt++;

                        NTDSP_SET_STATUS_MESSAGE2(DIRMSG_DEMOTE_NC_BEGIN,
                                                  (*ppNC)->StringName,
                                                  pszDSADNSName);
        
                        err = DirReplicaDemote(*ppNC, pszDSADNSName, pDSADN, 0);
                        if (err) {
                            NTDSP_SET_STATUS_MESSAGE2(DIRMSG_DEMOTE_NC_FAILED,
                                                      (*ppNC)->StringName,
                                                      pszDSADNSName);
                            
                            // Remember DSA and error so we can report them
                            // below should we find no further candidates.
                            errLastDemote = err;
                            if ((NULL != pLastDSADN)
                                && (pLastDSADN != pDemoteTargetDSADN)) {
                                THFree(pLastDSADN);
                            }
                            pLastDSADN = pDSADN;
                            
                            if ((NULL != pszLastDSADNSName)
                                && (pszLastDSADNSName
                                    != pszDemoteTargetDSADNSName)) {
                                THFree(pszLastDSADNSName);
                            }
                            pszLastDSADNSName = pszDSADNSName;
                            
                            // continue on to try demotion against next DSA
                            // candidate (if any)
                        } else {
                            // Success!
                            NTDSP_SET_STATUS_MESSAGE2(DIRMSG_DEMOTE_NC_SUCCESS,
                                                      (*ppNC)->StringName,
                                                      pszDSADNSName);
                        }
                    }
                } while ((NULL != pDSADN)           // Still finding targets
                         && (0 != err)              // AND haven't succeeded yet
                         && !(fCancelled            // AND user hasn't cancelled
                              = TEST_CANCELLATION()));

                if (0 == iAttempt) {
                    // Couldn't find any targets.
                    err = errLastTargetSearch;
                    Assert(err);
                    NTDSP_SET_ERROR_MESSAGE1(err,
                                             DIRMSG_DEMOTE_NC_NO_TARGETS,
                                             (*ppNC)->StringName);
                    __leave;
                } else if (NULL == pDSADN) {
                    // Failed all targets -- report the last failure as an
                    // error.
                    err = errLastDemote;
                    Assert(err);
                    NTDSP_SET_ERROR_MESSAGE2(err,
                                             DIRMSG_DEMOTE_NC_FAILED,
                                             (*ppNC)->StringName,
                                             pszLastDSADNSName);
                    __leave;
                } else if (fCancelled) {
                    err = ERROR_CANCELLED;
                    NTDSP_SET_ERROR_MESSAGE0(
                        err, 
                        DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS);
                }

                // Demotion of this NC was successful.  Move on to next NC.
                Assert(0 == err);
            }
        }
    } __finally {
        if ((NULL != pLastDSADN)
            && (pLastDSADN != pDemoteTargetDSADN)) {
            THFree(pLastDSADN);
        }
        
        if ((NULL != pszLastDSADNSName)
            && (pszLastDSADNSName
                != pszDemoteTargetDSADNSName)) {
            THFree(pszLastDSADNSName);
        }
    }

    return err;
}

DWORD
NtdspGetDomainFSMOServer(
    IN LPWSTR ServerName,
    IN HANDLE ClientToken,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    OUT LPWSTR *DomainFSMOServer
    )
/*++

Routine Description:

    This routines find the current domain naming FSMO

Parameters:

            
    None.

Return Values:

    a value from the win32 error space

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG LdapError = 0;

    NTDS_CONFIG_INFO ConfigInfo;
    LDAP *hLdap = NULL;

    // Parameter check
    Assert( ServerName );
    Assert( DomainFSMOServer );

    // Stack clearing
    RtlZeroMemory( &ConfigInfo, sizeof( ConfigInfo ) );

    //
    // Open an ldap connection to source server
    //
    hLdap = ldap_openW(ServerName, LDAP_PORT);

    if (!hLdap) {

        WinError = GetLastError();

        if (WinError == ERROR_SUCCESS) {
            //
            // This works around a bug in the ldap client
            //
            WinError = ERROR_CONNECTION_INVALID;
        }

        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_CANNOT_CONTACT_DOMAIN_FSMO,
                                  ServerName );

        goto Cleanup;
    }

    //
    // Bind
    //
    LdapError = impersonate_ldap_bind_sW(ClientToken,
                                         hLdap,
                                         NULL,  // use credentials instead
                                         (VOID*)Credentials,
                                         LDAP_AUTH_SSPI);

    WinError = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS != WinError) {
        if (ERROR_GEN_FAILURE == WinError ||
            ERROR_WRONG_PASSWORD == WinError )  {
            WinError = ERROR_NOT_AUTHENTICATED;
        }

        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_CANNOT_CONTACT_DOMAIN_FSMO,
                                  ServerName );

        goto Cleanup;
    }

    WinError = NtdspQueryConfigInfo( hLdap,
                                     &ConfigInfo );


    if (ERROR_SUCCESS != WinError) {

        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG,
                                  ServerName );
        goto Cleanup;

    }

    //
    // Now read the fsmo property from the partitions container
    //
    {
        BOOL FSMOMissing = FALSE;
        WinError = NtdspGetDomainFSMOInfo( hLdap,
                                          &ConfigInfo,
                                          &FSMOMissing );
    
        if (ERROR_SUCCESS != WinError) {
            if (!FSMOMissing) {
                NTDSP_SET_ERROR_MESSAGE1( WinError,
                                          DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG,
                                          ServerName );
            }
            goto Cleanup;
    
        }
    }

    // Transfer the goods
    *DomainFSMOServer = ConfigInfo.DomainNamingFsmoDnsName;
    ConfigInfo.DomainNamingFsmoDnsName = NULL;

    //
    // That's it - fall through to cleanup
    //

Cleanup:

    if ( hLdap )
    {
        ldap_unbind_s(hLdap);
    }

    NtdspReleaseConfigInfo( &ConfigInfo );

    return WinError;
}


DWORD
NtdspCheckServerInDomainStatus(
    OUT BOOLEAN *fLastDcInDomain
    )
/*++

Routine Description:

    This routine determines the if the local server is the last DC in the
    domain.

Arguments:

    fLastDcInDomain 

Return Values:

    Resource errors only

--*/
{

    DWORD    WinError = ERROR_SUCCESS, DirError;
    NTSTATUS NtStatus;

    SEARCHARG  SearchArg;
    SEARCHRES  *SearchRes = NULL;

    DWORD      dwNtdsDsaClass = CLASS_NTDS_DSA;

    DSNAME     *Domain;
    DSNAME     *Server;
    DSNAME     *ConfigContainer;
    DWORD      Size;
    FILTER     ObjClassFilter, HasNcFilter, AndFilter;

    //
    // Init the out parameter
    //
    *fLastDcInDomain = FALSE;

    //
    //  Get the base dsname to search from
    //
    Size = 0;
    ConfigContainer = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                     &Size,
                                     ConfigContainer );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        ConfigContainer = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                         &Size,
                                         ConfigContainer );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Get the current domain
    //
    Size = 0;
    Domain = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     Domain );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        Domain = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         Domain );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Get the current server
    //
    Size = 0;
    Server = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                     &Size,
                                     Server );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        Server = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                         &Size,
                                         Server );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &AndFilter, sizeof( AndFilter ) );
    RtlZeroMemory( &ObjClassFilter, sizeof( HasNcFilter ) );
    RtlZeroMemory( &HasNcFilter, sizeof( HasNcFilter ) );

    HasNcFilter.choice = FILTER_CHOICE_ITEM;
    HasNcFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    HasNcFilter.FilterTypes.Item.FilTypes.ava.type = ATT_HAS_MASTER_NCS;
    HasNcFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = Domain->structLen;
    HasNcFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) Domain;

    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwNtdsDsaClass );
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &dwNtdsDsaClass;

    AndFilter.choice                    = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count     = 2;

    AndFilter.FilterTypes.And.pFirstFilter = &ObjClassFilter;
    ObjClassFilter.pNextFilter = &HasNcFilter;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = ConfigContainer;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );
    
    if (  0 == DirError )
    {
        if (  SearchRes->count == 1 
           && NameMatched( Server, SearchRes->FirstEntInf.Entinf.pName ) )
        {
            *fLastDcInDomain = TRUE;
        }
        WinError = ERROR_SUCCESS;
    }
    else
    {
        //
        // This is an unexpected condition
        //
        WinError = ERROR_DS_UNAVAILABLE; 
    }

    //
    // That's it; fall through to cleanup
    //

Cleanup:

    return WinError;

}


VOID
NtdsFreeDnsRRInfo(
    IN PNTDS_DNS_RR_INFO pInfo
    )
{
    if ( pInfo ) {

        if ( pInfo->DnsDomainName ) {
            NtdspFree( pInfo->DnsDomainName );
        }

        if ( pInfo->DnsHostName ) {
            NtdspFree( pInfo->DnsHostName );
        }

        NtdspFree( pInfo );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\install.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    install.h

Abstract:

    Contains function headers the NtdsInstall support routines

Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/


//
// Exported functions
//
DWORD
NtdspInstall(
    IN  PNTDS_INSTALL_INFO pInstallInfo,
    OUT LPWSTR            *InstalledSiteName, OPTIONAL
    OUT GUID              *NewDnsDomainGuid,  OPTIONAL
    OUT PSID              *NewDnsDomainSid    OPTIONAL
    );

DWORD
NtdspSetInstallUndoInfo(
    IN PNTDS_INSTALL_INFO InstallInfo,
    IN PNTDS_CONFIG_INFO  ConfigInfo
    );

VOID
NtdspReleaseInstallUndoInfo(
    VOID
    );

DWORD
NtdspInstallUndo(
    VOID
    );

DWORD
NtdspSanityCheckLocalData(
    ULONG  Flags
    );

#define NTDSP_UNDO_DELETE_SERVER  (ULONG)(1<<0)
#define NTDSP_UNDO_DELETE_NTDSA   (ULONG)(1<<1)
#define NTDSP_UNDO_STOP_DSA       (ULONG)(1<<2) 
#define NTDSP_UNDO_UNDO_SAM       (ULONG)(1<<3)
#define NTDSP_UNDO_UNDO_CONFIG    (ULONG)(1<<4)
#define NTDSP_UNDO_DELETE_DOMAIN  (ULONG)(1<<5)
#define NTDSP_UNDO_DELETE_FILES   (ULONG)(1<<6)
#define NTDSP_UNDO_MORPH_ACCOUNT  (ULONG)(1<<7)

DWORD
NtdspInstallUndoWorker(
    IN LPWSTR                   RemoteServer,
    IN SEC_WINNT_AUTH_IDENTITY* Credentials,
    IN HANDLE                   ClientToken,
    IN LPWSTR                   ServerDn,
    IN LPWSTR                   DomainDn,  OPTIONAL
    IN LPWSTR                   AccountDn,  OPTIONAL
    IN LPWSTR                   LogDir,
    IN LPWSTR                   DatabaseDir,
    IN ULONG                    Flags
    );


DWORD
NtdspCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\demote.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    demote.h

Abstract:

    Contains file headers for demote routines          

Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/


DWORD
NtdspDemote(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials, OPTIONAL
    IN HANDLE                   ClientToken,
    IN LPWSTR                   AdminPassword, OPTIONAL
    IN DWORD                    Flags,
    IN LPWSTR                   ServerName
    );


DWORD
NtdspPrepareForDemotion(
    IN ULONG Flags,
    IN LPWSTR ServerName, OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN HANDLE                   ClientToken,
    OUT PNTDS_DNS_RR_INFO *pDnsRRInfo
    );

DWORD
NtdspPrepareForDemotionUndo(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\makefile.inc ===
# Dummy file to make build.exe happy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\install.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    install.c

Abstract:

    Contains function definitions for helper routines to install the ds

Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <stdio.h>
#include <winreg.h>
#include <ntlsa.h>
#include <winsock.h>  // for dnsapi.h
#include <dnsapi.h>
#include <lmcons.h>
#include <crypt.h>
#include <samrpc.h>
#include <samisrv.h>
#include <certca.h>


#include <dsconfig.h>
#include <dsgetdc.h>
#include <lmapibuf.h>

#include <drs.h>
#include <ntdsa.h>
#include <ntdsapi.h>
#include <attids.h>
#include <dsaapi.h>
#include <dsconfig.h>
#include <winldap.h>
#include <lsarpc.h>      // for lsaisrv.h
#include <lsaisrv.h>     // for LsaISafeMode
#include <rpcdce.h>
#include <lmaccess.h>
#include <mdcodes.h>
#include <debug.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <filtypes.h>
#include <dsevent.h>
#include <fileno.h>

#include "ntdsetup.h"
#include "setuputl.h"
#include "config.h"
#include "machacc.h"
#include "install.h"
#include "status.h"



#define DEBSUB "INSTALL:"
#define FILENO FILENO_NTDSETUP_NTDSETUP


//
// Type definitions
//
typedef struct
{
    // Is this structure valid?
    BOOL   fValid;

    // What kind of install was this
    ULONG  Flags;

    // The server on which operations were made
    LPWSTR RemoteServer;

    // The DN of the server to be created
    LPWSTR ServerDn;

    // The DN of the domain to be created
    LPWSTR DomainDn;

    // The DN of the machine account prior to Domain Controllers OU
    LPWSTR AccountDn;

    // The credentials used to perform the operations
    SEC_WINNT_AUTH_IDENTITY Credentials;

    // The log directory
    LPWSTR LogDir;

    // The database directory
    LPWSTR DatabaseDir;


    // Flags indicating what to do
    ULONG UndoFlags;

    // Token of the Client
    HANDLE ClientToken;

} NTDS_INSTALL_UNDO_INFO, *PNTDS_INSTALL_UNDO_INFO;

//
// Global data (to this module)
//

//
// This variable is used to keep global state between NtdsInstall and NtdsInstallUndo
// If NtdsInstall succeeds, it calls NtdspSetInstallUndoInfo() to save state
// necessary to roll back any changes.  Later if we have to rollback
// NtdsInstallUnfo will be called and it will use this information
//
NTDS_INSTALL_UNDO_INFO  gNtdsInstallUndoInfo;


//
// Forward decl's
//
DWORD
NtdspCheckDomainObject(
    OUT DSNAME **DomainDn
    );

DWORD
NtdspCheckCrossRef(
    IN DSNAME* DomainDn
    );

DWORD 
NtdspCheckNtdsDsaObject(
    IN DSNAME* DomainDn
    );

DWORD 
NtdspCheckMachineAccount(
    IN DSNAME* DomainDn
    );

DWORD
NtdspCheckWellKnownSids(
    IN DSNAME* DomainDn,
    IN ULONG   Flags
    );

DWORD
NtdspInstallUndo(
    VOID
    )
/*++

Routine Description:

    This routine undoe the effect NtdsInstall after NtdsInstall has 
    completed successfully. It grabs the info that was stored globally
    (if valid) and then calls the worker function.

Arguments:

    None.
    
Returns:

    ERROR_SUCCESS
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD WinError2 = ERROR_SUCCESS;

    LPWSTR ServerName;
    LPWSTR ServerDn;
    SEC_WINNT_AUTH_IDENTITY *Credentials = NULL;

    Assert( gNtdsInstallUndoInfo.fValid );

    if ( !gNtdsInstallUndoInfo.fValid )
    {
        // We don't have valid data; fail the call
        return ERROR_INVALID_PARAMETER;
    }

    if ( gNtdsInstallUndoInfo.Credentials.User )
    {
        // There are some credentials
        Credentials = &gNtdsInstallUndoInfo.Credentials;
    }

    WinError = NtdspInstallUndoWorker( gNtdsInstallUndoInfo.RemoteServer,
                                       Credentials,
                                       gNtdsInstallUndoInfo.ClientToken,
                                       gNtdsInstallUndoInfo.ServerDn,
                                       gNtdsInstallUndoInfo.DomainDn,
                                       gNtdsInstallUndoInfo.AccountDn,
                                       gNtdsInstallUndoInfo.LogDir,
                                       gNtdsInstallUndoInfo.DatabaseDir,
                                       gNtdsInstallUndoInfo.UndoFlags );

    if ( ERROR_SUCCESS != WinError )
    {
        DPRINT1( 0, "NtdspInstallUndoWorker failed %d\n", WinError );
    }

    return WinError;
}

DWORD
NtdspInstallUndoWorker(
    IN LPWSTR                  RemoteServer,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE                  ClientToken,
    IN LPWSTR                  ServerDn,
    IN LPWSTR                  DomainDn,
    IN LPWSTR                  AccountDn,
    IN LPWSTR                  LogDir,
    IN LPWSTR                  DatabaseDir,
    IN ULONG                   Flags
    )

/*++

Routine Description:

    Undoes all changes as indicated by the flags                                        
    
Arguments:

    RemoteServer: the server the on which to perform the operations
    
    Credentials:  the credentials to use
    
    ServerDn:     the server dn of the local machine
    
    DomainDn:     the dn of the domain that was created
    
    AccountDn:    the dn of the machine account object before it was moved
    
    Flags:        flags indicating what operation to undo
    
Returns:

    ERROR_SUCCESS
    
--*/
{

    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG LdapError = LDAP_SUCCESS;
    HANDLE   hDs = 0;

    //
    // Do the local stuff first
    //
    if ( FLAG_ON( Flags, NTDSP_UNDO_STOP_DSA ) )
    {
        NtStatus = DsUninitialize( FALSE ); // do the whole shutdown
        ASSERT( NT_SUCCESS(NtStatus) );
    }

    if ( FLAG_ON( Flags, NTDSP_UNDO_UNDO_SAM ) )
    {
        // Revert SAM
        NtStatus = SamIPromoteUndo();
        ASSERT( NT_SUCCESS(NtStatus) );
    }

    if ( FLAG_ON( Flags, NTDSP_UNDO_UNDO_CONFIG ) )
    {
        // Remove the registry settings
        NtStatus = NtdspConfigRegistryUndo();
        ASSERT( NT_SUCCESS(NtStatus) );
    }


    if ( FLAG_ON( Flags, NTDSP_UNDO_DELETE_FILES ) )
    {
        if ( LogDir )
        {
            WinError = NtdspClearDirectory( LogDir );
            if ( ERROR_SUCCESS != WinError )
            {
                DPRINT1( 0, "Failed to clear directory %ls\n", LogDir );
            }
        }
        if ( DatabaseDir )
        {
            WinError = NtdspClearDirectory( DatabaseDir );
            if ( ERROR_SUCCESS != WinError )
            {
                DPRINT1( 0, "Failed to clear directory %ls\n", DatabaseDir );
            }
        }

        // not fatal
        WinError = ERROR_SUCCESS;
    }

    //
    // Now do the external
    //

    // 
    // Remove the ntdsa object
    //
    if ( FLAG_ON( Flags, NTDSP_UNDO_DELETE_NTDSA ) )
    {
        // These should have been passed in
        Assert( RemoteServer );
        Assert( ServerDn );

        WinError = NtdspRemoveServer( &hDs,
                                      Credentials,
                                      ClientToken,
                                      RemoteServer,
                                      ServerDn,
                                      FALSE  // the ServerDn is NOT the ntdsa dn
                                       );

        if (  (ERROR_SUCCESS != WinError)
           && (ERROR_DS_CANT_FIND_DSA_OBJ != WinError) )
        {
            //
            // Let the user know this will have to cleaned up
            // manually
            //
            LogEvent8WithData( DS_EVENT_CAT_SETUP,
                               DS_EVENT_SEV_ALWAYS,
                               DIRLOG_FAILED_TO_REMOVE_NTDSA,
                               szInsertWC(ServerDn), szInsertWC(RemoteServer), NULL, NULL, NULL, NULL, NULL, NULL,
                               sizeof(DWORD), &WinError );

            //
            // Indicate to the UI that something has gone wrong
            //
            NTDSP_SET_NON_FATAL_ERROR_OCCURRED();

            // Handled
            WinError = ERROR_SUCCESS;
        }
    }

    //
    // Remove the domain
    //
    if ( FLAG_ON( Flags, NTDSP_UNDO_DELETE_DOMAIN ) )
    {
        // These should have been passed in
        Assert( RemoteServer );
        Assert( DomainDn );

        WinError = NtdspRemoveDomain( &hDs,
                                      Credentials,
                                      ClientToken,
                                      RemoteServer,
                                      DomainDn );

        if (  (ERROR_SUCCESS != WinError)
           && (ERROR_DS_NO_CROSSREF_FOR_NC != WinError) )
        {
            //
            // Let the user know this will have to cleaned up
            // manually
            //

            LogEvent8WithData( DS_EVENT_CAT_SETUP,
                               DS_EVENT_SEV_ALWAYS,
                               DIRLOG_FAILED_TO_REMOVE_EXTN_OBJECT,
                               szInsertWC(DomainDn), szInsertWC(RemoteServer), NULL, NULL, NULL, NULL, NULL, NULL,
                               sizeof(DWORD), &WinError );

            //
            // Indicate to the UI that something has gone wrong
            //
            NTDSP_SET_NON_FATAL_ERROR_OCCURRED();

            // Handled
            WinError = ERROR_SUCCESS;
        }
    }

    //
    // Remove the server
    //
    if ( FLAG_ON( Flags, NTDSP_UNDO_DELETE_SERVER ) )
    {

        LDAP *hLdap = 0;

        // These should have been passed in
        Assert( RemoteServer );
        Assert( ServerDn );

        hLdap = ldap_openW( RemoteServer, LDAP_PORT );
        if ( hLdap )
        {
            LdapError = impersonate_ldap_bind_sW(ClientToken,
                                                 hLdap,
                                                 NULL,  // use credentials instead
                                                 (PWCHAR) Credentials,
                                                 LDAP_AUTH_SSPI);

            WinError = LdapMapErrorToWin32(LdapError);

            if ( ERROR_SUCCESS == WinError )
            {
                WinError = NtdspLdapDelnode( hLdap,
                                             ServerDn );
            }
            ldap_unbind( hLdap );
        }
        else
        {
            WinError = GetLastError();
        }

        if (  (ERROR_SUCCESS != WinError)
           && (ERROR_FILE_NOT_FOUND != WinError) )
        {
            //
            // Let the user know this will have to be cleaned up manually
            //
            LogEvent8WithData( DS_EVENT_CAT_SETUP,
                               DS_EVENT_SEV_ALWAYS,
                               DIRLOG_FAILED_TO_REMOVE_EXTN_OBJECT,
                               szInsertWC(ServerDn), szInsertWC(RemoteServer), NULL, NULL, NULL, NULL, NULL, NULL,
                               sizeof(DWORD), &WinError );

            //
            // Indicate to the UI that something has gone wrong
            //
            NTDSP_SET_NON_FATAL_ERROR_OCCURRED();

            // Handled
            WinError = ERROR_SUCCESS;
        }
    }


    //
    // Unmorph the server account, if necessary
    //
    if ( FLAG_ON( Flags, NTDSP_UNDO_MORPH_ACCOUNT ) )
    {
        LPWSTR OriginalLocation = AccountDn;
        WCHAR AccountName[MAX_COMPUTERNAME_LENGTH+2];
        ULONG Length = sizeof(AccountName)/sizeof(AccountName[0]);

        if (GetComputerName(AccountName, &Length)) {

            wcscat(AccountName, L"$");

            WinError = NtdsSetReplicaMachineAccount(Credentials,
                                                    ClientToken,
                                                    RemoteServer,
                                                    AccountName,
                                                    UF_WORKSTATION_TRUST_ACCOUNT,
                                                    &OriginalLocation);
        } else {

            WinError = GetLastError();
        }

        if (ERROR_SUCCESS != WinError) {

            //
            // Let the user know this will have to be cleaned up manually
            //
            LogEvent8WithData(DS_EVENT_CAT_SETUP,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_SETUP_MACHINE_ACCOUNT_NOT_REVERTED,
                              szInsertWC(AccountName),
                              szInsertWin32Msg(WinError),
                              szInsertWC(AccountDn),
                              NULL, NULL, NULL, NULL, NULL,
                              sizeof(DWORD), 
                              &WinError);

            //
            // Indicate to the UI that something has gone wrong
            //
            NTDSP_SET_NON_FATAL_ERROR_OCCURRED();

            // Handled
            WinError = ERROR_SUCCESS;

        }

    }

    if ( hDs )
    {
        DsUnBind( &hDs );
    }

    return WinError;

}

DWORD
NtdspSetInstallUndoInfo(
    IN PNTDS_INSTALL_INFO InstallInfo,
    IN PNTDS_CONFIG_INFO  ConfigInfo
    )
/*++

Routine Description:

    This routine saves off infomation provided to (InstallInfo) and collected
    (ConfigInfo) during NtdsInstall so that NtdsInstallUndo knows what to
    undo

Arguments:

    InstallInfo : user supplied info
    ConfigInfo  : data collected during ntdsinstall
    
Returns:

    ERROR_SUCCESS
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD Length;

    Assert( InstallInfo );
    Assert( ConfigInfo );

    // Clear it
    RtlZeroMemory( &gNtdsInstallUndoInfo, sizeof( gNtdsInstallUndoInfo.fValid ) );

    gNtdsInstallUndoInfo.Flags = InstallInfo->Flags;

    // The server on which operations were made
    if ( ConfigInfo->DomainNamingFsmoDnsName )
    {
        gNtdsInstallUndoInfo.RemoteServer = _wcsdup( ConfigInfo->DomainNamingFsmoDnsName );
    } 
    else if ( InstallInfo->ReplServerName )
    {
        gNtdsInstallUndoInfo.RemoteServer = _wcsdup( InstallInfo->ReplServerName );
    }

    // The server on which operations were made
    if ( ConfigInfo->LocalServerDn )
    {
        gNtdsInstallUndoInfo.ServerDn = _wcsdup( ConfigInfo->LocalServerDn );
    }

    if ( ConfigInfo->DomainDN )
    {
        gNtdsInstallUndoInfo.DomainDn = _wcsdup( ConfigInfo->DomainDN );
    }

    if ( ConfigInfo->LocalMachineAccount )
    {
        gNtdsInstallUndoInfo.AccountDn = _wcsdup( ConfigInfo->LocalMachineAccount );
    }

    // Copy the credentials
    RtlZeroMemory( &gNtdsInstallUndoInfo.Credentials, sizeof( gNtdsInstallUndoInfo.Credentials ) );
    if ( InstallInfo->Credentials )
    {
        if ( InstallInfo->Credentials->User )
        {
            gNtdsInstallUndoInfo.Credentials.User = _wcsdup( InstallInfo->Credentials->User );
            gNtdsInstallUndoInfo.Credentials.UserLength = InstallInfo->Credentials->UserLength;
        }
        if ( InstallInfo->Credentials->Domain )
        {
            gNtdsInstallUndoInfo.Credentials.Domain = _wcsdup( InstallInfo->Credentials->Domain );
            gNtdsInstallUndoInfo.Credentials.DomainLength = InstallInfo->Credentials->DomainLength;
        }
        
        if ( InstallInfo->Credentials->Password )
        {
            gNtdsInstallUndoInfo.Credentials.Password = _wcsdup( InstallInfo->Credentials->Password );
            gNtdsInstallUndoInfo.Credentials.PasswordLength = InstallInfo->Credentials->PasswordLength;
        }

        gNtdsInstallUndoInfo.Credentials.Flags = InstallInfo->Credentials->Flags;

    }

    // Set the flags about what has to be undone
    gNtdsInstallUndoInfo.UndoFlags = ConfigInfo->UndoFlags;

    //
    // Note: when being called to undo the effects of NtdsInstall
    // the ds will have already been shutdown, so don't try to do it again.
    //
    gNtdsInstallUndoInfo.UndoFlags &= ~NTDSP_UNDO_STOP_DSA;

    if (InstallInfo->ClientToken) {
        BOOL fRet;

        fRet = DuplicateToken(InstallInfo->ClientToken,
                              SecurityImpersonation,
                              &gNtdsInstallUndoInfo.ClientToken);
        if (!fRet) {
            WinError = GetLastError();
            goto Exit;
        }

    }


    // The info is good!
    gNtdsInstallUndoInfo.fValid = TRUE;

Exit:

    return WinError;
}

VOID
NtdspReleaseInstallUndoInfo(
    VOID
    )
/*++

Routine Description:

    This routine frees all resources in gNtdsInstallUndoInfo 

Arguments:

    None.
    
Returns:

    None.
    
--*/
{

    if ( gNtdsInstallUndoInfo.fValid )
    {
        //
        // These were all wcsdup'ed. We need to cleanup the memory model here
        //
        if ( gNtdsInstallUndoInfo.RemoteServer )
        {
            free( gNtdsInstallUndoInfo.RemoteServer );
        }
        if ( gNtdsInstallUndoInfo.ServerDn )
        {
            free( gNtdsInstallUndoInfo.ServerDn );
        }
        if ( gNtdsInstallUndoInfo.DomainDn )
        {
            free( gNtdsInstallUndoInfo.DomainDn );
        }
        if ( gNtdsInstallUndoInfo.AccountDn )
        {
            free( gNtdsInstallUndoInfo.AccountDn );
        }
        if ( gNtdsInstallUndoInfo.Credentials.User )
        {
            free( gNtdsInstallUndoInfo.Credentials.User );
        }
        if ( gNtdsInstallUndoInfo.Credentials.Password )
        {
            free( gNtdsInstallUndoInfo.Credentials.Password );
        }
        if ( gNtdsInstallUndoInfo.Credentials.Domain )
        {
            free( gNtdsInstallUndoInfo.Credentials.Domain );
        }
        if ( gNtdsInstallUndoInfo.ClientToken )
        {
            CloseHandle( gNtdsInstallUndoInfo.ClientToken );
        }
    }

    RtlZeroMemory( &gNtdsInstallUndoInfo, sizeof(gNtdsInstallUndoInfo) );

    return;
}
DWORD
NtdspSanityCheckLocalData(
    ULONG  Flags
    )
/*++

Routine Description:

    This routine queries the database to find critical objects that
    are necessary to boot after dcpromo.
    
    //
    // 1) Domain Object exists
    // 2) Cross Ref exists and is an ntds domain
    // 3) Ntdsa object exists and has the proper has master nc's
    // 4) Well known sid check
    // 5) if replica install, checks the machine account object
    //
    
Arguments:

    Flags: the user install flags (replica, enterprise, etc)
    
Returns:

    ERROR_SUCCESS appropriate win32 error
    
--*/
{
    DWORD         WinError = ERROR_SUCCESS;

    //
    // Create a thread state
    //
    if ( THCreate( CALLERTYPE_INTERNAL ) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    SampSetDsa( TRUE );

    try {

        DSNAME *DomainDn = NULL ;
        WinError = NtdspCheckDomainObject( &DomainDn );
        if ( ERROR_SUCCESS != WinError )
        {
            _leave;
        }

        WinError = NtdspCheckCrossRef( DomainDn );
        if ( ERROR_SUCCESS != WinError )
        {
            _leave;
        }

        WinError = NtdspCheckNtdsDsaObject( DomainDn );
        if ( ERROR_SUCCESS != WinError )
        {
            _leave;
        }

        WinError = NtdspCheckWellKnownSids( DomainDn,
                                            Flags );
        if ( ERROR_SUCCESS != WinError )
        {
            _leave;
        }

        if ( FLAG_ON( Flags, NTDS_INSTALL_REPLICA ) )
        {
            WinError = NtdspCheckMachineAccount( DomainDn );
            if ( ERROR_SUCCESS != WinError )
            {
                _leave;
            }
        }


    }
    finally
    {
        THDestroy();
    }

    // Set the user error message
    if ( ERROR_SUCCESS != WinError )
    {
        NTDSP_SET_ERROR_MESSAGE0( WinError,
                                  DIRMSG_INSTALL_MISSING_INFO );
    }

    return WinError;
}


DWORD
NtdspCheckDomainObject(
    OUT DSNAME **DomainDn
    )
/*++

Routine Description:

    This routine queries the DS for the domain object

Arguments:

    DomainDn - the dn of the domain object it finds
    
Returns:

    ERROR_SUCCESS or ERROR_NO_SUCH_DOMAIN
    
--*/
{
    DWORD     WinError = ERROR_SUCCESS;
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    ULONG     DirError = 0;
    SEARCHARG SearchArg;
    SEARCHRES *SearchRes = NULL;
    ULONG     Size;

    Assert( DomainDn );
    *DomainDn = NULL;

    Size = 0;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     (*DomainDn) );

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        (*DomainDn) = (DSNAME*) THAlloc( Size );

        if ( (*DomainDn) )
        {
            NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                             &Size,
                                             (*DomainDn) );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Search for the object
    //
    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = (*DomainDn);
    SearchArg.choice  = SE_CHOICE_BASE_ONLY;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = NULL;  // no filter
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;
    SearchArg.pSelectionRange = NULL; // no requested attributes
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( SearchRes )
    {
        WinError = DirErrorToWinError( DirError, &SearchRes->CommRes );
    
        if ( ERROR_SUCCESS == WinError )
        {
            if ( SearchRes->count < 1 )
            {
                WinError = ERROR_NO_SUCH_DOMAIN;
                goto Cleanup;
            }
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (   (0 == (*DomainDn)->NameLen)
        || !RtlValidSid( &(*DomainDn)->Sid ) )
    {
        WinError = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

Cleanup:

    return WinError;
}

DWORD
NtdspCheckCrossRef(
    IN DSNAME* DomainDn
    )
/*++

Routine Description:

    This routine queries the DS for the domain's cross ref object

    
Arguments:

    DomainDn - the dn of the domain                                                                 
    
Returns:

    ERROR_SUCCESS or ERROR_DS_NO_CROSSREF_FOR_NC
    
--*/
{
    DWORD    WinError = ERROR_SUCCESS;     
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    DirError = 0;

    SEARCHARG     SearchArg;
    SEARCHRES     *SearchRes = NULL;
    ENTINFSEL     EntryInfoSelection;
    ATTR          Attr[1];
    ATTRBLOCK    *pAttrBlock;
    ATTR         *pAttr;
    ATTRVALBLOCK *pAttrVal;
    FILTER        Filter;
    ULONG         Size;
    DSNAME*       PartitionsContainer = NULL;
    BOOL          fCrossRefFound = FALSE;

    ULONG sysflags = 0;


    Assert( DomainDn );

    //
    // Search for the cross ref
    //
    Size = 0;
    NtStatus = GetConfigurationName( DSCONFIGNAME_PARTITIONS,
                                     &Size,
                                     PartitionsContainer );

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        PartitionsContainer = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_PARTITIONS,
                                         &Size,
                                         PartitionsContainer );
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &Filter, sizeof( Filter ) );

    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_NC_NAME;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = DomainDn->structLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) DomainDn;
    Filter.pNextFilter = NULL;

    //
    // Setup the attr's to return
    //
    RtlZeroMemory( &EntryInfoSelection, sizeof(EntryInfoSelection) );
    EntryInfoSelection.attSel = EN_ATTSET_LIST;
    EntryInfoSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntryInfoSelection.AttrTypBlock.attrCount = 1;
    EntryInfoSelection.AttrTypBlock.pAttr = &(Attr[0]);

    RtlZeroMemory(Attr, sizeof(Attr));
    Attr[0].attrTyp = ATT_SYSTEM_FLAGS;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = PartitionsContainer;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &EntryInfoSelection;
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( SearchRes )
    {
        WinError = DirErrorToWinError( DirError, &SearchRes->CommRes );
    
        if ( ERROR_SUCCESS == WinError )
        {
            if ( SearchRes->count == 1 )
            {
                fCrossRefFound = TRUE;
                if ( 1 == SearchRes->FirstEntInf.Entinf.AttrBlock.attrCount )
                {
                    if ( ATT_SYSTEM_FLAGS == SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[0].attrTyp)
                    {
                        sysflags = *((DWORD*)SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
                    }
                }
            }
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if (   !fCrossRefFound 
        || !(FLAG_CR_NTDS_DOMAIN & sysflags) 
        || !(FLAG_CR_NTDS_NC & sysflags) )
    {
        WinError = ERROR_DS_NO_CROSSREF_FOR_NC;
        goto Cleanup;
    }

Cleanup:

    return WinError;
}


DWORD 
NtdspCheckNtdsDsaObject(
    IN DSNAME* DomainDn
    )
/*++

Routine Description:

    This routine queries the DS for this machine's ntdsa object.
    
Arguments:

    DomainDn - the dn of the domain
    
Returns:

    ERROR_SUCCESS or ERROR_DS_CANT_FIND_DSA_OBJ
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DirError = 0;

    SEARCHARG     SearchArg;
    SEARCHRES     *SearchRes = NULL;
    ENTINFSEL     EntryInfoSelection;
    ATTR          Attr[1];
    ATTRBLOCK    *pAttrBlock;
    ATTR         *pAttr;
    ATTRVALBLOCK *pAttrVal;
    ULONG         Size;
    FILTER        Filter;
    BOOL          fDsaFound = FALSE;

    DSNAME* Dsa = NULL;

    Assert( DomainDn );

    Size = 0;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                     &Size,
                                     Dsa );

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        Dsa = (DSNAME*) alloca( Size );

        NtStatus = GetConfigurationName( DSCONFIGNAME_DSA,
                                         &Size,
                                         Dsa );
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &Filter, sizeof( Filter ) );

    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJ_DIST_NAME;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = Dsa->structLen;
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) Dsa;
    Filter.pNextFilter = NULL;

    //
    // Setup the attr's to return
    //
    RtlZeroMemory( &EntryInfoSelection, sizeof(EntryInfoSelection) );
    EntryInfoSelection.attSel = EN_ATTSET_LIST;
    EntryInfoSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntryInfoSelection.AttrTypBlock.attrCount = 1;
    EntryInfoSelection.AttrTypBlock.pAttr = &(Attr[0]);

    RtlZeroMemory(Attr, sizeof(Attr));
    Attr[0].attrTyp = ATT_HAS_MASTER_NCS;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = Dsa;
    SearchArg.choice  = SE_CHOICE_BASE_ONLY;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &EntryInfoSelection;
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( SearchRes )
    {
        WinError = DirErrorToWinError( DirError, &SearchRes->CommRes );
    
        if ( ERROR_SUCCESS == WinError )
        {
            if ( SearchRes->count == 1 )
            {
                fDsaFound = TRUE;
            }
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( !fDsaFound )
    {
        WinError = ERROR_DS_CANT_FIND_DSA_OBJ;
        goto Cleanup;
    }

Cleanup:

    return WinError;

}

DWORD
NtdspCheckWellKnownSids(
    IN DSNAME* DomainDn,
    IN ULONG   Flags
    )
/*++

Routine Description:

    This routine checks the accounts that are needed for the computer to
    reboot and for the admin to logon.

Arguments:

    DomainDn: the dn of the domain
    Flags: the user install flags (replica, enterprise, etc)
    
Returns:

    ERROR_SUCCESS or ERROR_DS_NOT_INSTALLED
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DirError = 0;

    SEARCHARG SearchArg;
    SEARCHRES *SearchRes = NULL;


    struct 
    {
        BOOL  fReplicaInstallOnly;
        BOOL  fBuiltin;
        ULONG Rid;

    } SidsToCheck[] = 
    {
        {TRUE, FALSE, DOMAIN_USER_RID_ADMIN},
        {TRUE,  FALSE, DOMAIN_USER_RID_KRBTGT},
        {TRUE,  FALSE, DOMAIN_GROUP_RID_ADMINS},
        {TRUE, TRUE,  DOMAIN_ALIAS_RID_ADMINS},
        {TRUE, TRUE,  DOMAIN_ALIAS_RID_USERS}
    };

    ULONG i;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    PSID  BuiltinDomainSid = NULL;
    PSID  DomainSid = NULL;

    Assert( DomainDn );

    //
    // Prepare the account domain sid
    //
    DomainSid = &DomainDn->Sid;

    //
    // Prepare the builtin domain sid
    //
    BuiltinDomainSid  = (PSID) alloca( RtlLengthRequiredSid( 1 ) );
    RtlInitializeSid( BuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( BuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;


    for ( i = 0; i < ARRAY_COUNT(SidsToCheck); i++ )
    {
        PSID AccountSid = NULL;
        PSID CurrentDomainSid = NULL;
        BOOLEAN fAccountFound = FALSE;
        PDSNAME DsName;
        ULONG   Size;

        if (   SidsToCheck[i].fReplicaInstallOnly
           && !FLAG_ON( Flags, NTDS_INSTALL_REPLICA ) )
        {
            // never mind
            continue;
        }

        //
        // Construct the sid
        //
        if ( SidsToCheck[i].fBuiltin )
        {
            CurrentDomainSid = BuiltinDomainSid;
        }
        else
        {
            CurrentDomainSid = DomainSid;
        }

        NtStatus = NtdspCreateFullSid( CurrentDomainSid,
                                       SidsToCheck[i].Rid,
                                       &AccountSid );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            WinError = RtlNtStatusToDosError( NtStatus );
            goto Cleanup;
        }

        //
        // Prepare the ds name
        //
        Size = DSNameSizeFromLen( 0 );
        DsName = (DSNAME*) alloca( Size );
        RtlZeroMemory( DsName, Size );
        DsName->structLen = Size;
        DsName->SidLen = RtlLengthSid( AccountSid );
        RtlCopyMemory( &DsName->Sid, AccountSid, RtlLengthSid(AccountSid) );


        //
        // Finally, do the search!
        //
        RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
        SearchArg.pObject = DsName;
        SearchArg.choice  = SE_CHOICE_BASE_ONLY;
        SearchArg.bOneNC  = TRUE;
        SearchArg.pFilter = NULL;  // no filter
        SearchArg.searchAliases = FALSE;
        SearchArg.pSelection = NULL;
        SearchArg.pSelectionRange = NULL; // no requested attributes
        InitCommarg( &SearchArg.CommArg );
    
        DirError = DirSearch( &SearchArg, &SearchRes );
    
        if ( SearchRes )
        {
            WinError = DirErrorToWinError( DirError, &SearchRes->CommRes );
        
            if ( ERROR_SUCCESS == WinError )
            {
                if ( SearchRes->count < 1 )
                {
                    WinError = ERROR_DS_NOT_INSTALLED;
                }
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( AccountSid )
        {
            NtdspFree( AccountSid );
        }

        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }
    }

Cleanup:

    return WinError;

}

DWORD 
NtdspCheckMachineAccount(
    IN DSNAME* DomainDn
    )
/*++

Routine Description:

    This routine tries to find the machine account of the local machine
    if it is a replica.

Arguments:

    DomainDn: the dn of the domain
    
Returns:

    ERROR_SUCCESS appropriate win32 error
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG DirError = 0;

    SEARCHARG SearchArg;
    SEARCHRES *SearchRes = NULL;
    ATTR      Attr;
    ENTINFSEL EntryInfoSelection;
    FILTER    Filter;

    ULONG     Size;

    WCHAR     AccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG     Length;
    BOOL      fMachineAccountFound = FALSE;

    Assert( DomainDn );

    Size = sizeof(AccountName);

    if (!GetComputerName( AccountName, &Size ))
    {
        WinError = GetLastError();
        goto Cleanup;
    }
    
    wcscat( AccountName, L"$" );
    Size = (wcslen( AccountName ) + 1) * sizeof(WCHAR);

    //
    // Setup the filter
    //
    RtlZeroMemory( &Filter, sizeof( Filter ) );

    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_SAM_ACCOUNT_NAME;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = wcslen(AccountName)*sizeof(WCHAR);
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) AccountName;
    Filter.pNextFilter = NULL;

    RtlZeroMemory( &EntryInfoSelection, sizeof(EntryInfoSelection) );
    EntryInfoSelection.attSel = EN_ATTSET_LIST;
    EntryInfoSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntryInfoSelection.AttrTypBlock.attrCount = 1;
    EntryInfoSelection.AttrTypBlock.pAttr = &Attr;
    RtlZeroMemory(&Attr, sizeof(Attr));
    Attr.attrTyp = ATT_OBJECT_GUID;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = DomainDn;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &EntryInfoSelection;
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( SearchRes )
    {
        WinError = DirErrorToWinError( DirError, &SearchRes->CommRes );
    
        if ( ERROR_SUCCESS == WinError )
        {
           if ( SearchRes->count == 1 )
            {
                fMachineAccountFound = TRUE;
            }
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    
    if ( !fMachineAccountFound )
    {
        WinError = ERROR_NO_TRUST_SAM_ACCOUNT;
    }

Cleanup:

    return WinError;
}



DWORD
NtdspCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

    The returned Sid may be freed with NtdspFreeSid.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/
{

    DWORD       WinError = ERROR_SUCCESS;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    //
    // Calculate the size of the new sid
    //
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //
    *AccountSid = NtdspAlloc(AccountSidLength);

    if (*AccountSid) {

        //
        // Copy the domain sid into the first part of the account sid
        //
        RtlCopySid(AccountSidLength, *AccountSid, DomainSid);

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

    } else {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\machacc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    machacc.h

Abstract:

    Contains function headers for utilities relating to machine
    account setting used in ntdsetup.dll

Author:

    ColinBr  03-Sept-1997

Environment:

    User Mode - Win32

Revision History:

    
--*/
DWORD
NtdspSetMachineAccount(
    IN WCHAR*                   AccountName,
    IN SEC_WINNT_AUTH_IDENTITY* Credentials, 
    IN HANDLE                   ClientToken,
    IN WCHAR*                   DomainDn, OPTIONAL
    IN WCHAR*                   DcAddress,
    IN ULONG                    ServerType,
    IN OUT WCHAR**              AccountDn
    );

DWORD
NtdspGetUserDn(
    IN LDAP*    LdapHandle,
    IN WCHAR*   DomainDn,
    IN WCHAR*   AccountName,
    OUT WCHAR** AccountNameDn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\instntds.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    instntds.c

Abstract:

    This is simple exe executes calls from ntdsetup.dll. Not meant
    used other than test.

Author:

    ColinBr  29-Sept-1996

Environment:

    User Mode - Win32

Revision History:




--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <stdio.h>
#include <stdlib.h>
#include <winsock.h>  // for dnsapi.h
#include <dnsapi.h>
#include <ntdsa.h>


#include <ntlsa.h>
#include <lmcons.h>


#include <winldap.h>
#include <dnsapi.h>
#include <dsconfig.h>
#include <dsgetdc.h>
#include <lmapibuf.h>

#include "ntdsetup.h"
#include "setuputl.h"

#include "config.h"

void
Usage(CHAR *name)
{
    fprintf(stderr, "Usage: %s <options>\n\n", name);
    fprintf(stderr, "/a:<netbios domain name> : tests NtdsLocateServerInDomain\n");
    fprintf(stderr, "/r                   : Configure registry for first DC in forest\n");
    fprintf(stderr, "/rr:srcDsName        : Configure replica registry when replicating from srcDsName\n");
    fprintf(stderr, "/b                   : tests NtdsGetDefaultDnsName\n");
    fprintf(stderr, "/e                   : this prints out the closest server hosting a DS\n");
    fprintf(stderr, "/s                   : tests NtdsSetReplicaMachineAccount\n");
    fprintf(stderr, "/t:<dns name>        : this prints out the DC= version of the dns name given\n");
    fprintf(stderr, "/y:<dns domain name> : tests NtdsLocateServerInDomain\n");
    fprintf(stderr, "/configureservice    : steps through an interactive installation\n");

    return;
}


int __cdecl
main( int argc, char *argv[])


/*++

Routine Description:

    This routine does a simple test of ntdsetup entry points.  If the ds is
    running then the program exits; other it does an install.

Parameters:

    See Usage()

Return Values:

    0 if successful; !0 otherwise

--*/
{
    DWORD   WinError;
    LONG    count, index;
    WCHAR   NtdsPath[MAX_PATH];
    WCHAR   ReplServerName[MAX_PATH];
    CHAR    *regFirstMsg = "Registry configured for first dsa in enterprise.";
    CHAR    *regReplicaMsg = "Registry configured for replica of first dsa in enterprise.";
    CHAR    *regMsg = regFirstMsg;
    BOOL    fReplica = FALSE;

    NTDS_INSTALL_INFO  InstallInfo;
    NTDS_CONFIG_INFO   ConfigInfo;

    if ( argc < 2) {
        Usage(argv[0]);
        exit(-1);
    }

    RtlZeroMemory( &InstallInfo, sizeof(InstallInfo) );
    RtlZeroMemory( &ConfigInfo, sizeof(ConfigInfo) );

    if ( !GetEnvironmentVariable(L"SystemRoot", NtdsPath, MAX_PATH) )
    {
        printf( "GetEnvironmentVariable failed with %d\n", GetLastError() );
        exit(-1);
    }
    wcscat(NtdsPath, L"\\ntds");

    InstallInfo.Flags = NTDS_INSTALL_ENTERPRISE;
    InstallInfo.DitPath = NtdsPath;
    InstallInfo.LogPath = NtdsPath;
    InstallInfo.SiteName = L"FirstSite";
    InstallInfo.DnsDomainName = L"microsoft.com";
    InstallInfo.FlatDomainName = L"microsoft";
    InstallInfo.DnsTreeRoot = L"microsoft.com";

    //
    // Loop through parameters
    //

    count = 1; // skip the program name
    while (count < argc) {

        index = 0;
        if (argv[count][index] != '/') {
            Usage(argv[0]);
            exit(-1);
        }
        index++;

        switch (argv[count][index]) {

            case 'r':

                if (    (    ('r' == argv[count][index+1])
                          || ('R' == argv[count][index+1]) )
                     && ( ':' == argv[count][index+2]) )
                {
                    // replica case!
                    fReplica = TRUE;
                    mbstowcs(ReplServerName, &argv[count][index+3], MAX_PATH);
                    InstallInfo.Flags = NTDS_INSTALL_REPLICA;
                    InstallInfo.ReplServerName = ReplServerName;
                    wcscpy(ConfigInfo.ServerDN, L"CN=NTDS Settings,CN=");
                    wcscat(ConfigInfo.ServerDN, ReplServerName);
                    wcscat(ConfigInfo.ServerDN, L",CN=Servers,CN=FirstSite,CN=Sites,CN=Configuration,DC=Microsoft,DC=Com");
                    wcscpy(ConfigInfo.DomainDN,L"DC=Microsoft,DC=Com");
                    wcscpy(ConfigInfo.ConfigurationDN,L"CN=Configuration,DC=Microsoft,DC=Com");
                    wcscpy(ConfigInfo.SchemaDN,L"CN=Schema,CN=Configuration,DC=Microsoft,DC=Com");
                    regMsg = regReplicaMsg;
                }

                //
                // Load the registry
                //
                if ( (WinError=NtdspConfigRegistry(&InstallInfo, &ConfigInfo))
                     != ERROR_SUCCESS) {
                    printf("NtdspConfigRegistry returned winerror %d\n", WinError);
                } else {
                    printf("%s\n", regMsg);
                }

                if ( fReplica )
                {
                    DWORD  WinError;
                    HKEY   hRegistryKey;

                    ASSERT(ReplServerName);

                    WinError = RegOpenKeyExW(
                                HKEY_LOCAL_MACHINE,
                                TEXT(DSA_CONFIG_SECTION),
                                0,
                                KEY_READ | KEY_WRITE,
                                &hRegistryKey);

                    if ( ERROR_SUCCESS == WinError )
                    {
                        WinError = RegSetValueExW(hRegistryKey,
                                              TEXT(SETUPINITIALREPLWITH),
                                              0,
                                              REG_SZ,
                                              (void*) ReplServerName,
                                              (wcslen(ReplServerName) + 1)*sizeof(WCHAR));

                        RegCloseKey(hRegistryKey);
                    }

                    if ( ERROR_SUCCESS != WinError )
                    {
                        printf("AddReplicaLinkKey error %d\n", WinError);
                    }
                }

                break;

        default:
            Usage(argv[0]);
            exit(-1);

        }

        count++;
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\ntdsetup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ntdsetup.c

Abstract:

    Contains entry point definitions for ntdsetup.dll

Author:

    ColinBr  29-Sept-1996

Environment:

    User Mode - Win32

Revision History:


--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <stdio.h>
#include <winreg.h>
#include <ntlsa.h>
#include <winsock.h>  // for dnsapi.h
#include <dnsapi.h>
#include <lmcons.h>
#include <crypt.h>
#include <samrpc.h>
#include <samisrv.h>
#include <certca.h>

#include <dsconfig.h>
#include <dsgetdc.h>
#include <lmapibuf.h>

#include <ntdsa.h>
#include <ntdsapi.h>
#include <drs.h>
#include <dsconfig.h>
#include <winldap.h>
#include <lsarpc.h>      // for lsaisrv.h
#include <lsaisrv.h>     // for LsaISafeMode
#include <rpcdce.h>
#include <lmaccess.h>
#include <mdcodes.h>
#include <debug.h>
#include <dsevent.h>
#include <fileno.h>

#include "ntdsetup.h"
#include "setuputl.h"
#include "machacc.h"
#include "install.h"
#include "status.h"
#include "config.h"
#include "sync.h"
#include "demote.h"

#define DEFS_ONLY
#include <draatt.h>        // DRS_xxx constants
#undef DEFS_ONLY
#include <dsaapi.h>        // DirReplicaXXX prototypes

//
// For the debugging subsystem
//
#define DEBSUB "NTDSETUP:"
#define FILENO FILENO_NTDSETUP_NTDSETUP

//
// Dll entrypoint definitions
//

DWORD
NtdsInstall(
    IN  PNTDS_INSTALL_INFO pInstallInfo,
    OUT LPWSTR *InstalledSiteName, OPTIONAL
    OUT GUID   *NewDnsDomainGuid,  OPTIONAL
    OUT PSID   *NewDnsDomainSid    OPTIONAL
    )
/*++

Routine Description:

    This routine is lsass.exe in-proc api to install the nt directory service.
    It is meant to be called in the context of a dsrole server side rpc thread.

    This purpose of this function is to prepare an environment where
    ntdsa!DsInitialize() will succeed. To that the end, the following
    items are done:

    1) performs user parameter checks
    2) tries to find a site if the user did not specify one
    3) determines the netbios name for the new domain if necessary
    4) verifies that the site object for the destination site exists
       on the source server, and that the ntds-dsa and xref object that
       may be created during DsInitialize() does not already exist
    5) sets the parameters in the registry
    6) sets up the performance counters
    7) call SamIPromote

        SamIPromote() is an api exported from samsrv.dll that prepares itself to
        host the ds and then actually initiates the ds initialization via
        DsInitialize().

    8) sets another parameter for the ds if reciprocal links are necessary.
    9) configures the machine to auto-enroll for an X.509 DC type certificate
        from the first Certifying Authority that will give it one.

Parameters:

    pInstallInfo  - structure filled with sufficient information
                    to install a directory service locally

Return Values:

    A value from winerror.h

    ERROR_SUCCESS, the service completed successfully.

    ERROR_NO_SITE_FOUND, dsgetdc could not find a site

    ERROR_NO_SUCH_SITE, the site specified cannot be found on the replica

    ERROR_SERVER_EXISTS, the server name already exists

    ERROR_DOMAIN_EXISTS, the domain name already exists

    ERROR_INVALID_PROMOTION, the ds installation is not supported in the current
                             environment

    ERROR_NOT_AUTHENTICATED, the user credentials were unable to replicate the
                             ds information, or to bind to source ds.

    ERROR_DS_NOT_INSTALLED, a fatal error occured while installing the ds.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    WinError = ERROR_SUCCESS;
    DWORD    RidManagerUpdateError = ERROR_SUCCESS;
    DWORD    BootOptionUpdateError = ERROR_SUCCESS;
    DWORD    WinError2;
    HRESULT  hResult;

    NTDS_INSTALL_INFO    *UserInfo;
    NTDS_CONFIG_INFO      DiscoveredInfo;

    UCHAR          Seed = 0;
    BOOLEAN        fPasswordEncoded = FALSE;
    UNICODE_STRING EPassword;

    //
    // Clear the stack
    //
    RtlZeroMemory(&DiscoveredInfo, sizeof(DiscoveredInfo));

    //
    // API parameter check
    //
    if ( !pInstallInfo ) {
        return ERROR_INVALID_PARAMETER;
    }
    UserInfo = pInstallInfo;


    //
    // Set the global callback routines
    //
    NtdspSetCallBackFunction( UserInfo->pfnUpdateStatus,
                              UserInfo->pfnErrorStatus,
                              UserInfo->pfnOperationResultFlags,
                              UserInfo->ClientToken  );

    //
    // Encode the password
    //
    if ( UserInfo->Credentials )
    {
        RtlInitUnicodeString( &EPassword, UserInfo->Credentials->Password );
        RtlRunEncodeUnicodeString( &Seed, &EPassword );
        fPasswordEncoded = TRUE;
    }

    //
    // Right off the bat, remember to cleanup the database files
    //
    DiscoveredInfo.UndoFlags |= NTDSP_UNDO_DELETE_FILES;

    //
    // Don't go any futher if the ds is already installed or
    // if we are in the directory service repair mode
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_INITIALIZATION );

    if ( SampUsingDsData() || LsaISafeMode() ) {
        NTDSP_SET_ERROR_MESSAGE0( ERROR_INVALID_SERVER_STATE,
                                  DIRLOG_INSTALL_FAILED_ENVIRONMENT );  

        WinError = ERROR_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    if ( TEST_CANCELLATION() ) {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Sanity check the large number of parameters
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_VALIDATING_PARAMS );

    WinError = NtdspValidateInstallParameters( UserInfo );
    if ( ERROR_SUCCESS != WinError )
    {
        //
        //  No error message here since this would only indicate
        //  an internal error
        //
        goto Cleanup;
    }

    if (TEST_CANCELLATION()) {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Determine what site to install ourselves into if none is provided
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_FINDING_SITE );

    WinError = NtdspFindSite( UserInfo,
                             &DiscoveredInfo );
    if ( ERROR_SUCCESS != WinError )
    {
        NTDSP_SET_ERROR_MESSAGE0( WinError, 
                                  DIRMSG_INSTALL_FAILED_SITE );

        goto Cleanup;
    }

    if ( TEST_CANCELLATION() )  {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Check the parameters with the environment we are about to install into
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_CONTEXT );

    if ( fPasswordEncoded )
    {
        RtlRunDecodeUnicodeString( Seed, &EPassword );
        fPasswordEncoded = FALSE;
    }

    WinError = NtdspVerifyDsEnvironment( UserInfo,
                                         &DiscoveredInfo );
                                         
    if ( ERROR_SUCCESS != WinError )
    {
        //
        // Error message should have already been set
        //
        ASSERT( NtdspErrorMessageSet() );
        if ( NtdspErrorMessageSet() )
        {
            WinError = NtdspErrorMessageSet();
        }
        goto Cleanup;
    }


    if ( TEST_CANCELLATION() ) {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    RidManagerUpdateError = NtdspBringRidManagerUpToDate( UserInfo,
                                                         &DiscoveredInfo );

    if ( ERROR_SUCCESS != RidManagerUpdateError )
    {
        //
        // This error is not fatal, but do make a note
        //
        DPRINT( 0, "Failed to bring rid manager up to date; continuing, though\n" );

    }


    //
    // Set the credentials in the replication client library. There are
    // quite a few layers between here and there and there is no support
    // to pass the information up the stack so they are set as globals
    // in the client library.
    //
    if ( !FLAG_ON( UserInfo->Flags, NTDS_INSTALL_ENTERPRISE ) )
    {
        WinError = NtdspSetReplicationCredentials( UserInfo );
        if ( WinError != ERROR_SUCCESS )
        {
            // No error message here
            goto Cleanup;
        }
    }

    //
    // Encode the password again
    //
    if ( UserInfo->Credentials )
    {
        RtlRunEncodeUnicodeString( &Seed, &EPassword );
        fPasswordEncoded = TRUE;
    }

    //
    // Set the registry parameters
    //
    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_CONFIGURE_LOCAL );

    WinError = NtdspConfigRegistry( UserInfo,
                                    &DiscoveredInfo );

    if ( ERROR_SUCCESS != WinError )
    {
        NTDSP_SET_ERROR_MESSAGE0( WinError, DIRLOG_INSTALL_FAILED_REGISTRY );
        goto Cleanup;

    }
    DiscoveredInfo.UndoFlags |= NTDSP_UNDO_UNDO_CONFIG;

    if ( TEST_CANCELLATION() ) {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Start the directory service initialization 
    //

    // Note, this may return prematurely with error if shutdown occurs
    WinError = NtdspDsInitialize( UserInfo,
                                  &DiscoveredInfo );

    if ( ERROR_SUCCESS != WinError )
    {
        Assert( NtdspErrorMessageSet() );
        if ( NtdspErrorMessageSet() )
        {
            WinError = NtdspErrorMessageSet();
        }
        goto Cleanup;
    }

    if ( TEST_CANCELLATION() ) {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }


    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_COMPLETING );

    //
    // Configure the registry such that the local machine is auto-enrolled for
    // a DC type certificate from the first Certifying Authority that will give
    // it one.  This ceritificate is used by both the KDC and DS intersite
    // replication.
    //

    hResult = CACreateLocalAutoEnrollmentObject(
                    wszCERTTYPE_DC,                     // DC certificate
                    NULL,                               // any CA
                    NULL,                               // reserved
                    CERT_SYSTEM_STORE_LOCAL_MACHINE);   // use machine store
    if (FAILED(hResult)) {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hResult)) {
            // Error is an encoded Win32 status -- decode back to Win32.
            WinError = HRESULT_CODE(hResult);
        }
        else {
            // Error is in some other facility.  For lack of a better plan,
            // pass the HRESULT off as a Win32 code.
            WinError = hResult;
        }

        NTDSP_SET_ERROR_MESSAGE0( WinError,
                                  DIRLOG_INSTALL_FAILED_CA_ENROLLMENT );

        goto Cleanup;
    }

    //
    // Transfer the parameters
    //
    if ( WinError == ERROR_SUCCESS )
    {
        if ( NewDnsDomainGuid )
        {
            RtlCopyMemory( NewDnsDomainGuid,
                           &DiscoveredInfo.NewDomainGuid,
                           sizeof( GUID ) );
        }

        if ( NewDnsDomainSid )
        {
            *NewDnsDomainSid = DiscoveredInfo.NewDomainSid;
        }

        if ( InstalledSiteName )
        {
            WCHAR *SiteName;
            ULONG Size;

            if ( UserInfo->SiteName )
            {
                SiteName = UserInfo->SiteName;
            }
            else
            {
                ASSERT( DiscoveredInfo.SiteName[0] != L'\0' );
                SiteName = DiscoveredInfo.SiteName;
            }

            if ( SiteName )
            {
                Size = (wcslen( SiteName ) + 1) * sizeof(WCHAR);
                *InstalledSiteName =  (WCHAR*) RtlAllocateHeap( RtlProcessHeap(),
                                                                0,
                                                                Size );
                if ( *InstalledSiteName )
                {
                    wcscpy( *InstalledSiteName, SiteName );
                }
                else
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else
            {
                *InstalledSiteName = NULL;
            }
        }

    }

    //
    // Log non-critical errors, if any.  Note that the EventTable has to 
    // loaded for the event logging routines to work.
    //
    Assert( ERROR_SUCCESS == WinError );

    LoadEventTable();
    if ( ERROR_SUCCESS != RidManagerUpdateError )
    {
                          
        LogEvent8WithData( DS_EVENT_CAT_SETUP,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_FAILED_TO_SYNC_RID_FSMO,
                           NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
                           sizeof(DWORD), &RidManagerUpdateError );
    }

    if ( ERROR_SUCCESS != BootOptionUpdateError )
    {
        LogEvent8WithData( DS_EVENT_CAT_SETUP,
                           DS_EVENT_SEV_ALWAYS,
                           DIRLOG_FAILED_TO_CREATE_BOOT_OPTION,
                           NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
                           sizeof(DWORD), &BootOptionUpdateError );
    }
    UnloadEventTable();


    //
    // Save off enough information to undo the changes
    //
    if ( fPasswordEncoded )
    {
        RtlRunDecodeUnicodeString( Seed, &EPassword );
        fPasswordEncoded = FALSE;
    }

    WinError = NtdspSetInstallUndoInfo(  UserInfo, &DiscoveredInfo );
    if ( ERROR_SUCCESS != WinError )
    {
        // This can only be a resource error so don't set a specific error
        // message
        goto Cleanup;
    }


    //
    // We are done!
    //

Cleanup:

    // Test for cancellation one last time
    if ( ERROR_CANCELLED != WinError )
    {
        if (TEST_CANCELLATION()) {
            WinError = ERROR_CANCELLED;
        }
    }

    if ( fPasswordEncoded )
    {
        RtlRunDecodeUnicodeString( Seed, &EPassword );
        fPasswordEncoded = FALSE;
    }

    if ( WinError != ERROR_SUCCESS && DiscoveredInfo.UndoFlags )
    {
        WinError2 = NtdspInstallUndoWorker( UserInfo->ReplServerName,
                                            UserInfo->Credentials,
                                            UserInfo->ClientToken,
                                            DiscoveredInfo.LocalServerDn,
                                            DiscoveredInfo.DomainDN,
                                            DiscoveredInfo.LocalMachineAccount,
                                            UserInfo->LogPath,
                                            UserInfo->DitPath,
                                            DiscoveredInfo.UndoFlags );

        if ( ERROR_SUCCESS != WinError2 )
        {
            // Event logs should already have been made
            DPRINT1( 0, "NtdspInstallUndoExternal failed with %d\n", WinError2 );
        }
   }


    if ( ERROR_SUCCESS != WinError 
      && ERROR_CANCELLED != WinError  )
    {
        Assert( NtdspErrorMessageSet() );
        if ( NtdspErrorMessageSet() )
        {
            WinError = NtdspErrorMessageSet();
        }

        //
        // Just in case it is not set, make it clear that the
        // error occurred while installing the ds
        //
        NTDSP_SET_ERROR_MESSAGE0( WinError, DIRLOG_INSTALL_FAILED_GENERAL );
    }

    NtdspSetCallBackFunction( NULL, NULL, NULL, NULL );

    NtdspReleaseConfigInfo( &DiscoveredInfo );

    return (WinError);

}


DWORD
NtdsGetDefaultDnsName(
    OUT WCHAR *DnsName,
    IN OUT ULONG *DnsNameLength
    )
/*++

Routine Description:

    This routine is a wrapper for GetDefaultDnsName. See that function
    for comments.

--*/
{
    return GetDefaultDnsName(DnsName, DnsNameLength);
}



DWORD
NtdsInstallUndo(
    VOID
    )
/*++

Routine Description:


    This function is the undo for NtdsInstall().  It is called by clients
    when NtdsInstall() has succeeded, but a subsequent operation has failed
    and the effects of NtdsInstall() need to be undone.


Returns:

    ERROR_SUCCESS

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    // We want to protect ourselves against clients calling this, when we
    // are in fact using the ds because removing these keys would hose the ds.
    if (SampUsingDsData()) {
        ASSERT(!"NTDSETUP: NtdsUninstall is being called in the wrong context");
        return ERROR_SUCCESS;
    }

    WinError = NtdspInstallUndo();

    return WinError;
}


DWORD
NtdsInstallShutdown(
    VOID
    )
/*++

Routine Description:

    This routine shuts down the directory service during the install
    phase.

Returns:

--*/
{
    DWORD status;

    status = ShutdownDsInstall();

    return status;
}


DWORD
NtdsInstallReplicateFull(
    CALLBACK_STATUS_TYPE StatusCallback,
    HANDLE               ClientToken,
    ULONG                ulRepOptions
    )

/*++

Routine Description:

This is a public entrypoint in the DLL.
It causes this system to do a full sync of the domain NC.
It is expected that the critical objects have already been replicated, and
this step is bring over the remainder of the objects.  This step may be
interrupted by the ds being shutdown.  In this case, we return ERROR_SHUTDOWN

Arguments:

    StatusCallback -- a pointer to a function to give status updates.

Return Value:

    DWORD -
    ERROR_SUCCESS
    ERROR_SHUTDOWN
--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    WinError = ERROR_SUCCESS;
    ULONG    ulOptions = DRS_FULL_SYNC_NOW;
    GUID     SrcSrvGuid;
    DSNAME * pdnDomain = NULL;
    ULONG    Size;

    // If NtdsInstallCancel is called, shutdown the ds
    SET_SHUTDOWN_DS();

    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Exit;
    }

    //
    // Set the global call back in the DS so the replication code
    // can give updates
    //
    DsaSetInstallCallback( StatusCallback, NULL, NULL, ClientToken );

    // Get the ntdsDsa objectGuid of the source of the domain nc
    WinError = GetConfigParamW(
        MAKE_WIDE(SOURCEDSAOBJECTGUID),
        &SrcSrvGuid,
        sizeof(SrcSrvGuid) );
    if (WinError != ERROR_SUCCESS) {
        DPRINT2( 0, "GetConfigParam( %s ) failed. Error %d\n",
                SOURCEDSAOBJECTGUID, WinError );
        goto Exit;
    }

    Size = 0;
    pdnDomain = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     pdnDomain );
    Assert( STATUS_BUFFER_TOO_SMALL == NtStatus );
    pdnDomain = (DSNAME*) alloca( Size );
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     pdnDomain );
    Assert( NT_SUCCESS( NtStatus ) );

    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_REPLICATE_FULL );

    // Note that this call may return prematurely if ds is shutdown
    // Error returned is a Win32 value

    Assert(THVerifyCount(0));

    if (ulRepOptions == NTDS_IFM_PROMOTION) {
        ulOptions = DRS_WRIT_REP;
    }
    
    WinError = DirReplicaSynchronize(
        pdnDomain,
        NULL,
        &SrcSrvGuid,
        ulOptions
        );
    
    // If we receive a cancellation, don't shutdown the ds
    CLEAR_SHUTDOWN_DS();

    DsaSetInstallCallback( NULL, NULL, NULL, NULL );

    // Free the thread state allocated by DirReplicaSynchronize().
    Assert(THVerifyCount(1));
    THDestroy();

    if (WinError)
    {
        DPRINT2(0,"DirReplicaSynchronize(%ws) Failed. Error %d\n",
                pdnDomain->StringName, WinError);
        goto Exit;
    }

    DPRINT1(0, "DirReplicaSynchronize(%ws) Succeeded\n",
            pdnDomain->StringName);


Exit:

    // If we receive a cancellation, don't shutdown the ds
    // as our caller will do that
    CLEAR_SHUTDOWN_DS();

    return WinError;
} /* NtdsInstallReplicateFull */


DWORD
NtdsInstallCancel(
    void
    )

/*++

Routine Description:

Cancel a call to NtdsInstall or NtdsInstallReplicateFull or NtdsDemote

This function causes the ds to shutdown, causing those calls in progress to
abort.  It is not necessary to call NtdsInstallShutdown if you call this
function.

It is the callers responsibility to undo the effects of the installation if
necessary.  The caller should keep track of whether it was calling NtdsInstall
or NtdsInstallReplicateFull.  For the former, it should fail the install and
undo; for the latter, it should indicate success.

Arguments:

    void -

Return Value:

    DWORD -

--*/

{

    DPRINT( 1, "NtdsInstallCancel entered\n" );

    return NtdspCancelOperation();

} /* NtdsInstallCancel */


DWORD
NtdsDemote(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN LPWSTR                   AdminPassword, OPTIONAL
    IN DWORD                    Flags,
    IN LPWSTR                   ServerName,
    IN HANDLE                   ClientToken,
    IN CALLBACK_STATUS_TYPE     pfnStatusCallBack,  OPTIONAL
    IN CALLBACK_ERROR_TYPE      pfnErrorCallBack  OPTIONAL
    )
/*++

Routine Description:

    This function is entrypoint for the demote operation from ntdsetup.
    It shuts down the directory service and prepares SAM and the LSA to
    be a non-DC server upon reboot.

    WARNING!  This is an unrecoverable function once it succeeds since it
    removes all traces of the server from the global directory service.

Parameters:

    Credentials:   pointer, credentials that will enable us to
                   change the account object

    AdminPassword: pointer, to admin password of new account database

    Flags        : supported flags are:
                       NTDS_LAST_DC_IN_DOMAIN  Last dc in domain
                       NTDS_LAST_DOMAIN_IN_ENTERPRISE Last dc in enterprise
                       NTDS_DONT_DELETE_DOMAIN


    ServerName   : the server to remove ourselves from
    
    ClientToken  : the client's used for impersonation

    pfnStatusCallBack: a function to call to provide a string status
                       of our current operation

    pfnErrorCallBack: a function to call to provide a string status
                      of the error that caused us to bail
                      
Return Values:

    A value from winerror.h

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    //
    // Don't bother if we've already been cancelled
    //
    if ( TEST_CANCELLATION() )
    {
        return ERROR_CANCELLED;
    }

    //
    // Do parameter checking
    //
    if ( !pfnStatusCallBack )
    {
        ASSERT( !"NTDSETUP: Bad parameters passed into NtdsDemote" );
        return ERROR_INVALID_PARAMETER;
    }

    // We should always get a client token
    ASSERT( 0 != ClientToken );

    NtdspSetCallBackFunction( pfnStatusCallBack, pfnErrorCallBack, NULL, ClientToken );

    NTDSP_SET_STATUS_MESSAGE0( DIRMSG_DEMOTE_INIT );

    //
    // First do some primitive checking to make we are being called in the
    // correct context
    //
    if ( !SampUsingDsData() || LsaISafeMode() ) {
        ASSERT(!"NTDSETUP: NtdsDemote is being called in the wrong context");
        return ERROR_INVALID_SERVER_STATE;
    }

    //
    // Call the worker
    //
    WinError = NtdspDemote(Credentials,
                           ClientToken,
                           AdminPassword,
                           Flags,
                           ServerName );


    NtdspSetCallBackFunction( NULL, NULL, NULL, NULL );

    return WinError;

}


DWORD
NtdsPrepareForDemotion(
    IN ULONG Flags,
    IN LPWSTR ServerName,
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,       OPTIONAL
    IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
    IN CALLBACK_ERROR_TYPE      pfnErrorStatus,    OPTIONAL
    IN HANDLE                   ClientToken,       OPTIONAL
    OUT PNTDS_DNS_RR_INFO      *pDnsRRInfo
    )
/*++

Routine Description:

    This routine is called before netlogon is turned off.
    
    Currently, it does the following:
    
    Attempts to get rid of all fsmo;s on the machine.
    
Parameters:

    Flags: currently only "Last dc in domain"
    
    ServerName: the server that is helping us to demote
    
    
    pDnsRRInfo: structure that caller uses to deregister the dns records
                of this DC

Return Values:

    A value from winerror.h

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    DWORD WinError = ERROR_SUCCESS;


    NtdspSetCallBackFunction( pfnStatusCallBack, pfnErrorStatus, NULL, ClientToken );
    DsaSetInstallCallback( pfnStatusCallBack, NULL, NULL, ClientToken );

    WinError = NtdspPrepareForDemotion( Flags,
                                        ServerName,
                                        Credentials,
                                        ClientToken,
                                        pDnsRRInfo );

    DsaSetInstallCallback( NULL, NULL, NULL, NULL );
    NtdspSetCallBackFunction( NULL, NULL, NULL, NULL );

    return WinError;
}


DWORD
NtdsPrepareForDemotionUndo(
    VOID
    )
/*++

Routine Description:

    This routine undoes NtdsPrepare for demote - currently nothing.

Parameters:

    None.


Return Values:

    A value from winerror.h

--*/
{

    DWORD WinError = ERROR_SUCCESS;

    WinError = NtdspPrepareForDemotionUndo();

    return WinError;
}



DWORD
NtdsSetReplicaMachineAccount(
    IN SEC_WINNT_AUTH_IDENTITY   *Credentials,
    IN HANDLE                     ClientToken,
    IN LPWSTR                     DcName,
    IN LPWSTR                     AccountName,
    IN ULONG                      AccountType,
    IN OUT WCHAR**                AccountDn
    )
/*++

Routine Description:

    This function sets the account type of account name on DcName.

Parameters:

    Credentials:   pointer, credentials that will enable us to
                   change the account object
                   
    ClientToken:   the token of the user requesting the role change                       

    DcName:        the server to contact

    AccountName:   the account to change

    AccountType:   the lmaccess.h defined value for the account control field
    
    AccountDn:     If AccountType == SERVER_TRUST_ACCOUNT, the account will
                   also be moved into the Domain Controllers OU, if it exists.
                   When the account is moved, AccountDn will be filled with
                   the old Dn of the account.
                   Otherwise, the account will be tried to be moved whatever
                   value is passed in; failure will not cause the routine
                   to fail.
                   Note, if the parameter is set when SERVER_TRUST_ACCOUNT,
                   the value will be ignored and overwritten.
                   
                   If this function returns failure, *AccountDn, will equal 0.
                   
                   When !0, the caller must free using the Rtl heap allocator.
                   
Return Values:

    A value from winerror.h

--*/
{

    DWORD WinError;

    if (   DcName == NULL
        || AccountName == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    WinError = NtdspSetMachineAccount( AccountName,
                                       Credentials,
                                       ClientToken,
                                       NULL,     // don't know the domain dn
                                       DcName,
                                       AccountType,
                                       AccountDn );

    return WinError;
}


DWORD
NtdsPrepareForDsUpgrade(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO NewLocalAccountInfo,
    OUT LPWSTR                      *NewAdminPassword
    )
/*++

Routine Description:

    This routine calls into SAM so it can save off the downlevel hive.
    Also, it creates a sid that will be used as the temporary account
    domain sid sid until dcpromo is run.

Parameters:

    NewLocalAccountInfo: allocated from the process heap, the new sid
                         for the temporary account domain
                         
    NewAdminPassword: the password of the admin in the new account domain                         

Return Values:

    A value from winerror.h

--*/
{

    NTSTATUS                    NtStatus;
    DWORD                       WinError;

    //
    // Parameter check
    //
    if ( !NewLocalAccountInfo || !NewAdminPassword )
    {
        return ERROR_INVALID_PARAMETER;
    }
    RtlZeroMemory( NewLocalAccountInfo, sizeof( POLICY_ACCOUNT_DOMAIN_INFO ) );
    *NewAdminPassword = NULL;

    //
    // Create the new account domain info
    //
    WinError = NtdspCreateLocalAccountDomainInfo( NewLocalAccountInfo,
                                                  NewAdminPassword );
    if ( ERROR_SUCCESS != WinError )
    {
        return WinError;
    }

    //
    // Prepare SAM
    //
    NtStatus = SamIReplaceDownlevelDatabase( NewLocalAccountInfo,
                                             *NewAdminPassword,
                                             &WinError );


    if ( NT_SUCCESS( NtStatus ) )
    {
        ASSERT( ERROR_SUCCESS == WinError );
    }

    if ( ERROR_SUCCESS != WinError )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, *NewAdminPassword );
        *NewAdminPassword = NULL;

    }

    return WinError;

}

BOOL
DllEntryPoint(
    IN HANDLE  hModule,
    IN DWORD   dwReason,
    IN LPVOID  lpRes
    )
{

    int argc = 2;
    char *argv[] = {"lsass.exe", "-noconsole"};

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        // init the cancel state
        NtdspInitCancelState();

        // init the debug library
        DEBUGINIT( argc, argv, "ntdsetup" );

        // init the logging library
        (VOID) LoadEventTable();
        //
        // We don't want to be notified when threads come and go
        //
        DisableThreadLibraryCalls( hModule );
        

        break;

    case DLL_PROCESS_DETACH:

        NtdspUnInitCancelState();

        NtdspReleaseInstallUndoInfo();

        DEBUGTERM();

        UnloadEventTable();
        break;

    default:
        break;
    }

    UNREFERENCED_PARAMETER(lpRes);

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\machacc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    machacc.c

Abstract:

    Contains function definitions for utilities relating to machine
    account setting used in ntdsetup.dll

Author:

    ColinBr  03-Sept-1997

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <NTDSpch.h>
#pragma  hdrstop

#include <drs.h>
#include <ntdsa.h>

#include <winldap.h>  // for ldap calls
#include <rpcdce.h>   // for SEC_WINNT_AUTH_IDENTITY
#include <lmaccess.h> // for UF_WORKSTATION_TRUST_ACCOUNT, etc

#include <rpcdce.h>   // for SEC_WINNT_AUTH_IDENTITY

#include <ntsam.h>    // for lsaisrv.h
#include <lsarpc.h>   // for lsaisrv.h
#include <lsaisrv.h>  // for internal LSA calls
#include <samrpc.h>   // for samisrv.h
#include <samisrv.h>  // for internal SAM call
#include <ntdsetup.h>
#include <setuputl.h>

#include "machacc.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    WCHAR*  SiteName;
    WCHAR*  SiteDn;

} SITELIST_ELEMENT, *PSITELIST_ELEMENT;

typedef SITELIST_ELEMENT *SITELIST_ARRAY;

DWORD
NtdspOpenLdapConnection(
    IN WCHAR*                   InitialDc,
    IN SEC_WINNT_AUTH_IDENTITY* Credentials,
    IN HANDLE                   ClientToken,
    OUT LDAP **                 LdapHandle
    );

DWORD
NtdspGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT WCHAR **DomainDn,
    OUT WCHAR **ConfigDn
    );

DWORD
NtdspGetDcListForSite(
    IN LDAP*            LdapHandle,
    IN WCHAR*           SiteDn,
    IN WCHAR*           DomainDn,
    IN WCHAR*           RootDomainName,
    OUT WCHAR***        DcList,
    OUT PULONG          DcCount
    );


DWORD
NtdspGetUserDn(
    IN LDAP*    LdapHandle,
    IN WCHAR*   DomainDn,
    IN WCHAR*   AccountName,
    OUT WCHAR** AccountNameDn
    );

DWORD
NtdspSetMachineType(
    IN LDAP*    LdapHandle,
    IN WCHAR*   AccountNameDn,
    IN ULONG    ServerType
    );

DWORD
NtdspSetContainer(
    IN LDAP*  LdapHandle,
    IN WCHAR* AccountName,
    IN WCHAR* AccountNameDn,
    IN ULONG  ServerType,
    IN WCHAR* DomainDn,
    IN OUT WCHAR** OldAccountDn
    );

BOOLEAN
NtdspDoesDestinationExist(
    IN LDAP*  LdapHandle,
    IN ULONG  ServerType,
    IN WCHAR* DomainName
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exported (from this source file) function definitions                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


DWORD
NtdspSetMachineAccount(
    IN WCHAR*                   AccountName,
    IN SEC_WINNT_AUTH_IDENTITY* Credentials,
    IN HANDLE                   ClientToken,
    IN WCHAR*                   DomainDn, OPTIONAL
    IN WCHAR*                   DcAddress,
    IN ULONG                    ServerType,
    IN OUT WCHAR**              AccountDn
    )
/*++

Routine Description:

    Given the account name dn, this routine will set server type and
    password if the server type is SERVER.

Parameters:

    AccountName   : a null terminated string of the account

    Credentials   : pointer to a set of valid credentials allowing us
                    to bind

    ClientToken:   the token of the user requesting the role change       
                    
    DomainDn      : null terminated string of root domain dn; this routine
                    will query for it if not present.

    DcAddress     : a null terminating string of the dc address (dns name)

    ServerType    : a value from lmaccess.h - see function for details


Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    LDAP *LdapHandle = NULL;
    DWORD WinError, IgnoreError;

    // need to free
    WCHAR *LocalDomainDn = NULL, *ConfigDn = NULL, *AccountNameDn = NULL;

    WCHAR *NewPassword;
    ULONG Length;
    ULONG RollbackServerType;


    //
    // Parameter sanity check
    //
    if (!AccountName ||
        !DcAddress) {
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }


    if ( UF_SERVER_TRUST_ACCOUNT == ServerType )
    {
        RollbackServerType = UF_WORKSTATION_TRUST_ACCOUNT;
    } 
    else if ( UF_WORKSTATION_TRUST_ACCOUNT == ServerType )
    {
        RollbackServerType = UF_SERVER_TRUST_ACCOUNT;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Here is the new password
    //
    Length = wcslen(AccountName);
    NewPassword = RtlAllocateHeap(RtlProcessHeap(), 0, (Length+1)*sizeof(WCHAR));
    if (!NewPassword) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(NewPassword, AccountName);
    if (NewPassword[Length-1] == L'$') {
        NewPassword[Length-1] = L'\0';
    } else {
        ASSERT(!"NTDSETUP: non machine account name passed in");
    }
    _wcslwr(NewPassword);

    WinError = NtdspOpenLdapConnection(DcAddress,
                                       Credentials,
                                       ClientToken,
                                       &LdapHandle);
    if (WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Get the domain dn if necessary
    //
    if (!DomainDn) {

        WinError = NtdspGetAuthoritativeDomainDn(LdapHandle,
                                                 &LocalDomainDn,
                                                 &ConfigDn);

        if (ERROR_SUCCESS != WinError) {
            goto Cleanup;
        }

    } else {

        LocalDomainDn = DomainDn;

    }

    WinError = NtdspGetUserDn(LdapHandle,
                              LocalDomainDn,
                              AccountName,
                              &AccountNameDn);

    if (ERROR_SUCCESS == WinError) {

        //
        // We found it!
        //

        WinError = NtdspSetMachineType(LdapHandle,
                                       AccountNameDn,
                                       ServerType);

        if ( ERROR_SUCCESS == WinError )
        {
            // set the location of the account if requested
            if ( AccountDn )
            {
                if ( *AccountDn )
                {
                    // the caller is explicity indicating where to put the
                    // object.  This routine does not gaurentee success of this
                    // attempt, nor do we return where the account was.
                    IgnoreError = ldap_modrdn2_sW(LdapHandle,
                                                  AccountNameDn,
                                                  (*AccountDn),
                                                  TRUE );  // fDelete old rdn
                }
                else
                {
                    // move the object to its default location
                    WinError = NtdspSetContainer(LdapHandle,
                                                 AccountName,
                                                 AccountNameDn,
                                                 ServerType,
                                                 LocalDomainDn,
                                                 AccountDn );
    
                    if ( ERROR_SUCCESS != WinError )
                    {
                        // Try to rollback account type change
                        IgnoreError = NtdspSetMachineType(LdapHandle,
                                                          AccountNameDn,
                                                          RollbackServerType);
        
                    }
                }
            }
        }
    }

Cleanup:

    if (LdapHandle) {
        ldap_unbind(LdapHandle);
    }

    if ( LocalDomainDn != DomainDn
      && LocalDomainDn   ) {
        RtlFreeHeap( RtlProcessHeap(), 0, LocalDomainDn );
    }

    if ( ConfigDn ) {
        RtlFreeHeap( RtlProcessHeap(), 0, ConfigDn );
    }

    if ( AccountNameDn ) {
        RtlFreeHeap( RtlProcessHeap(), 0, AccountNameDn );
    }

    return WinError;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private function definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
DWORD
NtdspOpenLdapConnection(
    IN WCHAR*                   InitialDc,
    IN SEC_WINNT_AUTH_IDENTITY* Credentials,
    IN HANDLE                   ClientToken,
    OUT LDAP **                 LdapHandle
    )
/*++

Routine Description:

    This routine is a simple helper function to open an ldap connection
    and bind to it.

Parameters:

    InitialDc     : a null terminating string of the dc address (dns name)

    Credentials   : pointer to a set of valid credentials allowing us
                    to bind
                    
    ClientToken   : the token of the user requesting the role change                       
    
    LdapHandle    : a pointer to an ldap handle to be filled in by this routine


Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD LdapError;

    ULONG ReferralOption = 0;

    // routine-local copy of the ldap handle
    LDAP  *LocalLdapHandle = NULL;

    //
    // Parameter sanity check
    //
    ASSERT(InitialDc);
    ASSERT(LdapHandle);

    LocalLdapHandle = ldap_open(InitialDc, LDAP_PORT);

    if (!LocalLdapHandle) {

        WinError = GetLastError();

        if (WinError == ERROR_SUCCESS) {
            //
            // This works around a bug in the ldap client
            //
            WinError = ERROR_CONNECTION_INVALID;
        }

        return WinError;

    }

    //
    // Don't chase any referrals; this function simply sets a field in
    // the ldap structure so can only fail with bad parameters.
    //
    LdapError = ldap_set_option(LocalLdapHandle,
                                LDAP_OPT_REFERRALS,
                                &ReferralOption);
    ASSERT(LdapError == LDAP_SUCCESS);

    LdapError = impersonate_ldap_bind_sW(ClientToken,
                                         LocalLdapHandle,
                                         NULL,  // use credentials instead
                                         (VOID*)Credentials,
                                         LDAP_AUTH_SSPI);

    WinError = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS != WinError) {

        ldap_unbind_s(LocalLdapHandle);

        if (ERROR_GEN_FAILURE == WinError ||
            ERROR_WRONG_PASSWORD == WinError)  {
            // This does not help anyone.  AndyHe needs to investigate
            // why this is returned when invalid credentials are passed in.
            WinError = ERROR_NOT_AUTHENTICATED;
        }

        return WinError;
    }

    *LdapHandle = LocalLdapHandle;

    return ERROR_SUCCESS;
}

DWORD
NtdspGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT WCHAR **DomainDn,
    OUT WCHAR **ConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    DomainDn      : a pointer to a string to be allocated in this routine

    ConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];

    WCHAR  *DefaultNamingContext       = L"defaultNamingContext";
    WCHAR  *ConfigurationNamingContext = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectClass=*";

    //
    // These must be present
    //
    ASSERT(LdapHandle);
    ASSERT(DomainDn);
    ASSERT(ConfigDn);

    //
    // Set the out parameters to null
    //
    *ConfigDn = 0;
    *DomainDn = 0;

    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = DefaultNamingContext;
    AttrArray[1] = ConfigurationNamingContext;
    AttrArray[2] = NULL;  // this is the sentinel

    LdapError = ldap_search_sW(LdapHandle,
                               NULL,
                               LDAP_SCOPE_BASE,
                               ObjectClassFilter,
                               AttrArray,
                               FALSE,
                               &SearchResult);

    WinError = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS == WinError) {

        Entry = ldap_first_entry(LdapHandle, SearchResult);

        if (Entry) {

            Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

            while (Attr) {

                if (!_wcsicmp(Attr, DefaultNamingContext)) {

                    Values = ldap_get_values(LdapHandle, Entry, Attr);

                    if (Values && Values[0]) {

                        (*DomainDn) = Values[0];

                    }

                } else if (!_wcsicmp(Attr, ConfigurationNamingContext)) {

                    Values = ldap_get_valuesW(LdapHandle, Entry, Attr);

                    if (Values && Values[0]) {

                        (*ConfigDn) = Values[0];
                    }
                }

                Attr = ldap_next_attribute(LdapHandle, Entry, BerElement);
            }
        }

        if ( !(*DomainDn) || !(*ConfigDn) ) {
            //
            // We could get the default domain - bail out
            //
            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

        }

    }

    if (ERROR_SUCCESS == WinError) {

        WCHAR *Temp;

        ASSERT(*DomainDn);
        ASSERT(*ConfigDn);

        Temp = *DomainDn;
        *DomainDn = (WCHAR*)RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen(Temp)+1)*sizeof(WCHAR) );
        if ( *DomainDn ) {
            wcscpy( *DomainDn, Temp );
        } else {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }

        Temp = *ConfigDn;
        *ConfigDn = (WCHAR*)RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen(Temp)+1)*sizeof(WCHAR) );
        if ( *ConfigDn ) {
            wcscpy( *ConfigDn, Temp );
        } else {
            RtlFreeHeap( RtlProcessHeap(), 0, *DomainDn );
            *DomainDn = NULL;
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( SearchResult ) {

        ldap_msgfree( SearchResult );
        
    }

    return WinError;
}

DWORD
NtdspGetDcListForSite(
    IN LDAP*            LdapHandle,
    IN WCHAR*           SiteDn,
    IN WCHAR*           RootDomainName,
    IN WCHAR*           DomainDn,
    OUT WCHAR***        DcList,
    OUT PULONG          DcCount
    )
/*++

Routine Description:

    This routine returns a list of dc's in the form of a dns address for the
    specified site.

    Note that we use the guid of the ntds-dsa object postfixed to the domiain's
    dns name to determine the dc's address.

    The array of strings (DcList) returned by this routine must be freed by
    the caller using RtlFreeHeap() using the process heap.


Parameters:

    LdapHandle    : a valid handle to an ldap session

    SiteDn        : a null terminated string to the site dn

    RootDomainName    : a null terminated string of the domain's dns name.

    DomainDn      : a null terminated string to the domain dn

    DcList        : a array of strings allocated by this routine

    DcCount       : the count of elements in DcList

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    DWORD  RpcStatus;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;
    ULONG        Length;
    PLDAP_BERVAL *BerValues;

    WCHAR  *AttrArray[2];

    WCHAR  *ObjectGuid          = L"objectGUID";
    WCHAR  *ObjectClassFilter   = L"(&(objectClass=nTDSDSA)";
    WCHAR  *HasMasterNcFilter   = L"(hasmasterncs=";
    WCHAR  *SitesString         = L"CN=Sites,";
    WCHAR  *CompleteFilter      = NULL;

    WCHAR  *GuidString = NULL, *DcAddressString = NULL;
    ULONG  RootDomainNameLength;

    ULONG   LocalCount = 0;
    WCHAR** LocalList = NULL;

    ULONG   Index;

    //
    // These must be present
    //

    if (!LdapHandle ||
        !DomainDn   ||
        !SiteDn     ||
        !RootDomainName ||
        !DcCount    ||
        !DcList) {

        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // These are referenced more than once, so save in a stack variable
    //
    RootDomainNameLength = wcslen(RootDomainName);

    //
    // Construct the complete filter
    //
    Length = wcslen(ObjectClassFilter) +
             wcslen(HasMasterNcFilter) +
             wcslen(DomainDn)          +
             wcslen(L"))")             +
             1;

    CompleteFilter = RtlAllocateHeap(RtlProcessHeap(), 0, Length*sizeof(WCHAR));
    if (!CompleteFilter) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(CompleteFilter, Length*sizeof(WCHAR));

    wcscpy(CompleteFilter, ObjectClassFilter);
    wcscat(CompleteFilter, HasMasterNcFilter);
    wcscat(CompleteFilter, DomainDn);
    wcscat(CompleteFilter, L"))");

    //
    // Construct the attr array
    //
    AttrArray[0] = ObjectGuid;
    AttrArray[1] = NULL;  // this is the sentinel

    LdapError = ldap_search_sW(LdapHandle,
                               SiteDn,
                               LDAP_SCOPE_SUBTREE,
                               CompleteFilter,
                               AttrArray,
                               FALSE,
                               &SearchResult);

    WinError = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS == WinError) {

        LocalCount = ldap_count_entries(LdapHandle, SearchResult);

        if (LocalCount > 0 ) {

            LocalList = RtlAllocateHeap(RtlProcessHeap(), 0, LocalCount*sizeof(WCHAR*));
            if (!LocalList) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;

            }
            RtlZeroMemory(LocalList, LocalCount*sizeof(WCHAR*));

            LocalCount = 0;

        }

    }

    if (ERROR_SUCCESS == WinError ) {

        Entry = ldap_first_entry(LdapHandle, SearchResult);

        while (Entry) {

            Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

            if (Attr) {

                if (!_wcsicmp(Attr, ObjectGuid)) {

                    BerValues = ldap_get_values_lenW(LdapHandle, Entry, Attr);

                    if (BerValues && BerValues[0]) {

                        RpcStatus = UuidToStringW( (UUID*)BerValues[0]->bv_val, &GuidString );
                        if ( RPC_S_OK == RpcStatus )
                        {
                            Length = wcslen(GuidString) + RootDomainNameLength + 2;

                            DcAddressString = RtlAllocateHeap(RtlProcessHeap(),
                                                     0,
                                                    (Length) * sizeof(WCHAR));
                            if (DcAddressString) {

                                RtlZeroMemory(DcAddressString, Length*sizeof(WCHAR));

                                wcscpy(DcAddressString, GuidString);
                                wcscat(DcAddressString, L".");
                                wcscat(DcAddressString, RootDomainName);

                                LocalList[LocalCount] = DcAddressString;
                                LocalCount++;
                                DcAddressString = NULL;

                            } else {

                                WinError = ERROR_NOT_ENOUGH_MEMORY;
                                goto Cleanup;

                            }

                            RpcStringFree( &GuidString );
                        }
                    }
                }
            }

            Entry = ldap_next_entry(LdapHandle, Entry);

        }
    }

    if (LocalCount == 0 && LocalList) {
        //
        // If we didn't find the attributes we need on any of the dc's,
        // free the list.
        //
        RtlFreeHeap(RtlProcessHeap(), 0, LocalList);
        LocalList = NULL;
    }


    //
    // That's it fall through to clean up
    //

Cleanup:

    //
    // Set the out parameters on success
    //
    if (ERROR_SUCCESS == WinError) {

        *DcCount = LocalCount;
        *DcList  = LocalList;

    } else {

        if (LocalList) {

            for (Index = 0; Index < LocalCount; Index++) {
                if (LocalList[Index]) {
                    RtlFreeHeap(RtlProcessHeap(), 0, LocalList[Index]);
                }

            }
            RtlFreeHeap(RtlProcessHeap(), 0, LocalList);
        }
    }

    if (DcAddressString) {
        RtlFreeHeap(RtlProcessHeap(), 0, DcAddressString);
    }

    if (CompleteFilter) {
        RtlFreeHeap(RtlProcessHeap(), 0, CompleteFilter);
    }

    if (SearchResult) {
        ldap_msgfree(SearchResult);
    }

    return WinError;
}

DWORD
NtdspGetUserDn(
    IN LDAP*    LdapHandle,
    IN WCHAR*   DomainDn,
    IN WCHAR*   AccountName,
    OUT WCHAR** AccountNameDn
    )
/*++

Routine Description:

    This routine tries to find the dn of the given user name.


Parameters:

    LdapHandle    : a valid handle to an ldap session

    DomainDn      : a null terminated string of the domain dn

    AccountName   : a null terminated string the account name

    AccountDn     : a pointer to a string to be filled in with the account dn
                    -- needs to be freed from process heap

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{
    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    ULONG        ReferralChasingOff = 0;
    ULONG        SaveReferralOption;
    BOOLEAN      fResetOption = FALSE;

    WCHAR  *AttrArray[3];

    WCHAR  *DistinguishedName    = L"distinguishedName";
    WCHAR  *UserAccountControl   = L"userAccountControl";
    WCHAR  *SamAccountNameFilter = L"(sAMAccountName=";
    WCHAR  *ObjectClassFilter    = L"(&(|(objectClass=user)(objectClass=computer))";
    WCHAR  *CompleteFilter;

    ULONG  UserAccountControlField;

    ULONG  Length;

    BOOLEAN fIsMachineAccountObject = FALSE;

    //
    // Parameter checks
    //
    if (!LdapHandle  ||
        !DomainDn    ||
        !AccountName ||
        !AccountNameDn) {
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set the out parameter to null
    //
    *AccountNameDn = 0;

    //
    // Construct the filter
    //
    Length = wcslen(ObjectClassFilter)     +
             wcslen(SamAccountNameFilter)  +
             wcslen(AccountName)           +
             wcslen(L"))")                 +
             1;

    CompleteFilter = RtlAllocateHeap(RtlProcessHeap(), 0, Length*sizeof(WCHAR));
    if (!CompleteFilter) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(CompleteFilter, Length*sizeof(WCHAR));

    wcscpy(CompleteFilter, ObjectClassFilter);
    wcscat(CompleteFilter, SamAccountNameFilter);
    wcscat(CompleteFilter, AccountName);
    wcscat(CompleteFilter, L"))");

    //
    // Don't chase any referrals; this function simply sets a field in
    // the ldap structure so can only fail with bad parameters.
    //
    LdapError = ldap_get_option(LdapHandle,
                                LDAP_OPT_REFERRALS,
                                &SaveReferralOption);
    ASSERT(LdapError == LDAP_SUCCESS);

    LdapError = ldap_set_option(LdapHandle,
                                LDAP_OPT_REFERRALS,
                                &ReferralChasingOff);
    ASSERT(LdapError == LDAP_SUCCESS);
    fResetOption = TRUE;


    //
    // Now get the dn of the machine account
    //
    AttrArray[0] = DistinguishedName;
    AttrArray[1] = UserAccountControl;
    AttrArray[2] = NULL; // this is the sentinel

    //
    // Search for the account
    //
    LdapError = ldap_search_s(LdapHandle,
                              DomainDn,
                              LDAP_SCOPE_SUBTREE,
                              CompleteFilter,
                              AttrArray,
                              FALSE,
                              &SearchResult);

    // Referral's may still contain found objects
    if ( LDAP_REFERRAL == LdapError ) {

        LdapError = LDAP_SUCCESS;
    }

    WinError = LdapMapErrorToWin32(LdapError);

    if (WinError == ERROR_SUCCESS) {

        Entry = ldap_first_entry(LdapHandle, SearchResult);

        while ( Entry ) {

            Attr = ldap_first_attribute(LdapHandle, Entry, &BerElement);

            while ( Attr ) {

                Values = ldap_get_values(LdapHandle, Entry, Attr);

                ASSERT( ldap_count_values( Values )  == 1 );

                if (Values && Values[0]) {

                    if (!wcscmp(Attr, DistinguishedName)) {

                        (*AccountNameDn) = Values[0];

                    }
                    else if ( !wcscmp(Attr, UserAccountControl) ) {

                        UserAccountControlField = (USHORT) _wtoi(Values[0]);

                        if ( (UserAccountControlField & UF_SERVER_TRUST_ACCOUNT)
                          || (UserAccountControlField & UF_WORKSTATION_TRUST_ACCOUNT) )
                        {
                            fIsMachineAccountObject = TRUE;
                        }

                    }
                    else {
                        //
                        // This is an unexpected result! This is not harmful
                        // but should be caught in the dev cycle
                        //
                        ASSERT(FALSE);
                    }

                }

                Attr = ldap_next_attribute( LdapHandle, Entry, BerElement );
            }


            if ( (*AccountNameDn) && fIsMachineAccountObject ) {

                //
                // Found it
                //
                break;

            }
            else
            {
                *AccountNameDn = NULL;
                Entry = ldap_next_entry( LdapHandle, Entry );
            }

        }

    }

    if ( !(*AccountNameDn) )
    {
        //
        // Couldn't find it
        //
        WinError = ERROR_NO_TRUST_SAM_ACCOUNT;

    } else {

        //
        // Allocate for our caller
        //
        WCHAR *Temp;

        Temp = *AccountNameDn;
        *AccountNameDn = (WCHAR*)RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen(Temp)+1)*sizeof(WCHAR) );
        if ( *AccountNameDn ) {
            wcscpy( *AccountNameDn, Temp );
        } else {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

Cleanup:

    if ( SearchResult ) {
        ldap_msgfree( SearchResult );
    }

    if ( CompleteFilter ) {
        RtlFreeHeap(RtlProcessHeap(), 0, CompleteFilter);
    }

    if ( fResetOption ) {

        LdapError = ldap_set_option(LdapHandle,
                                    LDAP_OPT_REFERRALS,
                                    &SaveReferralOption);
        ASSERT(LdapError == LDAP_SUCCESS);
    }

    return WinError;

}

DWORD
NtdspSetMachineType(
    IN LDAP*    LdapHandle,
    IN WCHAR*   AccountNameDn,
    IN ULONG    ServerType
    )
/*++

Routine Description:

    This routine will set the machine account type on the AccountNameDn

Parameters:

    LdapHandle    : a valid handle to an ldap session

    AccountNameDn : a null terminated string of the account dn

    ServerType    : a value from lmaccess.h

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{
    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR    Buffer[11];  // enough to hold a string representing a 32 bit number
    WCHAR   *AccountControlArray[2];
    LDAPMod  ModifyArgs;
    PLDAPMod ModifyArgsArray[3];

    WCHAR  *AttrArray[3];

    WCHAR  *ObjectClassFilter          = L"(objectclass=*)";  // we need a simple filter only
    WCHAR  *SamAccountControlString    = L"userAccountControl";

    ULONG  MessageNumber;

    DWORD  AccountControlField;
    BOOL   AccountControlFieldExists = FALSE;

    //
    // Sanity check the parameters
    //
    if (!LdapHandle ||
        !AccountNameDn) {
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We want to make absolutely sure we don't put a strange value
    // on the machine account control field.
    //
    if (ServerType != UF_INTERDOMAIN_TRUST_ACCOUNT
     && ServerType != UF_WORKSTATION_TRUST_ACCOUNT
     && ServerType != UF_SERVER_TRUST_ACCOUNT    ) {
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now get the account control field of the machine
    // account
    //
    AttrArray[0] = SamAccountControlString;
    AttrArray[1] = NULL; // this is the sentinel

    LdapError = ldap_search_sW(LdapHandle,
                               AccountNameDn,
                               LDAP_SCOPE_BASE,
                               ObjectClassFilter,
                               AttrArray,
                               FALSE,
                               &SearchResult);

    WinError = LdapMapErrorToWin32(LdapError);

    if (WinError == ERROR_SUCCESS) {

        Entry = ldap_first_entry(LdapHandle, SearchResult);

        if (Entry) {

            Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

            if (Attr) {

                Values = ldap_get_valuesW(LdapHandle, Entry, Attr);

                if (Values && Values[0]) {

                    if (!wcscmp(Attr, SamAccountControlString)) {

                        AccountControlField = _wtol(Values[0]);
                        AccountControlFieldExists = TRUE;

                    }
                }
            }
        }

        if (!AccountControlFieldExists) {
            //
            // Could not retrieve the information we needed
            //
            WinError = ERROR_NO_SUCH_USER;
        }

    }


    if (WinError == ERROR_SUCCESS) {

        //
        // Set the new value
        //
        BOOLEAN fRetriedAlready = FALSE;

        AccountControlField &= ~UF_MACHINE_ACCOUNT_MASK;
        AccountControlField |=  ServerType;

        if ( ServerType == UF_SERVER_TRUST_ACCOUNT ) {
            AccountControlField |= UF_TRUSTED_FOR_DELEGATION;
        } else {
            AccountControlField &= ~UF_TRUSTED_FOR_DELEGATION;
        }

        RtlZeroMemory(Buffer, sizeof(Buffer));
        _ltow( AccountControlField, Buffer, 10 );

        AccountControlArray[0] = &Buffer[0];
        AccountControlArray[1] = NULL;    // this is the sentinel

        ModifyArgs.mod_op = LDAP_MOD_REPLACE;
        ModifyArgs.mod_type = SamAccountControlString;
        ModifyArgs.mod_vals.modv_strvals = AccountControlArray;

        ModifyArgsArray[0] = &ModifyArgs;
        ModifyArgsArray[1] = NULL; // this is the sentinel

BusyTryAgain:

        LdapError = ldap_modify_ext_s(LdapHandle,
                                       AccountNameDn,
                                       ModifyArgsArray,
                                       NULL,
                                       NULL);

        if ( (LDAP_BUSY == LdapError) && !fRetriedAlready )
        {
            // No one has a definitive story about where ds retries should
            // be: server, client, client of client ... So during install
            // we try again on busy
            fRetriedAlready = TRUE;
            goto BusyTryAgain;
        }


        WinError = LdapMapErrorToWin32(LdapError);

    }

    if ( SearchResult ) {

        ldap_msgfree( SearchResult );

    }

    return WinError;
}

DWORD 
NtdspSetContainer (
    IN LDAP*  LdapHandle,
    IN WCHAR* AccountName,
    IN WCHAR* AccountNameDn,
    IN ULONG  ServerType,
    IN WCHAR* DomainDn,
    IN OUT WCHAR** OldAccountDn
    )
/*++

Routine Description:

    This routine will move AccountNameDn to the "Domain Controllers"
    container

Parameters:

    LdapHandle    : a valid handle to an ldap session

    AccountName   : a null terminated string of the account
    
    AccountNameDn : a null terminated string of the account dn
    
    ServerType    : the server type of the account
    
    DomainDn      : a null terminated string of the domain dn
    
    OldAccountDn  : if fill if the account is moved

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.
    
--*/
{
    DWORD  WinError = ERROR_SUCCESS;

    ULONG  LdapError = LDAP_SUCCESS;

    WCHAR *DistinguishedNameString = L"distinguishedName";
    WCHAR *NewDnFormat;

    WCHAR *DCFormat = L"CN=%ls,OU=Domain Controllers,%ls";
    WCHAR *ComputersFormat = L"CN=%ls,CN=Computers,%ls";

    WCHAR *NewDn = NULL;

    WCHAR *CurrentRdn;
    WCHAR *OriginalRdn;

    DSNAME *TempDsName;
    ULONG   Size, Retry, DirError;

    ATTRTYP AttrType;

    BOOLEAN fAccountMoved = FALSE;


    //
    // Parameter checks
    //
    ASSERT( LdapHandle );
    ASSERT( AccountName );
    ASSERT( AccountNameDn );
    ASSERT( DomainDn );

    // Init the out parameter
    if ( OldAccountDn )
    {
        ASSERT( NULL == *OldAccountDn );
        *OldAccountDn = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(), 
                                 0, 
                                 (wcslen(AccountNameDn)+1)*sizeof(WCHAR) );
        
        if ( *OldAccountDn )
        {
            wcscpy( *OldAccountDn, AccountNameDn );
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( UF_SERVER_TRUST_ACCOUNT == ServerType )
    {
        NewDnFormat = DCFormat;
    }
    else if ( UF_WORKSTATION_TRUST_ACCOUNT == ServerType )
    {
        NewDnFormat = ComputersFormat;
    }
#if DBG
    else
    {
        ASSERT(FALSE && "Invalid Server Type\n");
    }
#endif  // DBG

    // Preemptive check that the ou exists
    if ( !NtdspDoesDestinationExist( LdapHandle, ServerType, DomainDn ) )
    {
        // the destination OU doesn't exist - forget it
        WinError = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Get the RDN of the object
    //
    Size = (ULONG)DSNameSizeFromLen( wcslen( AccountNameDn ) );
    TempDsName = (DSNAME*) alloca( Size );

    RtlZeroMemory( TempDsName, Size );
    wcscpy( TempDsName->StringName, AccountNameDn );
    TempDsName->structLen = Size;
    TempDsName->NameLen = wcslen( AccountNameDn );

    OriginalRdn = (WCHAR*)alloca(Size);  //over alloc but oh well
    RtlZeroMemory( OriginalRdn, Size );

    DirError = GetRDNInfoExternal(
                           TempDsName,
                           OriginalRdn,
                           &Size,
                           &AttrType );
    ASSERT( 0 == DirError );

    // + 10 for NULL, and extra characters in a case of rdn conflicts
    Size = (wcslen(OriginalRdn)+10)*sizeof(WCHAR); 

    CurrentRdn = (WCHAR*) alloca( Size );

    wcscpy( CurrentRdn, OriginalRdn );

    // setup the new dn
    Size =  (wcslen( NewDnFormat ) * sizeof( WCHAR ))
          + (wcslen( DomainDn ) * sizeof( WCHAR ))
          + ( Size );  // size of Rdn
    NewDn = (WCHAR*) alloca( Size );
     

    Retry = 0;
    do 
    {
        if ( Retry > 100 )
        {
            // we try 100 different rdn's.  bail.
            break;
        }

        //
        // Create the new dn
        //
        wsprintf( NewDn, 
                  NewDnFormat, 
                  CurrentRdn,
                  DomainDn );

        if ( !_wcsicmp( NewDn, AccountNameDn ) )
        {
            // we are already there
            LdapError = LDAP_SUCCESS;
            break;
        }

        LdapError = ldap_modrdn2_sW(LdapHandle,
                                    AccountNameDn,
                                    NewDn,
                                    TRUE );  // fDelete old rdn

        Retry++; 

        if ( LDAP_ALREADY_EXISTS == LdapError )
        {
            //
            // Choose a new rdn
            //
            WCHAR NumberString[32]; // just to hold number

            _itow( Retry, NumberString, 10 );

            wcscpy( CurrentRdn, OriginalRdn );
            wcscat( CurrentRdn, L"~" );
            wcscat( CurrentRdn, NumberString );
        }

        if ( LDAP_SUCCESS == LdapError )
        {
            fAccountMoved = TRUE;
        }

        // Occasionally, the ds can be busy; retry if so

    } while ( (LDAP_ALREADY_EXISTS == LdapError) || (LDAP_BUSY == LdapError) );


    WinError = LdapMapErrorToWin32(LdapError);

Cleanup:

    if (   (WinError != ERROR_SUCCESS)
        || !fAccountMoved  )
    {
        if ( OldAccountDn )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, *OldAccountDn );
            *OldAccountDn = NULL;
        }
    }

    return WinError;

}

BOOLEAN
NtdspDoesDestinationExist(
    IN LDAP*  LdapHandle,
    IN ULONG  ServerType,
    IN WCHAR* DomainDn
    )
/*++

Routine Description:

    This routine determines if the ou "Domain Controllers" exists on
    the target server

Parameters:

    LdapHandle    : a valid handle to an ldap session
    
    ServerType    : dc or server

    DomainDn      : a null terminated string of the domain dn

Return Values:

    TRUE if  the ou exists; FALSE otherwise
    
--*/
{
    BOOLEAN fExist = FALSE;

    ULONG   LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;

    WCHAR  *AttrArray[2];

    WCHAR  *ObjectClassFilter       = L"objectClass=*";
    WCHAR  *DistinguishedNameString = L"distinguishedName";

    WCHAR  *DCOUString       = L"OU=Domain Controllers,";
    WCHAR  *ComputersString  = L"CN=Computers,";
    WCHAR  *DestString;
    WCHAR  *BaseDn = NULL;
    ULONG  Size;

    //
    // These must be present
    //
    ASSERT( LdapHandle );
    ASSERT( DomainDn );

    if ( UF_SERVER_TRUST_ACCOUNT == ServerType )
    {
        DestString = DCOUString;
    }
    else if ( UF_WORKSTATION_TRUST_ACCOUNT == ServerType )
    {
        DestString = ComputersString;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Construct the base dn for the first search
    //
    Size = (wcslen(DomainDn) + wcslen(DestString) + 1) * sizeof( WCHAR );

    BaseDn = (WCHAR*) alloca( Size );
    RtlZeroMemory( BaseDn, Size );

    wcscpy(BaseDn, DestString);
    wcscat(BaseDn, DomainDn);

    //
    // Construct the attr array which is also constant for all searches
    //
    AttrArray[0] = DistinguishedNameString;
    AttrArray[1] = NULL;  // this is the sentinel

    //
    // Do the search
    //
    LdapError = ldap_search_s(LdapHandle,
                              BaseDn,
                              LDAP_SCOPE_BASE,
                              ObjectClassFilter,
                              AttrArray,
                              FALSE,
                              &SearchResult);

    if ( LDAP_SUCCESS == LdapError )
    {
        if ( 1 == ldap_count_entries( LdapHandle, SearchResult ) )
        {
            fExist = TRUE;
        }

    }

    if ( SearchResult ) {
        ldap_msgfree( SearchResult );
    }

    return fExist;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\setuputl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setuputl.h

Abstract:

    Contains function headers for utilities used in
    ntdsetup.dll

Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/

//
// Useful  defines
//
#define FLAG_ON(x, y)  ((y) == ((x)&(y)))

#define ARRAY_COUNT(x) (sizeof(x)/sizeof((x)[0]))

//
// Function prototypes
//

//
// Some basic memory management routines
//
VOID*
NtdspAlloc( 
    IN SIZE_T Size
    );

VOID*
NtdspReAlloc(
    VOID *p,
    SIZE_T Size
    );

VOID
NtdspFree(
    IN VOID*
    );



DWORD
GetDomainName(WCHAR** ppDomainName);

DWORD
GetDefaultDnsName(WCHAR* pDnsDomainName,
                  PULONG pLength);

DWORD
NtdspDNStoRFC1779Name(
    IN OUT WCHAR *rfcDomain,
    IN OUT ULONG *rfcDomainLength,
    IN WCHAR *dnsDomain
    );

DWORD
ShutdownDsInstall(VOID);

typedef struct {

    // This is "discovered" by querying the lsa or manipulating the dns
    // domain name. Note that this will be the rdn of the xref object
    // This is not necessary for a replica install
    LPWSTR NetbiosName;

    // This is discovered via dsgetdc
    LPWSTR SiteName;

    // These are discovered via an ldap search
    LPWSTR ServerDN;
    LPWSTR SchemaDN;
    LPWSTR ConfigurationDN;
    LPWSTR DomainDN;
    LPWSTR RootDomainDN;  // root domain of the enterprise

    LPWSTR ParentDomainDN;  // name of parent domain if any
    LPWSTR TrustedCrossRef;  // the cross ref we trust for domain install


    // The helper server's guid
    GUID  ServerGuid;

    // The dn of RID FSMO - set only on replica install
    WCHAR *RidFsmoDn;

    // The dns name of the RID FSMO - set only on replica install
    WCHAR *RidFsmoDnsName;

    // The dn of Domain Naming FSMO - set only on new domain install
    WCHAR *DomainNamingFsmoDn;

    // The dns name of the Domain Naming FSMO - set only on new domain install
    WCHAR *DomainNamingFsmoDnsName;

    PSID  NewDomainSid;
    GUID  NewDomainGuid;

    // The dn of the server object to be created on the remote server
    LPWSTR LocalServerDn;

    // The dn of the machine account of the current machine
    LPWSTR LocalMachineAccount;

    // This flag is set if we determine that we need to create a domain
    BOOL fNeedToCreateDomain;

    // What we need to undo
    ULONG  UndoFlags;

    // The sid of the root domain (of the enterprise)
    PSID   RootDomainSid;

    // The dns name of the root domain (of the enterprise)
    LPWSTR RootDomainDnsName;

    // The tombstone Lifetime of the domain
    DWORD TombstoneLifeTime;

    // The Replication Epoch of the domain
    DWORD ReplicationEpoch;


} NTDS_CONFIG_INFO, *PNTDS_CONFIG_INFO;

VOID
NtdspReleaseConfigInfo(
    IN PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspQueryConfigInfo(
    IN LDAP *hLdap,
    OUT PNTDS_CONFIG_INFO DiscoveredInfo
);


DWORD ConstructInstallParam(IN  NTDS_INSTALL_INFO *pInfo,
                            IN  PNTDS_CONFIG_INFO  DiscoveredInfo,
                            OUT ULONG *argc,
                            OUT CHAR  ***argv);

DWORD
NtdspValidateInstallParameters(
    IN PNTDS_INSTALL_INFO UserInstallInfo
    );

DWORD
NtdspFindSite(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    OUT PNTDS_CONFIG_INFO     DiscoveredInfo
    );

DWORD
NtdspVerifyDsEnvironment(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    OUT PNTDS_CONFIG_INFO     DiscoveredInfo
    );

DWORD
NtdspDsInitialize(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO     DiscoveredInfo
    );

DWORD
NtdspSetReplicationCredentials(
    IN PNTDS_INSTALL_INFO UserInstallInfo
    );

NTSTATUS
NtdspRegistryDelnode(
    IN WCHAR*  KeyPath
    );

DWORD
NtdspDemote(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE                   ClientToken,
    IN LPWSTR                   AdminPassword, OPTIONAL
    IN DWORD                    Flags,
    IN LPWSTR                   ServerName
    );

//
// This function will set the machine account type of the
// computer object of the local server via ldap.
//
DWORD
NtdspSetReplicaMachineAccount(
    IN SEC_WINNT_AUTH_IDENTITY   *Credentials,
    IN LPWSTR                     ServerName,
    IN ULONG                      ServerType
    );

NTSTATUS
NtdspCreateSid(
    OUT PSID *NewSid
    );

DWORD
NtdspCreateLocalAccountDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo,
    OUT LPWSTR                     *NewAdminPassword
    );

DWORD
NtdspClearDirectory(
    WCHAR *Path
    );

DWORD
NtdspImpersonation(
    IN HANDLE NewThreadToken,
    IN OUT PHANDLE OldThreadToken
    );

WORD
NtdspGetProcessorArchitecture(
    VOID
    );

#define IS_MACHINE_INTEL  \
     (PROCESSOR_ARCHITECTURE_INTEL == NtdspGetProcessorArchitecture())

//
// Lamentably, these are system hardcoded
//
#define NT_PRODUCT_LANMAN_NT  L"LanmanNT"
#define NT_PRODUCT_SERVER_NT  L"ServerNT"
#define NT_PRODUCT_WIN_NT     L"WinNT"

DWORD
NtdspSetProductType(
    NT_PRODUCT_TYPE ProductType
    );

DWORD
NtdspDsInitializeUndo(
    VOID
    );

BOOL
NtdspTrimDn(
    IN WCHAR* Dst,  // must be preallocated
    IN WCHAR* Src,
    IN ULONG  NumberToWhack
    );

DWORD
NtdspRemoveServer(
    IN OUT HANDLE  *DsHandle, OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE ClientToken,
    IN PWSTR TargetServer,
    IN PWSTR DsaDn,
    IN BOOL  fDsaDn // FALSE -> DsaDn is really the serverDn
    );

DWORD
NtdspRemoveDomain(
    IN OUT HANDLE  *DsHandle, OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE ClientToken,
    IN PWSTR TargetServer,
    IN PWSTR DomainDn
    );

DWORD
NtdspLdapDelnode(
    IN LDAP *hLdap,
    IN WCHAR *ObjectDn
    );

DWORD
NtdspGetDomainFSMOInfo(
    IN LDAP *hLdap,
    IN OUT PNTDS_CONFIG_INFO ConfigInfo,
    IN BOOL *FSMOMissing
    );


ULONG 
LDAPAPI 
impersonate_ldap_bind_sW(
    IN HANDLE ClientToken, OPTIONAL
    IN LDAP *ld, 
    IN PWCHAR dn, 
    IN PWCHAR cred, 
    IN ULONG method
    );

DWORD
WINAPI
ImpersonateDsBindWithCredW(
    HANDLE          ClientToken,
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\sync.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sync.h

Abstract:

    Contains function headers to cause one machine to sync with another

Author:

    ColinBr  14-Aug-1998

Environment:

    User Mode - Win32

Revision History:


--*/

DWORD
NtdspBringRidManagerUpToDate(
    IN PNTDS_INSTALL_INFO UserInstallInfo,
    IN PNTDS_CONFIG_INFO  DiscoveredInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\status.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    status.c

Abstract:

    Routines and definitions for canelling, status messages, and error messages          
    
Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/


//
// Routine to perform the cancel operation
//
DWORD
NtdspCancelOperation(
    VOID
    );

//
// Routines to manage the cancel state
//
VOID
NtdspInitCancelState(
    VOID
    );

VOID
NtdspUnInitCancelState(
    VOID
    );

//
// Routines to test the if cancellation has occurred
//
BOOLEAN
TEST_CANCELLATION(
    VOID
    );

VOID 
CLEAR_CANCELLATION(
    VOID
    );


//
// Routines to manage whether the ds should be shutdown
//
VOID
SET_SHUTDOWN_DS(
    VOID
    );

VOID
CLEAR_SHUTDOWN_DS(
    VOID
    );


//
// Routines to set the status
//
VOID
NtdspSetStatusMessage (
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    );

#define NTDSP_SET_STATUS_MESSAGE0( msgid ) \
    NtdspSetStatusMessage( (msgid), NULL, NULL, NULL, NULL )
    
#define NTDSP_SET_STATUS_MESSAGE1( msgid, a ) \
    NtdspSetStatusMessage( (msgid), (a), NULL, NULL, NULL )

#define NTDSP_SET_STATUS_MESSAGE2( msgid, a, b ) \
    NtdspSetStatusMessage( (msgid), (a), (b), NULL, NULL )

#define NTDSP_SET_STATUS_MESSAGE3( msgid, a, b, c ) \
    NtdspSetStatusMessage( (msgid), (a), (b), (c), NULL )

#define NTDSP_SET_STATUS_MESSAGE4( msgid, a , b, c, d ) \
    NtdspSetStatusMessage( (msgid), (a), (b), (c), (d) )

//
// Routines to set the error message
//
VOID
NtdspSetErrorMessage (
    IN  DWORD  WinError,
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    );

#define NTDSP_SET_ERROR_MESSAGE0( err, msgid ) \
    NtdspSetErrorMessage( (err), (msgid), NULL, NULL, NULL, NULL )
    
#define NTDSP_SET_ERROR_MESSAGE1( err, msgid, a ) \
    NtdspSetErrorMessage( (err), (msgid), (a), NULL, NULL, NULL )

#define NTDSP_SET_ERROR_MESSAGE2( err, msgid, a, b ) \
    NtdspSetErrorMessage( (err), (msgid), (a), (b), NULL, NULL )

#define NTDSP_SET_ERROR_MESSAGE3( err, msgid, a, b, c ) \
    NtdspSetErrorMessage( (err), (msgid), (a), (b), (c), NULL )

#define NTDSP_SET_ERROR_MESSAGE4( err, msgid, a , b, c, d ) \
    NtdspSetErrorMessage( (err), (msgid), (a), (b), (c), (d) )
    
//
// Routines to set the OperationResultFlags
//

VOID
NtdspSetIFMDatabaseMoved();

VOID
NtdspSetGCRequestCannotBeServiced();

VOID
NtdspSetNonFatalErrorOccurred();

#define NTDSP_SET_IFM_RESTORED_DATABASE_FILES_MOVED() \
    NtdspSetIFMDatabaseMoved()
    
#define NTDSP_SET_IFM_GC_REQUEST_CANNOT_BE_SERVICED() \
    NtdspSetGCRequestCannotBeServiced()   

#define NTDSP_SET_NON_FATAL_ERROR_OCCURRED() \
    NtdspSetNonFatalErrorOccurred()   

DWORD
NtdspSetErrorString(
    IN PWSTR Message,
    IN DWORD WinError
    );

DWORD 
NtdspErrorMessageSet(
    VOID
    );

//
// This routine sets the global variables for the error and status callback
// routines the ds/sam install procedures should use
//
VOID
NtdspSetCallBackFunction(
    IN CALLBACK_STATUS_TYPE                 pfnStatusCallBack,
    IN CALLBACK_ERROR_TYPE                  pfnErrorCallBack,
    IN CALLBACK_OPERATION_RESULT_FLAGS_TYPE pfnOperationResultFlagsCallBack,
    IN HANDLE                               ClientToken
    );

//
// This function is a callback the ds makes to ntdsetup to indicate that
// it is safe to shutdown the ds (for the purposes of cancel), or not.
//
DWORD
NtdspIsDsCancelOk(
    IN BOOLEAN fShutdownOk
    );

extern ULONG  gErrorCodeSet;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\setuputl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setuputl.c

Abstract:

    Contains function definitions for utilities used in
    ntdsetup.dll

Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nt.h>
#include <winbase.h>
#include <tchar.h>
#include <ntsam.h>
#include <string.h>
#include <samrpc.h>

#include <crypt.h>
#include <ntlsa.h>
#include <winsock.h>  // for dnsapi.h
#include <dnsapi.h>
#include <loadperf.h>
#include <dsconfig.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <winldap.h>
#include <ntdsa.h>
#include <samisrv.h>
#include <rpcasync.h>
#include <drsuapi.h>
#include <dsaapi.h>
#include <attids.h>
#include <debug.h>
#include <mdcodes.h> // status message id's
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntldap.h>
#include <cryptdll.h>
#include <dsevent.h>
#include <fileno.h>
#include <shlwapi.h> //for PathIsRoot
#include <dsrolep.h>

#include "ntdsetup.h"
#include "setuputl.h"
#include "status.h"
#include "machacc.h"
#include "install.h"
#include "dsconfig.h"

#define DEBSUB "NTDSETUP:"
#define FILENO FILENO_NTDSETUP_NTDSETUP

//
// Global Data for this module
//

//
// These names are used in the schema.ini to construct the default configuration
// container. They are hardcoded here, to avoid a name conflict later on during
// processing of the schema.ini file at which point it become very difficult
// to tell what the real problem is.
//
WCHAR *gReserveredSiteNames[] =
{
    L"subnets",
    L"inter-site transports"
};

PWCHAR SidPrefix = L"<SID=";

DWORD
NtdspDoesServerObjectExistOnSourceinDifferentSite( 
    IN LDAP *hLdap,
    IN WCHAR *AccountNameDn,
    IN WCHAR *ServerDistinguishedName,
    OUT BOOLEAN *ObjectExists,
    OUT WCHAR   **NtdsSettingsObjectDN
    );

DWORD
NtdspDoesObjectExistOnSource(
    IN LDAP *hLdap,
    IN WCHAR *ObjectDN,
    OUT BOOLEAN *ObjectExists
    );

DWORD
NtdspCreateNewDCPrimaryDomainInfo(
    IN  LPWSTR FlatDomainName,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo
    );

DWORD
NtdspGetNewDomainGuid(
    OUT GUID *NewDomainGuid,
    OUT PSID *DomainSid OPTIONAL
    );

DWORD
NtdspCheckSchemaVersion(
    IN LDAP    *hLdap,
    IN WCHAR   *pSchemaDN,
    OUT BOOL   *fMisMatch
    );

DWORD
NtdspCheckBehaviorVersion( 
    IN LDAP * hLdap,
    IN DWORD flag,
    IN PNTDS_CONFIG_INFO DiscoveredInfo
    );

DWORD
NtdspDoesDomainExist(
    IN  LDAP              *hLdap,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo,
    IN  PWSTR              DomainDn,
    OUT BOOLEAN           *fDomainExists
    );

DWORD
NtdspDoesDomainExistEx(
    IN  LDAP              *hLdap,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo,
    IN  PWSTR              DomainDn,
    OUT BOOLEAN           *fDomainExists,
    OUT BOOLEAN           *fEnabled
    );

DWORD
NtdspGetRidFSMOInfo(
    IN LDAP *hLdap,
    IN OUT PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspGetSourceServerGuid(
    IN LDAP *hLdap,
    IN OUT PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspCreateServerObject(
    IN LDAP  *hLdap,
    IN LPWSTR RemoteServerName,
    IN PNTDS_CONFIG_INFO ConfigInfo,
    IN WCHAR *ServerDistinguishedName
    );

DWORD
NtdspUpdateServerReference(
    IN LDAP  *hLdap,
    IN PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspGetRootDomainSid(
    IN LDAP  *hLdap,
    IN PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspGetTrustedCrossRef(
    IN  LDAP              *hLdap,
    IN PNTDS_INSTALL_INFO UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    );

VOID
NtdspSidStringToBinary(
    WCHAR *SidString,
    PSID  *RootDomainSid
    );

DWORD
NtdspGetRootDomainConfigInfo(
    IN PNTDS_INSTALL_INFO UserInstallInfo,
    IN PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspAddDomainAdminAccessToServer(
    IN PNTDS_INSTALL_INFO UserInstallInfo,
    IN PNTDS_CONFIG_INFO ConfigInfo
    );

DWORD
NtdspAddAceToAcl(
    IN  PACL pOldAcl,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    IN  ULONG AceFlags,
    OUT PACL *ppNewAcl
    );

DWORD
NtdspAddAceToSd(
    IN  PSECURITY_DESCRIPTOR pOldSd,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    IN  ULONG AceFlags,
    OUT PSECURITY_DESCRIPTOR *ppNewSd
    );


BOOL
NtdspAceAlreadyExists( 
    PACL                 pDacl,
    PSID                 pSid,
    ULONG                AccessMask,
    ULONG                AceFlags
    );

DWORD
NtdspGetDwordAttFromDN(
    IN  LDAP  *hLdap,
    IN  WCHAR *wszDN,
    IN  WCHAR *wszAttribute,
    OUT BOOL  *fExists,
    OUT DWORD *dwValue
    );

DWORD
NtdspGetTombstoneLifeTime( 
    IN LDAP *hLdap,
    IN PNTDS_CONFIG_INFO  DiscoveredInfo
    );

DWORD
NtdspGetReplicationEpoch( 
    IN LDAP *hLdap,
    IN PNTDS_CONFIG_INFO DiscoveredInfo
    );

DWORD
NtdspCheckDomainDcLimit(
    IN  LDAP  *hLdap,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    );

DWORD
NtdspCopyDatabase(
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN LPWSTR RestorePath,
    IN LPWSTR SysvolPath
    );

BOOLEAN
IsValidDnsCharacter(
    WCHAR c)
/*++

Routine Description:

    This routine returns TRUE if c is a valid DNS character, as of
    April 10, 1997. There are apparently proposals to expand the
    character set - this function should be updated accordingly.

Parameters:

    c  : the character to check

Return Values:

    TRUE if c is a valid DNS character; FALSE otherwise

--*/
{
    if (  (c >= L'A' && c <= L'Z')
       || (c >= L'a' && c <= L'z')
       || (c >= L'0' && c <= L'9')
       || (c == L'-')              )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}

DWORD
GetDefaultDnsName(OUT WCHAR*  pDnsDomainName,
                  IN OUT PULONG  pLength)
/*++

Routine Description:

    This routine examines the local registry keys and tries to formulate
    a default DNS name for the directory service about to be installed.
    In general, it takes the DNS suffix of the machine's dns name and
    prepends the downlevel domain name.

Parameters:

    pDnsDomainName : a buffer to be filled with the dns name found.
                     Should be of length DNS_MAX_NAME_LENGTH
    pLength        : number of characters in pDnsDomainName


Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The service completed successfully.

--*/
{
    HKEY hkey;
    CHAR tmp[DNS_MAX_NAME_LENGTH], dnsDomain[DNS_MAX_NAME_LENGTH];
    ULONG len;
    ULONG err;
    DWORD type;
    DWORD WinError;
    WCHAR *DownlevelDomainName;
    ULONG i;

    if (!pLength)  {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory(dnsDomain, sizeof(dnsDomain));

    //
    // Get the downlevel domain name
    //
    WinError = GetDomainName(&DownlevelDomainName);
    if (WinError) {
        return WinError;
    }
    //
    // Translate non-DNS characters to "-"
    //
    len = wcslen(DownlevelDomainName);
    for (i = 0; i < len; i++) {
        if (!IsValidDnsCharacter(DownlevelDomainName[i])) {
            DownlevelDomainName[i] = L'-';
        }
    }

    wcstombs(dnsDomain, DownlevelDomainName, (wcslen(DownlevelDomainName)+1));
    RtlFreeHeap(RtlProcessHeap(), 0 , DownlevelDomainName);



    // The DNS name is DownlevelDomainName followed
    // by either Services\Tcpip\Parameters\Domain if it exists, or
    // Services\Tcpip\Parameters\DHCPDomain if it exists.  If neither
    // exists, use DownlevelDomainName by itself.
    //


    // Check the Tcpip keys.

    err = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                0,
                KEY_READ,
                &hkey);

    if ( ERROR_SUCCESS == err )
    {
        RtlZeroMemory(tmp, sizeof(tmp));
        len = sizeof(tmp);
        err = RegQueryValueExA(hkey, "Domain", NULL, &type, tmp, &len);

        if ( (ERROR_SUCCESS == err) && (0 != len) && (REG_SZ == type) &&
             !((1 == len) && ('\0' == tmp[0])) )
        {
            strcat(dnsDomain, ".");
            strcat(dnsDomain, tmp);
        }
        else
        {
            RtlZeroMemory(tmp, sizeof(tmp));
            len = sizeof(tmp);
            err = RegQueryValueExA(hkey, "DHCPDomain", NULL, &type, tmp, &len);

            if ( (ERROR_SUCCESS == err) && (0 != len) && (REG_SZ == type) &&
                 !((1 == len) && ('\0' == tmp[0])) )
            {
                strcat(dnsDomain, ".");
                strcat(dnsDomain, tmp);
            }
        }

        RegCloseKey(hkey);
    }

    len  = strlen(dnsDomain) + 1;
    if (len <= *pLength && pDnsDomainName) {

        mbstowcs(pDnsDomainName, dnsDomain, len);

        WinError = ERROR_SUCCESS;

    } else {
        WinError = ERROR_INSUFFICIENT_BUFFER;
    }
    *pLength = len;

    return WinError;
}

DWORD
GetDomainName(WCHAR** ppDomainName)
/*++

Routine Description:

    This routine queries the local lsa to determine what domain
    we are a part of. Note that ppDomainName is return with allocated
    memory - this memory must be released by the caller with
    RtlFreeHeap(RtlProcessHeap(), 0, ...);

Parameters:

    ppDomainName - a pointer to location that will be allocated in this
                   routine.

Return Values:

    A value from the winerror space.

    ERROR_SUCCESS is successful;

--*/
{
    NTSTATUS NtStatus;
    DWORD    WinError;

    OBJECT_ATTRIBUTES  PolicyObject;

    //
    // Resources to be cleaned up.
    //
    POLICY_PRIMARY_DOMAIN_INFO *DomainInfo = NULL;
    HANDLE                      hPolicyObject = INVALID_HANDLE_VALUE;

    //
    // Parameter check
    //
    ASSERT(ppDomainName);

    //
    // Stack clearing
    //
    RtlZeroMemory(&PolicyObject, sizeof(PolicyObject));


    NtStatus = LsaOpenPolicy(NULL,
                             &PolicyObject,
                             POLICY_VIEW_LOCAL_INFORMATION,
                             &hPolicyObject);
    if ( !NT_SUCCESS(NtStatus) ) {
        WinError = RtlNtStatusToDosError(NtStatus);
        goto CleanUp;
    }

    NtStatus = LsaQueryInformationPolicy(hPolicyObject,
                                         PolicyPrimaryDomainInformation,
                                         (VOID**) &DomainInfo);
    if ( !NT_SUCCESS(NtStatus) ) {
        WinError = RtlNtStatusToDosError(NtStatus);
        goto CleanUp;
    }

    //
    // Construct the domain name so it is NULL-terminated
    //
    *ppDomainName = RtlAllocateHeap(RtlProcessHeap(), 0,
                                    DomainInfo->Name.Length+sizeof(WCHAR));
    if ( !*ppDomainName ) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    RtlCopyMemory(*ppDomainName, DomainInfo->Name.Buffer, DomainInfo->Name.Length);
    (*ppDomainName)[DomainInfo->Name.Length/sizeof(WCHAR)] = L'\0';
    WinError = ERROR_SUCCESS;

CleanUp:

    if ( DomainInfo ) {
        LsaFreeMemory(DomainInfo);
    }

    if ( INVALID_HANDLE_VALUE != hPolicyObject ) {
        LsaClose(hPolicyObject);
    }

    if (ERROR_SUCCESS != WinError && *ppDomainName) {
        RtlFreeHeap(RtlProcessHeap(), 0, *ppDomainName);
        *ppDomainName = NULL;
    }

    return WinError;
}


DWORD
NtdspDNStoRFC1779Name(
    IN OUT WCHAR *rfcDomain,
    IN OUT ULONG *rfcDomainLength,
    IN WCHAR *dnsDomain
    )
/*++

Routine Description:

    This routine takes the DNS-style name of a domain controller and
    contructs the corresponding RFC1779 style name, using the
    domainComponent prefix.

    Furthermore, it make sure the x500 style name is properly quoted

Parameters:

    rfcDomain        - this is the destination string
    rfcDomainLength  - this is the length in wchars of rfcDomain
    dnsDomain        - NULL-terminated dns name.

Return Values:

    ERROR_SUCCESS if succesful;
    ERROR_INSUFFICIENT_BUFFER if there is not enough space in the dst string -
    rfcDomainLength will set to number of characters needed.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    WCHAR *NextToken;
    ULONG length = 1;   // include the null character
    WCHAR Buffer[DNS_MAX_NAME_LENGTH+1];
    WCHAR Buffer2[DNS_MAX_NAME_LENGTH+1];
    ULONG Size;

    if (!rfcDomainLength || !dnsDomain) {
        return ERROR_INVALID_PARAMETER;
    }

    if (wcslen(dnsDomain) > DNS_MAX_NAME_LENGTH) {
        return ERROR_INVALID_PARAMETER;
    }


    RtlCopyMemory(Buffer, dnsDomain, (wcslen(dnsDomain)+1)*sizeof(WCHAR));

    if (rfcDomain && *rfcDomainLength > 0) {
        RtlZeroMemory(rfcDomain, *rfcDomainLength*sizeof(WCHAR));
    }

    //
    // Start contructing the string
    //
    NextToken = wcstok(Buffer, L".");

    if ( NextToken )
    {
        //
        // Append the intial DC=
        //
        length += 3;
        if ( length <= *rfcDomainLength && rfcDomain )
        {
            wcscpy(rfcDomain, L"DC=");
        }
    }

    while ( NextToken )
    {
        // Worst case is label comprised of total " 's.
        WCHAR QuoteBuffer[DNS_MAX_LABEL_LENGTH*2+2];
        ULONG NumQuotedRDNChars = 0;

        RtlZeroMemory( QuoteBuffer, sizeof( QuoteBuffer ) );

        NumQuotedRDNChars += QuoteRDNValue( NextToken,
                                            wcslen( NextToken ),
                                            QuoteBuffer,
                                            sizeof(QuoteBuffer)/sizeof(WCHAR));
        if ( NumQuotedRDNChars > sizeof(QuoteBuffer)/sizeof(WCHAR) )
        {
            return ERROR_INVALID_DOMAINNAME;
        }
        length += NumQuotedRDNChars;

        if (length <= *rfcDomainLength && rfcDomain)
        {
            wcscat(rfcDomain, QuoteBuffer);
        }

        NextToken = wcstok(NULL, L".");

        if ( NextToken )
        {
            length += 4;

            if (length <= *rfcDomainLength && rfcDomain)
            {
                wcscat(rfcDomain, L",DC=");
            }
        }
    }


    if ( length > *rfcDomainLength )
    {
        WinError = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Return how much space was needed
    //
    *rfcDomainLength = length;

    return WinError;

}

DWORD
ShutdownDsInstall(
    VOID
    )
/*++

Routine Description:

    This routine sets a system named event to signal the SAM to shutdown
    down the directory service.  The idea here is that system clients other
    than SAM will need to put their information in the directory service so
    this function allows them to shutdown the ds down when they are done.

Parameters:

    None.

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The service completed successfully.

--*/
{

    NTSTATUS NtStatus;

    NtStatus = DsUninitialize( FALSE );  // do the whole shutdown

    if ( !NT_SUCCESS( NtStatus ) )
    {
         DPRINT1( 0, "DsUninitialize returned 0x%x\n", NtStatus );
    }

    return RtlNtStatusToDosError(NtStatus);

}

DWORD
NtdspQueryConfigInfo(
    IN LDAP *hLdap,
    OUT PNTDS_CONFIG_INFO pQueryInfo
)
/*++

Routine Description:


    This routine goes through LDAP to pick up the information in the
    NTDS_QUERY_INFO.  Amazingly enough, performing a simple bind and
    search at the root returns all the information we need to know
    to install a replica of a directory service locally.

Parameters:

    LdapHandle, a valid handle to the source server

    DiscoveredInfo - the structure to be filled by making LDAP calls.

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The service completed successfully.

--*/
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError;
    LDAPMessage  *SearchResult;
    ULONG        NumberOfEntries;
    ULONG        Size;


    // we want to query all the attributes of the rootDSA

    WCHAR       *attrs[] = {L"*", 
                            NULL
                            };

    LdapError = ldap_search_sW(hLdap,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"objectClass=*",
                               attrs, 
                               FALSE,
                               &SearchResult);

    if (LdapError) {


        return LdapMapErrorToWin32(LdapGetLastError());
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);

    if (NumberOfEntries > 0) {

        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        ULONG        NumberOfAttrs, NumberOfValues, i;

        //
        // Get entry
        //
        for (Entry = ldap_first_entry(hLdap, SearchResult), NumberOfEntries = 0;
                Entry != NULL;
                    Entry = ldap_next_entry(hLdap, Entry), NumberOfEntries++)
        {
            //
            // Get each attribute in the entry
            //
            for(Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement), NumberOfAttrs = 0;
                    Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement), NumberOfAttrs++)
            {
                LPWSTR * ppQueryInfoWStr = NULL;

                //
                // Get the value of the attribute
                //
                Values = ldap_get_valuesW(hLdap, Entry, Attr);
                if (!wcscmp(Attr, LDAP_OPATT_DS_SERVICE_NAME_W))
                {
                    ppQueryInfoWStr = &pQueryInfo->ServerDN;
                }
                else if (!wcscmp(Attr, LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W))
                {
                    ppQueryInfoWStr = &pQueryInfo->RootDomainDN;
                }
                else if (!wcscmp(Attr, LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W))
                {
                    ppQueryInfoWStr = &pQueryInfo->DomainDN;
                }
                else if (!wcscmp(Attr, LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W))
                {
                    ppQueryInfoWStr = &pQueryInfo->SchemaDN;
                }
                else if (!wcscmp(Attr, LDAP_OPATT_CONFIG_NAMING_CONTEXT_W))
                {
                    ppQueryInfoWStr = &pQueryInfo->ConfigurationDN;
                }

                if (NULL != ppQueryInfoWStr) {
                    // Dup returned LDAP string into NtdspAlloc'ed memory.
                    Size = (wcslen( Values[0] ) + 1) * sizeof(WCHAR);
                    *ppQueryInfoWStr = (WCHAR*) NtdspAlloc( Size );
                    if (NULL == *ppQueryInfoWStr) {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    
                    wcscpy(*ppQueryInfoWStr, Values[0]);
                }
            }  // looping on the attributes

            if ( ERROR_SUCCESS != WinError )
            {
                break;
            }

        } // looping on the entries

        if ((ERROR_SUCCESS == WinError)
            && (NULL != pQueryInfo->DomainDN)) {
            // In the case of child domain install, the domain DN of the target
            // is also the parent DN of the child domain we are installing.
            Size = (wcslen(pQueryInfo->DomainDN) + 1) * sizeof(WCHAR);
            pQueryInfo->ParentDomainDN = (WCHAR*) NtdspAlloc(Size);
            if (NULL == pQueryInfo->ParentDomainDN) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            wcscpy(pQueryInfo->ParentDomainDN, pQueryInfo->DomainDN);
        }
    
    } else {

        ASSERT(!"No naming contexts were returned from the source server");
        WinError = ERROR_DS_NOT_INSTALLED;
    }

    if (ERROR_SUCCESS != WinError) {
        goto Cleanup;
    }

    ASSERT( pQueryInfo->ServerDN );
    if (   pQueryInfo->ServerDN
        && (NULL == pQueryInfo->SiteName) )
    {
        //
        // This case captures the scenario in which
        // the client has not passed us in a site, and
        // dsgetdc failed to find us a site.  In this case
        // we take the site object of of the server we are
        // replicating from
        //
        ULONG  Size;
        DSNAME *src, *dst;
        WCHAR  *SiteName, *Terminator;

        Size = (ULONG)DSNameSizeFromLen(wcslen(pQueryInfo->ServerDN));

        src = alloca(Size);
        RtlZeroMemory(src, Size);

        dst = alloca(Size);
        RtlZeroMemory(dst, Size);

        src->NameLen = wcslen(pQueryInfo->ServerDN);
        wcscpy(src->StringName, pQueryInfo->ServerDN);

        if ( TrimDSNameBy(src, 3, dst) ) {
            KdPrint(("NTDSETUP: TrimDSNameBy failed - erroring out\n"));
            return ERROR_NO_SITENAME;
        }

        SiteName = wcsstr(dst->StringName, L"=");
        if (SiteName) {
            //
            // One more character and we will have the site name
            //
            SiteName++;

            // now go to the end
            Terminator = wcsstr(SiteName, L",");
            if (Terminator) {
                *Terminator = L'\0';
                Size = (wcslen(SiteName) + 1 ) * sizeof( WCHAR );
                pQueryInfo->SiteName = (WCHAR*) NtdspAlloc( Size );
                if ( pQueryInfo->SiteName )
                {
                    wcscpy(pQueryInfo->SiteName, SiteName);
                }
                else
                {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

            } else {
                return ERROR_NO_SITENAME;
            }

        } else {
            return ERROR_NO_SITENAME;
        }
    }

Cleanup:

    return WinError;
}

DWORD
NtdspValidateInstallParameters(
    PNTDS_INSTALL_INFO UserInstallInfo
    )
/*++

Routine Description:

    This routine does a simple pass of the parameters passed

Parameters:

    UserInstallInfo  - the user parameters

Return Values:

    ERROR_SUCCESS, all parameters check out

    ERROR_INVALID_PARAMETER, otherwise

Notes:

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    //
    // Common
    //
    if (!UserInstallInfo) {
        return ERROR_INVALID_PARAMETER;
    }


    if (!UserInstallInfo->DitPath
     || !UserInstallInfo->LogPath
     || !UserInstallInfo->DnsDomainName) {

        return ERROR_INVALID_PARAMETER;

    }

#if 0

    // This code should be removed once we have signed off on our DBCS testing

    {
        ULONG Length = 0;
        ULONG i;

        Length = wcslen( UserInstallInfo->DnsDomainName );

        for ( i = 0; i < Length; i++ )
        {
            if ( !iswascii(UserInstallInfo->DnsDomainName[i]) )
            {
                NTDSP_SET_ERROR_MESSAGE1( ERROR_INVALID_PARAMETER,
                                          DIRMSG_DBCS_DOMAIN_NAME,
                                          UserInstallInfo->DnsDomainName );

                return ERROR_INVALID_PARAMETER;
            }
        }
    }

#endif


    if (UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE) {

        //
        // There are no parameters that need checking here
        //

        NOTHING;

    } else if (UserInstallInfo->Flags & NTDS_INSTALL_REPLICA) {

        if (!UserInstallInfo->ReplServerName) {
            return ERROR_INVALID_PARAMETER;
        }

    } else if (UserInstallInfo->Flags & NTDS_INSTALL_DOMAIN) {

        if (!UserInstallInfo->ReplServerName) {
            return ERROR_INVALID_PARAMETER;
        }

    } else {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // If dns names are given make now that they are valid
    //
    if ( UserInstallInfo->DnsDomainName )
    {
        WinError = DnsValidateDnsName_W( UserInstallInfo->DnsDomainName );
        if ( WinError == DNS_ERROR_NON_RFC_NAME )
        {
            WinError = ERROR_SUCCESS;
        }
        if ( ERROR_SUCCESS != WinError )
        {
            return ERROR_INVALID_DOMAINNAME;
        }
    }

    if ( UserInstallInfo->SiteName )
    {
        WinError = DnsValidateDnsName_W( UserInstallInfo->SiteName );
        if ( WinError == DNS_ERROR_NON_RFC_NAME )
        {
            WinError = ERROR_SUCCESS;
        }
        if ( ERROR_SUCCESS != WinError )
        {
            return ERROR_INVALID_NAME;
        }
    }

    //
    // Make sure the site name, if given, is a NOT well known name
    //
    if ( UserInstallInfo->SiteName )
    {
        int i;
        for ( i = 0; i < ARRAY_COUNT(gReserveredSiteNames); i++)
        {
            if ( !_wcsicmp( UserInstallInfo->SiteName, gReserveredSiteNames[i] ) )
            {
                NTDSP_SET_ERROR_MESSAGE1( ERROR_OBJECT_ALREADY_EXISTS,
                                          DIRMSG_INSTALL_SPECIAL_NAME,
                                          gReserveredSiteNames[i] );

                return ERROR_OBJECT_ALREADY_EXISTS;
            }
        }
    }

    return ERROR_SUCCESS;
}

DWORD
NtdspFindSite(
    IN  PNTDS_INSTALL_INFO UserInstallInfo,
    OUT PNTDS_CONFIG_INFO     DiscoveredInfo
    )
/*++

Routine Description:

    This routine calls dsgetdcname to find a site that this machine
    belongs to if one does not exist.

    Site determination is as follows:

    1) Use the passed in site name if one exists

    2) Use the client site value returned by DsGetDcName if it exists

    3) Use the dc site value returned by DsGetDcName if it exists

    4) Use the value of the server that we are replicating from


Parameters:

    UserInstallInfo  - the user parameters

Return Values:

    ERROR_SUCCESS, all parameters check out

    ERROR_INVALID_PARAMETER, otherwise

Notes:

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO  DomainControllerInfo = NULL;
    ULONG Size;
    WCHAR *SiteName = NULL;

    ASSERT(UserInstallInfo);
    ASSERT(DiscoveredInfo);

    if (!UserInstallInfo->SiteName) {

        //
        // Pass the domain name in and it will return the site
        //
        WinError = DsGetDcNameW(NULL,  // computer name
                                UserInstallInfo->DnsDomainName,
                                NULL,  // domain guid
                                NULL,  // site name
                                DS_IS_DNS_NAME,
                                &DomainControllerInfo);

        if (WinError == ERROR_SUCCESS) {

            if (DomainControllerInfo->ClientSiteName) {

                SiteName = DomainControllerInfo->ClientSiteName;

            } else if (DomainControllerInfo->DcSiteName) {

                SiteName = DomainControllerInfo->DcSiteName;

            }
            else {

                ASSERT(FALSE && "Invalid Site Name\n");
                NetApiBufferFree(DomainControllerInfo);
                return(ERROR_NO_SUCH_DOMAIN);

            }

            Size = (wcslen( SiteName ) + 1) * sizeof(WCHAR);
            DiscoveredInfo->SiteName = NtdspAlloc( Size );
            if ( DiscoveredInfo->SiteName )  {
                wcscpy(DiscoveredInfo->SiteName, SiteName);
            } else {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
            }

            NetApiBufferFree(DomainControllerInfo);

        } else {
            //
            // We ignore the error, since if it fails we have yet another
            // backup mechanism to obtain the site.
            //
            WinError = ERROR_SUCCESS;
        }

    }

    return WinError;
}

DWORD
NtdspVerifyDsEnvironment(
    IN PNTDS_INSTALL_INFO    UserInstallInfo,
    IN OUT PNTDS_CONFIG_INFO DiscoveredInfo
    )
/*++

Routine Description:


    The purpose of this routine is to validate the parameters that the
    user specified with respect to the directory service that this server
    is about to join. The following checks are done:

    . enterprise install
        none - there is no source server to check against!

    . replica install
        . the site object specified by either user parameter or discovered info must
          exist on the replica that we are replicating from
        . the server name must not exists as an rdn of a ntds-dsa object
          in the site we are joining.  If it does and NTDS_INSTALL_DC_REINSTALL
          is set in the flags, then delete the existing ntds-dsa object

    . new domain; non enterprise
        . same as replica
        . the netbios name of the domain must not exist as an rdn of a
          cross ref object in the partitions container on the replica we
          are installing from

    This routine also returns the serverdn, schemadn, configurationdn, and
    domaindn.

Parameters:


    UserInstallInfo: pointer to the user parameters

    DiscoveredInfo :  pointer to the discovered parameters

Return Values:


    ERROR_SUCCESS, all parameters check out

    ERROR_NO_SUCH_SITE, the site specified cannot be found on the replica

    ERROR_DOMAIN_CONTROLLER_EXISTS, the server name already exists

    ERROR_DOMAIN_EXISTS, the domain name already exists

    ERROR_DS_INSTALL_SCHEMA_MISMATCH, the schema version in the source does not
                           match the version in the build being installed

    anything else is afatal system service or ldap win32 error

Notes:

    This routine uses ldap to talk to the source server

--*/
{

    DWORD        Win32Error = ERROR_SUCCESS;

    DWORD        IgnoreError;

    PLDAP        hLdap = NULL;
    ULONG        LdapError;

    WCHAR        *SiteDistinguishedName;
    WCHAR        *NtdsDsaDistinguishedName = NULL;
    WCHAR        *ServerDistinguishedName;
    WCHAR        *XrefDistinguishedName;

    WCHAR        ComputerName[MAX_COMPUTERNAME_LENGTH + 2]; // NULL and $
    ULONG        ComputerNameLength = sizeof(ComputerName);

    ULONG        Length, Size;

    BOOLEAN      ObjectExists = FALSE;

    WCHAR        *SiteName;

    WCHAR        *ServerName;

    HANDLE        DsHandle = 0;
    BOOLEAN       fDomainExists = TRUE;
    BOOLEAN       fEnabled = TRUE;

    BOOL fMisMatch;

    WCHAR *DomainDN = NULL;

    ASSERT(UserInstallInfo);
    ASSERT(DiscoveredInfo);

    RtlZeroMemory(ComputerName, sizeof(ComputerName));

    //
    // Get the easy case done first
    //
    if (UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE) {

        Win32Error = NtdspGetRootDomainConfigInfo( UserInstallInfo,
                                                   DiscoveredInfo );
        if ( ERROR_SUCCESS != Win32Error )
        {
            DPRINT1( 0, "NtdspGetRootDomainConfigInfo failed with 0x%x\n", Win32Error );
        }

        //
        // That's it for the root domain install
        //
        return Win32Error;
    }


    //
    // sanity checks
    //
    ASSERT( (UserInstallInfo->Flags & NTDS_INSTALL_REPLICA)
        ||  (UserInstallInfo->Flags & NTDS_INSTALL_DOMAIN)  );
    ASSERT(UserInstallInfo->ReplServerName);

    ServerName = UserInstallInfo->ReplServerName;
    while (*ServerName == L'\\') {
        ServerName++;
    }

    //
    // Open an ldap connection to source server
    //

    hLdap = ldap_openW(ServerName, LDAP_PORT);

    if (!hLdap) {

        Win32Error = GetLastError();

        if (Win32Error == ERROR_SUCCESS) {
            //
            // This works around a bug in the ldap client
            //
            Win32Error = ERROR_CONNECTION_INVALID;
        }

        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRMSG_INSTALL_FAILED_LDAP_CONNECT,
                                  ServerName );

        return Win32Error;
    }

    //
    // Bind
    //

    LdapError = impersonate_ldap_bind_sW(UserInstallInfo->ClientToken,
                                         hLdap,
                                         NULL,  // use credentials instead
                                         (VOID*)UserInstallInfo->Credentials,
                                         LDAP_AUTH_SSPI);

    Win32Error = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS != Win32Error) {
        ldap_unbind_s(hLdap);
        if (ERROR_GEN_FAILURE == Win32Error ||
            ERROR_WRONG_PASSWORD == Win32Error )  {
            // This does not help anyone.  AndyHe needs to investigate
            // why this returning when invalid credentials are passed in.
            Win32Error = ERROR_NOT_AUTHENTICATED;
        }

        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRMSG_INSTALL_FAILED_BIND,
                                  ServerName );

        return Win32Error;
    }

    //
    // Get the config information, so we can build the site, ntds-dsa and
    // xref object names. We will need the config infomation later for
    // setting up the ds, too.
    //
    Win32Error = NtdspQueryConfigInfo(hLdap,
                                      DiscoveredInfo);


    if ( ERROR_SUCCESS !=  Win32Error )
    {
        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG,
                                  ServerName );
        goto Cleanup;
    }


    //check if current version is compatible with the version of domain, and forest
    Win32Error = NtdspCheckBehaviorVersion(hLdap,
                                           UserInstallInfo->Flags,
                                           DiscoveredInfo );
    if ( ERROR_SUCCESS != Win32Error ) {
        
        NTDSP_SET_ERROR_MESSAGE0( Win32Error,
                                  DIRMSG_INSTALL_FAILED_VERSION_CHECK );
        goto Cleanup;
    }



    // Check if the schema versions match
    Win32Error = NtdspCheckSchemaVersion(hLdap,
                                         DiscoveredInfo->SchemaDN,
                                         &fMisMatch);
    if (ERROR_SUCCESS == Win32Error) {
        if (fMisMatch) {
            Win32Error = ERROR_DS_INSTALL_SCHEMA_MISMATCH;
        }
    }

    if ( ERROR_SUCCESS !=  Win32Error )
    {
        NTDSP_SET_ERROR_MESSAGE0( Win32Error,
                                  DIRMSG_INSTALL_FAILED_SCHEMA_CHECK );
        goto Cleanup;
    }

    
    //
    // Get the server we are talking to's guid so we can replicate
    // to it later on
    //
    Win32Error = NtdspGetSourceServerGuid(hLdap,
                                          DiscoveredInfo);
    if ( ERROR_SUCCESS != Win32Error )
    {
        ASSERT(UserInstallInfo->ReplServerName);
        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRMSG_FAIL_GET_GUID_REPLSERVER,
                                  UserInstallInfo->ReplServerName);        
        goto Cleanup;
    }

//
// Due to bug # 384465 this code will no longer be run.
// In windows Beta2 this limit was enforced.  Due to customer feedback
// this will no longer be enforced.
//

#if 0

    //
    // If this is a standard server we need to stop promotion if there
    // are already the limit of allowable servers in the domain.
    //
    if (!(UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE))
    {
        Win32Error = NtdspCheckDomainDcLimit(hLdap,
                                             DiscoveredInfo);
    
        if ( Win32Error == ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER) {
            
            goto Cleanup;
    
        } else if ( Win32Error !=  ERROR_SUCCESS ) 
        {
            ASSERT(ServerName);
            NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                      DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG,
                                      ServerName );
            goto Cleanup;
        }
    }

#endif
    
    //
    // If this is a replica install, get the RID FSMO info
    //
    if ( FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_REPLICA ) )
    {
        IgnoreError = NtdspGetRidFSMOInfo( hLdap,
                                           DiscoveredInfo );

        if ( ERROR_SUCCESS != IgnoreError )
        {
            // Oh, well, continue on
            DPRINT( 1, "Failed (non fatal) to read RID FSMO info from ServerName\n" );
            IgnoreError = ERROR_SUCCESS;
        }

        //if this is an install from media then get the tombstone lifetime of
        //the domain and store it in the registry for later use.  If the RestorePath
        //is an non-NULL value then We know that we are performing a install from media
        if(UserInstallInfo->RestorePath  && *(UserInstallInfo->RestorePath)){
            Win32Error = NtdspGetTombstoneLifeTime( hLdap,
                                                    DiscoveredInfo);
            //if we didn't find a tombstone then we are going to assume the default time
            if (Win32Error != 0) {
                DPRINT( 0, "Didn't retrieve the Tombstone from the replica server\n");
                NTDSP_SET_ERROR_MESSAGE0( Win32Error,
                                          DIRMSG_INSTALL_FAILED_TOMBSTONE_CHECK );
                goto Cleanup;            
            }
        }
    }

    // The Replication Epoch needs to be retrieved from the helper server.  It will
    // Be stored in the registry for later use if it is a greater than zero value.
    // The Replication Epoch of this server must match that of the domain for replication
    // To occur.
    Win32Error = NtdspGetReplicationEpoch( hLdap,
                                           DiscoveredInfo);
    if ( ERROR_SUCCESS != Win32Error ) {
        DPRINT(0, "Failed to retrieve the Replication Epoch from the replica server\n");
        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRMSG_REPLICATION_EPOCH_NOT_RETRIEVED,
                                  UserInstallInfo->ReplServerName );
        goto Cleanup;
    }

    //
    // If this is a child domain install, and we need to create the cross
    // ref, then start looking at the domain naming FSMO master because
    // that is where we will be creating the object
    //
    if (UserInstallInfo->Flags & NTDS_INSTALL_DOMAIN) {


        ASSERT(DiscoveredInfo->ConfigurationDN);
        ASSERT(UserInstallInfo->FlatDomainName);

        //
        // There are two entities of interest here:
        // The cross-ref object itself and the domain dn
        //
        // 1)There should not be any cross-ref objects with this
        // domain dn as a value of Dns-Root
        //
        // 2) There should not be a cross ref object with the flat domain
        // name as its RDN
        //

        //
        // Check for the domain dn
        //
        Length = 0;
        DomainDN = NULL;
        Win32Error = NtdspDNStoRFC1779Name( DomainDN,
                                            &Length,
                                            UserInstallInfo->DnsDomainName );

        Size = (Length+1)*sizeof(WCHAR);
        DomainDN = (WCHAR*) alloca( Size );
        RtlZeroMemory( DomainDN, Size );

        Win32Error = NtdspDNStoRFC1779Name( DomainDN,
                                           &Length,
                                            UserInstallInfo->DnsDomainName );

        if ( ERROR_SUCCESS != Win32Error )
        {
            NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                      DIRMSG_INSTALL_CANNOT_DERIVE_DN,
                                      UserInstallInfo->DnsDomainName );

            goto Cleanup;
        }


        Win32Error = NtdspDoesDomainExistEx( hLdap,
                                           DiscoveredInfo,
                                           DomainDN,
                                           &fDomainExists,
                                           &fEnabled );

        if ( ERROR_SUCCESS != Win32Error )
        {
            NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                      DIRLOG_INSTALL_DOMAIN_EXISTS,
                                      DomainDN,
                                      ServerName );
            goto Cleanup;
        }

        if ( !fDomainExists || fEnabled )
        {
            //
            // Ok, we need to talk to the DomainNamingFSMO instead of
            // our helper
            //
            {
                BOOL FSMOmissing = FALSE;
                Win32Error = NtdspGetDomainFSMOInfo( hLdap,
                                                     DiscoveredInfo,
                                                     &FSMOmissing);
    
                if ( ERROR_SUCCESS != Win32Error )
                {
                    if (!FSMOmissing) {
                        NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                                  DIRLOG_INSTALL_DOMAIN_EXISTS,
                                                  DomainDN,
                                                  ServerName );
                    }
                    //
                    // This is fatal
                    //
                    goto Cleanup;
                }
            }

            // No longer need this connection
            ldap_unbind( hLdap );

            ServerName = DiscoveredInfo->DomainNamingFsmoDnsName;

            hLdap = ldap_openW(ServerName, LDAP_PORT);

            if (!hLdap) {

                Win32Error = GetLastError();

                if (Win32Error == ERROR_SUCCESS) {
                    //
                    // This works around a bug in the ldap client
                    //
                    Win32Error = ERROR_CONNECTION_INVALID;
                }

                NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                          DIRMSG_CANNOT_CONTACT_DOMAIN_FSMO,
                                          ServerName );

                return Win32Error;
            }

            //
            // Bind
            //

            LdapError = impersonate_ldap_bind_sW(UserInstallInfo->ClientToken,
                                                 hLdap,
                                                 NULL,  // use credentials instead
                                                 (VOID*)UserInstallInfo->Credentials,
                                                 LDAP_AUTH_SSPI);

            Win32Error = LdapMapErrorToWin32(LdapError);

            if (ERROR_SUCCESS != Win32Error) {
                ldap_unbind_s(hLdap);
                if (ERROR_GEN_FAILURE == Win32Error ||
                    ERROR_WRONG_PASSWORD == Win32Error )  {
                    // This does not help anyone.  AndyHe needs to investigate
                    // why this returning when invalid credentials are passed in.
                    Win32Error = ERROR_NOT_AUTHENTICATED;
                }

                NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                          DIRMSG_CANNOT_CONTACT_DOMAIN_FSMO,
                                          ServerName );

                return Win32Error;
            }
        }

        if ( fDomainExists && fEnabled )
        {
            //
            // We have to wait for the ntdsa object to be removed before
            // we attempt to remove the domain
            //
            if ( !(UserInstallInfo->Flags & NTDS_INSTALL_DOMAIN_REINSTALL) )
            {
                //
                // The domain already exists
                //
                Win32Error = ERROR_DOMAIN_EXISTS;

                NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                          DIRLOG_INSTALL_DOMAIN_EXISTS,
                                          DomainDN,
                                          ServerName );
                goto Cleanup;
            }
        }

        if ( !fDomainExists )
        {
            // We'll need to create it
            DiscoveredInfo->fNeedToCreateDomain = TRUE;
        }

    }


    //
    // Make sure the site object exists
    //
    if (UserInstallInfo->SiteName) {
        SiteName = UserInstallInfo->SiteName;
    } else {
        SiteName = DiscoveredInfo->SiteName;
    }

    ASSERT(SiteName);
    ASSERT(DiscoveredInfo->ConfigurationDN);

    Length = wcslen(DiscoveredInfo->ConfigurationDN) +
             wcslen(SiteName) +
             wcslen(L"CN=,CN=Sites,") + 1;

    SiteDistinguishedName = alloca(Length * sizeof(WCHAR));

    wcscpy(SiteDistinguishedName, L"CN=");
    wcscat(SiteDistinguishedName, SiteName);
    wcscat(SiteDistinguishedName, L",CN=Sites,");
    wcscat(SiteDistinguishedName, DiscoveredInfo->ConfigurationDN);

    Win32Error = NtdspDoesObjectExistOnSource(hLdap,
                                              SiteDistinguishedName,
                                              &ObjectExists);

    if (ERROR_SUCCESS == Win32Error) {

        if (!ObjectExists) {
            // No so good, the ntds-dsa object hsa no where to go
            Win32Error = ERROR_NO_SUCH_SITE;
        }
    }

    if ( ERROR_SUCCESS != Win32Error )
    {
        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRMSG_INSTALL_FAILED_SITE_EXIST,
                                  SiteName );
        goto Cleanup;
    }

    //
    // Search for the machine account if this is a replica install
    //
    if (!GetComputerName(ComputerName, &ComputerNameLength)) {
        Win32Error = GetLastError();
    }

    if (   (ERROR_SUCCESS == Win32Error)
        && FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_REPLICA ) )
    {
        LPWSTR AccountNameDn = 0;
        ULONG  Length;

        wcscat( ComputerName, L"$" );

        Win32Error = NtdspGetUserDn( hLdap,
                                   DiscoveredInfo->DomainDN,
                                   ComputerName,
                                   &AccountNameDn );

        if ( ERROR_SUCCESS == Win32Error )
        {
            Length = (wcslen( AccountNameDn ) + 1) * sizeof(WCHAR);
            DiscoveredInfo->LocalMachineAccount = (LPWSTR) RtlAllocateHeap( RtlProcessHeap(), 0, Length );
            if ( DiscoveredInfo->LocalMachineAccount )
            {
                wcscpy( DiscoveredInfo->LocalMachineAccount, AccountNameDn );
            }
            else
            {
                Win32Error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        // get rid of the $
        Length = wcslen( ComputerName );
        ComputerName[Length-1] = L'\0';
    }

    if ( ERROR_SUCCESS != Win32Error )
    {
        NTDSP_SET_ERROR_MESSAGE1( Win32Error,
                                  DIRLOG_FAILED_TO_FIND_MACHINE_ACCOUNT,
                                  ServerName );
        goto Cleanup;
    }

    //
    // Make sure the server object is there; otherwise try to create it
    //

    if ( ERROR_SUCCESS == Win32Error ) {

        Length = wcslen(SiteDistinguishedName) +
                 wcslen(ComputerName) +
                 wcslen(L"CN=,CN=Servers,") + 1;

        ServerDistinguishedName = alloca(Length * sizeof(WCHAR));

        wcscpy(ServerDistinguishedName, L"CN=");
        wcscat(ServerDistinguishedName, ComputerName);
        wcscat(ServerDistinguishedName, L",CN=Servers,");
        wcscat(ServerDistinguishedName, SiteDistinguishedName);

        //
        // Save off a copy of this dn
        //
        DiscoveredInfo->LocalServerDn = RtlAllocateHeap( RtlProcessHeap(), 0, Length*sizeof(WCHAR) );
        if ( DiscoveredInfo->LocalServerDn ) {

            wcscpy( DiscoveredInfo->LocalServerDn, ServerDistinguishedName );

        } else {

            Win32Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Win32Error = NtdspDoesObjectExistOnSource(hLdap,
                                                  ServerDistinguishedName,
                                                  &ObjectExists);

        if ( ERROR_SUCCESS == Win32Error ) {

            if ( !ObjectExists ) {

                WCHAR *NtdssettingDN = NULL;

                if ( FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_REPLICA ) ) {

                    //Make sure that there isn't a server object For this machine
                    //In another site.
                    Win32Error = NtdspDoesServerObjectExistOnSourceinDifferentSite( hLdap,
                                                                                    DiscoveredInfo->LocalMachineAccount,
                                                                                    ServerDistinguishedName,
                                                                                    &ObjectExists,
                                                                                    &NtdssettingDN );
    
                    if ( ERROR_SUCCESS != Win32Error )
                    {
                         goto Cleanup;
                    }

                }

                if (ObjectExists) {
                    
                    if (UserInstallInfo->Flags & NTDS_INSTALL_DC_REINSTALL) {

                        //
                        // The user has requested that this machine be reinstalled.
                        //
                        // Note that there are two possible options here:
                        //
                        // 1) just delete the ntds-dsa object
                        //
                        // 2) reuse the existing ntds-dsa object.
                        //
                        // For now just 1) is supported.  If rid-manager support comes on line
                        // to reuse the mtsft-dsa object (ie supports rid-reclamation) then
                        // we will be able to just reuse the exising ntds-dsa object, possibly
                        // having to reguid it.  This will require support in dsamain\boot\install.cxx
                        //
    
    
                        Win32Error = NtdspRemoveServer( &DsHandle,
                                                        UserInstallInfo->Credentials,
                                                        UserInstallInfo->ClientToken,
                                                        ServerName,
                                                        NtdssettingDN,
                                                        TRUE );
    
                        if ( Win32Error != ERROR_SUCCESS )
                        {
                            NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                                      DIRLOG_INSTALL_FAILED_TO_DELETE_SERVER,
                                                      ServerName,
                                                      NtdssettingDN );
                            goto Cleanup;
                        }

                    } else {
    
                        //
                        // Can't continue installation when a dc with the same
                        // name exists
                        //
    
                        Win32Error = ERROR_DOMAIN_CONTROLLER_EXISTS;
    
                    }

                }

                if ( ERROR_SUCCESS == Win32Error ) {

                    Win32Error = NtdspCreateServerObject( hLdap,
                                                          ServerName,
                                                          DiscoveredInfo,
                                                          ServerDistinguishedName );

                }
                

            }
        }
    }

    if ( ERROR_SUCCESS != Win32Error )
    {
        goto Cleanup;
    }

    //
    // Make sure the ntds-dsa object is not there
    //

    if (ERROR_SUCCESS == Win32Error) {

        Length = wcslen(SiteDistinguishedName) +
                 wcslen(ComputerName) +
                 wcslen(L"CN=NTDS Settings,CN=,CN=Servers,") + 1;

        NtdsDsaDistinguishedName = alloca(Length * sizeof(WCHAR));

        wcscpy(NtdsDsaDistinguishedName, L"CN=NTDS Settings,CN=");
        wcscat(NtdsDsaDistinguishedName, ComputerName);
        wcscat(NtdsDsaDistinguishedName, L",CN=Servers,");
        wcscat(NtdsDsaDistinguishedName, SiteDistinguishedName);


        Win32Error = NtdspDoesObjectExistOnSource(hLdap,
                                                  NtdsDsaDistinguishedName,
                                                  &ObjectExists);

        if (ERROR_SUCCESS == Win32Error) {

            if (ObjectExists) {

                if (UserInstallInfo->Flags & NTDS_INSTALL_DC_REINSTALL) {

                    //
                    // The user has requested that this machine be reinstalled.
                    //
                    // Note that there are two possible options here:
                    //
                    // 1) just delete the ntds-dsa object
                    //
                    // 2) reuse the existing ntds-dsa object.
                    //
                    // For now just 1) is supported.  If rid-manager support comes on line
                    // to reuse the mtsft-dsa object (ie supports rid-reclamation) then
                    // we will be able to just reuse the exising ntds-dsa object, possibly
                    // having to reguid it.  This will require support in dsamain\boot\install.cxx
                    //


                    Win32Error = NtdspRemoveServer( &DsHandle,
                                                    UserInstallInfo->Credentials,
                                                    UserInstallInfo->ClientToken,
                                                    ServerName,
                                                    NtdsDsaDistinguishedName,
                                                    TRUE );

                    if ( Win32Error != ERROR_SUCCESS )
                    {
                        NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                                  DIRLOG_INSTALL_FAILED_TO_DELETE_SERVER,
                                                  ServerName,
                                                  NtdsDsaDistinguishedName );
                        goto Cleanup;
                    }

                } else {

                    //
                    // Can't continue installation when a dc with the same
                    // name exists
                    //

                    Win32Error = ERROR_DOMAIN_CONTROLLER_EXISTS;

                }
            }
        }
    }

    if ( ERROR_SUCCESS != Win32Error )
    {
        NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                  DIRLOG_INSTALL_SERVER_EXISTS,
                                  NtdsDsaDistinguishedName,
                                  ServerName );
        goto Cleanup;
    }
    //
    // Now try to remove the domain, if necessary
    //
    if (   FLAG_ON(UserInstallInfo->Flags, NTDS_INSTALL_DOMAIN)
        && FLAG_ON(UserInstallInfo->Flags, NTDS_INSTALL_DOMAIN_REINSTALL )
        && fDomainExists
        && fEnabled  )
    {

        //
        // The user has asked that this domain be reinstalled
        //

        Win32Error = NtdspRemoveDomain( &DsHandle,
                                         UserInstallInfo->Credentials,
                                         UserInstallInfo->ClientToken,
                                         ServerName,
                                         DomainDN );

        if ( Win32Error == ERROR_DS_NO_CROSSREF_FOR_NC )
        {
            //
            // Hmm, ok well, continue on then
            //
            Win32Error = ERROR_SUCCESS;
        }
        else if ( Win32Error != ERROR_SUCCESS )
        {
            NTDSP_SET_ERROR_MESSAGE2( Win32Error,
                                      DIRLOG_INSTALL_FAILED_TO_DELETE_DOMAIN,
                                      ServerName,
                                      DomainDN );
            goto Cleanup;
        }

        //
        // We'll definately need to create it.
        //
        DiscoveredInfo->fNeedToCreateDomain = TRUE;
    }



    //
    // Get the root domain sid
    //
    Win32Error = NtdspGetRootDomainSid( hLdap,
                                        DiscoveredInfo );
    if ( ERROR_SUCCESS != Win32Error )
    {
        DPRINT1( 0, "NtdspGetRootDomainSid returned %d\n", Win32Error );

        //
        // This is not fatal because some servers
        // do not support this functionality
        //
        Win32Error = ERROR_SUCCESS;

    }

    //
    // For a child domain install, get the parent's cross ref object
    //
    if ( FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_DOMAIN ) )
    {
        Win32Error = NtdspGetTrustedCrossRef( hLdap,
                                              UserInstallInfo,
                                              DiscoveredInfo );
        if ( ERROR_SUCCESS != Win32Error )
        {
            DPRINT1( 0, "NtdspGetTrustedCrossRef returned %d\n", Win32Error );
            goto Cleanup;
        }
    }


    //
    // Finally, on a replica install set the serverdn reference on the server 
    // object so the Rid Manager can quickly initialize
    //
    if (  FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_REPLICA ) )
    {
        IgnoreError = NtdspUpdateServerReference( hLdap,
                                                  DiscoveredInfo );

        if ( ERROR_SUCCESS != IgnoreError )
        {
            // This is not fatal
        }
    }

Cleanup:

    if (hLdap) {
        ldap_unbind(hLdap);
    }

    if ( DsHandle != 0 )
    {
        DsUnBind( &DsHandle );
    }

    return Win32Error;

}

DWORD
NtdspDoesServerObjectExistOnSourceinDifferentSite( 
    IN LDAP *hLdap,
    IN WCHAR *AccountNameDn,
    IN WCHAR *ServerDistinguishedName,
    OUT BOOLEAN *ObjectExists,
    OUT WCHAR   **NtdsSettingsObjectDN
    )
/*++

Routine Description:

    This routine searches for the ServerReferenceBL to make sure that there is no
    server object for this machine in another site.

Parameters:

    hLdap:                    handle to a valid ldap session
    AccountNameDn :           The Machine Account DN
    ServerDistinguishedName : The Server DN based on the site we expect it to be in.
    ObjectExists :            Reports if a server object was found outside the expected site.

Return Values:

    ERROR_SUCCESS, winerror from ldap otherwise

Notes:

--*/
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult  = NULL;
    LDAPMessage  *SearchResult2 = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2] = { 0,0 };
    WCHAR        **Values = NULL;

    WCHAR        *filter = L"ObjectClass=*";

    WCHAR        *NtdsSettingsPreFix = L"CN=NTDS Settings,";

    WCHAR        *NtdsSettings = NULL;

    LDAPModW     *Mod[2] = { 0,0 };

    Mod[0] = NtdspAlloc(sizeof(LDAPModW));
    if (!Mod[0]) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Mod[0]->mod_op   = LDAP_MOD_DELETE;
    Mod[0]->mod_type = L"serverReference";

    Mod[1] = NULL;
    
    ASSERT(hLdap);
    ASSERT(AccountNameDn);
    ASSERT(ServerDistinguishedName);

    AttrsToSearch[0] = L"serverReferenceBL";
    AttrsToSearch[1] = NULL;

    *ObjectExists = FALSE;

    LdapError = ldap_search_sW( hLdap,
                                AccountNameDn,
                                LDAP_SCOPE_BASE,
                                filter,
                                AttrsToSearch,
                                TRUE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                //
                // Found it - these are NULL-terminated strings
                //
                Values = ldap_get_valuesW( hLdap, Entry, Attr );
                if ( Values && Values[0] )
                {
                    DWORD i = 0;
                    while( Values[i] )
                    {
                        if ( _wcsicmp( Values[i], ServerDistinguishedName ) != 0 )
                        {
                            NtdsSettings = NtdspAlloc(wcslen(Values[i])+
                                                      wcslen(NtdsSettingsPreFix)+1);
                            if (!NtdsSettings) {
                                WinError = ERROR_NOT_ENOUGH_MEMORY;
                                goto Cleanup;
                            }
                            wcscpy(NtdsSettings,NtdsSettingsPreFix);
                            wcscat(NtdsSettings,Values[i]);

                            LdapError = ldap_search_sW( hLdap,
                                                        NtdsSettings,
                                                        LDAP_SCOPE_BASE,
                                                        filter,
                                                        NULL,
                                                        TRUE,
                                                        &SearchResult2);
                        
                            if ( LDAP_SUCCESS != LdapError )
                            {
                                WinError = LdapMapErrorToWin32(LdapError);
                                goto Cleanup;
                            }
                            if (ldap_count_entries(hLdap, SearchResult2) > 0) {

                                *ObjectExists=TRUE;
                                *NtdsSettingsObjectDN = NtdsSettings;

                            } else {
                                //cleanup serverReference since it doesn't have a NtdsSettingsObject

                                LdapError = ldap_modify_sW(hLdap,
                                                           Values[i],
                                                           Mod);
                                if ( LDAP_SUCCESS != LdapError )
                                {
                                    WinError = LdapMapErrorToWin32(LdapError);
                                    goto Cleanup;
                                }

                            }

                            if (NtdsSettings) {
                                NtdspFree(NtdsSettings);
                                NtdsSettings = NULL;
                            }
                            if (SearchResult2) {
                                ldap_msgfree( SearchResult2 );
                                SearchResult2 = NULL;
                            }

                        }
                        //Repeat on the next value
                        i++;
                    }
                }
                
            }
        }

        if (Values) {
            ldap_value_free(Values);
            Values = NULL;
        }
    }


    Cleanup:

    if (NtdsSettings) {
        NtdspFree(NtdsSettings);
    }
    if (Mod[0]) {
        NtdspFree(Mod[0]);
        Mod[0] = NULL;
    }
    if (SearchResult) {
        ldap_msgfree( SearchResult );
    }
    if (SearchResult2) {
        ldap_msgfree( SearchResult2 );
    }
    if (Values) {
        ldap_value_free(Values);
    }
    

    return ERROR_SUCCESS;

}



DWORD
NtdspDoesObjectExistOnSource(
    IN  LDAP *hLdap,
    IN  WCHAR *ObjectDN,
    OUT BOOLEAN *ObjectExists
    )
/*++

Routine Description:

    This routine searches for the ObjectDN using the hLdap.

Parameters:

    hLdap:        handle to a valid ldap session
    ObjectDN :    null terminated string
    ObjectExists: pointer to boolean describing whether the object exists

Return Values:

    ERROR_SUCCESS, winerror from ldap otherwise

Notes:

--*/
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError;
    LDAPMessage  *SearchResult;
    ULONG        NumberOfEntries;

    ASSERT(hLdap);
    ASSERT(ObjectDN);
    ASSERT(ObjectExists);

    *ObjectExists = FALSE;

    LdapError = ldap_search_sW(hLdap,
                               ObjectDN,
                               LDAP_SCOPE_BASE,
                               L"objectClass=*",
                               NULL,   // attrs
                               FALSE,  // attrsonly
                               &SearchResult);

    if (LdapError == LDAP_NO_SUCH_OBJECT) {

        *ObjectExists = FALSE;

    } else if (LdapError == LDAP_SUCCESS) {

        NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
        if (NumberOfEntries == 1) {
            *ObjectExists = TRUE;
        } else {
            //
            // This is really odd - a search on a specific dn resulted
            // in more than one object or none!  Assume it exists
            //
            ASSERT(FALSE);
            *ObjectExists = TRUE;
        }

    } else {

        WinError =  LdapMapErrorToWin32(LdapGetLastError());

    }

    return WinError;

}



DWORD
NtdspDsInitialize(
    IN  PNTDS_INSTALL_INFO    UserInstallInfo,
    IN  PNTDS_CONFIG_INFO     DiscoveredInfo
    )
/*++

Routine Description:


Parameters:

    UserInstallInfo: pointer to the user parameters

    DiscoveredInfo:  pointer to the discovered parameters

Return Values:

    ERROR_SUCCESS, winerror from ldap otherwise

Notes:


--*/
{

    DWORD    WinError = ERROR_SUCCESS;
    
    NTSTATUS NtStatus, IgnoreStatus;
    BOOLEAN NewDomain, UpgradePrincipals;
    NT_PRODUCT_TYPE    ProductType;
    UNICODE_STRING     AdminPassword, *pAdminPassword = NULL;
    UNICODE_STRING     SafeModeAdminPassword, *pSafeModeAdminPassword = NULL;
    POLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo = NULL;

    BOOLEAN            fDownlevelHiveLoaded = FALSE;
    BOOLEAN            fRestoreDnsDomainInfo = FALSE;
    ULONG              SamPromoteFlag = 0;

    OBJECT_ATTRIBUTES  PolicyObject;
    HANDLE             hPolicyObject = INVALID_HANDLE_VALUE;

    BOOLEAN            fStatus;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;

    ULONG              ulDsInitFlags = DSINIT_FIRSTTIME;

    DS_INSTALL_PARAM   InstallInParams;
    DS_INSTALL_RESULT  InstallOutParams;

    WCHAR              AccountName[MAX_COMPUTERNAME_LENGTH+2];
    ULONG              Length;


    

    // Clear the stack
    RtlZeroMemory( &NewPrimaryDomainInfo, sizeof(NewPrimaryDomainInfo ) );
    RtlZeroMemory( &InstallInParams, sizeof(DS_INSTALL_PARAM) );
    RtlZeroMemory( &InstallOutParams, sizeof(DS_INSTALL_RESULT) );

    // Check the product type
    fStatus = RtlGetNtProductType(&ProductType);
    if (   !fStatus
        || NtProductServer != ProductType )
    {
        WinError = ERROR_INVALID_SERVER_STATE;
        NTDSP_SET_ERROR_MESSAGE0( WinError, DIRMSG_WRONG_PRODUCT_TYPE );
        goto Cleanup;
    }


#if 0
    //look at bug # 102803 this is a fix that maybe useful later.  
    {
        BOOL fhasBlanks=FALSE;
        BOOL found=FALSE;
        WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
        LPWSTR pblank=NULL;
        DWORD len=sizeof(ComputerName);
        found =  GetComputerNameExW(ComputerNameNetBIOS,  
                                    ComputerName,      
                                    &len);
        if(!found){
            WinError = GetLastError();
            DPRINT1(0, "Failed to get computername of local machine: %d\n", WinError);
            goto Cleanup;    
        }

        pblank = wcsstr(ComputerName,L" ");
        if(pblank){
            WinError = ERROR_INVALID_COMPUTERNAME;
            NTDSP_SET_ERROR_MESSAGE0( WinError, DIRMSG_SPACE_IN_NETBIOSNAME );
            goto Cleanup;
        }
    }

#endif

    //
    // Set up the SAM flags
    //
    if (UserInstallInfo->Flags & NTDS_INSTALL_REPLICA)
    {
        //
        // This is a replica install
        //
        SamPromoteFlag |= SAMP_PROMOTE_REPLICA;

    }
    else
    {
        SamPromoteFlag |= SAMP_PROMOTE_DOMAIN;

        if ( UserInstallInfo->Flags & NTDS_INSTALL_ENTERPRISE )
        {
            SamPromoteFlag |= SAMP_PROMOTE_ENTERPRISE;
        }

        if ( UserInstallInfo->Flags & NTDS_INSTALL_UPGRADE )
        {
            // If this is a downlevel upgrade, upgrade, the existing principals
            SamPromoteFlag |= SAMP_PROMOTE_UPGRADE;
        }
        else if ( UserInstallInfo->Flags & NTDS_INSTALL_FRESH_DOMAIN )
        {
            SamPromoteFlag |= SAMP_PROMOTE_CREATE;
        }
        else
        {
            // The default action is to migrate the accounts
            SamPromoteFlag |= SAMP_PROMOTE_MIGRATE;
        }

        if ( UserInstallInfo->Flags & NTDS_INSTALL_ALLOW_ANONYMOUS )
        {
            SamPromoteFlag |= SAMP_PROMOTE_ALLOW_ANON;
        }

    }

    if ( UserInstallInfo->Flags & NTDS_INSTALL_DFLT_REPAIR_PWD )
    {
        SamPromoteFlag |= SAMP_PROMOTE_DFLT_REPAIR_PWD;
    }


    // Ok, new DC Info is created. Set it in Lsa
    // First, we must open a handle to the policy object
    RtlZeroMemory(&PolicyObject, sizeof(PolicyObject));
    NtStatus = LsaIOpenPolicyTrusted( &hPolicyObject );

    WinError = RtlNtStatusToDosError(NtStatus);

    if ( WinError != ERROR_SUCCESS )
    {
        DPRINT1(0, "Failed to open handle to Policy Object %d\n", NtStatus);
        goto Cleanup;
    }

    //
    // This routine will muck with the primary/dns domain sid.  Save the entire
    // structure so it can be restored at the end
    //
    NtStatus = LsaIQueryInformationPolicyTrusted(
                      PolicyDnsDomainInformation,
                      (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    if ( (SamPromoteFlag & SAMP_PROMOTE_CREATE) )
    {
        //
        // We are creating a new domain
        //
        NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_SECURITY );

        WinError = NtdspCreateNewDCPrimaryDomainInfo( UserInstallInfo->FlatDomainName,
                                                      &NewPrimaryDomainInfo );

        if ( WinError != ERROR_SUCCESS )
        {
            NTDSP_SET_ERROR_MESSAGE0( WinError,
                                      DIRLOG_INSTALL_FAILED_CREATE_NEW_ACCOUNT_INFO );
            goto Cleanup;
        }

    } else if ( (SamPromoteFlag & SAMP_PROMOTE_UPGRADE) )
    {
        //
        // This is an upgrade - see if SAM can load the downlevel database
        //
        NtStatus = SamILoadDownlevelDatabase( &WinError );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            DPRINT1( 0, "SamILoadDownlevelDatabase failed with 0x%x\n", NtStatus );
            //
            // This is a fatal error - we can't upgrade
            //

            NTDSP_SET_ERROR_MESSAGE0( WinError,
                                      DIRLOG_INSTALL_FAILED_LOAD_SAM_DB );

            goto Cleanup;

        }
        fDownlevelHiveLoaded = TRUE;

    } else if ( (SamPromoteFlag & SAMP_PROMOTE_MIGRATE) )
    {
        //
        // The local accounts will be "migrated" to the ds
        //
        NtStatus = LsaIQueryInformationPolicyTrusted(
                          PolicyAccountDomainInformation,
                          (PLSAPR_POLICY_INFORMATION*) &AccountDomainInfo );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            WinError = RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        NewPrimaryDomainInfo.Sid = AccountDomainInfo->DomainSid;
        RtlInitUnicodeString( &NewPrimaryDomainInfo.Name, UserInstallInfo->FlatDomainName );

    }


    //
    // Prepare the safe mode password
    //
    if (UserInstallInfo->SafeModePassword) {
        RtlInitUnicodeString(&SafeModeAdminPassword, UserInstallInfo->SafeModePassword);
        pSafeModeAdminPassword = &SafeModeAdminPassword;
    }


    //
    // Prepare the new password and the
    //
    if ( (SamPromoteFlag & SAMP_PROMOTE_MIGRATE)
      || (SamPromoteFlag & SAMP_PROMOTE_CREATE)  )
    {
        if (UserInstallInfo->AdminPassword) {
            RtlInitUnicodeString(&AdminPassword, UserInstallInfo->AdminPassword);
            pAdminPassword = &AdminPassword;
        }


        NtStatus = LsarSetInformationPolicy( hPolicyObject,
                                             PolicyPrimaryDomainInformation,
                                             (PLSAPR_POLICY_INFORMATION) &NewPrimaryDomainInfo );

        WinError = RtlNtStatusToDosError(NtStatus);

        if ( WinError != ERROR_SUCCESS )
        {
             DPRINT1(0, "Failed to set SID in lsa %d\n", NtStatus);
             goto Cleanup;
        }

        // ok, we have changed the sid - we must remember to change it back
        fRestoreDnsDomainInfo = TRUE;

    }

    if (UserInstallInfo->RestorePath) {

        WinError = NtdspCopyDatabase(UserInstallInfo->DitPath,
                                     UserInstallInfo->LogPath,
                                     UserInstallInfo->RestorePath,
                                     UserInstallInfo->SysVolPath);

        if ( WinError != ERROR_SUCCESS )
        {
             DPRINT1(0, "Failed to copy the restored database files: %d\n", WinError);
             goto Cleanup;
        }

    }

    DsaSetInstallCallback( (DSA_CALLBACK_STATUS_TYPE) UserInstallInfo->pfnUpdateStatus,
                           NtdspSetErrorString,
                           NtdspIsDsCancelOk,
                           UserInstallInfo->ClientToken );

    //
    // Initialize the directory service; this replicates or create the schema
    // configuration, and domain naming contexts.  The parameters for
    // DsInitialize() should have already been set in the registry.
    //

    InstallInParams.BootKey          = UserInstallInfo->BootKey;
    InstallInParams.cbBootKey        = UserInstallInfo->cbBootKey;
    InstallInParams.ReplicationEpoch = DiscoveredInfo->ReplicationEpoch;
    
    if ((UserInstallInfo->Options&DSROLE_DC_REQUEST_GC)==DSROLE_DC_REQUEST_GC) {
        
        InstallInParams.fPreferGcInstall = TRUE;
        
    }

    //
    // Setup parameters for replica installs
    //
    if (UserInstallInfo->Flags & NTDS_INSTALL_REPLICA) {

        ZeroMemory(AccountName, sizeof(AccountName));
        Length = sizeof(AccountName) / sizeof(AccountName[0]);
        if (!GetComputerName(AccountName, &Length)) {
            WinError = GetLastError();
            goto Cleanup;
        }
        wcscat(AccountName, L"$");
        InstallInParams.AccountName = AccountName;
        InstallInParams.ClientToken = UserInstallInfo->ClientToken;
    }

    NtStatus = DsInitialize( ulDsInitFlags,
                             &InstallInParams, 
                             &InstallOutParams );

    if ( !NT_SUCCESS(NtStatus) ) {
        Assert( NtdspErrorMessageSet() );
        DPRINT1( 0, "DsInitialize failed with 0x%x\n", NtStatus );
    }

    if ((InstallOutParams.ResultFlags&DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED)
        ==DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED)
    {
        NTDSP_SET_IFM_GC_REQUEST_CANNOT_BE_SERVICED();
    }

    DsaSetInstallCallback( NULL, NULL, NULL, NULL );

    //
    // Map the global error code set via the callback here
    //
    if ( ERROR_DUP_DOMAINNAME == gErrorCodeSet ) {
        gErrorCodeSet = ERROR_DOMAIN_EXISTS;
    }

    if (NtStatus == STATUS_INVALID_SERVER_STATE) {
        WinError = ERROR_INVALID_SERVER_STATE;
    } else if (NtStatus == STATUS_UNSUCCESSFUL) {
        WinError = ERROR_DS_NOT_INSTALLED;
    } else {
        WinError = RtlNtStatusToDosError(NtStatus);
    }

    // Try to clean up the ntdsa object if necessary; even if DsInstall
    // fails, it is still possible this object was left behind
    if (  ((ERROR_SUCCESS == WinError)
       && !FLAG_ON(UserInstallInfo->Flags, NTDS_INSTALL_ENTERPRISE))
       || ((ERROR_SUCCESS != WinError)
       && FLAG_ON(InstallOutParams.InstallOperationsDone, NTDS_INSTALL_SERVER_CREATED)) ) {

        DiscoveredInfo->UndoFlags |= NTDSP_UNDO_DELETE_NTDSA;
    }

    if (  ((ERROR_SUCCESS == WinError)
       &&  DiscoveredInfo->fNeedToCreateDomain )
       || ((ERROR_SUCCESS != WinError)
       && FLAG_ON(InstallOutParams.InstallOperationsDone, NTDS_INSTALL_DOMAIN_CREATED)) ) {

        DiscoveredInfo->UndoFlags |= NTDSP_UNDO_DELETE_DOMAIN;
    }

    if (FLAG_ON(InstallOutParams.InstallOperationsDone, NTDS_INSTALL_SERVER_MORPHED)) {

        DiscoveredInfo->UndoFlags |= NTDSP_UNDO_MORPH_ACCOUNT;
    }

    //
    // If the ds did not initialize, bail out now
    //
    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    // The ds is now initialized
    DiscoveredInfo->UndoFlags |= NTDSP_UNDO_STOP_DSA;

    if ( TEST_CANCELLATION() )
    {
        WinError = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // Call into SAM to start the directory service and upgrade the principals
    //
    if ( (SamPromoteFlag & SAMP_PROMOTE_UPGRADE) )
    {
        NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_UPGRADING_SAM );
    }
    else
    {
        NTDSP_SET_STATUS_MESSAGE0( DIRMSG_INSTALL_CREATING_SAM );
    }

    NtStatus = SamIPromote(SamPromoteFlag,
                           &NewPrimaryDomainInfo,
                           pAdminPassword,
                           pSafeModeAdminPassword);

    if (NtStatus == STATUS_INVALID_SERVER_STATE) {
        WinError = ERROR_INVALID_SERVER_STATE;
    } else if (NtStatus == STATUS_UNSUCCESSFUL) {
        WinError = ERROR_DS_NOT_INSTALLED;
    } else {
        WinError = RtlNtStatusToDosError(NtStatus);
    }

    if ( WinError != ERROR_SUCCESS )
    {
        if ( ERROR_DOMAIN_EXISTS == WinError )
        {
            //
            // This is the special case of backing up/restoring a DC
            // improperly.  See bug 194633
            //
            NTDSP_SET_ERROR_MESSAGE0( WinError,
                                      DIRMSG_DOMAIN_SID_EXISTS );
        }
        else
        {
            //
            // This must have been a resource error
            //
            NTDSP_SET_ERROR_MESSAGE0( WinError,
                                      DIRMSG_INSTALL_SAM_FAILED );
        }
        goto Cleanup;
    }

    // Remember to undo if necessary
    DiscoveredInfo->UndoFlags |= NTDSP_UNDO_UNDO_SAM;

    if ( WinError == ERROR_SUCCESS )
    {

        //
        // SamIPromote will unload any hives that are loaded
        //
        fDownlevelHiveLoaded = FALSE;

        WinError = NtdspGetNewDomainGuid( &DiscoveredInfo->NewDomainGuid,
                                          &DiscoveredInfo->NewDomainSid );

    }
    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }


    //
    // At this point all the DS and SAM data that we need to boot
    // should exist, either by replication or otherwise.  Verify this.
    //
    WinError = NtdspSanityCheckLocalData( UserInstallInfo->Flags );
    if ( ERROR_SUCCESS != WinError )
    {
        // The above routine should set a message
        Assert( NtdspErrorMessageSet() );
        goto Cleanup;
    }

    WinError = NtdspAddDomainAdminAccessToServer( UserInstallInfo,
                                                  DiscoveredInfo );

    if ( ERROR_SUCCESS != WinError )
    {
        if ( DiscoveredInfo->LocalServerDn ) {
            
            LogEvent8WithData( DS_EVENT_CAT_SETUP,
                               DS_EVENT_SEV_ALWAYS,
                               DIRLOG_CANT_APPLY_SERVER_SECURITY,
                               szInsertWC(DiscoveredInfo->LocalServerDn), NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               sizeof(DWORD), &WinError );
        }
        WinError = ERROR_SUCCESS;
    }

Cleanup:

    if ( ERROR_CANCELLED == WinError ) {

        NTDSP_SET_ERROR_MESSAGE0( WinError,
                                  DIRMSG_NTDSETUP_CANCELLED );

    }

    if ( fRestoreDnsDomainInfo )
    {
        IgnoreStatus = LsarSetInformationPolicy( hPolicyObject,
                                                 PolicyDnsDomainInformation,
                                                 (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
        ASSERT( NT_SUCCESS( IgnoreStatus ) );
    }

    if ( fDownlevelHiveLoaded )
    {
        IgnoreStatus = SamIUnLoadDownlevelDatabase( NULL );
        ASSERT( NT_SUCCESS( IgnoreStatus ) );
    }

    if ( AccountDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) AccountDomainInfo );

        RtlZeroMemory( &NewPrimaryDomainInfo, sizeof(NewPrimaryDomainInfo) );
    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }

    if ( NewPrimaryDomainInfo.Sid )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NewPrimaryDomainInfo.Sid );
    }


    if ( INVALID_HANDLE_VALUE != hPolicyObject )
    {
        LsarClose( &hPolicyObject );
    }

    return WinError;

}

DWORD
NtdspSetReplicationCredentials(
    IN PNTDS_INSTALL_INFO UserInstallInfo
    )
/*++

Routine Description:


Parameters:

    UserInstallInfo: pointer to the user parameters

Return Values:

    ERROR_SUCCESS, winerror from ldap otherwise

Notes:

--*/
{
    //
    // This assumes that we are in process, and calls the replication client
    // library directly
    //

    DWORD WinError;

    WCHAR *Domain = NULL, *User = NULL, *Password = NULL;
    ULONG  Length, Index, PasswordLength = 0;
    HANDLE ClientToken = 0;

    ASSERT( UserInstallInfo );

    if ( UserInstallInfo->Credentials )
    {
        User = UserInstallInfo->Credentials->User;
        Domain = UserInstallInfo->Credentials->Domain;
        Password = UserInstallInfo->Credentials->Password;
        PasswordLength = UserInstallInfo->Credentials->PasswordLength;
        ClientToken = UserInstallInfo->ClientToken;
    }

    //
    // DirReplicaSetCredentials returns winerror's
    //
    WinError = DirReplicaSetCredentials(ClientToken,
                                        User,
                                        Domain,
                                        Password,
                                        PasswordLength);

    ASSERT(0 == WinError);

    return WinError;

}


NTSTATUS
NtdspRegistryDelnode(
    IN WCHAR*  KeyPath
    )
/*++

Routine Description

    This routine recursively deletes the registry key starting at
    and including KeyPath.


Parameters

    KeyPath, null-terminating string

Return Values

    STATUS_SUCCESS or STATUS_NO_MEMORY; system service error otherwise

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    HANDLE            KeyHandle = 0;
    OBJECT_ATTRIBUTES KeyObject;
    UNICODE_STRING    KeyUnicodeName;

    #define EXPECTED_NAME_SIZE  32

    BYTE    Buffer1[sizeof(KEY_FULL_INFORMATION) + EXPECTED_NAME_SIZE];
    PKEY_FULL_INFORMATION FullKeyInfo = (PKEY_FULL_INFORMATION)&Buffer1[0];
    ULONG   FullKeyInfoSize = sizeof(Buffer1);
    BOOLEAN FullKeyInfoAllocated = FALSE;

    PKEY_BASIC_INFORMATION BasicKeyInfo = NULL;
    BOOLEAN                BasicKeyInfoAllocated = FALSE;

    WCHAR                  *SubKeyName = NULL;
    ULONG                  SubKeyNameSize = 0;

    WCHAR                  **SubKeyNameArray = NULL;
    ULONG                  SubKeyNameArrayLength = 0;

    ULONG                  Index;

    if (!KeyPath) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory(&Buffer1, sizeof(Buffer1));

    //
    // Open the root key
    //
    RtlInitUnicodeString(&KeyUnicodeName, KeyPath);
    InitializeObjectAttributes(&KeyObject,
                               &KeyUnicodeName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&KeyHandle,
                         KEY_ALL_ACCESS,
                         &KeyObject);

    if (!NT_SUCCESS(NtStatus)) {

        return NtStatus;

    }

    //
    // Get the number of subkeys
    //
    NtStatus = NtQueryKey(KeyHandle,
                         KeyFullInformation,
                         FullKeyInfo,
                         FullKeyInfoSize,
                         &FullKeyInfoSize);

    if (STATUS_BUFFER_OVERFLOW == NtStatus ||
        STATUS_BUFFER_TOO_SMALL == NtStatus) {

       FullKeyInfo = RtlAllocateHeap(RtlProcessHeap(),
                                     0,
                                     FullKeyInfoSize);
        if (!FullKeyInfo) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        FullKeyInfoAllocated = TRUE;

        NtStatus = NtQueryKey(KeyHandle,
                              KeyFullInformation,
                              FullKeyInfo,
                              FullKeyInfoSize,
                              &FullKeyInfoSize);

    }

    if (!NT_SUCCESS(NtStatus)) {

        goto Cleanup;

    }

    //
    // Make an array for the sub key names - this has to be recorded before
    // any are deleted.
    //
    SubKeyNameArrayLength = FullKeyInfo->SubKeys;
    SubKeyNameArray = RtlAllocateHeap(RtlProcessHeap(),
                                      0,
                                      SubKeyNameArrayLength * sizeof(WCHAR*));
    if (!SubKeyNameArray) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(SubKeyNameArray,  SubKeyNameArrayLength*sizeof(WCHAR*));

    //
    // Fill the names in
    //
    for (Index = 0;
            Index < SubKeyNameArrayLength && NT_SUCCESS(NtStatus);
                Index++) {


        BYTE    Buffer2[sizeof(KEY_BASIC_INFORMATION) + EXPECTED_NAME_SIZE];
        ULONG   BasicKeyInfoSize = sizeof(Buffer2);


        BasicKeyInfo = (PKEY_BASIC_INFORMATION) &Buffer2[0];
        BasicKeyInfoAllocated = FALSE;

        RtlZeroMemory(&Buffer2, sizeof(Buffer2));

        NtStatus = NtEnumerateKey(KeyHandle,
                                  Index,
                                  KeyBasicInformation,
                                  BasicKeyInfo,
                                  BasicKeyInfoSize,
                                  &BasicKeyInfoSize);

        if (STATUS_BUFFER_OVERFLOW == NtStatus ||
            STATUS_BUFFER_TOO_SMALL == NtStatus) {

            BasicKeyInfo = RtlAllocateHeap(RtlProcessHeap(),
                                           0,
                                           BasicKeyInfoSize);
            if (!BasicKeyInfo) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            BasicKeyInfoAllocated = TRUE;


            NtStatus = NtEnumerateKey(KeyHandle,
                                      Index,
                                      KeyBasicInformation,
                                      BasicKeyInfo,
                                      BasicKeyInfoSize,
                                      &BasicKeyInfoSize);

        }

        if (NT_SUCCESS(NtStatus))  {

            //
            // Construct the key name
            //
            SubKeyNameSize  = BasicKeyInfo->NameLength
                            + (wcslen(KeyPath)*sizeof(WCHAR))
                            + sizeof(L"\\\0");

            SubKeyName = RtlAllocateHeap(RtlProcessHeap(),
                                         0,
                                         SubKeyNameSize);
            if (!SubKeyName) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlZeroMemory(SubKeyName, SubKeyNameSize);

            wcscpy(SubKeyName, KeyPath);
            wcscat(SubKeyName, L"\\");
            wcsncat(SubKeyName, BasicKeyInfo->Name, BasicKeyInfo->NameLength/sizeof(WCHAR));

            SubKeyNameArray[Index] = SubKeyName;

        }

        if (BasicKeyInfoAllocated && BasicKeyInfo) {
            RtlFreeHeap(RtlProcessHeap(), 0, BasicKeyInfo);
        }
        BasicKeyInfo = NULL;

    }

    //
    // Now that we have a record of all the subkeys we can delete them!
    //
    if (NT_SUCCESS(NtStatus)) {

        for (Index = 0; Index < SubKeyNameArrayLength; Index++) {

            NtStatus = NtdspRegistryDelnode(SubKeyNameArray[Index]);

            if (!NT_SUCCESS(NtStatus)) {

                break;

            }
        }
    }


    //
    // Delete the key!
    //
    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtDeleteKey(KeyHandle);

    }


Cleanup:

    if (SubKeyNameArray) {
        for (Index = 0; Index < SubKeyNameArrayLength; Index++) {
            if (SubKeyNameArray[Index]) {
                RtlFreeHeap(RtlProcessHeap(), 0, SubKeyNameArray[Index]);
            }
        }
        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyNameArray);
    }

    if (BasicKeyInfoAllocated && BasicKeyInfo) {
        RtlFreeHeap(RtlProcessHeap(), 0, BasicKeyInfo);
    }

    if (FullKeyInfoAllocated && FullKeyInfo) {
        RtlFreeHeap(RtlProcessHeap(), 0, FullKeyInfo);
    }

    IgnoreStatus = NtClose(KeyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return NtStatus;

}

DWORD
NtdspLdapDelnode(
    IN LDAP *hLdap,
    IN WCHAR *ObjectDn
    )
/*++

Routine Description

    This routine recursively deletes the ds object  starting at
    and including ObjectDn.

    This routine is meant for deleting objects with shallow child.
    Note that the search response is not freed until all child have
    been deleted, making this a memory intensive delnode for deep
    trees.

Parameters

    hLdap, a valid ldap handle

    ObjectDn, the root of the object to delete

Return Values

    ERROR_SUCCESS, or win32 translated ldap error

--*/
{
    DWORD WinError, LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *DistinguishedName = L"distinguishedName";
    WCHAR  *ObjectClassFilter = L"objectClass=*";
    WCHAR  *AttrArray[2];

    //
    // Parameter checks
    //
    if (!hLdap || !ObjectDn) {

        ASSERT(hLdap);
        ASSERT(ObjectDn);

        return ERROR_INVALID_PARAMETER;

    }

    AttrArray[0] = DistinguishedName;
    AttrArray[1] = NULL;

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_s(hLdap,
                              ObjectDn,
                              LDAP_SCOPE_ONELEVEL,
                              ObjectClassFilter,
                              AttrArray,
                              FALSE,  // return values, too
                              &SearchResult
                              );

    WinError = LdapMapErrorToWin32(LdapError);

    if (ERROR_SUCCESS == WinError) {

        Entry = ldap_first_entry(hLdap, SearchResult);

        while (Entry && (WinError == ERROR_SUCCESS)) {

            Attr = ldap_first_attributeW(hLdap, Entry, &BerElement);

            while (Attr && (WinError == ERROR_SUCCESS) ) {

                if (!_wcsicmp(Attr, DistinguishedName)) {

                    Values = ldap_get_values(hLdap, Entry, Attr);

                    if (Values && Values[0]) {

                        LdapError = NtdspLdapDelnode(hLdap, Values[0]);

                        WinError = LdapMapErrorToWin32(LdapError);

                    }

                }

                Attr = ldap_next_attribute(hLdap, Entry, BerElement);
            }

            Entry = ldap_next_entry(hLdap, Entry);
        }
    }

    if (ERROR_SUCCESS == WinError) {

        //
        // Ok, we should be clear to delete the root node
        //

        LdapError = ldap_delete_s(hLdap, ObjectDn);

        WinError = LdapMapErrorToWin32(LdapError);

    }

    if (SearchResult) {
        ldap_msgfree(SearchResult);
    }

    return WinError;

}

DWORD
NtdspCreateNewDCPrimaryDomainInfo(
    IN  LPWSTR FlatDomainName,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo
    )
/*++

Routine Description:

    This routine completely fills in am account domain information
    with a new sid and the primary domain name (the computer name)

Parameters:

    FlatDomainName          : the flat name of the domain

    PrimaryDomainInfo : pointer, to structure to be filled in

Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus;

    WCHAR *Name = NULL;
    ULONG Size;

    //
    // Some parameter checking
    //
    ASSERT( FlatDomainName );
    ASSERT( PrimaryDomainInfo );
    RtlZeroMemory( PrimaryDomainInfo, sizeof( POLICY_ACCOUNT_DOMAIN_INFO ) );

    // Set up the sid
    NtStatus = NtdspCreateSid( &PrimaryDomainInfo->Sid );

    if ( NT_SUCCESS( NtStatus ) )
    {
        // Set up the name
        Size = ( wcslen( FlatDomainName ) + 1 ) * sizeof(WCHAR);
        Name = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(),
                                                  0,
                                                  Size );
        if ( Name )
        {
            RtlZeroMemory( Name, Size );
            wcscpy( Name, FlatDomainName );
            RtlInitUnicodeString( &PrimaryDomainInfo->Name, Name );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    return RtlNtStatusToDosError( NtStatus );

}


DWORD
NtdspGetNewDomainGuid(
    OUT GUID *NewDomainGuid,
    OUT PSID *DomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine reads the new created domain object for its guid
    and sid, both of which should exist.

    OPTIMIZE

    N.B.  This function can be optimized by simply reading the
    guid and sid from the returned dsname.

Parameters:

    NewDomainGuid : structure to be filled in

    DomainSid     : caller must free from the process heap

Return Values:

    a value from the win32 error space

--*/
{

    NTSTATUS NtStatus;

    DWORD WinError;
    DWORD DirError;

    WCHAR     *DomainDN = NULL;
    USHORT    Length;

    READARG   ReadArg;
    READRES   *ReadRes = 0;

    ENTINFSEL                  EntryInfoSelection;
    ATTR                       Attr[2];

    DSNAME                     *DomainDsName = 0;

    ATTRBLOCK    *pAttrBlock;
    ATTR         *pAttr;
    ATTRVALBLOCK *pAttrVal;

    ULONG        i;
    ULONG        Size;

    PSID         Sid = NULL;

    try {

        //
        // Create a thread state
        //
        if (THCreate( CALLERTYPE_INTERNAL )) {

            WinError = ERROR_NOT_ENOUGH_MEMORY;
            leave;

        }

        SampSetDsa( TRUE );


        //
        // Get the root domain's dn and turn it into a dsname for the
        // read argument
        //
        RtlZeroMemory(&ReadArg, sizeof(ReadArg));

        Size = 0;
        DomainDsName = NULL;
        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         DomainDsName );
        Assert( STATUS_BUFFER_TOO_SMALL == NtStatus );
        DomainDsName = (DSNAME*) alloca( Size );
        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         DomainDsName );

        Assert( NT_SUCCESS( NtStatus ) );

        ReadArg.pObject = DomainDsName;

        //
        // Set up the selection info for the read argument
        //
        RtlZeroMemory( &EntryInfoSelection, sizeof(EntryInfoSelection) );
        EntryInfoSelection.attSel = EN_ATTSET_LIST;
        EntryInfoSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
        EntryInfoSelection.AttrTypBlock.attrCount = 2;
        EntryInfoSelection.AttrTypBlock.pAttr = &(Attr[0]);

        RtlZeroMemory(Attr, sizeof(Attr));
        Attr[0].attrTyp = ATT_OBJECT_GUID;
        Attr[1].attrTyp = ATT_OBJECT_SID;

        ReadArg.pSel    = &EntryInfoSelection;

        //
        // Setup the common arguments
        //
        InitCommarg(&ReadArg.CommArg);

        //
        // We are now ready to read!
        //
        DirError = DirRead(&ReadArg,
                           &ReadRes);

        if ( 0 == DirError ) {

            NtStatus = STATUS_SUCCESS;

            pAttrBlock = &(ReadRes->entry.AttrBlock);

            ASSERT( 2 == pAttrBlock->attrCount );

            for ( i = 0; i < pAttrBlock->attrCount; i++ )
            {
                pAttr = &(pAttrBlock->pAttr[i]);
                pAttrVal = &(pAttr->AttrVal);

                // GUID and Sid are both single valued
                ASSERT( 1 == pAttrVal->valCount );

                Size = pAttrVal->pAVal[0].valLen;

                if ( pAttr->attrTyp == ATT_OBJECT_GUID )
                {
                    ASSERT( Size == sizeof( GUID ) );
                    RtlCopyMemory( NewDomainGuid, pAttrVal->pAVal[0].pVal, Size );
                }
                else if ( pAttr->attrTyp == ATT_OBJECT_SID )
                {
                    ASSERT( Size == RtlLengthSid( pAttrVal->pAVal[0].pVal ) );

                    Sid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );
                    if ( Sid )
                    {
                        RtlCopyMemory( Sid, pAttrVal->pAVal[0].pVal, Size );
                    }
                    else
                    {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }

                }
                else
                {
                    //
                    // Something is vastly wrong
                    //
                    ASSERT( !"Domain Guid and Sid not returned" );
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

        } else {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        WinError = RtlNtStatusToDosError(NtStatus);

    }
    finally
    {
        THDestroy();
    }

    if ( DomainSid )
    {
        *DomainSid = Sid;
    }

    return( WinError );

}

DWORD
NtdspCreateLocalAccountDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo,
    OUT LPWSTR                      *NewAdminPassword
    )
/*++

Routine Description:

    This routine creates a local Account Domain LSA structure
    that will be ultimately be used by SAM to construct a new
    database.

Parameters:

    AccountDomainInfo: the new account domain info

    NewAdminPassword: the admin password of the new account

Return Values:

    a value from the win32 error space

--*/
{
    NTSTATUS NtStatus;
    DWORD    WinError = ERROR_SUCCESS;

    WCHAR    ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG    ComputerNameLength = sizeof(ComputerName);

    WCHAR*   Name;
    ULONG    Size;
    ULONG    PasswordSize;

    ASSERT( AccountDomainInfo );

    //
    // Some parameter checking
    //
    ASSERT( AccountDomainInfo );
    RtlZeroMemory( AccountDomainInfo, sizeof( POLICY_ACCOUNT_DOMAIN_INFO ) );

    ASSERT( NewAdminPassword );
    *NewAdminPassword = NULL;

    // Set up the sid
    NtStatus = NtdspCreateSid( &AccountDomainInfo->DomainSid );

    if ( NT_SUCCESS( NtStatus ) )
    {
        // Set up the name
        if ( GetComputerName(ComputerName, &ComputerNameLength) )
        {

            Size = ( wcslen( ComputerName ) + 1 ) * sizeof(WCHAR);
            Name = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(),
                                             0,
                                             Size );
            if ( Name )
            {
                RtlZeroMemory( Name, Size );
                wcscpy( Name, ComputerName );
                RtlInitUnicodeString( &AccountDomainInfo->DomainName, Name );
            }
            else
            {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            WinError = GetLastError();
        }
    }
    else
    {
        WinError = RtlNtStatusToDosError( NtStatus );
    }

    // The length is arbitrary
    PasswordSize = 10 * sizeof(WCHAR);
    *NewAdminPassword = (LPWSTR) RtlAllocateHeap( RtlProcessHeap(),
                                                  0,
                                                  PasswordSize );
    if ( *NewAdminPassword )
    {
        BOOL fStatus;
        ULONG Length;
        ULONG i;

        fStatus = CDGenerateRandomBits( (PUCHAR) *NewAdminPassword,
                                        PasswordSize );
        ASSERT( fStatus );  // if false then we just get random stack noise

        // Terminate the password
        Length = PasswordSize / sizeof(WCHAR);
        (*NewAdminPassword)[Length-1] = L'\0';
        // Make sure there aren't any NULL's in the password
        for (i = 0; i < (Length-1); i++)
        {
            if ( (*NewAdminPassword)[i] == L'\0' )
            {
                // arbitrary letter
                (*NewAdminPassword)[i] = L'c';
            }
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ( ERROR_SUCCESS != WinError )
    {
        if ( AccountDomainInfo->DomainSid )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, AccountDomainInfo->DomainSid );
        }

        if ( *NewAdminPassword )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, *NewAdminPassword );
            *NewAdminPassword = NULL;
        }
    }

    return WinError;
}


DWORD
NtdspCheckBehaviorVersion( 
    IN LDAP * hLdap,
    IN DWORD flag,
    IN PNTDS_CONFIG_INFO DiscoveredInfo )

/*++

Routine Description:

    This routine check if the binary behavior version is
    compatible with the behavior versions of domain and forest.

Parameters:

    hLdap: LDAP handle
    
    flag: 
    
    DiscoveredInfo :  pointer to the discovered parameters


Return Values:

    a value from the win32 error space

--*/

{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError;
    LDAPMessage  *SearchResult;
    ULONG        NumberOfEntries = 0;
    WCHAR        *AttrsToSearch[2];

    LONG         ForestVersion = 0, DomainVersion = 0;
        
    DPRINT(2, "NtdpCheckBehaviorVersion entered\n" );
   
    
    AttrsToSearch[0] = L"msDS-Behavior-Version";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW(hLdap,
                               DiscoveredInfo->ConfigurationDN,
                               LDAP_SCOPE_ONELEVEL,
                               L"(cn=Partitions)",
                               AttrsToSearch,
                               FALSE,
                               &SearchResult);

    if (LdapError) {
        return LdapMapErrorToWin32(LdapError);
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);

    DPRINT1(3,"No of Entries returned is %d\n", NumberOfEntries);

    if (NumberOfEntries > 0) {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        Entry = ldap_first_entry(hLdap, SearchResult); 
        
        //
        // Get each attribute in the entry
        //
        for(Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                 Attr != NULL;
                     Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
        {
           //
           // Get the value of the attribute
           //
           Values = ldap_get_valuesW(hLdap, Entry, Attr);
           if ( !_wcsicmp(Attr,AttrsToSearch[0]) ) {
                ForestVersion = _wtol(Values[0]);
                ldap_value_free(Values);
                break;
           }
           ldap_value_free(Values);
        }
   
    }
    
    ldap_msgfree( SearchResult );

    if (DS_BEHAVIOR_VERSION_MIN > ForestVersion ) {

        DPRINT(2, "NtdpCheckBehaviorVersion: too old forest version.\n" );
        return ERROR_DS_FOREST_VERSION_TOO_LOW;
    }
    else if (DS_BEHAVIOR_VERSION_CURRENT < ForestVersion) {

        DPRINT(2, "NtdpCheckBehaviorVersion: too new forest version.\n" );
        return ERROR_DS_DOMAIN_VERSION_TOO_HIGH;
    }

    if ( flag & NTDS_INSTALL_DOMAIN ) {
        DPRINT(2, "NtdpCheckBehaviorVersion exits successfully.\n" );
        return ERROR_SUCCESS;
    }

    Assert(flag & NTDS_INSTALL_REPLICA);

    //search for the version of a domain
    LdapError = ldap_search_sW(hLdap,
                               DiscoveredInfo->DomainDN,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrsToSearch,
                               FALSE,
                               &SearchResult);

    if (LdapError) {
        return LdapMapErrorToWin32(LdapError);
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);

    DPRINT1(3,"No of Entries returned is %d\n", NumberOfEntries);

    if (NumberOfEntries > 0) {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        Entry = ldap_first_entry(hLdap, SearchResult);
            
        //
        // Get each attribute in the entry
        //
        for(Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                 Attr != NULL;
                      Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
        {
            //
            // Get the value of the attribute
            //
            Values = ldap_get_valuesW(hLdap, Entry, Attr);
            if ( !_wcsicmp(Attr,AttrsToSearch[0]) ) {
                DomainVersion = _wtol(Values[0]);
                ldap_value_free(Values);
                break;
            }
            ldap_value_free(Values);
        }
    }

    ldap_msgfree( SearchResult );

    if (DS_BEHAVIOR_VERSION_MIN > DomainVersion) {

        DPRINT(2, "NtdpCheckBehaviorVersion: too old domain version.\n" );
        return ERROR_DS_DOMAIN_VERSION_TOO_LOW;
    }
    else if (DS_BEHAVIOR_VERSION_CURRENT < DomainVersion) {

        DPRINT(2, "NtdpCheckBehaviorVersion: too new domain version.\n" );
        return ERROR_DS_DOMAIN_VERSION_TOO_HIGH;
    }

    
    DPRINT(2, "NtdpCheckBehaviorVersion exits successfully.\n" );
    return ERROR_SUCCESS;

}


DWORD
NtdspCheckSchemaVersion(
    IN LDAP *hLdap,
    IN WCHAR *pSchemaDN,
    OUT BOOL *fMismatch
)
/*++

Routine Description:


    This routine goes through LDAP to pick up the schema version of
    the source. It then compares the schema version in the source
    with the schema version in the schema.ini file of the build used
    for the replica setup. If no mismatch is detected, *fMisMatch is
    set to FALSE, else, it is set to TRUE

Parameters:

    LdapHandle, a valid handle to the source server

    pSchemaDN, pointer to string containing schema DN

    fMismatch, pointer to bool to be set to true if a mismatch is detected

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The check was done successfully.

--*/
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError;
    LDAPMessage  *SearchResult;
    ULONG        NumberOfEntries = 0;
    WCHAR        *AttrsToSearch[2];

    WCHAR        IniFileName[MAX_PATH];
    DWORD        SrcSchVersion = 0, NewSchVersion = 0;

    WCHAR        Buffer[32];
    WCHAR        *SCHEMASECTION = L"SCHEMA";
    WCHAR        *OBJECTVER = L"objectVersion";
    WCHAR        *DEFAULT = L"NOT_FOUND";


    // First read the schema version of the source through Ldap.
    // This is the value of the object-version attribute on the
    // schema container object. Store this value in SrcSchVersion.
    // If no object-version value is found on the source schema,
    // version is taken as 0

    AttrsToSearch[0] = OBJECTVER;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW(hLdap,
                               pSchemaDN,
                               LDAP_SCOPE_BASE,
                               L"objectClass=*",
                               AttrsToSearch,
                               FALSE,
                               &SearchResult);

    if (LdapError) {
        return LdapMapErrorToWin32(LdapError);
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);

    DPRINT1(1,"No of Entries returned is %d\n", NumberOfEntries);

    if (NumberOfEntries > 0) {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        ULONG        NumberOfAttrs, NumberOfValues, i;

        for (Entry = ldap_first_entry(hLdap, SearchResult), NumberOfEntries = 0;
                Entry != NULL;
                    Entry = ldap_next_entry(hLdap, Entry), NumberOfEntries++)
        {
            //
            // Get each attribute in the entry
            //
            for(Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                    Attr != NULL;
                       Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                //
                // Get the value of the attribute
                //
                Values = ldap_get_valuesW(hLdap, Entry, Attr);
                if ( !_wcsicmp(Attr,L"objectVersion") ) {
                    SrcSchVersion = (DWORD) _wtoi(Values[0]);
                }
             }
         }
    }

    ldap_msgfree( SearchResult );

    // Either the object-Version from source is read, or it is not present
    // in the source, or it is present but we don't have permission to read it.
    // In the latter two cases we still have the initial value of 0
    // No current DC has schema version 0, so a value of 0 at this stage
    // is an error

    if (SrcSchVersion == 0) {
        return ERROR_DS_INSTALL_NO_SRC_SCH_VERSION;
    }

    // Now read the schema version in the ini file.

    // First, form the path to the inifile. This is the schema.ini
    // in the system32 directory

    GetSystemDirectoryW(IniFileName, MAX_PATH);
    wcscat(IniFileName,L"\\schema.ini");

    GetPrivateProfileStringW(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(WCHAR),
        IniFileName
        );

    if ( wcscmp(Buffer, DEFAULT) ) {
         // Not the default string, so got a value
         NewSchVersion = _wtoi(Buffer);
    }
    else {
        // no value in the ini file. This is an error, since all builds
        // must have an objectVersion in the SCHEMA section of schema.ini

        return ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE;
    }

    // Ok, now we got both versions. Now compare and set the flag
    // accordingly. We allow installs only when the source schema version
    // is greater than or equal to the schema version in the build we are using

    if (SrcSchVersion >= NewSchVersion) {
       *fMismatch = FALSE;
    }
    else {
       *fMismatch = TRUE;
    }

    return ERROR_SUCCESS;

}


DWORD
NtdspClearDirectory(
    IN WCHAR *DirectoryName
    )
/*++

Routine Description:

    This routine deletes all the files in Directory and, then
    if the directory is empty, removes the directory.

Parameters:

    DirectoryName: a null terminated string

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The check was done successfully.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    HANDLE          FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR           Path[ MAX_PATH ];
    WCHAR           FilePath[ MAX_PATH ];
    BOOL            fStatus;

    if ( !DirectoryName )
    {
        return ERROR_SUCCESS;
    }

    if ( wcslen(DirectoryName) > MAX_PATH - 4 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory( Path, sizeof(Path) );
    wcscpy( Path, DirectoryName );
    wcscat( Path, L"\\*.*" );

    RtlZeroMemory( &FindData, sizeof( FindData ) );
    FindHandle = FindFirstFile( Path, &FindData );
    if ( INVALID_HANDLE_VALUE == FindHandle )
    {
        WinError = GetLastError();
        goto ClearDirectoryExit;
    }

    do
    {

        if (  !FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) )
        {
            RtlZeroMemory( FilePath, sizeof(FilePath) );
            wcscpy( FilePath, DirectoryName );
            wcscat( FilePath, L"\\" );
            wcscat( FilePath, FindData.cFileName );

            fStatus = DeleteFile( FilePath );

            //
            // Even if error, continue on
            //
        }

        RtlZeroMemory( &FindData, sizeof( FindData ) );

    } while ( FindNextFile( FindHandle, &FindData ) );

    WinError = GetLastError();
    if ( ERROR_NO_MORE_FILES != WinError
      && ERROR_SUCCESS != WinError  )
    {
        goto ClearDirectoryExit;
    }
    WinError = ERROR_SUCCESS;

    //
    // Fall through to the exit
    //

ClearDirectoryExit:

    if ( ERROR_NO_MORE_FILES == WinError )
    {
        WinError = ERROR_SUCCESS;
    }

    if ( INVALID_HANDLE_VALUE != FindHandle )
    {
        FindClose( FindHandle );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        //
        // Try to remove the directory
        //
        fStatus = RemoveDirectory( DirectoryName );

        //
        // Ignore the error and continue on
        //

    }

    return WinError;
}


DWORD
NtdspImpersonation(
    IN HANDLE NewThreadToken,
    IN OUT PHANDLE OldThreadToken
    )
/*++

Routine Description:

    This function handles the impersonation

Arguments:

    NewThreadToken - New thread token to be set

    OldThreadToken - Optional.  If specified, the currently used thread token is returned here

Returns:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If requested, get the current token
    //
    if ( OldThreadToken )
    {
        Status = NtOpenThreadToken( NtCurrentThread(),
                                    MAXIMUM_ALLOWED,
                                    TRUE,
                                    OldThreadToken );

        if ( Status == STATUS_NO_TOKEN )
        {
            Status = STATUS_SUCCESS;
            *OldThreadToken = NULL;
        }
    }

    //
    // Now, set the new
    //
    if ( NT_SUCCESS( Status )  )
    {
        Status = NtSetInformationThread( NtCurrentThread(),
                                         ThreadImpersonationToken,
                                         ( PVOID )&NewThreadToken,
                                         sizeof( HANDLE ) );
    }

    return( RtlNtStatusToDosError( Status ) );
}


DWORD
NtdspRemoveServer(
    IN OUT HANDLE  *DsHandle,  OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE ClientToken,
    IN PWSTR TargetServer,
    IN PWSTR DsaDn,
    IN BOOL  fDsaDn
    )
/*++

Routine Description:

    This function removes the infomoration related to DsaDn from the ds
    configuration container on TargetServer.

Arguments:

    DsHandle: if not NULL, then if the value is not NULL this is assumed to be
    a valid handle, other will open a ds handle to be returned.

    ClientToken : token of the user requesting this role change
                             
    TargetServer: the dns name of the server to contact

    DsaDn: the dn of the server to remove (this is the dn of the ntdsa object)

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   WinError = ERROR_SUCCESS;

    DSNAME  *ServerDsName;
    DSNAME  *DsaDsName;
    ULONG   Length;

    HANDLE  hDs = 0;

    ASSERT( TargetServer );
    ASSERT( DsaDn );

    Length = (ULONG)DSNameSizeFromLen( wcslen( DsaDn ) );
    DsaDsName = alloca( Length );
    memset( DsaDsName, 0, Length );
    DsaDsName->structLen = Length;
    wcscpy( DsaDsName->StringName, DsaDn );
    DsaDsName->NameLen = wcslen( DsaDn );

    if ( fDsaDn )
    {
        //
        // Trim the name by one to get the server name
        //
        ServerDsName = alloca( DsaDsName->structLen );
        memset( ServerDsName, 0, DsaDsName->structLen );
        ServerDsName->structLen = DsaDsName->structLen;
        TrimDSNameBy( DsaDsName, 1, ServerDsName );
    }
    else
    {
        ServerDsName = DsaDsName;
    }

    //
    // Sort out ds handles
    //
    if (  NULL == DsHandle
      ||  0 == *DsHandle )
    {
        // The caller wants us to open our own handle
        WinError = ImpersonateDsBindWithCredW( ClientToken,
                                               TargetServer,
                                               NULL,
                                               Credentials,
                                               &hDs );
    }
    else
    {
        // Caller have us a handle to use
        hDs = *DsHandle;
    }


    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    WinError = DsRemoveDsServer( hDs,
                                 ServerDsName->StringName,
                                 NULL,   // no domain name
                                 NULL,   // don't tell if this is the last
                                         // dc in the domain
                                 TRUE ); // commit the change
Cleanup:

    if ( 0 == DsHandle )
    {
        // Close the handle
        DsUnBind( &hDs );
    }
    else if ( 0 == *DsHandle )
    {
        if ( ERROR_SUCCESS == WinError )
        {
            *DsHandle = hDs;
        }
        else
        {
            // Don't pass back a handle on failure
            DsUnBind( &hDs );
        }
    }

    return WinError;
}


DWORD
NtdspRemoveDomain(
    IN OUT HANDLE  *DsHandle, OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,
    IN HANDLE ClientToken,
    IN PWSTR TargetServer,
    IN PWSTR DomainDn
    )
/*++

Routine Description:

    This routine removes DomainDn from the configuration container of the
    TargetServer's ds.

Arguments:

    DsHandle: if not NULL, then if the value is not NULL this is assumed to be
    a valid handle, other will open a ds handle to be returned.
    
    ClientToken: token of the user requesting this role change

    TargetServer: the dns name of the server to contact

    Domaindn: the dn of the domain to remove

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    HANDLE  hDs = 0;

    ASSERT( TargetServer );
    ASSERT( DomainDn );

    //
    // Sort out ds handles
    //
    if (  NULL == DsHandle
      ||  0 == *DsHandle )
    {
        // The caller wants us to open our own handle
        WinError = ImpersonateDsBindWithCredW( ClientToken,
                                               TargetServer,
                                               NULL,
                                               Credentials,
                                               &hDs );
    }
    else
    {
        // Caller have us a handle to use
        hDs = *DsHandle;
    }


    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    WinError = DsRemoveDsDomainW( hDs,
                                  DomainDn );

Cleanup:

    if ( 0 == DsHandle )
    {
        // Close the handle
        DsUnBind( &hDs );
    }
    else if ( 0 == *DsHandle )
    {
        if ( ERROR_SUCCESS == WinError )
        {
            *DsHandle = hDs;
        }
        else
        {
            // Don't pass back a handle on failure
            DsUnBind( &hDs );
        }
    }

    return WinError;
}


DWORD
NtdspDoesDomainExist(
    IN  LDAP              *hLdap,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo,
    IN  PWSTR              DomainDn,
    OUT BOOLEAN           *fDomainExists
    )
/*++

Routine Description:


Arguments:

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD LdapError = 0;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *DistinguishedName = L"distinguishedName";
    WCHAR  *ncName            = L"(&(!(enabled=FALSE))(ncName=";
    WCHAR  *Partitions        = L"CN=Partitions,";
    WCHAR  *ncNameFilter      = NULL;
    WCHAR  *AttrArray[2];
    ULONG  Length;
    WCHAR  *BaseDn;

    //
    // Parameter check
    //
    ASSERT( hLdap );
    ASSERT( DiscoveredInfo );
    ASSERT( DomainDn );
    ASSERT( fDomainExists );

    //
    // Assume the worst
    //
    *fDomainExists = TRUE;

    //
    // Prepare the ldap search
    //
    AttrArray[0] = DistinguishedName;
    AttrArray[1] = NULL;

    //
    // Prepare the filter
    //
    Length = wcslen( ncName ) + wcslen( DomainDn ) + 3;
    Length *= sizeof( WCHAR );
    ncNameFilter = (WCHAR*) alloca( Length );
    wcscpy( ncNameFilter, ncName );
    wcscat( ncNameFilter, DomainDn );
    wcscat( ncNameFilter, L"))" );

    //
    // Prepare the base dn
    //
    Length = wcslen( DiscoveredInfo->ConfigurationDN ) + wcslen( Partitions ) + 1;
    Length *= sizeof( WCHAR );
    BaseDn = alloca( Length );
    wcscpy( BaseDn, Partitions );
    wcscat( BaseDn, DiscoveredInfo->ConfigurationDN );

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_s(hLdap,
                              BaseDn,
                              LDAP_SCOPE_SUBTREE,
                              ncNameFilter,
                              AttrArray,
                              FALSE,  // return values, too
                              &SearchResult
                              );

    WinError = LdapMapErrorToWin32(LdapError);

    if ( ERROR_SUCCESS == WinError )
    {
        if ( 0 == ldap_count_entries( hLdap, SearchResult ) )
        {
            //
            // No such object; there is no cross ref object that
            // holds this domain name
            //
            *fDomainExists = FALSE;
        }
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    return WinError;
}


WORD
NtdspGetProcessorArchitecture(
    VOID
    )
{
    SYSTEM_INFO  SystemInfo;

    RtlZeroMemory( &SystemInfo, sizeof( SystemInfo ) );

    GetSystemInfo( &SystemInfo );

    return SystemInfo.wProcessorArchitecture;
}



DWORD
NtdspSetProductType(
    NT_PRODUCT_TYPE ProductType
    )
/*++

Routine Description:

    This function sets the product type of the server.  The machine
    should be rebooted after this point.

Arguments:

    ProductType: one of NtProductLanManNt NtProductServer NtProductWinNt

Returns:

    A system service error

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    WCHAR *ProductTypeString = NULL;
    HKEY  Key = 0;

    switch ( ProductType )
    {
        case NtProductLanManNt:
            ProductTypeString = NT_PRODUCT_LANMAN_NT;
            break;

        case NtProductServer:
            ProductTypeString = NT_PRODUCT_SERVER_NT;
            break;

        case NtProductWinNt:
            ProductTypeString = NT_PRODUCT_WIN_NT;
            break;

        default:
            return ERROR_INVALID_PARAMETER;
    }

    WinError = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                           L"System\\CurrentControlSet\\Control\\ProductOptions",
                           &Key );

    if ( ERROR_SUCCESS == WinError )
    {

        WinError = RegSetValueExW( Key,
                                   L"ProductType",
                                   0,  // reserved
                                   REG_SZ,
                                   (PVOID) ProductTypeString,
                                   (wcslen(ProductTypeString)+1)*sizeof(WCHAR));

        RegCloseKey( Key );
    }

    return WinError;

}


VOID
NtdspReleaseConfigInfo(
    IN PNTDS_CONFIG_INFO ConfigInfo
    )
//
// This routine frees the embedded resources in PNTDS_CONFIG_INFO
//
{
    if ( ConfigInfo )
    {
        if ( ConfigInfo->RidFsmoDnsName )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, ConfigInfo->RidFsmoDnsName );
        }

        if ( ConfigInfo->RidFsmoDn )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, ConfigInfo->RidFsmoDn );
        }

        if ( ConfigInfo->DomainNamingFsmoDnsName )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, ConfigInfo->DomainNamingFsmoDnsName );
        }

        if ( ConfigInfo->DomainNamingFsmoDn )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, ConfigInfo->DomainNamingFsmoDn );
        }

        if ( ConfigInfo->LocalMachineAccount )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, ConfigInfo->LocalMachineAccount );
        }

        NtdspFree( ConfigInfo->DomainDN );
        NtdspFree( ConfigInfo->RootDomainDN );
        NtdspFree( ConfigInfo->NetbiosName );
        NtdspFree( ConfigInfo->SchemaDN );
        NtdspFree( ConfigInfo->SiteName );
        NtdspFree( ConfigInfo->ConfigurationDN );
        NtdspFree( ConfigInfo->ServerDN );
        NtdspFree( ConfigInfo->RootDomainSid );
        NtdspFree( ConfigInfo->RootDomainDnsName );
        NtdspFree( ConfigInfo->TrustedCrossRef );
        NtdspFree( ConfigInfo->ParentDomainDN );

        RtlZeroMemory( ConfigInfo, sizeof(NTDS_CONFIG_INFO) );
    }
}


DWORD
NtdspGetRidFSMOInfo(
    IN LDAP *hLdap,
    IN OUT PNTDS_CONFIG_INFO ConfigInfo
    )
//
// This routine reads the dns name of rid FSMO and the guid
// of the server we are talking to
//
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *RidManagerReferenceAttr = L"rIDManagerReference";
    WCHAR        *FSMORoleOwnerAttr = L"fSMORoleOwner";
    WCHAR        *DnsHostNameAttr = L"dNSHostName";

    WCHAR        *RidManagerObject = NULL;
    WCHAR        *RidManagerDsa = NULL;
    WCHAR        *RidManagerServer = NULL;
    WCHAR        *RidManagerDnsName = NULL;

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );
    Assert( ConfigInfo );


    //
    // Read the reference to the rid manager object
    //
    AttrsToSearch[0] = RidManagerReferenceAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                ConfigInfo->DomainDN,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        DPRINT1( 0, "ldap_search_sW for rid manager reference failed with %d\n", WinError );

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                 Entry != NULL;
                     Entry = ldap_next_entry(hLdap, Entry) )
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                     Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, RidManagerReferenceAttr ) ) {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        RidManagerObject = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy( RidManagerObject, Values[0] );
                        DPRINT1( 1, "Rid Manager object is %ls\n", RidManagerObject );
                        break;
                    }
                }
             }
         }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !RidManagerObject )
    {
        WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
        goto Cleanup;
    }

    //
    // Next get the role owner
    //
    AttrsToSearch[0] = FSMORoleOwnerAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                RidManagerObject,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        DPRINT1( 0, "ldap_search_sW for rid manager reference failed with %d\n", WinError );

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                 Entry != NULL;
                     Entry = ldap_next_entry(hLdap, Entry) )
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                     Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, FSMORoleOwnerAttr ) ) {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW(hLdap, Entry, Attr);
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        RidManagerDsa = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy( RidManagerDsa, Values[0] );
                        DPRINT1( 1, "Rid FSMO owner %ls\n", RidManagerDsa );
                        break;
                    }
                }
             }
         }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !RidManagerDsa )
    {
        WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
        goto Cleanup;
    }

    //
    // Save it off!
    //
    Length = (wcslen( RidManagerDsa )+1)*sizeof(WCHAR);
    ConfigInfo->RidFsmoDn = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    if ( ConfigInfo->RidFsmoDn )
    {
        wcscpy( ConfigInfo->RidFsmoDn, RidManagerDsa );
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

     //
     // Ok, we now have the rid manager object; find its dns name
     //
     RidManagerServer = (WCHAR*) alloca( (wcslen( RidManagerDsa ) + 1) * sizeof(WCHAR) );
     if ( !NtdspTrimDn( RidManagerServer, RidManagerDsa, 1 ) )
     {
         // an error! The name must be mangled, somehow
         WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
         goto Cleanup;
     }

     AttrsToSearch[0] = DnsHostNameAttr;
     AttrsToSearch[1] = NULL;

     LdapError = ldap_search_sW(hLdap,
                                RidManagerServer,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

     if ( LDAP_SUCCESS != LdapError )
     {
         WinError = LdapMapErrorToWin32(LdapError);
         DPRINT1( 0, "ldap_search_sW for rid fsmo dns name failed with %d\n", WinError );
         goto Cleanup;
     }

     NumberOfEntries = ldap_count_entries( hLdap, SearchResult );
     if ( NumberOfEntries > 0 )
     {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(hLdap, Entry))
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, DnsHostNameAttr ) )
                {

                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                         //
                         // Found it - these are NULL-terminated strings
                         //
                         Length = wcslen( Values[0] );
                         RidManagerDnsName = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                         wcscpy( RidManagerDnsName, Values[0] );
                         DPRINT1( 1, "Rid FSMO owner %ls\n", RidManagerDnsName );
                         break;
                    }
                }
            }
        }
    }

     ldap_msgfree( SearchResult );
     SearchResult = NULL;

     if ( RidManagerDnsName )
     {
         //
         // We found it!
         //
         Length = (wcslen( RidManagerDnsName )+1) * sizeof(WCHAR);
         ConfigInfo->RidFsmoDnsName = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(), 0, Length );
         if ( ConfigInfo->RidFsmoDnsName )
         {
             wcscpy( ConfigInfo->RidFsmoDnsName, RidManagerDnsName );
         }
         else
         {
             WinError = ERROR_NOT_ENOUGH_MEMORY;
             goto Cleanup;
         }
     }
     else
     {
         // couldn't find it
         WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
         goto Cleanup;
     }

Cleanup:

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    return WinError;
}


BOOL
NtdspTrimDn(
    IN WCHAR* Dst,  // must be preallocated
    IN WCHAR* Src,
    IN ULONG  NumberToWhack
    )
//
// This function whacks NumberToWhack components from Src and puts the
// result into Dst.  Dst should be preallocated to have the same number of
// bytes as Src.
//
{

    ULONG  Size;
    DSNAME *srcDsName, *dstDsName;
    WCHAR  *SiteName, *Terminator;

    // Parameter check
    Assert( Dst );
    Assert( Src );

    if ( NumberToWhack < 1 )
    {
        wcscpy( Dst, Src );
        return TRUE;
    }

    //
    // Create the dsname structures
    //
    Size = (ULONG)DSNameSizeFromLen( wcslen(Src) );

    srcDsName = (DSNAME*) alloca( Size );
    RtlZeroMemory( srcDsName, Size );
    srcDsName->structLen = Size;

    dstDsName = (DSNAME*) alloca( Size );
    RtlZeroMemory( dstDsName, Size );
    dstDsName->structLen = Size;

    srcDsName->NameLen = wcslen( Src );
    wcscpy( srcDsName->StringName, Src );

    if ( TrimDSNameBy( srcDsName, NumberToWhack, dstDsName ) )
    {
        // This is a failure - the names must be very funny
        return FALSE;
    }

    //
    // Ok - copy the destination string
    //
    wcscpy( Dst, dstDsName->StringName );

    return TRUE;
}


DWORD
NtdspGetSourceServerGuid(
    IN LDAP *hLdap,
    IN OUT PNTDS_CONFIG_INFO ConfigInfo
    )
//
// This routine reads the guid of the source server object
//
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *GuidAttr = L"objectGUID";

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;
    BOOL          fFound = FALSE;


    // Parameter check
    Assert( hLdap );
    Assert( ConfigInfo );

    //
    // Read the reference to the rid manager object
    //
    AttrsToSearch[0] = GuidAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                ConfigInfo->ServerDN,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        DPRINT1( 0, "ldap_search_sW for serverdn reference failed with %d\n", WinError );

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries( hLdap, SearchResult );
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        BerElement  *pBerElement;
        PLDAP_BERVAL *BerValues;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                 Entry != NULL;
                     Entry = ldap_next_entry(hLdap, Entry) )
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                     Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, GuidAttr ) )
                {
                    BerValues = ldap_get_values_lenW( hLdap, Entry, Attr );

                    if (   BerValues
                        && BerValues[0]
                        && (BerValues[0]->bv_len == sizeof(GUID)) )
                    {
                        memcpy( &ConfigInfo->ServerGuid, BerValues[0]->bv_val, sizeof(GUID) );
                        fFound = TRUE;
                        break;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !fFound )
    {
        WinError = ERROR_DS_NO_REQUESTED_ATTS_FOUND;
    }

Cleanup:

    return WinError;
}

VOID*
NtdspAlloc(
    SIZE_T Size
    )
{
    return RtlAllocateHeap( RtlProcessHeap(), 0, Size );
}

VOID*
NtdspReAlloc(
    VOID *p,
    SIZE_T Size
    )
{
    return RtlReAllocateHeap( RtlProcessHeap(), 0, p, Size );
}

VOID
NtdspFree(
    VOID *p
    )
{
    if ( p )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, p );
    }
}


DWORD
NtdspCreateServerObject(
    IN LDAP  *hLdap,
    IN LPWSTR RemoteServerName,
    IN NTDS_CONFIG_INFO *DiscoveredInfo,
    IN WCHAR *ServerDistinguishedName
    )
/*++

Routine Description:

    This routine create a server object

Arguments:

    hLdap: a valid ldap handle

    RemoteServerName: the name of the server that hLdap is for

    DiscoveredInfo: the info collected during install

    ServerDistinguishedName: the name of the object to create

Returns:

    ERROR_SUCCESS; network error otherwise

--*/
{
    DWORD WinError  = ERROR_SUCCESS;
    ULONG LdapError = LDAP_SUCCESS;

    LPWSTR ObjectClassValue1 = L"server";
    LPWSTR ObjectClassValues[] = {ObjectClassValue1, 0};
    LDAPModW ClassMod = {LDAP_MOD_ADD, L"objectclass", ObjectClassValues};

    ULONG SystemFlags = FLAG_CONFIG_ALLOW_RENAME | FLAG_CONFIG_ALLOW_LIMITED_MOVE;
    WCHAR Buffer[32];
    LPWSTR SystemFlagsValue1 = _itow( SystemFlags, Buffer, 16 );
    LPWSTR SystemFlagsValues[] = { SystemFlagsValue1, 0 };
    LDAPModW SystemValueMod = {LDAP_MOD_ADD, L"systemflags", SystemFlagsValues};

    LPWSTR ServerReferenceValue1 = DiscoveredInfo->LocalMachineAccount;
    LPWSTR ServerReferenceValues[] = {ServerReferenceValue1, 0};
    LDAPModW ServerReferenceValue = {LDAP_MOD_ADD, L"serverReference", ServerReferenceValues};

    LDAPModW *Attrs[] =
    {
        &ClassMod,
        &SystemValueMod,
        &ServerReferenceValue,  // Before you remove this, see the check below
        0
    };

    Assert( hLdap );
    Assert( DiscoveredInfo );
    Assert( ServerDistinguishedName );

    if ( !DiscoveredInfo->LocalMachineAccount )
    {
        // If there is no value, don't set it
        Attrs[2] = NULL;
    }

    LdapError = ldap_add_sW( hLdap,
                             ServerDistinguishedName,
                             Attrs );

    WinError = LdapMapErrorToWin32( LdapError );

    if ( ERROR_SUCCESS != WinError )
    {
        NTDSP_SET_ERROR_MESSAGE2( WinError,
                                  DIRLOG_FAILED_TO_CREATE_EXTN_OBJECT,
                                  ServerDistinguishedName,
                                  RemoteServerName );
    }

    return WinError;
}



DWORD
NtdspUpdateServerReference(
    IN LDAP  *hLdap,
    IN PNTDS_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This routine write the server reference property on the server object
    of the machine that is being installed.

Arguments:

    hLdap: a valid ldap handle

    ConfigInfo  : data collected during ntdsinstall

Returns:

    ERROR_SUCCESS; network error otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD LdapError = LDAP_SUCCESS;

    LPWSTR ServerReferenceValue1 = ConfigInfo->LocalMachineAccount;
    LPWSTR ServerReferenceValues[] = {ServerReferenceValue1, 0};
    LDAPModW ServerReferenceValue = {LDAP_MOD_ADD, L"serverReference", ServerReferenceValues};

    LDAPModW *Attrs[] =
    {
        &ServerReferenceValue,
        0
    };

    Assert( hLdap );
    Assert( ConfigInfo );

    if ( !ConfigInfo->LocalMachineAccount )
    {
        // Strange - we don't have the machine account; oh this is not fatal
        return ERROR_NO_TRUST_SAM_ACCOUNT;
    }

    LdapError = ldap_modify_sW( hLdap,
                                ConfigInfo->LocalServerDn,
                                Attrs );


    if ( LDAP_ATTRIBUTE_OR_VALUE_EXISTS == LdapError )
    {
        // The value already exists; replace the value then
        ServerReferenceValue.mod_op = LDAP_MOD_REPLACE;

        LdapError = ldap_modify_sW( hLdap,
                                    ConfigInfo->LocalServerDn,
                                    Attrs );

    }

    WinError = LdapMapErrorToWin32( LdapError );

    if ( ERROR_SUCCESS != WinError )
    {
        DPRINT1( 0, "Setting the server reference failed with %d\n", WinError );
    }

    return WinError;
}


DWORD
NtdspGetDomainFSMOInfo(
    IN LDAP *hLdap,
    IN OUT PNTDS_CONFIG_INFO ConfigInfo,
    IN BOOL *FSMOMissing
    )
//
// This routine reads the dns name of Domain Naming FSMO
//
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *PartitionsRdn = L"CN=Partitions,";

    WCHAR        *PartitionsDn = NULL;
    WCHAR        *FSMORoleOwnerAttr = L"fSMORoleOwner";
    WCHAR        *DnsHostNameAttr = L"dNSHostName";

    WCHAR        *RidManagerObject = NULL;
    WCHAR        *RidManagerDsa = NULL;
    WCHAR        *RidManagerServer = NULL;
    WCHAR        *RidManagerDnsName = NULL;

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );
    Assert( ConfigInfo );

    *FSMOMissing = FALSE;

    Length =  (wcslen( ConfigInfo->ConfigurationDN )
            + wcslen( PartitionsRdn )
            + 1) * sizeof(WCHAR);

    PartitionsDn = (WCHAR*)alloca( Length );

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigInfo->ConfigurationDN );
    //
    // Next get the role owner
    //
    AttrsToSearch[0] = FSMORoleOwnerAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                PartitionsDn,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        DPRINT1( 0, "ldap_search_sW for Domain Naming FSMO failed with %d\n", WinError );

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                 Entry != NULL;
                     Entry = ldap_next_entry(hLdap, Entry) )
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                     Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, FSMORoleOwnerAttr ) ) {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW(hLdap, Entry, Attr);
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        RidManagerDsa = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy( RidManagerDsa, Values[0] );
                        if (IsMangledRDNExternal(RidManagerDsa,wcslen(RidManagerDsa),NULL)) {
                            WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
                            *FSMOMissing = TRUE;
                            NTDSP_SET_ERROR_MESSAGE0( WinError,
                                                      DIRMSG_INSTALL_FAILED_IMPROPERLY_DELETED_DOMAIN_FSMO );
                            goto Cleanup;
                        }
                        DPRINT1( 1, "Domain Naming FSMO owner %ls\n", RidManagerDsa );
                        break;
                    }
                }
             }
         }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !RidManagerDsa )
    {
        WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
        goto Cleanup;
    }

    //
    // Save it off!
    //
    Length = (wcslen( RidManagerDsa )+1)*sizeof(WCHAR);
    ConfigInfo->DomainNamingFsmoDn = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    if ( ConfigInfo->DomainNamingFsmoDn )
    {
        wcscpy( ConfigInfo->DomainNamingFsmoDn, RidManagerDsa );
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

     //
     // Ok, we now have the rid manager object; find its dns name
     //
     RidManagerServer = (WCHAR*) alloca( (wcslen( RidManagerDsa ) + 1) * sizeof(WCHAR) );
     if ( !NtdspTrimDn( RidManagerServer, RidManagerDsa, 1 ) )
     {
         // an error! The name must be mangled, somehow
         WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
         goto Cleanup;
     }

     AttrsToSearch[0] = DnsHostNameAttr;
     AttrsToSearch[1] = NULL;

     LdapError = ldap_search_sW(hLdap,
                                RidManagerServer,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

     if ( LDAP_SUCCESS != LdapError )
     {
         WinError = LdapMapErrorToWin32(LdapError);
         DPRINT1( 0, "ldap_search_sW for domain naming fsmo dns name failed with %d\n", WinError );
         goto Cleanup;
     }

     NumberOfEntries = ldap_count_entries( hLdap, SearchResult );
     if ( NumberOfEntries > 0 )
     {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(hLdap, Entry))
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, DnsHostNameAttr ) )
                {

                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                         //
                         // Found it - these are NULL-terminated strings
                         //
                         Length = wcslen( Values[0] );
                         RidManagerDnsName = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                         wcscpy( RidManagerDnsName, Values[0] );
                         DPRINT1( 1, "Domain Naming FSMO owner %ls\n", RidManagerDnsName );
                         break;
                    }
                }
            }
        }
    }

     ldap_msgfree( SearchResult );
     SearchResult = NULL;

     if ( RidManagerDnsName )
     {
         //
         // We found it!
         //
         Length = (wcslen( RidManagerDnsName )+1) * sizeof(WCHAR);
         ConfigInfo->DomainNamingFsmoDnsName = (WCHAR*) RtlAllocateHeap( RtlProcessHeap(), 0, Length );
         if ( ConfigInfo->DomainNamingFsmoDnsName )
         {
             wcscpy( ConfigInfo->DomainNamingFsmoDnsName, RidManagerDnsName );
         }
         else
         {
             WinError = ERROR_NOT_ENOUGH_MEMORY;
             goto Cleanup;
         }
     }
     else
     {
         // couldn't find it
         WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
         goto Cleanup;
     }

Cleanup:

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    return WinError;
}


DWORD
NtdspDoesDomainExistEx(
    IN  LDAP              *hLdap,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo,
    IN  PWSTR              DomainDn,
    OUT BOOLEAN           *fDomainExists,
    OUT BOOLEAN           *fEnabled
    )
/*++

Routine Description:


Arguments:

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD LdapError = 0;

    LDAPMessage  *SearchResult = NULL;

    LDAPMessage *Entry;
    WCHAR       *Attr;
    WCHAR       **Values;
    BerElement  *pBerElement;

    WCHAR  *EnabledAttr       = L"enabled";
    WCHAR  *ncName            = L"(ncName=";
    WCHAR  *Partitions        = L"CN=Partitions,";
    WCHAR  *ncNameFilter      = NULL;
    WCHAR  *AttrArray[2];
    ULONG  Length;
    WCHAR  *BaseDn;

    //
    // Parameter check
    //
    ASSERT( hLdap );
    ASSERT( DiscoveredInfo );
    ASSERT( DomainDn );
    ASSERT( fDomainExists );
    ASSERT( fEnabled );

    //
    // Assume the worst
    //
    *fDomainExists = TRUE;
    *fEnabled      = TRUE;

    //
    // Prepare the ldap search
    //
    AttrArray[0] = EnabledAttr;
    AttrArray[1] = NULL;

    //
    // Prepare the filter
    //
    Length = wcslen( ncName ) + wcslen( DomainDn ) + 3;
    Length *= sizeof( WCHAR );
    ncNameFilter = (WCHAR*) alloca( Length );
    wcscpy( ncNameFilter, ncName );
    wcscat( ncNameFilter, DomainDn );
    wcscat( ncNameFilter, L")" );

    //
    // Prepare the base dn
    //
    Length = wcslen( DiscoveredInfo->ConfigurationDN ) + wcslen( Partitions ) + 1;
    Length *= sizeof( WCHAR );
    BaseDn = alloca( Length );
    wcscpy( BaseDn, Partitions );
    wcscat( BaseDn, DiscoveredInfo->ConfigurationDN );

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_s(hLdap,
                              BaseDn,
                              LDAP_SCOPE_SUBTREE,
                              ncNameFilter,
                              AttrArray,
                              FALSE,  // return values, too
                              &SearchResult
                              );

    WinError = LdapMapErrorToWin32(LdapError);

    if ( ERROR_SUCCESS == WinError )
    {
        if ( 0 == ldap_count_entries( hLdap, SearchResult ) )
        {
            //
            // No such object; there is no cross ref object that
            // holds this domain name
            //
            *fDomainExists = FALSE;
            *fEnabled      = FALSE;
        }
        else
        {
            //
            // The cross ref exists - is it enabled?
            //

            for ( Entry = ldap_first_entry(hLdap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(hLdap, Entry))
            {
                for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, EnabledAttr ) )
                    {
                        Values = ldap_get_valuesW( hLdap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                             //
                             // Found it - these are NULL-terminated strings
                             //
                             if ( !_wcsicmp( Values[0], L"false" ) )
                             {
                                 *fEnabled = FALSE;
                             }
                             break;
                        }
                    }
                }
            }
        }
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    return WinError;
}



DWORD
NtdspGetRootDomainSid(
    IN LDAP  *hLdap,
    IN PNTDS_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This routine queries the remote server to get the sid of the root domain

Arguments:

    hLdap: a valid ldap handle

    ConfigInfo: the standard operational attributes

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD LdapError = 0;

    LDAPMessage  *SearchResult = NULL;

    LDAPMessage *Entry;
    WCHAR       *Attr;
    BerElement  *pBerElement;

    WCHAR  *ncNameAttr        = L"ncName";
    WCHAR  *dnsRootAttr       = L"dnsRoot";
    WCHAR  *ncName            = L"(ncName=";
    WCHAR  *Partitions        = L"CN=Partitions,";
    WCHAR  *ncNameFilter      = NULL;
    WCHAR  *AttrArray[] = {ncNameAttr, dnsRootAttr, 0};
    ULONG  Length;
    WCHAR  *BaseDn;
    LPWSTR DomainDn = ConfigInfo->RootDomainDN;
    LDAPControlW ServerControls;
    LDAPControlW *ServerControlsArray[] = {&ServerControls, 0};

    PSID     RootDomainSid = NULL;
    LPWSTR   RootDomainDnsName = NULL;

    // Parameter check
    Assert( hLdap );
    Assert( ConfigInfo );
    Assert( ConfigInfo->ConfigurationDN );
    Assert( ConfigInfo->RootDomainDN )

    // Search the partitions container for the cross ref
    // with the NC-Name of ConfigInfo->RootDomainDN and ask for the
    // extended attribute of NC-Name so we get the sid

    //
    // Setup the control
    //
    RtlZeroMemory( &ServerControls, sizeof(ServerControls) );
    ServerControls.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    // no data for ServerControls.ldctl_value

    // N.B.  We may be installing from beta2 servers and while the root domain
    // sid is not required (avialable on post beta2 servers), the ds install
    // now requires the root domain dns name which _is_ available on beta2
    // servers
    ServerControls.ldctl_iscritical = FALSE;

    //
    // Prepare the filter
    //
    Length = wcslen( ncName ) + wcslen( DomainDn ) + 3;
    Length *= sizeof( WCHAR );
    ncNameFilter = (WCHAR*) alloca( Length );
    wcscpy( ncNameFilter, ncName );
    wcscat( ncNameFilter, DomainDn );
    wcscat( ncNameFilter, L")" );

    //
    // Prepare the base dn
    //
    Length = wcslen( ConfigInfo->ConfigurationDN ) + wcslen( Partitions ) + 1;
    Length *= sizeof( WCHAR );
    BaseDn = alloca( Length );
    wcscpy( BaseDn, Partitions );
    wcscat( BaseDn, ConfigInfo->ConfigurationDN );

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_ext_sW(hLdap,
                                   BaseDn,
                                   LDAP_SCOPE_SUBTREE,
                                   ncNameFilter,
                                   AttrArray,
                                   FALSE,  // return values, too
                                   ServerControlsArray,
                                   NULL,                 // no client controls
                                   NULL, // no timeout
                                   0xffffffff, // size limit
                                   &SearchResult
                                  );

    WinError = LdapMapErrorToWin32(LdapError);

    if ( ERROR_SUCCESS == WinError )
    {
        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(hLdap, Entry))
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, ncNameAttr ) )
                {
                    WCHAR **Values;

                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        WCHAR *SidStart;
                        WCHAR *SidEnd;

                        //
                        // Extract the sid portion and then convert to
                        // binary
                        //

                        SidStart = wcsstr( Values[0], SidPrefix );
                        if ( SidStart )
                        {
                            SidStart += wcslen(SidPrefix);
                            SidEnd = wcsstr( SidStart, L">" );
                            if ( SidEnd )
                            {
                                *SidEnd = L'\0';
                                NtdspSidStringToBinary( SidStart, &RootDomainSid );
                                *SidEnd = L'>';
                            }
                        }
                    }
                }
                else if ( !_wcsicmp( Attr, dnsRootAttr ) )
                {

                    WCHAR **Values;

                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        RootDomainDnsName = (WCHAR*)NtdspAlloc( (Length+1) * sizeof(WCHAR) );
                        if ( RootDomainDnsName )
                        {
                            wcscpy( RootDomainDnsName, Values[0] );
                        }
                    }
                }
            }
        }
    }

    //
    // If we found the values, then copy it to ConfigInfo
    //
    if ( RootDomainSid )
    {
        ConfigInfo->RootDomainSid = RootDomainSid;
        RootDomainSid = NULL;
    }
    else
    {
        // We didn't find the attribute
        WinError = ERROR_DS_MISSING_REQUIRED_ATT;
    }

    if ( RootDomainDnsName )
    {
        ConfigInfo->RootDomainDnsName = RootDomainDnsName;
        RootDomainDnsName = NULL;
    }
    else
    {
        // We didn't find the attribute
        WinError = ERROR_DS_MISSING_REQUIRED_ATT;
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    if ( RootDomainDnsName )
    {
        NtdspFree( RootDomainDnsName );
    }

    if ( RootDomainSid )
    {
        NtdspFree( RootDomainSid );
    }

    return WinError;
}

BOOL
NtdspTranslateStringByte(
    IN  WCHAR *str,
    OUT UCHAR *b
    )
//
// This routine translates str which is a hex string to its binary
// representation.  So if str == "f1" the value of *b would be set to 0xf1
// This function assumes the value contained str can be represented within
// a UCHAR.  This function returns if the value can't be translated
//
{
    BOOL fStatus = TRUE;
    WCHAR *temp;
    ULONG Power;
    UCHAR retSum = 0;

    // init the return value
    *b = 0;

    // boundary case
    if ( !str ) {
        return TRUE;
    }

    if ( wcslen(str) > 2) {
        // too big
        return FALSE;
    }

    for ( temp = str, Power = wcslen(str) - 1;
            *temp != L'\0';
                temp++, Power--) {

        WCHAR c = *temp;
        UCHAR value;

        if ( c >= L'a' && c <= L'f' ) {
            value = (UCHAR) (c - L'a') + 10;
        } else if ( c >= L'0' && c <= L'9' ) {
            value = (UCHAR) c - L'0';
        } else {
            // bogus value
            fStatus = FALSE;
            break;
        }

        if ( Power > 0 ) {
            retSum += (UCHAR) (Power*16) * value;
        } else {
            retSum += (UCHAR) value;
        }
    }

    // send the value back
    if ( fStatus) {
        *b = retSum;
    }

    return fStatus;

}


VOID
NtdspSidStringToBinary(
    IN WCHAR *SidString,
    IN PSID  *RootDomainSid
    )
/*++

Routine Description:

    Converts a hex-string representation of a sid to binary

Arguments:

    SidString - a sid in string form where
    hLdap: a valid ldap handle

    ConfigInfo: the standard operational attributes

Returns:

    ERROR_SUCCESS - Success

--*/
{
    ULONG i;
    BYTE *ByteArray;
    ULONG StringSidLen;
    ULONG BinarySidLen;

    Assert( SidString );
    Assert( RootDomainSid );

    // Init the return value
    *RootDomainSid = NULL;

    // There are two characters for each byte; the string sid length
    // must be even
    StringSidLen = wcslen( SidString );
    if ( (StringSidLen % 2) != 0) {
        Assert( FALSE && "Invalid sid" );
        return;
    }

    BinarySidLen = StringSidLen / 2;
    // Allocate space for the binary sid
    ByteArray = (BYTE*) NtdspAlloc( BinarySidLen );
    if ( !ByteArray ) {
        return;
    }
    RtlZeroMemory( ByteArray, BinarySidLen );

    // Generate the binary sid
    for ( i  = 0; i < BinarySidLen; i++ ) {

        BOOL fStatus;
        WCHAR str[] = L"00";

        str[0] = SidString[i*2];
        str[1] = SidString[(i*2)+1];

        fStatus = NtdspTranslateStringByte( str, &ByteArray[i] );
        if ( !fStatus ) {
            Assert( "Bad Sid" );
            NtdspFree( ByteArray );
            return;
        }
    }

    // Set the return value
    *RootDomainSid = (PSID) ByteArray;

    Assert( RtlValidSid( *RootDomainSid ) );
    if ( !RtlValidSid( *RootDomainSid ) )
    {
        NtdspFree( *RootDomainSid );
        *RootDomainSid = NULL;
    }

    return;
}


DWORD
NtdspGetRootDomainConfigInfo(
    IN PNTDS_INSTALL_INFO UserInstallInfo,
    IN PNTDS_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This routine sets the root domain fields of ConfigInfo so they will we set
    in the registry later on.  The information is simply taken from UserInstallInfo
    and the LSA.  Note: this function should only be called for an enterprise
    DC install.

Arguments:

    UserInstallInfo:  user provided info

    ConfigInfo     :  derived info

Returns:

    ERROR_SUCCESS - Success; resource error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ULONG Length;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO  PrimaryDomainInfo = NULL;
    LPWSTR RootDomainDnsName = NULL;
    PSID   RootDomainSid = NULL;
    PSID   Sid = NULL;

    Assert( ConfigInfo );
    Assert( UserInstallInfo );
    Assert( UserInstallInfo->DnsDomainName );

    //
    // We have to get the root domain sid and domain name
    //
    if ( FLAG_ON(UserInstallInfo->Flags, NTDS_INSTALL_UPGRADE) ) {

        //
        // On upgrade query the primary domain information since
        // at this point we are a member server in that domain and
        // the "root domain" sid is the sid of the domain that we
        // are upgrading.
        //
        NtStatus = LsaIQueryInformationPolicyTrusted(
                          PolicyPrimaryDomainInformation,
                          (PLSAPR_POLICY_INFORMATION*) &PrimaryDomainInfo );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            goto Cleanup;
        }

        Sid = PrimaryDomainInfo->Sid;

        // This is an upgrade there must be a sid
        Assert( Sid );
        
    } else {

        //
        // In the fresh install case the "root domain" sid is the sid
        // of the new domain we are creating which comes the local
        // account database.  The sid for this is stored in the account
        // domain database.
        //
        NtStatus = LsaIQueryInformationPolicyTrusted(
                          PolicyAccountDomainInformation,
                          (PLSAPR_POLICY_INFORMATION*) &AccountDomainInfo );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            goto Cleanup;
        }

        Sid = AccountDomainInfo->DomainSid;
        Assert( Sid );

    }

    Length = RtlLengthSid( Sid );
    RootDomainSid = NtdspAlloc( Length );
    if ( !RootDomainSid )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlCopySid( Length, RootDomainSid, Sid );

    Length = wcslen( UserInstallInfo->DnsDomainName );
    RootDomainDnsName = NtdspAlloc( (Length+1) * sizeof(WCHAR) );
    if ( !RootDomainDnsName )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    wcscpy( RootDomainDnsName, UserInstallInfo->DnsDomainName );

    // Copy the values over
    ConfigInfo->RootDomainSid = RootDomainSid;
    RootDomainSid = NULL;
    ConfigInfo->RootDomainDnsName = RootDomainDnsName;
    RootDomainDnsName = NULL;

    //
    // That's it
    //

Cleanup:

    if ( RootDomainSid )
    {
        NtdspFree( RootDomainSid );
    }

    if ( RootDomainDnsName )
    {
        NtdspFree( RootDomainDnsName );
    }

    if ( AccountDomainInfo ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)AccountDomainInfo );
    }

    if ( PrimaryDomainInfo ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyPrimaryDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)PrimaryDomainInfo );
    }

    return RtlNtStatusToDosError( NtStatus );
}


DWORD
NtdspGetTrustedCrossRef(
    IN  LDAP              *hLdap,
    IN  PNTDS_INSTALL_INFO  UserInstallInfo,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo
    )
/*++

Routine Description:

    This routine determines the dn of the cross ref that this newly installed
    domain will trust.  A new tree will trust the root; a new child will trust
    its parent.

Arguments:

    hLdap: a valid ldap handle

    UserInstallInfo:  user provided info

    DiscoveredInfo     :  derived info

Returns:

    ERROR_SUCCESS - Success; resource error otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD LdapError = 0;

    LDAPMessage  *SearchResult = NULL;

    LDAPMessage *Entry;
    WCHAR       *Attr;
    BerElement  *pBerElement;

    WCHAR  *distinguishedName = L"distinguishedName";
    WCHAR  *ncName            = L"(ncName=";
    WCHAR  *Partitions        = L"CN=Partitions,";
    WCHAR  *ncNameFilter      = NULL;
    WCHAR  *AttrArray[] = {distinguishedName, 0};
    ULONG  Length;
    WCHAR  *BaseDn;
    LPWSTR DomainDn;

    PSID     RootDomainSid = NULL;
    LPWSTR   RootDomainDnsName = NULL;

    // Parameter check
    ASSERT( hLdap );
    ASSERT( UserInstallInfo );
    ASSERT( DiscoveredInfo );

    if ( FLAG_ON( UserInstallInfo->Flags, NTDS_INSTALL_NEW_TREE ) )
    {
        // we want the cross ref of the root
        Assert( DiscoveredInfo->RootDomainDN );
        DomainDn = DiscoveredInfo->RootDomainDN;
    }
    else
    {
        // we want the name of the domain
        Assert( DiscoveredInfo->ParentDomainDN );
        DomainDn = DiscoveredInfo->ParentDomainDN;
    }

    // Search the partitions container for the cross ref
    // with the NC-Name of DiscoveredInfo->RootDomainDN and ask for the
    // extended attribute of NC-Name so we get the sid

    //
    // Prepare the filter
    //
    Length = wcslen( ncName ) + wcslen( DomainDn ) + 3;
    Length *= sizeof( WCHAR );
    ncNameFilter = (WCHAR*) alloca( Length );
    wcscpy( ncNameFilter, ncName );
    wcscat( ncNameFilter, DomainDn );
    wcscat( ncNameFilter, L")" );

    //
    // Prepare the base dn
    //
    Length = wcslen( DiscoveredInfo->ConfigurationDN ) + wcslen( Partitions ) + 1;
    Length *= sizeof( WCHAR );
    BaseDn = alloca( Length );
    wcscpy( BaseDn, Partitions );
    wcscat( BaseDn, DiscoveredInfo->ConfigurationDN );

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_ext_sW(hLdap,
                                   BaseDn,
                                   LDAP_SCOPE_SUBTREE,
                                   ncNameFilter,
                                   AttrArray,
                                   FALSE,  // return values, too
                                   NULL,
                                   NULL,                 // no client controls
                                   NULL, // no timeout
                                   0xffffffff, // size limit
                                   &SearchResult
                                  );

    WinError = LdapMapErrorToWin32(LdapError);

    if ( ERROR_SUCCESS == WinError )
    {
        for ( Entry = ldap_first_entry(hLdap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(hLdap, Entry))
        {
            for( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(hLdap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, distinguishedName ) )
                {
                    WCHAR **Values;

                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        DiscoveredInfo->TrustedCrossRef = (WCHAR*)NtdspAlloc( (Length+1) * sizeof(WCHAR) );
                        if ( DiscoveredInfo->TrustedCrossRef )
                        {
                            wcscpy( DiscoveredInfo->TrustedCrossRef, Values[0] );
                        }
                    }
                }
            }
        }

        if ( !DiscoveredInfo->TrustedCrossRef )
        {
            WinError = ERROR_DS_MISSING_REQUIRED_ATT;
        }
    }


    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    return WinError;

}


DWORD
NtdspAddDomainAdminAccessToServer(
    IN PNTDS_INSTALL_INFO UserInstallInfo,
    IN PNTDS_CONFIG_INFO DiscoveredInfo
    )
/*++

Routine Description:

    This routine adds an ACE to the local server's security descriptor
    granting full control to domain admins.  This operates on the DS directly
    so we need to create a thread state (and destory it on exit).

Arguments:

    UserInstallInfo:  user provided info

    DiscoveredInfo :  derived info

Returns:

    ERROR_SUCCESS - Success; resource error otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG DirError = 0;

    READARG    ReadArg;
    READRES   *ReadResult;

    MODIFYARG  ModifyArg;
    MODIFYRES *ModifyRes;

    ENTINFSEL    EISelection; // Entry Information Selection
    ATTRBLOCK    AttrBlock;
    ATTRVALBLOCK AttrValBlock;
    ATTR         Attr;
    ATTRVAL     *pAttrVal = NULL;
    ATTRVAL      AttrVal;
    ULONG        ValCount = 0;
    ULONG        ValLength = 0;

    PSECURITY_DESCRIPTOR pSd = NULL, pNewSd = NULL;
    PSID        DomainAdminSid = NULL;
    ULONG       SecurityFlags = DACL_SECURITY_INFORMATION;
    PACL        Dacl; 

    ULONG     Length;
    BOOL      fStatus;

    DSNAME    *pObject;
    DWORD     cBytes;

    //
    // Now, check to make sure all our configuration information
    // is present
    //
    ASSERT( UserInstallInfo );
    ASSERT( DiscoveredInfo );
    ASSERT( DiscoveredInfo->LocalServerDn );
    ASSERT( DiscoveredInfo->NewDomainSid );

    if ( !DiscoveredInfo->LocalServerDn
      || !DiscoveredInfo->NewDomainSid ) {

        // There is nothing we can do here
        return ERROR_SUCCESS;
        
    }

    if ( THCreate( CALLERTYPE_INTERNAL ) )
    {
       return ERROR_NOT_ENOUGH_MEMORY;
    }
    SampSetDsa( TRUE );
    _try
    {
    
    
        cBytes = (DWORD)DSNameSizeFromLen(wcslen(DiscoveredInfo->LocalServerDn));
        pObject = alloca( cBytes );
        memset(pObject, 0, cBytes);
        pObject->structLen = cBytes;
        pObject->NameLen = wcslen(DiscoveredInfo->LocalServerDn);
        wcscpy( pObject->StringName, DiscoveredInfo->LocalServerDn );
    
    
        RtlZeroMemory(&AttrBlock, sizeof(ATTRBLOCK));
        RtlZeroMemory(&Attr, sizeof(ATTR));
        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&ModifyArg, sizeof(MODIFYARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&AttrValBlock, sizeof(ATTRVALBLOCK));
    
        //
        // Read the security descriptor
        //
        Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
        AttrBlock.attrCount = 1;
        AttrBlock.pAttr = &Attr;
        EISelection.AttrTypBlock = AttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
        ReadArg.pSel = &EISelection;
        ReadArg.pObject = pObject;
        InitCommarg( &ReadArg.CommArg );
    
        // Don't try to read the SACL
        ReadArg.CommArg.Svccntl.SecurityDescriptorFlags = SecurityFlags;
    
        DirError = DirRead( &ReadArg, &ReadResult );
    
        WinError = DirErrorToWinError(DirError, &ReadResult->CommRes);
    
        THClearErrors();
    
        if ( ERROR_SUCCESS != WinError )
        {
            if ( ERROR_DS_NO_REQUESTED_ATTS_FOUND == WinError )
            {
                // couldn't find the sd? probably wrong credentials
                WinError = ERROR_ACCESS_DENIED;
            }
            goto Cleanup;
        }
    
        //
        // Extract the value
        //
    
        ASSERT(NULL != ReadResult);
        AttrBlock = ReadResult->entry.AttrBlock;
        pAttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;
        Assert(1 == ValCount);
    
        pSd = (PDSNAME)(pAttrVal[0].pVal);
        Length = pAttrVal[0].valLen;
    
        if ( NULL == pSd )
        {
            // No SD? This is bad
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }
    
        //
        // Construct the Domain Admin's sid
        //
        WinError = NtdspCreateFullSid( DiscoveredInfo->NewDomainSid,
                                       DOMAIN_GROUP_RID_ADMINS,
                                       &DomainAdminSid );
    
        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }
    
        WinError = NtdspAddAceToSd( pSd,
                                    DomainAdminSid,
                                    DS_GENERIC_ALL,
                                    CONTAINER_INHERIT_ACE,
                                    &pNewSd );
    
        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }
    
        //
        // Write the security descriptor
        //
        memset( &ModifyArg, 0, sizeof( ModifyArg ) );
        ModifyArg.pObject = pObject;
    
        ModifyArg.FirstMod.pNextMod = NULL;
        ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    
        AttrVal.valLen = RtlLengthSecurityDescriptor( pNewSd );
        AttrVal.pVal = (PUCHAR)pNewSd;
        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;
        Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
        Attr.AttrVal = AttrValBlock;
    
        ModifyArg.FirstMod.AttrInf = Attr;
        ModifyArg.count = 1;
    
        InitCommarg( &ModifyArg.CommArg );
    
        //
        // We only want to change the dacl
        //
        ModifyArg.CommArg.Svccntl.SecurityDescriptorFlags = SecurityFlags;
    
    
        DirError = DirModifyEntry( &ModifyArg, &ModifyRes );
    
        WinError = DirErrorToWinError( DirError, &ModifyRes->CommRes );
    
        THClearErrors();
    
        //
        // We are done
        //
    
    Cleanup:
    
        if ( DomainAdminSid )
        {
            LocalFree( DomainAdminSid );
        }
    
        if ( pNewSd )
        {
            LocalFree( pNewSd );
        }

    }
    _finally
    {
        THDestroy();
    }
    
    return WinError;
    
}


DWORD
NtdspAddAceToSd(
    IN  PSECURITY_DESCRIPTOR pOldSd,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    IN  ULONG AceFlags,
    OUT PSECURITY_DESCRIPTOR *ppNewSd
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and AccessMask

Arguments:

    pOldAcl
    
    pClientSid
    
    AccessMask
    
    pNewAcl

Return Values:

    ERROR_SUCCESS if the ace was put in the sd
    
--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    BOOL   fStatus;

    PSECURITY_DESCRIPTOR pNewSelfRelativeSd = NULL;
    DWORD                NewSelfRelativeSdSize = 0;
    PACL                 pNewDacl  = NULL;

    SECURITY_DESCRIPTOR  AbsoluteSd;
    PACL                 pDacl  = NULL;
    PACL                 pSacl  = NULL;
    PSID                 pGroup = NULL;
    PSID                 pOwner = NULL;

    DWORD AbsoluteSdSize = sizeof( SECURITY_DESCRIPTOR );
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD GroupSize = 0;
    DWORD OwnerSize = 0;


    // Parameter check
    Assert( pOldSd );
    Assert( pClientSid );
    Assert( ppNewSd );

    // Init the out parameter
    *ppNewSd = NULL;

    RtlZeroMemory( &AbsoluteSd, AbsoluteSdSize );

    //
    // Make sd absolute
    //
    fStatus = MakeAbsoluteSD( pOldSd,
                              &AbsoluteSd,
                              &AbsoluteSdSize,
                              pDacl,
                              &DaclSize,
                              pSacl,
                              &SaclSize,
                              pOwner,
                              &OwnerSize,
                              pGroup,
                              &GroupSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        if ( 0 == DaclSize )
        {
            // No Dacl? We can't write to the dacl, then
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        if ( DaclSize > 0 ) pDacl = alloca( DaclSize );
        if ( SaclSize > 0 ) pSacl = alloca( SaclSize );
        if ( OwnerSize > 0 ) pOwner = alloca( OwnerSize );
        if ( GroupSize > 0 ) pGroup = alloca( GroupSize );

        if ( pDacl )
        {
            fStatus = MakeAbsoluteSD( pOldSd,
                                      &AbsoluteSd,
                                      &AbsoluteSdSize,
                                      pDacl,
                                      &DaclSize,
                                      pSacl,
                                      &SaclSize,
                                      pOwner,
                                      &OwnerSize,
                                      pGroup,
                                      &GroupSize );
    
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Does the ace already exist?
    //
    if ( !NtdspAceAlreadyExists( pDacl,
                                pClientSid,
                                AccessMask,
                                AceFlags ) ) {

        //
        // Create a new dacl with the new ace
        //
        WinError = NtdspAddAceToAcl( pDacl,
                                     pClientSid,
                                     AccessMask,
                                     AceFlags,
                                    &pNewDacl );
    } else {

        pNewDacl = pDacl;

    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Set the dacl
    //
    fStatus = SetSecurityDescriptorDacl ( &AbsoluteSd,
                                         TRUE,     // dacl is present
                                         pNewDacl,
                                         FALSE );  //  facl is not defaulted

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Make the new sd self relative
    //
    fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                   pNewSelfRelativeSd,
                                   &NewSelfRelativeSdSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        pNewSelfRelativeSd = LocalAlloc( 0, NewSelfRelativeSdSize );

        if ( pNewSelfRelativeSd )
        {
            fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                           pNewSelfRelativeSd,
                                           &NewSelfRelativeSdSize );
    
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( pNewDacl && (pNewDacl != pDacl) )
    {
        LocalFree( pNewDacl );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        Assert( pNewSelfRelativeSd );
        *ppNewSd = pNewSelfRelativeSd;
    }
    else
    {
        if ( pNewSelfRelativeSd )
        {
            LocalFree( pNewSelfRelativeSd );
        }
    }

    return WinError;

}

DWORD
NtdspAddAceToAcl(
    IN  PACL pOldAcl,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    IN  ULONG AceFlags,
    OUT PACL *ppNewAcl
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and AccessMask

Arguments:

    pOldAcl
    
    pClientSid
    
    AccessMask
    
    pNewAcl

Return Values:

    ERROR_SUCCESS if the ace was put in the sd
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL  fStatus;

    ACL_SIZE_INFORMATION     AclSizeInfo;
    ACL_REVISION_INFORMATION AclRevInfo;
    ACCESS_ALLOWED_ACE       Dummy;

    PVOID  FirstAce = 0;
    PACL   pNewAcl = 0;

    ULONG NewAclSize, NewAceCount, AceSize;

    // Parameter check
    Assert( pOldAcl );
    Assert( pClientSid );
    Assert( ppNewAcl );

    // Init the out parameter
    *ppNewAcl = NULL;

    memset( &AclSizeInfo, 0, sizeof( AclSizeInfo ) );
    memset( &AclRevInfo, 0, sizeof( AclRevInfo ) );

    //
    // Get the old sd's values
    //
    fStatus = GetAclInformation( pOldAcl,
                                 &AclSizeInfo,
                                 sizeof( AclSizeInfo ),
                                 AclSizeInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = GetAclInformation( pOldAcl,
                                 &AclRevInfo,
                                 sizeof( AclRevInfo ),
                                 AclRevisionInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Calculate the new sd's values
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( Dummy.SidStart )
              + GetLengthSid( pClientSid );

    NewAclSize  = AceSize + AclSizeInfo.AclBytesInUse;
    NewAceCount = AclSizeInfo.AceCount + 1;

    //
    // Init the new acl
    //
    pNewAcl = LocalAlloc( 0, NewAclSize );
    if ( NULL == pNewAcl )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    fStatus = InitializeAcl( pNewAcl,
                             NewAclSize,
                             AclRevInfo.AclRevision );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Copy the old into the new
    //
    fStatus = GetAce( pOldAcl,
                      0,
                      &FirstAce );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = AddAce( pNewAcl,
                      AclRevInfo.AclRevision,
                      0,
                      FirstAce,
                      AclSizeInfo.AclBytesInUse - sizeof( ACL ) );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Finally, add the new ace
    //
    fStatus = AddAccessAllowedAceEx( pNewAcl,
                                     ACL_REVISION,
                                     AceFlags,
                                     AccessMask,
                                     pClientSid );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    // Assign the out parameter
    *ppNewAcl = pNewAcl;

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( ERROR_SUCCESS != WinError )
    {
        if ( pNewAcl )
        {
            LocalFree( pNewAcl );
        }
    }

    return WinError;
}


BOOL
NtdspAceAlreadyExists( 
    PACL     pDacl,
    PSID     pSid,
    ULONG    AccessMask,
    ULONG    AceFlags
    )
{

    BOOL fStatus = FALSE;
    ACL_SIZE_INFORMATION AclInfo;
    ULONG i;

    ASSERT( pDacl );
    ASSERT( pSid );

    fStatus = GetAclInformation( pDacl, &AclInfo, sizeof(AclInfo), AclSizeInformation );
    if ( fStatus ) {

        for ( i = 0; i < AclInfo.AceCount; i++) {
    
            ACE_HEADER *pAceHeader;
    
            if ( GetAce( pDacl, i, &pAceHeader ) ) {

                if ( (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                  && (pAceHeader->AceFlags == AceFlags) ) {
    
                    ACCESS_ALLOWED_ACE *pAAAce = (ACCESS_ALLOWED_ACE*)pAceHeader;
        
                    if ( (pAAAce->Mask == AccessMask)
                      && (RtlEqualSid( (PSID)&(pAAAce->SidStart), pSid)) ) {
        
                          return TRUE;
                        
                    }
                }
            }
        }
    }

    return FALSE;
}

DWORD
NtdspGetReplicationEpoch( 
    IN LDAP  *hLdap,
    IN PNTDS_CONFIG_INFO  DiscoveredInfo
    )
/*++

Routine Description:

    This function will make an ldap call to discover the Replication Epoch of
    the enterprise.  Then it will store that time in the registry for later use

Arguments:

    hLdap - handle to an open ldap connection
    
    DiscoveredInfo - Structure containing DiscoveredInfo
    
Return Values:

    ERROR_SUCCESS - if the value was found and placed in the registry.
    
--*/
{
    DWORD        WinError = ERROR_SUCCESS;

    DWORD        ReplicationEpoch = 0;

    BOOL         fExists = FALSE;
    

    // Parameter check
    Assert( hLdap );

    //
    // Read the ReplicationEpoch
    //
    
    WinError = NtdspGetDwordAttFromDN(hLdap,
                                      DiscoveredInfo->ServerDN,
                                      L"msDs-ReplicationEpoch",
                                      &fExists,
                                      &ReplicationEpoch
                                      );
    if (ERROR_SUCCESS != WinError) {

        return WinError;

    }
                                  
    //if a value for the tombstone was retieved then we will store it
    //for later use.  If not then the default of zero will be used.
    if (fExists) {

        DiscoveredInfo->ReplicationEpoch = ReplicationEpoch;

    } else {

        DiscoveredInfo->ReplicationEpoch = 0;

    }

    return WinError;
}

DWORD
NtdspGetDwordAttFromDN(
    IN  LDAP  *hLdap,
    IN  WCHAR *wszDN,
    IN  WCHAR *wszAttribute,
    OUT BOOL  *fExists,
    OUT DWORD *dwValue
    )
/*++

Routine Description:

    This function given a Ldap handle a DN and Attribute which is a 
    DWORD will return whether or not it exists.

Arguments:

    hLdap - handle to an open ldap connection
    
    wszDN - A string of the DN to get the attribute from.
    
    wszAttribute - The Attribute
    
    fExists - Reports if the Value was found
    
    dwValue - Reports the Value of the Attribute that was looked up
    
Return Values:

    ERROR_SUCCESS.
    
--*/
{
    ULONG        LdapError = LDAP_SUCCESS;
    DWORD        WinError = ERROR_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;
    
    WCHAR        *AttrsToSearch[2];
    
    WCHAR        *DefaultFilter = L"objectClass=*";

    AttrsToSearch[0] = wszAttribute;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                wszDN,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;
        BOOLEAN     found=FALSE;
    
        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        *dwValue=_wtoi(Values[0]);
                        *fExists=TRUE;
                        ldap_value_free(Values);
                        break;
                    }

                }
            }
            if (*fExists == TRUE) {
                break;
            }
        }
    }

    if (SearchResult) {
        ldap_msgfree(SearchResult);
    }

    return WinError;

}


DWORD
NtdspGetTombstoneLifeTime( 
    IN LDAP  *hLdap,
    IN PNTDS_CONFIG_INFO  DiscoveredInfo
    )
/*++

Routine Description:

    This function will make an ldap call to discover the tombstone lifetime of
    the domain.  Then it will store that time in the registry for later use

Arguments:

    hLdap - handle to an open ldap connection
    
    DiscoveredInfo - Structure containing DiscoveredInfo
    
Return Values:

    ERROR_SUCCESS - if the value was found and placed in the registry.
    
--*/

{
    DWORD        WinError = ERROR_SUCCESS;
    WCHAR        *Base;
    
    DWORD        Tombstonelifetime=0;
    WCHAR        *pConfigurationDN=DiscoveredInfo->ConfigurationDN;
    BOOL         fExists = FALSE;

        
    // Parameter check
    Assert( hLdap );

    //build the base of the search
    Base=(WCHAR*) alloca((wcslen(pConfigurationDN) 
                          + sizeof(L"CN=Directory Service,CN=Windows NT,CN=Services,") +1)
                          * sizeof(WCHAR));
    wcscpy(Base,L"CN=Directory Service,CN=Windows NT,CN=Services,");
    wcscat(Base,pConfigurationDN);
    
    WinError = NtdspGetDwordAttFromDN(hLdap,
                                      Base,
                                      L"tombstoneLifetime",
                                      &fExists,
                                      &Tombstonelifetime
                                      );
    if (ERROR_SUCCESS != WinError) {

        return WinError;

    }
    
    //if a value for the tombstone was retieved then we will store it
    //for later use.
    if (fExists) {

        DiscoveredInfo->TombstoneLifeTime = Tombstonelifetime;

    } else {

        DiscoveredInfo->TombstoneLifeTime = DEFAULT_TOMBSTONE_LIFETIME;

    }

    return WinError;
}

DWORD
NtdspCheckDomainDcLimit(
    IN  LDAP               *hLdap,
    IN  PNTDS_CONFIG_INFO  DiscoveredInfo)
/*++

Routine Description:

    This Function will determine if the limit of Dc's in the
    Domain have been meet.  It will first look to see if we
    are trying to add a standared server.

Arguments:

    hLdap - handle to an open ldap connection
    
    DcLimit - The current limit of Dc's in the Domain if Standared server is presant
    
Return Values:

    ERROR_SUCCESS - if all is well.
    ERROR_DS_NO_VER - if the product type can not be determined
    ERROR_DS_TOO_MANY2 - if we have already reached the limit of dc's
    
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG        LdapError = LDAP_SUCCESS;
    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries = 0;
    DWORD        DcLimit = 0;
    WCHAR        szDcLimit[10] = L"";
    WCHAR        *Filter = L"objectCategory=nTDSDSA";
    OSVERSIONINFOEX osvi;
    
    DcLimit = MAX_STANDARD_SERVERS;

    // Parameter check
    Assert( hLdap );
    Assert( NULL != DiscoveredInfo->ConfigurationDN );

    ZeroMemory((PVOID)&osvi,sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx ( (OSVERSIONINFO *) &osvi)) {
        NTDSP_SET_ERROR_MESSAGE0( GetLastError(),
                                  DIRMSG_INSTALL_FAILED_NO_VER );
        return ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER;
    }

    // We have no DC amount restrictions for datacenter or for advanced server
    if ((osvi.wSuiteMask & VER_SUITE_DATACENTER) || (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)) {
        return ERROR_SUCCESS;
    }

    //Find all of the NTDS Setting objects
    LdapError = ldap_search_ext_sW( hLdap,
                                    DiscoveredInfo->ConfigurationDN,
                                    LDAP_SCOPE_SUBTREE,
                                    Filter,
                                    NULL,
                                    TRUE,
                                    NULL,
                                    NULL,
                                    NULL,
                                    MAX_STANDARD_SERVERS,
                                    &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError && LDAP_SIZELIMIT_EXCEEDED != LdapError )
    {
        return LdapMapErrorToWin32(LdapError);
    }
    //if this is true then we have more servers in the domain than we should
    if ( LDAP_SIZELIMIT_EXCEEDED == LdapError ) {
        WinError = ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER;
    } else {
        NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
        //restrict promotion if we have already reached the max number
        //of allowable DCs
        if ( NumberOfEntries > MAX_STANDARD_SERVERS-1 ) {
            WinError = ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER;
        }
    }
    
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    if (ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER == WinError) {
        wsprintf(szDcLimit,L"%d",DcLimit);
        NTDSP_SET_ERROR_MESSAGE1( WinError,
                                  DIRMSG_INSTALL_FAILED_TOO_MANY_STANDARD_SERVERS,
                                  szDcLimit );
    } 

    return WinError;
}

DWORD
NtdspCopyDatabase(LPWSTR DsDatabasePath,
                  LPWSTR DsLogPath,
                  LPWSTR RestorePath,
                  LPWSTR SysvolPath
                  )
//This function will set the registry so that all the values need for
//restore are in place.  And it will move the dit, pat, and logs into
//the directorys that were specified by the user.

//   DsDatabasePath -  The path to place the DS
//   DsLogPath - The path to place the Log files
{
    WCHAR DPath[MAX_PATH+1];
    WCHAR PPath[MAX_PATH+1];
    WCHAR LPath[MAX_PATH+1];
    WCHAR Path[MAX_PATH+1];
    ULONG cbPath=MAX_PATH+1;
    WCHAR regsystemfilepath[MAX_PATH];
    ULONG cbregsystemfilepath=MAX_PATH*2;
    BOOL  bSuccess=TRUE;
    HKEY  NTDSkey=NULL;
    HKEY  phkOldlocation=NULL;
    BOOL  SamePar=FALSE;
    HANDLE hLogs = INVALID_HANDLE_VALUE;
    HANDLE DLogs = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW Logfile;
    WIN32_FIND_DATAW file;
    DWORD Win32Err=ERROR_SUCCESS;
    BOOLEAN fWasEnabled=FALSE;
    NTSTATUS Status=STATUS_SUCCESS;


    
    //
    // Copy the ds database files
    //

    if (RestorePath && *RestorePath){
        
        wcscpy(Path,RestorePath);
        cbPath=wcslen(Path);

        //set up the location of the system registry file

        wcscpy(regsystemfilepath,Path);
        wcscat(regsystemfilepath,L"\\registry\\system");

        //set up the copy of the ntds.dit file

        wcscat(Path,L"\\Active Directory\\ntds.dit");
        wcscpy(DPath,DsDatabasePath);
        wcscat(DPath,L"\\ntds.dit");

        //do a move if source and dest. are on the same partitions

        SamePar=(tolower(*Path)==tolower(*DPath))?TRUE:FALSE;

        if (SamePar) 
        {
            NTDSP_SET_IFM_RESTORED_DATABASE_FILES_MOVED();
        }

        NTDSP_SET_STATUS_MESSAGE2( DIRMSG_COPY_RESTORED_FILES, Path, DPath );

        //
        // Get the source path of the database and the log files from the old
        // registry
        //
        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                     TRUE,           // Enable
                                     FALSE,          // not client; process wide
                                     &fWasEnabled );
        ASSERT( NT_SUCCESS( Status ) );


        Win32Err = RegLoadKeyW(
                          HKEY_LOCAL_MACHINE,        
                          IFM_SYSTEM_KEY, 
                          regsystemfilepath);

        if (Win32Err != ERROR_SUCCESS) {
            DPRINT1( 0, "Failed to load key: %d retrying\n",Win32Err );
            RegUnLoadKeyW(
                      HKEY_LOCAL_MACHINE,
                      IFM_SYSTEM_KEY);
            Win32Err = RegLoadKeyW(
                          HKEY_LOCAL_MACHINE,        
                          IFM_SYSTEM_KEY, 
                          regsystemfilepath);
            if (Win32Err != ERROR_SUCCESS) {
                DPRINT1( 0, "Failed to load key: %d\n",Win32Err );
                goto cleanup;
            }

        } 
        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                           FALSE,          // Disable
                           FALSE,          // not client; process wide
                           &fWasEnabled );
        ASSERT( NT_SUCCESS( Status ) );

        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,         // handle to open key
                      L"ifmSystem\\ControlSet001\\Services\\NTDS\\Parameters",  // subkey name
                      0,   // reserved
                      KEY_READ, // security access mask
                      &phkOldlocation  // handle to open key
                    );
    
        if (Win32Err != ERROR_SUCCESS) {
            DPRINT1( 0, "RegOpenKeyExW failed to find old location of Database with %d\n"
                     ,Win32Err );
            goto cleanup;
        }

            {
            DWORD type=REG_SZ;
            Win32Err = RegQueryValueEx(
                              phkOldlocation,           
                              L"DSA Database file", 
                              0,
                              &type,       
                              (VOID*)regsystemfilepath,        
                              &cbregsystemfilepath      
                              );
            if (Win32Err != ERROR_SUCCESS) {
                DPRINT1( 0, "RegQueryValueEx failed to find old location of Database with %d\n"
                         ,Win32Err );
                goto cleanup;

            }
        }
                        
        regsystemfilepath[cbregsystemfilepath/sizeof(WCHAR)-1]=L'\0';

        Win32Err = RegCloseKey(phkOldlocation);
        phkOldlocation=NULL;
        if (!NT_SUCCESS(Win32Err)) {
            DPRINT1( 0, "RegCloseKey failed with %d\n",
                          Win32Err );
        }
        
        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                     TRUE,           // Enable
                                     FALSE,          // not client; process wide
                                     &fWasEnabled );
        ASSERT( NT_SUCCESS( Status ) );
    
        Win32Err = RegUnLoadKeyW(
                      HKEY_LOCAL_MACHINE,
                      IFM_SYSTEM_KEY);
        if (!NT_SUCCESS(Win32Err)) {
            DPRINT1( 0, "RegUnLoadKeyW failed with %d\n",
                          Win32Err );
        }
    
        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                     FALSE,           // disable
                                     FALSE,          // not client; process wide
                                     &fWasEnabled );
        ASSERT( NT_SUCCESS( Status ) );


        if ( CreateDirectory( DsDatabasePath, NULL ) == FALSE ) {

            
            Win32Err = GetLastError();

            if ( Win32Err == ERROR_ALREADY_EXISTS) {

                Win32Err = ERROR_SUCCESS;

            } else if ( Win32Err == ERROR_ACCESS_DENIED ) {

                //If the path given to CreateDirectory is a root path then
                //it will fail with ERROR_ACCESS_DENIED instead of
                //ERROR_ALREADY_EXISTS but the path is still a valid one for
                //ntds.dit to be placed in.
                if ( PathIsRoot(DsDatabasePath) ) {
                    Win32Err = ERROR_SUCCESS;
                }
            }  else if ( Win32Err != ERROR_SUCCESS ) {
                        
                DPRINT2( 0, "Failed to create directory [%ws]: %lu\n",
                                  DsLogPath,
                                  Win32Err );
                goto cleanup;

            }
        }

        //Delete the File if it already exists
        hLogs = FindFirstFileW(DPath,
                               &file);
        if (hLogs == INVALID_HANDLE_VALUE) {
            Win32Err = GetLastError();
            if(Win32Err != ERROR_FILE_NOT_FOUND){
                DPRINT2( 0, "Failed to look for file in [%ws]: %lu\n",
                                  DPath,
                                  Win32Err );    
                goto cleanup;
            } else {
                Win32Err = ERROR_SUCCESS;
            }
        } else {
            if( DeleteFile(DPath) == FALSE ){
                Win32Err = GetLastError();
                if(Win32Err != ERROR_FILE_NOT_FOUND){
                DPRINT2( 0, "Failed to delete file in [%ws]: %lu\n",
                                  DPath,
                                  Win32Err );    
                goto cleanup;
                } else {
                    Win32Err = ERROR_SUCCESS;
                    FindClose(hLogs);
                    hLogs = INVALID_HANDLE_VALUE;
                }
            }
        }

        
        if ( Win32Err == ERROR_SUCCESS && 
             SamePar?(bSuccess=MoveFileW( Path, DPath)):(bSuccess=CopyFileW( Path, DPath, FALSE ))) {

            if(!bSuccess){
                Win32Err = GetLastError();
            } else {
                Win32Err = ERROR_SUCCESS;
            }

            if ( Win32Err == ERROR_SUCCESS) {

                BOOL GotName = FALSE;
                DWORD Ignore;
                WCHAR lpBuffer[MAX_COMPUTERNAME_LENGTH + 1];
                DWORD cblpBuffer = MAX_COMPUTERNAME_LENGTH + 1;
                DWORD LogNums[500];
                DWORD Logcount=0;
                DWORD i=0;
                WCHAR *pLogfile = NULL;
                WCHAR **ppLogfile = NULL;
                
                Win32Err = ERROR_SUCCESS;

                if ( CreateDirectory( DsLogPath, NULL ) == FALSE ){
                    Win32Err = GetLastError();

                    if ( Win32Err == ERROR_ACCESS_DENIED && PathIsRoot(DsLogPath) ) {

                        //If the path given to CreateDirectory is a root path then
                        //it will fail with ERROR_ACCESS_DENIED instead of
                        //ERROR_ALREADY_EXISTS but the path is still a valid one for
                        //the log files to be placed in.
                        Win32Err = ERROR_SUCCESS;
                        
                    } else if ( Win32Err != ERROR_ALREADY_EXISTS ) {
                        
                        DPRINT2( 0, "Failed to create directory [%ws]: %lu\n",
                                          DsLogPath,
                                          Win32Err );
                        goto cleanup;

                    }  

                }

                //copy the patch file
                Path[cbPath]=L'\0';
                wcscat(Path,L"\\Active Directory\\ntds.pat");
                wcscpy(DPath,DsLogPath);
                wcscat(DPath,L"\\ntds.pat");
                
                NTDSP_SET_STATUS_MESSAGE2( DIRMSG_COPY_RESTORED_FILES, Path, DPath );

                //Delete the File if it already exists
                hLogs = FindFirstFileW(DPath,
                                       &file);
                if (hLogs == INVALID_HANDLE_VALUE) {
                    Win32Err = GetLastError();
                    if(Win32Err != ERROR_FILE_NOT_FOUND){
                        DPRINT2( 0, "Failed to look for file [%ws]: %lu\n",
                                          DPath,
                                          Win32Err );    
                        goto cleanup;
                    } else {
                        Win32Err = ERROR_SUCCESS;
                    }
                } else {
                    if( DeleteFile(DPath) == FALSE ){
                        Win32Err = GetLastError();
                        if(Win32Err != ERROR_FILE_NOT_FOUND){
                        DPRINT2( 0, "Failed to Delete file [%ws]: %lu\n",
                                          DPath,
                                          Win32Err );    
                        goto cleanup;
                        } else {
                            Win32Err = ERROR_SUCCESS;
                            FindClose(hLogs);
                            hLogs = INVALID_HANDLE_VALUE;
                        }
                    }
                }

                SamePar?(bSuccess=MoveFileW( Path, DPath)):(bSuccess=CopyFileW( Path, DPath, FALSE ));
                if(!bSuccess){
                    Win32Err = GetLastError();
                } else {
                    Win32Err = ERROR_SUCCESS;
                }
                if( Win32Err != ERROR_SUCCESS ) 
                {
                    DPRINT1( 0, "Failed to copy patch file: %lu\n",
                                      Win32Err );
                    NTDSP_SET_ERROR_MESSAGE2(Win32Err,
                                     DIRMSG_COPY_RESTORED_FILES_FAILURE,
                                     Path,
                                     DPath);
                    goto cleanup;
                }


                //copy the log file and get the low and hi of them

                Path[cbPath]=L'\0';
                wcscat(Path,L"\\Active Directory\\edb*.log");
                

                DLogs = FindFirstFileW(
                                  Path,
                                  &Logfile);

                if (DLogs == INVALID_HANDLE_VALUE) {
                    DPRINT2( 0, "Couldn't find log files [%ws]: %lu\n",
                                          LPath,
                                          Win32Err );
                    goto cleanup;
                }

                Path[cbPath]=L'\0';
                wcscat(Path,L"\\Active Directory\\");
                wcscat(Path,Logfile.cFileName);
                wcscpy(LPath,DsLogPath);
                wcscat(LPath,L"\\");
                wcscat(LPath,Logfile.cFileName);

                pLogfile = Logfile.cFileName;
                LogNums[Logcount++] = wcstol(pLogfile+3,ppLogfile,16);
                
                SamePar=(tolower(*Path)==tolower(*LPath))?TRUE:FALSE;
                
                if (SamePar) 
                {
                    NTDSP_SET_IFM_RESTORED_DATABASE_FILES_MOVED();
                }
                    
                NTDSP_SET_STATUS_MESSAGE2( DIRMSG_COPY_RESTORED_FILES, Path, LPath );

                //Delete the File if it already exists
                hLogs = FindFirstFileW(LPath,
                                       &file);
                if (hLogs == INVALID_HANDLE_VALUE) {
                    Win32Err = GetLastError();
                    if(Win32Err != ERROR_FILE_NOT_FOUND){
                        DPRINT2( 0, "Failed to look for file in [%ws]: %lu\n",
                                          LPath,
                                          Win32Err );    
                        goto cleanup;
                    } else {
                        Win32Err = ERROR_SUCCESS;
                    }
                } else {
                    if( DeleteFile(LPath) == FALSE ){
                        Win32Err = GetLastError();
                        if(Win32Err != ERROR_FILE_NOT_FOUND){
                        DPRINT2( 0, "Failed to look for file in [%ws]: %lu\n",
                                          LPath,
                                          Win32Err );    
                        goto cleanup;
                        } else {
                            Win32Err = ERROR_SUCCESS;
                            FindClose(hLogs);
                            hLogs = INVALID_HANDLE_VALUE;
                        }
                    }
                }

                SamePar?(bSuccess=MoveFileW( Path, LPath)):(bSuccess=CopyFileW( Path, LPath, FALSE ));

                if (!bSuccess) {
                    Win32Err = GetLastError();
                } else {
                    Win32Err = ERROR_SUCCESS;
                }
                if( Win32Err != ERROR_SUCCESS ) 
                {
                    DPRINT1( 0, "Failed to copy log file: %lu\n",
                                      Win32Err );
                    NTDSP_SET_ERROR_MESSAGE2(Win32Err,
                                     DIRMSG_COPY_RESTORED_FILES_FAILURE,
                                     Path,
                                     LPath);
                    goto cleanup;
                }

                while ( FindNextFileW(DLogs,&Logfile)) {

                    Path[cbPath]=L'\0';
                    wcscat(Path,L"\\Active Directory\\");
                    wcscat(Path,Logfile.cFileName);
                    wcscpy(LPath,DsLogPath);
                    wcscat(LPath,L"\\");
                    wcscat(LPath,Logfile.cFileName);

                    pLogfile = Logfile.cFileName;
                    LogNums[Logcount++] = wcstol(pLogfile+3,ppLogfile,16);
                    
                    NTDSP_SET_STATUS_MESSAGE2( DIRMSG_COPY_RESTORED_FILES, Path, LPath );

                    //Delete the File if it already exists
                    hLogs = FindFirstFileW(LPath,
                                           &file);
                    if (hLogs == INVALID_HANDLE_VALUE) {
                        Win32Err = GetLastError();
                        if(Win32Err != ERROR_FILE_NOT_FOUND){
                            DPRINT2( 0, "Failed to look for file in [%ws]: %lu\n",
                                              LPath,
                                              Win32Err );    
                            goto cleanup;
                        } else {
                            Win32Err = ERROR_SUCCESS;
                        }
                    } else {
                        if( DeleteFile(LPath) == FALSE ){
                            Win32Err = GetLastError();
                            if(Win32Err != ERROR_FILE_NOT_FOUND){
                            DPRINT2( 0, "Failed to look for file in [%ws]: %lu\n",
                                              LPath,
                                              Win32Err );    
                            goto cleanup;
                            } else {
                                Win32Err = ERROR_SUCCESS;
                                FindClose(hLogs);
                                hLogs = INVALID_HANDLE_VALUE;
                            }
                        }
                    }

                    SamePar?(bSuccess=MoveFileW( Path, LPath )):(bSuccess=CopyFileW( Path, LPath, FALSE ));

                    if(!bSuccess){
                        Win32Err = GetLastError();
                    } else {
                        Win32Err = ERROR_SUCCESS;
                    }

                    if( Win32Err != ERROR_SUCCESS ) 
                    {
                        DPRINT1( 0, "Failed to copy log file: %lu\n",
                                          Win32Err );
                        NTDSP_SET_ERROR_MESSAGE2(Win32Err,
                                     DIRMSG_COPY_RESTORED_FILES_FAILURE,
                                     Path,
                                     LPath);
                        goto cleanup;
                    }

                }

                //close the search handle
                FindClose(DLogs);
                DLogs = INVALID_HANDLE_VALUE;

                wcscpy(Path,DsDatabasePath);
                Path[1]=L'$';               //change the : in [?:\path] into a $

                wcscpy(LPath,DsLogPath);
                LPath[1]=L'$';

                GotName = GetComputerNameW(
                                lpBuffer,  // computer name
                                &cblpBuffer   // size of name buffer
                                );
                
                if (!GotName) {

                    Win32Err = GetLastError();
                    DPRINT1( 0, "Failed to get computer name: %lu\n",
                                      Win32Err );
                    
                } else {

                    BYTE lpValue[MAX_PATH+MAX_COMPUTERNAME_LENGTH+14];    //14 for \\ before computername and one after + null char
                    DWORD cbData = MAX_PATH+MAX_COMPUTERNAME_LENGTH+14;
                    WCHAR *lpValueName = NULL;
                    BOOLEAN BinValue;
                    DWORD  DValue;
                    WCHAR Multsz[(MAX_PATH+MAX_COMPUTERNAME_LENGTH+14)*2+2];
                    WCHAR buf[MAX_PATH+MAX_COMPUTERNAME_LENGTH+14];

                    //change the format of regsystemfilepath to include the computer name

                    regsystemfilepath[1]=L'$';
                    wcscpy(buf,L"\\\\");
                    wcscat(buf,lpBuffer);
                    wcscat(buf,L"\\");
                    wcscat(buf,regsystemfilepath);
                    wcscpy(regsystemfilepath,buf);

                        

                    Win32Err = RegCreateKeyExW(
                                      HKEY_LOCAL_MACHINE,                      
                                      L"System\\CurrentControlSet\\Services\\NTDS\\restore in progress", // subkey name
                                      0,                            
                                      NULL,                         
                                      0,                            
                                      KEY_WRITE,          
                                      NULL, 
                                      &NTDSkey, 
                                      &Ignore
                                      ); 
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to Create Key for restore: %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }

                    lpValueName=L"BackupLogPath";
                    wcscpy((WCHAR*)lpValue,L"\\\\");
                    wcscat((WCHAR*)lpValue,lpBuffer);
                    wcscat((WCHAR*)lpValue,L"\\");
                    wcscat((WCHAR*)lpValue,Path);
                    wcscat((WCHAR*)lpValue,L"\\");
                    cbData=wcslen((WCHAR*)lpValue)*sizeof(WCHAR);

                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName, // value name
                                      0,      // reserved
                                      REG_SZ,        // value type
                                      lpValue,  // value data
                                      cbData         // size of value data
                                      );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up BackupLogPath in registry: %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }

                    lpValueName = L"CheckpointFilePath";
                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName, // value name
                                      0,      // reserved
                                      REG_SZ,        // value type
                                      lpValue,  // value data
                                      cbData         // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up CheckpointFilePath in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }
                    
                    lpValueName = L"NTDS Database recovered";
                    BinValue = 0;
                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName, // value name
                                      0,      // reserved
                                      REG_BINARY,        // value type
                                      (PBYTE)&BinValue,  // value data
                                      sizeof(BOOLEAN)         // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up NTDS Database recovered in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }

                    for(i=0;i<Logcount;i++) {
                        DValue = LogNums[0];
                        if(DValue>LogNums[i]) {
                            DValue = LogNums[i];
                        }
                    }

                    lpValueName = L"LowLog Number";
                    cbData = sizeof(DWORD);
                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName , // value name
                                      0,      // reserved
                                      REG_DWORD,        // value type
                                      (PBYTE)&DValue,  // value data
                                      sizeof(DWORD)    // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up LowLog Number in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }

                    for(i=0;i<Logcount;i++) {
                        DValue = LogNums[0];
                        if(DValue<LogNums[i]) {
                            DValue = LogNums[i];
                        }
                    }
                    lpValueName = L"HighLog Number";
                    cbData = sizeof(DWORD);
                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName, // value name
                                      0,      // reserved
                                      REG_DWORD,        // value type
                                      (PBYTE)&DValue,  // value data
                                      sizeof(DWORD)         // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up HighLog Number in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }

                    lpValueName = L"NTDS_RstMap Size";
                    DValue = 1;
                    cbData = sizeof(DWORD);
                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName, // value name
                                      0,      // reserved
                                      REG_DWORD,        // value type
                                      (PBYTE)&DValue,  // value data
                                      sizeof(DWORD)         // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up NTDS_RstMap Size in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }

                    
                    lpValueName = L"NTDS_RstMap";
                    wcscpy(Multsz,regsystemfilepath);
                    DValue = wcslen(Multsz);
                    wcscat(Multsz,L" ");
                    wcscat(Multsz,(WCHAR*)lpValue);
                    wcscat(Multsz,L"ntds.dit");
                    Multsz[wcslen(Multsz)+1]=L'\0';
                    Multsz[wcslen(Multsz)+2]=L'\0';
                    cbData = wcslen(Multsz)*sizeof(WCHAR)+2*sizeof(WCHAR); //2 for the 2 trailing null chars
                    Multsz[DValue]=L'\0';
                    Win32Err = RegSetValueExW(
                                      NTDSkey,         // handle to key
                                      lpValueName,     // value name
                                      0,               // reserved
                                      REG_MULTI_SZ,    // value type
                                      (PBYTE)Multsz,          // value data
                                      cbData           // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up NTDS_RstMap in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }


                    lpValueName = L"LogPath";
                    wcscpy((WCHAR*)lpValue,L"\\\\");
                    wcscat((WCHAR*)lpValue,lpBuffer);
                    wcscat((WCHAR*)lpValue,L"\\");
                    wcscat((WCHAR*)lpValue,LPath);
                    wcscat((WCHAR*)lpValue,L"\\");
                    Win32Err = RegSetValueExW(
                                      NTDSkey,           // handle to key
                                      lpValueName, // value name
                                      0,      // reserved
                                      REG_SZ,        // value type
                                      (PBYTE)lpValue,  // value data
                                      wcslen((WCHAR*)lpValue)*sizeof(WCHAR)         // size of value data
                                    );
                    if(Win32Err!=ERROR_SUCCESS)
                    {
                        DPRINT1( 0, "Failed to set up LogPath in registry %lu\n",
                                      Win32Err );
                        goto cleanup;
                    }


                    Win32Err = RegCloseKey(
                                  NTDSkey   // handle to key to close
                                );
                    NTDSkey=NULL;


                }
                
                
            } else {

            Win32Err = GetLastError();
            DPRINT3( 0, "Failed to copy install file %ws to %ws: %lu\n",
                              Path, DsDatabasePath, Win32Err );
            NTDSP_SET_ERROR_MESSAGE2(Win32Err,
                                     DIRMSG_COPY_RESTORED_FILES_FAILURE,
                                     Path,
                                     DsDatabasePath);
            }
        } else {

            Win32Err = GetLastError();
            DPRINT3( 0, "Failed to copy install file %ws to %ws: %lu\n",
                              Path, DsDatabasePath, Win32Err );
            NTDSP_SET_ERROR_MESSAGE2(Win32Err,
                                     DIRMSG_COPY_RESTORED_FILES_FAILURE,
                                     Path,
                                     DsDatabasePath);
        }
    }

    cleanup:
    if(phkOldlocation){
    
        Win32Err = RegCloseKey(phkOldlocation);
        if (!NT_SUCCESS(Win32Err)) {
            DPRINT1( 0, "RegCloseKey failed with %d\n",
                          Win32Err );
        } 

        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                     TRUE,           // Enable
                                     FALSE,          // not client; process wide
                                     &fWasEnabled );
        ASSERT( NT_SUCCESS( Status ) );
    
        Win32Err = RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,
                  IFM_SYSTEM_KEY);
        if (!NT_SUCCESS(Win32Err)) {
            DPRINT1( 0, "RegUnLoadKeyW failed with %d\n",
                          Win32Err );
        } 

        Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                     FALSE,           // Enable
                                     FALSE,          // not client; process wide
                                     &fWasEnabled );
        ASSERT( NT_SUCCESS( Status ) );
    }
    if (DLogs != INVALID_HANDLE_VALUE) {
        FindClose(DLogs);
    }
    if (hLogs != INVALID_HANDLE_VALUE) {
        FindClose(hLogs);
    }
    
    if(NTDSkey)
    {
        Win32Err = RegCloseKey(
                      NTDSkey   // handle to key to close
                    );
    }
    
    return Win32Err;
}

ULONG 
LDAPAPI 
impersonate_ldap_bind_sW(
    IN HANDLE ClientToken, OPTIONAL
    IN LDAP *ld, 
    IN PWCHAR dn, 
    IN PWCHAR cred, 
    IN ULONG method
    )
/*++

Routine Description:

    This routine is a wrapper for ldap_bind_sW that impersonates ClientToken.
    The reason for this routine is that some creds (namely, certs for smart
    cards) require the code to be impersonating the user to whom the certificate
    belongs to.  The thumbprint of the certificate is in the "user" field
    of the creds.
    
Arguments:

    ClientToken -- a token to impersonate, if available.
    
    see ldap_bind_sW for other parameters
    
Return Values:

    see ldap_bind_sW
    
--*/
{
    ULONG err;
    BOOL fImpersonate = FALSE;

    if (ClientToken) {
        fImpersonate = ImpersonateLoggedOnUser(ClientToken);
        if (!fImpersonate) {
            // The error must be from the LDAP error space
            return LDAP_INVALID_CREDENTIALS;
        }
    }

    err = ldap_bind_sW(ld, dn, cred, method);

    if (fImpersonate) {
        RevertToSelf();
    }

    return err;
}


DWORD
WINAPI
ImpersonateDsBindWithCredW(
    HANDLE          ClientToken,
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS
    )
/*++

Routine Description:

    This routine is a wrapper for DsBindWithCredW that impersonates ClientToken.
    The reason for this routine is that some creds (namely, certs for smart
    cards) require the code to be impersonating the user to whom the certificate
    belongs to.  The thumbprint of the certificate is in the "user" field
    of the creds.
    
Arguments:

    ClientToken -- a token to impersonate, if available.
    
    see DsBindWithCredW for other parameters
    
Return Values:

    see DsBindWithCredW
    
--*/
{
    ULONG err;
    BOOL fImpersonate = FALSE;

    if (ClientToken) {
        fImpersonate = ImpersonateLoggedOnUser(ClientToken);
        if (!fImpersonate) {
            return GetLastError();
        }
    }

    err = DsBindWithCredW(DomainControllerName,
                          DnsDomainName,
                          AuthIdentity,
                          phDS);

    if (fImpersonate) {
        RevertToSelf();
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\sync.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sync.h

Abstract:

    Contains function headers to cause one machine to sync with another

Author:

    ColinBr  14-Aug-1998

Environment:

    User Mode - Win32

Revision History:


--*/

#include <NTDSpch.h>
#pragma  hdrstop

// Lots of includes for setuputl.h

#include <lmcons.h>

#include <dns.h>
#include <dnsapi.h>

#include <drs.h>
#include <ntdsa.h>

#include <winldap.h>

#include <ntlsa.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>

#include <debug.h>   // for dscommon debug support

#include "mdcodes.h"
#include "ntdsetup.h"
#include "setuputl.h"
#include "sync.h"
#include "status.h"


#define DEBSUB "SYNC:"

//
// Exported function definitions
//
DWORD
NtdspBringRidManagerUpToDate(
    IN PNTDS_INSTALL_INFO  UserInfo,
    IN PNTDS_CONFIG_INFO   DiscoveredInfo
    )
/*++

Routine Description:

    For replica installs, this routine causes a sync between our helping 
    server and the rid fsmo owner so that the new server will be able to
    get rids quickly

Parameters:

    UserInfo: user supplied info.
    
    DiscoveredInfo:  useful info we have discovered a long the way

Return Values:

    WinError from replication attempt

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    WCHAR *NamingContext;
    WCHAR *NamingContextArray[4];
    ULONG i;

    GUID  SourceGuid;
    GUID  NullGuid;

    // Do the replication asynch so the install time isn't greatly affected
    // It should be done by the time the install is finished
    ULONG Options = DS_REPSYNC_ASYNCHRONOUS_OPERATION;

    HANDLE          hDs = NULL;

    // Parameter check
    Assert( UserInfo );
    Assert( DiscoveredInfo );

    if ( !FLAG_ON( UserInfo->Flags, NTDS_INSTALL_REPLICA ) )
    {
        // nothing to do since this isn't a replica install
        return ERROR_SUCCESS;
    }

    if (   DiscoveredInfo->RidFsmoDn
        && !wcscmp( DiscoveredInfo->RidFsmoDn, DiscoveredInfo->ServerDN ) )
    {
        // no need to do anything since we know the RidFsmo already has
        // the machine account
        return ERROR_SUCCESS;
    }

    if ( !DiscoveredInfo->RidFsmoDnsName )
    {
        // During the discovery phase we couldn't find the FSMO
        return ERROR_DS_COULDNT_CONTACT_FSMO;
    }


    //
    // Ok, attempt to bind and then ssync
    //
    NTDSP_SET_STATUS_MESSAGE2( DIRMSG_SYNCING_RID_FSMO,
                               UserInfo->ReplServerName,
                               DiscoveredInfo->RidFsmoDnsName );
                               

    RtlZeroMemory( &NullGuid, sizeof(GUID) );
    if ( !memcmp( &NullGuid, &DiscoveredInfo->ServerGuid, sizeof(GUID) ) )
    {
        // couldn't read the guid of the helper server
        return ERROR_DS_CANT_FIND_DSA_OBJ;
    }
    RtlCopyMemory( &SourceGuid, &DiscoveredInfo->ServerGuid, sizeof(GUID) );

    // verify other parameters are here
    Assert( UserInfo->ReplServerName );
    Assert( UserInfo->Credentials );

    //
    // Construct the list of NC's to replicate
    //
    NamingContextArray[0] = &DiscoveredInfo->SchemaDN[0];
    NamingContextArray[1] = &DiscoveredInfo->ConfigurationDN[0];
    NamingContextArray[2] = &DiscoveredInfo->DomainDN[0];
    NamingContextArray[3] = NULL;

    //
    // Bind to Rid FSMO
    //
    WinError = ImpersonateDsBindWithCredW( UserInfo->ClientToken,
                                           DiscoveredInfo->RidFsmoDnsName,
                                           NULL,
                                           (RPC_AUTH_IDENTITY_HANDLE) UserInfo->Credentials,
                                           &hDs );

    if ( WinError != ERROR_SUCCESS )
    {
        DPRINT2( 0, "DsBindWithCred to %ls failed with %d\n", DiscoveredInfo->RidFsmoDnsName, WinError );
        goto Cleanup;
    }

    //
    // Finally, replicate the nc's
    //
    for ( i = 0, NamingContext = NamingContextArray[i]; 
            NamingContext != NULL;
                i++, NamingContext = NamingContextArray[i] )
    {
        //
        // Note - this is an async repl request, so shouldn't take to long
        //
        WinError = DsReplicaSync( hDs,
                                  NamingContext,
                                  &SourceGuid,
                                  Options );

        if ( ERROR_SUCCESS != WinError )
        {
            //
            // What to do here?  The is most likely caused by network problems,
            // or access denied, in which case there is not point of continuing.
            //
            DPRINT2( 0, "DsReplicaSync to %ls failed with %d\n", DiscoveredInfo->RidFsmoDnsName, WinError );
            DPRINT( 0, "Aborting attempt to sync rid fsmo owner\n" );
            break;
        }
    }

Cleanup:

    if ( hDs )
    {
        DsUnBind( &hDs );
    }

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsetup\status.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    status.c

Abstract:
    
    Routines to manage error messages, status, and cancellability

Author:

    ColinBr  14-Jan-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nt.h>
#include <winbase.h>
#include <tchar.h>
#include <ntsam.h>
#include <string.h>
#include <samrpc.h>
#include <rpc.h>

#include <crypt.h>
#include <ntlsa.h>
#include <winsock.h>  // for dnsapi.h
#include <dnsapi.h>
#include <loadperf.h>
#include <dsconfig.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <winldap.h>
#include <ntdsa.h>
#include <samisrv.h>
#include <rpcasync.h>
#include <drsuapi.h>
#include <dsaapi.h>
#include <attids.h>
#include <debug.h>
#include <mdcodes.h> // status message id's
#include <lsarpc.h>
#include <lsaisrv.h>
#include <dsrolep.h>


#include "ntdsetup.h"
#include "setuputl.h"
#include "machacc.h"
#include "status.h"

#define DEBSUB "STATUS:"

////////////////////////////////////////////////////////////////////////////////
//                                                                             /
// Global data just for this module                                            /
//                                                                             /
////////////////////////////////////////////////////////////////////////////////

//
// Critical section for maintaining cancel state
//
CRITICAL_SECTION NtdspCancelCritSect;

#define LockNtdsCancel()   EnterCriticalSection( &NtdspCancelCritSect );
#define UnLockNtdsCancel() LeaveCriticalSection( &NtdspCancelCritSect );


// Used to signal whether cancellation is requested
// Start off in a non-cancelled state
BOOLEAN gfNtdspCancelled = FALSE;

// Used to indicate whether the cancel routine should initiate 
// a shutdown of the DS.  This is true either when 
// 1) we are replicating non-critical objects at the end of promotion
// 2) we are in the middle of DsInitialize and the NtdspIsDsCancelOk callback
//    has been called with the parameter TRUE.
BOOLEAN gfNtdspShutdownDsOnCancel = FALSE;


//
// Callbacks to our caller
//
CALLBACK_STATUS_TYPE                 gCallBackFunction = NULL;
CALLBACK_ERROR_TYPE                  gErrorCallBackFunction = NULL;
CALLBACK_OPERATION_RESULT_FLAGS_TYPE gOperationResultFlagsCallBackFunction = NULL;
DWORD                                gErrorCodeSet = ERROR_SUCCESS;
HANDLE                               gClientToken = NULL;


////////////////////////////////////////////////////////////////////////////////
//                                                                             /
// Global data just for this module                                            /
//                                                                             /
////////////////////////////////////////////////////////////////////////////////
VOID
NtdspSetCallBackFunction(
    IN CALLBACK_STATUS_TYPE                 pfnStatusCallBack,
    IN CALLBACK_ERROR_TYPE                  pfnErrorCallBack,
    IN CALLBACK_OPERATION_RESULT_FLAGS_TYPE pfnOperationResultFlagsCallBack,
    IN HANDLE                               ClientToken
    )
{
    gCallBackFunction = pfnStatusCallBack;
    gErrorCallBackFunction = pfnErrorCallBack;
    gOperationResultFlagsCallBackFunction = pfnOperationResultFlagsCallBack;
    gErrorCodeSet = ERROR_SUCCESS;
    gClientToken = ClientToken;
}

DWORD 
NtdspErrorMessageSet(
    VOID
    )
{
    return gErrorCodeSet;
}

DWORD
NtdspSetErrorString(
    IN PWSTR Message,
    IN DWORD WinError
    )
{
    if ( (ERROR_SUCCESS == gErrorCodeSet) && gErrorCallBackFunction )
    {
        DPRINT2( 0, "%ls, %d\n", Message, WinError );
        gErrorCallBackFunction( Message, WinError );
        gErrorCodeSet = WinError;
    }

    return ERROR_SUCCESS;
}

VOID
NtdspSetOperationsResultFlags(
    ULONG Flags
    )
{
    DWORD WinError = ERROR_SUCCESS;
    
    if (gOperationResultFlagsCallBackFunction) {

        WinError = gOperationResultFlagsCallBackFunction(Flags);

    } else {
        
        DPRINT( 0, "Fail to set the OperationResultFlags From Ntdsetup.dll.  No Callback function set.");

    }
    if (ERROR_SUCCESS != WinError) {

        DPRINT1( 0, "Fail to set the OperationResultFlags From Ntdsetup.dll: %d" , WinError);

    }

}


VOID
NtdspSetIFMDatabaseMoved()
{
    NtdspSetOperationsResultFlags(DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED);
}

VOID
NtdspSetGCRequestCannotBeServiced()
{
    NtdspSetOperationsResultFlags(DSROLE_IFM_GC_REQUEST_CANNOT_BE_SERVICED);
}

VOID
NtdspSetNonFatalErrorOccurred()
{
    NtdspSetOperationsResultFlags(DSROLE_NON_FATAL_ERROR_OCCURRED);
}

VOID
NtdspSetStatusMessage (
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    )
/*++

Routine Description

    This routine calls the calling client's call to update our status.

Parameters

    MessageId : the message to retrieve

    Insert*   : strings to insert, if any

Return Values

    None.

--*/
{
    static HMODULE ResourceDll = NULL;

    WCHAR   *DefaultMessageString = L"Preparing the directory service";
    WCHAR   *MessageString = NULL;
    WCHAR   *InsertArray[5];
    ULONG    Length;

    //
    // Set up the insert array
    //
    InsertArray[0] = Insert1;
    InsertArray[1] = Insert2;
    InsertArray[2] = Insert3;
    InsertArray[3] = Insert4;
    InsertArray[4] = NULL;    // This is the sentinel

    if ( !ResourceDll )
    {
        ResourceDll = (HMODULE) LoadLibrary( L"ntdsmsg.dll" );
    }

    if ( ResourceDll )
    {
        DWORD  WinError = ERROR_SUCCESS;
        BOOL   fSuccess = FALSE;

        fSuccess = ImpersonateLoggedOnUser(gClientToken);
        if (!fSuccess) {
            DPRINT1( 1, "NTDSETUP: Failed to Impersonate Logged On User for FromatMessage: %ul\n", GetLastError() );
        }
        
        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        MessageId,
                                        0,       // Use caller's language
                                        (LPWSTR)&MessageString,
                                        0,       // routine should allocate
                                        (va_list*)&(InsertArray[0])
                                        );
        if ( MessageString )
        {
            // Messages from a message file have a cr and lf appended
            // to the end
            MessageString[Length-2] = L'\0';
        }

        if (fSuccess) {
            if (!RevertToSelf()) {
                DPRINT1( 1, "NTDSETUP: Failed to Revert To Self: %ul\n", GetLastError() );
            }
        }
    }

    if ( !MessageString )
    {
        ASSERT( "NTDSETUP: No message string found - this is ignorable" );

        MessageString = DefaultMessageString;

    }

    DPRINT1( 1, "%ls\n", MessageString );

    if ( gCallBackFunction )
    {
        gCallBackFunction( MessageString );
    }

}

VOID
NtdspSetErrorMessage (
    IN  DWORD  WinError,
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    )
/*++

Routine Description

    This routine calls the calling client's call to give a string description
    of where the error occurred.

Parameters

    WinError : the win32 error that is causing the failure
                                    
    MessageId : the message to retrieve

    Insert*   : strings to insert, if any

Return Values

    None.

--*/
{
    static HMODULE ResourceDll = NULL;

    WCHAR   *DefaultMessageString = L"Preparing the directory service";
    WCHAR   *MessageString = NULL;
    WCHAR   *InsertArray[5];
    ULONG    Length;

    //
    // Set up the insert array
    //
    InsertArray[0] = Insert1;
    InsertArray[1] = Insert2;
    InsertArray[2] = Insert3;
    InsertArray[3] = Insert4;
    InsertArray[4] = NULL;    // This is the sentinel

    if ( !ResourceDll )
    {
        ResourceDll = (HMODULE) LoadLibrary( L"ntdsmsg.dll" );
    }

    if ( ResourceDll )
    {
        DWORD  WinError = ERROR_SUCCESS;
        BOOL   fSuccess = FALSE;

        fSuccess = ImpersonateLoggedOnUser(gClientToken);
        if (!fSuccess) {
            DPRINT1( 1, "NTDSETUP: Failed to Impersonate Logged On User for FromatMessage: %ul\n", GetLastError() );
        }
        
        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        MessageId,
                                        0,       // Use caller's language
                                        (LPWSTR)&MessageString,
                                        0,       // routine should allocate
                                        (va_list*)&(InsertArray[0])
                                        );
        if ( MessageString )
        {
            // Messages from a message file have a cr and lf appended
            // to the end
            MessageString[Length-2] = L'\0';
        }

        if (fSuccess) {
            if (!RevertToSelf()) {
                DPRINT1( 1, "NTDSETUP: Failed to Revert To Self: %ul\n", GetLastError() );
            }
        }
        
    }

    if ( !MessageString )
    {
        ASSERT( "NTDSETUP: No message string found - this is ignorable" );

        MessageString = DefaultMessageString;

    }

    NtdspSetErrorString( MessageString, WinError );

}

DWORD
NtdspCancelOperation(
    VOID
    )

/*++

Routine Description:

Cancel a call to NtdsInstall or NtdsInstallReplicateFull or NtdsDemote

This routine will 

1) set the global state to indicate that a cancel has occurred.
2) if global state indicates that the ds should be shutdown, then it will
issue a shutdown, but NOT close the database.  All threads currently executing
DS calls (like replicating in information) will stop and return.

There are two cases here

A) Cancel occurs during the "critical install" phase (ie schema, configuration or
critical domain objects are being replicated).  This means DsInitialize is in the
call stack, being called from ntdsetup.dll  In this case, once the ds is
called to shutdown (from this routine), DsInitialize will shutdown the 
database itself.

B) Cancel occurs during the NtdsInstallReplicateFull. In this case,
the DsUninitialize called from this function will cause the replication to
stop, but not close the database, so it needs to be closed after 
NtdsInstallReplicateFull returns.  This is performed by the caller of ntdsetup
routines (dsrole api) once it is done with the DS.

It is the callers responsibility to undo the effects of the installation if
necessary.  The caller should keep track of whether it was calling NtdsInstall
or NtdsInstallReplicateFull.  For the former, it should fail the install and
undo; for the latter, it should indicate success.


Arguments:

    void -

Return Value:

    DWORD -

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD shutdownStatus = ERROR_SUCCESS;

    DPRINT( 0, "Cancel notification received\n" );

    LockNtdsCancel();
    {
        Assert( FALSE == gfNtdspCancelled );
        if ( !gfNtdspCancelled )
        {
            // Set the global cancel state to TRUE
            gfNtdspCancelled = TRUE;
        
            // Does the ds need shutting down?
            if ( gfNtdspShutdownDsOnCancel )
            {
                DPRINT( 0, "Shutting down the ds\n" );
                NtStatus = DsUninitialize( TRUE ); // TRUE -> don't shutdown the database,
                                                   // but signal a shutdown
                shutdownStatus = RtlNtStatusToDosError( NtStatus );
                gfNtdspShutdownDsOnCancel = FALSE;
            }
        }
        // else
        //    someone has called cancel twice in a row.  This is bad
        //    but we'll just ignore it
    }
    UnLockNtdsCancel();

    return shutdownStatus;

} /* NtdspInstallCancel */


DWORD
NtdspIsDsCancelOk(
    BOOLEAN fShutdownOk
    )

/*++

Routine Description:

    This routine is called by the DS, (from install code), indicating
    that it is safe to call DsUnitialize(). If the operation had already
    been called then this routine returns ERROR_CANCELLED and the ds install
    path will exit causing DsInitialize() to return ERROR_CANCELLED.

Arguments:

    fShutdownOk - is it ok to shutdown to DS?

Return Value:

    DWORD - ERROR_CANCELLED or ERROR_SUCCESS

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    CHAR* String = NULL;

    LockNtdsCancel();
    {
        String = fShutdownOk ? "TRUE" : "FALSE";
        DPRINT1( 0, "Setting ds shutdown state to %s\n", String );

        // Set the state
        gfNtdspShutdownDsOnCancel = fShutdownOk;

        //
        // Now, if we've already been cancelled, reset the state and 
        // return FAILURE
        //
        if ( gfNtdspCancelled )
        {
            DPRINT( 0, "Cancel already happened; telling ds to return\n" );
            gfNtdspShutdownDsOnCancel = FALSE;
            WinError = ERROR_CANCELLED;
        }

    }
    UnLockNtdsCancel();

    return WinError;
}

//
// Routines to manage the cancel state
//
VOID
NtdspInitCancelState(
    VOID
    )
{
    InitializeCriticalSection( &NtdspCancelCritSect );

    gCallBackFunction = NULL;
    gErrorCallBackFunction = NULL;
    gErrorCodeSet = ERROR_SUCCESS;

    gfNtdspShutdownDsOnCancel = FALSE;
    gfNtdspCancelled = FALSE;
}

VOID
NtdspUnInitCancelState(
    VOID
    )
{
    DeleteCriticalSection( &NtdspCancelCritSect );

    gCallBackFunction = NULL;
    gErrorCallBackFunction = NULL;
    gErrorCodeSet = ERROR_SUCCESS;

    gfNtdspShutdownDsOnCancel = FALSE;
    gfNtdspCancelled = FALSE;
}

//
// Routines to test the if cancellation has occurred
//
BOOLEAN
TEST_CANCELLATION(
    VOID
    )
{
    BOOLEAN fCancel;

    LockNtdsCancel()
    fCancel = gfNtdspCancelled;
    if ( fCancel ) gfNtdspCancelled = FALSE;
    UnLockNtdsCancel();

    return fCancel;
}

VOID 
CLEAR_CANCELLATION(
    VOID
    )
{
    LockNtdsCancel()
    gfNtdspCancelled = FALSE;
    UnLockNtdsCancel();
}


//
// Routines to manage whether the ds should be shutdown
//
VOID
CLEAR_SHUTDOWN_DS(
    VOID
    )
{
    LockNtdsCancel()
    gfNtdspShutdownDsOnCancel = FALSE;
    UnLockNtdsCancel();
}

VOID
SET_SHUTDOWN_DS(
    VOID
    )
{
    LockNtdsCancel()
    gfNtdspShutdownDsOnCancel = TRUE;
    UnLockNtdsCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\ar.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ar.h

Abstract:

    This module contains the declarations of the functions for performing
    Authoritative Restores.

Author:

    Kevin Zatloukal (t-KevinZ) 05-08-98

Revision History:

    05-08-98 t-KevinZ
        Created.

--*/


#ifndef _AR_H_
#define _AR_H_


#ifdef __cplusplus
extern "C" {
#endif


HRESULT
AuthoritativeRestoreFull(
    IN DWORD VersionIncreasePerDay
    );

HRESULT
AuthoritativeRestoreSubtree(
    IN CONST WCHAR *SubtreeRoot,
    IN DWORD VersionIncreasePerDay
    );

HRESULT
AuthoritativeRestoreObject(
    IN CONST WCHAR *SubtreeRoot,
    IN DWORD VersionIncreasePerDay
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\armain.cxx ===
/*++

copyright (c) 1998  Microsoft Corporation

Module Name:

    armain.cxx

Abstract:

    This module contains the definitions of the functions which are called by
    the command parser.  They examine the given arguments and then call into
    ar.c to perform the Authoritative Restore.

Author:

    Kevin Zatloukal (t-KevinZ) 05-08-98

Revision History:
    
    02-17-00 xinhe
        Added restore object.
        
    05-08-98 t-KevinZ
        Created.

--*/

#include <stdio.h>
#include <parser.hxx>
#include "ntdsutil.hxx"
#include "armain.hxx"

#include "resource.h"


extern "C" {
#include "winldap.h"
#include "utilc.h"
#include "ar.h"
}

#define DEFAULT_VERSION_INCREASE 100000


CParser arParser;
BOOL    fArQuit;
BOOL    fArParserInitialized = FALSE;

// Build a table which defines our language.


LegalExprRes arLanguage[] = 
{
    {   L"Help",
        AuthoritativeRestoreHelp,
        IDS_HELP_MSG, 0 },

    {   L"?",
        AuthoritativeRestoreHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        AuthoritativeRestoreQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Restore database",
        AuthoritativeRestoreCommand,
        IDS_AUTH_RESTORE_DB_MSG, 0 },

#ifdef ALLOW_VERSION_INCREASE_OVERRIDES
    {   L"Restore database verinc %d",
        AuthoritativeRestoreCommand,
        IDS_AUTH_RESTORE_DB_VERINC_MSG, 0 },
#endif

    {   L"Restore subtree %s",
        AuthoritativeRestoreCommand,
        IDS_AUTH_RESTORE_SUBTREE_MSG, 0 },

#ifdef ALLOW_VERSION_INCREASE_OVERRIDES
    
    {   L"Restore subtree %s verinc %d",
        AuthoritativeRestoreCommand2,
        IDS_AUTH_RESTORE_SUBTREE_VINC_MSG, 0 },
#endif
    
    {   L"Restore object %s",
        AuthoritativeRestoreObjectCommand,
        IDS_AUTH_RESTORE_OBJECT_MSG, 0 }

#ifdef ALLOW_VERSION_INCREASE_OVERRIDES
    ,
    
    {   L"Restore object %s verinc %d",
        AuthoritativeRestoreObjectCommand2,
        IDS_AUTH_RESTORE_OBJECT_VINC_MSG, 0 }
#endif

};

HRESULT
AuthoritativeRestoreMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !IsSafeMode() )
    {
        return(S_OK);
    }

    if ( !fArParserInitialized )
    {
        cExpr = sizeof(arLanguage) / sizeof(LegalExprRes);

        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (arLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = arParser.AddExpr(arLanguage[i].expr,
                                              arLanguage[i].func,
                                              arLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fArParserInitialized = TRUE;
    fArQuit = FALSE;
    
    prompt = READ_STRING (IDS_PROMPT_AUTH_RESTORE);

    hr = arParser.Parse(gpargc,
                        gpargv,
                        stdin,
                        stdout,
                        prompt,
                        &fArQuit,
                        FALSE,               // timing info
                        FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }
    
    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}


HRESULT AuthoritativeRestoreHelp(CArgs *pArgs)
{
    return(arParser.Dump(stdout,L""));
}


HRESULT AuthoritativeRestoreQuit(CArgs *pArgs)
{
    fArQuit = TRUE;
    return(S_OK);
}


HRESULT
AuthoritativeRestoreCommandworker(
    DWORD versionIncrease,
    CONST WCHAR *subtreeRoot,
    BOOL fObjectOnly
    );

HRESULT
AuthoritativeRestoreCommand(
    CArgs *pArgs
    )
/*++

Routine Description:

    Performs the authoritative restore command.  If subtree root is given,
    only that subtree is updated; otherwise, the entire DIT is updated.

Arguments:

    pArgs - Supplies the argument block.  This could contain no arguments or
       a single integer (the version increase) or an integer and a string
       (the subtree root).

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT result;
    int intVersionIncrease;
    DWORD versionIncrease;
    CONST WCHAR *subtreeRoot;
    

    result = pArgs->GetInt(0, &intVersionIncrease);
    if ( FAILED(result) ) {
        versionIncrease = DEFAULT_VERSION_INCREASE;
    } else {
        versionIncrease = (DWORD) intVersionIncrease;
    }

    result = pArgs->GetString(0, &subtreeRoot);

    if ( FAILED(result) ) {
        subtreeRoot = NULL;
    }

    return AuthoritativeRestoreCommandworker (versionIncrease, subtreeRoot, FALSE );
}

HRESULT
AuthoritativeRestoreCommand2(
    CArgs *pArgs
    )
{
    HRESULT result;
    int intVersionIncrease;
    DWORD versionIncrease;
    CONST WCHAR *subtreeRoot;
    
    result = pArgs->GetString(0, &subtreeRoot);
    if ( FAILED(result) ) {
        subtreeRoot = NULL;
    }

    result = pArgs->GetInt(1, &intVersionIncrease);
    if ( FAILED(result) ) {
        versionIncrease = DEFAULT_VERSION_INCREASE;
    } else {
        versionIncrease = (DWORD) intVersionIncrease;
    }

    return AuthoritativeRestoreCommandworker (versionIncrease, subtreeRoot, FALSE );
}


HRESULT
AuthoritativeRestoreCommandworker(
    DWORD versionIncrease,
    CONST WCHAR *subtreeRoot,
    BOOL fObjectOnly
    )
{
    HRESULT result;

    if ( fPopups ) {

       const WCHAR * message_body  = READ_STRING (IDS_AUTH_RESTORE_CONFIRM_MSG);
       const WCHAR * message_title = READ_STRING (IDS_AUTH_RESTORE_CONFIRM_TITLE);
       
       if (message_body && message_title) {

          int ret =  MessageBoxW(GetFocus(),
                            message_body, 
                            message_title,
                            MB_APPLMODAL |
                            MB_DEFAULT_DESKTOP_ONLY |
                            MB_YESNO |
                            MB_DEFBUTTON2 |
                            MB_ICONQUESTION |
                            MB_SETFOREGROUND);

          RESOURCE_STRING_FREE (message_body);
          RESOURCE_STRING_FREE (message_title);
          
          switch ( ret )
            {
            case IDYES:
                  break;
    
            case IDNO: 
                  RESOURCE_PRINT (IDS_OPERATION_CANCELED);

                  return(S_OK);
            
            default: 
                  RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
                  
                  return(S_OK);    
            }
       }
    }
    
    if ( subtreeRoot == NULL ) {
        result = AuthoritativeRestoreFull(versionIncrease);
    } else if ( !fObjectOnly ){
        result = AuthoritativeRestoreSubtree(subtreeRoot, versionIncrease);
    } else {
        result = AuthoritativeRestoreObject(subtreeRoot, versionIncrease);
    }
    
    return result;

} // AuthoritativeRestoreCommand


HRESULT
AuthoritativeRestoreObjectCommand(
    CArgs *pArgs
    )
/*++

Routine Description:

    Performs the authoritative restore command to restore an object only.
    
Arguments:

    pArgs - Supplies the argument block.  This could contain no arguments or
       a single integer (the version increase) or an integer and a string
       (the subtree root).

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT result;
    int intVersionIncrease;
    DWORD versionIncrease;
    CONST WCHAR *subtreeRoot;
    

    versionIncrease = DEFAULT_VERSION_INCREASE;
    
    result = pArgs->GetString(0, &subtreeRoot);

    if ( FAILED(result) ) {
        return E_INVALIDARG;
    }

    return AuthoritativeRestoreCommandworker (versionIncrease, subtreeRoot, TRUE);
}  //AuthoritativeRestoreObjectCommand

HRESULT
AuthoritativeRestoreObjectCommand2(
    CArgs *pArgs
    )
{
    HRESULT result;
    int intVersionIncrease;
    DWORD versionIncrease;
    CONST WCHAR *subtreeRoot;
    
    result = pArgs->GetString(0, &subtreeRoot);
    if ( FAILED(result) ) {
        return E_INVALIDARG;
    }

    result = pArgs->GetInt(1, &intVersionIncrease);
    if ( FAILED(result) ) {
        versionIncrease = DEFAULT_VERSION_INCREASE;
    } else {
        versionIncrease = (DWORD) intVersionIncrease;
    }

    return AuthoritativeRestoreCommandworker (versionIncrease, subtreeRoot, TRUE);
} //AuthoritativeRestoreObjectCommand2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\compact.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "jetutil.hxx"
#include "resource.h"
#include <dbopen.h>

HRESULT 
Compact(
    CArgs   *pArgs
    )
/*++

  Routine Description: 

    Generates a script for compacting the DB and runs it.

  Parameters: 

    pArgs - Pointer to argument block where 0th arg identifies destination
        for the compacted DB as in-place compaction is not supported 
        by esentutl.exe.

  Return Values:

    Always S_OK except for errors reading arguments.

--*/
{
    HRESULT         hr;
    const WCHAR     *pwszDstDir;
    char            *szDstDir;
    char            *szDstPath;
    SystemInfo      *pInfo;
    ExePathString   szEsentutlPath;
    char            *pTmpDrive;
    DWORD           iDstDrive;
    char            szDstDrive[4];
    DiskSpaceString szDiskSpace;
    DiskSpaceString szDiskSpaceFree;
    BOOL            fIsDir;
    char            *szTmp;
    char			*szTmpDstPath;
    char			*szFullTmpDstPath;
    DWORD           cb;

    if ( FAILED( hr = pArgs->GetString( 0, &pwszDstDir ) ) )
    {
        return hr;
    }

    // Convert arguments from WCHAR to CHAR.

    cb = wcslen( pwszDstDir ) + 1;
    szDstDir = (char *)alloca( cb );
    memset( szDstDir, 0, cb );
    wcstombs( szDstDir, pwszDstDir, wcslen( pwszDstDir ) );

    pInfo = GetSystemInfo();

    if ( !pInfo ) 
    {
        return S_OK;
    }


    if ( DoSoftRecovery( pInfo ) )
    {
        RESOURCE_PRINT( IDS_ERR_SOFT_RECOVERY );
        return S_OK;
    }

    _try
    {
        // Check whether files exist.  We can recover with no logs, but
        // we at least need a DB file.

        if ( gliZero.QuadPart == pInfo->cbDb.QuadPart ) 
        {
           RESOURCE_PRINT( IDS_COMPACT_MISSING_DB );
            _leave;
        }

        // Make sure we have esentutl.exe on this machine.

        if ( !FindExecutable( ESE_UTILITY_PROGRAM, szEsentutlPath ) ) 
        {
            _leave;
        }


        // **********
        // UNDONE: Use splitpath/makepath to parse/build paths
        // instead of trying to do it manually
        // **********


        // Destination should identify drive, path and file so it must
        // minimally have one '\\' to be correct.

        szTmp = strrchr( szDstDir, (int)'\\' );
        if ( !szTmp ) 
        {
           RESOURCE_PRINT1( IDS_COMPACT_PATH_ERROR, szDstDir );
            _leave;
        }

        // Verify that target drive exists.

        strncpy( szDstDrive, szDstDir, 3 );
        szDstDrive[3] = '\0';

        for ( iDstDrive = 0; iDstDrive < pInfo->cDrives; iDstDrive++ ) 
        {
            if ( !_stricmp( pInfo->rDrives[iDstDrive].pszDrive, szDstDrive ) )
            {
                break;
            }
        }

        if ( iDstDrive >= pInfo->cDrives ) 
        {
           RESOURCE_PRINT1( IDS_COMPACT_DEST_ERROR, szDstDir );
            _leave;
        }

        // Emit warning if disk space is low relative to DB size.
        // Variable i is still at matching drive.

        if ( pInfo->rDrives[iDstDrive].dwFreeBytes.QuadPart < pInfo->cbDb.QuadPart )
        {
           FormatDiskSpaceString( &pInfo->cbDb, szDiskSpace );
           FormatDiskSpaceString( &pInfo->rDrives[iDstDrive].dwFreeBytes, szDiskSpaceFree );
           
           RESOURCE_PRINT3( IDS_COMPACT_DISK_WARN, szDiskSpace, szDstDrive, szDiskSpaceFree );
        }

        // To avoid confusion, we require that destination file not exist.
        // I.e. We don't want to accidentally overwrite some file he 
        // really wants to save.

        szDstPath = (CHAR *)alloca( sizeof(CHAR) *
                                    ( strlen( szDstDir )
                                    + strlen( pInfo->pszDbFile )
                                    + 2 ) );    // +2 for possible trailing path delimiter and for null-terminator
        strcpy( szDstPath, szDstDir );
        if ( '\\' != szDstPath[ strlen(szDstPath) - 1 ] )
        {
            strcat( szDstPath, "\\" );
        }
        strcat( szDstPath, pInfo->pszDbFile );

        if ( ExistsFile( szDstPath, &fIsDir ) ) 
        {
            RESOURCE_PRINT1( IDS_COMPACT_FILE_EXISTS,  szDstPath );
            _leave;
        }

          
        // Create directories from root to destination dir.  

        szFullTmpDstPath = (CHAR *)alloca( sizeof(CHAR) * ( strlen( szDstPath ) + 1 ) );
        strcpy( szFullTmpDstPath, szDstPath );

        szTmpDstPath = szFullTmpDstPath + 3;
        while ( szTmp = strchr( szTmpDstPath, (int)'\\' ) )
        {
            *szTmp = '\0';
            if ( CreateDirectory( szFullTmpDstPath, NULL ) )
            {
                RESOURCE_PRINT1( IDS_CREATING_DIR, szFullTmpDstPath );
            }

            *szTmp = '\\';
            szTmpDstPath = szTmp + 1;
        }
          
        // invoke esentutl with the following command-line params:
        //      /d - specifies defrag mode (MUST be first param)
        //      /t - specifies pathed filename of defragged database
        //      /p - preserved both original and defragged database
        //      /o - suppresses "Microsoft Windows Database Utilities" logo
        
        const char * const  szCmdFmt        = "%s /d\"%s\" /t\"%s\" /p /o";
        const SIZE_T        cbCmdFmt        = strlen( szCmdFmt );           // buffer will be slighly over-allocated, big deal!
        const SIZE_T        cbEsentutlPath  = strlen( szEsentutlPath );
        const SIZE_T        cbDbName        = strlen( pInfo->pszDbAll );
        const SIZE_T        cbDstPath       = strlen( szDstPath );
        char * const        szCmd           = (char *)alloca( cbCmdFmt      // over-allocated, so no need for +1 for null-terminator
                                                              + cbEsentutlPath
                                                              + cbDbName
                                                              + cbDstPath );
                                                              

        // WARNING: assert no trailing backslash
        // because it would cause problems with the
        // surrounding quotes that we stick in
        // (a trailing backslash followed by the
        // end quote ends up getting interpreted as
        // an escape sequence)
        ASSERT( '\\' != pInfo->pszDbAll[ cbDbName-1 ] );
        ASSERT( '\\' != szDstPath[ cbDstPath-1 ] );

		sprintf( szCmd,
                 szCmdFmt,
                 szEsentutlPath,
                 pInfo->pszDbAll,
                 szDstPath );
          
        RESOURCE_PRINT1( IDS_EXECUTING_COMMAND, szCmd );

        // WARNING: we're forcing the current directory to
        // be the same directory as where the defragged
        // database will go, so that's the directory that
        // Jet will for its temp. database 

        SpawnCommand( szCmd, szDstDir, NULL );

        RESOURCE_PRINT3( IDS_COMPACT_SUCC_MSG, szDstPath, pInfo->pszDbAll, pInfo->pszLogDir );
    }
    _finally
    {
        FreeSystemInfo( pInfo );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\ar.c ===
/*++

copyright (c) 1998  Microsoft Corporation

Module Name:

    ar.c

Abstract:

    This module contains the definitions of the functions for performing
    Authoritative Restores.

Author:

    Kevin Zatloukal (t-KevinZ) 05-08-98

Revision History:

    02-17-00 xinhe
        Added restore object.

    05-08-98 t-KevinZ
        Created.

--*/


#include <NTDSpch.h>
#pragma hdrstop

#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dsconfig.h>

#include <limits.h>
#include <drs.h>
#include <objids.h>
#include <dsutil.h>
#include <ntdsbsrv.h>
#include <ntdsbcli.h>
#include "parsedn.h"
#include "ditlayer.h"
#include "ar.h"
#include "scheck.h"

#ifndef OPTIONAL
#define OPTIONAL
#endif

#include "reshdl.h"
#include "resource.h"

// ASSERT() is being used in this code base
// Some DS macro's in use here expand to Assert().
// Map them to the same form as the rest.
#define Assert(exp) ASSERT(exp)

typedef
HRESULT
(*VISIT_FUNCTION)(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL AlreadyFilledRetrievalArray
    );

typedef
HRESULT
(*VISIT_LINK_FUNCTION)(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL fDirectionForward
    );

typedef
HRESULT
(*TRAVERSAL_FUNCTION)(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    );


#define SECONDS_PER_DAY (60*60*24)

#define DEFAULT_DN_SIZE 1024

#define MAX_DWORD_DIGITS 10

// These constants represent the number of records to process between updates
// to the progress meter.  There are different constants for different times
// in the program.
#define COUNTING_DISPLAY_DELTA 100
#define UPDATING_DISPLAY_DELTA 10

// This global is used by traversal functions when determining how often to
// update the progress meter.  It should be set to one of the *_DISPLAY_DELTA
// constants from above.
DWORD gCurrentDisplayDelta;

// This global tells how many digits will be used in the progress meter.
DWORD gNumDigitsToPrint;

// This is the amount that version numbers are increased per day that this
// machine has been idle.
DWORD gVersionIncreasePerDay;

// Used by errprintf (see its Routine Description)
BOOL gInUnfinishedLine;

// These globals contain the information that is used by
// AuthoritativeRestoreCurrentObject to update the meta-data of the current
// object.
DWORD  gVersionIncrease;
DSTIME gCurrentTime;
GUID   gDatabaseGuid;

// This global is incremented by each call to CountRecord.  After the traversal
// is completed, it will contain the total number of records that need to be
// updated.
ULONG gRecordCount;

// This global is incremented by each call to
// AuthoritativeRestoreCurrentObject. After the traversal is completed, it
// should contain the same number as gRecordCount.
ULONG gRecordsUpdated;

// This will point to the DN of the root of the subtree to update (if this is
// a subtree Authoritative Restore).
CONST WCHAR *gSubtreeRoot;

// ***************************************************************************
// This is the array of column names from which retrieval array for
// AuthoritativeRestoreCurrentObject is generated.
CONST CHAR *gMainColumnNames[] = {
    SZDNT,
    SZPDNT,
    SZINSTTYPE,
    SZISDELETED,
    SZMETADATA,
    SZOBJCLASS
    };

#define NUM_MAIN_COLUMN_NAMES 6

// This is the retrieval array that is used by
// AuthoritativeRestoreCurrentObject.  It must have been generated from the
// gMainColumnNames array above.
RETRIEVAL_ARRAY *gMainRetrievalArray;

// ***************************************************************************
// These are the names of the columns which are set by
// AuthoritativeRestoreCurrentObject but are not queried.
CHAR *gOtherColumnNames[] = {
    SZDRAUSNNAME,
    SZDRATIMENAME
    };

#define NUM_OTHER_COLUMN_NAMES 2

// These are the column ids for the values which are set by
// AuthoritativeRestoreCurrentObject but not queried.
DWORD gUsnChangedColumnId;
DWORD gWhenChangedColumnId;

// ***************************************************************************
// This is the array of column names from which retrieval array for
// CountRecord is generated.
CONST CHAR *gCountingColumnNames[] = {
    SZDNT,
    SZPDNT,
    SZINSTTYPE,
    SZISDELETED,
    SZOBJCLASS
    };

#define NUM_COUNTING_COLUMN_NAMES 5

// This is the retrieval array that is used by CountRecord.  It must have been
// generated by the gCountingColumnNames array above.
RETRIEVAL_ARRAY *gCountingRetrievalArray;

// ***************************************************************************
// This is the array of link column names from which retrieval array for
// CountRecord is generated.
CONST CHAR *gCountingLinkColumnNames[] = {
    SZLINKDNT,
    SZLINKBASE,
    SZBACKLINKDNT,
    SZLINKMETADATA
    };

#define NUM_COUNTING_LINK_COLUMN_NAMES 4

// This is the retrieval array that is used by CountRecord.  It must have been
// generated by the gCountingColumnNames array above.
RETRIEVAL_ARRAY *gCountingLinkRetrievalArray;

// ***************************************************************************
// This is the array of column names from which retrieval array for
// link table is generated.
CONST CHAR *gLinkColumnNames[] = {
    SZLINKDNT,
    SZLINKBASE,
    SZBACKLINKDNT,
    SZLINKMETADATA,
    SZLINKDELTIME
    };

#define NUM_LINK_COLUMN_NAMES 5

// This is the retrieval array that is used by
// link table.  It must have been generated from the
// gLinkColumnNames array above.
RETRIEVAL_ARRAY *gMainLinkRetrievalArray;

// ***************************************************************************
// These are the names of the columns which are set by
// link table but are not queried.
CHAR *gOtherLinkColumnNames[] = {
    SZLINKUSNCHANGED
    };

// There are assumptions that this is <= NUM_OTHER_COLUMN_NAMES
#define NUM_OTHER_LINK_COLUMN_NAMES 1

// These are the column ids for the values which are set by
// link table but not queried.
DWORD gLinkUsnChangedColumnId;

// ***************************************************************************
// These following globals are all used to ease access into the retrieval
// arrays declared above.  (See AuthoritativeRestore find out how they are
// used.)
JET_RETRIEVECOLUMN *gDntVal;
JET_RETRIEVECOLUMN *gPDntVal;
JET_RETRIEVECOLUMN *gInstanceTypeVal;
JET_RETRIEVECOLUMN *gIsDeletedVal;
JET_RETRIEVECOLUMN *gMetaDataVal;
JET_RETRIEVECOLUMN *gObjClassVal;

DWORD gDntIndex;
DWORD gPDntIndex;
DWORD gInstanceTypeIndex;
DWORD gIsDeletedIndex;
DWORD gMetaDataIndex;
DWORD gObjClassIndex;

JET_RETRIEVECOLUMN *gLinkDntVal;
JET_RETRIEVECOLUMN *gLinkBaseVal;
JET_RETRIEVECOLUMN *gBackLinkDntVal;
JET_RETRIEVECOLUMN *gLinkMetaDataVal;
JET_RETRIEVECOLUMN *gLinkDelTimeVal;

DWORD gLinkDntIndex;
DWORD gLinkBaseIndex;
DWORD gBackLinkDntIndex;
DWORD gLinkMetaDataIndex;
DWORD gLinkDelTimeIndex;

// When the subtree traversal finds the head of a new DC, it adds the DNT of
// that record to this list, and after the subtree traversal is done, it
// prints out a list of the sub-NCs that were encountered.
DWORD *gSubrefList;

DWORD gSubrefListSize;
DWORD gSubrefListMaxSize;

#define DEFAULT_SUBREF_LIST_SIZE 8

// We only want to update the subref list during one of the two passes.
BOOL gUpdateSubrefList;

// The DNT of the Schema object.
DWORD gSchemaDnt;

// This global is used to store a description of a Jet error that has occured.
WCHAR gJetErrorDescription[MAX_JET_ERROR_LENGTH];

HRESULT
GetRegDword(
    IN CHAR *KeyName,
    OUT DWORD *OutputDword,
    IN BOOL Optional
    );

HRESULT
AuthoritativeRestore(
    IN TRAVERSAL_FUNCTION Traversal
    );

HRESULT
TraverseDit(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    );

HRESULT
TraverseSubtree(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    );


HRESULT
TraverseObject(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    );

HRESULT
CountRecord(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL AlreadyFilledRetrievalArray
    );

HRESULT
CountLink(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL fDirectionForward
    );

HRESULT
AuthoritativeRestoreCurrentObject(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL AlreadyFilledRetrievalArray
    );

HRESULT
AuthoritativeRestoreCurrentLink(
    IN DB_STATE *DbState,
    IN TABLE_STATE *LinkTableState,
    IN BOOL fDirectionForward
    );

HRESULT
TraverseSubtreeRecursive(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit,
    IN BOOL SubtreeRoot
    );

HRESULT
GetVersionIncrease(
    IN DB_STATE *DbState,
    OUT DWORD *VersionIncrease
    );

HRESULT
GetCurrentDsTime(
    OUT DSTIME *CurrentTime
    );

ULONG
NumDigits(
    IN ULONG N
    );

HRESULT
MetaDataLookup(
    IN ATTRTYP AttributeType,
    IN PROPERTY_META_DATA_VECTOR *MetaDataVector,
    OUT DWORD *Index
    );

HRESULT
MetaDataInsert(
    IN ATTRTYP AttributeType,
    IN OUT PROPERTY_META_DATA_VECTOR **MetaDataVector,
    IN OUT DWORD *BufferSize
    );

HRESULT
DsTimeToString(
    IN DSTIME Time,
    OUT CHAR *String
    );

int
errprintf(
    IN char *FormatString,
    IN ...
    );

int
errprintfRes(
    IN UINT FormatStringId,
    IN ...
    );

int
dbgprintf(
    IN CHAR *FormatString,
    IN ...
    );

HRESULT
ARAlloc(
    OUT VOID **Buffer,
    IN DWORD Size
    );

HRESULT
ARRealloc(
    IN OUT VOID **Buffer,
    IN OUT DWORD *CurrentSize
    );

VOID
UpdateProgressMeter(
    IN DWORD Progress,
    IN BOOL MustUpdate
    );



HRESULT
AuthoritativeRestoreFull(
    IN DWORD VersionIncreasePerDay
    )
/*++

Routine Description:

    This function performs an Authoritative Restore on the entire DIT.

Arguments:

    VersionIncreasePerDay - Supplies the amount by which to increase the
        version numbers for each day that the DIT has been idle.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    gVersionIncreasePerDay = VersionIncreasePerDay;
    gSubtreeRoot = NULL;

    return AuthoritativeRestore(&TraverseDit);

} // AuthoritativeRestoreFull



HRESULT
AuthoritativeRestoreSubtree(
    IN CONST WCHAR *SubtreeRoot,
    IN DWORD VersionIncreasePerDay
    )
/*++

Routine Description:

    This function performs an Authoritative Restore on the subtree of the DIT
    which is rooted at the given object.

Arguments:

    VersionIncreasePerDay - Supplies the amount by which to increase the
        version numbers for each day that the DIT has been idle.
    SubtreeRoot - Supplies the Subtree of the root to restore.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    gVersionIncreasePerDay = VersionIncreasePerDay;
    gSubtreeRoot = SubtreeRoot;

    return AuthoritativeRestore(&TraverseSubtree);

} // AuthoritativeRestoreSubtree



HRESULT
AuthoritativeRestoreObject(
    IN CONST WCHAR *SubtreeRoot,
    IN DWORD VersionIncreasePerDay
    )
/*++

Routine Description:

    This function performs an Authoritative Restore on the given object
    -- SubtreeRoot.

Arguments:

    VersionIncreasePerDay - Supplies the amount by which to increase the
        version numbers for each day that the DIT has been idle.
    SubtreeRoot - Supplies the object.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    gVersionIncreasePerDay = VersionIncreasePerDay;
    gSubtreeRoot = SubtreeRoot;

    return AuthoritativeRestore(&TraverseObject);

} // AuthoritativeRestoreSubtree





HRESULT
AuthoritativeRestore(
    IN TRAVERSAL_FUNCTION Traverse
    )
/*++

Routine Description:

    This function performs an authoritative restore.  The given traversal
    function is used select which records are updated.

Arguments:

    Traversal - Supplies the TRAVERSAL_FUNCTION which enumerates through the
        objects to be updated.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    RPC_STATUS rpcStatus;

    DB_STATE *dbState = NULL;
    TABLE_STATE *tableState = NULL;
    TABLE_STATE *linkTableState = NULL;
    ULONG maxRecordCount;
    DWORD i;
    WCHAR *dnBuffer = NULL;
    DWORD dnBufferSize = 0;
    DWORD size;
    DWORD columnIds[NUM_OTHER_COLUMN_NAMES];
    BOOL  fRestored = FALSE;
    DWORD restValue = 0;

    if ( Traverse == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    /* initialize global variables */
    gInUnfinishedLine = FALSE;
    gSubrefList = NULL;
    gSubrefListSize = 0;
    gSubrefListMaxSize = 0;

    DitSetErrorPrintFunction(&errprintfRes);

    //"\nOpening DIT database... "
    RESOURCE_PRINT (IDS_AR_OPEN_DB_DIT);

    gInUnfinishedLine = TRUE;

    result = DitOpenDatabase(&dbState);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    //"done.\n"
    RESOURCE_PRINT (IDS_DONE);
    gInUnfinishedLine = FALSE;

    result = DitOpenTable(dbState, SZDATATABLE, SZDNTINDEX, &tableState);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    // SZLINKALLINDEX includes both present and absent link values
    result = DitOpenTable(dbState, SZLINKTABLE, SZLINKALLINDEX, &linkTableState);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = GetVersionIncrease(dbState, &gVersionIncrease);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = GetCurrentDsTime(&gCurrentTime);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    //
    // Determine if we have been restored from backup.
    //

    if (GetRegDword(DSA_RESTORED_DB_KEY, &restValue, TRUE) == S_OK) {
        fRestored = TRUE;
    }

    //
    // if this was not a restore from backup, use the current invocation ID.
    // else, create a new one.
    //

    if ( !fRestored ) {

        result = DitGetDatabaseGuid(dbState, &gDatabaseGuid);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }
    } else {

        DWORD         err;
        USN           usnAtBackup;
        LPSTR         pszUsnChangedColName = SZDRAUSNNAME;
        LPSTR         pszLinkUsnChangedColName = SZLINKUSNCHANGED;
        JET_COLUMNID  usnChangedId, linkUsnChangedId;

        err = DitGetColumnIdsByName(dbState,
                                    tableState,
                                    &pszUsnChangedColName,
                                    1,
                                    &usnChangedId);
        Assert(0 == err);

        err = DitGetColumnIdsByName(dbState,
                                    linkTableState,
                                    &pszLinkUsnChangedColName,
                                    1,
                                    &linkUsnChangedId);
        Assert(0 == err);

        if (0 == err) {
            // Save the usn-at-backup in the hidden table before we allocate
            // any new usns. We take the highest-in-use usn under the *old*
            // invocation id to be the usn-at- backup. If we did not capture
            // this now, use of new usns during AR would throw off our count.
            // The fact that these AR usn's are written under the new Invocation
            // Id doesn't help since the highest-in-use usn determination does
            // not consider which invocation id the usn was written under.
            // usnAtBackup is NOT used
            err = ErrGetBackupUsnFromDatabase(dbState->databaseId,
                                              dbState->sessionId,
                                              dbState->hiddenTableId,
                                              dbState->sessionId,
                                              tableState->tableId,
                                              usnChangedId,
                                              linkTableState->tableId,
                                              linkUsnChangedId,
                                              FALSE, // update usn in hidden
                                              &usnAtBackup);
            Assert(0 == err);
        }

        if (0 == err) {
            //
            // Get a uuid. This routine will check to see if we already
            // allocated a new one. If so, it uses that. This is to handle
            // the case of multiple Auth restores.
            //

            err = ErrGetNewInvocationId(NEW_INVOCID_CREATE_IF_NONE,
                                        &gDatabaseGuid);
            Assert(0 == err);
        }

        if (err != ERROR_SUCCESS) {
            //"Cannot generate new invocation id for dsa. Error %d\n"
            errprintfRes(IDS_AR_ERR_GEN_INVOK_ID_DSA, err);

            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
    }

    result = DitGetSchemaDnt(dbState, &gSchemaDnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    // Make a preliminary pass through the updateable objects just to count
    // them.

    result = DitCreateRetrievalArray(dbState,
                                     tableState,
                                     gCountingColumnNames,
                                     NUM_COUNTING_COLUMN_NAMES,
                                     &gCountingRetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    gDntIndex          = gCountingRetrievalArray->indexes[0];
    gPDntIndex         = gCountingRetrievalArray->indexes[1];
    gInstanceTypeIndex = gCountingRetrievalArray->indexes[2];
    gIsDeletedIndex    = gCountingRetrievalArray->indexes[3];
    gObjClassIndex     = gCountingRetrievalArray->indexes[4];

    gDntVal         = &gCountingRetrievalArray->columnVals[gDntIndex];
    gPDntVal        = &gCountingRetrievalArray->columnVals[gPDntIndex];
    gInstanceTypeVal= &gCountingRetrievalArray->columnVals[gInstanceTypeIndex];
    gIsDeletedVal   = &gCountingRetrievalArray->columnVals[gIsDeletedIndex];
    gObjClassVal    = &gCountingRetrievalArray->columnVals[gObjClassIndex];

    result = DitCreateRetrievalArray(dbState,
                                     linkTableState,
                                     gCountingLinkColumnNames,
                                     NUM_COUNTING_LINK_COLUMN_NAMES,
                                     &gCountingLinkRetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    gLinkDntIndex          = gCountingLinkRetrievalArray->indexes[0];
    gLinkBaseIndex         = gCountingLinkRetrievalArray->indexes[1];
    gBackLinkDntIndex      = gCountingLinkRetrievalArray->indexes[2];
    gLinkMetaDataIndex     = gCountingLinkRetrievalArray->indexes[3];

    gLinkDntVal         = &gCountingLinkRetrievalArray->columnVals[gLinkDntIndex];
    gLinkBaseVal        = &gCountingLinkRetrievalArray->columnVals[gLinkBaseIndex];
    gBackLinkDntVal     = &gCountingLinkRetrievalArray->columnVals[gBackLinkDntIndex];
    gLinkMetaDataVal    = &gCountingLinkRetrievalArray->columnVals[gLinkMetaDataIndex];

    gNumDigitsToPrint = MAX_DWORD_DIGITS;

    //"\nCounting records that need updating...\n");
    //"Records found: %0*u", gNumDigitsToPrint, 0);
    RESOURCE_PRINT2 (IDS_AR_RECORDS_UPDATE1, gNumDigitsToPrint, 0);

    gInUnfinishedLine = TRUE;

    gCurrentDisplayDelta = COUNTING_DISPLAY_DELTA;
    gUpdateSubrefList = FALSE;
    gRecordCount = 0;

    result = (*Traverse)(dbState,
                         tableState,
                         linkTableState,
                         gCountingRetrievalArray,
                         gCountingLinkRetrievalArray,
                         CountRecord,
                         CountLink);

    if ( FAILED(result) ) {
        if ( *(DWORD*)gDntVal->pvData > 0 ) {
            //"Failed to update record with DNT %u.\n"
            errprintfRes(IDS_AR_ERR_FAILED_UPDATE_REC,
                      *(DWORD*)gDntVal->pvData);
        }
        returnValue = result;
        goto CleanUp;
    }

    UpdateProgressMeter(gRecordCount, TRUE);
    putchar('\n');
    gInUnfinishedLine = FALSE;

    //"Done.\n"
    RESOURCE_PRINT (IDS_DONE);

    //"\nFound %u records to update.\n"
    RESOURCE_PRINT1 (IDS_AR_RECORDS_UPDATE2, gRecordCount);

    result = DitDestroyRetrievalArray(&gCountingRetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitDestroyRetrievalArray(&gCountingLinkRetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }


    // Preallocate all of the USNs that we will need.

    result = DitPreallocateUsns(dbState, gRecordCount);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }


    // Now, make a second pass.  This time update the objects for real.

    result = DitCreateRetrievalArray(dbState,
                                     tableState,
                                     gMainColumnNames,
                                     NUM_MAIN_COLUMN_NAMES,
                                     &gMainRetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    gDntIndex           = gMainRetrievalArray->indexes[0];
    gPDntIndex          = gMainRetrievalArray->indexes[1];
    gInstanceTypeIndex  = gMainRetrievalArray->indexes[2];
    gIsDeletedIndex     = gMainRetrievalArray->indexes[3];
    gMetaDataIndex      = gMainRetrievalArray->indexes[4];
    gObjClassIndex      = gMainRetrievalArray->indexes[5];

    gDntVal           = &gMainRetrievalArray->columnVals[gDntIndex];
    gPDntVal          = &gMainRetrievalArray->columnVals[gPDntIndex];
    gInstanceTypeVal  = &gMainRetrievalArray->columnVals[gInstanceTypeIndex];
    gIsDeletedVal     = &gMainRetrievalArray->columnVals[gIsDeletedIndex];
    gMetaDataVal      = &gMainRetrievalArray->columnVals[gMetaDataIndex];
    gObjClassVal      = &gMainRetrievalArray->columnVals[gObjClassIndex];

    result = DitGetColumnIdsByName(dbState,
                                   tableState,
                                   gOtherColumnNames,
                                   NUM_OTHER_COLUMN_NAMES,
                                   columnIds);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    gUsnChangedColumnId  = columnIds[0];
    gWhenChangedColumnId = columnIds[1];

    // Link retrieval array

    result = DitCreateRetrievalArray(dbState,
                                     linkTableState,
                                     gLinkColumnNames,
                                     NUM_LINK_COLUMN_NAMES,
                                     &gMainLinkRetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    gLinkDntIndex          = gMainLinkRetrievalArray->indexes[0];
    gLinkBaseIndex         = gMainLinkRetrievalArray->indexes[1];
    gBackLinkDntIndex      = gMainLinkRetrievalArray->indexes[2];
    gLinkMetaDataIndex     = gMainLinkRetrievalArray->indexes[3];
    gLinkDelTimeIndex      = gMainLinkRetrievalArray->indexes[4];

    gLinkDntVal         = &gMainLinkRetrievalArray->columnVals[gLinkDntIndex];
    gLinkBaseVal        = &gMainLinkRetrievalArray->columnVals[gLinkBaseIndex];
    gBackLinkDntVal     = &gMainLinkRetrievalArray->columnVals[gBackLinkDntIndex];
    gLinkMetaDataVal    = &gMainLinkRetrievalArray->columnVals[gLinkMetaDataIndex];
    gLinkDelTimeVal     = &gMainLinkRetrievalArray->columnVals[gLinkDelTimeIndex];

    // Link other columns
    result = DitGetColumnIdsByName(dbState,
                                   linkTableState,
                                   gOtherLinkColumnNames,
                                   NUM_OTHER_LINK_COLUMN_NAMES,
                                   columnIds);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    gLinkUsnChangedColumnId  = columnIds[0];

    //"\nUpdating records...\n"
    RESOURCE_PRINT (IDS_AR_RECORDS_UPDATE3);

    //"Records remaining: %0*u"
    RESOURCE_PRINT2( IDS_AR_RECORDS_REMAIN, gNumDigitsToPrint, gRecordCount);

    gInUnfinishedLine = TRUE;

    gCurrentDisplayDelta = UPDATING_DISPLAY_DELTA;
    gUpdateSubrefList = TRUE;
    gRecordsUpdated = 0;

    result = (*Traverse)(dbState,
                         tableState,
                         linkTableState,
                         gMainRetrievalArray,
                         gMainLinkRetrievalArray,
                         AuthoritativeRestoreCurrentObject,
                         AuthoritativeRestoreCurrentLink );
    if ( FAILED(result) ) {
        if ( *(DWORD*)gDntVal->pvData > 0 ) {
            //"Failed to update record with DNT %u.\n"
            errprintfRes(IDS_AR_ERR_FAILED_UPDATE_REC,
                      *(DWORD*)gDntVal->pvData);
        }
        returnValue = result;
        goto CleanUp;
    }

    UpdateProgressMeter(gRecordsUpdated - gRecordCount, TRUE);
    putchar('\n');
    gInUnfinishedLine = FALSE;
    //"Done.\n"
    RESOURCE_PRINT (IDS_DONE);

    //"\nSuccessfully updated %u records.\n"
    RESOURCE_PRINT1 (IDS_AR_RECORDS_UPDATED, gRecordsUpdated);


    if ( gSubrefList != NULL ) {

        dnBufferSize = sizeof(WCHAR) * DEFAULT_DN_SIZE;
        result = ARAlloc(&dnBuffer, dnBufferSize);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        //"\nThe following sub-NCs were not updated:\n"
        RESOURCE_PRINT (IDS_AR_RECORDS_NON_UPDATED);

        for ( i = 0; i < gSubrefListSize; i++ ) {

            result = DitGetDnFromDnt(dbState,
                                     tableState,
                                     gSubrefList[i],
                                     &dnBuffer,
                                     &dnBufferSize);
            if ( FAILED(result) ) {
                returnValue = result;
                goto CleanUp;
            } else if ( result == S_FALSE ) {
                //"Could not find subref %u in the database.\n"
                errprintfRes(IDS_AR_ERR_FIND_SUBREF,
                          gSubrefList[i]);
                returnValue = E_UNEXPECTED;
                goto CleanUp;
            }

            printf(" (%d) %S\n", i, dnBuffer);
        }
    }


CleanUp:

    if ( SUCCEEDED(returnValue) ) {
        //"\nAuthoritative Restore completed successfully.\n\n"
        errprintfRes (IDS_AR_AUTH_RESTORE_COMPLETE);
    } else {
        //"\nAuthoritative Restore failed.\n\n"
        errprintfRes(IDS_AR_AUTH_RESTORE_FAIL);
    }

    if ( gSubrefList != NULL ) {
        free(gSubrefList);
        gSubrefList = NULL;
    }

    if ( dnBuffer != NULL ) {
        free(dnBuffer);
        dnBuffer = NULL;
    }

    if ( gCountingRetrievalArray != NULL ) {
        result = DitDestroyRetrievalArray(&gCountingRetrievalArray);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( gCountingLinkRetrievalArray != NULL ) {
        result = DitDestroyRetrievalArray(&gCountingLinkRetrievalArray);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( gMainRetrievalArray != NULL ) {
        result = DitDestroyRetrievalArray(&gMainRetrievalArray);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( gMainLinkRetrievalArray != NULL ) {
        result = DitDestroyRetrievalArray(&gMainLinkRetrievalArray);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( tableState != NULL ) {
        result = DitCloseTable(dbState, &tableState);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( linkTableState != NULL ) {
        result = DitCloseTable(dbState, &linkTableState);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( dbState != NULL ) {
        result = DitCloseDatabase(&dbState);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( gSubrefList != NULL ) {
        free(gSubrefList);
        gSubrefList = NULL;
    }

    return returnValue;

} // AuthoritativeRestore



HRESULT
TraverseLinksSingleDirection(
    IN DB_STATE *DbState,
    IN DWORD Dnt,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN BOOL fDirectionForward,
    IN VISIT_LINK_FUNCTION LinkVisit
    )
/*++

Routine Description:

    This function traverses through all of the links under the named
    object and calls the function Visit to process them.

    Note that this function may change the default index of the link table.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    Dnt - Dnt of containing object for the links
    LinkTableState - Supplies the state of the opened DIT table.
    LinkRetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    fDirectionForward - Whether we are visiting forward links for backward links
    LinkVisit - Supplies the function which will be called to process each record
        visitted.

Return Value:

    S_OK - The record was modified successfully.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    DWORD linkObjectDnt, linkValueDnt;

    if ( (DbState == NULL) ||
         (LinkTableState == NULL) ||
         (LinkVisit == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    // Change to proper index
    // Note that this call does nothing if we are already on the right index
    result = DitSetIndex(DbState,
                         LinkTableState,
                         fDirectionForward ? SZLINKALLINDEX : SZBACKLINKALLINDEX,
                         TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    // Construct a search key that matches on the first segment dnt.  Note that we
    // do not create a second segment to match on link base, since we want all
    // links for a given object and don't care about which attribute they are.
    jetResult = JetMakeKey(DbState->sessionId,
                           LinkTableState->tableId,
                           &Dnt,
                           sizeof(Dnt),
                           JET_bitNewKey);
    if ( jetResult != JET_errSuccess ) {
        //"Could not move cursor in DIT database: %ws.\n"
        errprintfRes(IDS_AR_ERR_MOVE_CURSOR_DIT,
                  GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // find first matching record
    jetResult = JetSeek(DbState->sessionId,
                        LinkTableState->tableId,
                        JET_bitSeekGE);

    if ((jetResult != JET_errSuccess) && (jetResult != JET_wrnSeekNotEqual)) {
        // no records
        return S_OK;
    }

    jetResult = JET_errSuccess;

    while ( jetResult == JET_errSuccess ) {

        // Read the record
        result = DitGetColumnValues(DbState,
                                    LinkTableState,
                                    LinkRetrievalArray);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        if (fDirectionForward) {
            linkObjectDnt = *(DWORD*)gLinkDntVal->pvData;
            linkValueDnt = *(DWORD*)gBackLinkDntVal->pvData;
        } else {
            linkValueDnt = *(DWORD*)gLinkDntVal->pvData;
            linkObjectDnt = *(DWORD*)gBackLinkDntVal->pvData;
        }

        if (Dnt != linkObjectDnt ) {
            // Moved beyond current object
            return S_OK;
        }

        result = (*LinkVisit)(DbState, LinkTableState, fDirectionForward);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        jetResult = JetMove(DbState->sessionId,
                            LinkTableState->tableId,
                            JET_MoveNext,
                            0);

    }

    if ( jetResult != JET_errNoCurrentRecord ) {
        //"Could not move cursor in DIT database: %ws.\n"
        errprintfRes(IDS_AR_ERR_MOVE_CURSOR_DIT,
                  GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }


CleanUp:

    return returnValue;

} // TraverseDit



HRESULT
TraverseDit(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    )
/*++

Routine Description:

    This function traverses through all of the objects in the DIT and calls
    the function Visit to process them.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    LinkTableState - Supplies the state of the opened DIT table.
    RetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    LinkRetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    Visit - Supplies the function which will be called to process each record
        visited.
    LinkVisit - Supplies the function which will be called to process each record
        visited.

Return Value:

    S_OK - The record was modified successfully.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    ULONG i;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (LinkTableState == NULL) ||
         (LinkVisit == NULL) ||
         (Visit == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    jetResult = JetMove(DbState->sessionId,
                        TableState->tableId,
                        JET_MoveFirst,
                        0);

    while ( jetResult == JET_errSuccess ) {

        result = (*Visit)(DbState, TableState, FALSE);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        result = TraverseLinksSingleDirection(
            DbState,
            *(DWORD*)gDntVal->pvData,
            LinkTableState,
            LinkRetrievalArray,
            TRUE, // forward links
            LinkVisit );
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        result = TraverseLinksSingleDirection(
            DbState,
            *(DWORD*)gDntVal->pvData,
            LinkTableState,
            LinkRetrievalArray,
            FALSE, // backward links
            LinkVisit );
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        jetResult = JetMove(DbState->sessionId,
                            TableState->tableId,
                            JET_MoveNext,
                            0);

    }

    if ( jetResult != JET_errNoCurrentRecord ) {
        //"Could not move cursor in DIT database: %ws.\n"
        errprintfRes(IDS_AR_ERR_MOVE_CURSOR_DIT,
                  GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }


CleanUp:

    return returnValue;

} // TraverseDit



HRESULT
TraverseSubtree(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    )
/*++

Routine Description:

    This function traverses through all of the objects in the subtree rooted
    at the current object and calls the function Visit to process them.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    LinkTableState - Supplies the state of the opened DIT table.
    RetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    LinkRetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    Visit - Supplies the function which will be called to process each record
        visitted.
    LinkVisit - Supplies the function which will be called to process each record
        visited.

Return Value:

    S_OK - The record was modified successfully.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (Visit == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToDn(DbState, TableState, gSubtreeRoot);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = TraverseSubtreeRecursive(DbState,
                                      TableState,
                                      LinkTableState,
                                      RetrievalArray,
                                      LinkRetrievalArray,
                                      Visit,
                                      LinkVisit,
                                      TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

CleanUp:

    return returnValue;

} // TraverseSubtree



HRESULT
TraverseSubtreeRecursive(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit,
    IN BOOL SubtreeRoot
    )
/*++

Routine Description:

    This function finishes the work of TraverseSubtree by recursively visiting
    the records in the subtree rooted at this object.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    LinkTableState - Supplies the state of the opened DIT table.
    RetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    LinkRetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    Visit - Supplies the function which will be called to process each record
        visited.
    LinkVisit - Supplies the function which will be called to process each record
        visited.
    SubtreeRoot - Supplies whether this call is being made on the root of the
        subtree (this is a slightly special case).

Return Value:

    S_OK - The record was modified successfully.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;

    DWORD size;
    DWORD pDnt;
    DWORD *newSubrefList;
    BOOL moveFirst = FALSE;  // we only need to move first when there is no
                             // current record


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (Visit == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitGetColumnValues(DbState, TableState, RetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    pDnt = *(DWORD*)gDntVal->pvData;

    if ( (*(SYNTAX_INTEGER*)gInstanceTypeVal->pvData & IT_NC_HEAD) &&
         (!SubtreeRoot) ) {

        if ( gUpdateSubrefList ) {

            if ( gSubrefList == NULL ) {

                gSubrefListMaxSize = DEFAULT_SUBREF_LIST_SIZE;

                result = ARAlloc(&gSubrefList,
                                 gSubrefListMaxSize * sizeof(DWORD));
                if ( FAILED(result) ) {
                    returnValue = result;
                    goto CleanUp;
                }

            } else if ( gSubrefListSize == gSubrefListMaxSize ) {

                size = gSubrefListMaxSize * sizeof(DWORD);

                result = ARRealloc(&gSubrefList, &size);
                if ( FAILED(result) ) {
                    returnValue = result;
                    goto CleanUp;
                }

                gSubrefListMaxSize *= 2;
            }

            gSubrefList[gSubrefListSize] = *(DWORD*)gDntVal->pvData;
            gSubrefListSize++;

        }

        goto CleanUp;

    }

    result = (*Visit)(DbState, TableState, TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = TraverseLinksSingleDirection(
        DbState,
        *(DWORD*)gDntVal->pvData,
        LinkTableState,
        LinkRetrievalArray,
        TRUE, // forward links
        LinkVisit );
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = TraverseLinksSingleDirection(
        DbState,
        *(DWORD*)gDntVal->pvData,
        LinkTableState,
        LinkRetrievalArray,
        FALSE, // backward links
        LinkVisit );
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToFirstChild(DbState, TableState, pDnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    } else if ( result == S_FALSE ) {
        // there aren't any records at all, so just skip to the bottom
        moveFirst = TRUE;
        goto RestoreCursor;
    }

    result = DitGetColumnValues(DbState, TableState, RetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    jetResult = JET_errSuccess;

    while ( (jetResult == JET_errSuccess) &&
            (*(DWORD*)gPDntVal->pvData == pDnt) ) {

        result = TraverseSubtreeRecursive(DbState,
                                          TableState,
                                          LinkTableState,
                                          RetrievalArray,
                                          LinkRetrievalArray,
                                          Visit,
                                          LinkVisit,
                                          FALSE);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        jetResult = JetMove(DbState->sessionId,
                            TableState->tableId,
                            JET_MoveNext,
                            0);
        if ( jetResult == JET_errNoCurrentRecord ) {

            moveFirst = TRUE;
            break;

        } else if ( jetResult != JET_errSuccess ) {

            //"Could not move in \"%hs\" table: %ws.\n"
            errprintfRes(IDS_AR_ERR_MOVE_IN_TABLE,
                      TableState->tableName,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

        result = DitGetColumnValues(DbState, TableState, RetrievalArray);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        } else if ( result == S_FALSE ) {
            break;
        }

    }

RestoreCursor:

    result = DitSetIndex(DbState, TableState, SZDNTINDEX, TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToDnt(DbState, TableState, pDnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }


CleanUp:

    return returnValue;

} // TraverseSubtreeRecursive


HRESULT
TraverseObject(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN TABLE_STATE *LinkTableState,
    IN RETRIEVAL_ARRAY *RetrievalArray,
    IN RETRIEVAL_ARRAY *LinkRetrievalArray,
    IN VISIT_FUNCTION Visit,
    IN VISIT_LINK_FUNCTION LinkVisit
    )
/*++

Routine Description:

    This function finds the given object in the database,
    and call function Visit to handle it.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    LinkTableState - Supplies the state of the opened DIT table.
    RetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    LinkRetrievalArray - Supplies the retrieval array which needs to be filled for
        this Visit function.
    Visit - Supplies the function which will be called to process each record
        visited.
    LinkVisit - Supplies the function which will be called to process each record
        visited.

Return Value:

    S_OK - The record was modified successfully.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;

    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (Visit == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitSeekToDn(DbState, TableState, gSubtreeRoot);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitGetColumnValues(DbState, TableState, RetrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }


    result = (*Visit)(DbState, TableState, TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = TraverseLinksSingleDirection(
        DbState,
        *(DWORD*)gDntVal->pvData,
        LinkTableState,
        LinkRetrievalArray,
        TRUE, // forward links
        LinkVisit );
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = TraverseLinksSingleDirection(
        DbState,
        *(DWORD*)gDntVal->pvData,
        LinkTableState,
        LinkRetrievalArray,
        FALSE, // backward links
        LinkVisit );
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

CleanUp:

    return returnValue;

} // TraverseObject



HRESULT
CountRecord(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL AlreadyFilledRetrievalArray
    )
/*++

Routine Description:

    This function increments the global variable gRecordCount.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    AlreadyFilledRetrievalArray - Supplies a boolean telling whether the
        gMainRetrievalArray has already been filled with the information for
        this record.

Return Value:

    S_OK - The record was modified successfully.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;

    DWORD i;


    if ( !AlreadyFilledRetrievalArray ) {

        result = DitGetColumnValues(DbState,
                                    TableState,
                                    gCountingRetrievalArray);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

    }

    // we only update objects with the following properties:
    //
    // Writeable: users shouldn't be allowed to restore objects they are not
    // allowed to write.
    //
    // Not Deleted: if this object has been restored (by the system), 99% of
    // the time, it will just be restored again if we delete it again, so why
    // bother.
    //
    // LostAndFound -- replication protocol assumes this is the first object
    // replicated in in the NC.  This object can't be modified elsewhere in
    // the system, so no need to authoritatively restore it.

    if ( (gIsDeletedVal->err == JET_wrnColumnNull) &&
         (*(SYNTAX_INTEGER*)gInstanceTypeVal->pvData & IT_WRITE) &&
         (*(DWORD*)gDntVal->pvData != gSchemaDnt) &&
         (*(DWORD*)gPDntVal->pvData != gSchemaDnt) &&
         (*(ATTRTYP*)gObjClassVal->pvData != CLASS_LOST_AND_FOUND) ) {

        gRecordCount++;

        UpdateProgressMeter(gRecordCount, FALSE);

    }


CleanUp:

    return returnValue;

} // CountRecord


HRESULT
CountLink(
    IN DB_STATE *DbState,
    IN TABLE_STATE *LinkTableState,
    IN BOOL fDirectionForward
    )
/*++

Routine Description:

    This function increments the global variable gRecordCount.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    LinkTableState - Supplies the state of the opened DIT table.
    fDirectionForward - Whether this is a forward link or a backward link.
        Use this information to determine the two ends of the link

Return Value:

    S_OK - The record was modified successfully.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;

    // Only count values with metadata. Ignore legacy values.
    if (gLinkMetaDataVal->cbActual != 0) {
        gRecordCount++;

        UpdateProgressMeter(gRecordCount, FALSE);
    }

    return returnValue;

} // CountLink



HRESULT
AuthoritativeRestoreCurrentObject(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN BOOL AlreadyFilledRetrievalArray
    )
/*++

Routine Description:

    If the current record is writeable and non-deleted, this function updates
    its meta-data so that it appears to have been written to its current
    value at the given time at the given DC.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    AlreadyFilledRetrievalArray - Supplies a boolean telling whether the
        gMainRetrievalArray has already been filled with the information for
        this record.

Return Value:

    S_OK - The record was modified successfully.
    S_FALSE - The record was deleted or not writeable
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_FALSE;
    HRESULT result;
    JET_ERR jetResult;

    DWORD i;
    BOOL inTransaction = FALSE;
    CHAR displayTime[SZDSTIME_LEN+1];
    SYNTAX_INTEGER instanceType;
    USN nextUsn;
    PROPERTY_META_DATA_VECTOR *pMetaDataVector = NULL;

    if ( !AlreadyFilledRetrievalArray ) {

        result = DitGetColumnValues(DbState, TableState, gMainRetrievalArray);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }
    }

    // we only update objects with the following properties:
    //
    // Writeable: users shouldn't be allowed to restore objects they are not
    // allowed to write.
    //
    // Not Deleted: if this object has been restored (by the system), 99% of
    // the time, it will just be restored again if we delete it again, so why
    // bother.
    //
    // LostAndFound -- replication protocol assumes this is the first object
    // replicated in in the NC.  This object can't be modified elsewhere in
    // the system, so no need to authoritatively restore it.

    if ( (gIsDeletedVal->err == JET_wrnColumnNull) &&
         (*(SYNTAX_INTEGER*)gInstanceTypeVal->pvData & IT_WRITE) &&
         (*(DWORD*)gDntVal->pvData != gSchemaDnt) &&
         (*(DWORD*)gPDntVal->pvData != gSchemaDnt) &&
         (*(ATTRTYP*)gObjClassVal->pvData != CLASS_LOST_AND_FOUND) ) {

        // Incoming metadata should be valid
        VALIDATE_META_DATA_VECTOR_VERSION(((PROPERTY_META_DATA_VECTOR *)(gMetaDataVal->pvData)));
        ASSERT( gMetaDataVal->cbData >=
                MetaDataVecV1Size(((PROPERTY_META_DATA_VECTOR *)(gMetaDataVal->pvData))) );
        // gMetaDataVal->cbActual is not defined at this time

        returnValue = S_OK;

        jetResult = JetBeginTransaction(DbState->sessionId);
        if ( jetResult != JET_errSuccess ) {
            // "Could not start a new transaction: %ws.\n"
            errprintfRes(IDS_AR_ERR_START_TRANS,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
        inTransaction = TRUE;

        jetResult = JetPrepareUpdate(DbState->sessionId,
                                     TableState->tableId,
                                     JET_prepReplace);
        if ( jetResult != JET_errSuccess ) {
            //"Could not prepare update in \"%s\" table: %ws.\n"
            errprintfRes(IDS_AR_ERR_PREPARE_UPDATE,
                      TableState->tableName,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        // allocate a USN

        result = DitGetNewUsn(DbState, &nextUsn);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        // set the USN-Changed attribute

        jetResult = JetSetColumn(DbState->sessionId,
                                 TableState->tableId,
                                 gUsnChangedColumnId,
                                 &nextUsn,
                                 sizeof(nextUsn),
                                 0,
                                 NULL);
        if ( jetResult != JET_errSuccess ) {
            //"Could not set Usn-Changed column in \"%s\" table: %S.\n"
            errprintfRes(IDS_AR_ERR_SET_USN_CHANGED,
                      TableState->tableName,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        // set the When-Changed attribute

        jetResult = JetSetColumn(DbState->sessionId,
                                 TableState->tableId,
                                 gWhenChangedColumnId,
                                 &gCurrentTime,
                                 sizeof(gCurrentTime),
                                 0,
                                 NULL);
        if ( jetResult != JET_errSuccess ) {
            //"Could not set When-Changed column in \"%s\" table: %S.\n"
            errprintfRes(IDS_AR_ERR_SET_WHEN_CHANGED,
                      TableState->tableName,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        // insert an entry for isDeleted if one is not already present
        // Note that gMetaDataVal may be re-allocated as a result of this call
        result = MetaDataInsert(ATT_IS_DELETED,
                                (PROPERTY_META_DATA_VECTOR**)
                                &gMetaDataVal->pvData,
                                &gMetaDataVal->cbData);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        VALIDATE_META_DATA_VECTOR_VERSION(((PROPERTY_META_DATA_VECTOR *)(gMetaDataVal->pvData)));
        ASSERT( gMetaDataVal->cbData >=
                MetaDataVecV1Size(((PROPERTY_META_DATA_VECTOR *)(gMetaDataVal->pvData))) );

        // munge the meta data entries

        pMetaDataVector = (PROPERTY_META_DATA_VECTOR*) gMetaDataVal->pvData;

        for ( i = 0; i < pMetaDataVector->V1.cNumProps; i++ ) {

            switch ( pMetaDataVector->V1.rgMetaData[i].attrType ) {

            case ATT_OBJECT_CLASS:
            case ATT_RID_ALLOCATION_POOL:
            case ATT_RID_PREVIOUS_ALLOCATION_POOL:
            case ATT_RID_AVAILABLE_POOL:
            case ATT_RID_USED_POOL:
            case ATT_RID_NEXT_RID:
            case ATT_MS_DS_BEHAVIOR_VERSION:
                /* do not update these */
                break;

            case ATT_RDN:
                /* skip the RDN of uninstantiated NC heads */
                instanceType = *(SYNTAX_INTEGER*)gInstanceTypeVal->pvData;
                if ( (instanceType & IT_NC_HEAD) &&
                     !(instanceType & IT_UNINSTANT) )
                    break;

            default:
                pMetaDataVector->V1.rgMetaData[i].dwVersion +=
                    gVersionIncrease;
                pMetaDataVector->V1.rgMetaData[i].timeChanged = gCurrentTime;
                pMetaDataVector->V1.rgMetaData[i].uuidDsaOriginating =
                    gDatabaseGuid;
                pMetaDataVector->V1.rgMetaData[i].usnOriginating = nextUsn;
                pMetaDataVector->V1.rgMetaData[i].usnProperty = nextUsn;
                break;

            }

        }

        // Set the actual size of the vector
        gMetaDataVal->cbActual = MetaDataVecV1Size(((PROPERTY_META_DATA_VECTOR *)(gMetaDataVal->pvData)));

        // Check metadata before writing
        VALIDATE_META_DATA_VECTOR_VERSION(((PROPERTY_META_DATA_VECTOR *)(gMetaDataVal->pvData)));
        // set the metadata attribute
        jetResult = JetSetColumn(DbState->sessionId,
                                 TableState->tableId,
                                 gMetaDataVal->columnid,
                                 gMetaDataVal->pvData,
                                 gMetaDataVal->cbActual,
                                 JET_bitSetOverwriteLV,
                                 NULL);
        if ( jetResult != JET_errSuccess ) {
            //"Could not set meta-data column in \"%s\" table: %S.\n"
            errprintfRes(IDS_AR_ERR_SET_METADATA,
                      TableState->tableName,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetUpdate(DbState->sessionId,
                              TableState->tableId,
                              NULL,
                              0,
                              0);
        if ( jetResult != JET_errSuccess ) {
            //"Could not update column in \"%s\" table: %S.\n"
            errprintfRes(IDS_AR_ERR_UPDATE_COLUMN,
                      TableState->tableName,
                      GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetCommitTransaction(DbState->sessionId,
                                         JET_bitCommitLazyFlush);
        if ( jetResult != JET_errSuccess ) {
            //"Failed to commit transaction: %S.\n"
            errprintfRes(IDS_AR_ERR_FAIL_COMMIT_TRANS,
                      GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
            goto CleanUp;
        }
        inTransaction = FALSE;

        gRecordsUpdated++;

        UpdateProgressMeter(gRecordCount - gRecordsUpdated, FALSE);

    }


CleanUp:

    // if we are still in a transaction, there must have been a failure
    // somewhere along the way.

    if ( inTransaction ) {

        jetResult = JetRollback(DbState->sessionId, JET_bitRollbackAll);
        if ( jetResult != JET_errSuccess ) {
            //"Failed to rollback transaction: %S.\n"
            errprintfRes(IDS_AR_ERR_FAIL_ROLLBACK_TRANS,
                      GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }

    }

    return returnValue;

} // AuthoritativeRestoreCurrentObject



HRESULT
AuthoritativeRestoreCurrentLink(
    IN DB_STATE *DbState,
    IN TABLE_STATE *LinkTableState,
    IN BOOL fDirectionForward
    )
/*++

Routine Description:

    This function updates the metadata for the current link record so that
    its meta-data appears to have been written to its current
    value at the given time at the given DC.

Some important rules:

1. AR should remark as absent links that are absent. This follows the rule in the
design that absent values are not tombstones, but are simply a differerent flavor
of value. Unlike objects, absent values may be made present by the user. For this
reason alone, we need a way to re-assert that they are made absent consistently.

2. We do NOT rewrite legacy values. Value metadata is for values with metadata (duh)
and attribute metadata covers the legacy values.  Following this design rule, the
existing AR code will touch the attribute level metadata for the linked attribute,
and this will automatically take care of re-replicating the legacy values.

By following this rule, we can make AR independent of whether the system is in
LVR mode or not.  We always update the linked value attribute metadata if there
is any. We ONLY update the value metadata for non-legacy values.  A non-LVR system
will simply not have any, and thus none will be marked. The only inefficiency I see
is that the linked attribute metadata might be touched when there are no more
legacy values. This would cause a harmless legacy value change replication to occur.
If we wanted to avoid this, we could have the attribute value metadata marking code
check first whether there are any legacy values for this attribute.
Not sure if this is worth the trouble though.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    fDirectionForward - Whether this is a forward link or a backward link.
        Use this information to determine the two ends of the link

Return Value:

    S_OK - The record was modified successfully.
    S_FALSE - The record was deleted or not writeable
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{
    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    BOOL inTransaction = FALSE;
    USN nextUsn;
    VALUE_META_DATA_EXT metaDataExt;
    VALUE_META_DATA_EXT *pMetaDataExt = &( metaDataExt );
    VALUE_META_DATA_EXT *pOldMetaDataExt;

    // Check for old metadata. There many not be any.

    if (gLinkMetaDataVal->cbActual == 0) {
        // Value has no metadata: legacy value. Nothing to do.
        goto CleanUp;
    } else if (gLinkMetaDataVal->cbActual == sizeof( VALUE_META_DATA_EXT )) {
        // Metadata is in native format
        pOldMetaDataExt = (VALUE_META_DATA_EXT *) gLinkMetaDataVal->pvData;
    } else {
        errprintfRes(IDS_AR_ERR_UNKNOWN_VALUE_METADATA_FORMAT,
                     gLinkMetaDataVal->cbActual );
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    Assert( pOldMetaDataExt );

    // Start a new transaction

    jetResult = JetBeginTransaction(DbState->sessionId);
    if ( jetResult != JET_errSuccess ) {
        // "Could not start a new transaction: %ws.\n"
        errprintfRes(IDS_AR_ERR_START_TRANS,
                     GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    inTransaction = TRUE;

    // Prepare for update

    jetResult = JetPrepareUpdate(DbState->sessionId,
                                 LinkTableState->tableId,
                                 JET_prepReplace);
    if ( jetResult != JET_errSuccess ) {
        //"Could not prepare update in \"%s\" table: %ws.\n"
        errprintfRes(IDS_AR_ERR_PREPARE_UPDATE,
                     LinkTableState->tableName,
                     GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // allocate a USN

    result = DitGetNewUsn(DbState, &nextUsn);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    // set the Link USN-Changed attribute

    jetResult = JetSetColumn(DbState->sessionId,
                             LinkTableState->tableId,
                             gLinkUsnChangedColumnId,
                             &nextUsn,
                             sizeof(nextUsn),
                             0,
                             NULL);
    if ( jetResult != JET_errSuccess ) {
        //"Could not set Usn-Changed column in \"%s\" table: %S.\n"
        errprintfRes(IDS_AR_ERR_SET_USN_CHANGED,
                     LinkTableState->tableName,
                     GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // If value is absent, rewrite deletion time
    if (gLinkDelTimeVal->cbActual) {
        DSTIME timeCreated, timeDeleted;

        // Set to maximum of timeCurrent and creationTime

        timeCreated = pOldMetaDataExt->timeCreated;
        if (timeCreated > gCurrentTime) {
            timeDeleted = timeCreated;
        } else {
            timeDeleted = gCurrentTime;
        }


        jetResult = JetSetColumn(DbState->sessionId,
                                 LinkTableState->tableId,
                                 gLinkDelTimeVal->columnid,
                                 &timeDeleted,
                                 sizeof(timeDeleted),
                                 0,
                                 NULL);
        if ( jetResult != JET_errSuccess ) {
            //"Could not set Del Time column in \"%s\" table: %S.\n"
            errprintfRes(IDS_AR_ERR_SET_DEL_TIME,
                         LinkTableState->tableName,
                         GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
    }

    // Calculate new metadata for the link.

    // An existing value
    pMetaDataExt->timeCreated = pOldMetaDataExt->timeCreated;
    pMetaDataExt->MetaData.dwVersion =
        pOldMetaDataExt->MetaData.dwVersion + gVersionIncrease;
    pMetaDataExt->MetaData.timeChanged = gCurrentTime;
    pMetaDataExt->MetaData.uuidDsaOriginating = gDatabaseGuid;
    pMetaDataExt->MetaData.usnOriginating = nextUsn;
    // usnProperty is written in the UsnChanged Column

    // set the metadata attribute
    jetResult = JetSetColumn(DbState->sessionId,
                             LinkTableState->tableId,
                             gLinkMetaDataVal->columnid,
                             pMetaDataExt,
                             sizeof( VALUE_META_DATA_EXT ),
                             0,
                             NULL);
    if ( jetResult != JET_errSuccess ) {
        //"Could not set meta-data column in \"%s\" table: %S.\n"
        errprintfRes(IDS_AR_ERR_SET_METADATA,
                     LinkTableState->tableName,
                     GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // Update the record

    jetResult = JetUpdate(DbState->sessionId,
                          LinkTableState->tableId,
                          NULL,
                          0,
                          0);
    if ( jetResult != JET_errSuccess ) {
        //"Could not update column in \"%s\" table: %S.\n"
        errprintfRes(IDS_AR_ERR_UPDATE_COLUMN,
                     LinkTableState->tableName,
                     GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // Commit the transaction

    jetResult = JetCommitTransaction(DbState->sessionId,
                                     JET_bitCommitLazyFlush);
    if ( jetResult != JET_errSuccess ) {
        //"Failed to commit transaction: %S.\n"
        errprintfRes(IDS_AR_ERR_FAIL_COMMIT_TRANS,
                     GetJetErrString(jetResult));
        if ( SUCCEEDED(returnValue) ) {
            returnValue = E_UNEXPECTED;
        }
        goto CleanUp;
    }

    inTransaction = FALSE;

    gRecordsUpdated++;

    UpdateProgressMeter(gRecordCount - gRecordsUpdated, FALSE);

CleanUp:

    // if we are still in a transaction, there must have been a failure
    // somewhere along the way.

    if ( inTransaction ) {

        jetResult = JetRollback(DbState->sessionId, JET_bitRollbackAll);
        if ( jetResult != JET_errSuccess ) {
            //"Failed to rollback transaction: %S.\n"
            errprintfRes(IDS_AR_ERR_FAIL_ROLLBACK_TRANS,
                      GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }

    }

    return returnValue;
}


HRESULT
GetVersionIncrease(
    IN DB_STATE *DbState,
    OUT DWORD *VersionIncrease
    )
/*++

Routine Description:

    This function determines the amount by which each version number should
    be increase.  It searches through the database to find the time of the last
    change that occured.  It is assumed that this DC has been idle since that
    change occured.  The version increase then is computed as the number of
    idle days (rounded up) times gVersionIncreasePerDay.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    VersionIncrease - Returns the amount by which to increase each version
        number.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;

    DSTIME currentTime;
    DSTIME mostRecentChange;
    DWORD idleSeconds;
    DWORD idleDays;
    CHAR displayTime[SZDSTIME_LEN+1];


    if ( (DbState == NULL) ||
         (VersionIncrease == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = GetCurrentDsTime(&currentTime);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DsTimeToString(currentTime, displayTime);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    //"The current time is %s.\n"
    RESOURCE_PRINT1 (IDS_TIME, displayTime);

    result = DitGetMostRecentChange(DbState, &mostRecentChange);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DsTimeToString(mostRecentChange, displayTime);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    //"Most recent database update occured at %s.\n"
    RESOURCE_PRINT1 (IDS_AR_UPDATE_TIME, displayTime);

    ASSERT(currentTime > mostRecentChange);

    idleSeconds = (DWORD)(currentTime - mostRecentChange);

    idleDays = idleSeconds / SECONDS_PER_DAY;
    if ( idleSeconds % SECONDS_PER_DAY > 0 ) {
        idleDays++;
    }

    *VersionIncrease = idleDays * gVersionIncreasePerDay;

    //"Increasing version numbers by %u.\n"
    RESOURCE_PRINT1 (IDS_AR_INCREASE_VERSION, *VersionIncrease);


CleanUp:

    return returnValue;

} // GetVersionIncrease



HRESULT
GetCurrentDsTime(
    OUT DSTIME *CurrentTime
    )
/*++

Routine Description:

    This function gets the current time in DSTIME form.  This function was
    basically stolen from tasq\time.c.

Arguments:

    CurrentTime - Returns the current time.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    BOOL succeeded;

    SYSTEMTIME systemTime;
    FILETIME fileTime;


    if ( CurrentTime == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    GetSystemTime(&systemTime);

    succeeded = SystemTimeToFileTime(&systemTime, &fileTime);
    if ( !succeeded ) {
        //"Could not convert system time to file time (Windows Error %u).\n"
        errprintfRes(IDS_AR_ERR_CONVERT_SYSTEM_TIME,
                  GetLastError());
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    (*CurrentTime) = fileTime.dwLowDateTime;
    (*CurrentTime) |= (DSTIME)fileTime.dwHighDateTime << 32;
    (*CurrentTime) /= 10000000L;


CleanUp:

    return returnValue;

} // GetCurrentDsTime



ULONG
NumDigits(
    IN ULONG N
    )
/*++

Routine Description:

    Counts the number of decimal digits in the given number N.

Arguments:

    N - Supplies the number of which to count the digits.

Return Value:

    The number of decimal digits in N.

--*/
{

    BOOL addExtraDigit = FALSE;
    ULONG numDigits = 0;


    while ( N > 0 ) {

        if ( N % 10 != 0 ) {
            addExtraDigit = TRUE;
        }

        N = N / 10;

        numDigits++;

    }

    return numDigits;

} // NumDigits


HRESULT
MetaDataLookup(
    IN ATTRTYP AttributeType,
    IN PROPERTY_META_DATA_VECTOR *MetaDataVector,
    OUT DWORD *Index
    )
/*++

Routine Description:

    Find the meta data for the given attribute in the meta data vector.
    Returns the index at which the entry was found, or, if the corresponding
    meta data is absent, the index at which the entry would be inserted to
    preserve the sort order.

    Note: this function was basically stolen from dsamain\dra\drameta.c

Arguments:

    AttributeType - Supplies the attribute type to search for.
    MetaDataVector - Supplies meta data vector in which to search.
    Index - Returns the index at which the meta data was found or, if absent,
        the index at which meta data should have been.

Return Values:

    S_OK - The attribute was found.
    S_FALSE - The attribute was not found.

--*/
{

    HRESULT returnValue = S_FALSE;
    ATTRTYP first, last, current;
    long delta;


    VALIDATE_META_DATA_VECTOR_VERSION(MetaDataVector);
    current = delta = first = 0;
    last = MetaDataVector->V1.cNumProps - 1;

    while ( first <= last ) {

        current = (first + last) / 2;

        delta = AttributeType -
                MetaDataVector->V1.rgMetaData[current].attrType;

        if ( delta < 0 ) {

            last = current - 1;

        } else if ( delta > 0 ) {

            first = current + 1;

        } else {

            *Index = current;
            returnValue = S_OK;
            break;

        }

    }

    // if we did not find it in the vector,
    // set index to where it should have been
    if ( returnValue == S_FALSE ) {
        if ( delta < 0 ) {
            *Index = current;
        } else {
            *Index = current + 1;
        }
    }

    return returnValue;

} // MetaDataLookup


HRESULT
MetaDataInsert(
    IN ATTRTYP AttributeType,
    IN OUT PROPERTY_META_DATA_VECTOR **MetaDataVector,
    IN OUT DWORD *BufferSize
    )
/*++

Routine Description:

    Attempts to insert the given ATTRTYP into the given MetaDataVector.  If
    the entry is not already present, it will be added and its elements will
    be nulled with the exception of the attribute type, which will be set to
    given value.

    Note: this function was basically stolen from dsamain\dra\drameta.c

Arguments:

    AttributeType - Supplies the attribute type to search for.
    MetaDataVector - Supplies meta data vector in which to search.
    BufferSize - Supplies the size of the buffer which MetaDataVector points
        to.  If the buffer is not large enough to accomodate another entry,
        a new buffer will be allocated, and the new size returned here.

Return Values:

    S_OK - The attribute was inserted.
    S_FALSE - The attribute was already present.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    DWORD index;
    DWORD i;


    result = MetaDataLookup(AttributeType, *MetaDataVector, &index);

    if ( result == S_FALSE ) {

        returnValue = S_OK;

        while ( *BufferSize - MetaDataVecV1Size((*MetaDataVector)) <
                  sizeof(PROPERTY_META_DATA) ) {

            result = ARRealloc(MetaDataVector, BufferSize);
            if ( FAILED(result) ) {
                returnValue = result;
                goto CleanUp;
            }

        }

        // make room for the new guy

        (*MetaDataVector)->V1.cNumProps++;

        for ( i = (*MetaDataVector)->V1.cNumProps - 1;
              i > index;
              i-- ) {
            (*MetaDataVector)->V1.rgMetaData[i] =
                (*MetaDataVector)->V1.rgMetaData[i-1];
        }

        ZeroMemory(&(*MetaDataVector)->V1.rgMetaData[index],
                   sizeof(PROPERTY_META_DATA));

        // insert the new guy

        (*MetaDataVector)->V1.rgMetaData[index].attrType = AttributeType;

    } else if ( result == S_OK ) {

        // there is no need to insert it if it's already there.

        ASSERT((*MetaDataVector)->V1.rgMetaData[index].attrType ==
                 AttributeType);

        returnValue = S_FALSE;

    } else {

        returnValue = result;
        goto CleanUp;

    }


CleanUp:
    VALIDATE_META_DATA_VECTOR_VERSION((*MetaDataVector));

    return returnValue;

} // MetaDataInsert



HRESULT
DsTimeToString(
    IN DSTIME Time,
    OUT CHAR *String
    )
/*++

Routine Description:

    This function converts a DSTIME into a displayable string form.

    Note:  this function was basically stolen from dscommon\dsutil.c.

Arguments:

    Time - Supplies the DSTIME to convert.
    String - Returns the string form of the given DSTIME.  This should contain
       space for at least SZDSTIME_LEN characters.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    BOOL succeeded;

    SYSTEMTIME utcSystemTime;
    SYSTEMTIME systemTime;
    FILETIME fileTime;
    ULONGLONG ull;


    if ( String == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    ASSERT(sizeof(DSTIME) == sizeof(ULONGLONG));

    // convert DSTIME to FILETIME.
    ull = (LONGLONG) Time * 10000000L;
    fileTime.dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
    fileTime.dwHighDateTime = (DWORD) (ull >> 32);

    succeeded = FileTimeToSystemTime(&fileTime, &utcSystemTime);
    if ( !succeeded ) {
        //"Could not convert file time to system time (Windows Error %u).\n"
        errprintfRes(IDS_AR_ERR_CONVERT_FILE_TIME,
                  GetLastError());
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    succeeded = SystemTimeToTzSpecificLocalTime(NULL,
                                                &utcSystemTime,
                                                &systemTime);
    if ( !succeeded ) {
        //"Could not convert system time to local time (Windows Error %u).\n"
        errprintfRes(IDS_AR_ERR_CONVERT_LOCAL_TIME,
                  GetLastError());
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    sprintf(String,
            "%02d-%02d-%02d %02d:%02d.%02d",
            systemTime.wMonth,
            systemTime.wDay,
            systemTime.wYear % 100,
            systemTime.wHour,
            systemTime.wMinute,
            systemTime.wSecond);


CleanUp:

    return returnValue;

} // DsTimeToString



int
errprintf(
    IN CHAR *FormatString,
    IN ...
    )
/*++

Routine Description:

    This function prints out an error message in the same manner as printf.
    The error message is sent to stderr.

    The global variable gInUnfinishedLine is TRUE whenever another part of the
    code is waiting for an operation finish before it can print out the rest
    of the line.  Clearly, an error has occured before that could happen,
    so an extra newline is printed out.

Arguments:

    FormatString - Supplies the format string to pass to vfprintf.

Return Value:

    None

--*/
{

    int result;
    va_list vl;


    va_start(vl, FormatString);

    if ( gInUnfinishedLine ) {
        putc('\n', stderr);
        gInUnfinishedLine = FALSE;
    }

    result = vfprintf(stderr, FormatString, vl);

    va_end(vl);

    return result;

} // errprintf


int
errprintfRes(
    IN UINT FormatStringId,
    IN ...
    )
/*++

Routine Description:

    This function prints out an error message in the same manner as printf.
    The error message is loaded from a resource file.
    The error message is sent to stderr.

    The global variable gInUnfinishedLine is TRUE whenever another part of the
    code is waiting for an operation finish before it can print out the rest
    of the line.  Clearly, an error has occured before that could happen,
    so an extra newline is printed out.

Arguments:

    FormatString - Supplies the format string to pass to vfprintf.

Return Value:

    None

--*/
{

    int result;
    va_list vl;
    const WCHAR *formatString;


    va_start(vl, FormatStringId);


    formatString = READ_STRING (FormatStringId);


    if ( gInUnfinishedLine ) {
        putc('\n', stderr);
        gInUnfinishedLine = FALSE;
    }

    if (formatString) {
        result = vfwprintf(stderr, formatString, vl);
    }
    else {
        result = 0;
    }

    va_end(vl);

    RESOURCE_STRING_FREE (formatString);

    return result;

} // errprintfRes


int
dbgprintf(
    IN CHAR *FormatString,
    IN ...
    )
/*++

Routine Description:

    This function is simply a wrapper on printf that is meant to be used only
    while still debugging this program.

Arguments:

    FormatString - Supplies the format string for printf.

Return Value:

    None

--*/
{

    int result;
    va_list vl;


    va_start(vl, FormatString);

    if ( gInUnfinishedLine ) {
        putc('\n', stderr);
        gInUnfinishedLine = FALSE;
    }

    fprintf(stderr, "debug: ");

    result = vfprintf(stderr, FormatString, vl);

    va_end(vl);

    return result;

} // dbgprintf



HRESULT
ARAlloc(
    OUT VOID **Buffer,
    IN DWORD Size
    )
/*++

Routine Description:

    This function allocates the specified amount of memory (if possible) and
    sets Buffer to point to the buffer allocated.

Arguments:

    Buffer - Returns a pointer to the buffer allocated.
    Size - Supplies the size of the buffer to allocate.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.

--*/
{

    HRESULT returnValue = S_OK;


    *Buffer = malloc(Size);
    if ( *Buffer == NULL ) {
        errprintfRes(IDS_ERR_MEMORY_ALLOCATION, Size);
        returnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    ZeroMemory(*Buffer, Size);


CleanUp:

    return returnValue;

} // ARAlloc



HRESULT
ARRealloc(
    IN OUT VOID **Buffer,
    IN OUT DWORD *CurrentSize
    )
/*++

Routine Description:

    This function re-allocates the given buffer to twice the given size (if
    possible).

Arguments:

    Buffer - Returns a pointer to the new buffer allocated.
    CurrentSize - Supplies the current size of the buffer.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.

--*/
{

    HRESULT returnValue = S_OK;
    BYTE *newBuffer;


    newBuffer = (BYTE*) realloc(*Buffer, *CurrentSize * 2);
    if ( newBuffer == NULL ) {
        errprintfRes(IDS_ERR_MEMORY_ALLOCATION,
                  *CurrentSize * 2);
        returnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    ZeroMemory(&newBuffer[*CurrentSize], *CurrentSize);

    *Buffer = newBuffer;
    *CurrentSize *= 2;


CleanUp:

    return returnValue;

} // ARRealloc



VOID
UpdateProgressMeter(
    IN DWORD Progress,
    IN BOOL MustUpdate
    )
/*++

Routine Description:

    If necessary, updates the progress meter on the screen to show the current
    progress. The update is necessary if gCurrentDisplayDelta updates have
    occured since the last update or if MustUpdate is true.  This updating can
    be removed by #define-ing NO_PROGRESS_METER.

Arguments:

    Progress - Supplies the current progress.
    MustUpdate - Supplies whether we must perform an update this time.

Return Value:

    None

--*/
{

    DWORD i;

#ifndef NO_PROGRESS_METER

    if ( MustUpdate || (Progress % gCurrentDisplayDelta == 0) ) {

        for ( i = 0; i < gNumDigitsToPrint; i++ ) {
            putchar('\b');
        }

        printf("%0*u", gNumDigitsToPrint, Progress);

    }

#endif

} // UpdateProgressMeter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include "crc32.h"

//
// This code comes from Dr. Dobbs Journal, May 1992
//


unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


void
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc)
{
    unsigned char * pbBuffer = (unsigned char *) pvBuffer;

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    *pNewCrc = dwCrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\confset.cxx ===
#include <NTDSpch.h>
#pragma hdrstop


#include "ntdsutil.hxx"
#include "select.hxx"
#include "connect.hxx"
#include "confset.hxx"

#include "resource.h"

#include <ldapsvr.hxx>

CParser ConfSetParser;
BOOL    fConfSetQuit;
BOOL    fConfSetParserInitialized = FALSE;

//
// List of settings supported. Assume a max of 32.
//
#define DEF_CONFSET_LIST_SIZE 32
PCONFSET    gConfSets = NULL;
CONFSET     ConfSet[DEF_CONFSET_LIST_SIZE] = {0};
PWCHAR      ConfSetPath = NULL;
DWORD       nConfSets = 0;

#define APPEND_VALUE(_i, _p, _v)    {\
    if ( gConfSets[(_i)].ValueType == CONFSET_BOOLEAN ) {   \
                                                        \
        wcscat((_p),                                    \
               ((_v) != 0) ? L"True" : L"False");       \
    } else {                                        \
        WCHAR buf[MAX_PATH];                        \
        _itow((_v),buf,10 );                        \
        wcscat((_p), buf);                          \
    }                                               \
}

//
// Forward references.
//

extern  HRESULT ConfSetHelp(CArgs *pArgs);
extern  HRESULT ConfSetQuit(CArgs *pArgs);
extern  HRESULT ConfSetList(CArgs *pArgs);
extern  HRESULT ConfSetShowValues(CArgs *pArgs);
extern  HRESULT ConfSetSet(CArgs *pArgs);
extern  HRESULT ConfSetCommitChanges(CArgs *pArgs);
extern  HRESULT ConfSetCancelChanges(CArgs *pArgs);

BOOL
GetValues(
    VOID
    );

BOOL
GetConfSetPath(
    VOID
    );

BOOL
ListConfSets(
    IN BOOL fPrint,
    IN PCONFSET Settings,
    OUT PDWORD nSettings
    );

BOOL
ConfSetInitialize(
    VOID
    );

// Build a table which defines our language.

LegalExprRes ConfSetLanguage[] =
{
    CONNECT_SENTENCE_RES

    {   L"?", 
        ConfSetHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        ConfSetHelp,
        IDS_HELP_MSG, 0  },

    {   L"Quit",
        ConfSetQuit,
        IDS_RETURN_MENU_MSG, 0  },

    {   L"List",
        ConfSetList,
        IDS_CONFSET_LIST_MSG, 0 },

    {   L"Show Values",
        ConfSetShowValues,
        IDS_CONFSET_SHOW_VAL_MSG, 0 },

    {   L"Commit Changes",
        ConfSetCommitChanges,
        IDS_CONFSET_COMMIT_MSG, 0 },

    {   L"Cancel Changes",
        ConfSetCancelChanges,
        IDS_CONFSET_CANCEL_MSG, 0 },

    {   L"Set %s to %s",
        ConfSetSet,
        IDS_CONFSET_SET_VAL_MSG, 0 }

};

HRESULT
ConfSetMain(
    CArgs   *pArgs
    )
{
    HRESULT     hr;
    const WCHAR *prompt;
    int         cExpr;
    char        *pTmp;

    if ( !fConfSetParserInitialized )
    {
        cExpr = sizeof(ConfSetLanguage) / sizeof(LegalExprRes);
        
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (ConfSetLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.

        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = ConfSetParser.AddExpr(ConfSetLanguage[i].expr,
                                                   ConfSetLanguage[i].func,
                                                   ConfSetLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fConfSetParserInitialized = TRUE;
    fConfSetQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_CONFSET);

    hr = ConfSetParser.Parse(gpargc,
                             gpargv,
                             stdin,
                             stdout,
                             prompt,
                             &fConfSetQuit,
                             FALSE,               // timing info
                             FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }
    
    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT ConfSetHelp(CArgs *pArgs)
{
    return(ConfSetParser.Dump(stdout,L""));
}

HRESULT ConfSetQuit(CArgs *pArgs)
{
    fConfSetQuit = TRUE;
    return(S_OK);
}

HRESULT
ConfSetList(CArgs *pArgs)
{
    //
    // Initialize CONFSET structures
    //

    if ( !ConfSetInitialize() ) {
        return S_OK;
    }

    (VOID)ListConfSets(TRUE, NULL, NULL);
    return(S_OK);
}

HRESULT
ConfSetSet(CArgs *pArgs)
{
    DWORD i;
    HRESULT     hr;
    LONG NewValue;
    const WCHAR *pwszConfSet;
    const WCHAR *pwszVal;

    //
    // Initialize CONFSET structures
    //

    if ( !ConfSetInitialize() ) {
        return S_OK;
    }

    if ( FAILED(hr = pArgs->GetString(0, &pwszConfSet)) )
    {
        //"Unable to retrieve policy name\n"
        RESOURCE_PRINT (IDS_CONFSET_NAME_ERR);
        return(hr);
    }

    if ( FAILED(hr = pArgs->GetString(1, &pwszVal)) )
    {
        //"Unable to retrieve policy value\n"
        RESOURCE_PRINT (IDS_CONFSET_VALUE_ERR);
        return(hr);
    }

    for (i=0; i<nConfSets; i++) {

        if ( _wcsicmp(pwszConfSet, gConfSets[i].Name) != 0 ) {
            continue;
        }

        if ( gConfSets[i].ValueType == CONFSET_BOOLEAN ) {

            if ( _wcsicmp(pwszVal, L"TRUE") == 0 ) {
                gConfSets[i].NewValue = 1;
            } else if ( _wcsicmp(pwszVal, L"FALSE") == 0 ) {
                gConfSets[i].NewValue = 0;
            }
            break;
        } else {

            //
            // integer value
            //
            NewValue = _wtoi(pwszVal);
            if (gConfSets[i].MinLimit && NewValue < (LONG)gConfSets[i].MinLimit) {
                NewValue = gConfSets[i].MinLimit;
                //"Value outside of range; adjusting to %d\n"
                RESOURCE_PRINT1 (IDS_CONFSET_RANGE, NewValue);
            }
            if (gConfSets[i].MaxLimit && NewValue > (LONG)gConfSets[i].MaxLimit) {
                NewValue = gConfSets[i].MaxLimit;
                //"Value outside of range; adjusting to %d\n"
                RESOURCE_PRINT1 (IDS_CONFSET_RANGE, NewValue);
            }

            gConfSets[i].NewValue = NewValue;
            break;
        }
    }

    if ( i == nConfSets ) {
        //"No such configurable setting %ws\n"
        RESOURCE_PRINT1 (IDS_CONFSET_NOTFOUND,
                   pwszConfSet);
    }

    return(S_OK);
}

HRESULT
ConfSetShowValues(CArgs *pArgs)
{

    DWORD i;

    //
    // Initialize CONFSET structures
    //

    if ( !ConfSetInitialize() ) {
        return S_OK;
    }

    GetValues( );

    //"\nPolicy\t\t\t\tCurrent(New)\n\n"
    RESOURCE_PRINT (IDS_CONFSET_INFO);
    
    for (i=0; i< nConfSets; i++) {

        printf("%ws",gConfSets[i].Name);

        if ( gConfSets[i].ValueType == CONFSET_BOOLEAN ) {

            if ( gConfSets[i].CurrentValue == 0 ) {
                printf("\t\tFALSE");
            } else {
                printf("\t\tTRUE");
            }
        } else {
            printf("\t\t%d", gConfSets[i].CurrentValue);
        }

        if ( gConfSets[i].NewValue != 0xffffffff ) {

            if ( gConfSets[i].ValueType == CONFSET_BOOLEAN ) {
                if ( gConfSets[i].CurrentValue == 0 ) {
                    printf("(FALSE)");
                } else {
                    printf("(TRUE)");
                }
            } else {
                printf("(%d)\n", gConfSets[i].NewValue);
            }
        } else {
            printf("\n");
        }
    }
    printf("\n");

    return(S_OK);
}

BOOL
ConfSetInitialize(
    VOID
    )
{
    DWORD nSets = 0;

    //
    // if we already have a list, return success
    //

    if ( gConfSets != NULL ) {
        return TRUE;
    }

    //
    // Get the path for the policy
    //

    if ( !GetConfSetPath() ) {
        return FALSE;
    }

    //
    // Get the number of limits
    //

    nSets = DEF_CONFSET_LIST_SIZE;
    if ( ListConfSets(FALSE, ConfSet, &nSets) ) {
        gConfSets = ConfSet;
        goto exit;
    }

    //
    // See if the buffer we passed was too small
    //

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

        //
        // Nothing we can do here.
        //

        //"ListConfSets returned %s\n");
        RESOURCE_PRINT2  (IDS_CONFSET_LIST_ERR,
                    GetLastError(), GetW32Err(GetLastError()));
        return FALSE;
    }

#if DBG
    if ( nSets < DEF_CONFSET_LIST_SIZE ) {
          //"Got a new settings size %d smaller than the old one[%d]!\n",
          RESOURCE_PRINT2 (IDS_CONFSET_SETTINGS_ERR,
                      nSets, DEF_CONFSET_LIST_SIZE);
    }
#endif

    gConfSets = (PCONFSET)LocalAlloc(LPTR, nSets * sizeof(CONFSET));
    if ( gConfSets == NULL ) {
        //"Unable to allocate %d bytes[%d] of memory\n"
        RESOURCE_PRINT2  (IDS_CONFSET_MEMORY1_ERR, 
                    nSets * sizeof(CONFSET), nSets);
        return FALSE;
    }

    //
    // now we can call it again.
    //

    if ( ListConfSets(FALSE, gConfSets, &nSets) ) {
        LocalFree(gConfSets);
        gConfSets = NULL;
        //"ListConfSets failed with %s\n"
        RESOURCE_PRINT2  (IDS_CONFSET_LIST_ERR,
                    GetLastError(), GetW32Err(GetLastError()));
        
        return FALSE;
    }

exit:
    for (DWORD i=0; i<nSets; i++) {
        gConfSets[i].NewValue = 0xFFFFFFFF;
        gConfSets[i].MinLimit = LIMIT_LOW_DYNAMIC_OBJECT_TTL;
        gConfSets[i].MaxLimit = LIMIT_HIGH_DYNAMIC_OBJECT_TTL;
    }
    nConfSets = nSets;
    return TRUE;


} // ConfSetInitialize


VOID
ConfSetCleanupGlobals(
    VOID
    )
{
    //
    // free the policy list
    //

    if ( gConfSets != NULL ) {
        LocalFree(gConfSets);
        gConfSets = NULL;
    }

    if ( ConfSetPath != NULL ) {
        LocalFree(ConfSetPath);
        ConfSetPath = NULL;
    }
    return;
} // ConfSetCleanupGlobals


HRESULT
ConfSetCancelChanges(CArgs *pArgs)
{
    DWORD i;

    if ( gConfSets != NULL ) {
        for (i=0; i< nConfSets; i++) {
            gConfSets[i].NewValue = 0xffffffff;
        }
    }
    return(S_OK);
}

HRESULT
ConfSetCommitChanges(CArgs *pArgs)
{

    DWORD err;
    LDAPModW* mods[2];
    LDAPModW mod;
    BOOL doModify = FALSE;
    DWORD i, j;
    PWCHAR  values[DEF_CONFSET_LIST_SIZE+1];
    WCHAR  ConfSets[DEF_CONFSET_LIST_SIZE+1][MAX_PATH];

    //
    // Initialize CONFSET structures
    //

    if ( !ConfSetInitialize() ) {
        return S_OK;
    }

    GetValues( );

    //
    // See if we really need to change anything
    //

    ZeroMemory(values, sizeof(values));
    for (i=0, j=0;i<nConfSets;i++) {

        //
        // If this is an integer value whose
        // new value is zero, or the value hasn't
        // changed but it's old value was zero,
        // then don't write this value.
        //
        if (gConfSets[i].ValueType == CONFSET_INTEGER
            && (   
                   gConfSets[i].NewValue == 0
                || (   
                       gConfSets[i].NewValue == 0xffffffff
                    && gConfSets[i].CurrentValue == 0
                   )
               )
           )
        {
            //
            // Never set an Integer value to zero.
            //

            continue;
        }

        values[j] = ConfSets[j];
        wcscpy(ConfSets[j], gConfSets[i].Name);
        wcscat(ConfSets[j], L"=");

        if ( gConfSets[i].NewValue != 0xffffffff) {
            doModify = TRUE;
            APPEND_VALUE(i, ConfSets[j], gConfSets[i].NewValue);        

        } else {

            //
            // value has not changed
            //
            APPEND_VALUE(i, ConfSets[j], gConfSets[i].CurrentValue);
            
        }
        j++;

    }

    if ( !doModify ) {
        //"No changes to commit.\n"
        RESOURCE_PRINT  (IDS_CONFSET_NO_COMMIT);
        return S_OK;
    }

    mods[0] = &mod;
    mods[1] = NULL;

    mod.mod_op = LDAP_MOD_REPLACE;
    mod.mod_type = L"msDS-Other-Settings";
    mod.mod_values = values;

    err = 0;
    err = ldap_modify_sW(gldapDS,
                        ConfSetPath,
                        mods
                        );

    if ( err == LDAP_SUCCESS ) {
        ConfSetCancelChanges(pArgs);
    } else {
        //"ldap_modify of attribute msDS-Other-Settings failed with %s"
        RESOURCE_PRINT2  (IDS_CONFSET_MODIFY_ERR, 
                    err, GetLdapErr(err));
    }

    return(S_OK);
}


BOOL
ListConfSets(
    IN BOOL fPrint,
    IN PCONFSET ConfSets,
    OUT PDWORD nConfSets
    )
{
    INT count = -1;
    DWORD i = 0;
    DWORD err;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PWSTR                   *values = NULL;
    BOOL    ok = FALSE;
    DWORD   nGiven = 0;

    //
    // get the buffer size passed
    //

    if ( (ConfSets != NULL) && (*nConfSets != 0) ) {
        nGiven = *nConfSets;
    }

    atts[0] = L"supportedConfigurableSettings";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS,
                         L"",
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {

        //"ldap_search of supportedConfigurableSettings failed with %s"
        RESOURCE_PRINT2  (IDS_CONFSET_SEARCH1_ERR, 
                    err, GetLdapErr(err));
        
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry )
    {
        //"No entries returned when reading %s\n"
        RESOURCE_PRINT1  (IDS_CONFSET_NO_ENTRIES1, 
                    atts[0]);
        goto exit;
    }

    values = ldap_get_valuesW(gldapDS, entry, atts[0]);

    if ( !values )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            //"No rights to read Settings\n"
            RESOURCE_PRINT  (IDS_CONFSET_NO_RIGHTS1);
            goto exit;
        }
        
        //"Unable to get values for %s\n"
        RESOURCE_PRINT1  (IDS_CONFSET_RETRIVE_ERR, 
                    atts[0]);
        goto exit;
    }

    if ( fPrint ) {
        //"Supported Settings:\n"
        RESOURCE_PRINT (IDS_CONFSET_SUPPORTED);
    }

    count = 0;

    while ( values[count] != NULL ) {
        if ( fPrint ) {
            printf("\t%ws\n", values[count]);
        }

        if ( count < (INT)nGiven ) {
            wcscpy(ConfSets[count].Name, values[count]);
            ConfSets[count].ValueType = CONFSET_INTEGER;
        }

        count++;
    }

    ok = TRUE;
    if ( nConfSets != NULL ) {
        *nConfSets = count;
    }

exit:
    if ( values != NULL ) {
        ldap_value_freeW(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }
    return(ok);

} // ListConfSets


BOOL
GetValues(
    VOID
    )
{
    DWORD err;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PWSTR                   *values = NULL;
    BOOL    ok = FALSE;
    DWORD count;

    atts[0] = L"msDS-Other-Settings";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS,
                         ConfSetPath,
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {
        //"ldap_search of msDS-Other-Settings failed with %s"
        RESOURCE_PRINT2 (IDS_CONFSET_SEARCH2_ERR, 
                    err, GetLdapErr(err));
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry )
    {
        //"0 entries returned when reading Settings\n"
        RESOURCE_PRINT (IDS_CONFSET_NO_ENTRIES2);
        goto exit;
    }

    values = ldap_get_valuesW(gldapDS, entry, atts[0]);

    if ( !values )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            //"No rights to read Settings\n"
            RESOURCE_PRINT (IDS_CONFSET_NO_RIGHTS1);
            goto exit;
        }
        
        //"Unable to get values for %s\n"
        RESOURCE_PRINT1  (IDS_CONFSET_RETRIVE_ERR, 
                    atts[0]);
        goto exit;
    }

    count = 0;
    while ( values[count] != NULL ) {

        DWORD i;
        PWCHAR p;

        for (i=0; i< nConfSets; i++ ) {

            if ( _wcsnicmp(values[count], gConfSets[i].Name, wcslen(gConfSets[i].Name) ) == 0) {

                //
                // Get the value
                //

                p=wcschr(values[count],L'=');
                if (p != NULL) {
                    p++;

                    if ( gConfSets[i].ValueType == CONFSET_INTEGER ) {

                        gConfSets[i].CurrentValue = _wtoi(p);

                    } else {

                        if ( _wcsicmp(p, L"TRUE") == 0 ) {
                            gConfSets[i].CurrentValue = 1;
                        } else {
                            gConfSets[i].CurrentValue = 0;
                        }
                    }
                    break;
                }
            }
        }

        count++;
    }

    ok = TRUE;
exit:

    if ( values != NULL ) {
        ldap_value_freeW(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }
    return ok;

} // GetValues


BOOL
GetConfSetPath(
    VOID
    )
{

    DWORD err;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PWSTR                   *values = NULL;
    BOOL    ok = FALSE;

    if ( ConfSetPath != NULL ) {
        return TRUE;
    }

    atts[0] = L"configurationNamingContext";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS,
                         L"",
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {
        //"ldap_search of configurationNamingContext failed with %s"
        RESOURCE_PRINT2  (IDS_CONFSET_SEARCH3_ERR, 
                    err, GetLdapErr(err));
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry ) {
        //"Unable to get entry from search\n"
        RESOURCE_PRINT  (IDS_CONFSET_SEARCH_ENTRY_ERR);
        goto exit;
    }

    values = ldap_get_valuesW(gldapDS, entry, atts[0]);

    if ( !values || (values[0] == NULL) )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            //"No rights to read RootDSE\n"
            RESOURCE_PRINT  (IDS_CONFSET_NO_RIGHTS2);
            goto exit;
        }

        //"Unable to get values for %s\n"
        RESOURCE_PRINT1  (IDS_CONFSET_RETRIVE_ERR, atts[0]);
        goto exit;
    }

    ConfSetPath =
        (PWCHAR)LocalAlloc(LPTR, (wcslen(values[0]) + wcslen(CONFSET_PATH))*sizeof(WCHAR) +
                           sizeof(WCHAR));

    if ( ConfSetPath == NULL ) {

        //"Cannot allocate memory for confset path\n"
        RESOURCE_PRINT  (IDS_CONFSET_MEMORY2_ERR);
        goto exit;
    }

    wcscpy(ConfSetPath, CONFSET_PATH);
    wcscat(ConfSetPath, values[0]);

    ok = TRUE;

exit:

    if ( values != NULL ) {
        ldap_value_freeW(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }

    return ok;

} // GetConfSetPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\dbinfo.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "connect.hxx"

#include "resource.h"

void
FreeSystemInfo(
    SystemInfo  *pInfo
    )
/*++

  Routine Description: 

    Frees the memory associated with a SystemInfo.

  Parameters: 

    pInfo - SystemInfo pointer.

  Return Values:

    None.

--*/
{
    LogInfo *pLogInfo, *pTmpInfo;

    if ( pInfo )
    {
        pLogInfo = pInfo->pLogInfo;

        // Free the linked list of log file information.

        while ( pLogInfo )
        {
            pTmpInfo = pLogInfo;
            pLogInfo = pLogInfo->pNext;
            free(pTmpInfo);
        }
        
        free(pInfo);
    }
}

void
GetDbInfo(
    SystemInfo  *pInfo
)
/*++

  Routine Description:

    Reads various registry keys which identify where the DS files are
    and then determines those files' sizes, etc. 

  Parameters:

    pInfo - Pointer to SystemInfo to fill.

  Return Values:

    None.

--*/
{
    HKEY            hKey;
    HANDLE          hFile;
    DWORD           dwErr;
    DWORD           dwType;
    DWORD           cbData;
    LARGE_INTEGER   liDbFileSize;
    LogInfo         *pLogInfo;
    char            *pPattern;
    char            *pTmp;
    char            *pDbFileName = NULL;
    DWORD           cFilesExamined;

    if ( dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hKey) )
    {
        //"%s %d(%s) opening registry key %s\n"
        RESOURCE_PRINT3(IDS_ERR_OPENING_REGISTRY, 
                dwErr, GetW32Err(dwErr),
                DSA_CONFIG_SECTION);
        return;
    }

    _try
    {
        // Read FILEPATH_KEY.

        cbData = sizeof(pInfo->pszDbAll);
        dwErr = RegQueryValueEx(    hKey, 
                                    FILEPATH_KEY, 
                                    NULL,
                                    &dwType, 
                                    (LPBYTE) pInfo->pszDbAll, 
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            //"%s %d(%s) reading %s\\%s\n"
            RESOURCE_PRINT4(IDS_WRN_READING, 
                    dwErr, GetW32Err(dwErr),
                    DSA_CONFIG_SECTION,
                    FILEPATH_KEY);
        } 
        else if ( cbData > sizeof(pInfo->pszDbAll) )
        {
            // "%s buffer overflow reading %s\\%s\n"
            RESOURCE_PRINT2(IDS_ERR_BUFFER_OVERFLOW,
                    DSA_CONFIG_SECTION,
                    FILEPATH_KEY);
        }
        else
        {
            strcpy(pInfo->pszDbDir, pInfo->pszDbAll);
            pTmp = strrchr(pInfo->pszDbDir, (int) '\\');
    
            if ( !pTmp )
            {
                //"%s Invalid DB path in %s\\%s\n"
                RESOURCE_PRINT2(IDS_ERR_INVALID_PATH, 
                        DSA_CONFIG_SECTION,
                        FILEPATH_KEY);
                pInfo->pszDbAll[0] = '\0';
                pInfo->pszDbFile[0] = '\0';
                pInfo->pszDbDir[0] = '\0';
            }
            else
            {
                *pTmp = '\0';
                pTmp++;
                strcpy(pInfo->pszDbFile, pTmp);
                pDbFileName = pTmp;
            }
        }

        // Read LOGPATH_KEY.
    
        cbData = sizeof(pInfo->pszLogDir);
        dwErr = RegQueryValueEx(    hKey, 
                                    LOGPATH_KEY, 
                                    NULL,
                                    &dwType, 
                                    (LPBYTE) pInfo->pszLogDir, 
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            //"%s %d(%s) reading %s\\%s\n"
            RESOURCE_PRINT4(IDS_WRN_READING, 
                    dwErr, GetW32Err(dwErr),
                    DSA_CONFIG_SECTION,
                    LOGPATH_KEY);
        }
        else if ( cbData > sizeof(pInfo->pszLogDir) )
        {
            // "%s buffer overflow reading %s\\%s\n"
            RESOURCE_PRINT2(IDS_ERR_BUFFER_OVERFLOW,
                    DSA_CONFIG_SECTION,
                    LOGPATH_KEY);
        }

        // Read BACKUPPATH_KEY.

        cbData = sizeof(pInfo->pszBackup);
        dwErr = RegQueryValueEx(    hKey, 
                                    BACKUPPATH_KEY, 
                                    NULL,
                                    &dwType, 
                                    (LPBYTE) pInfo->pszBackup, 
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            //"%s %d(%s) reading %s\\%s\n"
            RESOURCE_PRINT4(IDS_WRN_READING, 
                    dwErr, GetW32Err(dwErr),
                    DSA_CONFIG_SECTION,
                    BACKUPPATH_KEY);
        }
        else if ( cbData > sizeof(pInfo->pszLogDir) )
        {
            // "%s buffer overflow reading %s\\%s\n"
            RESOURCE_PRINT2(IDS_ERR_BUFFER_OVERFLOW,
                    DSA_CONFIG_SECTION,
                    BACKUPPATH_KEY);
        }

        // Read JETSYSTEMPATH_KEY.

        cbData = sizeof(pInfo->pszSystem);
        dwErr = RegQueryValueEx(    hKey, 
                                    JETSYSTEMPATH_KEY, 
                                    NULL,
                                    &dwType, 
                                    (LPBYTE) pInfo->pszSystem, 
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            //"%s %d(%s) reading %s\\%s\n"
            RESOURCE_PRINT4(IDS_WRN_READING, 
                    dwErr, GetW32Err(dwErr),
                    DSA_CONFIG_SECTION,
                    JETSYSTEMPATH_KEY);
        }
        else if ( cbData > sizeof(pInfo->pszLogDir) )
        {
            // "%s buffer overflow reading %s\\%s\n"
            RESOURCE_PRINT2(IDS_ERR_BUFFER_OVERFLOW,
                    DSA_CONFIG_SECTION,
                    JETSYSTEMPATH_KEY);
        }
    }
    _finally
    {
        RegCloseKey(hKey);
    }

    // Get size of the DB - provided it was found.

    if ( pInfo->pszDbFile[0] )
    {
        hFile = CreateFile(pInfo->pszDbAll,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
    
        if ( INVALID_HANDLE_VALUE == hFile )
        {
            dwErr = GetLastError();
            //"%s %d(%s) opening \"%s\"\n"
            RESOURCE_PRINT3(IDS_ERR_OPENING_REGISTRY, 
                    dwErr, GetW32Err(dwErr),
                    pInfo->pszDbAll);
        }
        else
        {
            liDbFileSize.LowPart = GetFileSize(
                                        hFile, 
                                        (DWORD *) &liDbFileSize.HighPart);
    
            if ( 0xffffffff == liDbFileSize.LowPart )
            {
                dwErr = GetLastError();
                //"%s %d(%s) getting size of \"%s\"\n"
                RESOURCE_PRINT3(IDS_ERR_GETTING_SIZE,
                        dwErr, GetW32Err(dwErr),
                        pInfo->pszDbAll);
            }
            else
            {
                pInfo->cbDb.QuadPart = liDbFileSize.QuadPart;
            }

            CloseHandle(hFile);
        }
    }

    // Get sizes of all log (and associated non-DB) files.  We 
    // consider anything that is not the DB or a directory is a log.

    if ( pInfo->pszLogDir[0] )
    {
        pPattern = (char *) alloca(strlen(pInfo->pszLogDir) + 10);
        strcpy(pPattern, pInfo->pszLogDir);
        strcat(pPattern, "\\*");

        // dwErr will signal whether we need to clean up allocations
        // in case of early exit.
        dwErr = 0;
        hFile = INVALID_HANDLE_VALUE;
        cFilesExamined = 0;

        while ( TRUE )
        {
            // Allocate a new LogInfo node to link into pInfo.

            pLogInfo = (LogInfo *) malloc(sizeof(LogInfo));

            if ( !pLogInfo )
            {
                RESOURCE_PRINT (IDS_MEMORY_ERROR);
                dwErr = 1;
                break;
            }
    
            memset(pLogInfo, 0, sizeof(LogInfo));

            // Read either the first or Nth matching file name.

            if (  0 == cFilesExamined++ )
            {
                hFile = FindFirstFile(pPattern, &pLogInfo->findData);
    
                if ( INVALID_HANDLE_VALUE == hFile )
                {
                    dwErr = GetLastError();
                    //"%s %d(%s) finding first match of \"%s\"\n"
                    RESOURCE_PRINT3 (IDS_ERR_FINDING_1st_MATCH, 
                            dwErr, GetW32Err(dwErr),
                            pPattern);
                    free(pLogInfo);
                    break;
                }
            }
            else
            {
                if ( !FindNextFile(hFile, &pLogInfo->findData) )
                {
                    dwErr = GetLastError();
    
                    if ( ERROR_NO_MORE_FILES == dwErr )
                    {
                        dwErr = 0;
                        hFile = INVALID_HANDLE_VALUE;
                    }
                    else
                    {
                        //"%s %d(%s) finding Nth match of \"%s\"\n"
                        RESOURCE_PRINT3 (IDS_ERR_FINDING_Nth_MATCH, 
                                dwErr, GetW32Err(dwErr),
                                pPattern);
                    }
    
                    free(pLogInfo);
                    break;
                }
            }

            // See if this item is worth saving.

            if (    (    pDbFileName 
                      && !_stricmp( pDbFileName, 
                                    pLogInfo->findData.cFileName) )
                 || ( !_stricmp(".", pLogInfo->findData.cFileName) )
                 || ( !_stricmp("..", pLogInfo->findData.cFileName) )
                 || ( !_stricmp("edb.chk", pLogInfo->findData.cFileName) )
                 || ( pLogInfo->findData.dwFileAttributes 
                                                & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                free(pLogInfo);
                continue;
            }
    
            // Hook this file/LogInfo into the linked list.

            pLogInfo->pNext = pInfo->pLogInfo;
            pInfo->pLogInfo = pLogInfo;

            // Save file size and advance count.

            pLogInfo->cBytes.LowPart = 
                            pLogInfo->findData.nFileSizeLow;
            pLogInfo->cBytes.HighPart = 
                            (LONG) pLogInfo->findData.nFileSizeHigh;
            pInfo->cbLogs.QuadPart += pLogInfo->cBytes.QuadPart;
            pInfo->cLogs++;
        } // while ( TRUE )

        // Miscellaneous cleanup.

        if ( INVALID_HANDLE_VALUE != hFile )
        {
            FindClose(hFile);
        }

        if ( dwErr )
        {
            // Error getting the log file names and sizes.  Clean out
            // partially complete linked list and reset counters.

            pInfo->cLogs = 0;
            pInfo->cbLogs.QuadPart = 0;
            pLogInfo = pInfo->pLogInfo;
            
            while ( pInfo->pLogInfo )
            {
                pLogInfo = pInfo->pLogInfo;
                pInfo->pLogInfo = pInfo->pLogInfo->pNext;
                free(pLogInfo);
            }
        }
    }
}

SystemInfo *
GetSystemInfo(
    )
/*++

  Routine Description:

    Retrieves information about drives in the system and the DS files.

  Parameters:

    None.

  Return Values:

    Returns a filled in SystemInfo* or NULL otherwise.

--*/
{
    SystemInfo      *pInfo;
    char            pszDriveNames[(4*26)+10];
    char            *pszDrive;
    UINT            driveType;
    DWORD           dwErr, dwDontCare;
    LARGE_INTEGER   sectorsPerCluster, bytesPerSector, freeClusters, clusters;
    DiskSpaceString pszFree, pszTotal;

    pInfo = (SystemInfo *) malloc(sizeof(SystemInfo));

    if ( !pInfo )
    {
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return(NULL);
    }

    memset(pInfo, 0, sizeof(SystemInfo));

    // Get disk info.

    if ( sizeof(pszDriveNames) < GetLogicalDriveStrings(sizeof(pszDriveNames),
                                                        pszDriveNames) )
    {
        dwErr = GetLastError();
        //"%s %d(%s) getting logical drive strings\n"
        RESOURCE_PRINT2 (IDS_ERR_GET_LOGICAL_DRIVE_STRS,
                dwErr, GetW32Err(dwErr));
        FreeSystemInfo(pInfo);
        return(NULL);
    }

    // Parse the drive letter string.

    pszDrive = pszDriveNames;

    while ( *pszDrive )
    {
        driveType = GetDriveType(pszDrive);

        if ( DRIVE_FIXED == driveType || (DRIVE_REMOTE == driveType) )
        {                                                             
            if ( !GetVolumeInformation(
                                pszDrive,
                                NULL,
                                0,
                                NULL,
                                &dwDontCare,
                                &dwDontCare,
                                pInfo->rDrives[pInfo->cDrives].pszFileSystem,
                                FILE_SYSTEM_NAME_LEN) )
            {
                dwErr = GetLastError();
                //"%s %d(%s) getting volume information for %s\n", 
                RESOURCE_PRINT3 (IDS_WRN_GET_VOLUME_INFO,
                        dwErr, GetW32Err(dwErr),
                        pszDrive);
                goto nextDrive;
            }

            sectorsPerCluster.QuadPart = 0;
            bytesPerSector.QuadPart = 0;
            freeClusters.QuadPart = 0;
            clusters.QuadPart = 0;

            if ( !GetDiskFreeSpace(
                                pszDrive,
                                &sectorsPerCluster.LowPart,
                                &bytesPerSector.LowPart,
                                &freeClusters.LowPart,
                                &clusters.LowPart) )
            {
                dwErr = GetLastError();
                //"%s %d(%s) getting disk free space for %s\n"
                RESOURCE_PRINT3 (IDS_WRN_GET_FREE_SPACE,
                        dwErr, GetW32Err(dwErr),
                        pszDrive);
                goto nextDrive;
            }

            pInfo->rDrives[pInfo->cDrives].driveType = driveType;
            pInfo->rDrives[pInfo->cDrives].dwBytes.QuadPart =
                    (sectorsPerCluster.QuadPart 
                                * bytesPerSector.QuadPart 
                                            * clusters.QuadPart);
            pInfo->rDrives[pInfo->cDrives].dwFreeBytes.QuadPart =
                    (sectorsPerCluster.QuadPart 
                                * bytesPerSector.QuadPart 
                                            * freeClusters.QuadPart);
            strcpy(pInfo->rDrives[pInfo->cDrives++].pszDrive, pszDrive);
        }
        

nextDrive:

        pszDrive += (strlen(pszDrive) + 1);
    }

    GetDbInfo(pInfo);

    return(pInfo);
}

HRESULT 
DbInfo(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Main routine called by parser to generate system and file information.

  Parameters:

    pArgs - Pointer to argument block - ignored.

  Return Values:

    Always returns S_OK.

--*/
{
    SystemInfo *pInfo;

    pInfo = GetSystemInfo();

    if ( pInfo )
    {
        DumpSystemInfo(pInfo);
        FreeSystemInfo(pInfo);
    }

    return(S_OK);
}

void
DumpSystemInfo(
    SystemInfo  *pInfo
    )
/*++

  Routine Description:

    Dumps contents of a SystemInfo struct to stdout in formatted fashion.

  Parameters:

    pInfo - Pointer to SystemInfo to dump.

  Return Values:

    None.

--*/
{
    DWORD           i;
    DiskSpaceString pszFree;
    DiskSpaceString pszTotal;
    LogInfo         *pLogInfo;

    if ( pInfo )
    {
        //"\nDrive Information:\n\n"
        RESOURCE_PRINT (IDS_DRIVE_INFO);

        const WCHAR *msg_drive_fixed = READ_STRING (IDS_DRIVE_FIXED);
        const WCHAR *msg_drive_network = READ_STRING (IDS_DRIVE_NETWORK);

        for ( i = 0; i < pInfo->cDrives; i++ )
        {
            FormatDiskSpaceString(&pInfo->rDrives[i].dwFreeBytes, pszFree);
            FormatDiskSpaceString(&pInfo->rDrives[i].dwBytes, pszTotal);
    
            //"\t%s %s free(%s) total(%s)\n"
            RESOURCE_PRINT5 (IDS_DRIVE_FREE_TOTAL,
                    pInfo->rDrives[i].pszDrive,
                    pInfo->rDrives[i].pszFileSystem,
                    pInfo->rDrives[i].driveType == DRIVE_FIXED ? msg_drive_fixed : msg_drive_network,
                    pszFree,
                    pszTotal);
        }

        RESOURCE_STRING_FREE (msg_drive_fixed);
        RESOURCE_STRING_FREE (msg_drive_network);


        //"\nDS Path Information:\n\n"
        RESOURCE_PRINT (IDS_DS_PATH_INFO);

        if ( pInfo->pszDbDir[0] )
        {
            FormatDiskSpaceString(&pInfo->cbDb, pszTotal);
            //"\tDatabase   : %s\\%s - %s\n"
            RESOURCE_PRINT3 (IDS_DATABASE_PATH,
                    pInfo->pszDbDir, 
                    pInfo->pszDbFile,
                    pszTotal);
        }

        if ( pInfo->pszBackup[0] )
        {
            //"\tBackup dir : %s\n"
            RESOURCE_PRINT1 (IDS_BACKUP_PATH, pInfo->pszBackup);
        }

        if ( pInfo->pszSystem[0] )
        {
            //"\tWorking dir: %s\n"
            RESOURCE_PRINT1 (IDS_WORK_PATH, pInfo->pszSystem);
        }
    
        if ( pInfo->pszLogDir[0] )
        {
            FormatDiskSpaceString(&pInfo->cbLogs, pszTotal);
            //"\tLog dir    : %s - %s total\n"
            RESOURCE_PRINT2 (IDS_LOG_PATH,
                    pInfo->pszLogDir, 
                    pszTotal);

            pLogInfo = pInfo->pLogInfo;

            for ( i = 0; i < pInfo->cLogs; i++ )
            {
                FormatDiskSpaceString(&pLogInfo->cBytes, pszTotal);
                printf( "\t\t\t%s - %s\n", 
                        pLogInfo->findData.cFileName, 
                        pszTotal);
                pLogInfo = pLogInfo->pNext;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\connect.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "ldapparm.hxx"

#include "resource.h"

extern "C" {
#include "lmcons.h"         // MAPI constants req'd for lmapibuf.h
#include "lmapibuf.h"       // NetApiBufferFree()
#include "dsgetdc.h"

#include <ndnc.h>

}

HANDLE                      ghDS = NULL;
WCHAR                       gpwszServer[MAX_PATH] = { L'\0' };
WCHAR                       gpwszUser[MAX_PATH];
WCHAR                       gpwszDomain[MAX_PATH];
SEC_WINNT_AUTH_IDENTITY_W   *gpCreds = NULL;

// Forward references

extern HRESULT  ConnectHelp(CArgs *pArgs);
extern HRESULT  ConnectQuit(CArgs *pArgs);
extern HRESULT  ConnectClearCredentials(CArgs *pArgs);
extern HRESULT  ConnectSetCredentials(CArgs *pArgs);
extern HRESULT  ConnectToDomain(CArgs *pArgs);
extern HRESULT  ConnectToServer(CArgs *pArgs);
extern HRESULT  ConnectInfo(CArgs *pArgs);

CParser connectParser;
BOOL    fConnectQuit;
BOOL    fConnectParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes connectLanguage[] = 
{
    {   L"?", 
        ConnectHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help", 
        ConnectHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        ConnectQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Set creds %s %s %s",
        ConnectSetCredentials,
        IDS_CONNECT_SET_CRED_MSG, 0 },

    {   L"Clear creds",
        ConnectClearCredentials,
        IDS_CONNECT_CLEAR_CRED_MSG, 0 },

    {   L"Connect to server %s", 
        ConnectToServer,
        IDS_CONNECT_SRV_MSG, 0 },

    {   L"Connect to domain %s",
        ConnectToDomain,
        IDS_CONNECT_DOMAIN_MSG, 0 },

    {   L"Info",
        ConnectInfo,
        IDS_CONNECT_INFO_MSG, 0 }
};


VOID NotConnectedPrintError ()
{
   RESOURCE_PRINT (IDS_NOT_CONNECTED);
}


HRESULT
ConnectMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fConnectParserInitialized )
    {
        cExpr = sizeof(connectLanguage) / sizeof(LegalExprRes);

        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (connectLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }
    
        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = connectParser.AddExpr(connectLanguage[i].expr,
                                                   connectLanguage[i].func,
                                                   connectLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fConnectParserInitialized = TRUE;
    fConnectQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SRV_CONNECTIONS);

    // For the re-entry case, print out current connection state.
    ConnectInfo(NULL);

    hr = connectParser.Parse(gpargc,
                             gpargv,
                             stdin,
                             stdout,
                             prompt,
                             &fConnectQuit,
                             FALSE,               // timing info
                             FALSE);              // quit on error

    if ( FAILED(hr) )
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT ConnectHelp(CArgs *pArgs)
{
    return(connectParser.Dump(stdout,L""));
}

HRESULT ConnectQuit(CArgs *pArgs)
{
    fConnectQuit = TRUE;
    return(S_OK);
}

VOID 
ConnectCleanupConnections()
{
    BOOL fNotifyOfDisconnect = FALSE;

    if ( ghDS )
    {
        fNotifyOfDisconnect = TRUE;
        DsUnBindW(&ghDS);
        ghDS = NULL;
    }

    if ( gldapDS )
    {
        fNotifyOfDisconnect = TRUE;
        ldap_unbind(gldapDS);
        gldapDS = NULL;
    }

    if ( *gpwszServer )
    {
        if ( fNotifyOfDisconnect )
        {
            if ( gpCreds )
            {
               RESOURCE_PRINT3 (IDS_CONNECT_CLEANUP1, gpwszUser, gpwszDomain, gpwszServer);
            }
            else
            {
               RESOURCE_PRINT1 (IDS_CONNECT_CLEANUP2, gpwszServer);
            }
        }

        gpwszServer[0] = L'\0';
    }

    // Always cleanup selections when cleaning up connections.
    SelectCleanupGlobals();

    //
    // Cleanup LDAP globals when connection is torn down.
    //

    LdapCleanupGlobals( );
}

VOID
ConnectCleanupCreds()
{
    if ( gpCreds )
    {
        DsFreePasswordCredentials(
            (RPC_AUTH_IDENTITY_HANDLE *) gpCreds);
        gpCreds = NULL;
    }
}

VOID
ConnectCleanupGlobals()
{
    ConnectCleanupConnections();
    ConnectCleanupCreds();
}

HRESULT
ConnectToServer(
    CArgs   *pArgs
    )
{
    SEC_WINNT_AUTH_IDENTITY creds;
    WCHAR                   *pwszServer;
    WCHAR                   *pTmpServer;
    DWORD                   dwErr;
    HRESULT                 hr;
    ULONG                   ulOptions;

    // Flush old state.

    ConnectCleanupConnections();

    // Get server argument.

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pwszServer)) )
    {
        return(hr);
    }

    if ( gpCreds )
    {
       RESOURCE_PRINT3 (IDS_CONNECT_BINDING1,
               pwszServer, gpwszUser, gpwszDomain);
    }
    else
    {
       RESOURCE_PRINT1 (IDS_CONNECT_BINDING2,
               pwszServer);
    }

    // Bind to RPC interface.

    if ( gpCreds )
    {
        dwErr = DsBindWithCredW(pwszServer, NULL, gpCreds, &ghDS);
    }
    else
    {
        dwErr = DsBindW(pwszServer, NULL, &ghDS);
    }

    if ( dwErr )
    {
        RESOURCE_PRINT3 (IDS_CONNECT_ERROR, 
               gpCreds ? "DsBindWithCredW" : "DsBindW", 
               dwErr, GetW32Err(dwErr));
        ConnectCleanupConnections();
        return(S_OK);
    }

    // Set up an LDAP connection.

    pTmpServer = pwszServer;
    
    if ( !wcsncmp(L"\\\\", pTmpServer, 2) )
    {
        // LDAP bind chokes on leading "\\".
        pTmpServer += 2;
    }

    if ( NULL == (gldapDS = ldap_initW(pTmpServer, LDAP_PORT)) )
    {
        RESOURCE_PRINT1 (IDS_CONNECT_LDAP_OPEN_ERROR, pwszServer);
        
        ConnectCleanupConnections();
        return(S_OK);
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( gldapDS, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
    
    // This function sets an option in the ldap handle so that DomCreateNDNC
    // can function.  See function for more details.
    if(!SetIscReqDelegate(gldapDS)){
        // The function should have printed out the error.
        ConnectCleanupConnections();
        return(S_OK);
    }

    if ( gpCreds )
    {
        dwErr = ldap_bind_sW(gldapDS, NULL, (WCHAR *) gpCreds, LDAP_AUTH_SSPI);
    }
    else
    {
        memset(&creds, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
        creds.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        dwErr = ldap_bind_sW(gldapDS, NULL, (WCHAR *) &creds, LDAP_AUTH_SSPI);
    }

    if ( LDAP_SUCCESS != dwErr )
    {
        RESOURCE_PRINT2 (IDS_CONNECT_LDAP_BIND_ERROR, dwErr, GetLdapErr(dwErr));
        
        ConnectCleanupConnections();
        return(S_OK);
    }

    wcscpy(gpwszServer, pwszServer);
    ConnectInfo(NULL);
    return(S_OK);
}

HRESULT
ConnectInfo(
    CArgs   *pArgs
    )
{
    if ( !ghDS || !gldapDS )
    {
        return(S_OK);
    }

    if ( gpCreds )
    {
       RESOURCE_PRINT3 (IDS_CONNECT_INFO1,
                 gpwszServer, gpwszUser, gpwszDomain);
    }
    else
    {
       RESOURCE_PRINT1 (IDS_CONNECT_INFO2,
                 gpwszServer);
    }
    
    return(S_OK);
}

HRESULT
ConnectToDomain(
    CArgs   *pArgs
    )
{
    WCHAR                   *pwszDomain;
    DWORD                   dwErr;
    HRESULT                 hr;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;
    CArgs                   args;
 
    ConnectCleanupConnections();

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pwszDomain)) )
    {
        return(hr);
    }

    dwErr = DsGetDcNameW(
                NULL,                       // computer name
                pwszDomain,                 // DNS domain nam
                NULL,                       // domain guid
                NULL,                       // site guid
                DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                &pDcInfo);

    if ( 0 != dwErr )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsGetDcNameW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    if ( FAILED(hr = args.Add((const WCHAR *) pDcInfo->DomainControllerName)) )
    {
        NetApiBufferFree(pDcInfo);
        //"Internal error 0x%x(%s)\n"
        RESOURCE_PRINT2 (IDS_ERR_INTERNAL, hr, GetW32Err(hr));
        return(S_OK);
    }

    ConnectToServer(&args);
    NetApiBufferFree(pDcInfo);
    return(S_OK);
}

HRESULT
ConnectSetCredentials(
    CArgs   *pArgs
    )
{
    WCHAR   *pUser;
    WCHAR   *pDomain;
    WCHAR   *pPassword;
    DWORD   dwErr;
    HRESULT hr;

    // Wipe any current connections if they are going to change credentials.

    ConnectCleanupCreds();

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pDomain)) )
    {
        return(hr);
    }

    if ( FAILED(hr = pArgs->GetString(1, (const WCHAR **) &pUser)) )
    {
        return(hr);
    }

    if ( FAILED(hr = pArgs->GetString(2, (const WCHAR **) &pPassword)) )
    {
        return(hr);
    }

    if ( !_wcsicmp(pPassword, L"null") )
    {
        pPassword = L"";
    }

    if ( dwErr = DsMakePasswordCredentialsW(
                            pUser,
                            pDomain,
                            pPassword,
                            (RPC_AUTH_IDENTITY_HANDLE *) &gpCreds) )
    {
        ConnectCleanupCreds();
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsMakePasswordCredentialsW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    wcscpy(gpwszUser, pUser);
    wcscpy(gpwszDomain, pDomain);
    return(S_OK);
}

HRESULT
ConnectClearCredentials(
    CArgs   *pArgs
    )
{
    ConnectCleanupCreds();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\dommgmt.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dommgmt.cxx

Abstract:

    This module contains commands for Domain Naming Context and Non-Domain
    Naming Context management.

Author:

    Dave Straube (DaveStr) Long Ago

Environment:

    User Mode.

Revision History:

    21-Feb-2000     BrettSh

        Added support for Non-Domain Naming Contexts.

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <assert.h>
#include <windns.h>

#include "ntdsutil.hxx"
#include "select.hxx"
#include "connect.hxx"
#include "ntdsapip.h"

#include "resource.h"

// The Non-Domain Naming Context (NDNC) routines are in a different file, 
// and a whole different library, for two reasons:
// A) So this file can be ported to the Platform SDK as an example of how to 
//    implement NDNCs programmatically.
// B) So that the utility tapicfg.exe, could make use of the same routines.
#include <ndnc.h>

CParser domParser;
BOOL    fDomQuit;
BOOL    fDomParserInitialized = FALSE;
DS_NAME_RESULTW *gNCs = NULL;

// Build a table which defines our language.

extern HRESULT DomHelp(CArgs *pArgs);
extern HRESULT DomQuit(CArgs *pArgs);
extern HRESULT DomListNCs(CArgs *pArgs);
extern HRESULT DomAddNC(CArgs *pArgs);
extern HRESULT DomCreateNDNC(CArgs *pArgs);
extern HRESULT DomDeleteNDNC(CArgs *pArgs);
extern HRESULT DomAddNDNCReplica(CArgs *pArgs);
extern HRESULT DomRemoveNDNCReplica(CArgs *pArgs);
extern HRESULT DomSetNDNCRefDom(CArgs *pArgs);
extern HRESULT DomSetNCReplDelays(CArgs *pArgs);
extern HRESULT DomListNDNCReplicas(CArgs *pArgs);
extern HRESULT DomListNDNCInfo(CArgs *pArgs);

LegalExprRes domLanguage[] = 
{
    CONNECT_SENTENCE_RES

    SELECT_SENTENCE_RES

    {   L"?",
        DomHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        DomHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        DomQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"List",
        DomListNCs,
        IDS_DM_MGMT_LIST_MSG, 0 },

    {   L"Precreate %s %s",
        DomAddNC,
        IDS_DM_MGMT_PRECREATE_MSG, 0 },

    // The following 8 functions are for NDNCs.
    {   L"Create NC %s %s",
        DomCreateNDNC,
        IDS_DM_MGMT_CREATE_NDNC, 0 },

    {   L"Delete NC %s",
        DomDeleteNDNC,
        IDS_DM_MGMT_DELETE_NDNC, 0 },

    {   L"Add NC Replica %s %s",
        DomAddNDNCReplica,
        IDS_DM_MGMT_ADD_NDNC_REPLICA, 0 },

    {   L"Remove NC Replica %s %s",
        DomRemoveNDNCReplica,
        IDS_DM_MGMT_REMOVE_NDNC_REPLICA, 0 },

    {   L"Set NC Reference Domain %s %s",
        DomSetNDNCRefDom,
        IDS_DM_MGMT_SET_NDNC_REF_DOM, 0 },

    {   L"Set NC Replicate Notification Delay %s %d %d",
        DomSetNCReplDelays,
        IDS_DM_MGMT_SET_NDNC_REPL_DELAYS, 0 },

    {   L"List NC Replicas %s",
        DomListNDNCReplicas,
        IDS_DM_MGMT_LIST_NDNC_REPLICAS, 0 },

    {   L"List NC Information %s",
        DomListNDNCInfo,
        IDS_DM_MGMT_LIST_NDNC_INFO, 0 },
    
};

HRESULT
DomMgmtMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fDomParserInitialized ) {
        cExpr = sizeof(domLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (domLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }
        
        
        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ ) {
            if ( FAILED(hr = domParser.AddExpr(domLanguage[i].expr,
                                               domLanguage[i].func,
                                               domLanguage[i].help)) ) {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fDomParserInitialized = TRUE;
    fDomQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_DOMAIN_MGMT);

    hr = domParser.Parse(gpargc,
                         gpargv,
                         stdin,
                         stdout,
                         prompt,
                         &fDomQuit,
                         FALSE,               // timing info
                         FALSE);              // quit on error

    if ( FAILED(hr) )
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);


    return(hr);
}


HRESULT
DomHelp(CArgs *pArgs)
{
    return domParser.Dump(stdout,L"");
}

HRESULT
DomQuit(CArgs *pArgs)
{
    fDomQuit = TRUE;
    return S_OK;
}

WCHAR wcPartition[] = L"cn=Partitions,";
ULONG ChaseReferralFlag = LDAP_CHASE_EXTERNAL_REFERRALS;
LDAPControlW ChaseReferralControl = {LDAP_CONTROL_REFERRALS_W,
                                     {sizeof(ChaseReferralFlag), 
                                         (PCHAR)&ChaseReferralFlag},
                                     FALSE};


HRESULT
DomAddNC(CArgs *pArgs)
{
    WCHAR *pDomain[2];
    WCHAR *pDNS[2];
    HRESULT hr;
    WCHAR *pwcTemp;
    LDAPModW Mod[99];
    LDAPModW *pMod[99];
    WCHAR *dn, *pConfigDN;
    WCHAR *objclass[] = {L"crossRef", NULL};
    WCHAR *enabled[] = {L"FALSE", NULL};
    DWORD dwErr;
    int i, iStart, iEnd;
    PLDAPControlW pServerControls[1];
    PLDAPControlW pClientControls[2];

    // Fetch arguments
    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pDomain[0])) ) {
        return(hr);
    }

    if ( FAILED(hr = pArgs->GetString(1, (const WCHAR **) &pDNS[0])) ) {
        return(hr);
    }

    // Check NCName to make sure it looks like a domain name
    pwcTemp = pDomain[0];
    if ( !CheckDnsDn(pwcTemp) ) {
        RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
        return S_OK;
    }

    i = iStart = iEnd = 0;
    while (pwcTemp[i] && (iEnd == 0)) {
        if (pwcTemp[i] == L'=') {
            iStart = i+1;
        }
        if (pwcTemp[i] == L',') {
            iEnd = i;
        }
        ++i;
    }
    if (   (iStart == 0)
        || (iEnd == 0)
        || (iStart >= iEnd)) {
        RESOURCE_PRINT1 (IDS_DM_MGMT_UNPARSABLE_DN, pwcTemp);
        return S_OK;
    }

    // Check DNS address for reasonable-ness
    pwcTemp = pDNS[0];
    i = 0;
    while ((i == 0) && *pwcTemp) {
        if(*pwcTemp == L'.') {
            i = 1;
        }
        ++pwcTemp;
    }
    if (i == 0) {
        //A full DNS address must contain at least one '.', which '%ws' doesn't\n"
        RESOURCE_PRINT1 (IDS_DM_MGMT_ADDRESS_ERR, pDNS[0]);
        return S_OK;
    }

    // Build the LDAP argument
    pMod[0] = &(Mod[0]);
    Mod[0].mod_op = LDAP_MOD_ADD;
    Mod[0].mod_type = L"objectClass";
    Mod[0].mod_vals.modv_strvals = objclass;

    pMod[1] = &(Mod[1]);
    Mod[1].mod_op = LDAP_MOD_ADD;
    Mod[1].mod_type = L"ncName";
    Mod[1].mod_vals.modv_strvals = pDomain;
    pDomain[1] = NULL;

    pMod[2] = &(Mod[2]);
    Mod[2].mod_op = LDAP_MOD_ADD;
    Mod[2].mod_type = L"dnsRoot";
    Mod[2].mod_vals.modv_strvals = pDNS;
    pDNS[1] = NULL;

    pMod[3] = &(Mod[3]);
    Mod[3].mod_op = LDAP_MOD_ADD;
    Mod[3].mod_type = L"enabled";
    Mod[3].mod_vals.modv_strvals = enabled;

    pMod[4] = NULL;

    if ( ReadAttribute(gldapDS,
                       L"\0",
                       L"configurationNamingContext",
                       &pConfigDN) ) {
        return S_OK;
    }

    dn = (WCHAR*)malloc((iEnd - iStart + 6 + wcslen(pConfigDN)) * sizeof(WCHAR)
                        + sizeof(wcPartition));
    if (!dn) {
        if(pConfigDN) { free(pConfigDN); }
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return S_OK;
    }

    dn[0]=L'C';
    dn[1]=L'N';
    dn[2]=L'=';
    for (i=3; i <= (iEnd + 3 - iStart); i++) {
        dn[i] = pDomain[0][iStart + i - 3];
    }
    wcscpy(&dn[i], wcPartition);
    wcscat(dn,pConfigDN);

    pServerControls[0] = NULL;
    pClientControls[0] = &ChaseReferralControl;
    pClientControls[1] = NULL;

    //"adding object %ws\n"
    RESOURCE_PRINT1 (IDS_DM_MGMT_ADDING_OBJ, dn);

#if 0
    dwErr = ldap_add_ext_sW(gldapDS,
                            dn,
                            pMod,
                            pServerControls,
                            pClientControls);

    if (LDAP_SUCCESS != dwErr) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "ldap_add_sW", dwErr, GetLdapErr(dwErr));
    }
#else
    ULONG msgid;
    LDAPMessage *pmsg;

    // 10 second timeout
    struct l_timeval timeout;
    timeout.tv_sec = 10;
    timeout.tv_usec = 10;

    ldap_add_extW(gldapDS,
                  dn,
                  pMod,
                  pServerControls,
                  pClientControls,
                  &msgid);

    ldap_result(gldapDS,
                msgid,
                LDAP_MSG_ONE,
                &timeout,
                &pmsg);

    ldap_parse_resultW(gldapDS,
                       pmsg,
                       &dwErr,
                       NULL,    // matched DNs
                       NULL,    // error message
                       NULL,    // referrals
                       NULL,    // server control
                       TRUE     // free the message
                       );
    

    if (LDAP_SUCCESS != dwErr) {
        //"ldap_addW of %ws failed with %s"
        RESOURCE_PRINT3 (IDS_LDAP_ADDW_FAIL, dn, dwErr, GetLdapErr(dwErr));
    }
#endif

    free(dn);
    free(pConfigDN);
    return S_OK;
}



HRESULT
DomListNCs(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;
    LPCWSTR dummy = L"dummy";

    RETURN_IF_NOT_CONNECTED;

    if ( gNCs )
    {
        DsFreeNameResultW(gNCs);
        gNCs = NULL;
    }
 
    if ( dwErr = DsCrackNamesW(ghDS,
                               DS_NAME_NO_FLAGS,
                               (DS_NAME_FORMAT)DS_LIST_NCS,
                               DS_FQDN_1779_NAME,
                               1,
                               &dummy,
                               &gNCs) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsCrackNamesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d Naming Context(s)\n"
    RESOURCE_PRINT1 (IDS_DM_MGMT_FOUND_NC, gNCs->cItems);

    for ( i = 0; i < gNCs->cItems; i++ )
    {
        printf("%d - %S\n", i, gNCs->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
DomCreateNDNC(
    CArgs   *pArgs    // "Create NC %s [%s]"
    )
{
    HRESULT       hr = S_OK;
    WCHAR *       ppNDNC[2];
    WCHAR *       ppDC[2];
    LDAP *        pLocalLdap = NULL;
    DWORD         dwRet;
    WCHAR *       pwcTemp;
    const WCHAR * wszNdncDesc;

    __try{
        // Fetch and Validate 1 or 2 Arguments.

        // Fetch 1st argument.
        if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &ppNDNC[0])) ) {
            __leave;
        }
        // Validate 1st Argument
        if( !CheckDnsDn(ppNDNC[0]) ){
            RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
            hr = S_OK;
            __leave;
        }


        // Fetch 2nd optional argument.
        if ( FAILED(hr = pArgs->GetString(1, (const WCHAR **) &ppDC[0])) ||
             (0 == _wcsicmp(ppDC[0], L"null")) ){
            // No 2nd argument, check if we are already connected to a DC
            //   through the "connections" menu.
            RETURN_IF_NOT_CONNECTED;
        } else {

            // Actually have 2nd argument, validate it.
            // Validate DC's DNS address.
            pwcTemp = ppDC[0];
            ULONG i = 0;
            while ((i == 0) && *pwcTemp) {
                if(*pwcTemp == L'.') {
                    i = 1;
                }
                ++pwcTemp;
            }
            if (i == 0) {
                //A full DNS address must contain at least one '.', which 
                //    '%ws' doesn't\n"
                RESOURCE_PRINT1 (IDS_DM_MGMT_ADDRESS_ERR, ppDC[0]);
                __leave;
            }

            // Connect & Bind to ppDC.
            pLocalLdap = GetNdncLdapBinding(ppDC[0], &dwRet, FALSE, gpCreds);
            if(!pLocalLdap){
                RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
                return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
            }
        }

        // At this point we should have a valid LDAP binding in pLocalLdap or
        //  gldapDS and a valid FQDN of the new NDNC.

        // "adding object %ws\n"
        RESOURCE_PRINT1 (IDS_DM_MGMT_ADDING_OBJ, ppNDNC[0]);

        wszNdncDesc = READ_STRING (IDS_DM_MGMT_NDNC_DESC);
        if(0 == wcscmp(wszNdncDesc, DEFAULT_BAD_RETURN_STRING)){
            assert(!"Couldn't read string from our own array.");
            __leave;
        }

        dwRet = CreateNDNC((pLocalLdap) ? pLocalLdap : gldapDS,
                           ppNDNC[0],
                           wszNdncDesc);
        
        if(dwRet){
            RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                             "ldap_add_ext_sW", dwRet, 
                             GetLdapErrEx((pLocalLdap) ? pLocalLdap : gldapDS,
                                          dwRet) );
        }

    } __finally {
        // Clean up and return.
        if(pLocalLdap){ 
            ldap_unbind(pLocalLdap); 
            pLocalLdap = NULL; 
        }
    }

    if(FAILED (hr)){
        return(hr);
    }       

    return(S_OK);
}

HRESULT
DomDeleteNDNC(
    CArgs   *pArgs
    )
{
    WCHAR *       pNDNC[2];
    HRESULT       hr  = S_OK;
    DWORD         dwRet;

    // Fetch Argument.
    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pNDNC[0])) ) {
        return(hr);
    }

    // Validate Arguments
    
    // Check NCName to make sure it looks like a domain name
    if( !CheckDnsDn(pNDNC[0]) ){
        RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
        return S_OK;
    }

    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    dwRet = RemoveNDNC(gldapDS, pNDNC[0]);

    if(dwRet){
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                         "ldap_delete_ext_sW", dwRet, GetLdapErr(dwRet));
    }

    return(hr);
}
        
HRESULT
DomAddNDNCReplica(
    CArgs   *pArgs
    )
{
    HRESULT       hr = S_OK;
    DWORD         dwRet;
    WCHAR *       pNDNC[2];
    WCHAR *       pServer[2];
    WCHAR *       wszNtdsaDn = NULL;

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pNDNC[0])) ) {
        return(hr);
    }

    if( !CheckDnsDn(pNDNC[0]) ){
        RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
        return S_OK;
    }

    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    if ( FAILED(hr = pArgs->GetString(1, (const WCHAR **) &pServer[0])) ||
         (0 == _wcsicmp(pServer[0], L"null")) ) {
        hr = S_OK;

        dwRet = GetRootAttr(gldapDS, L"dsServiceName", &wszNtdsaDn);
        if(dwRet){
            RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LDAP", dwRet, 
                             GetLdapErr(dwRet));
            return(S_OK);
        }

    } else {
        dwRet = GetServerNtdsaDnFromServerDns(gldapDS,
                                              pServer[0],
                                              &wszNtdsaDn);
        switch(dwRet){
        case LDAP_SUCCESS:
            // continue on.
            break;
        case LDAP_MORE_RESULTS_TO_RETURN:
            RESOURCE_PRINT1 ( IDS_DM_MGMT_NDNC_SERVER_DUPLICATES, pServer[0]);
            return(S_OK);
        case LDAP_NO_SUCH_OBJECT:
            RESOURCE_PRINT1 ( IDS_DM_MGMT_NDNC_SERVER_COULDNT_FIND, pServer[0]);
            return(S_OK);
        default:
            if(dwRet){
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                                 "LDAP", dwRet, GetLdapErr(dwRet));
            }
            return(S_OK);
        }
    }

    assert(wszNtdsaDn);

    // Last value is TRUE for add, FALSE for remove
    dwRet = ModifyNDNCReplicaSet(gldapDS, pNDNC[0], wszNtdsaDn, TRUE);

    if(dwRet){
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                         "LDAP", dwRet, GetLdapErr(dwRet));
    }

    if(wszNtdsaDn){ LocalFree(wszNtdsaDn); }

    return(hr);
}
        
HRESULT
DomRemoveNDNCReplica(
    CArgs   *pArgs
    )
{
    HRESULT       hr = S_OK;
    DWORD         dwRet;
    WCHAR *       pNDNC[2];
    WCHAR *       pServer[2];
    WCHAR *       wszNtdsaDn = NULL;


    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pNDNC[0])) ) {
        return(hr);
    }

    if( !CheckDnsDn(pNDNC[0]) ){
        RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
        return S_OK;
    }


    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    if ( FAILED(hr = pArgs->GetString(1, (const WCHAR **) &pServer[0])) ||
         (0 == _wcsicmp(pServer[0], L"null")) ) {
        hr = S_OK;

        dwRet = GetRootAttr(gldapDS, L"dsServiceName", &wszNtdsaDn);
        if(dwRet){
            RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LDAP", dwRet, 
                             GetLdapErr(dwRet));
            return(S_OK);
        }

    } else {
        dwRet = GetServerNtdsaDnFromServerDns(gldapDS,
                                              pServer[0],
                                              &wszNtdsaDn);
        switch(dwRet){
        case LDAP_SUCCESS:
            // continue on.
            break;
        case LDAP_MORE_RESULTS_TO_RETURN:
            RESOURCE_PRINT1 ( IDS_DM_MGMT_NDNC_SERVER_DUPLICATES, pServer[0]);
            return(S_OK);
        case LDAP_NO_SUCH_OBJECT:
            RESOURCE_PRINT1 ( IDS_DM_MGMT_NDNC_SERVER_COULDNT_FIND, pServer[0]);
            return(S_OK);
        default:
            if(dwRet){
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                                 "LDAP", dwRet, GetLdapErr(dwRet));
            }
            return(S_OK);
        }
    }

    assert(wszNtdsaDn);

    // Last value if TRUE for add, FALSE for remove
    dwRet = ModifyNDNCReplicaSet(gldapDS, pNDNC[0], wszNtdsaDn, FALSE);

    if(dwRet){
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                         "LDAP", dwRet, GetLdapErr(dwRet));
    }
        
    if(wszNtdsaDn){ LocalFree(wszNtdsaDn); }
    
    return(hr);
}
        
HRESULT
DomSetNDNCRefDom(
    CArgs   *pArgs
    )
{   
    HRESULT       hr = S_OK;
    DWORD         dwRet;
    WCHAR *       pNDNC[2];
    WCHAR *       pRefDom[2];

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &pNDNC[0])) ) {
        return(hr);
    }

    if( !CheckDnsDn(pNDNC[0]) ){
        RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
        return S_OK;
    }

    if ( FAILED(hr = pArgs->GetString(1, (const WCHAR **) &pRefDom[0])) ) {
        return(hr);
    }

    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }
    
    dwRet = SetNDNCSDReferenceDomain(gldapDS, pNDNC[0], pRefDom[0]);

    if(dwRet){
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                         "ldap_modify_ext_sW", dwRet, GetLdapErr(dwRet));
    }

    return(hr);
}
        
HRESULT
DomSetNCReplDelays(
    CArgs   *pArgs
    )
{   
    HRESULT       hr = S_OK;
    DWORD         dwRet;
    int           iFirstDelay;
    int           iSecondDelay;
    WCHAR *       ppNC[2];
    LDAP *        ldapDomainNamingFSMO;

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &ppNC[0])) ) {
        return(hr);
    }

    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    if( FAILED(hr = pArgs->GetInt(1, &iFirstDelay)) ){
        return(hr);
    }
    
    if( FAILED(hr = pArgs->GetInt(2, &iSecondDelay)) ){
        return(hr);
    }

    dwRet = SetNCReplicationDelays(gldapDS, 
                                   ppNC[0],
                                   iFirstDelay, 
                                   iSecondDelay);

    if(dwRet){
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LDAP", dwRet, GetLdapErr(dwRet));
    }

    return(S_OK);
}

HRESULT
DomListNDNCReplicas(
    CArgs   *pArgs
    )
{
    HRESULT          hr = S_OK;
    WCHAR *          ppNDNC[2];
    ULONG            ulRet;
    WCHAR *          wszCrossRefDn = NULL;
    WCHAR *          pwszAttrFilterNC[2];
    WCHAR *          pwszAttrFilterCR[2];
    WCHAR **         pwszDcsFromCR = NULL;
    WCHAR **         pwszDcsFromNC = NULL;
    LDAPMessage *    pldmResultsCR = NULL;
    LDAPMessage *    pldmResultsNC = NULL;
    LDAPMessage *    pldmEntry = NULL;
    ULONG            i, j;
    WCHAR *          pwszEmpty [] = { NULL };
    BOOL             fInstantiated;
    BOOL             fSomeUnInstantiated = FALSE;
    BOOL             fUnableToDetermineInstantiated = FALSE;
    PVOID            pvReferrals = (VOID *) TRUE;
    LDAP *           hld = NULL;
    WCHAR *          wszDomainNamingFSMO = NULL;


    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &ppNDNC[0])) ) {
        return(hr);
    }

    if( !CheckDnsDn(ppNDNC[0]) ){
        RESOURCE_PRINT (IDS_DM_MGMT_BAD_RDN);
        return S_OK;
    }

    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }
    

    __try {


        //
        // We should always read the list of replicas off the Domain Naming 
        // FSMO, because that server is the authoritative source on which
        // DCs are replicas of a given NDNC.
        //
    
        ulRet = GetDomainNamingDns(gldapDS, &wszDomainNamingFSMO);
    
        if(ulRet || wszDomainNamingFSMO == NULL){
            assert(ulRet);
            RESOURCE_PRINT(IDS_GET_DOMAIN_NAMING_FSMO_ERROR);
            RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                             "LDAP", ulRet, GetLdapErr(ulRet));
            __leave;
        }
        assert(wszDomainNamingFSMO);
    
        hld = GetNdncLdapBinding(wszDomainNamingFSMO, &ulRet, TRUE, gpCreds);
        if(ulRet || hld == NULL){
            assert(ulRet);
            RESOURCE_PRINT(IDS_BIND_DOMAIN_NAMING_FSMO_ERROR);
            RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, 
                             "LDAP", ulRet, GetLdapErr(ulRet));
            __leave;
        }


        // Turn on referrals.
        ulRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
        if(ulRet != LDAP_SUCCESS){
            // We might be OK, so go on ... __leave;
        }

        //
        //  First get all the replicas the cross-ref thinks there are.
        //

        // Get the Cross-Ref DN.
        ulRet = GetCrossRefDNFromNCDN( hld, ppNDNC[0], &wszCrossRefDn);
        if(ulRet){
            __leave;
        }
        assert(wszCrossRefDn);
        
        // Fill in the Attr Filter.
        pwszAttrFilterCR[0] = L"mSDS-NC-Replica-Locations";
        pwszAttrFilterCR[1] = NULL;

        ulRet = ldap_search_sW(hld,
                               wszCrossRefDn,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilterCR,
                               0,
                               &pldmResultsCR);
        if(ulRet == LDAP_SUCCESS){
            pldmEntry = ldap_first_entry(hld, pldmResultsCR);
            if(pldmEntry){
                pwszDcsFromCR = ldap_get_valuesW(hld, pldmEntry, 
                                                 L"mSDS-NC-Replica-Locations");

                if(pwszDcsFromCR){
                    // This is the normal successful case.
                } else {
                    pwszDcsFromCR = pwszEmpty;
                }
            } else {
                pwszDcsFromCR = pwszEmpty;
            }
        } else {
            pwszDcsFromCR = pwszEmpty;
        }
        assert(pwszDcsFromCR);

        // 
        //  Then get all the replicas the NC head thinks there are.
        //
               
        pwszAttrFilterNC[0] = L"masteredBy";
        pwszAttrFilterNC[0] = NULL;

        ulRet = ldap_search_sW(hld,
                               ppNDNC[0],
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilterNC,
                               0,
                               &pldmResultsNC);
        if(ulRet == LDAP_SUCCESS){
            pldmEntry = ldap_first_entry(hld, pldmResultsNC);
            if(pldmEntry){
                pwszDcsFromNC = ldap_get_valuesW(hld, pldmEntry, 
                                                 L"masteredBy");

                if(pwszDcsFromCR){
                    // This is the normal successful case.
                } else {
                    pwszDcsFromNC = pwszEmpty;
                }
            } else {
                pwszDcsFromNC = pwszEmpty;
            }
        } else {
            // In the case of an error, we can't pretend the list is empty.
            fUnableToDetermineInstantiated = TRUE;
            pwszDcsFromNC = pwszEmpty;
        }
        assert(pwszDcsFromNC);

        //
        //  Now ready to get giggy with it!! Oh yeah!
        //

        RESOURCE_PRINT1 (IDS_DM_MGMT_NDNC_LIST_HEADER, ppNDNC[0]);

        for(i = 0; pwszDcsFromCR[i] != NULL; i++){
            fInstantiated = FALSE;
            for(j = 0; pwszDcsFromNC[j] != NULL; j++){
                if(0 == _wcsicmp(pwszDcsFromCR[i], pwszDcsFromNC[j])){
                    // We've got an instantiated NC.
                    fInstantiated = TRUE;
                }
            }
            
            // The "*" indicates that we determined that the NC is
            // currently uninstantiated on this paticular replica.
            // If we were unable to determine the instantiated -
            // uninstantiated state of a replica we leave the * off
            // and comment about it later in 
            //   IDS_DM_MGMT_NDNC_LIST_HEADER_NOTE
            wprintf(L"\t%ws%ws\n", 
                    pwszDcsFromCR[i], 
                    (!fUnableToDetermineInstantiated || fInstantiated)? L" ": L" *");

            if(!fInstantiated){
                fSomeUnInstantiated = TRUE;
            }
        }
        if(i == 0){
            RESOURCE_PRINT (IDS_DM_MGMT_NDNC_LIST_NO_REPLICAS);
        } else if (fUnableToDetermineInstantiated){
            RESOURCE_PRINT (IDS_DM_MGMT_NDNC_LIST_FOOTER_2);
        } else if (fSomeUnInstantiated) {
            RESOURCE_PRINT (IDS_DM_MGMT_NDNC_LIST_FOOTER);
        }

    } __finally {

        if(pldmResultsCR != NULL){ ldap_msgfree(pldmResultsCR); }
        if(pldmResultsNC != NULL){ ldap_msgfree(pldmResultsNC); }
        if(pwszDcsFromCR != NULL && pwszDcsFromCR != pwszEmpty){ 
            ldap_value_freeW(pwszDcsFromCR); 
        }
        if(pwszDcsFromNC != NULL && pwszDcsFromNC != pwszEmpty){
            ldap_value_freeW(pwszDcsFromNC);
        }
        if(wszCrossRefDn != NULL){ LocalFree(wszCrossRefDn); }
        pvReferrals = (VOID *) FALSE; 
        ulRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
        if(hld != NULL) { ldap_unbind(hld); }
        if(wszDomainNamingFSMO != NULL) { LocalFree(wszDomainNamingFSMO); }

    }

    return(hr);
}
        
HRESULT
DomListNDNCInfo(
    CArgs   *pArgs
    )
{
    HRESULT            hr = S_OK;
    WCHAR *            ppNDNC[2];
    ULONG              ulRet;
    WCHAR *            wszCrossRefDn = NULL;
    BOOL               fInfoPrinted = FALSE;
    WCHAR *            pwszAttrFilter[3];
    WCHAR **           pwszTempAttr = NULL;
    LDAPMessage *      pldmResults = NULL;
    LDAPMessage *      pldmEntry = NULL;
    PVOID              pvReferrals = (VOID *) TRUE;

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **) &ppNDNC[0])) ) {
        return(hr);
    }

    if(!gldapDS){
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }
    
    __try {
    
        ulRet = ldap_set_option(gldapDS, LDAP_OPT_REFERRALS, &pvReferrals);
        if(ulRet){
            // We'll still probably be OK, so lets give it a go __leave;
        }

        //
        // Get and print the security descriptor reference domain.
        //

        pwszAttrFilter[0] = L"msDS-Security-Descriptor-Reference-Domain";
        pwszAttrFilter[1] = NULL;

        ulRet = ldap_search_sW(gldapDS,
                               ppNDNC[0],
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(ulRet == LDAP_SUCCESS){
            pldmEntry = ldap_first_entry(gldapDS, pldmResults);
            if(pldmEntry){

                pwszTempAttr = ldap_get_valuesW(gldapDS, pldmEntry, 
                                   L"msDS-Security-Descriptor-Reference-Domain");

                if(pwszTempAttr){
                    RESOURCE_PRINT1 (IDS_DM_MGMT_NDNC_SD_REF_DOM, pwszTempAttr[0]);
                    fInfoPrinted = TRUE;
                    ldap_value_freeW(pwszTempAttr);
                    pwszTempAttr = NULL;
                }
            }
        }
        
        if(pldmResults){
            ldap_msgfree(pldmResults);
            pldmResults = NULL;
        }

        // Get the Cross-Ref DN.
        ulRet = GetCrossRefDNFromNCDN( gldapDS, ppNDNC[0], &wszCrossRefDn);
        if(ulRet){
            __leave;
        }
        assert(wszCrossRefDn);

        //
        // Get and print the replication delays.
        //

        // Fill in the Attr Filter.
        pwszAttrFilter[0] = L"msDS-Replication-Notify-First-DSA-Delay";
        pwszAttrFilter[1] = L"msDS-Replication-Notify-Subsequent-DSA-Delay";
        pwszAttrFilter[2] = NULL;

        ulRet = ldap_search_sW(gldapDS,
                               wszCrossRefDn,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(ulRet == LDAP_SUCCESS){
            pldmEntry = ldap_first_entry(gldapDS, pldmResults);
            if(pldmEntry){

                pwszTempAttr = ldap_get_valuesW(gldapDS, pldmEntry, 
                                   L"msDS-Replication-Notify-First-DSA-Delay");

                if(pwszTempAttr){    
                    RESOURCE_PRINT1 (IDS_DM_MGMT_NC_REPL_DELAY_1, pwszTempAttr[0]);
                    fInfoPrinted = TRUE;
                    ldap_value_freeW(pwszTempAttr);
                    pwszTempAttr = NULL;
                }

                pwszTempAttr = ldap_get_valuesW(gldapDS, pldmEntry, 
                                   L"msDS-Replication-Notify-Subsequent-DSA-Delay");

                if(pwszTempAttr){
                    RESOURCE_PRINT1 (IDS_DM_MGMT_NC_REPL_DELAY_2, pwszTempAttr[0]);
                    fInfoPrinted = TRUE;
                    ldap_value_freeW(pwszTempAttr);
                    pwszTempAttr = NULL;
                }
            }
        }

        if(pldmResults){
            ldap_msgfree(pldmResults);
            pldmResults = NULL;
        }

    } __finally {

        if(wszCrossRefDn) { LocalFree(wszCrossRefDn); }
        if(pldmResults){ ldap_msgfree(pldmResults); }
        if(pwszTempAttr) { ldap_value_freeW(pwszTempAttr); }
        pvReferrals = (VOID *) FALSE; 
        ulRet = ldap_set_option(gldapDS, LDAP_OPT_REFERRALS, &pvReferrals);

    }

    if(!fInfoPrinted){
        //Print something so we don't leave the user hanging and wondering.
        RESOURCE_PRINT(IDS_DM_MGMT_NC_NO_INFO);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\ditlayer.c ===
/*++

copyright (c) 1998  Microsoft Corporation

Module Name:

    ditlayer.c

Abstract:

    This module contains the definition of functions for examining and
    modifying the DIT database of the current machine.

Author:

    Kevin Zatloukal (t-KevinZ) 05-08-98

Revision History:

    05-08-98 t-KevinZ
        Created.

--*/


#include <NTDSpch.h>
#pragma hdrstop

#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dbopen.h>
#include <dsconfig.h>

#include <limits.h>
#include <drs.h>
#include <objids.h>
#include <dsutil.h>
#include <ntdsbsrv.h>
#include <ntdsbcli.h>
#include <usn.h>
#include "parsedn.h"
#include "ditlayer.h"
#include <winldap.h>
#include "utilc.h"
#include "scheck.h"

#include "reshdl.h"
#include "resource.h"

#ifndef OPTIONAL
#define OPTIONAL
#endif


// This functions is called to report errors to the client.  It is
// set by the DitSetErrorPrintFunction function below.

PRINT_FUNC_RES gPrintError = &printfRes;

#define DIT_ERROR_PRINT (*gPrintError)

HRESULT
GetRegString(
    IN CHAR *KeyName,
    OUT CHAR **OutputString,
    IN BOOL Optional
    );

HRESULT
GetRegDword(
    IN CHAR *KeyName,
    OUT DWORD *OutputDword,
    IN BOOL Optional
    );


HRESULT
DitOpenDatabase(
    IN DB_STATE **DbState
    )
/*++

Routine Description:

    This function initializes the Jet engine, begins a new session, and
    opens the DIT database.

Arguments:

    DbState - Returns the state of the opened DIT database.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - The given pointer was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    DWORD error;

    DWORD size;
    JET_COLUMNBASE dsaColumnInfo;
    JET_COLUMNBASE usnColumnInfo;
    ULONG actualSize;
    PCHAR p;

    if ( DbState == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }


    result = DitAlloc(DbState, sizeof(DB_STATE));
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    (*DbState)->instanceSet = FALSE;
    (*DbState)->sessionIdSet = FALSE;
    (*DbState)->databaseIdSet = FALSE;
    (*DbState)->hiddenTableIdSet = FALSE;

    SetJetParameters (&(*DbState)->instance);

    error = ErrRecoverAfterRestore(TEXT(DSA_CONFIG_ROOT),
                                   g_szBackupAnnotation,
                                   TRUE);
    if ( error != ERROR_SUCCESS ) {
        //"Failed to recover database from external backup (Windows Error %x).\n",
        DIT_ERROR_PRINT (IDS_DIT_RECOVER_ERR, error, GetW32Err(error));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // OpenDatabase
    //

    jetResult = DBInitializeJetDatabase(&(*DbState)->instance,
                                        &(*DbState)->sessionId,
                                        &(*DbState)->databaseId,
                                        NULL,
                                        FALSE);
    if ( jetResult != JET_errSuccess ) {
        //"Could not initialize the Jet engine: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETINIT_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }
    (*DbState)->instanceSet = TRUE;
    (*DbState)->sessionIdSet = TRUE;
    (*DbState)->databaseIdSet = TRUE;


    // read the relevant information out of the hidden table

    jetResult = JetOpenTable((*DbState)->sessionId,
                             (*DbState)->databaseId,
                             SZHIDDENTABLE,
                             NULL,
                             0,
                             JET_bitTableUpdatable,
                             &(*DbState)->hiddenTableId);
    if ( jetResult != JET_errSuccess ) {
        //"Could not open table hidden table: %ws.\n"
        DIT_ERROR_PRINT(IDS_DIT_OPENHIDENTBL_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }
    (*DbState)->hiddenTableIdSet = TRUE;

    jetResult = JetMove((*DbState)->sessionId,
                        (*DbState)->hiddenTableId,
                        JET_MoveFirst,
                        0);
    if ( jetResult != JET_errSuccess ) {
        //"Could not move in hidden table: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MOVEHIDENTBL_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetGetColumnInfo((*DbState)->sessionId,
                                 (*DbState)->databaseId,
                                 SZHIDDENTABLE,
                                 SZDSA,
                                 &dsaColumnInfo,
                                 sizeof(dsaColumnInfo),
                                 4);
    if ( jetResult != JET_errSuccess ) {
        //"Could not get info for DSA column in hidden table: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_GETDSAINFO_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetRetrieveColumn((*DbState)->sessionId,
                                  (*DbState)->hiddenTableId,
                                  dsaColumnInfo.columnid,
                                  &(*DbState)->dsaDnt,
                                  sizeof((*DbState)->dsaDnt),
                                  &actualSize,
                                  0,
                                  NULL);
    if ( jetResult != JET_errSuccess ) {
        //"Could not retrieve DSA column in hidden table: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_GETDSACOL_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetGetColumnInfo((*DbState)->sessionId,
                                 (*DbState)->databaseId,
                                 SZHIDDENTABLE,
                                 SZUSN,
                                 &usnColumnInfo,
                                 sizeof(usnColumnInfo),
                                 4);
    if ( jetResult != JET_errSuccess ) {
        //"Could not get info for USN column in hidden table: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_GETUSNCOL_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }
    (*DbState)->usnColumnId = usnColumnInfo.columnid;

    jetResult = JetRetrieveColumn((*DbState)->sessionId,
                                  (*DbState)->hiddenTableId,
                                  (*DbState)->usnColumnId,
                                  &(*DbState)->nextAvailableUsn,
                                  sizeof((*DbState)->nextAvailableUsn),
                                  &actualSize,
                                  0,
                                  NULL);
    if ( jetResult != JET_errSuccess ) {
        //"Could not retrieve USN column in hidden table: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_RETRUSNCOL_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    // we will allocate some USNs from the database on the first call to
    // DitGetNewUsn
    (*DbState)->highestCommittedUsn = (*DbState)->nextAvailableUsn;


CleanUp:

    return returnValue;

} // DitOpenDatabase



HRESULT
DitCloseDatabase(
    IN OUT DB_STATE **DbState
    )
/*++

Routine Description:

    This function closes the DIT database, ends the session, and frees the
    DitFileName array.

    Note:  this function should be called after both a successful and
    unsuccessful call to OpenDitDatabase.  This function frees all of the
    resources that it opened.

Arguments:

    DbState - Supplies the state of the opened DIT database.

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - There was nothing to delete.
    E_INVALIDARG - The given pointer was NULL.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;


    if ( DbState == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    if ( *DbState == NULL ) {
        returnValue = S_FALSE;
        goto CleanUp;
    }

    if ( ((*DbState)->sessionIdSet) &&
         ((*DbState)->hiddenTableIdSet) ) {

        jetResult = JetCloseTable((*DbState)->sessionId,
                                  (*DbState)->hiddenTableId);
        if ( jetResult != JET_errSuccess ) {
            //"Could not close hidden table: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_CLOSEHIDENTBL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
        }

        (*DbState)->hiddenTableIdSet = FALSE;
    }

    if ((*DbState)->sessionId != 0) {
        if((*DbState)->databaseId) {
            if ((jetResult = JetCloseDatabase((*DbState)->sessionId, (*DbState)->databaseId, 0)) != JET_errSuccess) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_WRN, "JetCloseDatabase", GetJetErrString(jetResult));
            }
            (*DbState)->databaseId = 0;
        }

        if ((jetResult = JetEndSession((*DbState)->sessionId, JET_bitForceSessionClosed)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_WRN, "JetEndSession", GetJetErrString(jetResult));
        }
        (*DbState)->sessionId = 0;

        JetTerm((*DbState)->instance);
        (*DbState)->instance = 0;
    }

    (*DbState)->databaseIdSet = FALSE;
    (*DbState)->sessionIdSet = FALSE;
    (*DbState)->instanceSet = FALSE;

    DitFree(*DbState);
    *DbState = NULL;

CleanUp:

    return returnValue;

} // DitCloseDatabase



HRESULT
DitOpenTable(
    IN DB_STATE *DbState,
    IN CHAR *TableName,
    IN CHAR *InitialIndexName,
    OUT TABLE_STATE **TableState
    )
/*++

Routine Description:

    Opens the given table in the DIT database, sets the index to the given one
    and moves to the first record with that index.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableName - Supplies the name of the table to open.
    TableState - Returns the state of the opened DIT table.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - The given pointer was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    DWORD size;


    if ( (DbState == NULL) ||
         (TableName == NULL) ||
         (TableState == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitAlloc(TableState, sizeof(DB_STATE));
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    (*TableState)->tableIdSet = FALSE;
    (*TableState)->tableName = NULL;
    (*TableState)->indexName = NULL;

    result = DitAlloc(&(*TableState)->tableName, strlen(TableName) + 1);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    strcpy((*TableState)->tableName, TableName);

    jetResult = JetOpenTable(DbState->sessionId,
                             DbState->databaseId,
                             (*TableState)->tableName,
                             NULL,
                             0,
                             JET_bitTableUpdatable,
                             &(*TableState)->tableId);
    if ( jetResult != JET_errSuccess ) {
        //"Could not open table \"%s\": %ws.\n"
        DIT_ERROR_PRINT (IDS_JETOPENTABLE_ERR,
                       (*TableState)->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }
    (*TableState)->tableIdSet = TRUE;

    if ( InitialIndexName != NULL ) {
        result = DitSetIndex(DbState, *TableState, InitialIndexName, TRUE);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }
    }

CleanUp:

    return returnValue;

} // DitOpenTable



HRESULT
DitCloseTable(
    IN DB_STATE *DbState,
    IN OUT TABLE_STATE **TableState
    )
/*++

Routine Description:

    Closes a table in the opened DIT database.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Returns the state of the opened DIT table.

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - There was nothing to delete.
    E_INVALIDARG - The given pointer was NULL.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;


    if ( (DbState == NULL) ||
         (TableState == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    if ( *TableState == NULL ) {
        returnValue = S_FALSE;
        goto CleanUp;
    }

    if ( (*TableState)->indexName != NULL ) {

        DitFree((*TableState)->indexName);

        (*TableState)->indexName = NULL;

    }

    if ( ((*TableState)->tableName != NULL) &&
         ((*TableState)->tableIdSet) ) {

        jetResult = JetCloseTable(DbState->sessionId, (*TableState)->tableId);
        if ( jetResult != JET_errSuccess ) {
            //"Could not close table \"%s\": %ws.\n"
            DIT_ERROR_PRINT (IDS_JETCLOSETABLE_ERR,
                           (*TableState)->tableName,
                           GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
        }

    }

    if ( (*TableState)->tableName != NULL ) {

        DitFree((*TableState)->tableName);

        (*TableState)->tableName = NULL;

    }

    DitFree(*TableState);
    *TableState = NULL;


CleanUp:

    return returnValue;

} // DitCloseTable



HRESULT
DitSetIndex(
    IN DB_STATE *DbState,
    OUT TABLE_STATE *TableState,
    IN CHAR *IndexName,
    IN BOOL MoveFirst
    )
/*++

Routine Description:

    Sets the current index in the open DIT table.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Returns the state of the opened DIT table.
    IndexName - Supplies the name of the index to use.
    MoveFirst - Supplies whether we should stay on the same record or move to
        the first record.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - The given pointer was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    JET_GRBIT grbit;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (IndexName == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    if ( TableState->indexName != NULL ) {

        if ( strcmp(TableState->indexName, IndexName) == 0 ) {

            // No need to do any work: we're already set to the index
            // requested.
            goto CleanUp;

        } else {

            DitFree(TableState->indexName);

        }

    }

    result = DitAlloc(&TableState->indexName, strlen(IndexName) + 1);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    strcpy(TableState->indexName, IndexName);

    if ( MoveFirst ) {
        grbit = JET_bitMoveFirst;
    } else {
        grbit = JET_bitNoMove;
    }

    jetResult = JetSetCurrentIndex2(DbState->sessionId,
                                    TableState->tableId,
                                    TableState->indexName,
                                    grbit);
    if ( jetResult != JET_errSuccess ) {
        //"Could not set current index to \"%s\": %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSETINDEX_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }


CleanUp:

    return returnValue;

} // DitSetIndex



HRESULT
DitIndexRecordCount(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    OUT DWORD *RecordCount
    )
/*++

Routine Description:

    This function returns the total number of records in the current index.

Arguments:

    RecordCount - Returns the number of records in the currentIndex.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - The given pointer was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (RecordCount == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    jetResult = JetIndexRecordCount(DbState->sessionId,
                                    TableState->tableId,
                                    RecordCount,
                                    ULONG_MAX);
    if ( jetResult != JET_errSuccess ) {
        //"Could not count the records in the database: %S.\n"
        DIT_ERROR_PRINT (IDS_JETCOUNTREC_ERR, GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }


CleanUp:

    return returnValue;

} // DitGetRecordCount



HRESULT
DitSeekToDn(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN const WCHAR *DN
    )
/*++

Routine Description:

    This function parses the given DN and moves the cursor to point to the
    object that it refers to (if it exists).

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    DN - Supplies the distinguished name of the object to seek to.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_INVALIDARG - The given DN is not parseable or does not refer to an actual
       object in the DS.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    unsigned failed;

    unsigned i;
    BOOL isRoot;
    unsigned partCount;
    unsigned currentLength;

    DSNAME* pDn = NULL;
    DWORD   cbDn;
    unsigned charsCopied;
    const WCHAR *key;
    const WCHAR *quotedVal;
    unsigned keyLen;
    unsigned quotedValLen;

    ATTRTYP attrType;
    WCHAR value[MAX_RDN_SIZE];
    DWORD currentDnt;

    currentLength = wcslen(DN);
    cbDn = DSNameSizeFromLen(currentLength);

    result = DitAlloc(&pDn, cbDn);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSetIndex(DbState, TableState, SZDNTINDEX, TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToDnt(DbState, TableState, ROOTTAG);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    currentDnt = ROOTTAG;

    // there is one case that the parsedn stuff doesn't handle, which is when
    // the given string is all whitespace.  that should also denote the root.
    isRoot = TRUE;
    for ( i = 0; i < currentLength; i++ ) {
        if ( !iswspace(DN[i]) ) {
            isRoot = FALSE;
            break;
        }
    }

    // if the given DN referred to the root node, then quit:
    // we're already at the root node.
    if ( isRoot ) {
        goto CleanUp;
    }

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    pDn->structLen = cbDn;
    pDn->NameLen = currentLength;
    wcscpy((WCHAR*)&pDn->StringName, DN);
    pDn->StringName[pDn->NameLen] = L'\0';

    failed = CountNameParts(pDn, &partCount);
    if ( failed ) {
        //"Could not parse the given DN.\n"
        DIT_ERROR_PRINT(IDS_DIT_PARSEDN_ERR);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    for ( i = 0; i < partCount; i++ ) {

        failed = GetTopNameComponent(pDn->StringName,
                                     currentLength,
                                     &key,
                                     &keyLen,
                                     &quotedVal,
                                     &quotedValLen);
        if ( failed ) {
            //"Could not parse the given DN.\n"
            DIT_ERROR_PRINT(IDS_DIT_PARSEDN_ERR);
            returnValue = E_INVALIDARG;
            goto CleanUp;
        }

        currentLength = (unsigned)(key - pDn->StringName);

        attrType = KeyToAttrTypeLame((WCHAR*)key, keyLen);
        if ( attrType == 0 ) {
            //"Invalid key \"%.*ws\" found in DN.\n"
            DIT_ERROR_PRINT (IDS_DIT_INVALIDKEY_DN_ERR, keyLen, key);
            returnValue = E_INVALIDARG;
            goto CleanUp;
        }

        charsCopied = UnquoteRDNValue(quotedVal, quotedValLen, value);
        if ( charsCopied == 0 ) {
            //"Could not parse the given DN.\n"
            DIT_ERROR_PRINT(IDS_DIT_PARSEDN_ERR);
            returnValue = E_INVALIDARG;
            goto CleanUp;
        }

        value[charsCopied] = L'\0';

        result = DitSeekToChild(DbState,
                                TableState,
                                currentDnt,
                                attrType,
                                value);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        } else if ( result == S_FALSE ) {
            //"Could not find the object with the given DN: "
            //"failed on component \"%.*ws=%.*ws\".\n"
            DIT_ERROR_PRINT (IDS_DIT_FIND_OBJ_ERR,
                           keyLen,
                           key,
                           quotedValLen,
                           quotedVal);
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        result = DitGetColumnByName(DbState,
                                    TableState,
                                    SZDNT,
                                    &currentDnt,
                                    sizeof(currentDnt),
                                    NULL);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

    }


CleanUp:

    if ( pDn != NULL ) {
        DitFree(pDn);
    }

    return returnValue;

} // DitSeekToDn



HRESULT
DitSeekToChild(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD Dnt,
    IN ATTRTYP RdnType,
    IN CONST WCHAR *Rdn
    )
/*++

Routine Description:

    This function seeks to a child of the object with the given DNT.  The child
    it seeks to is identified by the RdnType and Rdn.

    Note: this function assumes that the current index is SZPDNTINDEX.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    Dnt - Supplies the DNT of the parent (the PDNT of the child).
    RdnType - Supplies the RDN-Type of the child.
    Rdn - Supplies the RDN of the child.

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The specified object was not found.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;
    DWORD   result, trialtype, cbActual;
    BOOL    bTruncated;

    jetResult = JetMakeKey(DbState->sessionId,
                           TableState->tableId,
                           &Dnt,
                           sizeof(Dnt),
                           JET_bitNewKey);
    if ( jetResult !=  JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetMakeKey(DbState->sessionId,
                           TableState->tableId,
                           Rdn,
                           sizeof(WCHAR) * wcslen(Rdn),
                           0);
    if ( jetResult !=  JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }


    // Was our key truncated?
    jetResult = JetRetrieveKey(DbState->sessionId,
                               TableState->tableId,
                               NULL,
                               0,
                               &cbActual,
                               0);

    if (( jetResult !=  JET_errSuccess )  &&
        ( jetResult !=  JET_wrnBufferTruncated)) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                         TableState->indexName,
                         GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    bTruncated = (cbActual >= JET_cbKeyMost);

    jetResult = JetSeek(DbState->sessionId,
                        TableState->tableId,
                        JET_bitSeekEQ);
    if ( jetResult == JET_errRecordNotFound ) {

        returnValue = S_FALSE;

    } else if ( jetResult != JET_errSuccess ) {

        //"Could not seek in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSEEK_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }
    else {
        if(bTruncated) {
            // Our key was truncated, so we may have found something that
            // started off with the same characters as the value we're looking
            // for, but differs after many characters.  Validate the actual
            // value.
            WCHAR currentRdn[MAX_RDN_SIZE+1];
            DWORD currentRdnLength;

            result = DitGetColumnByName(DbState,
                                        TableState,
                                        SZRDNATT,
                                        currentRdn,
                                        sizeof(currentRdn),
                                        &currentRdnLength);
            if ( FAILED(result) || (result == S_FALSE) ) {
                returnValue = result;
                goto CleanUp;
            }
            currentRdnLength /= sizeof(WCHAR);
            currentRdn[currentRdnLength] = L'\0';

            if(2 != CompareStringW(DS_DEFAULT_LOCALE,
                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                   Rdn,
                                   -1,
                                   currentRdn,
                                   currentRdnLength)) {
                // Nope, this is not a match.  And, since our index is unique, I
                // know that this is the only object in the index that starts
                // out this way.  Therefore, we have no match for the value
                // we've been asked to find.
                returnValue = S_FALSE;
                goto CleanUp;
            }
        }

        // OK, we found a real object with the correct RDN value and PDNT.
        // However, we haven't yet verified the rdn type. Do so now.
        result = DitGetColumnByName(DbState,
                                    TableState,
                                    SZRDNTYP,
                                    &trialtype,
                                    sizeof(trialtype),
                                    NULL);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        if(RdnType != trialtype) {
            // Nope.  We found an object with the correct PDNT-RDN, but the
            // types were incorrect.  Return an error.
            returnValue = S_FALSE;
        }
    }

CleanUp:

    return returnValue;

} // DitSeekToChild



HRESULT
DitSeekToFirstChild(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD Dnt
    )
/*++

Routine Description:

    This function seeks to the first child of the object with the given DNT.

    Note: this function assumes that the current index is SZPDNTINDEX.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    Dnt - Supplies the DNT of the parent (the PDNT of the child).

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The specified object was not found.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;


    jetResult = JetMakeKey(DbState->sessionId,
                           TableState->tableId,
                           &Dnt,
                           sizeof(Dnt),
                           JET_bitNewKey);
    if ( jetResult !=  JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetSeek(DbState->sessionId,
                        TableState->tableId,
                        JET_bitSeekGE);
    if ( jetResult == JET_errRecordNotFound ) {

        returnValue = S_FALSE;

    } else if ( (jetResult != JET_errSuccess) &&
                (jetResult != JET_wrnSeekNotEqual) ) {

        //"Could not seek in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSEEK_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }


CleanUp:

    return returnValue;

} // DitSeekToFirstChild



HRESULT
DitSeekToDnt(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD Dnt
    )
/*++

    This function seeks to the object with the given DNT.

    Note: this function assumes that the current index is SZDNTINDEX.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    Dnt - Supplies the DNT of the object to seek to.

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The specified object was not found.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;


    jetResult = JetMakeKey(DbState->sessionId,
                           TableState->tableId,
                           &Dnt,
                           sizeof(Dnt),
                           JET_bitNewKey);
    if ( jetResult !=  JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetSeek(DbState->sessionId,
                        TableState->tableId,
                        JET_bitSeekEQ);
    if ( jetResult == JET_errRecordNotFound ) {

        returnValue = S_FALSE;

    } else if ( jetResult != JET_errSuccess ) {

        //"Could not seek in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSEEK_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }


CleanUp:

    return returnValue;


} // DitSeekToDnt

HRESULT
DitSeekToLink(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD linkDnt,
    IN DWORD linkBase
    )
/*++

    This function seeks to the object with the given DNT.

    Note: this function assumes that the current index is SZLINKALLINDEX.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    linkDnt - Supplies the DNT link object
    linkBase - The base from which to construct the key

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The specified object was not found.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;

    //
    // Make key for seek
    //
    jetResult = JetMakeKey(DbState->sessionId,
                           TableState->tableId,
                           &linkDnt,
                           sizeof(linkDnt),
                           JET_bitNewKey);
    if ( jetResult !=  JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetMakeKey(DbState->sessionId,
                           TableState->tableId,
                           &linkBase,
                           sizeof(linkBase),
                           0);
    if ( jetResult !=  JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_DIT_MAKE_KEY_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetSeek(
                    DbState->sessionId,
                    TableState->tableId,
                    JET_bitSeekGE);

    if ( jetResult == JET_wrnSeekNotEqual) {
        returnValue = S_OK;
        goto CleanUp;
    }
    if ( jetResult == JET_errRecordNotFound ) {

        returnValue = S_FALSE;

    } else if ( jetResult != JET_errSuccess ) {

        //"Could not seek in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSEEK_ERR,
                       TableState->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }

CleanUp:

    return returnValue;
} // DitSeekToLink



HRESULT
DitGetDsaDnt(
    IN DB_STATE *DbState,
    OUT DWORD *DsaDnt
    )
/*++

Routine Description:

    Finds the DNT of the DSA object and return it in DsaDnt.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    DsaDnt - Returns the DNT of the DSA object.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;


    if ( (DbState == NULL) ||
         (DsaDnt  == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    *DsaDnt = DbState->dsaDnt;


CleanUp:

    return returnValue;

} // DitGetDsaDnt



HRESULT
DitGetNewUsn(
    IN DB_STATE *DbState,
    OUT USN *NewUsn
    )
/*++

Routine Description:

    This function a new USN number and returns it.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    NewHighestUsn - Returns the new USN that was allocated.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    BOOL inTransaction = FALSE;

    TABLE_STATE *tableState = NULL;
    JET_COLUMNBASE usnColumnInfo;
    ULONG usnColumnSize;
    USN newCommittedUsn;


    if ( (DbState == NULL) ||
         (NewUsn == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    if ( !(DbState->nextAvailableUsn < DbState->highestCommittedUsn) ) {

        DbState->highestCommittedUsn =
            DbState->nextAvailableUsn + USN_DELTA_INIT;

        jetResult = JetBeginTransaction(DbState->sessionId);
        if ( jetResult != JET_errSuccess ) {
            //"Could not start a new transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETBEGINTRANS_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
        inTransaction = TRUE;

        jetResult = JetPrepareUpdate(DbState->sessionId,
                                     DbState->hiddenTableId,
                                     JET_prepReplace);
        if ( jetResult != JET_errSuccess ) {
            //"Could not prepare hidden table for update: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_PREPARE_HIDDENTBL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetSetColumn(DbState->sessionId,
                                 DbState->hiddenTableId,
                                 DbState->usnColumnId,
                                 &DbState->highestCommittedUsn,
                                 sizeof(DbState->highestCommittedUsn),
                                 0,
                                 NULL);
        if ( jetResult != JET_errSuccess ) {
            //"Could not set USN column in hidden table: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_SETUSNCOL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetUpdate(DbState->sessionId,
                              DbState->hiddenTableId,
                              NULL,
                              0,
                              0);
        if ( jetResult != JET_errSuccess ) {
            //"Could not update hidden table: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_UPDATEHIDDENTBL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetCommitTransaction(DbState->sessionId, 0);
        inTransaction = FALSE;
        if ( jetResult != JET_errSuccess ) {
            //"Failed to commit transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETCOMMITTRANSACTION_ERR, GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
            goto CleanUp;
        }

    }

    *NewUsn = DbState->nextAvailableUsn;

    DbState->nextAvailableUsn++;


CleanUp:

    // if we are still in a transaction, there must have been an error
    // somewhere along the way.

    if ( inTransaction ) {

        jetResult = JetRollback(DbState->sessionId, JET_bitRollbackAll);
        if ( jetResult != JET_errSuccess ) {
            //"Failed to rollback transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETROLLBACK_ERR, GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }

    }

    return returnValue;

} // DitGetNewUsn



HRESULT
DitPreallocateUsns(
    IN DB_STATE *DbState,
    IN DWORD NumUsns
    )
/*++

Routine Description:

    This functions assures that after this call, the client can get atleast
    NumUsns USNs before any updates to the database will need to be made.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    NumUsns - Supplies the number of USNs to preallocate.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;
    BOOL inTransaction = FALSE;

    ULONGLONG numAvailableUsns;
    ULONGLONG numNeededUsns;


    if ( DbState == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    numAvailableUsns =
        DbState->highestCommittedUsn - DbState->nextAvailableUsn;

    numNeededUsns = NumUsns - numAvailableUsns;

    if ( numNeededUsns > 0 ) {

        DbState->highestCommittedUsn += numNeededUsns;

        jetResult = JetBeginTransaction(DbState->sessionId);
        if ( jetResult != JET_errSuccess ) {
            //"Could not start a new transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETBEGINTRANS_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
        inTransaction = TRUE;

        jetResult = JetPrepareUpdate(DbState->sessionId,
                                     DbState->hiddenTableId,
                                     JET_prepReplace);
        if ( jetResult != JET_errSuccess ) {
            //"Could not prepare hidden table for update: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_PREPARE_HIDDENTBL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetSetColumn(DbState->sessionId,
                                 DbState->hiddenTableId,
                                 DbState->usnColumnId,
                                 &DbState->highestCommittedUsn,
                                 sizeof(DbState->highestCommittedUsn),
                                 0,
                                 NULL);
        if ( jetResult != JET_errSuccess ) {
            //"Could not set USN column in hidden table: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_SETUSNCOL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetUpdate(DbState->sessionId,
                              DbState->hiddenTableId,
                              NULL,
                              0,
                              0);
        if ( jetResult != JET_errSuccess ) {
            //"Could not update hidden table: %ws.\n"
            DIT_ERROR_PRINT (IDS_DIT_UPDATEHIDDENTBL_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetCommitTransaction(DbState->sessionId, 0);
        inTransaction = FALSE;
        if ( jetResult != JET_errSuccess ) {
            //"Failed to commit transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETCOMMITTRANSACTION_ERR, GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
            goto CleanUp;
        }

    }


CleanUp:

    // if we are still in a transaction, there must have been an error
    // somewhere along the way.

    if ( inTransaction ) {

        jetResult = JetRollback(DbState->sessionId, JET_bitRollbackAll);
        if ( jetResult != JET_errSuccess ) {
            //"Failed to rollback transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETROLLBACK_ERR, GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }

    }

    return returnValue;

} // DitPreallocateUsns



HRESULT
DitGetMostRecentChange(
    IN DB_STATE *DbState,
    OUT DSTIME *MostRecentChange
    )
/*++

Routine Description:

    This function searches through the database to find the most recent change
    that occured.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    MostRecentChange - Returns the DSTIME of the most recent change.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;

    TABLE_STATE *dataTable = NULL;

    const CHAR *columnNames[] = {SZDNT, SZNCDNT, SZDRATIMENAME};
    RETRIEVAL_ARRAY *retrievalArray = NULL;
    JET_RETRIEVECOLUMN *ncDntVal;
    JET_RETRIEVECOLUMN *whenChangedVal;
    JET_RETRIEVECOLUMN *dntVal;

    DWORD currentNcDnt;
    DWORD i;


    if ( (DbState == NULL) ||
         (MostRecentChange == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitOpenTable(DbState, SZDATATABLE, SZDRAUSNINDEX, &dataTable);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitCreateRetrievalArray(DbState,
                                     dataTable,
                                     columnNames,
                                     3,
                                     &retrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    dntVal = &retrievalArray->columnVals[retrievalArray->indexes[0]];
    ncDntVal = &retrievalArray->columnVals[retrievalArray->indexes[1]];
    whenChangedVal = &retrievalArray->columnVals[retrievalArray->indexes[2]];

    currentNcDnt = 0;
    *MostRecentChange = 0;

    for (;;) {

        jetResult = JetMakeKey(DbState->sessionId,
                               dataTable->tableId,
                               &currentNcDnt,
                               sizeof(currentNcDnt),
                               JET_bitNewKey);
        if ( jetResult !=  JET_errSuccess ) {
            //"Could not make key in \"%s\" index: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETMAKEKEY_ERR,
                           dataTable->indexName,
                           GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        jetResult = JetSeek(DbState->sessionId,
                            dataTable->tableId,
                            JET_bitSeekGE);
        if ( jetResult == JET_errRecordNotFound ) {

            break;

        } else if ( (jetResult != JET_errSuccess) &&
                    (jetResult != JET_wrnSeekNotEqual) ) {

            //"Could not seek in \"%s\" index: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETSEEK_ERR,
                           dataTable->indexName,
                           GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

        result = DitGetColumnValues(DbState, dataTable, retrievalArray);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        currentNcDnt = *(DWORD*)ncDntVal->pvData + 1;

        jetResult = JetMove(DbState->sessionId,
                            dataTable->tableId,
                            JET_MovePrevious,
                            0);
        if ( jetResult != JET_errSuccess ) {
            //"Could not move in \"%s\" table: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETMOVE_ERR,
                           dataTable->tableName,
                           GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        result = DitGetColumnValues(DbState, dataTable, retrievalArray);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        if ( *(DSTIME*)whenChangedVal->pvData > *MostRecentChange ) {
            *MostRecentChange = *(DSTIME*)whenChangedVal->pvData;
        }

    }

    jetResult = JetMove(DbState->sessionId,
                        dataTable->tableId,
                        JET_MoveLast,
                        0);
    if ( jetResult != JET_errSuccess ) {
        //"Could not move in \"%s\" table: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETMOVE_ERR,
                       dataTable->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    result = DitGetColumnValues(DbState, dataTable, retrievalArray);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    if ( *(DSTIME*)whenChangedVal->pvData > *MostRecentChange ) {
        *MostRecentChange = *(DSTIME*)whenChangedVal->pvData;
    }


CleanUp:

    if ( retrievalArray != NULL ) {
        result = DitDestroyRetrievalArray(&retrievalArray);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    if ( dataTable != NULL ) {
        result = DitCloseTable(DbState, &dataTable);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    return returnValue;

} // DitGetMostRecentChange



HRESULT
DitGetDatabaseGuid(
    IN DB_STATE *DbState,
    OUT GUID *DatabaseGuid
    )
/*++

Routine Description:

    This function finds the Invocation-Id of this DC and returns it.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    DatabaseGuid - Returns the Invocation-ID GUID.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;

    TABLE_STATE *dataTable = NULL;
    DWORD dsaDnt;


    if ( (DbState == NULL) ||
         (DatabaseGuid == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitGetDsaDnt(DbState, &dsaDnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitOpenTable(DbState, SZDATATABLE, SZDNTINDEX, &dataTable);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    jetResult = JetMakeKey(DbState->sessionId,
                           dataTable->tableId,
                           &dsaDnt,
                           sizeof(dsaDnt),
                           JET_bitNewKey);
    if ( jetResult != JET_errSuccess ) {
        //"Could not make key in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETMAKEKEY_ERR,
                       dataTable->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetSeek(DbState->sessionId,
                        dataTable->tableId,
                        JET_bitSeekEQ);
    if ( jetResult != JET_errSuccess ) {
        //"Could not seek in \"%s\" index: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSEEK_ERR,
                       dataTable->indexName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }

    result = DitGetColumnByName(DbState,
                                dataTable,
                                SZINVOCIDNAME,
                                DatabaseGuid,
                                sizeof(*DatabaseGuid),
                                NULL);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }


CleanUp:

    if ( dataTable != NULL ) {
        result = DitCloseTable(DbState, &dataTable);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    return returnValue;

} // DitGetDcGuid



HRESULT
DitGetSchemaDnt(
    IN DB_STATE *DbState,
    OUT DWORD *SchemaDnt
    )
/*++

Routine Description:

    This function finds the DNT of the Schema object.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    SchemaDnt - Returns the DNT of the Schema object.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;

    TABLE_STATE *dataTable = NULL;
    DWORD dsaDnt;


    result = DitGetDsaDnt(DbState, &dsaDnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitOpenTable(DbState, SZDATATABLE, SZDNTINDEX, &dataTable);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToDnt(DbState, dataTable, dsaDnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitGetColumnByName(DbState,
                                dataTable,
                                SZDMDLOCATION,
                                SchemaDnt,
                                sizeof(*SchemaDnt),
                                NULL);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }


CleanUp:

    if ( dataTable != NULL ) {
        result = DitCloseTable(DbState, &dataTable);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    return returnValue;

} // DitGetSchemaDnt



HRESULT
DitGetDntDepth(
    IN DB_STATE *DbState,
    IN DWORD Dnt,
    OUT DWORD *Depth
    )
/*++

Routine Description:

    This function finds the depth in the tree of the object with the given
    DNT.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    Dnt - Supplies the DNT of the object whose depth we wish to find.
    Depth - Returns the depth of the given object.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;

    TABLE_STATE *dataTable = NULL;
    DWORD currentDnt;


    if ( DbState == NULL ) {
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitOpenTable(DbState, SZDATATABLE, SZDNTINDEX, &dataTable);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToDnt(DbState, dataTable, Dnt);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitGetColumnByName(DbState,
                                dataTable,
                                SZDNT,
                                &currentDnt,
                                sizeof(currentDnt),
                                NULL);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    *Depth = 0;
    currentDnt = Dnt;

    while ( currentDnt != ROOTTAG ) {

        (*Depth)++;

        result = DitGetColumnByName(DbState,
                                    dataTable,
                                    SZPDNT,
                                    &currentDnt,
                                    sizeof(currentDnt),
                                    NULL);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        result = DitSeekToDnt(DbState, dataTable, currentDnt);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

    }


CleanUp:

    if ( dataTable != NULL ) {
        result = DitCloseTable(DbState, &dataTable);
        if ( FAILED(result) ) {
            if ( SUCCEEDED(returnValue) ) {
                returnValue = result;
            }
        }
    }

    return returnValue;

} // DitGetDntDepth



HRESULT
DitGetColumnByName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN CHAR *ColumnName,
    OUT VOID *OutputBuffer,
    IN DWORD OutputBufferSize,
    OUT DWORD *OutputActualSize OPTIONAL
    )
/*++

Routine Description:

    This function retrieves the value of the column whose name was given and
    stores it in the buffer supplied by OutputBuffer.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    ColumnName - Supplies the name of the column to look up.
    OutputBuffer - Returns the value of the given column.
    OutputBufferSize - Supplies the number of bytes in the given output buffer.
    OutputActualSize - If non-NULL, this is returns the number of bytes that
        were written into the OutputBuffer.

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The value written to the buffer had to be truncated.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;
    JET_COLUMNBASE columnInfo;
    DWORD actualSize;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (ColumnName == NULL) ||
         (OutputBuffer == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    if ( OutputActualSize == NULL ) {
        OutputActualSize = &actualSize;
    }

    jetResult = JetGetColumnInfo(DbState->sessionId,
                                 DbState->databaseId,
                                 TableState->tableName,
                                 ColumnName,
                                 &columnInfo,
                                 sizeof(columnInfo),
                                 4);
    if ( jetResult != JET_errSuccess ) {
        //"Could not get info for \"%s\" column in \"%s\" table: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETGETCOLUMNINFO_ERR,
                       ColumnName,
                       TableState->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetRetrieveColumn(DbState->sessionId,
                                  TableState->tableId,
                                  columnInfo.columnid,
                                  OutputBuffer,
                                  OutputBufferSize,
                                  OutputActualSize,
                                  0,
                                  NULL);
    if ( jetResult == JET_wrnBufferTruncated ) {

        returnValue = S_FALSE;

    } else if ( jetResult != JET_errSuccess ) {

        //"Could not retrieve \"%s\" column in \"%s\" table: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETRETRIEVECOLUMN_ERR,
                       ColumnName,
                       TableState->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }


CleanUp:

    return returnValue;

} // DitGetColumnByName



HRESULT
DitSetColumnByName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN CHAR *ColumnName,
    OUT VOID *InputBuffer,
    IN DWORD InputBufferSize,
    IN BOOL fTransacted
    )
/*++

Routine Description:

    This function sets the value of the column whose name was given and
    to the value in the buffer supplied by InputBuffer.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    ColumnName - Supplies the name of the column to look up.
    InputBuffer - Supplies the new value of the given column.
    InputBufferSize - Supplies the number of bytes in the given input buffer.
    fTransacted - tell us if we should open/close a transaction or if
                  caller manages the transaction

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;
    BOOL inTransaction = FALSE;
    JET_COLUMNBASE columnInfo;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (ColumnName == NULL) ||
         (InputBuffer == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    jetResult = JetGetColumnInfo(DbState->sessionId,
                                 DbState->databaseId,
                                 TableState->tableName,
                                 ColumnName,
                                 &columnInfo,
                                 sizeof(columnInfo),
                                 4);
    if ( jetResult != JET_errSuccess ) {
        //"Could not get info for \"%s\" column in \"%s\" table: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETGETCOLUMNINFO_ERR,
                       ColumnName,
                       TableState->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    if ( fTransacted ) {
        jetResult = JetBeginTransaction(DbState->sessionId);
        if ( jetResult != JET_errSuccess ) {
            //"Could not start a new transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETBEGINTRANS_ERR, GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
        inTransaction = TRUE;
    }

    jetResult = JetPrepareUpdate(DbState->sessionId,
                                 TableState->tableId,
                                 JET_prepReplace);
    if ( jetResult != JET_errSuccess ) {
        //"Could not prepare \"%s\" table for update: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETPREPARE_ERR,
                       TableState->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetSetColumn(DbState->sessionId,
                             TableState->tableId,
                             columnInfo.columnid,
                             InputBuffer,
                             InputBufferSize,
                             0,
                             NULL);
    if ( jetResult != JET_errSuccess ) {
        //"Could not set \"%s\" column in \"%s\" table: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETSETCOLUMN_ERR,
                       ColumnName,
                       TableState->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    jetResult = JetUpdate(DbState->sessionId,
                          TableState->tableId,
                          NULL,
                          0,
                          0);
    if ( jetResult != JET_errSuccess ) {
        //"Could not update ""%s"" table: %ws.\n"
        DIT_ERROR_PRINT (IDS_JETUPDATE_ERR,
                       TableState->tableName,
                       GetJetErrString(jetResult));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    if ( fTransacted ) {

        jetResult = JetCommitTransaction(DbState->sessionId, 0);
        inTransaction = FALSE;
        if ( jetResult != JET_errSuccess ) {
            //"Failed to commit transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETCOMMITTRANSACTION_ERR, GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
            goto CleanUp;
        }
    }

CleanUp:

    // if we are still in a transaction, there must have been an error
    // somewhere along the way.

    if ( inTransaction ) {

        jetResult = JetRollback(DbState->sessionId, JET_bitRollbackAll);
        if ( jetResult != JET_errSuccess ) {
            //"Failed to rollback transaction: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETROLLBACK_ERR, GetJetErrString(jetResult));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }

    }

    return returnValue;

} // DitSetColumnByName



HRESULT
DitGetColumnIdsByName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN CHAR **ColumnNames,
    IN DWORD NumColumnNames,
    OUT DWORD *ColumnIds
    )
/*++

Routine Description:

    description-of-function

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    ColumnNames - Supplies the names of the columns for which the column id
        is to be found.
    NumColumnNames - Supplies the number of entries in the ColumnNames array.
    ColumnIds - Returns the column ids of the given columns.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was null.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    JET_ERR jetResult;

    JET_COLUMNBASE columnInfo;
    DWORD i;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (ColumnNames == NULL) ||
         (ColumnIds == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    for ( i = 0; i < NumColumnNames; i++ ) {

        jetResult = JetGetColumnInfo(DbState->sessionId,
                                     DbState->databaseId,
                                     TableState->tableName,
                                     ColumnNames[i],
                                     &columnInfo,
                                     sizeof(columnInfo),
                                     4);
        if ( jetResult != JET_errSuccess ) {
            //"Could not get info for \"%s\" column in \"%s\" table: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETGETCOLUMNINFO_ERR,
                           ColumnNames[i],
                           TableState->tableName,
                           GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        ColumnIds[i] = columnInfo.columnid;

    }


CleanUp:

    return returnValue;

} // DitGetColumnIdsByName



void
SwapColumns(
    IN int Index1,
    IN int Index2,
    IN OUT JET_RETRIEVECOLUMN *RetrievalArray,
    IN OUT CHAR **ColumnNames
    )
/*++

Routine Description:

    This function swaps entries Index1 and Index2 in the given
    JET_RETRIEVECOLUMN array.

    Note:  this function was basically stolen from dsamain\src\dbdump.c

Arguments:

    Index1 - Supplies the index of the first entry.
    Index2 - Supplies the index of the second entry.
    RetrievalArray - Supplies an array in which to swap the columns.
    ColumnNames - Supplies an array in which to swap the columns.

Return Value:

    None

--*/
{

    JET_RETRIEVECOLUMN tempVal;
    CHAR *tempName;


    if ( Index1 != Index2 ) {

        tempVal  = RetrievalArray[Index1];
        tempName = ColumnNames[Index1];

        RetrievalArray[Index1] = RetrievalArray[Index2];
        ColumnNames[Index1]    = ColumnNames[Index2];

        RetrievalArray[Index2] = tempVal;
        ColumnNames[Index2]    = tempName;

    }

} // SwapColumns


// This global variable is used by ColumnIdComp in order to determine which
// of the given indexes points to an entry with a lesser column id.

JET_RETRIEVECOLUMN *_ColumnIdComp_ColumnIds;



int
__cdecl
ColumnIdComp(
    IN const void *Elem1,
    IN const void *Elem2
    )
/*++

Routine Description:

    This function is passed as an argument to qsort when called by the
    function below.  The two given arguments are indexes into the
    _ColumnIdComp_ColumnIds array.  The return value tells which of the two
    entries into the array (given by those indexes) has a lesser column id.

    Note:  this function was basically stolen from dsamain\src\dbdump.c

Arguments:

    Elem1 - Supplies the first array index.
    Elem2 - Supplies the second array index.

Return Value:

    < 0 - column id of Elem1 is less than that of Elem2
    0   - column ids of Elem1 and Elem2 are equal
    > 0 - column id of Elem1 is greater than that of Elem2

--*/
{

    return _ColumnIdComp_ColumnIds[*(int*)Elem1].columnid -
           _ColumnIdComp_ColumnIds[*(int*)Elem2].columnid;

} // ColumnIdComp



HRESULT
DitCreateRetrievalArray(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN const CHAR **ColumnNames,
    IN DWORD NumColumns,
    OUT RETRIEVAL_ARRAY **RetrievalArray
    )
/*++

Routine Description:

    This function creates a RETRIEVAL_ARRAY structure from the given column
    names.  The columnVals array is an array of JET_RETRIEVECOLUMN structures
    suitable to be passed to JetRetrieveColumns.  The entries in this array
    are sorted by columnid, and an index into the original column names array
    is mapped to an index into columnVals by the indexes array.    Ccolumn
    names array is also sorted.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    ColumnNames - Supplies the names of the columns to be in the retrieval
        array.
    NumColumns - Supplies the number of entries in teh ColumnNames array.
    RetrievalArray - Returns the RETRIEVAL_ARRAY structure created.

Return Value:

    S_OK - The operation succeeded.
    E_INVALIDARG - One of the given pointers was NULL.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;

    JET_COLUMNBASE columnInfo;
    DWORD *newIndexes = NULL;
    DWORD *temp;
    DWORD size;
    DWORD i, j;


    if ( (DbState == NULL) ||
         (TableState == NULL) ||
         (ColumnNames == NULL) ||
         (RetrievalArray == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = DitAlloc(RetrievalArray, sizeof(RETRIEVAL_ARRAY));
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    (*RetrievalArray)->numColumns = NumColumns;

    result = DitAlloc(&(*RetrievalArray)->columnVals,
                     sizeof(JET_RETRIEVECOLUMN) * NumColumns);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitAlloc((VOID**)&(*RetrievalArray)->columnNames,
                     sizeof(CHAR*) * NumColumns);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    for ( i = 0; i < NumColumns; i++) {

        result = DitAlloc(&(*RetrievalArray)->columnNames[i],
                         strlen(ColumnNames[i]) + 1);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        strcpy((*RetrievalArray)->columnNames[i], ColumnNames[i]);

    }

    result = DitAlloc(&(*RetrievalArray)->indexes, sizeof(DWORD) * NumColumns);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitAlloc(&newIndexes, sizeof(DWORD) * NumColumns);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    for ( i = 0; i < NumColumns; i++ ) {

        (*RetrievalArray)->indexes[i] = i;

        jetResult = JetGetColumnInfo(DbState->sessionId,
                                     DbState->databaseId,
                                     TableState->tableName,
                                     ColumnNames[i],
                                     &columnInfo,
                                     sizeof(columnInfo),
                                     4);
        if ( jetResult != JET_errSuccess ) {
            //"Could not get info for \"%s\" column in \"%s\" table: %ws.\n"
            DIT_ERROR_PRINT (IDS_JETGETCOLUMNINFO_ERR,
                           ColumnNames[i],
                           TableState->tableName,
                           GetJetErrString(jetResult));
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        switch ( columnInfo.coltyp ) {

        case JET_coltypUnsignedByte:    size = 1;     break;
        case JET_coltypLong:            size = 4;     break;
        case JET_coltypCurrency:        size = 8;     break;
        case JET_coltypBinary:
        case JET_coltypText:            size = 256;   break;
        case JET_coltypLongBinary:      size = 4096;  break;
        case JET_coltypLongText:        size = 4096;  break;

        default:
            // this should never happen
            ASSERT(FALSE);
            //"Encountered unexpected column type %d.\n"
            DIT_ERROR_PRINT (IDS_DIT_UNEXPECTER_COLTYP_ERR, columnInfo.coltyp);
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

        result = DitAlloc(&(*RetrievalArray)->columnVals[i].pvData, size);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        (*RetrievalArray)->columnVals[i].cbData = size;
        (*RetrievalArray)->columnVals[i].columnid = columnInfo.columnid;
        (*RetrievalArray)->columnVals[i].itagSequence = 1;

    }

    _ColumnIdComp_ColumnIds = (*RetrievalArray)->columnVals;
    qsort((*RetrievalArray)->indexes, NumColumns, sizeof(int), ColumnIdComp);

    // rearrange the elements of the other arrays so that they are also sorted
    // by column id

    for ( i = 0; i < NumColumns - 1; i++ ) {

        // find the index of the one element that's supposed to be in position
        // i (it may have been moved by subsequence swaps)
        for ( j = (*RetrievalArray)->indexes[i];
              j < i;
              j = (*RetrievalArray)->indexes[j] );

        SwapColumns(i,
                    j,
                    (*RetrievalArray)->columnVals,
                    (*RetrievalArray)->columnNames);

    }

    // construct a new indexes array that maps old indexes to new indexes.
    for ( i = 0; i < NumColumns; i++ ) {

        for ( j = 0; (*RetrievalArray)->indexes[j] != i; j++ );

        newIndexes[i] = j;

    }

    temp = (*RetrievalArray)->indexes;
    (*RetrievalArray)->indexes = newIndexes;
    newIndexes = temp;


CleanUp:

    if ( newIndexes != NULL ) {
        DitFree(newIndexes);
    }

    return returnValue;

} // DitCreateRetrievalArray



HRESULT
DitDestroyRetrievalArray(
    IN RETRIEVAL_ARRAY **RetrievalArray
    )
/*++

Routine Description:

    This function deallocates all of the memory in the given RETRIEVAL_ARRAY
    structure.

Arguments:

    RetrievalArray - Supplies the RETRIEVAL_ARRAY to deallocate.

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The object was already deleted.
    E_INVALIDARG - One of the given pointers was NULL.

--*/
{

    HRESULT returnValue = S_OK;
    DWORD i;


    if ( RetrievalArray == NULL ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    if ( *RetrievalArray == NULL ) {
        returnValue = S_FALSE;
        goto CleanUp;
    }

    if ( (*RetrievalArray)->columnVals != NULL ) {

        for ( i = 0; i < (*RetrievalArray)->numColumns; i++ ) {

            if ( (*RetrievalArray)->columnVals[i].pvData != NULL ) {
                DitFree((*RetrievalArray)->columnVals[i].pvData);
                (*RetrievalArray)->columnVals[i].pvData = NULL;
            }

        }

        DitFree((*RetrievalArray)->columnVals);
        (*RetrievalArray)->columnVals = NULL;

    }

    if ( (*RetrievalArray)->columnNames != NULL ) {

        for ( i = 0; i < (*RetrievalArray)->numColumns; i++ ) {

            if ( (*RetrievalArray)->columnNames[i] != NULL ) {
                DitFree((*RetrievalArray)->columnNames[i]);
                (*RetrievalArray)->columnNames[i] = NULL;
            }

        }

        DitFree((*RetrievalArray)->columnNames);
        (*RetrievalArray)->columnNames = NULL;

    }

    if ( (*RetrievalArray)->indexes != NULL ) {
        DitFree((*RetrievalArray)->indexes);
        (*RetrievalArray)->indexes = NULL;
    }

    DitFree(*RetrievalArray);
    *RetrievalArray = NULL;


CleanUp:

    return returnValue;

} // DitDestroyRetrievalArray



HRESULT
DitGetColumnValues(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN OUT RETRIEVAL_ARRAY *RetrievalArray
    )
/*++

Routine Description:

    This function performs a batch column retrieval passing the
    JET_RETRIEVECOLUMN array contained in RetrievalArray to JetRetrieveColumns.
    If one of the columns does not have enough buffer space to retrieve all
    of the column, it is reallocated and the batch retrieval is performed
    again.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    RetrievalArray - Supplies the JET_RETRIEVECOLUMN array to be passed to
        JetRetrieveColumns.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jetResult;
    DWORD i;
    BOOL doRetrieval = TRUE;

    while ( doRetrieval ) {

        doRetrieval = FALSE;

        jetResult = JetRetrieveColumns(DbState->sessionId,
                                       TableState->tableId,
                                       RetrievalArray->columnVals,
                                       RetrievalArray->numColumns);

        if ( jetResult != JET_errSuccess ) {

            for ( i = 0; i < RetrievalArray->numColumns; i++ ) {

                if ( RetrievalArray->columnVals[i].err ==
                       JET_wrnBufferTruncated ) {

                    result = DitRealloc(&RetrievalArray->columnVals[i].pvData,
                                       &RetrievalArray->columnVals[i].cbData);
                    if ( FAILED(result) ) {
                        returnValue = result;
                        goto CleanUp;
                    }

                    doRetrieval = TRUE;

                } else if ( (RetrievalArray->columnVals[i].err !=
                               JET_wrnColumnNull) &&
                            (RetrievalArray->columnVals[i].err !=
                               JET_errSuccess) ) {

                    //"Could not retrieve ""%s"" column in ""%s"" table: %ws.\n"
                    DIT_ERROR_PRINT (IDS_JETRETRIEVECOLUMN_ERR,
                                   RetrievalArray->columnNames[i],
                                   TableState->tableName,
                                   GetJetErrString(jetResult));
                    returnValue = E_UNEXPECTED;
                    goto CleanUp;

                }

            }

        }

    }


CleanUp:

    return returnValue;

} // DitGetColumnValues



HRESULT
DitGetDnFromDnt(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD Dnt,
    IN OUT WCHAR **DnBuffer,
    IN OUT DWORD *DnBufferSize
    )
/*++

Routine Description:

    This function constructs the DN for the record with the given DNT.

Arguments:

    DbState - Supplies the state of the opened DIT database.
    TableState - Supplies the state of the opened DIT table.
    Dnt - Supplies the DNT of the record for which to construct the DN.
    DnBuffer - Returns the DN constructed.
    DnBufferSize - Returns the size of the DN buffer.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;

    DWORD currentDnt;
    WCHAR currentRdn[MAX_RDN_SIZE+1];
    DWORD currentDnLength;
    DWORD currentRdnLength;
    ATTRTYP currentRdnType;
    DWORD currentRdnTypeLength;
    WCHAR currentRdnTypeString[16];


    result = DitSetIndex(DbState, TableState, SZDNTINDEX, TRUE);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = DitSeekToDnt(DbState, TableState, Dnt);
    if ( FAILED(result) || (result == S_FALSE) ) {
        returnValue = result;
        goto CleanUp;
    }

    currentDnt = Dnt;
    currentDnLength = 0;
    (*DnBuffer)[currentDnLength] = L'\0';

    while ( currentDnt != ROOTTAG ) {

        result = DitGetColumnByName(DbState,
                                    TableState,
                                    SZRDNATT,
                                    currentRdn,
                                    sizeof(currentRdn),
                                    &currentRdnLength);
        if ( FAILED(result) || (result == S_FALSE) ) {
            returnValue = result;
            goto CleanUp;
        }
        currentRdnLength /= sizeof(WCHAR);
        currentRdn[currentRdnLength] = L'\0';


        result = DitGetColumnByName(DbState,
                                    TableState,
                                    SZRDNTYP,
                                    &currentRdnType,
                                    sizeof(currentRdnType),
                                    NULL);
        if ( FAILED(result) || (result == S_FALSE) ) {
            returnValue = result;
            goto CleanUp;
        }

        currentRdnTypeLength = AttrTypeToKey(currentRdnType,
                                             currentRdnTypeString);
        if ( currentRdnTypeLength == 0 ) {
            //"Could not display the attribute type for the object with DNT %u.\n"
            DIT_ERROR_PRINT (IDS_DIT_DISP_ATTR_TYPE_ERR, Dnt);
            returnValue = E_UNEXPECTED;
            goto CleanUp;
        }
        currentRdnTypeString[currentRdnTypeLength] = L'\0';

        while ( (currentDnLength + currentRdnTypeLength + 1 +
                 currentRdnLength + 1) * sizeof(WCHAR) > *DnBufferSize ) {

            result = DitRealloc(DnBuffer, DnBufferSize);
            if ( FAILED(result) ) {
                returnValue = result;
                goto CleanUp;
            }

        }

        if ( currentDnLength > 0 ) {
            wcscat(*DnBuffer, L",");
            currentDnLength += 1;
        }

        wcscat(*DnBuffer, currentRdnTypeString);
        wcscat(*DnBuffer, L"=");
        wcscat(*DnBuffer, currentRdn);
        currentDnLength += currentRdnTypeLength + 1 + currentRdnLength;

        result = DitGetColumnByName(DbState,
                                    TableState,
                                    SZPDNT,
                                    &currentDnt,
                                    sizeof(currentDnt),
                                    NULL);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        result = DitSeekToDnt(DbState,
                              TableState,
                              currentDnt);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

    }

    (*DnBuffer)[currentDnLength] = L'\0';


CleanUp:

    return returnValue;

} // DitGetDnFromDnt



VOID
DitSetErrorPrintFunction(
    IN PRINT_FUNC_RES PrintFunction
    )
/*++

Routine Description:

    This function sets the function which is used for printing error
    information to the client.  Note that "printf" is a
    perfectly valid PRINT_FUNC.

Arguments:

    PrintFunction - Supplies the new PRINT_FUNC to use for this task.

Return Value:

    S_OK - The operation succeeded.

--*/
{

    gPrintError = PrintFunction;

} // DitSetErrorPrintFunction



HRESULT
GetRegString(
    IN CHAR *KeyName,
    OUT CHAR **OutputString,
    IN BOOL Optional
    )
/*++

Routine Description:

    This function finds a given key in the DSA Configuration section of the
    registry.

Arguments:

    KeyName - Supplies the name of the key to query.
    OutputString - Returns a pointer to the buffer containing the string
        retrieved.
    Optional - Supplies whether or not the given key MUST be in the registry
        (i.e. if this is false and it is not found, that that is an error).

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The key was not found and Optional == TRUE.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    HKEY keyHandle = NULL;
    DWORD pathSize=0;
    DWORD keyType;


    if ( (KeyName == NULL) ||
         (OutputString == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          DSA_CONFIG_SECTION,
                          0,
                          KEY_QUERY_VALUE,
                          &keyHandle);
    if ( result != ERROR_SUCCESS ) {
        //"Could not open the DSA Configuration registry key.Error 0x%x(%ws).\n"
        DIT_ERROR_PRINT (IDS_DSA_OPEN_REGISTRY_KEY_ERR,
                       result, GetW32Err(result));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    result = RegQueryValueExA(keyHandle,
                              KeyName,
                              NULL,
                              &keyType,
                              NULL,
                              &pathSize);
    if ( result != ERROR_SUCCESS ) {

        if ( Optional ) {

            returnValue = S_FALSE;
            goto CleanUp;

        } else {

            //"Could not query DSA registry key %s. Error 0x%x(%ws).\n"
            DIT_ERROR_PRINT (IDS_DSA_QUERY_REGISTRY_KEY_ERR,
                           KeyName,
                           result, GetW32Err(result));
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

    } else if ( keyType != REG_SZ ) {

        //"DSA registry key %s is not of string type.\n"
        DIT_ERROR_PRINT (IDS_DSA_KEY_NOT_STRING_ERR, KeyName);
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }

    result = DitAlloc(OutputString, pathSize+1);
    if ( FAILED(result) ) {
        returnValue = result;
        goto CleanUp;
    }

    result = RegQueryValueExA(keyHandle,
                              KeyName,
                              NULL,
                              &keyType,
                              (LPBYTE)(*OutputString),
                              &pathSize);
    if ( result != ERROR_SUCCESS ) {

        if ( Optional ) {

            returnValue = S_FALSE;
            goto CleanUp;

        } else {

            //"Could not query DSA registry key %s. Error 0x%x(%ws).\n"
            DIT_ERROR_PRINT (IDS_DSA_QUERY_REGISTRY_KEY_ERR,
                           KeyName,
                           result, GetW32Err(result));
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

    } else if ( keyType != REG_SZ ) {

        //"DSA registry key %s is not of string type.\n"
        DIT_ERROR_PRINT (IDS_DSA_KEY_NOT_STRING_ERR, KeyName);
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }

    (*OutputString)[pathSize] = '\0';


CleanUp:

    if ( keyHandle != NULL ) {
        result = RegCloseKey(keyHandle);
        if ( result != ERROR_SUCCESS ) {
            //"Failed to close DSA Configuration registry key. Error 0x%x(%ws).\n"
            DIT_ERROR_PRINT (IDS_DSA_CLOSE_REGISTRY_KEY_ERR,
                           result, GetW32Err(result));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }
    }

    return returnValue;

} // GetRegString



HRESULT
GetRegDword(
    IN CHAR *KeyName,
    OUT DWORD *OutputDword,
    IN BOOL Optional
    )
/*++

Routine Description:

    This function finds a given key in the DSA Configuration section of the
    registry.

Arguments:

    KeyName - Supplies the name of the key to query.
    OutputInt - Returns the DWORD found.
    Optional - Supplies whether or not the given key MUST be in the registry
        (i.e. if this is false and it is not found, that that is an error).

Return Value:

    S_OK - The operation succeeded.
    S_FALSE - The key was not found and Optional == TRUE.
    E_INVALIDARG - One of the given pointers was null.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.
    E_UNEXPECTED - Some variety of unexpected error occured.

--*/
{

    HRESULT returnValue = S_OK;
    HRESULT result;
    HKEY keyHandle = NULL;
    DWORD keySize=0;
    DWORD keyType;


    if ( (KeyName == NULL) ||
         (OutputDword == NULL) ) {
        ASSERT(FALSE);
        returnValue = E_INVALIDARG;
        goto CleanUp;
    }

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          DSA_CONFIG_SECTION,
                          0,
                          KEY_QUERY_VALUE,
                          &keyHandle);
    if ( result != ERROR_SUCCESS ) {
        //"Could not open the DSA Configuration registry key.Error 0x%x(%ws).\n"
        DIT_ERROR_PRINT (IDS_DSA_OPEN_REGISTRY_KEY_ERR,
                       result, GetW32Err(result));
        returnValue = E_UNEXPECTED;
        goto CleanUp;
    }

    result = RegQueryValueExA(keyHandle,
                              KeyName,
                              NULL,
                              &keyType,
                              NULL,
                              &keySize);
    if ( result != ERROR_SUCCESS ) {

        if ( Optional ) {

            returnValue = S_FALSE;
            goto CleanUp;

        } else {

            //"Could not query DSA registry key %s. Error 0x%x(%ws).\n"
            DIT_ERROR_PRINT (IDS_DSA_QUERY_REGISTRY_KEY_ERR,
                           KeyName,
                           result, GetW32Err(result));
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

    } else if ( keyType != REG_DWORD ) {

        //"DSA registry key %s is not of dword type.\n"
        DIT_ERROR_PRINT (IDS_DSA_KEY_NOT_DWORD_ERR, KeyName);
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }

    ASSERT(keySize == sizeof(DWORD));

    result = RegQueryValueExA(keyHandle,
                              KeyName,
                              NULL,
                              &keyType,
                              (LPBYTE)OutputDword,
                              &keySize);
    if ( result != ERROR_SUCCESS ) {

        if ( Optional ) {

            returnValue = S_FALSE;
            goto CleanUp;

        } else {

            //"Could not query DSA registry key %s. Error 0x%x(%ws).\n"
            DIT_ERROR_PRINT (IDS_DSA_QUERY_REGISTRY_KEY_ERR,
                           KeyName,
                           result, GetW32Err(result));
            returnValue = E_UNEXPECTED;
            goto CleanUp;

        }

    } else if ( keyType != REG_DWORD ) {

        //"DSA registry key %s is not of dword type.\n"
        DIT_ERROR_PRINT (IDS_DSA_KEY_NOT_DWORD_ERR, KeyName);
        returnValue = E_UNEXPECTED;
        goto CleanUp;

    }

    ASSERT(keySize == sizeof(DWORD));


CleanUp:

    if ( keyHandle != NULL ) {
        result = RegCloseKey(keyHandle);
        if ( result != ERROR_SUCCESS ) {
            //"Failed to close DSA Configuration registry key. Error 0x%x(%ws).\n"
            DIT_ERROR_PRINT (IDS_DSA_CLOSE_REGISTRY_KEY_ERR,
                            result, GetW32Err(result));
            if ( SUCCEEDED(returnValue) ) {
                returnValue = E_UNEXPECTED;
            }
        }
    }

    return returnValue;

} // GetRegDword





HRESULT
DitAlloc(
    OUT VOID **Buffer,
    IN DWORD Size
    )
/*++

Routine Description:

    This function allocates the specified amount of memory (if possible) and
    sets Buffer to point to the buffer allocated.

Arguments:

    Buffer - Returns a pointer to the buffer allocated.
    Size - Supplies the size of the buffer to allocate.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.

--*/
{

    HRESULT returnValue = S_OK;


    *Buffer = malloc(Size);
    if ( *Buffer == NULL ) {
        DIT_ERROR_PRINT (IDS_ERR_MEMORY_ALLOCATION, Size);
        returnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    ZeroMemory(*Buffer, Size);


CleanUp:

    return returnValue;

} // DitAlloc


HRESULT
DitFree(
    IN VOID *Buffer
    )
/*++

Routine Description:

    Shells on free (for consistency & maintnance).

Arguments:

    Buffer - the buffer allocated.

Return Value:

    S_OK - The operation succeeded.
    E_UNEXPECTED - given NULL pointer

--*/
{

    if ( !Buffer ) {
        return E_UNEXPECTED;
    }

    free(Buffer);

    return S_OK;

} // DitFree



HRESULT
DitRealloc(
    IN OUT VOID **Buffer,
    IN OUT DWORD *CurrentSize
    )
/*++

Routine Description:

    This function re-allocates the given buffer to twice the given size (if
    possible).

Arguments:

    Buffer - Returns a pointer to the new buffer allocated.
    CurrentSize - Supplies the current size of the buffer.

Return Value:

    S_OK - The operation succeeded.
    E_OUTOFMEMORY - Not enough memory to allocate buffer.

--*/
{

    HRESULT returnValue = S_OK;
    BYTE *newBuffer;


    newBuffer = (BYTE*) realloc(*Buffer, *CurrentSize * 2);
    if ( newBuffer == NULL ) {
        DIT_ERROR_PRINT (IDS_ERR_MEMORY_ALLOCATION, *CurrentSize * 2);
        returnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    ZeroMemory(&newBuffer[*CurrentSize], *CurrentSize);

    *Buffer = newBuffer;
    *CurrentSize *= 2;


CleanUp:

    return returnValue;

} // DitRealloc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\ditlayer.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ditlayer.h

Abstract:

    This module contains the declaration of functions for examining and
    modifying the DIT database of the current machine.

Author:

    Kevin Zatloukal (t-KevinZ) 05-08-98

Revision History:

    05-08-98 t-KevinZ
        Created.

--*/


#ifndef _DITLAYER_H_
#define _DITLAYER_H_


#ifdef __cplusplus
extern "C" {
#endif


#include <dsjet.h>


typedef struct _TABLE_STATE {
    BOOL tableIdSet;
    JET_TABLEID tableId;
    CHAR *tableName;
    CHAR *indexName;
    } TABLE_STATE;

typedef struct _DB_STATE {
    BOOL instanceSet;
    BOOL sessionIdSet;
    BOOL databaseIdSet;
    BOOL hiddenTableIdSet;
    JET_INSTANCE instance;
    JET_SESID sessionId;
    JET_DBID databaseId;
    JET_TABLEID hiddenTableId;
    JET_COLUMNID usnColumnId;
    USN highestCommittedUsn;
    USN nextAvailableUsn;
    DWORD dsaDnt;
    } DB_STATE;

typedef struct _RETRIEVAL_ARRAY {
    JET_RETRIEVECOLUMN *columnVals;
    CHAR **columnNames;
    DWORD *indexes;
    DWORD numColumns;
    } RETRIEVAL_ARRAY;


/* This is the type for the functions that the ditlayer uses to print
   information.  This could be used to print the information into a console
   window or into a string that would be displayed to the user in a message
   box.  You can set where the ditlayer prints normal, error, and
   debug information with the DitSet*PrintFunction functions below.  Note
   that "printf" is a valid PRINT_FUNC. */

//typedef int (*PRINT_FUNC)(char *format, ...);
typedef int (*PRINT_FUNC_RES)(UINT FormatStringId, ...);

HRESULT
DitOpenDatabase(
    OUT DB_STATE **DbState
    );

HRESULT
DitCloseDatabase(
    IN OUT DB_STATE **DbState
    );

HRESULT
DitOpenTable(
    IN DB_STATE *DbState,
    IN CHAR *TableName,
    IN CHAR *InitialIndexName, OPTIONAL
    OUT TABLE_STATE **TableState
    );

HRESULT
DitCloseTable(
    IN DB_STATE *DbState,
    IN OUT TABLE_STATE **TableState
    );

HRESULT
DitSetIndex(
    IN DB_STATE *DbState,
    OUT TABLE_STATE *TableState,
    IN CHAR *IndexName,
    IN BOOL MoveFirst
    );

HRESULT
DitIndexRecordCount(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    OUT DWORD *RecordCount
    );

HRESULT
DitSeekToDn(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN const WCHAR *Dn
    );

HRESULT
DitSeekToChild(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD PDnt,
    IN ATTRTYP RdnType,
    IN CONST WCHAR *Rdn
    );

HRESULT
DitSeekToFirstChild(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD PDnt
    );

HRESULT
DitSeekToDnt(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD Dnt
    );

HRESULT
DitSeekToLink(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD linkDnt,
    IN DWORD linkBase
    );

HRESULT
DitGetDsaDnt(
    IN DB_STATE *DbState,
    OUT DWORD *DsaDnt
    );

HRESULT
DitGetNewUsn(
    IN DB_STATE *DbState,
    OUT USN *NewUsn
    );

HRESULT
DitPreallocateUsns(
    IN DB_STATE *DbState,
    IN DWORD NumUsns
    );

HRESULT
DitGetMostRecentChange(
    IN DB_STATE *DbState,
    OUT DSTIME *MostRecentChange
    );

HRESULT
DitGetDatabaseGuid(
    IN DB_STATE *DbState,
    OUT GUID *DatabaseGuid
    );

HRESULT
DitGetSchemaDnt(
    IN DB_STATE *DbState,
    OUT DWORD *SchemaDnt
    );

HRESULT
DitGetDntDepth(
    IN DB_STATE *DbState,
    IN DWORD Dnt,
    OUT DWORD *Depth
    );

HRESULT
DitGetColumnByName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN CHAR *ColumnName,
    OUT VOID *OutputBuffer,
    IN DWORD OutputBufferSize,
    OUT DWORD *OutputActualSize OPTIONAL
    );

HRESULT
DitSetColumnByName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN CHAR *ColumnName,
    IN VOID *InputBuffer,
    IN DWORD InputBufferSize,
    IN BOOL fTransacted
    );

HRESULT
DitGetColumnIdsByName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN CHAR **ColumnNames,
    IN DWORD NumColumnNames,
    OUT DWORD *ColumnIds
    );

HRESULT
DitCreateRetrievalArray(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN const CHAR **ColumnNames,
    IN DWORD NumColumns,
    OUT RETRIEVAL_ARRAY **RetrievalArray
    );

HRESULT
DitDestroyRetrievalArray(
    IN OUT RETRIEVAL_ARRAY **RetrievalArray
    );

HRESULT
DitGetColumnValues(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN OUT RETRIEVAL_ARRAY *RetrievalArray
    );

HRESULT
DitGetDnFromDnt(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD Dnt,
    IN OUT WCHAR **DnBuffer,
    IN OUT DWORD *DnBufferSize
    );

VOID
DitSetErrorPrintFunction(
    IN PRINT_FUNC_RES PrintFunction
    );


HRESULT
DitAlloc(
    OUT VOID **Buffer,
    IN DWORD Size
    );

HRESULT
DitFree(
    IN VOID *Buffer
    );

HRESULT
DitRealloc(
    IN OUT VOID **Buffer,
    IN OUT DWORD *CurrentSize
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\fsmoxfer.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "fsmo.hxx"

extern "C" {
// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>
#include <prefix.h>    
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header

#include "ntldap.h"
#include "winldap.h"
#include "ntlsa.h"
#include "lmcons.h"         // MAPI constants req'd for lmapibuf.h
#include "lmapibuf.h"       // NetApiBufferFree()
#include "sddl.h"         // ConvertStringSecurityDescriptorToSecurityDescriptorW()
#include "Dsgetdc.h"

#include "resource.h"

#define SECURITY_WIN32
#include <sspi.h>

}

#define RID_POOL_SIZE 500

//Added for RID Seizure mechanism
#define T_BIND_SLEEP 500  //in milliseconds
#define T_SEARCH_SLEEP 5000  //in milliseconds
#define CONNECT_TIMEOUT_SEC 15 //connect timeout in seconds
#define CONNECT_TIMEOUT_USEC 0 //connect timeout in micro seconds
#define CONNECT_SAMESITE_TIMEOUT_SEC 1 //connect timeout in seconds
#define CONNECT_SAMESITE_TIMEOUT_USEC 0 //connect timeout in micro seconds
#define RESULT_TIMEOUT_SEC 0 //connect timeout in micro seconds
#define RESULT_TIMEOUT_USEC 100000 //connect timeout in micro seconds

struct RidSeizureElement
{
    RidSeizureElement* pNext;
    LDAP*   pLDAPSession;
    LONG    nValue;
    PWCHAR* RidSetReference;
    RidSeizureElement();    //constructor!!
}; 


BOOLEAN
OpenLDAPSession(
    IN WCHAR* DNSName,
    IN BOOLEAN bSameSite,
    OUT LDAP** ppSession
    );

VOID
DeallocateRIDSeizureList(
    IN RidSeizureElement* pHead
    );


// Define a constant to hold a large integer
#define  MAX_LONG_NUM_STRING_LENGTH 21 // Big enough for 0xFFFFFFFFFFFFFFFF

// Define an SD which gives write rights to admin.
PWSTR pwszNewSD = L"O:DAG:DAD:(A;;RPLCRC;;;AU)(A;;RPWPLCCCDCRC;;;DA)(A;;RPWPLCCCDCRCWDWOSDSW;;;SY)S:(AU;SAFA;WDWOSDWPCCDCSW;;;WD)";

// When we whack the RID FSMO it is better to synchronize the server
// with at least some other servers. We try synchronizing the server
// with its direct replication partners. This constant determines the
// maximum number of servers that we will synchronize the selected server
// with. We do this in order to get the server more upto date on the
// Rid Available pool attribute in on order to minimize chances of duplicate
// SIDs
#define MAX_SERVERS_FOR_SYNCHRONIZATION 2

DWORD
GetDomainSid(
    POLICY_PRIMARY_DOMAIN_INFO  **ppInfo
    )
/*++
    Gets the sid for the domain hosted by the currently connected server.
    Caller should free info via NetApiBufferFree.
    Returns 0 on success, !0 otherwise.
--*/
{
    NTSTATUS                    status;
    UNICODE_STRING              unicodeStr;
    LSA_OBJECT_ATTRIBUTES       attrs;
    LSA_HANDLE                  hLsa;
    DWORD                       dwErr;

    RtlInitUnicodeString(&unicodeStr, gpwszServer);
    memset(&attrs, 0, sizeof(attrs));
    status = LsaOpenPolicy(&unicodeStr, 
                           &attrs, 
                           MAXIMUM_ALLOWED, 
                           &hLsa);

    if ( !NT_SUCCESS(status) )
    {
        dwErr = RtlNtStatusToDosError(status);
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LsaOpenPolicy", 
                            dwErr, GetW32Err(dwErr));
        return(1);
    }
    
    status = LsaQueryInformationPolicy(hLsa, 
                                       PolicyPrimaryDomainInformation, 
                                       (VOID **) ppInfo);

    if ( !NT_SUCCESS(status) )
    {
        dwErr = RtlNtStatusToDosError(status);
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LsaQueryInformationPolicy",
                            dwErr, GetW32Err(dwErr));
    }
    
    LsaClose(hLsa);
    return(status);
}

DWORD
FsmoRoleTransferHelper(
    WCHAR   *pwszOpControl,
    ULONG   cbVal,
    CHAR    *pVal
    )
/*++
    Generic role transfer helper routine which is called during both
    role transfer and role seizure.
--*/
{
    DWORD                   dwErr;
    LDAPModW                mod, *rMods[2];
    PWCHAR                  attrs[2];
    LDAP_BERVAL             berval;
    PLDAP_BERVAL            rBervals[2];

    if ( cbVal && pVal )
    {
        berval.bv_len = cbVal;
        berval.bv_val = pVal;
        rBervals[0] = &berval;
        rBervals[1] = NULL;
        mod.mod_vals.modv_bvals = rBervals;
        mod.mod_op = (LDAP_MOD_REPLACE | LDAP_MOD_BVALUES);
    }
    else
    {
        attrs[0] = L"bogusValue";
        attrs[1] = NULL;
        mod.mod_vals.modv_strvals = attrs;
        mod.mod_op = LDAP_MOD_REPLACE;
    }

    rMods[0] = &mod;
    rMods[1] = NULL;
    mod.mod_type = pwszOpControl;

    if ( LDAP_SUCCESS != (dwErr = ldap_modify_sW(gldapDS, L"", rMods)) )
    {
        //"ldap_modify_sW error 0x%x\n"
        //"Depending on the error code this may indicate a connection,\n"
        //"ldap, or role transfer error.\n"

        RESOURCE_PRINT2 (IDS_LDAP_MODIFY_ERR, dwErr, GetLdapErr(dwErr));
    }

    return(dwErr);
}

HRESULT
FsmoRoleTransfer(
    WCHAR   *pwszOpControl,
    UINT     uQuestionID,
    ULONG   cbVal,
    CHAR    *pVal
    )
/*++
    Generic role transfer routine.
--*/
{
    int         ret;
    DWORD       cChar;
    WCHAR       *msg;
    const WCHAR *pszQuestionFormat = READ_STRING (uQuestionID);
    const WCHAR *pszMessageTitle = READ_STRING (IDS_FSMOXFER_MSG1_TITLE);


    if ( fPopups )
    {
        // Give the admin a chance to abort.

        cChar =    wcslen(pszQuestionFormat) 
                 + wcslen(gpwszServer)
                 + 20;
    
        if ( NULL == (msg = (WCHAR *) malloc(cChar * sizeof (WCHAR))) )
        {
            //"Memory allocation error\n"
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }
    
        swprintf(msg, 
                pszQuestionFormat, 
                gpwszServer);
    
        ret = MessageBoxW(
                    GetFocus(),
                    msg,
                    pszMessageTitle,
                    (   MB_APPLMODAL 
                      | MB_DEFAULT_DESKTOP_ONLY 
                      | MB_YESNO
                      | MB_DEFBUTTON2
                      | MB_ICONQUESTION 
                      | MB_SETFOREGROUND ) );
        free(msg);

        RESOURCE_STRING_FREE (pszMessageTitle);
        RESOURCE_STRING_FREE (pszQuestionFormat);

        switch ( ret )
        {
        case 0:
    
            //"Message box error\n"
            RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
            return(S_OK);
    
        case IDYES:
    
            break;
    
        default:
    
            //"Operation cancelled\n"
            RESOURCE_PRINT (IDS_OPERATION_CANCELED);
            return(S_OK);
        }


    }

    // The admin said do it - so we shall.

    FsmoRoleTransferHelper(pwszOpControl, cbVal, pVal);
    SelectListRoles(NULL);
    return(S_OK);
}

HRESULT
FsmoAbandonAllRoles(
    CArgs   *pArgs
    )
{
    RETURN_IF_NOT_CONNECTED;

    // The 'e' stands for "Enterprise wide fsmo's" and the 'd' stands for
    // "Domain wide fsmo's". Get rid of them all!
    CHAR OperationParameter[] = "ed";

    return(FsmoRoleTransfer(
                    L"abandonFsmoRoles",
                    IDS_FSMOXFER_ABANDON_ROLES,
                    sizeof(OperationParameter),
                    OperationParameter));
}

HRESULT
FsmoBecomeRidMaster(
    CArgs   *pArgs
    )
{
    RETURN_IF_NOT_CONNECTED;

    return(FsmoRoleTransfer(
                    L"becomeRidMaster",
                    IDS_FSMOXFER_BECOME_RIDMASTER,
                    0,
                    NULL));
}

HRESULT
FsmoBecomeInfrastructureMaster(
    CArgs   *pArgs
    )
{
    RETURN_IF_NOT_CONNECTED;

    return(FsmoRoleTransfer(
                    L"becomeInfrastructureMaster",
                    IDS_FSMOXFER_BECOME_INF_MSTR,
                    0,
                    NULL));
}

HRESULT
FsmoBecomeSchemaMaster(
    CArgs   *pArgs
    )
{
    RETURN_IF_NOT_CONNECTED;

    return(FsmoRoleTransfer(
                    L"becomeSchemaMaster",
                    IDS_FSMOXFER_BECOME_SCH_MSTR,
                    0,
                    NULL));
}

HRESULT
FsmoBecomeDomainMaster(
    CArgs   *pArgs
    )
{
    RETURN_IF_NOT_CONNECTED;

    return(FsmoRoleTransfer(
                    L"becomeDomainMaster",
                    IDS_FSMOXFER_BECOME_DM_MSTR,
                    0,
                    NULL));
}

HRESULT
FsmoBecomePdcMaster(
    CArgs   *pArgs
    )
{
    POLICY_PRIMARY_DOMAIN_INFO  *pInfo;
    HRESULT                     hr;

    RETURN_IF_NOT_CONNECTED;

    if ( GetDomainSid(&pInfo) )
    {
        // GetDomainSid spewed an error message already.
        return(S_OK);
    }

    hr = FsmoRoleTransfer(
                    L"becomePdc",
                    IDS_FSMOXFER_BECOME_PDC,
                    RtlLengthSid(pInfo->Sid),
                    (CHAR *) pInfo->Sid);

    NetApiBufferFree(pInfo);
    return(hr);
}


DWORD
ReadAttributeQuiet(
    LDAP    *ld,
    WCHAR   *searchBase,
    WCHAR   *attrName,
    WCHAR   **ppAttrValue,
    BOOL    fQuiet
    )
/*++
    Reads an operational attribute and returns it in malloc'd memory.
    Returns 0 on success, !0 on error.
--*/
{
    DWORD       dwErr;
    PWCHAR      attrs[2] = { attrName, NULL };
    LDAPMessage *res, *e;
    WCHAR       *a;
    PWCHAR      *vals;
    VOID        *ptr;

    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
                                            ld,
                                            searchBase,
                                            LDAP_SCOPE_BASE,
                                            L"(objectClass=*)",
                                            attrs,
                                            0,
                                            &res)) )
    {
        if (!fQuiet) {
            //"ldap_search for attribute %ws failed with %s\n"
            RESOURCE_PRINT3 (IDS_LDAP_SEARCH_ATTR_ERR,
                   attrName, dwErr, GetLdapErr(dwErr));
        }
        return(1);
    }

    
    for ( e = ldap_first_entry(ld, res);
          e != NULL;
          e = ldap_next_entry(ld, e) ) 
    {
        for ( a = ldap_first_attributeW(ld, e, (BerElement **) &ptr);
              a != NULL;
              a = ldap_next_attributeW(ld, e, (BerElement *) ptr ) ) 
        {
            if ( !_wcsicmp(a, attrName) ) 
            {
                vals = ldap_get_valuesW(ld, e, a);
                *ppAttrValue = (WCHAR *) malloc(
                                    sizeof(WCHAR) * (wcslen(vals[0]) + 1));
                if ( !*ppAttrValue )
                {
                    if (!fQuiet) {
                        RESOURCE_PRINT (IDS_MEMORY_ERROR);
                    }
                    ldap_value_freeW(vals);
                    ldap_msgfree(res);
                    return(1);
                }

                wcscpy(*ppAttrValue, vals[0]);
                ldap_value_freeW(vals);
                ldap_msgfree(res);
                return(0);
            }
        }
    }

    if (!fQuiet) {
        //"Failed to read operational attribute %ws\n"
        RESOURCE_PRINT1 (IDS_FAIL_READ_ATTRIBUTE, attrName);
    }
    ldap_msgfree(res);
    return(1);
}


DWORD
ReadAttribute(
    LDAP    *ld,
    WCHAR   *searchBase,
    WCHAR   *attrName,
    WCHAR   **ppAttrValue
    )
/*++
    Reads an operational attribute and returns it in malloc'd memory.
    Returns 0 on success, !0 on error.
--*/
{
    return ReadAttributeQuiet(ld, searchBase, attrName, ppAttrValue, FALSE);
}

DWORD
ReadAttributeBinary(
    LDAP    *ld,
    WCHAR   *searchBase,
    WCHAR   *attrName,
    WCHAR   **ppAttrValue,
    PULONG    len
    )
/*++
    Reads an  attribute  in binary form and returns it in malloc'd memory.
    Returns 0 on success, !0 on error.
--*/
{
    DWORD       dwErr;
    PWCHAR      attrs[2] = { attrName, NULL };
    LDAPMessage *res, *e;
    WCHAR       *a;
    PLDAP_BERVAL *valList;
    LDAP_BERVAL *val;
    VOID        *ptr;

    *len=0;
    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
                                            ld,
                                            searchBase,
                                            LDAP_SCOPE_BASE,
                                            L"(objectClass=*)",
                                            attrs,
                                            0,
                                            &res)) )
    {
        //"ldap_search for attribute %ws failed with %s\n"
        RESOURCE_PRINT3 (IDS_LDAP_SEARCH_ATTR_ERR,
               attrName, dwErr, GetLdapErr(dwErr));
        return(1);
    }

    
    for ( e = ldap_first_entry(ld, res);
          e != NULL;
          e = ldap_next_entry(ld, e) ) 
    {
        for ( a = ldap_first_attributeW(ld, e, (BerElement **) &ptr);
              a != NULL;
              a = ldap_next_attributeW(ld, e, (BerElement *) ptr ) ) 
        {
            if ( !_wcsicmp(a, attrName) ) 
            {
                valList = ldap_get_values_lenW(ld, e, a);
                val = valList[0];
                *ppAttrValue = (WCHAR *) malloc(
                                    val[0].bv_len);
                if ( !*ppAttrValue )
                {
                    //"Memory allocation error\n"
                    RESOURCE_PRINT (IDS_MEMORY_ERROR);
                    ldap_value_free_len(valList);
                    ldap_msgfree(res);
                    return(1);
                }

                memcpy(*ppAttrValue, val[0].bv_val,val[0].bv_len);
                *len = val[0].bv_len;
                ldap_value_free_len(valList);
                ldap_msgfree(res);
                return(0);
            }
        }
    }

    //"Failed to read operational attribute %ws\n"
    RESOURCE_PRINT1 (IDS_FAIL_READ_ATTRIBUTE, attrName);
    ldap_msgfree(res);
    return(1);
}

DWORD
ReadWellKnownObject (
        LDAP  *ld,
        WCHAR *pHostObject,
        WCHAR *pWellKnownGuid,
        WCHAR **ppObjName
        )
{
    DWORD        dwErr;
    PWSTR        attrs[2];
    PLDAPMessage res, e;
    WCHAR       *pSearchBase;
    WCHAR       *pDN=NULL;
    
    // First, make the well known guid string
    pSearchBase = (WCHAR *)malloc(sizeof(WCHAR) * (11 +
                                                   wcslen(pHostObject) +
                                                   wcslen(pWellKnownGuid)));
    if(!pSearchBase) {
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return(1);
    }
    wsprintfW(pSearchBase,L"<WKGUID=%s,%s>",pWellKnownGuid,pHostObject);

    attrs[0] = L"1.1";
    attrs[1] = NULL;
    
    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
            ld,
            pSearchBase,
            LDAP_SCOPE_BASE,
            L"(objectClass=*)",
            attrs,
            0,
            &res)) )
    {
        //"ldap_search on %ws failed with %ws\n"
        RESOURCE_PRINT3 (IDS_LDAP_SEARCH_ERR, pSearchBase, dwErr, GetLdapErr(dwErr));
        return(1);
    }
    free(pSearchBase);
    
    // OK, now, get the dsname from the return value.
    e = ldap_first_entry(ld, res);
    if(!e) {
        //"No entry reading %ws\n"
        RESOURCE_PRINT1 (IDS_NO_ENTRY, pSearchBase);
        return(1);
    }
    pDN = ldap_get_dnW(ld, e);
    if(!pDN) {
        //"No DN on entry reading %S\n"
        RESOURCE_PRINT1 (IDS_NO_DN_ENTRY,pSearchBase);
        return(1);
    }

    *ppObjName = (PWCHAR)malloc(sizeof(WCHAR) *(wcslen(pDN) + 1));
    if(!*ppObjName) {
        //"Memory allocation error\n"
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return(1);
    }
    wcscpy(*ppObjName, pDN);
    
    ldap_memfreeW(pDN);
    ldap_msgfree(res);
    return 0;
}

ReadOperationalAttribute(
    LDAP    *ld,
    WCHAR   *attrName,
    WCHAR   **ppAttrValue
    )
{
    return (ReadAttribute(ld,L"\0",attrName,ppAttrValue));
}

DWORD
FsmoForcePopup(
    WCHAR   *serverName,
    WCHAR   *roleName,
    WCHAR   *dsaName
    )
/*++
    Last chance warning popup for whacking fsmo.
    Returns 0 on success, !0 on error or abort.
    By orders of marketing the word "seize" should be used.
--*/
{
    DWORD   cChar;
    int     ret;
    WCHAR   *msg;
    const WCHAR   *format = READ_STRING (IDS_FSMOXFER_MSG2);
    const WCHAR   *message_title = READ_STRING (IDS_FSMOXFER_MSG2_TITLE);

   
    // Give the admin a chance to abort.

    cChar =    wcslen(format) 
             + wcslen(serverName)
             + wcslen(roleName)
             + wcslen(dsaName)
             + 20;

    if ( NULL == (msg = (WCHAR *) malloc(cChar * sizeof (WCHAR))) )
    {
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return(1);
    }

    swprintf(msg, 
            format, 
            serverName,
            roleName,
            dsaName);
    
    ret = MessageBoxW(
                GetFocus(),
                msg,
                message_title,
                (   MB_APPLMODAL 
                  | MB_DEFAULT_DESKTOP_ONLY 
                  | MB_YESNO
                  | MB_DEFBUTTON2
                  | MB_ICONQUESTION 
                  | MB_SETFOREGROUND ) );
    free(msg);
    RESOURCE_STRING_FREE (format);
    RESOURCE_STRING_FREE (message_title);

    switch ( ret )
    {
    case 0:

        //"Message box error\n"
        RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
        return(1);

    case IDYES:

        return(0);

    default:

        //"Operation cancelled\n"
        RESOURCE_PRINT (IDS_OPERATION_CANCELED);
    }

    return(1);
}

DWORD
EmitWarningAndPrompt(
    UINT WarningMsgId
    )
/*++
    This routing throws up a warning as specified by msg, and then prompts for YES
    or NO. A success code of 0 is returned if the user selects YES and an error
    code of 1 is returned if the user hits NO.
--*/
{
   
    DWORD   cChar;
    int     ret;
    WCHAR   *msg;
    const WCHAR   *format = READ_STRING (IDS_FSMOXFER_MSG3);
    const WCHAR   *message_title = READ_STRING (IDS_FSMOXFER_MSG3_TITLE);
    const WCHAR   *WarningMsg = READ_STRING (WarningMsgId);

   
    // Give the admin a chance to abort.

    cChar =    wcslen(format) 
             + wcslen(WarningMsg)
             + 20;

    if ( NULL == (msg = (WCHAR *) malloc(cChar * sizeof (WCHAR))) )
    {
        //"Memory allocation error\n"
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return(1);
    }

    swprintf(msg, 
            format,
            WarningMsg);
    
    ret = MessageBoxW(
                GetFocus(),
                msg,
                message_title,
                (   MB_APPLMODAL 
                  | MB_DEFAULT_DESKTOP_ONLY 
                  | MB_YESNO
                  | MB_DEFBUTTON2
                  | MB_ICONQUESTION 
                  | MB_SETFOREGROUND ) );

    free(msg);
    RESOURCE_STRING_FREE (format);
    RESOURCE_STRING_FREE (message_title);
    RESOURCE_STRING_FREE (WarningMsg);
    
    
    switch ( ret )
    {
    case 0:

        //"Message box error\n"
        RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
        return(1);

    case IDYES:

        return(0);

    default:

        //"Operation cancelled\n"
        RESOURCE_PRINT (IDS_OPERATION_CANCELED);
    }

    return(1);
}



DWORD
ReadSD(
    LDAP                *ld, 
    WCHAR               *pDN,
    SECURITY_DESCRIPTOR **ppSD
    )
/*++
    Reads the security descriptor off the specified DN and returns it
    in malloc'd memory.
    Returns 0 on success, !0 on error.
--*/
{
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    WCHAR                   *attrs[2];
    PWSTR                   *values = NULL;
    PLDAP_BERVAL            *sd_value = NULL;
    SECURITY_INFORMATION    seInfo = DACL_SECURITY_INFORMATION;
    BYTE                    berValue[2*sizeof(ULONG)];
    LDAPControlW            seInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W,
                                              { 5, 
                                                (PCHAR) berValue },
                                              TRUE };
    PLDAPControlW           serverControls[2] = { &seInfoControl, NULL };
    DWORD                   dwErr;

    *ppSD = NULL;
    dwErr = 1;

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)(seInfo & 0xF);

    _try
    {
        attrs[0] = L"nTSecurityDescriptor";
        attrs[1] = NULL;
    
        dwErr = ldap_search_ext_sW(ld,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   L"(objectClass=*)",
                                   attrs,
                                   0,
                                   (PLDAPControlW *) &serverControls,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);
    
        if ( LDAP_SUCCESS != dwErr ) 
        {
            //"ldap_search on %ws failed with %s\n"
            RESOURCE_PRINT3 (IDS_LDAP_SEARCH_ERR, pDN, dwErr, GetLdapErr(dwErr));
            _leave;
        }
    
        entry = ldap_first_entry(ld, ldap_message);
    
        if ( !entry )
        {
            //"0 entries returned when reading SD on %ws\n"
            RESOURCE_PRINT1 (IDS_LDAP_READ_SD_ERR, pDN);
            dwErr = 1;
            _leave;
        }
    
        values = ldap_get_valuesW(ld, entry, attrs[0]);
    
        if ( !values )
        {
            if ( LDAP_NO_SUCH_ATTRIBUTE == (dwErr = ld->ld_errno) )
            {
                //"No rights to read DS on %ws\n"
                RESOURCE_PRINT1 (IDS_LDAP_NO_RIGHTS, pDN);
                _leave;
            }
    
            //"Error 0x%x reading SD on %ws\n"
            RESOURCE_PRINT3 (IDS_LDAP_READ_SD_ERR1, dwErr, GetLdapErr(dwErr), pDN);
            _leave;
        }
    
        sd_value = ldap_get_values_lenW(ld, ldap_message, attrs[0]);
    
        if ( !sd_value )
        {
            dwErr = ld->ld_errno;
            //"Error 0x%x reading SD on %ws\n"
            RESOURCE_PRINT3 (IDS_LDAP_READ_SD_ERR1, dwErr, GetLdapErr(dwErr), pDN);
            _leave;
        }
    
        *ppSD = (SECURITY_DESCRIPTOR *) malloc((*sd_value)->bv_len);
    
        if ( !*ppSD )
        {
            //"Memory allocation error\n"
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            dwErr = 1;
            _leave;
        }
    
        memcpy(*ppSD, (BYTE *) (*sd_value)->bv_val, (*sd_value)->bv_len);
        dwErr = 0;
    }
    _finally
    {
        if ( sd_value )
            ldap_value_free_len(sd_value);

        if ( values )
            ldap_value_freeW(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }


    return(dwErr);
}

DWORD 
WriteSD(
    LDAP                *ld, 
    WCHAR               *pDN,
    SECURITY_DESCRIPTOR *pSD
    )
/*++
    Writes the specified SD on the specified DN.
    Returns 0 on success, !0 on error.
--*/
{
    LDAPModW                mod;
    PLDAP_BERVAL            rBervals[2];
    LDAP_BERVAL             berval;
    LDAPModW                *rMods[2];
    SECURITY_INFORMATION    seInfo = DACL_SECURITY_INFORMATION;
    BYTE                    berValue[2*sizeof(ULONG)];
    LDAPControlW            seInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W,
                                              { 5, 
                                                (PCHAR) berValue },
                                              TRUE };
    PLDAPControlW           serverControls[2] = { &seInfoControl, NULL };
    DWORD                   dwErr;

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)(seInfo & 0xF);

    rMods[0] = &mod;
    rMods[1] = NULL;
    rBervals[0] = &berval;
    rBervals[1] = NULL;

    mod.mod_op   = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    mod.mod_type = L"nTSecurityDescriptor";
    mod.mod_vals.modv_bvals = rBervals;
    berval.bv_len = RtlLengthSecurityDescriptor(pSD);
    berval.bv_val = (CHAR *) pSD;

    dwErr = ldap_modify_ext_sW(ld,
                               pDN,
                               rMods,
                               (PLDAPControlW *) &serverControls,
                               NULL);

    if ( LDAP_SUCCESS != dwErr ) {
        //"ldap_modify of SD failed with %s\n"
        RESOURCE_PRINT2 (IDS_LDAP_MODIFY_SD_ERR, dwErr, GetLdapErr(dwErr));
    }

    return(dwErr);
}

#define FSMO_DOMAIN         0
#define FSMO_PDC            1
#define FSMO_RID            2
#define FSMO_SCHEMA         3
#define FSMO_INFRASTRUCTURE 4

HRESULT
FsmoForceFsmo(
    DWORD   fsmo
    )
/*++
    Generic FSMO whacker.
--*/
{
    DWORD                       dwErr, dwErr1;
    WCHAR                       *pDN = NULL;
    WCHAR                       *pDSA = NULL;
    WCHAR                       *pTmp;
    DWORD                       cb;
    CHAR                        *msg;
    WCHAR                       *roleName;
    LDAPModW                    mod, *rMods[2];
    PWCHAR                      attrs[2];
    SECURITY_DESCRIPTOR         *pOldSD = NULL;
    SECURITY_DESCRIPTOR         *pNewSD = NULL;
    WCHAR                       *pwszOpControlTransfer;
    ULONG                       cbValTransfer;
    CHAR                        *pValTransfer;
    POLICY_PRIMARY_DOMAIN_INFO  *pInfo = NULL;

    RETURN_IF_NOT_CONNECTED;

    // We handle only infrastructure, PDC, domain and schema here.

    if (    !(FSMO_PDC == fsmo) 
         && !(FSMO_DOMAIN == fsmo) 
         && !(FSMO_SCHEMA == fsmo) 
         && !(FSMO_INFRASTRUCTURE == fsmo) )
    {
        //"Internal error %f/%d"
        RESOURCE_PRINT2(IDS_ERR_INTERNAL_FILE_LINE, __FILE__, __LINE__);
        return(S_OK);
    }

    // Punt if we're not connected to a server.

    RETURN_IF_NOT_CONNECTED;

    // Use try/finally so we clean up handles, malloc'd memory, etc.

    _try
    {
        // You can only tell a server to make himself the role owner.
        // So ask the connected server for his NTDS-DSA name.

        if ( ReadOperationalAttribute(gldapDS,
                                      L"dsServiceName",
                                      &pDSA) )
        {
            return(S_OK);
        }
    
        // Derive name of object which holds FSMO.
    
        switch ( fsmo )
        {
        case FSMO_INFRASTRUCTURE:        
            // In product 1 there is only one domain per DC, so we
            // can ask the DC what his domain is.

            if ( ReadOperationalAttribute(gldapDS,
                                          L"defaultNamingContext",
                                          &pTmp) )
            {
                return(S_OK);
            }
            // Now, read the well known objects attribute on that object,
            // looking for the correct well known guid.

            if ( ReadWellKnownObject(gldapDS,
                                     pTmp,
                                     GUID_INFRASTRUCTURE_CONTAINER_W,
                                     &pDN) ) {
                return(S_OK);
            }

            free(pTmp);
            roleName = L"infrastructure";
            pwszOpControlTransfer = L"becomeInfrastructureMaster";
            cbValTransfer = 0;
            pValTransfer = NULL;
            break;
        case FSMO_SCHEMA:
    
            if ( ReadOperationalAttribute(gldapDS,
                                          L"schemaNamingContext",
                                          &pDN) )
            {
                return(S_OK);
            }

            roleName = L"schema";
            pwszOpControlTransfer = L"becomeSchemaMaster";
            cbValTransfer = 0;
            pValTransfer = NULL;
            break;
            
        case FSMO_DOMAIN:

            if ( ReadOperationalAttribute(gldapDS,
                                          L"configurationNamingContext",
                                          &pDN) )
            {
                return(S_OK);
            }

            cb = sizeof(WCHAR) * (wcslen(pDN) + strlen("CN=Partitions,") + 10);
            pTmp = (WCHAR *) malloc(cb);

            if ( !pTmp )
            {
                printf("Memory alloction error\n");
                return(S_OK);
            }

            wcscpy(pTmp, L"CN=Partitions,");
            wcscat(pTmp, pDN);
            free(pDN);
            pDN = pTmp;
            roleName = L"domain naming";
            pwszOpControlTransfer = L"becomeDomainMaster";
            cbValTransfer = 0;
            pValTransfer = NULL;
            break;

        case FSMO_PDC:

            // In product 1 there is only one domain per DC, so we
            // can ask the DC what his domain is.

            if ( ReadOperationalAttribute(gldapDS,
                                          L"defaultNamingContext",
                                          &pDN) )
            {
                return(S_OK);
            }

            if ( GetDomainSid(&pInfo) )
            {
                // GetDomainSid spewed an error message already.
                return(S_OK);
            }
            
            roleName = L"PDC";
            pwszOpControlTransfer = L"becomePdc";
            cbValTransfer = RtlLengthSid(pInfo->Sid);
            pValTransfer = (CHAR *) pInfo->Sid;
            break;
        }

        // Construct role-appropriate popup message and abort if desired.

        if ( fPopups )
        {
            if ( FsmoForcePopup(gpwszServer, roleName, pDSA) )
            {
                return(S_OK);
            }
        }

        // They want to whack, but maybe they're confused and we can 
        // actually transfer.  So try a transfer first.

        //"Attempting safe transfer of %ws FSMO before seizure.\n"
        RESOURCE_PRINT1 (IDS_FSMOXFER_ATTEMPT_TRFR, roleName);

        if ( 0 == FsmoRoleTransferHelper(pwszOpControlTransfer, 
                                         cbValTransfer,
                                         pValTransfer) )
        {
            //"FSMO transferred successfully - seizure not required.\n"
            RESOURCE_PRINT (IDS_FSMOXFER_ATTEMPT_TRFR_SUC);
            SelectListRoles(NULL);
            return(S_OK);
        }

        // Check for magic error codes
        if (   (ldap_get_optionW(gldapDS, LDAP_OPT_SERVER_EXT_ERROR, &dwErr)
                == LDAP_SUCCESS)
            && (dwErr == ERROR_DS_NAMING_MASTER_GC)) {
            RESOURCE_PRINT(IDS_SEIZURE_FORBIDDEN);
            return(S_OK);
        }

        //"Transfer of %ws FSMO failed, proceeding with seizure ...\n"
        RESOURCE_PRINT1 (IDS_FSMOXFER_ATTEMPT_TRFR_FAIL, roleName);

        // OK - whack the property.

        attrs[0] = pDSA;
        attrs[1] = NULL;
        mod.mod_vals.modv_strvals = attrs;
        mod.mod_op = LDAP_MOD_REPLACE;
        rMods[0] = &mod;
        rMods[1] = NULL;
        mod.mod_type = L"fsmoRoleOwner";

        dwErr = ldap_modify_sW(gldapDS, pDN, rMods);

        if ( LDAP_SUCCESS == dwErr )
        {
            // The whack worked - time to go.
            SelectListRoles(NULL);
            return(S_OK);
        }
        else if (    (LDAP_INAPPROPRIATE_AUTH != dwErr) 
                  && (LDAP_INVALID_CREDENTIALS != dwErr) 
                  && (LDAP_INSUFFICIENT_RIGHTS != dwErr) )
        {
            // Some error other than a security error - bail.
            //"ldap_modify of fsmoRoleOwner failed with %ws"
            RESOURCE_PRINT2 (IDS_LDAP_MODIFY_FSMOROLE_ERR, dwErr, GetLdapErr(dwErr));
            return(S_OK);
        }

        // Write of fsmoRoleOwner failed with a security error.  Try to 
        // whack the ACL on the object such that we can write the property.


        if ( ReadSD(gldapDS, pDN, &pOldSD) )
            return(S_OK);

        // Convert temporary SD from text to binary.

        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                                                            pwszNewSD,
                                                            SDDL_REVISION_1,
                                       (VOID **)            &pNewSD,
                                                            &cb) )
        {
            dwErr = GetLastError();
            //"Error 0x%x(%ws) converting text SD\n"
            RESOURCE_PRINT2 (IDS_FSMOXFER_CNV_TXT_SD_ERR, dwErr, GetW32Err(dwErr));
            return(S_OK);
        }

        // Write the temporary SD.

        if ( WriteSD(gldapDS, pDN, pNewSD) )
            return(S_OK);

        // Re-attempt write the fsmoRoleOwner property and restore the old
        // SD before exiting.

        if ( LDAP_SUCCESS != (dwErr = ldap_modify_sW(gldapDS, pDN, rMods)) )
        {
            //"ldap_modify of fsmoRoleOwner failed with %ws"
            RESOURCE_PRINT2 (IDS_LDAP_MODIFY_FSMOROLE_ERR, dwErr, GetLdapErr(dwErr));
        }

        if ( dwErr1 = WriteSD(gldapDS, pDN, pOldSD) )
        {
            //"Use the ACL editor to repair the SD on %ws\n"
            RESOURCE_PRINT1 (IDS_FSMOXFER_USE_ACL_REPAIR, pDN);
        }

        SelectListRoles(NULL);
        return(S_OK);
    }
    _finally
    {
        if ( pDN )
            free(pDN);

        if ( pDSA )
            free(pDSA);

        if ( pOldSD )
            free(pOldSD);

        if ( pNewSD )
            LocalFree(pNewSD);

        if ( pInfo )
            NetApiBufferFree(pInfo);
    }
            
    return(S_OK);
}

HRESULT
FsmoForcePdcMaster(
    CArgs   *pArgs
    )
{
    return(FsmoForceFsmo(FSMO_PDC));
}

HRESULT
FsmoForceSchemaMaster(
    CArgs   *pArgs
    )
{
    return(FsmoForceFsmo(FSMO_SCHEMA));
}

HRESULT
FsmoForceInfrastructureMaster(
    CArgs   *pArgs
    )
{
    return(FsmoForceFsmo(FSMO_INFRASTRUCTURE));
}

HRESULT
FsmoForceDomainMaster(
    CArgs   *pArgs
    )
{
    return(FsmoForceFsmo(FSMO_DOMAIN));
}

DWORD
GetRidManagerInfo(
    LDAP *ld, 
    PWCHAR * ppPrevRidManagerDN,
    PWCHAR * ppDomainDN,
    PWCHAR * ppRidManagerDN)
/*++

    Gets the DN of the ntdsa object of the DC that is the current 
    Rid Role Owner

--*/
{
   

    DWORD dwErr;

    __try 
    {

        if (0!=(dwErr=ReadOperationalAttribute(ld,
                L"DefaultNamingContext",ppDomainDN)))
        {
            return dwErr;
        }

        if (0!=(dwErr= ReadAttribute(ld,*ppDomainDN,
                L"RidManagerReference",ppRidManagerDN)))
        {
            return dwErr;
        }

        if (0!=(dwErr = ReadAttribute(ld,*ppRidManagerDN,
                L"fsmoRoleOwner",ppPrevRidManagerDN)))
        {
            return dwErr;
        }
    }
    __finally 
    {
        if (0!=dwErr)
        {
            if (NULL!=*ppDomainDN)
                free(*ppDomainDN);

            if (NULL!=*ppRidManagerDN)
                free(*ppRidManagerDN);

            if (NULL!=*ppPrevRidManagerDN)
                free(*ppPrevRidManagerDN);
        }
    }

    return dwErr;
}



BOOLEAN
VerifyNeighbourHood(
    LDAP *ld,
    WCHAR * pDomainDN,
    WCHAR * pDNPrevRidManager
    )
/*++

  This routine currently verifies if the new RID manager is a direct neighbour of
  the old. Future versions may actually make the RID manager sync with the neighbours
  of the old

--*/
{

    DWORD       dwErr;
   
    PWCHAR      RepsFrom[2] = {L"repsFrom" , NULL };
    LDAPMessage *res, *e;
    WCHAR       *a;
    PLDAP_BERVAL *valList;
    LDAP_BERVAL *val;
    VOID        *ptr;
    GUID        *pGuidVal;
    BOOLEAN     IsNeighbour = FALSE;
    BOOLEAN     RetValue = FALSE;
    ULONG       len;

    
  

    //
    // Read the GUID of the rid manager
    //

    dwErr = ReadAttributeBinary(
            ld,
            pDNPrevRidManager,
            L"objectGuid",
            (WCHAR **) &pGuidVal,
            &len
            );

    if (0!=dwErr)
    {
        //"Cannot read previous RID manager's GUID\n"
        RESOURCE_PRINT (IDS_FSMOXFER_PREV_RID_ERR);
        return(FALSE);
    }

    //
    // Read the Reps To
    //

    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
                                            ld,
                                            pDomainDN,
                                            LDAP_SCOPE_BASE,
                                            L"(objectClass=*)",
                                            RepsFrom,
                                            0,
                                            &res)) )
    {
        //"ldap_search_sW of %ws failed with %s\n"
        RESOURCE_PRINT3 (IDS_LDAP_SEARCH_ERR, pDomainDN,dwErr, GetLdapErr(dwErr));
        return(FALSE);
    }

    
    for ( e = ldap_first_entry(ld, res);
          e != NULL;
          e = ldap_next_entry(ld, e) ) 
    {
        for ( a = ldap_first_attributeW(ld, e, (BerElement **) &ptr);
              a != NULL;
              a = ldap_next_attributeW(ld, e, (BerElement *) ptr ) ) 
        {
            if ( !_wcsicmp(a, L"repsFrom") ) 
            {
                ULONG i=0;

                valList = ldap_get_values_lenW(ld, e, a);
                while (valList[i]!=NULL)
                {
                    REPLICA_LINK * prl;

                    prl = (REPLICA_LINK *) valList[i]->bv_val;
                    if (prl->dwVersion > 1)
                    {
                        //"Unable to parse replication Links -- Version mismatch\n"
                        RESOURCE_PRINT (IDS_FSMOXFER_PARSE_REPL_LINKS);
                        RetValue = FALSE;
                        break;
                    }

                    if (0==memcmp(&prl->V1.uuidDsaObj,pGuidVal,sizeof(GUID)))
                    {
                        // Yes we are a neighbour
                        RetValue = TRUE;
                        break;
                    }

                    i++;
                }

                ldap_value_free_len(valList);

                    

            }
        }
    }

    
    ldap_msgfree(res);
    return(RetValue);

}

BOOLEAN
SynchronizeNeighbourHood(
    LDAP *ld,
    WCHAR * pDomainDN
   )
/*++

  This routine asks the candidate Rid manager to synchronize with each of its direct neighbours. 

--*/
{

    DWORD       dwErr;
    PWCHAR      RepsFrom[2] = {L"repsFrom" , NULL };
    LDAPMessage *res, *e;
    WCHAR       *a;
    PLDAP_BERVAL *valList;
    LDAP_BERVAL *val;
    VOID        *ptr;
    GUID        *pGuidVal;
    ULONG       NumSynced=0;
    ULONG       len;

  
    //
    // Print out a message saying that you are about to synchronize
    // with neighbours
    //

    //"Synchronizing server %ws with its neighbours\n"
    //"This operation may take a few minutes ....");
    RESOURCE_PRINT1 (IDS_FSMOXFER_SYNCHRONIZING_MSG, gpwszServer);

    //
    // Read the Reps To
    //

    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
                                            ld,
                                            pDomainDN,
                                            LDAP_SCOPE_BASE,
                                            L"(objectClass=*)",
                                            RepsFrom,
                                            0,
                                            &res)) )
    {
        //"ldap_search for attribute repsFrom failed with %s\n"
        RESOURCE_PRINT3 (IDS_LDAP_SEARCH_ATTR_ERR, L"repsFrom", dwErr, GetLdapErr(dwErr));

        return(FALSE);
    }

    
    for ( e = ldap_first_entry(ld, res);
          e != NULL;
          e = ldap_next_entry(ld, e) ) 
    {
        for ( a = ldap_first_attributeW(ld, e, (BerElement **) &ptr);
              a != NULL;
              a = ldap_next_attributeW(ld, e, (BerElement *) ptr ) ) 
        {
            if ( !_wcsicmp(a, L"repsFrom") ) 
            {
                ULONG i=0;

                valList = ldap_get_values_lenW(ld, e, a);
                while ((valList[i]!=NULL) && (NumSynced<MAX_SERVERS_FOR_SYNCHRONIZATION))
                {
                    REPLICA_LINK * prl;

                    prl = (REPLICA_LINK *) valList[i]->bv_val;
                    if (prl->dwVersion > 1)
                    {
                        //"Unable to parse replication Links -- Version mismatch\n"
                        RESOURCE_PRINT (IDS_FSMOXFER_PARSE_REPL_LINKS);
                        break;
                    }

                    //
                    // Make the call to synchronize this server with its neighbours.
                    //

                    dwErr = DsReplicaSyncW(
                                ghDS,
                                pDomainDN,
                                &prl->V1.uuidDsaObj,
                                0
                                );

                    if (0==dwErr)
                    {
                        NumSynced++;
                        printf("...");
                    }

                    i++;
                }

                ldap_value_free_len(valList);

                    

            }
        }
    }

    
    ldap_msgfree(res);

    if (NumSynced>0)
    {
        RESOURCE_PRINT (IDS_DONE);
    }
    else
    {
        RESOURCE_PRINT (IDS_FAILED);
    }

    return(NumSynced>0);

}

DWORD
ParseStringToLargeInteger(
    IN CHAR * c,
    IN ULONG len,
    OUT LARGE_INTEGER  *pInt
    )
/*++

    Parses a String into a Large Integer 

    Parameters:

        c -- char string as returned in ldap berval
        len -- length of string
        pInt -- Pointer to Large Integer

    Return Values 

        0 success
        !0 failure
-*/
{
    LONG sign=1;
    unsigned i;

  
    pInt->QuadPart = 0;
    i=0;
    if(c[i] == '-') {
        sign = -1;
        i++;
    }

    if(i==len) {
        // No length or just a '-'
        return !0;
    }

    for(;i<len;i++) {
        // Parse the string one character at a time to detect any
        // non-allowed characters.
        if((c[i] < '0') || (c[i] > '9'))
            return !0;

        pInt->QuadPart = ((pInt->QuadPart * 10) +
                           c[i] - '0');
    }
    pInt->QuadPart *= sign;

   
    return 0;
 }

HRESULT
FsmoForceRidMaster(
    CArgs   *pArgs
    )
{
   
    DWORD                   dwErr, dwErr1;
    WCHAR                   * pPrevRidManagerDN=NULL;
    WCHAR                   * pDomainDN=NULL;
    WCHAR                   * pRidManagerDN=NULL;
    WCHAR                   * pDSA=NULL;
    LARGE_INTEGER           HighestRIDAvailablePool;
    LDAP_BERVAL             berval;
    PLDAP_BERVAL            rBervals[2];
    LDAPModW                mod1,mod2, *rmods[3];
    PWCHAR                  attrs[2];
    CHAR                   *AvailablePoolStringForm=NULL;
    CHAR                    NewAvailablePoolStringForm[MAX_LONG_NUM_STRING_LENGTH+1];
    ULONG                   len;
    
    HRESULT hr = E_FAIL;
    LDAPMessage*    pMsg1           = NULL;
    LDAPMessage*    pMsg2           = NULL;
    LDAPMessage*    pEntry          = NULL;
    LPWSTR          pSite           = NULL;

    PWCHAR          pBaseNamingContext   = NULL;
    PWCHAR          pSchemaNamingContext = NULL;
    PWCHAR*         ppComputerObjectCategory = NULL;
    
    PWCHAR Attr[4];
    PWCHAR strFilter1 = NULL;
    PWCHAR strFilter2 = NULL;
    PWCHAR str4 = NULL;
    
    HighestRIDAvailablePool.LowPart = 0;
    HighestRIDAvailablePool.HighPart = 0;

    RidSeizureElement* pPos = NULL;
    RidSeizureElement* pHead = NULL; //head pointer to linked list


    struct l_timeval        tdelay;    //0.1 seconds
    tdelay.tv_sec = RESULT_TIMEOUT_SEC;
    tdelay.tv_usec = RESULT_TIMEOUT_USEC;


    RETURN_IF_NOT_CONNECTED;
                                                   
    // Use try/finally so we clean up handles, malloc'd memory, etc.

    _try
    {
        //
        // Get the Previous Rid manager 
        //
        if (S_OK!=GetRidManagerInfo(gldapDS,&pPrevRidManagerDN,&pDomainDN,&pRidManagerDN))
        {
            //"Unable to query Rid manager Object\n"
            RESOURCE_PRINT (IDS_FSMOXFER_QUERY_RID_MGR);
            return(S_OK);
        }

        //
        // Read the current DSA's DN 
        //

        dwErr = ReadOperationalAttribute(gldapDS,L"dsServiceName",&pDSA);
        if (0!=dwErr)
        {
            //"Unable to Query the Current Server's Name\n"
            RESOURCE_PRINT (IDS_FSMOXFER_QUERY_CUR_SVR);
            return S_OK;
        }
      
        //
        // If we are already the fsmo role owner then bail
        //
        
        if (!_wcsicmp(pDSA,pPrevRidManagerDN))
        {
            //"The Selected Server is already the RID role owner\n"
            RESOURCE_PRINT (IDS_FSMOXFER_SVR_ALREADY_RID);
            return S_OK;
        }

        if ( fPopups )
        {
            if ( FsmoForcePopup(gpwszServer, L"RID Master", pDSA) )
            {
                return(S_OK);
            }
        }

        
        //"Attempting safe transfer of %ws FSMO before seizure.\n"
        RESOURCE_PRINT1 (IDS_FSMOXFER_ATTEMPT_TRFR, L"RID");

    
        if ( 0 == FsmoRoleTransferHelper(L"becomeRidMaster", 0, NULL) )
        {
            //"FSMO transferred successfully - seizure not required.\n"
            RESOURCE_PRINT (IDS_FSMOXFER_ATTEMPT_TRFR_SUC);
            SelectListRoles(NULL);
            return(S_OK);
        }
    
        //"Transfer of %ws FSMO failed, proceeding with seizure ...\n"
        RESOURCE_PRINT1 (IDS_FSMOXFER_ATTEMPT_TRFR_FAIL, L"RID"); 

        
        //Initialize HighestRIDAvailablePool to be the rIDAvailablePool attribute of the RidManager object
        dwErr = ReadAttributeBinary(gldapDS,pRidManagerDN,L"ridAvailablePool",(WCHAR **)&AvailablePoolStringForm,&len);
        if (0!=dwErr)
        {
            //"Unable to query the available RID pool\n"
            RESOURCE_PRINT (IDS_FSMOXFER_QUERY_RID_POOL);
            return S_OK;
        }
    
    
        //
        // Convert the string form available pool to one in
        // binary form
        //
        dwErr = ParseStringToLargeInteger(AvailablePoolStringForm,len,&HighestRIDAvailablePool);
        if (0!=dwErr)
        {
            //"Unable to Parse the available RID pool\n"
            RESOURCE_PRINT (IDS_FSMOXFER_PARSE_RID_POOL);
            return S_OK;
        }

        //Get the site of the current Domain Controller...
        //The ldap connection timeout will be appropriately determined based on whether a DC is same-site or not
        //If, for some reason, the site information cannot be determined
        //then we should not fail, just use the default (different site) connection time-out...
        dwErr = DsGetSiteNameW(NULL,&pSite);
        if (dwErr != NO_ERROR)
        {
            //Keep going...even if this fails
            pSite = NULL;
        }
        
        //Get defaultNamingContext, and schemaNamingContext
        dwErr = ReadOperationalAttribute(gldapDS,LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,&pBaseNamingContext);
        if (dwErr != 0)
        {
            //Unable to get the Domains operational attributes
            RESOURCE_PRINT (IDS_FSMOXFER_OP_ATTR);
            return S_OK;
        }

        dwErr = ReadOperationalAttribute(gldapDS,LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W,&pSchemaNamingContext);
        if (dwErr != 0)
        {
            //Unable to get the Domains operational attributes
            RESOURCE_PRINT (IDS_FSMOXFER_OP_ATTR);
            return S_OK;
        }
        
        //Get the ldapDisplayName of 'Computer' from the schema container...
        Attr[0] = L"defaultObjectCategory";
        Attr[1] = NULL;
        
        strFilter1 = L"lDAPDisplayName=computer";
        if (ldap_search_sW(gldapDS,pSchemaNamingContext,LDAP_SCOPE_SUBTREE,strFilter1,Attr,NULL,&pMsg1)!=LDAP_SUCCESS)
        {
            RESOURCE_PRINT (IDS_FSMOXFER_OP_ATTR);
            return(S_OK);
        }
        
        ASSERT(pMsg1 != NULL);
        pEntry = ldap_first_entry(gldapDS,pMsg1);
        if (pEntry == NULL) 
        {
            RESOURCE_PRINT (IDS_FSMOXFER_OP_ATTR);
            return(S_OK);
        }
        ppComputerObjectCategory = ldap_get_valuesW(gldapDS,pEntry,L"defaultObjectCategory");
        if(ppComputerObjectCategory == NULL)
        {
            RESOURCE_PRINT (IDS_FSMOXFER_OP_ATTR);
            return(S_OK);
        }

        
        //We need to get the DNS names of all DC's
        //Now do a deep search looking for all domain controllers
        WCHAR str1[5]; 
        _itow(DOMAIN_GROUP_RID_CONTROLLERS,str1,10);
        PWCHAR str2 = L")(objectCategory=";
        PWCHAR str3 = L"(&(primaryGroupID=";
        
        str4 = new WCHAR[wcslen(str1)+wcslen(str2)+wcslen(str3)+3];
        if (str4 == NULL)
        {
            //"Memory allocation error\n"
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }
        wcscpy(str4,str3);   
        wcscat(str4,str1);
        wcscat(str4,str2);
        //For example...
        //str4 = L"(&(primaryGroupID=516)(objectCategory="

        strFilter2 = new WCHAR[wcslen(str4)+wcslen(*ppComputerObjectCategory)+3];  /*for the '))' at the end*/
        if (strFilter2 == NULL)
        {
            //"Memory allocation error\n"
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }
        
        wcscpy(strFilter2,str4);   
        wcscat(strFilter2,*ppComputerObjectCategory);
        wcscat(strFilter2,L"))");
        //For example...
        //strFilter2 = L"(&(primaryGroupID=516)(objectCategory=CN=Computer,CN=Schema,CN=Configuration,DC=AKDOMAIN,DC=nttest,DC=microsoft,DC=com))";

        Attr[0] = L"dNSHostName";
        Attr[1] = L"rIDSetReferences";
        Attr[2] = L"serverReferenceBL";
        Attr[3] = NULL;
           
        //set chasing no referrals
        //But before we do this, get the value of LDAP_OPT_REFERRALS from the global LDAP handle, so that we can reset it 
        DWORD oldValue;
        DWORD newValue = FALSE;
        
        if (ldap_get_option(gldapDS,LDAP_OPT_REFERRALS,&oldValue) != LDAP_SUCCESS)
        {
            RESOURCE_PRINT (IDS_FSMOXFER_NO_DCS);
            return(S_OK);
        }
        
        if (ldap_set_option(gldapDS,LDAP_OPT_REFERRALS,&newValue) != LDAP_SUCCESS)
        {
            RESOURCE_PRINT (IDS_FSMOXFER_NO_DCS);
            return(S_OK);
        }

        if (ldap_search_sW(gldapDS,pBaseNamingContext,LDAP_SCOPE_SUBTREE,strFilter2,Attr,NULL,&pMsg2)!=LDAP_SUCCESS)
        {
            //set the Referral option back to original value
            ldap_set_option(gldapDS,LDAP_OPT_REFERRALS,&oldValue);
            RESOURCE_PRINT (IDS_FSMOXFER_NO_DCS);
            return(S_OK);
        }
        //set the Referral option back to original value, don't care if this function fails...
        ldap_set_option(gldapDS,LDAP_OPT_REFERRALS,&oldValue);
                
        //Open an LDAP session with the dnsHostName from the search results.
        //Increment pEntry, creating new RidSeizureElements for each connection
        pEntry = ldap_first_entry(gldapDS,pMsg2);
        while(pEntry != NULL)
        {
            PWCHAR* ppDNS = NULL;
            PWCHAR* ppRIDSetReference = NULL;
            PWCHAR* ppSiteReference = NULL;
            LDAP* pTempSession = NULL;
            BOOLEAN bSite = FALSE;       //samesite boolean value 
            PWSTR* dnComponents = NULL;
            PWSTR  siteName = NULL; 

            ppDNS = ldap_get_valuesW(gldapDS,pEntry,L"dNSHostName");
            ppRIDSetReference = ldap_get_valuesW(gldapDS,pEntry,L"rIDSetReferences");
            ppSiteReference = ldap_get_valuesW(gldapDS,pEntry,L"serverReferenceBL");
            //note that pRIDSetReference is deallocated in the cleanup routine -> DeallocateRIDSeizureList()

            //Let's see if we can make the connection
            if((ppDNS != NULL)&&(ppRIDSetReference != NULL))
            {
                //Determine the timeout, use the pSiteReference to determine whether the domain controller (pDNS) 
                //is at the same site as pSite (the site of the local machine)...     
                
                if ((ppSiteReference != NULL)&&(pSite != NULL))  
                //check to see if pSite is NULL just in case we could not get the site name of the local machine.
                {
                    dnComponents = ldap_explode_dnW(*ppSiteReference,1);   

                    if (dnComponents != NULL) 
                    {
                        siteName = dnComponents[2]; //can do this since the format of serverReferenceBL is constant
                        if (siteName != NULL)
                        {
                            if (_wcsicmp(siteName,pSite)==0)
                            {
                                //the domain controller is at the same site as local machine
                                bSite = TRUE;
                            }    
                        }
                    }
                }
                
                if (OpenLDAPSession(*ppDNS,bSite,&pTempSession) == TRUE)
                {
                    DWORD err;
                    RidSeizureElement* pTemp = NULL;

                    // The server is available. Bind. Note the synchronous
                    // bind allows SSPI to be used.
                    err = ldap_bind_sW(pTempSession,
                                       NULL,
                                       (PWCHAR) gpCreds,
                                       LDAP_AUTH_NEGOTIATE);
                    if (LDAP_SUCCESS == err) {

                        pTemp = new RidSeizureElement;
                        if (pTemp == NULL)
                        {
                            //"Memory allocation error\n"
                            RESOURCE_PRINT (IDS_MEMORY_ERROR);
                            ldap_unbind_s(pTempSession);
                            return(S_OK);
                        }
                        pTemp->pLDAPSession = pTempSession;
                        pTemp->RidSetReference = ppRIDSetReference;                
            
                        //set the head pointer
                        if(pHead == NULL)
                        {
                            //first element of the list
                            pHead = pTemp;
                        }
                        else
                        {
                            pPos->pNext = pTemp;
                        }
                        pPos = pTemp;
                        pTemp->pNext = NULL;

                    } else {

                        //
                        // DC is available, but bind failed
                        //
                        ldap_unbind_s(pTempSession);

                    }
                }
            }
            //deallocate pDNS
            if(ppDNS != NULL)
                ldap_value_freeW(ppDNS);

            //deallocate ppSiteReference
            if(ppSiteReference != NULL)
                ldap_value_freeW(ppSiteReference);
            
            if(dnComponents != NULL)
                ldap_value_freeW(dnComponents);

            //in either case, move to next DC
            pEntry = ldap_next_entry(gldapDS,pEntry);
        }
        
        //Now iterate through list which contains all DC's with which a connect
        //and a bind were successful
        pPos = pHead;
        while (pPos != NULL)
        {
            // Do an asynchronous search, store the msgid in pPos->nValue     
            Attr[0] = L"rIDAllocationPool";
            Attr[1] = NULL;
                            
            pPos->nValue = ldap_searchW(pPos->pLDAPSession,*(pPos->RidSetReference),LDAP_SCOPE_SUBTREE,L"(objectClass=*)",Attr,0);
            pPos = pPos->pNext;
        }

        //Sleep for a bit...wait for the searches to complete
        RESOURCE_PRINT (IDS_FSMOXFER_SLEEP_SEARCH);
        Sleep(T_SEARCH_SLEEP);

        //Now let's get the values, if a search has not completed, then skip to next DC
        pPos = pHead;
        while (pPos != NULL)
        {
            LDAPMessage* pTempMsg = NULL;
            LDAPMessage* pTempEntry = NULL;
            
            if(ldap_result(pPos->pLDAPSession,
                            pPos->nValue,
                            LDAP_MSG_ONE,
                            &tdelay,
                            &pTempMsg) == LDAP_RES_SEARCH_ENTRY)
            {
                if ((ldap_result2error(pPos->pLDAPSession,pTempMsg,FALSE))==LDAP_SUCCESS)
                {
                    pTempEntry = ldap_first_entry(pPos->pLDAPSession,pTempMsg);
                    if (pTempEntry != NULL)
                    {
                        LDAP_BERVAL** ppVal = NULL;
                        LARGE_INTEGER TempRIDPool;

                        ppVal = ldap_get_values_len(pPos->pLDAPSession,pTempEntry,"rIDAllocationPool");
                        if(ppVal != NULL)
                        {
                            ParseStringToLargeInteger((CHAR*)(*ppVal)->bv_val,(*ppVal)->bv_len,&TempRIDPool);
                            
                            if(TempRIDPool.LowPart > HighestRIDAvailablePool.LowPart)
                            {
                                HighestRIDAvailablePool = TempRIDPool;
                            }
                            ldap_value_free_len(ppVal);
                        }
                    }
                }
                if(pTempMsg != NULL)
                    ldap_msgfree(pTempMsg);
            }
            pPos = pPos->pNext;
        }
                
        ////////////////
        #ifdef OLDCODE//
        ////////////////
        //
        // Verify the neighbourhood of the Rid manager
        //
        if (!VerifyNeighbourHood(gldapDS,pDomainDN,pPrevRidManagerDN))
        {

            if (fPopups)
            {
                dwErr = EmitWarningAndPrompt( IDS_FSMOXFER_NEIGHBOURHOOD_WARN);
                if (0!=dwErr)
                {
                    return S_OK;
                }
            }
        }
      
        //
        // Synchronize the RID manager with its neighbours
        //
        if (!SynchronizeNeighbourHood(gldapDS,pDomainDN))
        {

            if (fPopups)
            {
                dwErr = EmitWarningAndPrompt( IDS_FSMOXFER_SYNCHRONIZE_WARN );
                if (0!=dwErr)
                {
                    return S_OK;
                }
            }
        }
        //
        // Read the available pool attribute of the Rid manager 
        //
        dwErr = ReadAttributeBinary(gldapDS,pRidManagerDN,L"ridAvailablePool",
                    (WCHAR **)&AvailablePoolStringForm,&len);
        if (0!=dwErr)
        {
            //"Unable to query the available RID pool\n"
            RESOURCE_PRINT (IDS_FSMOXFER_QUERY_RID_POOL);
            return S_OK;
        }
        
        //
        // Convert the string form available pool to one in
        // binary form
        //
        dwErr = ParseStringToLargeInteger(AvailablePoolStringForm,len,&HighestRIDAvailablePool);
        if (0!=dwErr)
        {
            //"Unable to Parse the available RID pool\n"
            RESOURCE_PRINT (IDS_FSMOXFER_PARSE_RID_POOL);
            return S_OK;
        }
        /////////////
        #endif
        /////////////
        
        //
        // Increment by one RID pool size
        // (note that RID_POOL_SIZE = 500, and is defined at the top of this file...)
        HighestRIDAvailablePool.LowPart += RID_POOL_SIZE;
       
        //
        // Check for Overflows
        //

        if (HighestRIDAvailablePool.LowPart < RID_POOL_SIZE)
        {
            //"Overflow Error in Incrementing RID pool\n"
            RESOURCE_PRINT (IDS_FSMOXFER_OVERFLOW_INC_RID);
            return S_OK;
        }


        //
        // Convert the available pool back to String Form
        //

        if (!NT_SUCCESS(RtlLargeIntegerToChar(
                            &HighestRIDAvailablePool,
                            10,//base 10
                            MAX_LONG_NUM_STRING_LENGTH,
                            NewAvailablePoolStringForm
                            )))
        {
             //"Error Processing Rid available pool\n"
            RESOURCE_PRINT (IDS_FSMOXFER_PROC_AVAIL_RID_POOL);
            return S_OK;
        }
           
      
        len = strlen(NewAvailablePoolStringForm);
        

        //
        // All right whack the FSMO
        //

        berval.bv_len = len;
        berval.bv_val = (CHAR *) NewAvailablePoolStringForm;
        rBervals[0] = &berval;
        rBervals[1] = NULL;
        mod1.mod_vals.modv_bvals = rBervals;
        mod1.mod_op = (LDAP_MOD_REPLACE | LDAP_MOD_BVALUES);
        mod1.mod_type = L"ridAvailablePool";

        attrs[0] = pDSA;
        attrs[1] = NULL;
        mod2.mod_vals.modv_strvals = attrs;
        mod2.mod_op = LDAP_MOD_REPLACE;
        mod2.mod_type = L"fsmoRoleOwner";

        rmods[0]=&mod1;
        rmods[1]=&mod2;
        rmods[2]=NULL;

        dwErr = ldap_modify_sW(gldapDS,pRidManagerDN , rmods);

        if (0!=dwErr)
        {
            //"ldap_modify_sW of Rid role owner failed with %ws\n"
            RESOURCE_PRINT2 (IDS_LDAP_MODIFY_RID_ERR, dwErr, GetLdapErr(dwErr));
            return S_OK;
        }

        //
        // OK successfully whacked the FSMO
        //

        SelectListRoles(NULL);
    }
    __finally
    {
       if (NULL!=pPrevRidManagerDN)
           free(pPrevRidManagerDN);

       if (NULL!=pDomainDN)
           free(pDomainDN);

       if (NULL!=pRidManagerDN)
           free(pRidManagerDN);

       if (NULL!=AvailablePoolStringForm)
           free(AvailablePoolStringForm);
    
       
       //Cleanup for RID Seizure
       if(ppComputerObjectCategory != NULL)
           ldap_value_freeW(ppComputerObjectCategory);
       
       if (pMsg1 != NULL) 
           ldap_msgfree(pMsg1);

       if (pMsg2 != NULL) 
           ldap_msgfree(pMsg2);

       if (strFilter2 != NULL) 
           delete strFilter2;

       if (str4 != NULL) 
           delete str4;

       if (pSite != NULL)
          NetApiBufferFree(pSite);

       DeallocateRIDSeizureList(pHead);
    }
    return S_OK;
}



RidSeizureElement::RidSeizureElement()
{                                            
    pNext = NULL;
    pLDAPSession = NULL;
    nValue = 0L;
    RidSetReference = NULL;
}

void DeallocateRIDSeizureList(RidSeizureElement* pHead)
{
   RidSeizureElement* pPos = pHead;    
   while(pPos != NULL)
    {
        RidSeizureElement* pTemp = pPos;
        if (pPos->pLDAPSession != NULL) 
        {
            //unbind, close connection
            ldap_unbind(pPos->pLDAPSession);
        }
        if (pPos->RidSetReference != NULL) 
        {
            ldap_value_freeW(pPos->RidSetReference);
        }
        pPos = pPos->pNext;
        delete pTemp;
    }
}

BOOLEAN OpenLDAPSession(WCHAR* pDNS, BOOLEAN bSameSite, LDAP** ppSession)
{
    DWORD err = LDAP_SUCCESS;
    PVOID opt;

    ASSERT(pDNS != NULL);
    
    //Use default portnumber (LDAP_PORT) for now
    //Could be a problem if there are MANY DC's
    (*ppSession) = ldap_initW(pDNS,LDAP_PORT);
    if ((*ppSession) == NULL) 
    {
        //error
        return FALSE;
    }
    
    struct l_timeval timeout;
    if (bSameSite == TRUE) 
    {
        timeout.tv_sec = CONNECT_SAMESITE_TIMEOUT_SEC;
        timeout.tv_usec = CONNECT_SAMESITE_TIMEOUT_USEC;
    }
    else
    {
        timeout.tv_sec = CONNECT_TIMEOUT_SEC;
        timeout.tv_usec = CONNECT_TIMEOUT_USEC;
    }
    
    err = ldap_connect((*ppSession),&timeout);
    if (LDAP_SUCCESS == err) {
        //
        // The DC is available -- set options to mutual auth and
        // signing.
        //
        opt = (PVOID)ISC_REQ_MUTUAL_AUTH;
        err = ldap_set_optionW((*ppSession),
                               LDAP_OPT_SSPI_FLAGS,
                               &opt);
        if (LDAP_SUCCESS == err) {
            opt = LDAP_OPT_ON;
            err = ldap_set_optionW((*ppSession),
                                   LDAP_OPT_SIGN,
                                   &opt);
        }
    }

    if (err) {
        if (*ppSession) {
            ldap_unbind_s(*ppSession);
            *ppSession = NULL;
        }
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\header.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "resource.h"
#include <dbopen.h>

HRESULT 
Header(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Called by parser to dump Jet database header.

  Parameters:

    pArgs - Pointer to argument block - ignored.

  Return Values:

    Always returns S_OK.

--*/
{
    SystemInfo      *pInfo;
    ExePathString   pszScript;
    ExePathString   pszEsentutlPath;
    FILE            *fp;
    BOOL            fIsDir;

    pInfo = GetSystemInfo();

    if ( !pInfo ) 
    {
        return(S_OK);
    }

    _try
    {
        // Check whether file exists.

        if ( !pInfo->pszDbAll[0] )
        {
           RESOURCE_PRINT2 (IDS_ERR_NO_DB_FILE_SPECIFIED, DSA_CONFIG_SECTION, FILEPATH_KEY);              
            _leave;
        }
        else if ( !ExistsFile(pInfo->pszDbAll, &fIsDir) )
        {
            RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_NOT_EXIST, pInfo->pszDbAll);
            _leave;
        }
        else if ( fIsDir )
        {
           RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_IS_DIR, pInfo->pszDbAll);
            _leave;
        }
        else if ( gliZero.QuadPart == pInfo->cbDb.QuadPart )
        {
           RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_EMPTY, pInfo->pszDbAll);
            _leave;
        }

        // Make sure we have esentutl.exe on this machine.

        if ( !FindExecutable(ESE_UTILITY_PROGRAM, pszEsentutlPath) )
        {
            _leave;
        }

        // invoke esentutl with the following command-line params:
        //      /m - specifies file-dump mode (MUST be first param)
        //      /o - suppresses "Microsoft Windows Database Utilities" logo

        const char * const  szCmdFmt        = "%s /m\"%s\" /o";
        const SIZE_T        cbCmdFmt        = strlen( szCmdFmt );           // buffer will be slighly over-allocated, big deal!
        const SIZE_T        cbEsentutlPath  = strlen( pszEsentutlPath );
        const SIZE_T        cbDbName        = strlen( pInfo->pszDbAll );
        char * const        szCmd           = (char *)alloca( cbCmdFmt      // over-allocated, so no need for +1 for null-terminator
                                                              + cbEsentutlPath
                                                              + cbDbName );

        // WARNING: assert no trailing backslash
        // because it would cause problems with the
        // surrounding quotes that we stick in
        // (a trailing backslash followed by the
        // end quote ends up getting interpreted as
        // an escape sequence)
        ASSERT( '\\' != pInfo->pszDbAll[ cbDbName-1 ] );

        sprintf( szCmd,
                 szCmdFmt,
                 pszEsentutlPath,
                 pInfo->pszDbAll );

        RESOURCE_PRINT1 (IDS_EXECUTING_COMMAND, szCmd);

        SpawnCommand (szCmd, pInfo->pszDbDir, NULL);
    }
    _finally
    {
        FreeSystemInfo(pInfo);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\fsmomain.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "fsmo.hxx"

#include "resource.h"

CParser         fsmoParser;
BOOL            fFsmoQuit;
BOOL            fFsmoParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes fsmoLanguage[] = 
{
    CONNECT_SENTENCE_RES
    SELECT_SENTENCE_RES

    {   L"?", 
        FsmoHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help", 
        FsmoHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit", 
        FsmoQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Transfer RID master",
        FsmoBecomeRidMaster,
        IDS_FSMO_TRANFER_RID_MSG, 0 },

    {   L"Transfer PDC",
        FsmoBecomePdcMaster,
        IDS_FSMO_TRANFER_PDC_MSG, 0 },

    {   L"Transfer infrastructure master",
        FsmoBecomeInfrastructureMaster,
        IDS_FSMO_TRANFER_INFRASTR_MSG, 0  },
    
    {   L"Transfer schema master",
        FsmoBecomeSchemaMaster,
        IDS_FSMO_TRANFER_SCHEMA_MSG, 0 },

    {   L"Transfer domain naming master",
        FsmoBecomeDomainMaster,
        IDS_FSMO_TRANFER_DN_MSG, 0  },

#if DBG
    {   L"Abandon all roles",
        FsmoAbandonAllRoles,
        IDS_FSMO_ABANDON_ALL_MSG, 0 },
#endif

    {   L"Seize RID master",
        FsmoForceRidMaster,
        IDS_FSMO_SEIZE_RID_MSG, 0  },

    {   L"Seize PDC",
        FsmoForcePdcMaster,
        IDS_FSMO_SEIZE_PDC_MSG, 0  },

    {   L"Seize infrastructure master",
        FsmoForceInfrastructureMaster,
        IDS_FSMO_SEIZE_INFRASTR_MSG, 0 },
    
    {   L"Seize schema master",
        FsmoForceSchemaMaster,
        IDS_FSMO_SEIZE_SCHEMA_MSG, 0 },
    
    {   L"Seize domain naming master",
        FsmoForceDomainMaster,
        IDS_FSMO_SEIZE_DN_MSG, 0 },
};

HRESULT
FsmoMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fFsmoParserInitialized )
    {
        cExpr = sizeof(fsmoLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (fsmoLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }


        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = fsmoParser.AddExpr(fsmoLanguage[i].expr,
                                                fsmoLanguage[i].func,
                                                fsmoLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fFsmoParserInitialized = TRUE;
    fFsmoQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_FSMO_MAINTAINANCE);

    hr = fsmoParser.Parse(gpargc,
                          gpargv,
                          stdin,
                          stdout,
                          prompt,
                          &fFsmoQuit,
                          FALSE,               // timing info
                          FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT FsmoHelp(CArgs *pArgs)
{
    return(fsmoParser.Dump(stdout,L""));
}

HRESULT FsmoQuit(CArgs *pArgs)
{
    fFsmoQuit = TRUE;
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\filemain.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "connect.hxx"

#include "resource.h"

CParser fileParser;
BOOL    fFileQuit;
BOOL    fFileParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes fileLanguage[] = 
{
    {   L"?",
        FileHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        FileHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        FileQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Info",
        DbInfo,
        IDS_FILES_INFO_MSG, 0 },

    {   L"Header",
        Header,
        IDS_FILES_HEADER_MSG, 0  },

    {   L"Recover",
        Recover,
        IDS_FILES_RECOVER_MSG, 0 },

    {   L"Integrity",
        Integrity,
        IDS_FILES_JET_INTEGRITY_MSG, 0 },

    {   L"Compact to %s",
        Compact,
        IDS_FILES_COMPACT_MSG, 0 },

    {   L"Move logs to %s",
        MoveLogs,
        IDS_FILES_MOVE_LOGS_MSG, 0 },

    {   L"Move DB to %s",
        MoveDb,
        IDS_FILES_MOVE_DB_MSG, 0  },

    {   L"Set path DB %s",
        SetPathDb,
        IDS_FILES_SET_DB_PATH_MSG, 0 },

    {   L"Set path backup %s",
        SetPathBackup,
        IDS_FILES_SET_BACKUP_PATH_MSG, 0 },

    {   L"Set path logs %s",
        SetPathLogs,
        IDS_FILES_SET_LOGS_PATH_MSG, 0 },

    {   L"Set path working dir %s",
        SetPathSystem,
        IDS_FILES_SET_WRK_PATH_MSG, 0 },
};

HRESULT
FileMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !IsSafeMode() || CheckIfRestored() )
    {
        return(S_OK);
    }

    if ( !fFileParserInitialized )
    {
        cExpr = sizeof(fileLanguage) / sizeof(LegalExprRes);
        
        
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (fileLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }
    
        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = fileParser.AddExpr(fileLanguage[i].expr,
                                                fileLanguage[i].func,
                                                fileLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fFileParserInitialized = TRUE;
    fFileQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_FILE_MAINTAINANCE);

    hr = fileParser.Parse(gpargc,
                          gpargv,
                          stdin,
                          stdout,
                          prompt,
                          &fFileQuit,
                          FALSE,               // timing info
                          FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT FileHelp(CArgs *pArgs)
{
    return(fileParser.Dump(stdout,L""));
}

HRESULT FileQuit(CArgs *pArgs)
{
    fFileQuit = TRUE;
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\dsver.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dsver.cxx

Abstract:

    This module contains commands for ds behavior version management
    
Author:

    Xin He (xinhe)   04-27-2000

Environment:

    User Mode.

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <mdglobal.h>
#include <assert.h>

#include "ntdsutil.hxx"
#include "select.hxx"
#include "connect.hxx"
#include "ntdsapip.h"

#include "resource.h"

#include <dsconfig.h>
                  
#include "ndnc.h"


CParser verParser;
BOOL    fVerQuit;
BOOL    fVerParserInitialized = FALSE;

// Build a table which defines our language.

HRESULT VerHelp(CArgs *pArgs);
HRESULT VerQuit(CArgs *pArgs);
HRESULT VerInfo(CArgs *pArgs);
HRESULT VerRaiseDomain(CArgs *pArgs);
HRESULT VerRaiseForest(CArgs *pArgs); 
HRESULT VerAddAttributes(CArgs *pArgs); 

LegalExprRes verLanguage[] = 
{
    CONNECT_SENTENCE_RES

    {   L"?",
        VerHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        VerHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        VerQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Info",
        VerInfo,
        IDS_DS_VER_INFO_MSG, 0 },

    {   L"Raise domain version to %d",
        VerRaiseDomain,
        IDS_DS_VER_RAISE_DOMAIN_MSG, 0 },

    {   L"Raise forest version to %d",
        VerRaiseForest,
        IDS_DS_VER_RAISE_FOREST_MSG, 0 }
   
};

HRESULT
VerMain(
    CArgs   *pArgs
    )
{
    HRESULT        hr;
    const WCHAR   *prompt;
    int            cExpr;
        
    if ( !fVerParserInitialized ) {
        cExpr = sizeof(verLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (verLanguage, cExpr)) ) {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }
        
        
        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ ) {
            if ( FAILED(hr = verParser.AddExpr(verLanguage[i].expr,
                                               verLanguage[i].func,
                                               verLanguage[i].help)) ) {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fVerParserInitialized = TRUE;
    fVerQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_DS_VER);

    hr = verParser.Parse(gpargc,
                         gpargv,
                         stdin,
                         stdout,
                         prompt,
                         &fVerQuit,
                         FALSE,               // timing info
                         FALSE);              // quit on error

    if ( FAILED(hr) )
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);


    return(hr);
}

#define FREE(_x_)   { if(_x_) { free(_x_); _x_ = NULL; } }

HRESULT
VerHelp(CArgs *pArgs)
{
    return verParser.Dump(stdout,L"");
}


HRESULT
VerQuit(CArgs *pArgs)
{
    fVerQuit = TRUE;
    return S_OK;
}


HRESULT
VerInfo(CArgs *pArgs)
{
    LONG   domainVersion, forestVersion;
    WCHAR *pwszTemp;
    WCHAR *pwszPartitionDN, *pwszDomainDN, *pwszConfigurationDN;
    DWORD  dwErr;

    //check LDAP connection
    if ( CHECK_IF_NOT_CONNECTED ) {
        return S_OK;
    }

    //get domain DN
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               L"defaultNamingContext",
                               &pwszDomainDN ) ) {
        return S_OK;
    }

    //get domain version
    if (dwErr = ReadAttribute( gldapDS,
                               pwszDomainDN,
                               L"msDs-Behavior-Version",
                               &pwszTemp )  ) {
        domainVersion = 0;
    }
    else {
        domainVersion = _wtol(pwszTemp);
        free(pwszTemp);

    }
    
    RESOURCE_PRINT1(IDS_DS_VER_DOMAIN_MSG, domainVersion);
    free(pwszDomainDN);


    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               L"configurationNamingContext",
                               &pwszConfigurationDN ) ) {
        return S_OK;
    }

   //figure out partition DN
    pwszPartitionDN = (PWCHAR) malloc(  sizeof(WCHAR)
                                      * (  wcslen(L"CN=Partitions,") 
                                         + wcslen(pwszConfigurationDN)
                                         + 1 ) );
    if (!pwszPartitionDN) {
        RESOURCE_PRINT(IDS_MEMORY_ERROR);
        free(pwszConfigurationDN);
        return S_OK;
    }
    
    wcscpy(pwszPartitionDN, L"CN=Partitions,");
    wcscat(pwszPartitionDN, pwszConfigurationDN);

    //get forest version
    if (dwErr = ReadAttribute( gldapDS,
                               pwszPartitionDN,
                               L"msDs-Behavior-Version",
                               &pwszTemp )  ) {
        forestVersion = 0;
    }
    else {
        forestVersion = _wtol(pwszTemp);
        free(pwszTemp);
    }
    
    RESOURCE_PRINT1(IDS_DS_VER_FOREST_MSG, forestVersion);

    free(pwszConfigurationDN);
    free(pwszPartitionDN);
    return S_OK;

}

HRESULT
VerRaiseDomain(CArgs *pArgs)
{
    int                     newVersion;
    DWORD                   dwErr;
    LDAPModW                mod, *rMods[2];
    PWCHAR                  attrs[2];
    LDAP_BERVAL             berval;
    PLDAP_BERVAL            rBervals[2];

    PWCHAR                  pwszDomainDN;
    WCHAR                   pwszNumber[128];
    PWCHAR                  ppVal[2];
    
    //check LDAP connection
    if ( CHECK_IF_NOT_CONNECTED ) {
        return S_OK;
    }
    
    //extract new version from the argument
    if ( S_OK != pArgs->GetInt(0,&newVersion) )
    {
        return S_OK;
    }

    _itow(newVersion,pwszNumber,10);

    //confirmation from user
    if ( fPopups ) {

        const WCHAR * message_body  = READ_STRING (IDS_DS_VER_CHANGE_CONFIRM_MSG);
        const WCHAR * message_title = READ_STRING (IDS_DS_VER_CHANGE_CONFIRM_TITLE);
       
        if (message_body && message_title) {

           int ret =  MessageBoxW(GetFocus(),
                                  message_body, 
                                  message_title,
                                  MB_APPLMODAL |
                                  MB_DEFAULT_DESKTOP_ONLY |
                                  MB_YESNO |
                                  MB_DEFBUTTON2 |
                                  MB_ICONQUESTION |
                                  MB_SETFOREGROUND);

           RESOURCE_STRING_FREE (message_body);
           RESOURCE_STRING_FREE (message_title);
          
           switch ( ret )
             {
             case IDYES:
                   break;
    
             case IDNO: 
                   RESOURCE_PRINT (IDS_OPERATION_CANCELED);
               
                   return(S_OK);
            
             default: 
                   RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
                  
                   return(S_OK);    
             }
        }
    }

    
    //figure out domain DN
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               L"defaultNamingContext",
                               &pwszDomainDN ) ) 
    {
        return S_OK;
    }

    //LDAP modify
    ppVal[0] = pwszNumber;
    ppVal[1] = NULL;
    mod.mod_vals.modv_strvals = ppVal;
    mod.mod_op = LDAP_MOD_REPLACE;
    mod.mod_type = L"msDS-Behavior-Version";

    rMods[0] = &mod;
    rMods[1] = NULL;
    

    if ( LDAP_SUCCESS != (dwErr = ldap_modify_sW(gldapDS, pwszDomainDN, rMods)) ) {
        //"ldap_modify_sW error 0x%x\n"
        //"Depending on the error code this may indicate a connection,\n"
        //"ldap, or role transfer error.\n"

        RESOURCE_PRINT2 (IDS_LDAP_MODIFY_ERR, dwErr, GetLdapErr(dwErr));
    }

    free(pwszDomainDN);
    return S_OK;

}

HRESULT
VerRaiseForest(CArgs *pArgs)
{
    int                     newVersion;
    DWORD                   dwErr;
    LDAPModW                mod, *rMods[2];
    PWCHAR                  attrs[2];
    LDAP_BERVAL             berval;
    PLDAP_BERVAL            rBervals[2];
    PWCHAR                  pwszConfigurationDN = NULL;
    PWCHAR                  pwszPartitionDN = NULL;
    PWCHAR                  pwszCurNumber = NULL;
    WCHAR                   pwszNumber[128];
    PWCHAR                  ppVal[2];
    
    //check LDAP connection
    if ( CHECK_IF_NOT_CONNECTED ) {
        return S_OK;
    }
    
    //extract new version from the argument
    if ( S_OK != pArgs->GetInt(0,&newVersion) ) {
        return S_OK;
    }

    _itow(newVersion,pwszNumber,10);

    //confirmation from user
    if ( fPopups ) {

        const WCHAR * message_body  = READ_STRING (IDS_DS_VER_CHANGE_CONFIRM_MSG);
        const WCHAR * message_title = READ_STRING (IDS_DS_VER_CHANGE_CONFIRM_TITLE);
       
        if (message_body && message_title) {

           int ret =  MessageBoxW(GetFocus(),
                                  message_body, 
                                  message_title,
                                  MB_APPLMODAL |
                                  MB_DEFAULT_DESKTOP_ONLY |
                                  MB_YESNO |
                                  MB_DEFBUTTON2 |
                                  MB_ICONQUESTION |
                                  MB_SETFOREGROUND);

           RESOURCE_STRING_FREE (message_body);
           RESOURCE_STRING_FREE (message_title);
          
           switch ( ret )
             {
             case IDYES:
                   break;
    
             case IDNO: 
                   RESOURCE_PRINT (IDS_OPERATION_CANCELED);
               
                   return(S_OK);
            
             default: 
                   RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
                  
                   return(S_OK);    
             }
        }
    }
    
    //figure out partition DN
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               L"configurationNamingContext",
                               &pwszConfigurationDN ) ) {
      goto cleanup;
    }
    pwszPartitionDN = (PWCHAR) malloc(   sizeof(WCHAR)  
                                       * (  wcslen(L"CN=Partitions,")
                                          + wcslen(pwszConfigurationDN)
                                          + 1 )  );
    if (!pwszPartitionDN) {
        RESOURCE_PRINT(IDS_MEMORY_ERROR);
        goto cleanup;
    }

    wcscpy(pwszPartitionDN, L"CN=Partitions,");
    wcscat(pwszPartitionDN, pwszConfigurationDN);

    ReadAttributeQuiet( gldapDS,
                        pwszPartitionDN,
                        L"msDS-Behavior-Version",
                        &pwszCurNumber,
                        TRUE );

    // Ignore modify if behavior version is already set correctly
    // or we are preprocessing prior to raising the behavior version
    // (called from VerRaiseForestOptional())
    if (!pwszCurNumber || _wcsicmp(pwszCurNumber, pwszNumber)) {

        //LDAP modify
        ppVal[0] = pwszNumber;
        ppVal[1] = NULL;
        mod.mod_vals.modv_strvals = ppVal;
        mod.mod_op = LDAP_MOD_REPLACE;
        mod.mod_type = L"msDS-Behavior-Version";
        
        rMods[0] = &mod;
        rMods[1] = NULL;
        
        
        if ( LDAP_SUCCESS != (dwErr = ldap_modify_sW(gldapDS, pwszPartitionDN, rMods)) ) {
          //"ldap_modify_sW error 0x%x\n"
          //"Depending on the error code this may indicate a connection,\n"
          //"ldap, or role transfer error.\n"
        
          RESOURCE_PRINT2 (IDS_LDAP_MODIFY_ERR, dwErr, GetLdapErr(dwErr));
          goto cleanup;
        }
    }

    cleanup:
    FREE(pwszConfigurationDN);
    FREE(pwszPartitionDN);
    FREE(pwszCurNumber);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\jetutil.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "dsconfig.h"

#include <dsjet.h>
extern "C" {
#include "scheck.h"
}

#include "reshdl.h"
#include "resource.h"
#include "file.hxx"

//
// returns 0 on success and non-zero on failure.
//
int DoSoftRecovery (SystemInfo *pInfo)
{
    BOOL            fIsDir;
    int             retCode = 1;
    
    _try
    {
        // Check whether files exist.  We can recover with no logs, but
        // we at least need a DB file.

        if ( !pInfo->pszDbAll[0] )
        {
            //"No DB file specified in %s\\%s\n",
            RESOURCE_PRINT2 (IDS_ERR_NO_DB_FILE_SPECIFIED, DSA_CONFIG_SECTION,FILEPATH_KEY);
            _leave;
        }
        else if ( !ExistsFile(pInfo->pszDbAll, &fIsDir) )
        {
            //"Source file \"%s\" does not exist\n"
            RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_NOT_EXIST, pInfo->pszDbAll);
            _leave;
        }
        else if ( fIsDir )
        {
           //"Source \"%s\" is a directory, not a file\n"
           RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_IS_DIR, pInfo->pszDbAll);
            _leave;
        }
        else if ( gliZero.QuadPart == pInfo->cbDb.QuadPart )
        {
            //"Source file \"%s\" is empty\n"
            RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_EMPTY, pInfo->pszDbAll);
            _leave;
        }


        if ( OpenJet (pInfo->pszDbAll) != S_OK ) {
            _leave;
        }
        retCode = 0;
    
    }
    _finally
    {
        CloseJet();
    }
    printf("\n");

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\ipdeny.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "select.hxx"
#include "connect.hxx"
#include "ldapparm.hxx"
#include <winsock2.h>

#include "resource.h"

CParser denyParser;
BOOL    fDenyQuit;
BOOL    fDenyParserInitialized = FALSE;

//
// Forward references.
//

extern  HRESULT DenyHelp(CArgs *pArgs);
extern  HRESULT DenyQuit(CArgs *pArgs);
extern  HRESULT LdapShowDenyList(CArgs *pArgs);
extern  HRESULT DenyCommitChanges(CArgs *pArgs);
extern  HRESULT DenyCancelChanges(CArgs *pArgs);
extern  HRESULT DenyAddToList(CArgs *pArgs);
extern  HRESULT DenyDelFromList(CArgs *pArgs);
extern  HRESULT DenyTestIP(CArgs *pArgs);

#define NODE_MASK   0xFFFFFFFF      // 255.255.255.255
VOID
CleanupList(
    VOID
    );

BOOL
LdapGetDenyList(
    VOID
    );

BOOL
DottedDecimalToDword(
    IN PCHAR*   ppszAddress,
    IN DWORD *  pdwAddress,
    IN PCHAR    pszLast
    );

LIST_ENTRY DenyList;

// Build a table which defines our language.

LegalExprRes denyLanguage[] = 
{
    CONNECT_SENTENCE_RES

    {   L"?", 
        DenyHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        DenyHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        DenyQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Add %s %s",
        DenyAddToList,
        IDS_IPDENY_ADD_MSG, 0 },

    {   L"Delete %d",
        DenyDelFromList,
        IDS_IPDENY_DELETE_MSG, 0 },

    {   L"Show",
        LdapShowDenyList,
        IDS_IPDENY_SHOW_MSG, 0 },

    {   L"Test %s",
        DenyTestIP,
        IDS_IPDENY_TEST_MSG, 0 },

    {   L"Commit",
        DenyCommitChanges,
        IDS_IPDENY_COMMIT_MSG, 0 },

    {   L"Cancel",
        DenyCancelChanges,
        IDS_IPDENY_CANCEL_MSG, 0 }

};

HRESULT
DenyListMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fDenyParserInitialized )
    {
        InitializeListHead(&DenyList);

        cExpr = sizeof(denyLanguage) / sizeof(LegalExprRes);
        
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (denyLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }
    
        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = denyParser.AddExpr(denyLanguage[i].expr,
                                                denyLanguage[i].func,
                                                denyLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fDenyParserInitialized = TRUE;
    fDenyQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_IP_DENY);

    hr = denyParser.Parse(gpargc,
                          gpargv,
                          stdin,
                          stdout,
                          prompt,
                          &fDenyQuit,
                          FALSE,               // timing info
                          FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT DenyHelp(CArgs *pArgs)
{
    return(denyParser.Dump(stdout,L""));
}

HRESULT DenyQuit(CArgs *pArgs)
{
    fDenyQuit = TRUE;
    return(S_OK);
}

HRESULT 
DenyDelFromList(CArgs *pArgs)
{
    DWORD index;
    PLIST_ENTRY pEntry;
    BOOL fFound = FALSE;
    HRESULT hr;
    PLDAP_DENY_NODE node;

    if ( FAILED(hr = pArgs->GetInt(0, (int *)&index)) )
    {
       RESOURCE_PRINT (IDS_IPDENY_INDEXRETR_ERR);
       return(hr);
    }

    pEntry = DenyList.Flink;
    while ( pEntry != &DenyList ) {

        IN_ADDR addr;

        node = CONTAINING_RECORD(pEntry,
                                 LDAP_DENY_NODE,
                                 ListEntry);

        if ( node->Index == index ) {

            //
            // if we just added this, remove it.
            //

            fFound = TRUE;
            if ( node->fAdd ) {

                RemoveEntryList(pEntry);
            } else {
                node->fDelete = TRUE;
            }
        }

        pEntry = pEntry->Flink;
    }

    if ( fFound ) {
       RESOURCE_PRINT1 (IDS_IPDENY_MARK_DELETE, index);
    } else {
       RESOURCE_PRINT (IDS_IPDENY_INDEX_ERR);
    }

    LdapShowDenyList(pArgs);
    return(S_OK);
}

HRESULT 
DenyAddToList(CArgs *pArgs)
{
    DWORD mask;
    DWORD ipAddress;
    PLDAP_DENY_NODE node;
    HRESULT hr;
    const WCHAR* szAddress;
    const WCHAR* szMask;

    PCHAR p;
    CHAR tmpAddress[64];
    CHAR tmpMask[64];
    DWORD len, i;

    if ( !LdapGetDenyList( ) ) {
        return S_OK;
    }

    if ( FAILED(hr = pArgs->GetString(0, &szAddress)) )
    {
        RESOURCE_PRINT (IDS_IPDENY_POLICY_RETR_ERR);
        return(hr);
    }

    if ( FAILED(hr = pArgs->GetString(1, &szMask)) )
    {
        RESOURCE_PRINT (IDS_IPDENY_MASK_RETR_ERR);
        return(hr);
    }

    //
    // convert strings to dword
    //

    len = wcslen(szAddress);
    for ( i=0; i <=len; i++ ) {
        tmpAddress[i] = (CHAR)szAddress[i];
    }

    len = wcslen(szMask);
    for ( i=0; i <=len; i++ ) {
        tmpMask[i] = (CHAR)szMask[i];
    }

    p = tmpAddress;
    if ( !DottedDecimalToDword((PCHAR*)&p, &ipAddress, (PCHAR)tmpAddress + strlen(tmpAddress)) ) {
        RESOURCE_PRINT1 (IDS_IPDENY_INVALID_IP, tmpAddress);
        return S_OK;
    }

    p = tmpMask;
    if ( !DottedDecimalToDword((PCHAR*)&p, &mask, (PCHAR)tmpMask + strlen(tmpMask)) ) {
        if ( _stricmp(tmpMask, "NODE") == 0 ) {
            mask = NODE_MASK;
        } else {
            RESOURCE_PRINT1 (IDS_IPDENY_INVALID_MASK,   tmpMask);
            return S_OK;
        }
    }

    node = (PLDAP_DENY_NODE)LocalAlloc(LPTR, sizeof(LDAP_DENY_NODE));
    if ( node == NULL ) {
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        return E_FAIL;
    }

    node->IpAddress = ipAddress;
    node->Mask = mask;
    node->fAdd = TRUE;
    node->Index = (DWORD)-1;

    InsertHeadList(
               &DenyList,
               &node->ListEntry);

    LdapShowDenyList(pArgs);
    return S_OK;
}

HRESULT 
DenyTestIP(CArgs *pArgs)
{
    DWORD ipAddress;
    PLDAP_DENY_NODE node;
    HRESULT hr;
    const WCHAR* szAddress;
    DWORD i, len;
    CHAR tmpAddress[64];
    PLIST_ENTRY pEntry;

    if ( !LdapGetDenyList( ) ) {
        return S_OK;
    }

    if ( FAILED(hr = pArgs->GetString(0, &szAddress)) )
    {
        RESOURCE_PRINT (IDS_IPDENY_POLICY_RETR_ERR);
        return(hr);
    }

    //
    // convert strings to dword
    //

    len = wcslen(szAddress);
    for ( i=0; i <=len; i++ ) {
        tmpAddress[i] = (CHAR)szAddress[i];
    }

    //
    // check it.
    //

    ipAddress = inet_addr(tmpAddress);
    pEntry = DenyList.Flink;
    while ( pEntry != &DenyList ) {

        node = CONTAINING_RECORD(pEntry,
                                 LDAP_DENY_NODE,
                                 ListEntry);

        if ( !node->fDelete ) {

            if ( (node->Mask & ipAddress) == node->IpAddress ) {
                //"IP address %ws will be DENIED access.\n"
                RESOURCE_PRINT1 (IDS_IPDENY_IP_DENY, szAddress);
                return S_OK;
            }
        }

        pEntry = pEntry->Flink;
    }
    
    //"IP address %ws will be ALLOWED access.\n"
    RESOURCE_PRINT1 (IDS_IPDENY_IP_ALLOW, szAddress);
    return S_OK;
}

HRESULT 
LdapShowDenyList(CArgs *pArgs)
{
    PLIST_ENTRY pEntry;
    PLDAP_DENY_NODE node;
    DWORD index = 1;

    if ( !LdapGetDenyList( ) ) {
        return S_OK;
    }

    pEntry = DenyList.Flink;
    while ( pEntry != &DenyList ) {

        IN_ADDR addr;

        node = CONTAINING_RECORD(pEntry,
                                 LDAP_DENY_NODE,
                                 ListEntry);

        node->Index = index++;
        addr.s_addr = node->IpAddress;
        if ( node->fAdd ) {
            printf("*");
        } else if ( node->fDelete ) {
            printf("D");
        } else {
            printf(" ");
        }

        printf("[%d] %s", node->Index, inet_ntoa(addr));

        if ( node->Mask == NODE_MASK ) {
            printf("\tSINGLE NODE\n");
        } else {
            addr.s_addr = node->Mask;
            printf("\tGROUP MASK\t%s\n", inet_ntoa(addr));
        }
        pEntry = pEntry->Flink;
    }
    
    RESOURCE_PRINT (IDS_IPDENY_NOTE);

    return(S_OK);
}

BOOL
LdapGetDenyList(
    VOID
    )
{
    DWORD err;
    INT count;
    BOOL ok = FALSE;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PSTR                   *values = NULL;
    PLDAP_DENY_NODE         node;

    //
    //  See if we're already connected
    //

    if ( gldapDS == NULL ) {
        //"No LDAP connection established.\n"
        RESOURCE_PRINT (IDS_IPDENY_LDAP_CON_ERR);
        return FALSE;
    }

    //
    // if we already have a list, return success
    //

    if ( !IsListEmpty(&DenyList) ) {
        return TRUE;
    }
    
    //
    // Get the path for the policy
    //

    if ( !GetPolicyPath() ) {
        return FALSE;
    }

    atts[0] = L"ldapIpDenyList";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS, 
                         PolicyPath,
                         LDAP_SCOPE_BASE, 
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {

        //"ldap_search of ldapIpDenyList failed with %ws"
        RESOURCE_PRINT2 (IDS_IPDENY_LDAP_SEARCH_FAIL, err, GetLdapErr(err));
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry )
    {
        //"0 entries returned when reading Deny List\n"
        RESOURCE_PRINT (IDS_IPDENY_ZERO_LIST);
        goto exit;
    }

    values = ldap_get_values(gldapDS, entry, "ldapIpDenyList");

    if ( !values )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            ok = TRUE;
            goto exit;
        }

        //"Unable to get values for %ws\n"
        RESOURCE_PRINT1 (IDS_IPDENY_ZERO_LIST, atts[0]);
        goto exit;
    }
    
    count = 0;
    while ( values[count] != NULL ) {

        DWORD netAddress, netMask;
        PCHAR pszLast, p;
        
        node = (PLDAP_DENY_NODE)LocalAlloc(LPTR, sizeof(LDAP_DENY_NODE));
        if ( node == NULL ) {
           //"Unable to allocate memory\n"
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            goto exit;
        }

        p=values[count];
        pszLast = p + strlen(p);

        if ( !DottedDecimalToDword((PCHAR*)&p, &netAddress, (PCHAR)pszLast) ||
             !DottedDecimalToDword((PCHAR*)&p, &netMask, (PCHAR)pszLast) ) {

            //"Badly formatted pair %s\n"
            RESOURCE_PRINT1 (IDS_IPDENY_BAD_FORMAT_PAIR, values[count]);
            continue;
        }

        node->IpAddress = netAddress;
        node->Mask = netMask;
        node->fAdd = FALSE;
        node->Index = (DWORD)-1;

        InsertHeadList(
                   &DenyList,
                   &node->ListEntry);

        count++;
    }

    ok = TRUE;
exit:

    if ( values != NULL ) {
        ldap_value_free(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }
    return ok;

} // LdapGetDenyList

HRESULT 
DenyCancelChanges(CArgs *pArgs)
{
    CleanupList();
    return(S_OK);
}

HRESULT 
DenyCommitChanges(CArgs *pArgs)
{
    DWORD err;
    LDAPModW* mods[2];
    LDAPModW mod;
    DWORD i = 0;
    PWCHAR  *values;
    PWCHAR  buffer;

    BOOL fChange = FALSE;
    DWORD nAddresses = 0;
    PLIST_ENTRY pEntry;
    PLDAP_DENY_NODE node;

    //
    // Initialize LDAP structures
    //

    if ( IsListEmpty(&DenyList) ) {
        return S_OK;
    }

    pEntry = DenyList.Flink;
    while ( pEntry != &DenyList ) {

        IN_ADDR addr;

        nAddresses++;

        node = CONTAINING_RECORD(pEntry,
                                 LDAP_DENY_NODE,
                                 ListEntry);

        if ( node->fAdd || node->fDelete ) {
            fChange = TRUE;
        }

        pEntry = pEntry->Flink;
    }

    if ( !fChange ) {
        return S_OK;
    }

    //
    // See if we really need to change anything
    //

    values = (PWCHAR*)LocalAlloc(LPTR, (nAddresses+1) * sizeof(PWCHAR));
    buffer = (PWCHAR)LocalAlloc(LPTR, nAddresses * MAX_PATH * sizeof(WCHAR));
    if ( (values == NULL) || (buffer == NULL) ) {
        //"Unable to allocate memory for commit operation\n"
        RESOURCE_PRINT (IDS_IPDENY_MEM_COMMIT_ERR);

        goto exit;
    }

    ZeroMemory(values, (nAddresses + 1) * sizeof(PWCHAR));
    pEntry = DenyList.Flink;
    while ( pEntry != &DenyList ) {

        IN_ADDR addr;
        PCHAR p;
        PWCHAR q;

        node = CONTAINING_RECORD(pEntry,
                                 LDAP_DENY_NODE,
                                 ListEntry);

        if ( !node->fDelete ) {

            values[i] = buffer;
            buffer += MAX_PATH;

            addr.s_addr = node->IpAddress;

            if (NULL == (p = inet_ntoa(addr))) {
                //"Unable to allocate memory for commit operation\n"
                RESOURCE_PRINT (IDS_IPDENY_MEM_COMMIT_ERR);
                goto exit;
            }
            for (q = values[i];
                 *p != '\0';
                 q++, p++
                 ) {
                *q = (WCHAR) *p;
            }
            *(q++) = L'\0';

            wcscat(values[i], L" ");

            addr.s_addr = node->Mask;
            if (NULL == (p = inet_ntoa(addr))) {
                //"Unable to allocate memory for commit operation\n"
                RESOURCE_PRINT (IDS_IPDENY_MEM_COMMIT_ERR);
                goto exit;
            }
            for (;*p != '\0';
                 q++, p++
                 ) {
                *q = (WCHAR) *p;
            }
            *q = L'\0';
            i++;
        }

        pEntry = pEntry->Flink;
    }

    mods[0] = &mod;
    mods[1] = NULL;

    mod.mod_op = LDAP_MOD_REPLACE;
    mod.mod_type = L"ldapIpDenyList";
    mod.mod_values = values;

    err = ldap_modify_sW(gldapDS,
                        PolicyPath,
                        mods
                        );

    if ( err == LDAP_SUCCESS ) {
        DenyCancelChanges(pArgs);
    } else {
       //"ldap_modify of attribute ldapAdminLimits failed with %s"
       RESOURCE_PRINT2 (IDS_IPDENY_LDAP_ATTR_FAIL, err, GetLdapErr(err));
    }

exit:
    if (values != NULL ) {
        LocalFree(values);
    }

    if ( buffer != NULL ) {
        LocalFree(buffer);
    }
    LdapShowDenyList(pArgs);
    return(S_OK);

} // DenyCommitChanges

BOOL
DottedDecimalToDword(
    IN PCHAR*   ppszAddress,
    IN DWORD *  pdwAddress,
    IN PCHAR    pszLast
    )
/*++

Routine Description:

    Converts a dotted decimal IP string to it's network equivalent

    Note: White space is eaten before *pszAddress and pszAddress is set
    to the character following the converted address

    *** Copied from IIS 2.0 project ***
Arguments:

    ppszAddress - Pointer to address to convert.  White space before the
        address is OK.  Will be changed to point to the first character after
        the address
    pdwAddress - DWORD equivalent address in network order

    returns TRUE if successful, FALSE if the address is not correct

--*/
{
    CHAR *          psz;
    USHORT          i;
    ULONG           value;
    int             iSum =0;
    ULONG           k = 0;
    UCHAR           Chr;
    UCHAR           pArray[4];

    psz = *ppszAddress;

    //
    //  Skip white space
    //

    while ( *psz && !isdigit( *psz )) {
        psz++;
    }

    //
    //  Convert the four segments
    //

    pArray[0] = 0;

    while ( (psz != pszLast) && (Chr = *psz) && (Chr != ' ') ) {
        if (Chr == '.') {
            // be sure not to overflow a byte.
            if (iSum <= 0xFF) {
                pArray[k] = (UCHAR)iSum;
            } else {
                return FALSE;
            }

            // check for too many periods in the address
            if (++k > 3) {
                return FALSE;
            }
            pArray[k] = 0;
            iSum = 0;

        } else {
            Chr = Chr - '0';

            // be sure character is a number 0..9
            if ((Chr < 0) || (Chr > 9)) {
                return FALSE;
            }
            iSum = iSum*10 + Chr;
        }

        psz++;
    }

    // save the last sum in the byte and be sure there are 4 pieces to the
    // address
    if ((iSum <= 0xFF) && (k == 3)) {
        pArray[k] = (UCHAR)iSum;
    } else {
        return FALSE;
    }

    // now convert to a ULONG, in network order...
    value = 0;

    // go through the array of bytes and concatenate into a ULONG
    for (i=0; i < 4; i++ )
    {
        value = (value << 8) + pArray[i];
    }
    *pdwAddress = htonl( value );

    *ppszAddress = psz;

    return TRUE;
} // DottedDecimalToDword


VOID
CleanupList(
    VOID
    )
{
    PLIST_ENTRY pEntry;
    PLDAP_DENY_NODE node;

    while (!IsListEmpty(&DenyList)) {

        pEntry = RemoveHeadList(&DenyList);
        node = CONTAINING_RECORD(pEntry,
                                 LDAP_DENY_NODE,
                                 ListEntry);

        LocalFree(node);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\integrit.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "jetutil.hxx"
#include "resource.h"
#include <dbopen.h>

HRESULT 
Integrity(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Called by parser to perform Jet database integrity check.

  Parameters:

    pArgs - Pointer to argument block - ignored.

  Return Values:

    Always returns S_OK.

--*/
{
    SystemInfo      *pInfo;
    ExePathString   pszScript;
    ExePathString   pszEsentutlPath;
    FILE            *fp;
    BOOL            fIsDir;

    pInfo = GetSystemInfo();

    if ( !pInfo ) 
    {
        return(S_OK);
    }
    if (DoSoftRecovery (pInfo)) {
        RESOURCE_PRINT(IDS_ERR_SOFT_RECOVERY);
        return S_OK;
    }

    _try
    {
        // Check whether files exist.  We can integrity check with no logs,
        // but we at least need a DB file.

        if ( !pInfo->pszDbAll[0] )
        {
           RESOURCE_PRINT2 (IDS_ERR_NO_DB_FILE_SPECIFIED, DSA_CONFIG_SECTION, FILEPATH_KEY);              
            _leave;
        }
        else if ( !ExistsFile(pInfo->pszDbAll, &fIsDir) )
        {
           RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_NOT_EXIST, pInfo->pszDbAll);
            _leave;
        }
        else if ( fIsDir )
        {
           RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_IS_DIR, pInfo->pszDbAll);
            _leave;
        }
        else if ( gliZero.QuadPart == pInfo->cbDb.QuadPart )
        {
           RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_EMPTY, pInfo->pszDbAll);
            _leave;
        }

        // Make sure we have esentutl.exe on this machine.

        if ( !FindExecutable(ESE_UTILITY_PROGRAM, pszEsentutlPath) )
        {
            _leave;
        }

        // invoke esentutl with the following command-line params:
        //      /g - specifies integrity-check mode (MUST be first param)
        //      /o - suppresses "Microsoft Windows Database Utilities" logo

        const char * const  szCmdFmt        = "%s /g\"%s\" /o";
        const SIZE_T        cbCmdFmt        = strlen( szCmdFmt );           // buffer will be slighly over-allocated, big deal!
        const SIZE_T        cbEsentutlPath  = strlen( pszEsentutlPath );
        const SIZE_T        cbDbName        = strlen( pInfo->pszDbAll );
        char * const        szCmd           = (char *)alloca( cbCmdFmt      // over-allocated, so no need for +1 for null-terminator
                                                              + cbEsentutlPath
                                                              + cbDbName );

        // WARNING: assert no trailing backslash
        // because it would cause problems with the
        // surrounding quotes that we stick in
        // (a trailing backslash followed by the
        // end quote ends up getting interpreted as
        // an escape sequence)
        ASSERT( '\\' != pInfo->pszDbAll[ cbDbName-1 ] );

		sprintf( szCmd,
                 szCmdFmt,
                 pszEsentutlPath,
                 pInfo->pszDbAll );

        RESOURCE_PRINT1 (IDS_EXECUTING_COMMAND, szCmd);

        SpawnCommand (szCmd, pInfo->pszDbDir, NULL);

        RESOURCE_PRINT (IDS_INTEGRITY_SUCC_MSG);
    }
    _finally
    {
        FreeSystemInfo(pInfo);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\loser.c ===
/* Copyright 1999 by Microsoft Corp.  All Rights Reserved */

#include <NTDSpch.h>
#pragma hdrstop

#include <mdcodes.h>

#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <dsutil.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <mdlocal.h>

#include "scheck.h"
#include "reshdl.h"
#include "resource.h"
#include <winldap.h>
#include "utilc.h"

typedef struct _AttConfList {
    ATT_CONFLICT_DATA   Data;
    struct _AttConfList *pNext;
} AttConfList;

unsigned
FindSchemaConflicts(AttConfList **ppACList, unsigned *pnRead)
{

    HANDLE hEventLog;
    LPVOID lpvBuffer;
    DWORD cbBuffer, cbRead, cbRequired;
    EVENTLOGRECORD *pELR;
    DWORD cbOffset;
    DWORD nRead = 0;
    BOOL bSuccess;
    BYTE *pData;
    unsigned i;
    AttConfList *pACLnew, **ppACLtemp;
    unsigned err = ERROR_SUCCESS;

    *ppACList = NULL;

    hEventLog = OpenEventLog(NULL,
                             "NTDS General");
    if (NULL == hEventLog) {
        err = GetLastError();
        RESOURCE_PRINT1(IDS_SCH_REPAIR_LOG_ERROR, err);
        return err;
    }

    cbBuffer = 64*1024;
    lpvBuffer = LocalAlloc(LMEM_FIXED, cbBuffer);
    if (!lpvBuffer) {
        RESOURCE_PRINT(IDS_MEMORY_ERROR);
        CloseEventLog(hEventLog);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        bSuccess = ReadEventLog(hEventLog,
                                (EVENTLOG_BACKWARDS_READ |
                                 EVENTLOG_SEQUENTIAL_READ),
                                0,
                                lpvBuffer,
                                cbBuffer,
                                &cbRead,
                                &cbRequired);
        if (FALSE == bSuccess) {
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
                cbBuffer = cbRequired;
                lpvBuffer = LocalReAlloc(lpvBuffer, cbBuffer, LMEM_MOVEABLE);
                bSuccess = TRUE;
                continue;
            }
            break;
        }

        cbOffset = 0;

        while (cbOffset < cbRead) {
            pELR = (EVENTLOGRECORD *)((PBYTE)lpvBuffer + cbOffset);
            cbOffset += pELR->Length;
            ++nRead;

            if (pELR->EventID == DIRLOG_SCHEMA_ATT_CONFLICT) {
                RESOURCE_PRINT1(IDS_SCH_REPAIR_CONFLICT_FOUND,
                                pELR->RecordNumber);

                pData = (PBYTE)pELR + pELR->DataOffset;
                if (pELR->DataLength == sizeof(ATT_CONFLICT_DATA)) {
                    pACLnew = LocalAlloc(LMEM_FIXED, sizeof(AttConfList));
                    if (!pACLnew) {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                        goto Exit;
                    }
                    memcpy(&pACLnew->Data,
                           pData,
                           sizeof(ATT_CONFLICT_DATA));
                    if (pACLnew->Data.Version != 1) {
                        RESOURCE_PRINT(IDS_SCH_REPAIR_WRONG_VER);
                        LocalFree(pACLnew);
                        err = ERROR_OLD_WIN_VERSION;
                        goto Exit;
                    }
                    ppACLtemp = ppACList;
                    while (*ppACLtemp &&
                           memcmp(&pACLnew->Data.Guid,
                                  &((*ppACLtemp)->Data.Guid),
                                  sizeof(GUID))) {
                        ppACLtemp = &((*ppACLtemp)->pNext);
                    }
                    if (*ppACLtemp == NULL) {
                        /* We got to the end of the list without a dup */
                        *ppACLtemp = pACLnew;
                        pACLnew->pNext = NULL;
                    }
                    else {
                        /* We already found this logged conflict */
                        LocalFree(pACLnew);
                    }
                }
                else {
                    RESOURCE_PRINT(IDS_SCH_REPAIR_WRONG_VER);
                    err = ERROR_OLD_WIN_VERSION;
                    goto Exit;
                }
            }
        }
    } while (bSuccess);

  Exit:

    CloseEventLog(hEventLog);
    LocalFree(lpvBuffer);

    if (err) {
        AttConfList *pACL1, *pACL2;
        pACL1 = *ppACList;
        *ppACList = NULL;
        while (pACL1) {
            pACL2 = pACL1;
            pACL1 = pACL1->pNext;
            LocalFree(pACL2);
        }
    }

    if (pnRead) {
        *pnRead = nRead;
    }

    return err;
}

unsigned
FixAttributeConflict(ATT_CONFLICT_DATA *pACD,
                     BOOL *pbRefCountFixupRequired)
{
    JET_ERR jerr;
    BOOL bDnAtt;
    DWORD LinkId;
    JET_COLUMNDEF coldef;
    JET_COLUMNID cidLinkId, cidDNT, cidIsDel, cidDelTime, cidCN, cidRDN;
    JET_COLUMNID cidLinkBase, cidLinkDNT;
    DWORD attDNT, curDNT;
    unsigned long ulJunk1, ulJunk2;
    unsigned long IsDel;
    WCHAR *pwcsGuid;
    unsigned long len;
    DSTIME DelTime;

    if ( OpenJet(NULL) != S_OK ) {
        return 1;
    }

    if (OpenTable(TRUE, FALSE) != -1) {
        jerr = 2;
        goto Exit;
    }

    switch (pACD->AttSyntax) {
      case SYNTAX_DISTNAME_TYPE:
      case SYNTAX_DISTNAME_BINARY_TYPE:
      case SYNTAX_DISTNAME_STRING_TYPE:
        bDnAtt = TRUE;
        break;

      default:
        bDnAtt = FALSE;
    }

    jerr = JetBeginTransaction(sesid);
    if (jerr) {
        RESOURCE_PRINT2(IDS_JET_GENERIC_ERR1, "JetBeginTransaction",
                        GetJetErrString(jerr));
        goto ExitNoTrans;
    }


    /* determine some column ids */
    jerr = JetGetTableColumnInfo(sesid,
                                 tblid,
                                 SZDNT,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidDNT = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZDNT, GetJetErrString(jerr));
        goto Exit;
    }


    jerr = JetGetTableColumnInfo(sesid,
                                 tblid,
                                 SZLINKID,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidLinkId = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZLINKID, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetGetTableColumnInfo(sesid,
                                 tblid,
                                 SZISDELETED,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidIsDel = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZISDELETED, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetGetTableColumnInfo(sesid,
                                 tblid,
                                 SZDELTIME,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidDelTime = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZDELTIME, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetGetTableColumnInfo(sesid,
                                 tblid,
                                 SZCOMMONNAME,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidCN = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZCOMMONNAME, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetGetTableColumnInfo(sesid,
                                 tblid,
                                 SZRDNATT,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidRDN = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZRDNATT, GetJetErrString(jerr));
        goto Exit;
    }

    /* goto object by guid */
    jerr = JetSetCurrentIndex(sesid, tblid, SZGUIDINDEX);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex",
                         SZGUIDINDEX, GetJetErrString(jerr));
        goto Exit;
    }
    jerr = JetMakeKey(sesid,
                      tblid,
                      &pACD->Guid,
                      sizeof(GUID),
                      JET_bitNewKey);
    if (jerr) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetMakeKey",
                         GetJetErrString(jerr));
        goto Exit;
    }
    jerr = JetSeek(sesid, tblid, JET_bitSeekEQ);
    if (jerr) {
        char szGuid[40];
        RESOURCE_PRINT2(IDS_SCH_REPAIR_GUID_NOTFOUND,
                        DsUuidToStructuredString(&(pACD->Guid), szGuid),
                        GetJetErrString(jerr));
        jerr = 0;
        goto Exit;
    }

    /* read interesting data from attribute definition */
    jerr = JetRetrieveColumn(sesid,
                             tblid,
                             cidDNT,
                             &attDNT,
                             sizeof(attDNT),
                             &ulJunk1,
                             0,
                             NULL);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                         "DNT", GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetRetrieveColumn(sesid,
                             tblid,
                             cidLinkId,
                             &LinkId,
                             sizeof(LinkId),
                             &ulJunk1,
                             0,
                             NULL);
    if (jerr == JET_wrnColumnNull) {
        LinkId = 0;
    }
    else if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                         "LinkID", GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetRetrieveColumn(sesid,
                             tblid,
                             cidIsDel,
                             &IsDel,
                             sizeof(IsDel),
                             &ulJunk1,
                             0,
                             NULL);
    if (jerr == JET_wrnColumnNull) {
        IsDel = 0;
    }
    else if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                         "IsDeleted", GetJetErrString(jerr));
        goto Exit;
    }

    if (IsDel) {
        RESOURCE_PRINT1(IDS_SCH_REPAIR_ATT_NOTFOUND, pACD->AttID);
        goto Exit;
    }

    if (LinkId || bDnAtt) {
        *pbRefCountFixupRequired = TRUE;
    }

    /* Forcibly delete the attribute definition object */
    jerr = JetPrepareUpdate(sesid,
                            tblid,
                            JET_prepReplace);
    if (jerr) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate",
                         GetJetErrString(jerr));
        goto Exit;
    }


    /* Mark the object as deleted */
    IsDel = 1;
    jerr = JetSetColumn(sesid,
                        tblid,
                        cidIsDel,
                        &IsDel,
                        sizeof(IsDel),
                        0,
                        NULL);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetColumn",
                         "IsDeleted", GetJetErrString(jerr));
        goto Exit;
    }

    /* Set the deletion time to 1 */
    DelTime = 1;
    jerr = JetSetColumn(sesid,
                        tblid,
                        cidDelTime,
                        &DelTime,
                        sizeof(DelTime),
                        0,
                        NULL);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetColumn",
                         "DeletionTime", GetJetErrString(jerr));
        goto Exit;
    }

    /* Mangle the object name */
    UuidToStringW(&pACD->Guid, &pwcsGuid);
    len = wcslen(pwcsGuid);
    pwcsGuid[len] = BAD_NAME_CHAR;
    jerr = JetSetColumn(sesid,
                        tblid,
                        cidCN,
                        pwcsGuid,
                        len*sizeof(WCHAR),
                        0,
                        NULL);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetColumn",
                         "CommonName", GetJetErrString(jerr));
        goto Exit;
    }
    jerr = JetSetColumn(sesid,
                        tblid,
                        cidRDN,
                        pwcsGuid,
                        len*sizeof(WCHAR),
                        0,
                        NULL);
    pwcsGuid[len] = L'\0';
    RpcStringFreeW(&pwcsGuid);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetColumn",
                         "RDN", GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetUpdate(sesid,
                     tblid,
                     NULL,
                     0,
                     NULL);
    if ( jerr ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate",
                         GetJetErrString(jerr));
        goto Exit;
    }


    /* The definition of the attribute is gone, now we need to destroy
     * the values
     */
    if (LinkId) {
        unsigned long LinkBase, curLinkBase;

        LinkBase = MakeLinkBase(LinkId);

        jerr = JetGetTableColumnInfo(sesid,
                                     linktblid,
                                     SZLINKBASE,
                                     &coldef,
                                     sizeof(coldef),
                                     JET_ColInfo);
        cidLinkBase = coldef.columnid;
        if (jerr) {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                             SZLINKBASE, GetJetErrString(jerr));
            goto Exit;
        }

        jerr = JetSetCurrentIndex2(sesid,
                                   linktblid,
                                   SZLINKINDEX,
                                   JET_bitMoveFirst);
        if (jerr) {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex2",
                             SZLINKINDEX, GetJetErrString(jerr));
            goto Exit;
        }

        do {
            jerr = JetRetrieveColumn(sesid,
                                     linktblid,
                                     cidLinkBase,
                                     &curLinkBase,
                                     sizeof(curLinkBase),
                                     &len,
                                     JET_bitRetrieveFromIndex,
                                     NULL);

            if (jerr) {
                RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                                 "LinkBase", GetJetErrString(jerr));
                goto Exit;
            }
            if (curLinkBase == LinkBase) {
                jerr = JetDelete(sesid,
                                 linktblid);
                if (jerr) {
                    RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetDelete",
                                     GetJetErrString(jerr));
                    goto Exit;
                }
            }
            jerr = JetMove(sesid,
                           linktblid,
                           JET_MoveNext,
                           0);
        } while (jerr == JET_errSuccess);
    }
    else {
        char szName[20];

        sprintf(szName, SZATTINDEXPREFIX"%08X", pACD->AttID);
        JetDeleteIndex(sesid,
                       tblid,
                       szName);
        sprintf(szName, SZATTINDEXPREFIX"P_%08X", pACD->AttID);
        JetDeleteIndex(sesid,
                       tblid,
                       szName);
        sprintf(szName, "ATTa%d", pACD->AttID);
        szName[3] += (char)(pACD->AttSyntax);
        jerr = JetDeleteColumn(sesid,
                               tblid,
                               szName);
        if (jerr) {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetDeleteColumn",
                             szName, GetJetErrString(jerr));
            goto Exit;
        }
    }

    /* Destroy all links that the old attSchema had */

    jerr = JetGetTableColumnInfo(sesid,
                                 linktblid,
                                 SZLINKDNT,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidLinkDNT = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZLINKDNT, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetSetCurrentIndex2(sesid,
                               linktblid,
                               SZLINKINDEX,
                               JET_bitMoveFirst);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex2",
                         SZLINKINDEX, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetMakeKey(sesid,
                      linktblid,
                      &attDNT,
                      sizeof(attDNT),
                      JET_bitNewKey);
    if (jerr) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetMakeKey",
                         GetJetErrString(jerr));
        goto Exit;
    }
    jerr = JetSeek(sesid,
                   linktblid,
                   JET_bitSeekGE);
    if (jerr == JET_errSuccess || jerr == JET_wrnSeekNotEqual) {
        jerr = JetRetrieveColumn(sesid,
                                 linktblid,
                                 cidLinkDNT,
                                 &curDNT,
                                 sizeof(curDNT),
                                 &len,
                                 JET_bitRetrieveFromIndex,
                                 NULL);
        if (jerr) {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                             "LinkDNT", GetJetErrString(jerr));
            goto Exit;
        }
        while ((jerr == JET_errSuccess)
               && (attDNT == curDNT)) {
            *pbRefCountFixupRequired = TRUE;
            jerr = JetDelete(sesid,
                             linktblid);
            if (jerr) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetDelete",
                                 GetJetErrString(jerr));
                goto Exit;
            }
            jerr = JetMove(sesid,
                           linktblid,
                           JET_MoveNext,
                           0);
            if (jerr == JET_errSuccess) {
                jerr = JetRetrieveColumn(sesid,
                                         linktblid,
                                         cidLinkDNT,
                                         &curDNT,
                                         sizeof(curDNT),
                                         &len,
                                         JET_bitRetrieveFromIndex,
                                         NULL);
                if (jerr) {
                    RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                                     "LinkDNT", GetJetErrString(jerr));
                    goto Exit;
                }
            }
        }
    }

    /* And now destroy all backlinks that the old attSchema had */

    jerr = JetGetTableColumnInfo(sesid,
                                 linktblid,
                                 SZBACKLINKDNT,
                                 &coldef,
                                 sizeof(coldef),
                                 JET_ColInfo);
    cidLinkDNT = coldef.columnid;
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo",
                         SZBACKLINKDNT, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetSetCurrentIndex2(sesid,
                               linktblid,
                               SZBACKLINKINDEX,
                               JET_bitMoveFirst);
    if (jerr) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex2",
                         SZBACKLINKINDEX, GetJetErrString(jerr));
        goto Exit;
    }

    jerr = JetMakeKey(sesid,
                      linktblid,
                      &attDNT,
                      sizeof(attDNT),
                      JET_bitNewKey);
    if (jerr) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetMakeKey",
                         GetJetErrString(jerr));
        goto Exit;
    }
    jerr = JetSeek(sesid,
                   linktblid,
                   JET_bitSeekGE);
    if (jerr == JET_errSuccess || jerr == JET_wrnSeekNotEqual) {
        jerr = JetRetrieveColumn(sesid,
                                 linktblid,
                                 cidLinkDNT,
                                 &curDNT,
                                 sizeof(curDNT),
                                 &len,
                                 JET_bitRetrieveFromIndex,
                                 NULL);
        if (jerr) {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                             "BackLinkDNT", GetJetErrString(jerr));
            goto Exit;
        }
        while ((jerr == JET_errSuccess)
               && (attDNT == curDNT)) {
            *pbRefCountFixupRequired = TRUE;
            jerr = JetDelete(sesid,
                             linktblid);
            if (jerr) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetDelete",
                                 GetJetErrString(jerr));
                goto Exit;
            }
            jerr = JetMove(sesid,
                           linktblid,
                           JET_MoveNext,
                           0);
            if (jerr == JET_errSuccess) {
                jerr = JetRetrieveColumn(sesid,
                                         linktblid,
                                         cidLinkDNT,
                                         &curDNT,
                                         sizeof(curDNT),
                                         &len,
                                         JET_bitRetrieveFromIndex,
                                         NULL);
                if (jerr) {
                    RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetRetrieveColumn",
                                     "BackLinkDNT", GetJetErrString(jerr));
                    goto Exit;
                }
            }
        }
    }

    jerr = 0;

  Exit:
    if (0 == jerr) {
        jerr = JetCommitTransaction(sesid, 0);
        if ( jerr ) {
            RESOURCE_PRINT2(IDS_JET_GENERIC_ERR2,
                            "JetCommitTransaction",
                            GetJetErrString(jerr));
        }
    }
    else {
        JetRollback(sesid, 0);
    }

  ExitNoTrans:

    CloseJet();

    return jerr;
}

void DoRepairSchemaConflict(void)
{
    unsigned err, nRead;
    AttConfList *pACL, *pACLtmp;

    err = FindSchemaConflicts(&pACL, &nRead);

    if (err) {
        RESOURCE_PRINT1(IDS_SCH_REPAIR_FIND_FAILURE, err);
    }
    else {
        if (pACL) {
            char szGuid[40];
            BOOL bRefCountFixupRequired = FALSE;

            RESOURCE_PRINT1(IDS_SCH_REPAIR_FIND_TITLE, nRead);
            pACLtmp = pACL;
            while (pACLtmp) {
                RESOURCE_PRINT4(IDS_SCH_REPAIR_FIND_DETAIL,
                       pACLtmp->Data.AttID,
                       pACLtmp->Data.AttSyntax,
                       pACLtmp->Data.Version,
                       DsUuidToStructuredString(&(pACLtmp->Data.Guid),
                                                szGuid));
                pACLtmp = pACLtmp->pNext;
            }

            if ( fPopups ) {
                const WCHAR * message_body =
                  READ_STRING (IDS_SCH_REPAIR_CONFIRM_MSG);
                const WCHAR * message_title =
                  READ_STRING (IDS_SCH_REPAIR_CONFIRM_TITLE);

                if (message_body && message_title) {

                    int ret =  MessageBoxW(GetFocus(),
                                           message_body,
                                           message_title,
                                           MB_APPLMODAL |
                                           MB_DEFAULT_DESKTOP_ONLY |
                                           MB_YESNO |
                                           MB_DEFBUTTON2 |
                                           MB_ICONQUESTION |
                                           MB_SETFOREGROUND);

                    RESOURCE_STRING_FREE (message_body);
                    RESOURCE_STRING_FREE (message_title);

                    switch ( ret ) {
                      case IDYES:
                        break;

                      case IDNO:
                        RESOURCE_PRINT (IDS_OPERATION_CANCELED);
                        return;

                      default:
                        RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
                        return;
                    }
                }
            }

            pACLtmp = pACL;
            while (pACLtmp) {
                err = FixAttributeConflict(&pACLtmp->Data,
                                           &bRefCountFixupRequired);
                if (0 == err) {
                    RESOURCE_PRINT1(IDS_SCH_REPAIR_DEL_SUCCESS,
                           pACLtmp->Data.AttID);
                }
                else {
                    RESOURCE_PRINT2(IDS_SCH_REPAIR_DEL_FAILURE,
                           err,
                           pACLtmp->Data.AttID);
                }
                pACLtmp = pACLtmp->pNext;
            }
            if (bRefCountFixupRequired) {
                RESOURCE_PRINT(IDS_SCH_REPAIR_REF_FIXUP);
                StartSemanticCheck(TRUE, FALSE);
            }
        }
        else {
            RESOURCE_PRINT1(IDS_SCH_REPAIR_NONE_DETECTED, nRead);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\ldapparm.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "select.hxx"
#include "connect.hxx"
#include "ldapparm.hxx"

#include "resource.h"

CParser ldapParser;
BOOL    fLdapQuit;
BOOL    fLdapParserInitialized = FALSE;

//
// List of limits supported. Assume a max of 32.
//

#define DEF_POLICY_LIST_SIZE        32
PLDAP_LIMITS    gPolicy = NULL;
LDAP_LIMITS     PolicyList[DEF_POLICY_LIST_SIZE] = {0};
PWCHAR  PolicyPath = NULL;
DWORD nLdapLimits = 0;

#define POLICY_PATH L"CN=Default Query Policy,CN=Query-Policies,CN=Directory Service,CN=Windows NT,CN=Services,"

#define APPEND_VALUE(_i, _p, _v)    {\
    if ( gPolicy[(_i)].ValueType == LIMIT_BOOLEAN ) {   \
                                                        \
        wcscat((_p),                                    \
               ((_v) != 0) ? L"True" : L"False");       \
    } else {                                        \
        WCHAR buf[MAX_PATH];                        \
        _itow((_v),buf,10 );                        \
        wcscat((_p), buf);                          \
    }                                               \
}

//
// Forward references.
//

extern  HRESULT LdapHelp(CArgs *pArgs);
extern  HRESULT LdapQuit(CArgs *pArgs);
extern  HRESULT LdapListPolicies(CArgs *pArgs);
extern  HRESULT LdapShowValues(CArgs *pArgs);
extern  HRESULT LdapSetPolicy(CArgs *pArgs);
extern  HRESULT LdapCommitChanges(CArgs *pArgs);
extern  HRESULT LdapCancelChanges(CArgs *pArgs);

BOOL
FillValues(
    VOID
    );

BOOL
GetPolicyPath(
    VOID
    );

BOOL
ListPolicies(
    IN BOOL fPrint,
    IN PLDAP_LIMITS Limits,
    OUT PDWORD nLimits
    );

BOOL
LdapInitializePolicy(
    VOID
    );

// Build a table which defines our language.

LegalExprRes ldapLanguage[] =
{
    CONNECT_SENTENCE_RES

    {   L"?", 
        LdapHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        LdapHelp,
        IDS_HELP_MSG, 0  },

    {   L"Quit",
        LdapQuit,
        IDS_RETURN_MENU_MSG, 0  },

    {   L"List",
        LdapListPolicies,
        IDS_LDAP_POLICIES_LIST_MSG, 0 },

    {   L"Show Values",
        LdapShowValues,
        IDS_LDAP_POLICIES_SHOW_VAL_MSG, 0 },

    {   L"Commit Changes",
        LdapCommitChanges,
        IDS_LDAP_POLICIES_COMMIT_MSG, 0 },

    {   L"Cancel Changes",
        LdapCancelChanges,
        IDS_LDAP_POLICIES_CANCEL_MSG, 0 },

    {   L"Set %s to %s",
        LdapSetPolicy,
        IDS_LDAP_POLICIES_SET_VAL_MSG, 0 }

};

HRESULT
LdapMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fLdapParserInitialized )
    {
        cExpr = sizeof(ldapLanguage) / sizeof(LegalExprRes);
        
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (ldapLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.

        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = ldapParser.AddExpr(ldapLanguage[i].expr,
                                                ldapLanguage[i].func,
                                                ldapLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fLdapParserInitialized = TRUE;
    fLdapQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_LDAP_POLICY);

    hr = ldapParser.Parse(gpargc,
                          gpargv,
                          stdin,
                          stdout,
                          prompt,
                          &fLdapQuit,
                          FALSE,               // timing info
                          FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }
    
    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT LdapHelp(CArgs *pArgs)
{
    return(ldapParser.Dump(stdout,L""));
}

HRESULT LdapQuit(CArgs *pArgs)
{
    fLdapQuit = TRUE;
    return(S_OK);
}

HRESULT
LdapListPolicies(CArgs *pArgs)
{
    //
    // Initialize LDAP structures
    //

    if ( !LdapInitializePolicy() ) {
        return S_OK;
    }

    (VOID)ListPolicies(TRUE, NULL, NULL);
    return(S_OK);
}

HRESULT
LdapSetPolicy(CArgs *pArgs)
{
    DWORD i;
    HRESULT     hr;
    const WCHAR *pwszPolicy;
    const WCHAR *pwszVal;

    //
    // Initialize LDAP structures
    //

    if ( !LdapInitializePolicy() ) {
        return S_OK;
    }

    if ( FAILED(hr = pArgs->GetString(0, &pwszPolicy)) )
    {
        //"Unable to retrieve policy name\n"
        RESOURCE_PRINT (IDS_LDAP_POLICIES_NAME_ERR);
        return(hr);
    }

    if ( FAILED(hr = pArgs->GetString(1, &pwszVal)) )
    {
        //"Unable to retrieve policy value\n"
        RESOURCE_PRINT (IDS_LDAP_POLICIES_VALUE_ERR);
        return(hr);
    }

    for (i=0; i<nLdapLimits; i++) {

        if ( _wcsicmp(pwszPolicy, gPolicy[i].Name) != 0 ) {
            continue;
        }

        if ( gPolicy[i].ValueType == LIMIT_BOOLEAN ) {

            if ( _wcsicmp(pwszVal, L"TRUE") == 0 ) {
                gPolicy[i].NewValue = 1;
            } else if ( _wcsicmp(pwszVal, L"FALSE") == 0 ) {
                gPolicy[i].NewValue = 0;
            }
            break;
        } else {

            //
            // integer value
            //

            gPolicy[i].NewValue = _wtoi(pwszVal);
            break;
        }
    }

    if ( i == nLdapLimits ) {
        //"No such policy %ws\n"
        RESOURCE_PRINT1 (IDS_LDAP_POLICIES_NOTFOUND,
                   pwszPolicy);
    }

    return(S_OK);
}

HRESULT
LdapShowValues(CArgs *pArgs)
{

    DWORD i;

    //
    // Initialize LDAP structures
    //

    if ( !LdapInitializePolicy() ) {
        return S_OK;
    }

    FillValues( );

    //"\nPolicy\t\t\t\tCurrent(New)\n\n"
    RESOURCE_PRINT (IDS_LDAP_POLICIES_INFO);
    
    for (i=0; i< nLdapLimits; i++) {

        printf("%ws",gPolicy[i].Name);

        if ( gPolicy[i].ValueType == LIMIT_BOOLEAN ) {

            if ( gPolicy[i].CurrentValue == 0 ) {
                printf("\t\tFALSE");
            } else {
                printf("\t\tTRUE");
            }
        } else {
            printf("\t\t\t%d", gPolicy[i].CurrentValue);
        }

        if ( gPolicy[i].NewValue != 0xffffffff ) {

            if ( gPolicy[i].ValueType == LIMIT_BOOLEAN ) {
                if ( gPolicy[i].CurrentValue == 0 ) {
                    printf("(FALSE)");
                } else {
                    printf("(TRUE)");
                }
            } else {
                printf("(%d)\n", gPolicy[i].NewValue);
            }
        } else {
            printf("\n");
        }
    }
    printf("\n");

    return(S_OK);
}

BOOL
LdapInitializePolicy(
    VOID
    )
{
    DWORD nLimits = 0;

    //
    // if we already have a list, return success
    //

    if ( gPolicy != NULL ) {
        return TRUE;
    }

    //
    // Get the path for the policy
    //

    if ( !GetPolicyPath() ) {
        return FALSE;
    }

    //
    // Get the number of limits
    //

    nLimits = DEF_POLICY_LIST_SIZE;
    if ( ListPolicies(FALSE, PolicyList, &nLimits) ) {
        gPolicy = PolicyList;
        goto exit;
    }

    //
    // See if the buffer we passed was too small
    //

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

        //
        // Nothing we can do here.
        //

        //"ListPolicies returned %s\n");
        RESOURCE_PRINT2  (IDS_LDAP_POLICIES_LIST_ERR,
                    GetLastError(), GetW32Err(GetLastError()));
        return FALSE;
    }

#if DBG
    if ( nLimits < DEF_POLICY_LIST_SIZE ) {
          //"Got a new limit size %d smaller than the old one[%d]!\n",
          RESOURCE_PRINT2 (IDS_LDAP_POLICIES_LIMIT_ERR,
                      nLimits, DEF_POLICY_LIST_SIZE);
    }
#endif

    gPolicy = (PLDAP_LIMITS)LocalAlloc(LPTR, nLimits * sizeof(LDAP_LIMITS));
    if ( gPolicy == NULL ) {
        //"Unable to allocate %d bytes[%d] of memory\n"
        RESOURCE_PRINT2  (IDS_LDAP_POLICIES_MEMORY1_ERR, 
                    nLimits * sizeof(LDAP_LIMITS), nLimits);
        return FALSE;
    }

    //
    // now we can call it again.
    //

    if ( ListPolicies(FALSE, gPolicy, &nLimits) ) {
        LocalFree(gPolicy);
        gPolicy = NULL;
        //"ListPolicies failed with %s\n"
        RESOURCE_PRINT2  (IDS_LDAP_POLICIES_LIST_ERR,
                    GetLastError(), GetW32Err(GetLastError()));
        
        return FALSE;
    }

exit:
    for (DWORD i=0; i<nLimits; i++) {
        gPolicy[i].NewValue = 0xFFFFFFFF;
    }
    nLdapLimits = nLimits;
    return TRUE;


} // LdapInitializePolicy


VOID
LdapCleanupGlobals(
    VOID
    )
{
    //
    // free the policy list
    //

    if ( gPolicy != NULL ) {
        LocalFree(gPolicy);
        gPolicy = NULL;
    }

    if ( PolicyPath != NULL ) {
        LocalFree(PolicyPath);
        PolicyPath = NULL;
    }
    return;
} // LdapCleanupGlobals


HRESULT
LdapCancelChanges(CArgs *pArgs)
{
    DWORD i;

    if ( gPolicy != NULL ) {
        for (i=0; i< nLdapLimits; i++) {
            gPolicy[i].NewValue = 0xffffffff;
        }
    }
    return(S_OK);
}

HRESULT
LdapCommitChanges(CArgs *pArgs)
{

    DWORD err;
    LDAPModW* mods[2];
    LDAPModW mod;
    BOOL doModify = FALSE;
    DWORD i, j;
    PWCHAR  values[DEF_POLICY_LIST_SIZE+1];
    WCHAR  limits[DEF_POLICY_LIST_SIZE+1][MAX_PATH];

    //
    // Initialize LDAP structures
    //

    if ( !LdapInitializePolicy() ) {
        return S_OK;
    }

    FillValues( );

    //
    // See if we really need to change anything
    //

    ZeroMemory(values, sizeof(values));
    for (i=0, j=0;i<nLdapLimits;i++) {

        //
        // If this is an integer value whose
        // new value is zero, or the value hasn't
        // changed but it's old value was zero,
        // then don't write this value.
        //
        if (gPolicy[i].ValueType == LIMIT_INTEGER
            && (   
                   gPolicy[i].NewValue == 0
                || (   
                       gPolicy[i].NewValue == 0xffffffff
                    && gPolicy[i].CurrentValue == 0
                   )
               )
           )
        {
            //
            // Never set an Integer value to zero.
            //

            continue;
        }

        values[j] = limits[j];
        wcscpy(limits[j], gPolicy[i].Name);
        wcscat(limits[j], L"=");

        if ( gPolicy[i].NewValue != 0xffffffff) {
            doModify = TRUE;
            APPEND_VALUE(i, limits[j], gPolicy[i].NewValue);        

        } else {

            //
            // value has not changed
            //
            APPEND_VALUE(i, limits[j], gPolicy[i].CurrentValue);
            
        }
        j++;

    }

    if ( !doModify ) {
        //"No changes to commit.\n"
        RESOURCE_PRINT  (IDS_LDAP_POLICIES_NO_COMMIT);
        return S_OK;
    }

    mods[0] = &mod;
    mods[1] = NULL;

    mod.mod_op = LDAP_MOD_REPLACE;
    mod.mod_type = L"ldapAdminLimits";
    mod.mod_values = values;

    err = 0;
    err = ldap_modify_sW(gldapDS,
                        PolicyPath,
                        mods
                        );

    if ( err == LDAP_SUCCESS ) {
        LdapCancelChanges(pArgs);
    } else {
        //"ldap_modify of attribute ldapAdminLimits failed with %s"
        RESOURCE_PRINT2  (IDS_LDAP_POLICIES_MODIFY_ERR, 
                    err, GetLdapErr(err));
    }

    return(S_OK);
}


BOOL
ListPolicies(
    IN BOOL fPrint,
    IN PLDAP_LIMITS Limits,
    OUT PDWORD nLimits
    )
{
    INT count = -1;
    DWORD i = 0;
    DWORD err;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PWSTR                   *values = NULL;
    BOOL    ok = FALSE;
    DWORD   nGiven = 0;

    //
    // get the buffer size passed
    //

    if ( (Limits != NULL) && (*nLimits != 0) ) {
        nGiven = *nLimits;
    }

    atts[0] = L"supportedLdapPolicies";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS,
                         L"",
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {

        //"ldap_search of supportedLdapPolicies failed with %s"
        RESOURCE_PRINT2  (IDS_LDAP_POLICIES_SEARCH1_ERR, 
                    err, GetLdapErr(err));
        
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry )
    {
        //"No entries returned when reading %s\n"
        RESOURCE_PRINT1  (IDS_LDAP_POLICIES_NO_ENTRIES1, 
                    atts[0]);
        goto exit;
    }

    values = ldap_get_valuesW(gldapDS, entry, atts[0]);

    if ( !values )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            //"No rights to read Policies\n"
            RESOURCE_PRINT  (IDS_LDAP_POLICIES_NO_RIGHTS1);
            goto exit;
        }
        
        //"Unable to get values for %s\n"
        RESOURCE_PRINT1  (IDS_LDAP_POLICIES_RETRIVE_ERR, 
                    atts[0]);
        goto exit;
    }

    if ( fPrint ) {
        //"Supported Policies:\n"
        RESOURCE_PRINT (IDS_LDAP_POLICIES_SUPPORTED);
    }

    count = 0;

    while ( values[count] != NULL ) {
        if ( fPrint ) {
            printf("\t%ws\n", values[count]);
        }

        if ( count < (INT)nGiven ) {
            wcscpy(Limits[count].Name, values[count]);
            Limits[count].ValueType = LIMIT_INTEGER;
        }

        count++;
    }

    ok = TRUE;
    if ( nLimits != NULL ) {
        *nLimits = count;
    }

exit:
    if ( values != NULL ) {
        ldap_value_freeW(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }
    return(ok);

} // ListPolicies


BOOL
FillValues(
    VOID
    )
{
    DWORD err;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PWSTR                   *values = NULL;
    BOOL    ok = FALSE;
    DWORD count;

    atts[0] = L"ldapAdminLimits";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS,
                         PolicyPath,
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {
        //"ldap_search of ldapAdminLimits failed with %s"
        RESOURCE_PRINT2 (IDS_LDAP_POLICIES_SEARCH2_ERR, 
                    err, GetLdapErr(err));
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry )
    {
        //"0 entries returned when reading Policies\n"
        RESOURCE_PRINT (IDS_LDAP_POLICIES_NO_ENTRIES2);
        goto exit;
    }

    values = ldap_get_valuesW(gldapDS, entry, atts[0]);

    if ( !values )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            //"No rights to read Policies\n"
            RESOURCE_PRINT (IDS_LDAP_POLICIES_NO_RIGHTS1);
            goto exit;
        }
        
        //"Unable to get values for %s\n"
        RESOURCE_PRINT1  (IDS_LDAP_POLICIES_RETRIVE_ERR, 
                    atts[0]);
        goto exit;
    }

    count = 0;
    while ( values[count] != NULL ) {

        DWORD i;
        PWCHAR p;

        for (i=0; i< nLdapLimits; i++ ) {

            if ( _wcsnicmp(values[count], gPolicy[i].Name, wcslen(gPolicy[i].Name) ) == 0) {

                //
                // Get the value
                //

                p=wcschr(values[count],L'=');
                if (p != NULL) {
                    p++;

                    if ( gPolicy[i].ValueType == LIMIT_INTEGER ) {

                        gPolicy[i].CurrentValue = _wtoi(p);

                    } else {

                        if ( _wcsicmp(p, L"TRUE") == 0 ) {
                            gPolicy[i].CurrentValue = 1;
                        } else {
                            gPolicy[i].CurrentValue = 0;
                        }
                    }
                    break;
                }
            }
        }

        count++;
    }

    ok = TRUE;
exit:

    if ( values != NULL ) {
        ldap_value_freeW(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }
    return ok;

} // FillValues


BOOL
GetPolicyPath(
    VOID
    )
{

    DWORD err;
    PWSTR atts[2];
    PLDAPMessage ldapmsg = NULL;
    PLDAPMessage            entry = NULL;
    PWSTR                   *values = NULL;
    BOOL    ok = FALSE;

    if ( PolicyPath != NULL ) {
        return TRUE;
    }

    atts[0] = L"configurationNamingContext";
    atts[1] = NULL;

    err = ldap_search_sW(gldapDS,
                         L"",
                         LDAP_SCOPE_BASE,
                         L"(objectclass=*)",
                         atts,
                         0,
                         &ldapmsg
                         );

    if ( err != LDAP_SUCCESS ) {
        //"ldap_search of configurationNamingContext failed with %s"
        RESOURCE_PRINT2  (IDS_LDAP_POLICIES_SEARCH3_ERR, 
                    err, GetLdapErr(err));
        goto exit;
    }

    entry = ldap_first_entry(gldapDS, ldapmsg);

    if ( !entry ) {
        //"Unable to get entry from search\n"
        RESOURCE_PRINT  (IDS_LDAP_POLICIES_SEARCH_ENTRY_ERR);
        goto exit;
    }

    values = ldap_get_valuesW(gldapDS, entry, atts[0]);

    if ( !values || (values[0] == NULL) )
    {
        if ( LDAP_NO_SUCH_ATTRIBUTE == (err = gldapDS->ld_errno) )
        {
            //"No rights to read RootDSE\n"
            RESOURCE_PRINT  (IDS_LDAP_POLICIES_NO_RIGHTS2);
            goto exit;
        }

        //"Unable to get values for %s\n"
        RESOURCE_PRINT1  (IDS_LDAP_POLICIES_RETRIVE_ERR, atts[0]);
        goto exit;
    }

    PolicyPath =
        (PWCHAR)LocalAlloc(LPTR, (wcslen(values[0]) + wcslen(POLICY_PATH))*sizeof(WCHAR) +
                           sizeof(WCHAR));

    if ( PolicyPath == NULL ) {

        //"Cannot allocate memory for policy path\n"
        RESOURCE_PRINT  (IDS_LDAP_POLICIES_MEMORY2_ERR);
        goto exit;
    }

    wcscpy(PolicyPath, POLICY_PATH);
    wcscat(PolicyPath, values[0]);

    ok = TRUE;

exit:

    if ( values != NULL ) {
        ldap_value_freeW(values);
    }

    if ( ldapmsg != NULL ) {
        ldap_msgfree(ldapmsg);
    }

    return ok;

} // GetPolicyPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\parsedn.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    parsedn.c

Abstract:

    This file brings the functionality of dsamain\src\parsedn.c into this
    project in a very sneaky way that I stole from ntdsapi\parsedn.c.

    Note:  this file is almost complete stolen from ntdsapi\parsedn.c.
    
Author:

    Kevin Zatloukal (t-KevinZ) 10-08-98

Revision History:

    10-08-98 t-KevinZ
        Created.

--*/

void
errprintf(
    char *FormatString,
    ...
    );

int
errprintfRes(
    unsigned int FormatStringId,
    ...
    );

// Define the symbol which turns off varios capabilities in the original
// parsedn.c which we don't need or would pull in too many helpers which we
// don't want on the client side.  For example, we disable recognition of
// "OID=1.2.3.4" type tags and any code which uses THAlloc/THFree.

#define CLIENT_SIDE_DN_PARSING 1

// Include the original source in all its glory.
#include "..\..\ntdsa\src\parsedn.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\movedb.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "jetutil.hxx"
#include "resource.h"

void
GenerateDbScript(
    char            *pszSrcPath,
    char            *pszDstPath,    
    FILE            *fp
)
/*++

  Routine Description:

    Generates the script for moving a DB to another location.

  Parameters:

    pszSrcPath - Full path of source DB file.

    pszDstPath - Full path of destination DB file.

    fp - File pointer representing file to write to.

  Return Values:

    None.

--*/
{
    char    drive[4];
    char    *pszDir;
    char    *pTmp;

    // Identify what the script is doing.

    fprintf(    fp,
                "REM - **********************************************\n");
    fprintf(    fp, 
                "REM - Script to move DS DB file\n");
    fprintf(    fp,
                "REM - **********************************************\n\n");

    // Set working directory to the root of the destination drive.

    strncpy(drive, pszDstPath, 2);
    drive[2] = '\0';
    fprintf(fp, "%s\n", drive);
    fprintf(fp, "cd \\\n");

    // Create directories from root to destination dir.  mkdir 
    // doesn't fail, only complains, if directory already exists.

    pszDir = (char *) alloca(strlen(pszDstPath) + 1);
    strcpy(pszDir, pszDstPath);
    pszDir += 3;

    while ( pTmp = strchr(pszDir, (int) '\\') )
    {
        *pTmp = '\0';
        fprintf(fp, "mkdir \"%s\"\n", pszDir);
        fprintf(fp, "cd \"%s\"\n", pszDir);
        pszDir = pTmp + 1;
    }

    // Move the file as appropriate.
        
    fprintf(    fp, 
                "%s \"%s\" \"%s\"\n", 
                "move",
                pszSrcPath, 
                pszDstPath);

    // Fix up three registy entries - DB location, working dir, backup path.
    // We'll use default values for the working dir and backup path.
    // Sophisticated users can use "ntdsutil set path xxx yyy" to refine.

    fprintf(    fp, 
                "%s files \"set path DB \\\"%s\\\"\" quit quit\n", 
                gNtdsutilPath, 
                pszDstPath);
    pszDir = (char *) alloca(strlen(pszDstPath) + 1);
    strcpy(pszDir, pszDstPath);
    pTmp = strrchr(pszDir, (int) '\\');

    if ( pTmp )
    {
        *pTmp = '\0';
    }

    fprintf(    fp, 
                "%s files \"set path backup \\\"%s\\DSADATA.BAK\\\"\" quit quit\n", 
                gNtdsutilPath, 
                pszDir);
    fprintf(    fp, 
                "%s files \"set path working dir \\\"%s\\\"\" quit quit\n", 
                gNtdsutilPath, 
                pszDir);

    // Dump file information.

    fprintf(    fp,
                "%s files info quit quit\n", 
                gNtdsutilPath);

    // As per bug 163999 ...

    fprintf(    fp, "REM - **********************************************\n");
    fprintf(    fp, "REM - Please make a backup immediately else restore\n");
    fprintf(    fp, "REM - will not retain the new file location.\n");
    fprintf(    fp, "REM - **********************************************\n");
}
    
HRESULT 
MoveDb(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Moves a DB to the caller specified location.

  Parameters:

    pArgs - Argument block where 0th arg represents destination.

  Return Values:

    Always S_OK except when error reading arguments.

--*/
{
    const WCHAR     *pwszDstDir;
    char            *pszDstDir;
    char            *pszDstPath;
    HRESULT         hr;
    DWORD           i, cb;
    SystemInfo      *pInfo = NULL;
    FILE            *fp;
    char            *pszSrc;
    ExePathString   pszScript;
    BOOL            fIsDir;
    DiskSpaceString pszDiskSpace;
    DiskSpaceString pszDiskSpaceFree;
    char            pszDstDrive[4];
    char            *edbchkPath;

    if ( FAILED(hr = pArgs->GetString(0, &pwszDstDir)) ) 
    {
        return(hr);
    }

    // Convert arguments from WCHAR to CHAR.

    cb = wcslen(pwszDstDir) + 1;
    pszDstDir = (char *) alloca(cb);
    memset(pszDstDir, 0, cb);
    wcstombs(pszDstDir, pwszDstDir, wcslen(pwszDstDir));

    // Get system information.
    
    if ( !(pInfo = GetSystemInfo()) )
    {
        return(S_OK);
    }

    _try
    {
        // Check that old path is not new path.

        if ( !_stricmp(pszDstDir, pInfo->pszDbDir) )
        {
            //"Old and new paths the same - nothing to do.\n"
            RESOURCE_PRINT (IDS_ERR_OLD_NEW_PATHS_SAME);
            _leave;
        }

        // Check that destination corresponds to an existing drive.
        
        strncpy(pszDstDrive, pszDstDir, 3);
        pszDstDrive[3] = '\0';

        for ( i = 0; i < pInfo->cDrives; i++ )
        {
            if ( !_strnicmp(pInfo->rDrives[i].pszDrive, pszDstDir, 3) )
            {
                break;
            }
        }

        if ( i >= pInfo->cDrives )
        {
            //"%s does not correspond to a local drive\n"
            RESOURCE_PRINT1 (IDS_ERR_NO_LOCAL_DRIVE, pszDstDir);
            _leave;
        }

        if ( pInfo->rDrives[i].driveType != DRIVE_FIXED) {
            RESOURCE_PRINT1 (IDS_ERR_NO_LOCAL_DRIVE, pszDstDir);
            _leave;
        }


        // Verify we have a source.

        if ( !pInfo->pszDbAll[0] )
        {
            //"No DB file specified in %s\\%s\n",
            RESOURCE_PRINT2 (IDS_ERR_NO_DB_FILE_SPECIFIED,
                       DSA_CONFIG_SECTION,
                       FILEPATH_KEY);
            _leave;
        }
        else if ( !ExistsFile(pInfo->pszDbAll, &fIsDir) )
        {
            //"Source file \"%s\" does not exist\n"
            RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_NOT_EXIST,
                          pInfo->pszDbAll);
            _leave;
        }
        else if ( fIsDir )
        {
            //"Source \"%s\" is a directory, not a file\n"
            RESOURCE_PRINT1 (IDS_ERR_SOURCE_FILE_IS_DIR,
                          pInfo->pszDbAll);
            _leave;
        }


        // Emit warning if disk space is low relative to DB size.
        // Variable i is still at matching drive.

        if ( pInfo->rDrives[i].dwFreeBytes.QuadPart < pInfo->cbDb.QuadPart )
        {
           FormatDiskSpaceString(&pInfo->cbDb, pszDiskSpace);
           FormatDiskSpaceString(&pInfo->rDrives[i].dwFreeBytes, pszDiskSpaceFree);
           
           RESOURCE_PRINT3 (IDS_MOVE_DB_DISK_SPACE_ERR, pszDiskSpace, pszDstDrive, pszDiskSpaceFree);
           _leave;
        }


        // Don't let admin overwrite an existing file.

        pszDstPath = (CHAR *) alloca( 
            sizeof(CHAR) * (strlen(pszDstDir) + strlen(pInfo->pszDbFile) + 4));

        strcpy(pszDstPath, pszDstDir);
        strcat(pszDstPath, "\\");
        strcat(pszDstPath, pInfo->pszDbFile);

        if ( ExistsFile(pszDstPath, &fIsDir) )
        {
            //"Destination \"%s\" already exists - please remove\n"
            RESOURCE_PRINT1 (IDS_ERR_FILE_EXISTS,
                            pszDstPath);
            _leave;
        }

        // Do soft recovery
        //
        if (DoSoftRecovery (pInfo)) {
            RESOURCE_PRINT(IDS_ERR_SOFT_RECOVERY);
            _leave;
        }

        // Open script file.

        if ( !(fp = OpenScriptFile(pInfo, pszScript)) )
        {
            _leave;
        }

        GenerateDbScript(   pInfo->pszDbAll,
                            pszDstPath, 
                            fp);

        fclose(fp);
        SpawnCommandWindow("NTDS Move DB Script", pszScript);

        // delete unneeded edb.chk file (checkpoint file). 
        // it will be created in new location after the soft recovery.
        edbchkPath = (CHAR *) alloca( sizeof(CHAR) * (strlen(pInfo->pszDbAll) + 10));
        strcpy(edbchkPath, pInfo->pszSystem);
        strcat(edbchkPath, "\\");
        strcat(edbchkPath, "edb.chk");

        DeleteFile (edbchkPath);

        // SystemInfo has changed so reread it.
        //
        FreeSystemInfo(pInfo);
        pInfo = 0;

        if ( !(pInfo = GetSystemInfo()) )
            _leave;

        // Do soft recovery (2nd time)
        //
        if (DoSoftRecovery (pInfo)) {
            RESOURCE_PRINT(IDS_ERR_SOFT_RECOVERY);
            _leave;
        }

        RESOURCE_PRINT (IDS_MOVE_DB_SUCC_MSG);
    }
    _finally
    {
        if ( pInfo ) FreeSystemInfo(pInfo);
    }
    
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\movelogs.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "jetutil.hxx"
#include "resource.h"

void
GenerateLogScript(
    LogInfo         *pLogInfo,
    char            *pszSrc,
    char            *pszDst,    
    FILE            *fp
    )
/*++

  Routine Description:

    Generate a script for moving NTDS log files.

  Parameters:

    pLogInfo - Pointer to linked list of LogInfo structs which identify
        the log files to move.

    pszSrc - Directory in which the log files currently reside.

    pszDst - Directoty in which to place the log files.

    fp - Open FILE pointer where script commands are to be written.

  Return Values:

    None.

--*/
{
    char    drive[4];
    char    *pszDir;
    char    *pTmp;
    LogInfo *pLogInfoSave = pLogInfo;

    // Identify what the script is doing.

    fprintf(    fp,
                "REM - **********************************************\n");
    fprintf(    fp, 
                "REM - Script to move DS log files\n");
    fprintf(    fp,
                "REM - **********************************************\n\n");

    // Set working directory to the root of the destination drive.

    strncpy(drive, pszDst, 2);
    drive[2] = '\0';
    fprintf(fp, "%s\n", drive);
    fprintf(fp, "cd \\\n");

    // Create directories from root to destination dir.  mkdir 
    // doesn't fail, only complains, if directory already exists.

    pszDir = (char *) alloca(strlen(pszDst) + 1);
    strcpy(pszDir, pszDst);
    pszDir += 3;
    pTmp = pszDir;

    while ( TRUE )
    {
        if ( pTmp = strchr(pszDir, (int) '\\') )
        {
            *pTmp = '\0';
        }

        fprintf(fp, "mkdir \"%s\"\n", pszDir);
        fprintf(fp, "cd \"%s\"\n", pszDir);

        if ( !pTmp )
        {
            break;
        }

        pszDir = pTmp + 1;
    }

    // Move the files as appropriate.

    for ( ; pLogInfo; pLogInfo = pLogInfo->pNext ) 
    {
        fprintf(    fp, 
                    "%s \"%s\\%s\" \"%s\\%s\"\n", 
                    "move", 
                    pszSrc, 
                    pLogInfo->findData.cFileName,
                    pszDst,
                    pLogInfo->findData.cFileName);
    }

    // Fix up log directory registy entries.

    fprintf(    fp, 
                "%s files \"set path logs \\\"%s\\\"\" quit quit\n", 
                gNtdsutilPath, 
                pszDst);

    // Dump file information.

    fprintf(    fp, 
                "%s files info quit quit\n", 
                gNtdsutilPath);

    // As per bug 163999 ...

    fprintf(    fp, "REM - **********************************************\n");
    fprintf(    fp, "REM - Please make a backup immediately else restore\n");
    fprintf(    fp, "REM - will not retain the new file location.\n");
    fprintf(    fp, "REM - **********************************************\n");
}
    
HRESULT 
MoveLogs(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Routine called by parser to change location of log files.

  Parameters:

    pArgs - Pointer to argument block - 0th arg identifies destination.

  Return Values:

    S_OK or error retreiving arguments.

--*/
{
    const WCHAR     *pwszDst;
    char            *pszDst;
    HRESULT         hr;
    DWORD           i, cb;
    SystemInfo      *pInfo = NULL;
    FILE            *fp;
    ExePathString   pszScript;
    BOOL            fIsDir;
    LogInfo         *pLogInfo;
    char            buf[MAX_PATH];
    BOOL            fAbort;
    DiskSpaceString pszDiskSpace;
    DiskSpaceString pszDiskSpaceFree;
    char            pszDstDrive[4];

    if ( FAILED(hr = pArgs->GetString(0, &pwszDst)) ) 
    {
        return(hr);
    }

    // Convert arguments from WCHAR to CHAR.

    cb = wcslen(pwszDst) + 1;
    pszDst = (char *) alloca(cb);
    memset(pszDst, 0, cb);
    wcstombs(pszDst, pwszDst, wcslen(pwszDst));

    // Get system information.
    
    if ( !(pInfo = GetSystemInfo()) ) 
    {
        return(S_OK);
    }
    _try
    {
        // Check that old path is not new path.

        if ( !_stricmp(pszDst, pInfo->pszLogDir) ) 
        {
           //"Old and new paths the same - nothing to do.\n"
           RESOURCE_PRINT (IDS_ERR_OLD_NEW_PATHS_SAME);
            _leave;
        }

        strncpy(pszDstDrive, pszDst, 3);
        pszDstDrive[3] = '\0';

        // Check that destination corresponds to an existing drive.

        for ( i = 0; i < pInfo->cDrives; i++ ) 
        {
            if ( !_strnicmp(pInfo->rDrives[i].pszDrive, pszDst, 3) ) 
        {
                break;
            }
        }

        if ( i >= pInfo->cDrives ) 
        {
            //"%s does not correspond to a local drive\n"
            RESOURCE_PRINT1 (IDS_ERR_NO_LOCAL_DRIVE, pszDst);
            _leave;
        }
        
        if ( pInfo->rDrives[i].driveType != DRIVE_FIXED) {
            RESOURCE_PRINT1 (IDS_ERR_NO_LOCAL_DRIVE, pszDst);
            _leave;
        }


        // Verify we have a source.

        if ( !pInfo->pszLogDir[0] )
        {
            //"No log files specified in %s\\%s\n"
            RESOURCE_PRINT2 (IDS_ERR_NO_LOGS_SPECIFIED,
                       DSA_CONFIG_SECTION,
                       LOGPATH_KEY);
            _leave;
        }
        else if ( !ExistsFile(pInfo->pszLogDir, &fIsDir) )
        {
            //"Source directory \"%s\" does not exist\n"
            RESOURCE_PRINT1 (IDS_ERR_DIR_NOT_EXIST,
                          pInfo->pszLogDir);
            _leave;
        }
        else if ( !fIsDir )
        {
            //"Source \"%s\" is not a directory\n"
            RESOURCE_PRINT1 (IDS_ERR_SOURCE_NOT_DIR,
                          pInfo->pszLogDir);
            _leave;
        }
        else if ( !pInfo->pLogInfo ) 
        {
            //"No logs in source directory \"%s\"\n",
            RESOURCE_PRINT1 (IDS_ERR_NO_LOGS_IN_SOURCE,
                          pInfo->pszLogDir);
            _leave;
        }

        // Emit warning if disk space is low relative to DB size.
        // Variable i is still at matching drive.

        if ( pInfo->rDrives[i].dwFreeBytes.QuadPart < pInfo->cbLogs.QuadPart )
        {
           FormatDiskSpaceString(&pInfo->cbLogs, pszDiskSpace);
           FormatDiskSpaceString(&pInfo->rDrives[i].dwFreeBytes, pszDiskSpaceFree);
           
           RESOURCE_PRINT3 (IDS_MOVE_LOGS_DISK_SPACE_ERR, pszDiskSpace, pszDstDrive, pszDiskSpaceFree);
           _leave;
        }


        // Abort if we will be overwriting any files in the destination.

        pLogInfo = pInfo->pLogInfo;
        fAbort = FALSE;

        for ( ; pLogInfo; pLogInfo = pLogInfo->pNext ) 
        {
            strcpy(buf, pszDst);
            strcat(buf, "\\");
            strcat(buf, pLogInfo->findData.cFileName);

            if ( ExistsFile(buf, &fIsDir) )
            {
                if ( !fAbort )
                {
                    RESOURCE_PRINT1 (IDS_ERR_LOG_FILE_EXISTS,
                                 pszDst);
                }

                printf( "\t\t%s\n",
                        pLogInfo->findData.cFileName);
                fAbort = TRUE;
            }
        }

        if ( fAbort )
        {
            _leave;
        }
    
        // ready for soft recovery
        //
        if (DoSoftRecovery (pInfo)) {
            RESOURCE_PRINT(IDS_ERR_SOFT_RECOVERY);
            _leave;
        }

        // Open script file.

        if ( !(fp = OpenScriptFile(pInfo, pszScript)) ) {
            _leave;
        }

        GenerateLogScript(  pInfo->pLogInfo,
                            pInfo->pszLogDir, 
                            pszDst, 
                            fp);
        fclose(fp);
        SpawnCommandWindow("NTDS Move Logs Script", pszScript);

        FreeSystemInfo(pInfo);
        pInfo = 0;

        if ( !(pInfo = GetSystemInfo()) )
            _leave;

        // ready for soft recovery (2nd time)
        //
        if (DoSoftRecovery (pInfo)) {
            RESOURCE_PRINT(IDS_ERR_SOFT_RECOVERY);
            _leave;
        }

        RESOURCE_PRINT (IDS_MOVE_LOGS_SUCC_MSG);
    }
    _finally
    {
        if ( pInfo) FreeSystemInfo(pInfo);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\parsedn.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    parsedn.h

Abstract:

    This file contains the declarations of the functions I use from
    parsedh.c.

Author:

    Kevin Zatloukal (t-KevinZ) 10-08-98

Revision History:

    10-08-98 t-KevinZ
        Created.

--*/


#ifndef _PARSEDN_H_
#define _PARSEDN_H_


#ifdef __cplusplus
extern "C" {
#endif

    
unsigned
CountNameParts(
    const DSNAME *pName,
    unsigned *pCount
    );

ATTRTYP
KeyToAttrTypeLame(
    WCHAR * pKey,
    unsigned cc
    );

unsigned
StepToNextDNSep(
    const WCHAR * pString,
    const WCHAR * pLastChar,
    const WCHAR **ppNextSep,
    const WCHAR **ppStartOfToken,
    const WCHAR **ppEqualSign
    );

unsigned
GetTopNameComponent(
    const WCHAR * pName,
    unsigned ccName,
    const WCHAR **ppKey,
    unsigned *pccKey,
    const WCHAR **ppVal,
    unsigned *pccVal
    );

unsigned
UnquoteRDNValue(
    const WCHAR * pQuote,
    unsigned ccQuote,
    WCHAR * pVal
    );

BOOL
IsRoot(
    const DSNAME *pName
    );


#ifdef __cplusplus
}
#endif

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\recover.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "resource.h"
#include <dbopen.h>


HRESULT 
Recover(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Called by parser to perform soft database recovery.

  Parameters:

    pArgs - Pointer to argument block - ignored.

  Return Values:

    Always returns S_OK.

--*/
{
    SystemInfo      *pInfo;
    ExePathString   pszScript;
    ExePathString   pszEsentutlPath;
    FILE            *fp;
    BOOL            fIsDir;

    pInfo = GetSystemInfo();

    if ( !pInfo ) 
    {
        return(S_OK);
    }

    _try
    {
        // Check whether log files exist.  We can recover with no database
        // or checkpoint file, but we at least need log files.

        if ( !pInfo->pszLogDir[0] )
        {
            //"No log files specified in %s\\%s\n"
            RESOURCE_PRINT2( IDS_ERR_NO_LOGS_SPECIFIED,
                             DSA_CONFIG_SECTION,
                             LOGPATH_KEY );
            _leave;
        }
        else if ( !ExistsFile( pInfo->pszLogDir, &fIsDir ) )
        {
            //"Source directory \"%s\" does not exist\n"
            RESOURCE_PRINT1( IDS_ERR_DIR_NOT_EXIST,
                             pInfo->pszLogDir );
            _leave;
        }
        else if ( !fIsDir )
        {
            //"Source \"%s\" is not a directory\n"
            RESOURCE_PRINT1( IDS_ERR_SOURCE_NOT_DIR,
                             pInfo->pszLogDir );
            _leave;
        }
        else if ( !pInfo->pLogInfo ) 
        {
            //"No logs in source directory \"%s\"\n",
            RESOURCE_PRINT1( IDS_ERR_NO_LOGS_IN_SOURCE,
                             pInfo->pszLogDir );
            _leave;
        }

        // Make sure we have esentutl.exe on this machine.

        if ( !FindExecutable(ESE_UTILITY_PROGRAM, pszEsentutlPath) )
        {
            _leave;
        }

        // invoke esentutl with the following command-line params:
        //      /redb - specifies recovery mode (MUST be first param), with logfile basename of "edb"
        //      /l - specifies logfile path
        //      /s - specifies system path
        //      /8 - specifies 8k database pages
        //      /o - suppresses "Microsoft Windows Database Utilities" logo

        const char * const  szCmdFmt        = "%s /redb /l\"%s\" /s\"%s%s\" /8 /o";
        const SIZE_T        cbCmdFmt        = strlen( szCmdFmt );           // buffer will be slighly over-allocated, big deal!
        const SIZE_T        cbEsentutlPath  = strlen( pszEsentutlPath );
        const SIZE_T        cbLogDir        = strlen( pInfo->pszLogDir );
        const SIZE_T        cbSystemDir     = strlen( pInfo->pszSystem );
        char * const        szCmd           = (char *)alloca( cbCmdFmt      // over-allocated, so no need for +1 for null-terminator
                                                              + cbEsentutlPath
                                                              + cbLogDir
                                                              + cbSystemDir );

        // WARNING: assert no trailing backslash
        // on the logfile path because it would
        // cause problems with the surrounding
        // quotes that we stick in (a trailing
        // (backslash followed by the end quote
        // ends up getting interpreted as an
        // escape sequence)
        // Note that we know that the logfile
        // path cannot have a trailing backslash
        // because the path is validated using
        // ExistsFile() above. That function
        // uses FindFirstFile() to perform the
        // validation, and FirdFirstFile() will
        // always err out if a trailing backslash
        // is present.
        ASSERT( '\\' != pInfo->pszLogDir[ cbLogDir-1 ] );

        // if no system path specified, use current dir
        // (which will be pszDbDir due to the manner in
        // which we spawn esentutl)

        if ( cbSystemDir > 0 )
        {
            // WARNING: must account for trailing
            // backslash on the system path because
            // it would cause problems with the
            // surrounding quotes that we stick in
            // (a trailing backslash followed by the
            // end quote ends up getting interpreted
            // as an escape sequence)
            // Note that there's no need to do the
            // same for the logfile path (see above
            // for explanation why there can't be a
            // trailing backslash on the logfile path)

            sprintf( szCmd,
                     szCmdFmt,
                     pszEsentutlPath,
                     pInfo->pszLogDir,
                     pInfo->pszSystem,
                     ( '\\' == pInfo->pszSystem[ cbSystemDir-1 ] ? "." : "" ) );
        }
        else
        {
            sprintf( szCmd,
                     "%s /redb /l\"%s\" /8 /o",
                     pszEsentutlPath,
                     pInfo->pszLogDir );
        }

        RESOURCE_PRINT1 (IDS_EXECUTING_COMMAND, szCmd);

        SpawnCommand (szCmd, pInfo->pszLogDir, NULL);

        RESOURCE_PRINT (IDS_RECOVER_SUCC_MSG);
    }
    _finally
    {
        FreeSystemInfo(pInfo);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\main.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include <locale.h>
#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "ldapparm.hxx"
#include "confset.hxx"

#include "resource.h"


int             *gpargc = NULL;
char            ***gpargv = NULL;

LARGE_INTEGER   gliZero;
LARGE_INTEGER   gliOneKb;
LARGE_INTEGER   gliOneMb;
LARGE_INTEGER   gliOneGb;
LARGE_INTEGER   gliOneTb;
ExePathString   gNtdsutilPath;

CParser         gParser;
BOOL            gfQuit;


// Build a table which defines our language.

LegalExprRes language[] = 
{
    {   L"?",
        Help,
        IDS_HELP_MSG, 0 },

    {   L"Help",
        Help,
        IDS_HELP_MSG, 0 },


    {   L"Quit",
        Quit,
        IDS_QUIT_MSG, 0 },

    {   L"Metadata cleanup",
        RemoveMain,
        IDS_METADATA_CLEANUP_MSG, 0 },

    {   L"Files",
        FileMain,
        IDS_FILES_MSG, 0  },

    {   L"Roles",
        FsmoMain,
        IDS_ROLES_MSG, 0  },

    {   L"Popups %s",
        Popups,
        IDS_POPUPS_MSG, 0  },

    {   L"Semantic database analysis",
        SCheckMain,
        IDS_SEMANTIC_DB_ANALYSIS_MSG, 0 },

    {   L"Domain management",
        DomMgmtMain,
        IDS_DOMAIN_MGNT_MSG, 0  },

    {   L"LDAP policies",
        LdapMain,
        IDS_LDAP_POLICIES_MSG, 0  },

    {   L"Configurable Settings",
        ConfSetMain,
        IDS_CONFSET_MSG, 0  },

    {   L"IPDeny List",
        DenyListMain,
        IDS_IPDENY_LIST_MSG, 0 },

    {   L"Authoritative restore",
        AuthoritativeRestoreMain,
        IDS_AUTH_RESTORE_MSG, 0 }, 

    {   L"Security account management", 
        SamMain, 
        IDS_SAM_MSG, 0 },

    {   L"Behavior version management",
        VerMain,
        IDS_VER_MSG, 0 }
};

VOID
DeriveOurPath(
    char    *argv0
    )
/*++

  Routine Description:

    Derives the path to our own executable so we can reference it later on.
    This is required as the spawned scripts either may not have ntdsutil.exe's
    location in their path, or the customer has renamed ntdsutil.exe.

  Parameters:

    argv0 - argv[0] as in main().

  Return Values:

    None.
--*/
{
    char    *pTmp;
    char    pExe[MAX_PATH];
    int     i;

    // Extract just the exe name w/o any leading paths.

    if ( pTmp = strrchr(argv0, (int) '\\') )
    {
        pTmp++;
    }
    else
    {
        pTmp = argv0;
    }

    // Append ".exe" if not there.

    strcpy(pExe,pTmp);

    if (    ((i = strlen(pExe)) <= 4)
         || _stricmp(&pExe[i-4], ".exe") )
    {
        strcat(pExe, ".exe");
    }
    
    if ( !FindExecutable(pExe, gNtdsutilPath) )
    {
        exit(1);
    }
}


int _cdecl main(
    int     argc, 
    char    *argv[]
    )
{
    HRESULT hr;
    WCHAR   prompt[MAX_PATH+10];
    int     cExpr;
    char    *pTmp;

    UINT Codepage;
    char achCodepage[12] = ".OCP";      // ".", "uint in decimal", null
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    swprintf (prompt, L"%hs:", argv[0]);

    cExpr = sizeof(language) / sizeof(LegalExprRes);

    // Init some globals.

    gpargc = &argc;
    gpargv = &argv;

    DeriveOurPath(argv[0]);

    gliZero.QuadPart = 0;
    gliOneKb.QuadPart = 1024;
    gliOneMb.QuadPart = (gliOneKb.QuadPart * gliOneKb.QuadPart);
    gliOneGb.QuadPart = (gliOneMb.QuadPart * gliOneKb.QuadPart);
    gliOneTb.QuadPart = (gliOneGb.QuadPart * gliOneKb.QuadPart);

    
    // Set Console Window Attributes
    SetConsoleAttrs();
    
    // Read All Strings from Resource Database
    int count = ReadAllStrings ();
    if (count == 0) {
        fprintf (stderr, "ERROR reading resource file. Exiting.\n\n");
        return 0;
    }
    
    // Init Error Messages
    InitErrorMessages();
    

    // Read in our language.
    //

    // Load String from resource file
    //
    if ( FAILED (hr = LoadResStrings (language, cExpr)) )
    {
         RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
         return (hr);
    }


    for ( int i = 0; i < cExpr; i++ )
    {
        if ( FAILED(hr = gParser.AddExpr(language[i].expr,
                                         language[i].func,
                                         language[i].help)) )
        {
            RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
            return(hr);
        }
    }

    gfQuit = FALSE;

    // take care of the /? command line argument
    //
    if (argc == 2) {
        if (strcmp (argv[1], "/?") == 0) {
            RESOURCE_PRINT (IDS_HELP_MSG_BANNER1);
            RESOURCE_PRINT (IDS_HELP_MSG_BANNER2);
            
            Help (NULL);

            goto exit_gracefully;
        }
    }
    
    
    // Advance past program name.
    (*gpargc) -= 1;
    (*gpargv) += 1;

    


    hr = gParser.Parse(gpargc,
                       gpargv,
                       stdin,
                       stdout,
                       prompt,
                       &gfQuit,
                       FALSE,               // timing info
                       FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }


    // Cleanup things
exit_gracefully:
    
    LdapCleanupGlobals();
    ConnectCleanupGlobals();

    FreeErrorMessages();
    FreeAllStrings();

    return(hr);
}

HRESULT Help(CArgs *pArgs)
{
    return(gParser.Dump(stdout,L""));
}

HRESULT Quit(CArgs *pArgs)
{
    gfQuit = TRUE;
    return(S_OK);
}

HRESULT Popups(CArgs *pArgs)
{
    const WCHAR *pwszVal;
    HRESULT     hr;

    if ( FAILED(hr = pArgs->GetString(0, &pwszVal)) )
    {
        return(hr);
    }

    const WCHAR * message_on = READ_STRING (IDS_ON);
    const WCHAR * message_off = READ_STRING (IDS_OFF);


    if ( !_wcsicmp(message_on, pwszVal) )
    {
        fPopups = TRUE;

        RESOURCE_PRINT (IDS_POPUPS_ENABLED);
    }

    else if ( !_wcsicmp(message_off, pwszVal) )
    {
        fPopups = FALSE;
        
        RESOURCE_PRINT (IDS_POPUPS_DISABLED);
    }

    else
    {
       RESOURCE_PRINT (IDS_INVALID_ON_OFF);
    }

    RESOURCE_STRING_FREE (message_on);
    RESOURCE_STRING_FREE (message_off);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\refc.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <mdlocal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <objids.h>
#include "scheck.h"
#include "crc32.h"

#include "reshdl.h"
#include "resource.h"

DWORD       bDeleted;
DWORD       insttype;
BYTE        bObject;
ULONG       ulDnt;
ULONG       ulPdnt;
ULONG       ulDName;
ULONG       ulNcDnt;
DSTIME      DelTime;
GUID        Guid;
SYSTEMTIME  NowTime;
ATTRTYP     ClassId;

PDNAME_TABLE_ENTRY pDNameTable = NULL;
DWORD   DnameTableSize = 0;

JET_RETRIEVECOLUMN *jrc = NULL;
DWORD jrcSize = 0;
PDWORD AncestorBuffer = NULL;
PWCHAR szRdn = NULL;

#define COLS    14
JET_RETRIEVECOLUMN jrcf[COLS] =  {
    {0, &ulDnt, sizeof(ulDnt), 0, 0, 0, 1, 0, 0},
    {0, &ulPdnt, sizeof(ulPdnt), 0, 0, 0, 1, 0, 0},
    {0, &ClassId, sizeof(ClassId), 0, 0, 0, 1, 0, 0},
    {0, &bObject, sizeof(bObject), 0, 0, 0, 1, 0, 0},
    {0, &lCount, sizeof(lCount), 0, 0, 0, 1, 0, 0},
    {0, &bDeleted, sizeof(bDeleted), 0, 0, 0, 1, 0, 0},
    {0, &insttype, sizeof(insttype), 0, 0, 0, 1, 0, 0},
    {0, &ulNcDnt, sizeof(ulNcDnt), 0, 0, 0, 1, 0, 0},
    {0, NULL, sizeof(WCHAR)*512, 0, 0, 0, 1, 0, 0},
    {0, NULL, 2048, 0, 0, 0, 1, 0, 0},
    {0, NULL, sizeof(DWORD)*1024, 0, 0, 0, 1, 0, 0},
    {0, &DelTime, sizeof(DelTime), 0, 0, 0, 1, 0, 0},
    {0, &Guid, sizeof(Guid), 0, 0, 0, 1, 0, 0},
    {0, &ulDName, sizeof(ulDName), 0, 0, 0, 1, 0, 0}
};

#define PDNT_ENTRY          1
#define REFC_ENTRY          4
#define NCDNT_ENTRY         7
#define IT_ENTRY            COLS-8
#define RDN_ENTRY           COLS-6
#define SD_ENTRY            COLS-5
#define ANCESTOR_ENTRY      COLS-4
#define DELTIME_ENTRY       COLS-3
#define GUID_ENTRY          COLS-2
#define OBJ_DNAME_ENTRY     COLS-1


#define DEF_SUBREF_ENTRIES  16

char *szColNames[] = {
    SZDNT,
    SZPDNT,
    SZOBJCLASS,
    SZOBJ,
    SZCNT,
    SZISDELETED,
    SZINSTTYPE,
    SZNCDNT,
    SZRDNATT,
    SZNTSECDESC,
    SZANCESTORS,
    SZDELTIME,
    SZGUID,
    "ATTb49"        // obj dist name
};

DWORD   NcDntIndex = 0;
DWORD   GuidIndex = 0;
DWORD   DeltimeIndex = 0;
DWORD   AncestorIndex = 0;
DWORD   SdIndex = 0;
DWORD   rdnIndex = 0;
DWORD   itIndex = 0;
DWORD   subRefcolid = 0;

PREFCOUNT_ENTRY RefTable = NULL;
DWORD   RefTableSize = 0;

DWORD deletedFound = 0;
DWORD phantomFound = 0;
DWORD realFound = 0;
DWORD recFound = 0;

BOOL fDisableSubrefChecking = FALSE;    // should we check the subrefs

JET_ERR
GotoDnt(
    IN DWORD Dnt
    );

VOID
AddToSubRefList(
    PREFCOUNT_ENTRY pParent,
    DWORD Subref,
    BOOL fListed
    );

BOOL
FixSubref(
    IN DWORD Dnt,
    IN DWORD SubRef,
    IN BOOL  fAdd
    );

BOOL
FixRefCount(
    IN DWORD Dnt,
    IN DWORD OldCount,
    IN DWORD NewCount
    );

VOID
CheckSubrefs(
    IN BOOL fFixup
    );

VOID
CheckForBogusReference(
    IN DWORD Dnt,
    IN JET_COLUMNID ColId,
    IN PDWORD pSequence
    );

VOID
FixReferences(
    VOID
    );

VOID
CheckForBogusReferenceOnLinkTable(
    IN DWORD Dnt
    );

VOID XXX();

VOID
DoRefCountCheck(
    IN DWORD nRecs,
    IN BOOL fFixup
    )
{
    JET_ERR err;
    DWORD i;
    DWORD checkPoint;
    PREFCOUNT_ENTRY pEntry;
    PREFCOUNT_ENTRY pCurrentEntry;

    GetLocalTime(&NowTime);
    if ( !BuildRetrieveColumnForRefCount() ) {
        return;
    }

    //
    // Allocate our in memory structure
    //

    if ( nRecs < 50 ) {
        checkPoint = 5;
    } else if (nRecs < 1000) {
        checkPoint = 50;
    } else {
        checkPoint = 100;
    }

    RefTableSize = ROUND_ALLOC(nRecs);

    RefTable = LocalAlloc(LPTR, sizeof(REFCOUNT_ENTRY) * RefTableSize );
    if ( RefTable == NULL ) {
        //"Cannot allocate memory for %hs Table[entries = %d]\n"
        RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "Ref", RefTableSize);
        goto exit;
    }

    RefTable[0].Dnt = 0xFFFFFFFF;
    RefTable[0].Actual = 1;

    deletedFound = 0;
    phantomFound = 0;
    realFound = 0;
    recFound = 0;

    //"Records scanned: %10u"
    RESOURCE_PRINT1 (IDS_REFC_REC_SCANNED, recFound);

    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while ( !err ) {

        szRdn[0] = L'\0';
        ulDName = 0;
        bDeleted = 0;
        bObject = 0;
        insttype = 0;
        ulNcDnt = 0;
        ClassId = 0;

do_again:
        err = JetRetrieveColumns(sesid, tblid, jrc, jrcSize);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"JetRetrieveColumns error: %S.\n", GetJetErrString(err));
            goto next_rec;
        }

        //
        // See if we have enough.
        //

        if ( err == JET_wrnBufferTruncated ) {

            for (i=0; i < jrcSize ;i++) {

                if ( jrc[i].err == JET_wrnBufferTruncated ) {

                    if ( ExpandBuffer(&jrc[i]) ) {
                        szRdn = (PWCHAR)jrc[rdnIndex].pvData;
                        AncestorBuffer = (PDWORD)jrc[AncestorIndex].pvData;
                        goto do_again;
                    }
                }
            }
        }

        //printf("got dnt %d pdnt %d count %d\n", ulDnt, ulPdnt, lCount);

        pCurrentEntry = pEntry = FindDntEntry(ulDnt,TRUE);
        pEntry->Actual += lCount;
        pEntry->InstType = (WORD)insttype;
        pEntry->NcDnt = ulNcDnt;
        pEntry->fDeleted = bDeleted;
        pEntry->fObject = bObject;

        //
        // null terminate the rdn
        //

        szRdn[jrc[rdnIndex].cbActual/sizeof(WCHAR)] = L'\0';

        if ( ulDnt != 1 ) {

            //
            // Check the ancestor Blob
            //

            CheckAncestorBlob(pEntry);

            //
            // Check the security descriptor
            //

            ValidateSD( );
        }

        if ( (jrc[itIndex].err == JET_wrnColumnNull) && bObject ) {

            //
            // DNT == 1 is the NOT_AN_OBJECT object
            //

            if ( ulDnt != 1 ) {
                Log(TRUE,"No Instancetype for Dnt %d[%ws]\n",ulDnt, szRdn);
            }
        }

        //
        // ref the PDNT
        //

        if ( !jrc[PDNT_ENTRY].err ) {

            pEntry->Pdnt = ulPdnt;
            pEntry = FindDntEntry(ulPdnt,TRUE);
            pEntry->RefCount++;

        } else if ( ulDnt != 1 ) {

            Log(TRUE, "Dnt %d [%ws] does not have a PDNT\n", ulDnt, szRdn);
        }

        //
        // see if we need to process subrefs
        //

        if ( !jrc[NcDntIndex].err &&
             (insttype & IT_NC_HEAD) &&
             (ulDnt != ulNcDnt) &&
             (!bDeleted) ) {

            pEntry = FindDntEntry(ulNcDnt,TRUE);

            //
            // if this is an NC head, then it must be a subref of another NC head.
            // Add to the list.
            //

            AddToSubRefList(pEntry, ulDnt, FALSE);
        }

        //
        // everyone has an RDN
        //

        if ( jrc[rdnIndex].err ) {
            Log(TRUE, "Dnt %d does not have an RDN\n",ulDnt);
        }

        //
        // go through the entire list and ref the DNTs
        //

        for (i=0;i < jrcSize; i++) {

            //
            // Syntax is zero if this is not a distname
            //

            if ( pDNameTable[i].Syntax == 0 ) {
                continue;
            }

            if ( !jrc[i].err ) {

                DWORD dnt;
                DWORD seq;

                dnt = (*((PDWORD)jrc[i].pvData));

                //
                // Find the entry and reference it.
                //

                pEntry = FindDntEntry(dnt,TRUE);
                pEntry->RefCount++;

                //
                // See if we have more values
                //

                if ( jrc[i].columnid == subRefcolid ) {

                    AddToSubRefList( pCurrentEntry, dnt, TRUE );
                }

                seq = 1;
                do {

                    DWORD alen;
                    JET_RETINFO retInfo;

                    retInfo.itagSequence = ++seq;
                    retInfo.cbStruct = sizeof(retInfo);
                    retInfo.ibLongValue = 0;
                    err = JetRetrieveColumn(sesid,
                                            tblid,
                                            jrc[i].columnid,
                                            jrc[i].pvData,
                                            jrc[i].cbData,
                                            &alen,
                                            0,
                                            &retInfo);

                    if ( !err ) {

#if 0
                        if ( jrc[i].cbActual != 4 ) {
                            PCHAR p = jrc[i].pvData;
                            DWORD j;
                            for (j=0;j<28;j++) {
                                printf("%02X ", (UCHAR)p[j]);
                            }
                        }
#endif
                        dnt = (*((PDWORD)jrc[i].pvData));
                        pEntry = FindDntEntry(dnt,TRUE);
                        pEntry->RefCount++;

                        //
                        // add to subref list
                        //

                        if ( jrc[i].columnid == subRefcolid ) {

                            AddToSubRefList( pCurrentEntry, dnt, TRUE );
                        }
                    }

                } while (!err);
            } else {
                if ( jrc[i].err != JET_wrnColumnNull) {
                    Log(TRUE,"JetRetrieveColumn error[%S] [Colid %d Size %d]\n",
                            GetJetErrString(jrc[i].err),
                            jrc[i].columnid, jrc[i].cbActual);
                }
            }
        }

        //
        // Check object and phantom properties
        //

        if ( bObject ) {

            //
            // A real object has both an object name and a GUID
            //

            if ( (ulDName == 0) && (ulDnt != 1) ) {
                Log(TRUE,
                    "Real object[DNT %d(%ws)] has no distinguished name!\n", ulDnt, szRdn);
            }

            if ( jrc[GuidIndex].err ) {
                Log(TRUE, "Cannot get GUID for object DNT %d(%ws). Jet Error [%S]\n",
                       ulDnt, szRdn, GetJetErrString(jrc[GUID_ENTRY].err));
            }

            if ( lCount == 0 ) {
                Log(TRUE, "DNT %d(%ws) has zero refcount\n",ulDnt, szRdn);
            }

            //
            // if this is deleted, the check the deletion date
            //

            if ( bDeleted ) {

                CheckDeletedRecord("Deleted");
                deletedFound++;
            } else {
                realFound++;
            }

        } else {

            phantomFound++;

            //
            // Should have no GUID or object dist name
            //

            if ( ulDName != 0 ) {
                Log(TRUE, "The phantom %d(%ws) has a distinguished name!\n",
                    ulDnt, szRdn);
            }

            if ( bDeleted ) {
                Log(TRUE, "Phantom %d(%ws) has deleted bit turned on!\n", ulDnt,szRdn);
            }

            ValidateDeletionTime("Phantom");
        }

        //
        // Check the object's replication blob
        //

        if ( bObject ) {
            CheckReplicationBlobs( );
        }

next_rec:

        recFound++;

        if ( (recFound % checkPoint) == 0 ) {
            printf("\b\b\b\b\b\b\b\b\b\b%10u", recFound);
        }

        err = JetMove(sesid, tblid, JET_MoveNext, 0);
    }

    if (err != JET_errNoCurrentRecord) {
        Log(TRUE, "Error while walking data table. Last Dnt = %d. JetMove failed [%S]\n",
             ulDnt, GetJetErrString(err));
    }

    RESOURCE_PRINT (IDS_REFC_PROC_RECORDS);

    //
    // Get references from the link table
    //

    ProcessLinkTable( );

    fprintf(stderr,".");

    //
    // Print results
    //

    ProcessResults(fFixup);
    RESOURCE_PRINT (IDS_DONE);

exit:
    if ( jrc != NULL ) {

        if ( jrc[SdIndex].pvData != NULL ) {
            LocalFree(jrc[SdIndex].pvData);
        }

        if ( jrc[rdnIndex].pvData != NULL ) {
            LocalFree(jrc[rdnIndex].pvData);
        }

        if ( jrc[AncestorIndex].pvData != NULL ) {
            LocalFree(jrc[AncestorIndex].pvData);
        }

        LocalFree(jrc);
    }

    if ( RefTable != NULL ) {
        LocalFree(RefTable);
    }

    if ( pDNameTable != NULL ) {
        LocalFree(pDNameTable);
    }

} // DoRefCountCheck



PREFCOUNT_ENTRY
FindDntEntry(
    IN DWORD Dnt,
    IN BOOL fInsert
    )
{
    DWORD slot;
    DWORD inc;
    PREFCOUNT_ENTRY table = RefTable;
    PREFCOUNT_ENTRY entry;

    slot = Dnt & REFCOUNT_HASH_MASK;
    if ( Dnt == 0 ) {
        goto exit;
    }

    while ( slot < RefTableSize ) {

        entry = &table[slot];

        if ( entry->Dnt == Dnt ) {

            goto exit;

        } else if ( entry->Dnt == 0 ) {

            if ( fInsert ) {
                entry->Dnt = Dnt;
                goto exit;
            } else {
                return NULL;
            }
        }

        slot += REFCOUNT_HASH_INCR;
    }

    //
    // ok, we failed to get a slot on the first level hashing.
    // now do a secondary hash
    //

    inc = GET_SECOND_HASH_INCR(Dnt);

    while (TRUE ) {

        slot += inc;

        if ( slot >= RefTableSize ) {
            slot -= RefTableSize;
        }
        entry = &table[slot];

        if ( entry->Dnt == Dnt ) {
            goto exit;

        } else if ( entry->Dnt == 0 ) {

            if ( fInsert ) {
                entry->Dnt = Dnt;
                goto exit;
            } else {
                return NULL;
            }
        }
    }

exit:
    return &RefTable[slot];

} // FindDntEntry


BOOL
BuildRetrieveColumnForRefCount(
    VOID
    )
{
    DWORD i;

    JET_ERR err;
    JET_COLUMNLIST jcl;
    JET_RETRIEVECOLUMN ajrc[2];
    JET_TABLEID newtid;
    CHAR achColName[50];
    DWORD colCount;
    JET_COLUMNID jci;
    DWORD syntax;

    //
    // First do the required fields
    //

    colCount = COLS;
    DnameTableSize = colCount + 32;

    pDNameTable = LocalAlloc(LPTR,
                     DnameTableSize * sizeof(DNAME_TABLE_ENTRY));

    if ( pDNameTable == NULL ) {
        //"Cannot allocate memory for %hs Table[entries = %d]\n"
        RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "DName", DnameTableSize);
        return FALSE;
    }

    for (i=0; i < COLS; i++) {

        JET_COLUMNDEF coldef;
        if (err = JetGetTableColumnInfo(sesid, tblid, szColNames[i], &coldef,
                sizeof(coldef), 0)) {

            //"%hs [%hs] failed with [%ws].\n",
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo", szColNames[i], GetJetErrString(jrc[i].err));
            return FALSE;
        }

        //printf("Name %s ColumnId %d type %d\n", szColNames[i], coldef.columnid, coldef.coltyp);

        jrcf[i].columnid = coldef.columnid;
        pDNameTable[i].ColId = coldef.columnid;
        pDNameTable[i].Syntax = 0;
        pDNameTable[i].pValue = &jrcf[i];
    }

    err = JetGetColumnInfo(sesid, dbid, SZDATATABLE, 0, &jcl,
                           sizeof(jcl), JET_ColInfoList);

    if ( err ) {
            //"%hs [%hs] failed with [%ws].\n",
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetColumnInfo",
                SZDATATABLE, GetJetErrString(jrc[i].err));
        return FALSE;
    }

    // Ok, now walk the table and extract info for each column.  Whenever
    // we find a column that looks like an attribute (name starts with ATT)
    // allocate an attcache structure and fill in the jet col and the att
    // id (computed from the column name).
    ZeroMemory(ajrc, sizeof(ajrc));

    ajrc[0].columnid = jcl.columnidcolumnid;
    ajrc[0].pvData = &jci;
    ajrc[0].cbData = sizeof(jci);
    ajrc[0].itagSequence = 1;
    ajrc[1].columnid = jcl.columnidcolumnname;
    ajrc[1].pvData = achColName;
    ajrc[1].cbData = sizeof(achColName);
    ajrc[1].itagSequence = 1;

    //
    // Go through the column list table
    //

    newtid = jcl.tableid;
    err = JetMove(sesid, newtid, JET_MoveFirst, 0);

    while (!err) {

        ZeroMemory(achColName, sizeof(achColName));
        err = JetRetrieveColumns(sesid, newtid, ajrc, 2);
        if ( err ) {
            //"%hs failed with [%ws].\n"
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumn", GetJetErrString(err));
            continue;
        }
#if 0
        if ( jci == 790) {
            printf("name is %s\n",achColName);
        }
#endif
        if (strncmp(achColName,"ATT",3)) {
            // not an att column

            err = JetMove(sesid, newtid, JET_MoveNext, 0);
            continue;
        }

        syntax = achColName[3] - 'a';
        if ( (syntax == SYNTAX_DISTNAME_TYPE) ||
             (syntax == SYNTAX_DISTNAME_BINARY_TYPE) ||
             (syntax == SYNTAX_DISTNAME_STRING_TYPE) ) {

            // printf("found an ATTname %s col %d\n", achColName, jci);

            if ( colCount >= DnameTableSize ) {

                PVOID tmp;
                DnameTableSize = colCount + 63;
                tmp = LocalReAlloc(pDNameTable,
                                       DnameTableSize * sizeof(DNAME_TABLE_ENTRY),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

                if ( tmp == NULL ) {
                    //"Cannot allocate memory for %hs Table[entries = %d]\n"
                    RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "DName", DnameTableSize);
                    return FALSE;
                }
                pDNameTable = (PDNAME_TABLE_ENTRY)tmp;
            }

            if ( strcmp(achColName, "ATTb131079") == 0) {
                subRefcolid = jci;
            }

            if ( jci != jrcf[OBJ_DNAME_ENTRY].columnid ) {
                pDNameTable[colCount].ColId = jci;
                pDNameTable[colCount].Syntax = syntax;
                colCount++;
            }
        }

        err = JetMove(sesid, newtid, JET_MoveNext, 0);
    }

    err = JetCloseTable(sesid, newtid);

    //
    // ok, now we need to sort the entries based on column id
    //

    qsort(pDNameTable, colCount, sizeof(DNAME_TABLE_ENTRY), fnColIdSort);

    //
    // OK, now we build the retrieve column list
    //

    jrcSize = colCount;
    jrc = LocalAlloc(LPTR, sizeof(JET_RETRIEVECOLUMN) * jrcSize );

    if ( jrc == NULL ) {
        //"Cannot allocate memory for Jet retrieve column table\n"
        RESOURCE_PRINT (IDS_REFC_MEM_ERR1);
        return FALSE;
    }

    for (i=0;i<colCount;i++) {

        jrc[i].columnid = pDNameTable[i].ColId;
        jrc[i].itagSequence = 1;

        if ( pDNameTable[i].Syntax == SYNTAX_DISTNAME_TYPE ) {

            jrc[i].cbData = sizeof(DWORD);
            jrc[i].pvData = &pDNameTable[i].Value;

        } else if (pDNameTable[i].Syntax == 0) {

            //
            // Syntax is zero if this is not a distname
            //

            JET_RETRIEVECOLUMN *pJrc = (JET_RETRIEVECOLUMN*)pDNameTable[i].pValue;
            jrc[i].cbData = pJrc->cbData;
            jrc[i].pvData = pJrc->pvData;

            if ( jrc[i].columnid == jrcf[GUID_ENTRY].columnid ) {
                GuidIndex = i;
            } else if ( jrc[i].columnid == jrcf[ANCESTOR_ENTRY].columnid ) {
                jrc[i].pvData = LocalAlloc(LPTR, jrc[i].cbData);
                if ( jrc[i].pvData == NULL ) {
                    //"Cannot allocate ancestor buffer.\n"
                    RESOURCE_PRINT (IDS_REFC_MEM_ERR2);
                    return FALSE;
                }
                AncestorIndex = i;
                AncestorBuffer = (PDWORD)jrc[i].pvData;
            } else if ( jrc[i].columnid == jrcf[SD_ENTRY].columnid ) {

                jrc[i].pvData = LocalAlloc(LPTR, jrc[i].cbData);
                if ( jrc[i].pvData == NULL ) {
                    //"Cannot allocate security descriptor buffer.\n"
                    RESOURCE_PRINT (IDS_REFC_MEM_ERR3);
                    return FALSE;
                }
                SdIndex = i;

            } else if ( jrc[i].columnid == jrcf[RDN_ENTRY].columnid ) {
                jrc[i].pvData = LocalAlloc(LPTR, jrc[i].cbData + sizeof(WCHAR));
                if ( jrc[i].pvData == NULL ) {
                    //"Cannot allocate rdn buffer.\n"
                    RESOURCE_PRINT(IDS_REFC_MEM_ERR4);
                    return FALSE;
                }

                rdnIndex = i;
                szRdn = (PWCHAR)jrc[i].pvData;

            } else if ( jrc[i].columnid == jrcf[DELTIME_ENTRY].columnid ) {
                DeltimeIndex = i;
            } else if ( jrc[i].columnid == jrcf[NCDNT_ENTRY].columnid ) {
                NcDntIndex = i;
            } else if ( jrc[i].columnid == jrcf[IT_ENTRY].columnid ) {
                itIndex = i;
            } else if ( jrc[i].columnid == jrcf[OBJ_DNAME_ENTRY].columnid ) {
                pDNameTable[i].Syntax = SYNTAX_DISTNAME_TYPE;
            }
        } else {

            jrc[i].pvData = LocalAlloc(LPTR,64);
            if ( jrc[i].pvData == NULL ) {
                //"Cannot allocate data buffer for column %d\n"
                RESOURCE_PRINT1 (IDS_REFC_COL_ALLOC_ERR, i);
                jrc[i].cbData = 0;
            } else {
                jrc[i].cbData = 64;
            }
        }
    }

    return TRUE;
}


int __cdecl
fnColIdSort(
    const void * keyval,
    const void * datum
    )
{
    PDNAME_TABLE_ENTRY entry1 = (PDNAME_TABLE_ENTRY)keyval;
    PDNAME_TABLE_ENTRY entry2 = (PDNAME_TABLE_ENTRY)datum;
    return (entry1->ColId - entry2->ColId);

} // AuxACCmp


VOID
ValidateDeletionTime(
    IN LPSTR ObjectStr
    )
{

    CHAR szDelTime[32];

    //
    // should have delete time
    //

    if ( jrc[DeltimeIndex].err ) {
        Log(TRUE,"%s object %u does not have a deletion time. Error %d\n",
               ObjectStr, ulDnt, jrc[DELTIME_ENTRY].err);
    } else {

        SYSTEMTIME st;
        DWORD   now;
        DWORD   del;

        //
        // Check time
        //

        DSTimeToLocalSystemTime(DelTime, &st);

        now = NowTime.wYear * 12 + NowTime.wMonth;
        del = st.wYear * 12 + st.wMonth;

        if ( del > now ) {

            // this is for the deleted object containers
            if ( !(st.wYear == 9999 && st.wMonth==12 && st.wDay==31) ) {
                Log(VerboseMode,"WARNING: %s object %u has timestamp[%02d/%02d/%4d] later than now\n",
                    ObjectStr, ulDnt, st.wMonth, st.wDay, st.wYear);
            }

        } else if ( (now - del) > 6 ) {

            Log(VerboseMode,"WARNING: %s object %u has old timestamp[%02d/%02d/%4u]\n",
                   ObjectStr, ulDnt, st.wMonth, st.wDay, st.wYear);

        }
    }
} // ValidateDeletionTime


// Named IsRdnMangled to avoid warnings due to def of IsMangledRdn in mdlocal.h.
BOOL
IsRdnMangled(
    IN  WCHAR * pszRDN,
    IN  DWORD   cchRDN,
    OUT GUID *  pGuid
    )
/*++

Routine Description:

    Detect whether an RDN has been mangled by a prior call to MangleRDN().
    If so, decode the embedded GUID and return it to the caller.

Arguments:

    pszRDN (IN) - The RDN.

    cchRDN (IN) - Size in characters of the RDN.

    pGuid (OUT) - On return, holds the decoded GUID if found.

Return Values:

    TRUE - RDN was mangled; *pGuid holds the GUID passed to MangleRDN().

    FALSE - The RDN was not mangled.

--*/
{
    BOOL        fDecoded = FALSE;
    LPWSTR      pszGuid;
    RPC_STATUS  rpcStatus;

// Size in characters of tags (e.g., "DEL", "CNF") embedded in mangled RDNs.
#define MANGLE_TAG_LEN  (3)

// Size in characters of string (e.g.,
// "#DEL:a746b716-0ac0-11d2-b376-0000f87a46c8", where # is BAD_NAME_CHAR)
// appended to an RDN by MangleRDN().
#define MANGLE_APPEND_LEN   (1 + MANGLE_TAG_LEN + 1 + 36)
#define SZGUIDLEN (36)

    if ((cchRDN > MANGLE_APPEND_LEN)
        && (BAD_NAME_CHAR == pszRDN[cchRDN - MANGLE_APPEND_LEN])) {
        WCHAR szGuid[SZGUIDLEN + 1];

        // The RDN has indeed been mangled; decode it.
        pszGuid = pszRDN + cchRDN - MANGLE_APPEND_LEN + 1 + MANGLE_TAG_LEN + 1;

        // Unfortunately the RDN is not null-terminated, so we need to copy and
        // null-terminate it before we can hand it to RPC.
        memcpy(szGuid, pszGuid, SZGUIDLEN * sizeof(szGuid[0]));
        szGuid[SZGUIDLEN] = L'\0';

        rpcStatus = UuidFromStringW(szGuid, pGuid);

        if (RPC_S_OK == rpcStatus) {
            fDecoded = TRUE;
        }
        else {
            Log(TRUE,"UuidFromStringW(%ws, %p) returned %d!\n",
                    szGuid, pGuid, rpcStatus);
        }
    }

    return fDecoded;
}

VOID
CheckDeletedRecord(
    IN LPSTR ObjectStr
    )
{
    GUID guid;

    //
    // Make sure the times are cool
    //

    ValidateDeletionTime(ObjectStr);

    //
    // Check the GUID. Should start with DEL:
    //

    if ( !IsRdnMangled(szRdn,jrc[rdnIndex].cbActual/sizeof(WCHAR),&guid) ) {

        if ( _wcsicmp(szRdn,L"Deleted Objects") != 0 ) {
            Log(TRUE, "Deleted object %d(%ws) does not have a mangled rdn\n",ulDnt, szRdn);
        }
        return;
    }

    //
    // Compare the guid we got with this object's guid
    //

    if ( memcmp(&guid,&Guid,sizeof(GUID)) != 0 ) {
        Log(TRUE, "Object guid for deleted object %d(%ws) does not match the mangled version\n",
            ulDnt, szRdn);
    }

    return;

} // CheckDeletedRecord


VOID
CheckAncestorBlob(
    PREFCOUNT_ENTRY pEntry
    )
{
    PDWORD pId;
    DWORD nIds = 0;
    DWORD newCrc;

    if ( !jrc[AncestorIndex].err ) {
        nIds = jrc[AncestorIndex].cbActual/sizeof(DWORD);
    } else {

        Log(TRUE, "Cannot get ancestor for %d(%ws)\n", ulDnt, szRdn);
    }

    if ( nIds == 0 ) {
        Log(TRUE,"Object %d(%ws) does not have an ancestor\n", ulDnt,szRdn);
        return;
    }

    pId = AncestorBuffer;
    Crc32(0, jrc[AncestorIndex].cbActual, pId, &newCrc);

    //
    // Make sure last DNT is equal to current DNT. Make sure second to the last is
    // equal to the PDNT
    //

    if ( pId[nIds-1] != ulDnt ) {
        Log(TRUE,"Last entry[%d] of ancestor list does not match current DNT %d(%ws)\n",
               pId[nIds-1], ulDnt, szRdn);
    }

    if ( nIds >= 2 ) {
        if ( pId[nIds-2] != ulPdnt ) {
            printf("Second to last entry[%d] of ancestor list does not match PDNT[%d] of current DNT %d(%ws)\n",
                   pId[nIds-2], ulPdnt, ulDnt, szRdn);
        }
    }

    pEntry->nAncestors = (WORD)(nIds - 1);
    pEntry->AncestorCrc = newCrc;
    return;

} // CheckAncestorBlob


VOID
ValidateSD(
    VOID
    )
{
    SECURITY_DESCRIPTOR         *pSD = (SECURITY_DESCRIPTOR *)jrc[SdIndex].pvData;
    ACL                         *pDACL = NULL;
    BOOLEAN                     fDaclPresent = FALSE;
    BOOLEAN                     fDaclDefaulted = FALSE;
    NTSTATUS                    status;
    ULONG                       revision;
    SECURITY_DESCRIPTOR_CONTROL control;
    DWORD                       cb;

    if ( jrc[SdIndex].err != JET_errSuccess ) {
        if ( jrc[SdIndex].err == JET_wrnColumnNull ) {

            //
            // if not real object, don't expect a SD
            //

            if ( !bObject ) {
                return;
            }

            //
            // not instantiated, no SD.
            //

            if ( insttype & IT_UNINSTANT ) {
                return;
            }

            Log(TRUE, "Object %d(%ws) does not have a Security descriptor.\n",
                ulDnt, szRdn);
            return;

        } else {

            Log(TRUE, "Jet Error [%S] retrieving security descriptor for object %d(%ws).\n",
                GetJetErrString(jrc[SdIndex].err), ulDnt, szRdn);
            return;
        }
    }

    if ( !bObject ) {

        Log(TRUE, "Non object %d(%ws) has a security descriptor\n", ulDnt, szRdn);
        return;
    }

    cb = jrc[SdIndex].cbActual;

    // Parent SD can be legally NULL - caller tells us via fNullOK.

    if ( !cb ) {
        Log(TRUE,"Object %d(%ws) has a null SD\n",ulDnt, szRdn);
        return;
    }

    // Does base NT like this SD?

    status = RtlValidSecurityDescriptor(pSD);

    //
    // Ignore rootObj (dnt 2).
    //

    if ( !NT_SUCCESS(status) && (ulDnt != 2)) {
        Log(TRUE,"Object %d(%ws) has an invalid Security Descriptor [error %x]\n",
               ulDnt,szRdn,status);
        return;
    }

    // Every SD should have a control field.

    status = RtlGetControlSecurityDescriptor(pSD, &control, &revision);

    if ( !NT_SUCCESS(status) ) {

        // skip the weird root object.
        if ( ulDnt != 2 ) {
            Log(TRUE,"Error(0x%x) getting SD control for %d(%ws). Rev %d\n",
                    status, ulDnt, szRdn, revision);
        }
        return;
    }

    // Emit warning if protected bit is set as this stops propagation
    // down the tree.

    if ( control & SE_DACL_PROTECTED ) {
        if ( !bDeleted ) {
            Log(VerboseMode,"Warning SE_DACL_PROTECTED for %d(%ws)\n",ulDnt,szRdn);
        }
    }

    // Every SD in the DS should have a DACL.

    status = RtlGetDaclSecurityDescriptor(
                            pSD, &fDaclPresent, &pDACL, &fDaclDefaulted);

    if ( !NT_SUCCESS(status) ) {
        Log(TRUE,"Error(0x%x) getting DACL for %d(%ws)\n",status,ulDnt,szRdn);
        return;
    }

    if ( !fDaclPresent )
    {
        Log(TRUE,"No DACL found for %d(%ws)\n",ulDnt,szRdn);
        return;
    }

    // A NULL Dacl is equally bad.

    if ( NULL == pDACL ) {
        Log(TRUE,"NULL DACL for %d(%ws)\n",ulDnt,szRdn);
        return;
    }
    // A DACL without any ACEs is just as bad as no DACL at all.

    if ( 0 == pDACL->AceCount ) {
        Log(TRUE,"No ACEs in DACL for %d(%ws)\n",ulDnt,szRdn);
        return;
    }
    return;

} // ValidateSD


VOID
ProcessLinkTable(
    VOID
    )
{

    DWORD err;
    PREFCOUNT_ENTRY pEntry;

    //
    // Walk the link table and retrieve the backlink field to get additional
    // references.
    //

    err = JetMove(sesid, linktblid, JET_MoveFirst, 0);

    while ( !err ) {

        DWORD blinkdnt;
        DWORD alen;

        err = JetRetrieveColumn(sesid,
                                linktblid,
                                blinkid,
                                &blinkdnt,
                                sizeof(blinkdnt),
                                &alen,
                                0,
                                NULL);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"Cannot retrieve back link column. Error [%S].\n",
                GetJetErrString(err));
            return;
        }

        if (!err) {
            pEntry = FindDntEntry(blinkdnt,TRUE);
            if ( pEntry != NULL ) {
                pEntry->RefCount++;
            } else {
                Log(TRUE,"Data Table has missing backlink entry DNT %d.\n",
                    blinkdnt);
            }
        }
        err = JetMove(sesid, linktblid, JET_MoveNext, 0);
    }
} // ProcessLinkTable



VOID
ProcessResults(
    IN BOOL fFixup
    )
{

    Log(VerboseMode, "%d total records walked.\n",recFound);

    //
    // Check Subrefs. We need to do subref fixing before refcount checking since
    // this might change the refcount of an object.
    //

    CheckSubrefs( fFixup );

    //
    // CheckRefCount
    //

    CheckRefCount( fFixup );

    //
    // Check Ancestors
    //

    CheckAncestors( fFixup );

    //
    // Check InstanceTypes
    //

    CheckInstanceTypes( );

    return;
} // ProcessResults


DWORD
FixAncestors (VOID)
{
    JET_TABLEID sdproptblid = JET_tableidNil;
    JET_ERR err;
    JET_COLUMNDEF coldef;
    JET_COLUMNID begindntid;
    JET_COLUMNID trimmableid;
    JET_COLUMNID orderid;
    BYTE Trim=1;
    DWORD index, cbActual;
    DWORD rootTAG = ROOTTAG;


    __try
    {
        if (err = JetOpenTable(sesid,
                               dbid,
                               SZPROPTABLE,
                               NULL,
                               0,
                               JET_bitTableUpdatable | JET_bitTableDenyRead,
                               &sdproptblid)) {

            sdproptblid = JET_tableidNil;
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable",
                    SZPROPTABLE, GetJetErrString(err));
            _leave;
        }

        // get several needed column ids

        if ((err = JetGetTableColumnInfo(sesid, sdproptblid, SZBEGINDNT, &coldef,
                                         sizeof(coldef), 0)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo", GetJetErrString(err));
            _leave;
        }
        begindntid = coldef.columnid;

        if ((err = JetGetTableColumnInfo(sesid, sdproptblid, SZTRIMMABLE, &coldef,
                                         sizeof(coldef), 0)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo", GetJetErrString(err));
            _leave;
        }
        trimmableid = coldef.columnid;

        if ((err = JetGetTableColumnInfo(sesid, sdproptblid, SZORDER,
                                         &coldef,
                                         sizeof(coldef), 0)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo", GetJetErrString(err));
            _leave;
        }
        orderid = coldef.columnid;


        // check to see if propagation already there
        // we insert in the end

        err = JetMove (sesid,
                       sdproptblid,
                       JET_MoveLast, 0);


        if (err == JET_errSuccess) {
            err = JetRetrieveColumn(sesid,
                                    sdproptblid,
                                    begindntid,
                                    &index,
                                    sizeof(index),
                                    &cbActual,
                                    JET_bitRetrieveCopy,
                                    NULL);

            if (err == JET_errSuccess) {
                if (index == ROOTTAG) {

                    err = JetRetrieveColumn(sesid,
                                            sdproptblid,
                                            orderid,
                                            &index,
                                            sizeof(index),
                                            &cbActual,
                                            JET_bitRetrieveCopy,
                                            NULL);


                    Log(TRUE,"Propagation to fix Ancestry already enqueued (id=%d). Skipped.\n", index);
                    _leave;
                }
            }
        }

        Log(TRUE,"Enqueing a propagation to fix Ancestry\n");

        err = JetPrepareUpdate(sesid,
                               sdproptblid,
                               JET_prepInsert);
        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
            _leave;
        }


        // Set the DNT column
        err = JetSetColumn(sesid,
                           sdproptblid,
                           begindntid,
                           &rootTAG,
                           sizeof(rootTAG),
                           0,
                           NULL);

        if(err != DB_success)   {
            JetPrepareUpdate(sesid,
                             sdproptblid,
                             JET_prepCancel);
            _leave;
        }

        err = JetSetColumn(sesid,
                           sdproptblid,
                           trimmableid,
                           &Trim,
                           sizeof(Trim),
                           0,
                           NULL);
        if(err != DB_success) {
            JetPrepareUpdate(sesid,
                             sdproptblid,
                             JET_prepCancel);
            _leave;
        }

        err = JetRetrieveColumn(sesid,
                                sdproptblid,
                                orderid,
                                &index,
                                sizeof(index),
                                &cbActual,
                                JET_bitRetrieveCopy,
                                NULL);

        Log(TRUE,"Propagation to fix Ancestry Enqueued (id=%d). Propagation will be done the next time the DS is restarted.\n", index);

        err = JetUpdate(sesid,
                        sdproptblid,
                        NULL,
                        0,
                        NULL);

        if(err != DB_success)  {
            JetPrepareUpdate(sesid,
                             sdproptblid,
                             JET_prepCancel);
            _leave;
        }
    }
    __finally
    {
        if ( sdproptblid != JET_tableidNil ) {
            JetCloseTable(sesid,sdproptblid);
        }
    }

    return err;
}



VOID
CheckAncestors(
    IN BOOL fFixup
    )
{
    PREFCOUNT_ENTRY pEntry;
    DWORD i;
    BOOL  fNeedFix = FALSE;

    for ( i=0; i < RefTableSize; i++ ) {

        DWORD dnt = RefTable[i].Dnt;

        if ( dnt != 0 ) {

            DWORD newCrc;
            DWORD pdnt;
            DWORD ncdnt;
            BOOL  foundNcDnt;
            BOOL  nextNCExists;

            //
            // Check ancestors. Make sure that the ancestor of current DNT is
            // equal to ancestor of parent + current DNT
            //

            if ( RefTable[i].Pdnt != 0 ) {
                pEntry = FindDntEntry(RefTable[i].Pdnt,FALSE);
                if ( pEntry != NULL ) {

                    Crc32(pEntry->AncestorCrc, sizeof(DWORD), &RefTable[i].Dnt, &newCrc);

                    if ( newCrc != RefTable[i].AncestorCrc ) {
                        Log(TRUE,"Ancestor crc inconsistency for DNT %d PDNT %d.\n",
                            dnt, RefTable[i].Pdnt );

                        fNeedFix = TRUE;
                    }

                    if ( RefTable[i].nAncestors != (pEntry->nAncestors+1)) {
                        Log(TRUE,"Ancestor count mismatch for DNT %d.\n",dnt);

                        fNeedFix = TRUE;
                    }
                } else {
                    Log(TRUE, "parent [PDNT %d] of entry [dnt %d] is missing.\n",
                        RefTable[i].Pdnt, dnt);
                }
            }

            //
            // Walk up the PDNT link until we hit the parent
            //

            if ( RefTable[i].InstType == 0 ) {
                continue;
            }

            ncdnt = RefTable[i].NcDnt;
            pdnt = RefTable[i].Pdnt;
            nextNCExists = FALSE;
            foundNcDnt = FALSE;

            while ( pdnt != 0 ) {

                pEntry = FindDntEntry(pdnt,FALSE);
                if ( pEntry == NULL ) {
                    Log(TRUE, "Ancestor [dnt %d] of entry [dnt %d] is missing.\n",
                        pdnt, dnt);
                    break;
                }

                //
                // If we've aready gone through this object, then we're done.
                //

                if ( (ncdnt == pdnt) || nextNCExists ) {

                    if ( ((pEntry->InstType & IT_NC_HEAD) == 0) ||
                          (pEntry->InstType & IT_UNINSTANT) ) {

                        if ( nextNCExists ) {
                            Log(TRUE,"Expecting %d to be instantiated NC head. Referring entry %d\n",
                               pdnt, RefTable[i].Dnt);
                        }
                    }

                    nextNCExists = FALSE;

                    if ( ncdnt == pdnt ) {
                        foundNcDnt = TRUE;
                    }
                }

                if ( pEntry->InstType & IT_NC_ABOVE ) {
                    nextNCExists = TRUE;
                }

                if ( pEntry->Pdnt == 0 ) {
                    if ( (pEntry->InstType & IT_NC_HEAD) == 0 ) {
                        Log(TRUE,"Unexpected termination of search on non NC Head %d\n",
                               pEntry->Pdnt);
                    }
                }
                pdnt = pEntry->Pdnt;
            }

            if (RefTable[i].Pdnt != 0) {

                if ( !foundNcDnt ) {
                    Log(TRUE,"Did not find the NCDNT for object %d\n",RefTable[i].Dnt);
                }
            }
        }
    }

    if (fNeedFix && fFixup) {
        FixAncestors ();
    }

    return;

} //CheckAncestors


VOID
CheckInstanceTypes(
    VOID
    )
{
    DWORD i;
    PREFCOUNT_ENTRY pEntry;

    for ( i=0; i < RefTableSize; i++ ) {

        if ( RefTable[i].Dnt != 0 ) {

            SYNTAX_INTEGER instType = RefTable[i].InstType;
            DWORD dnt = RefTable[i].Dnt;

            //
            // Make sure the instance type is valid. Root object (dnt 2)
            // is an exception.
            //

            if ( !ISVALIDINSTANCETYPE(instType) ) {
                if ( (dnt != 2) || (instType != (IT_UNINSTANT | IT_NC_HEAD)) ) {
                    Log(TRUE,"Invalid instance type %x for Dnt %d\n",
                           instType, dnt);
                }
                continue;
            }

            //
            // if not object, then no instance type
            //

            if ( !RefTable[i].fObject ) {
                continue;
            }

            //
            // For non-NCHead objects, if instance type has IT_WRITE,
            // the parent should also have it
            //

            if ( (instType & IT_NC_HEAD) == 0 ) {

                BOOL writeable, parentWriteable;

                pEntry = FindDntEntry(RefTable[i].Pdnt,FALSE);
                if ( pEntry == NULL ) {
                    Log(TRUE,"Parent [PDNT %d] of DNT %d missing\n",
                        RefTable[i].Pdnt, dnt);
                    continue;
                }

                writeable = (BOOL)((instType & IT_WRITE) != 0);
                parentWriteable = (BOOL)((pEntry->InstType & IT_WRITE) != 0);

                if ( writeable != parentWriteable ) {
                    Log(TRUE,"Inconsistent Instance type for %d and parent %d [%x != %x]\n",
                            dnt,RefTable[i].Pdnt,instType,pEntry->InstType);
                }

                //
                // fSubRef should not be set on non NC heads
                //

                if ( RefTable[i].fSubRef ) {
                    Log(TRUE,"Non Nc Head %d marked as SubRef\n",dnt);
                }
            }
        }
    }
    return;

} // CheckInstanceTypes


VOID
CheckSubrefs(
    IN BOOL fFixup
    )
{

    DWORD i;
    DWORD fBad = FALSE;

    //
    // If stated and found refcounts are different, print a message
    //

    for ( i=1; i < RefTableSize; i++ ) {

        // ok, we have something...
        if ( RefTable[i].Subrefs != NULL ) {

            // ignore if fatal error or object is a phantom

            if ( !fDisableSubrefChecking && RefTable[i].fObject ) {

                DWORD j;
                PSUBREF_ENTRY pSubref = RefTable[i].Subrefs;

                for (j=0; j < RefTable[i].nSubrefs; j++ ) {

                    // if found and also listed, then everything is fine.
                    if ( pSubref[j].fListed && pSubref[j].fFound ) {
                        continue;
                    }

                    // if found only, then

                    fBad = TRUE;
                    if ( pSubref[j].fFound ) {
                        Log(TRUE, "Missing subref entry for %d on %d.\n",
                               pSubref[j].Dnt, RefTable[i].Dnt);
                    } else {
                        Log(TRUE, "Found extra subref entry for %d on %d.\n",
                               pSubref[j].Dnt, RefTable[i].Dnt);
                    }

                    if ( fFixup ) {

                        // if fixup succeeded, add a ref to the subref
                        if ( FixSubref(RefTable[i].Dnt, pSubref[j].Dnt, pSubref[j].fFound) ){

                            PREFCOUNT_ENTRY pEntry;

                            //
                            // if add, increment else decrement
                            //

                            pEntry = FindDntEntry(pSubref[j].Dnt,FALSE);
                            //
                            // PREFIX: Since it's technically possible for
                            // FindDntEntry() to return NULL, the following
                            // check on pEntry was added to shut PREFIX up.
                            // FindDntEntry() should never return NULL here though.
                            //
                            if (pEntry) {
                                if ( pSubref[j].fFound ) {
                                    pEntry->RefCount++;
                                } else {
                                    pEntry->RefCount--;
                                }
                            }
                        }
                    }
                }
            }

            // free blob

            LocalFree(RefTable[i].Subrefs);
            RefTable[i].Subrefs = NULL;
            RefTable[i].nSubrefs = 0;
        }
    }

    if ( fBad ) {
        fprintf(stderr, "\nError: Missing subrefs detected.\n");
    }

    return;

} // CheckSubrefs

VOID
CheckRefCount(
    IN BOOL fFixup
    )
{

    BOOL fBad = FALSE;
    DWORD i;
    BOOL  fRemoveInvalidReference = FALSE;

    Log(TRUE,"\n\nSummary: \nActive Objects \t%8u\nPhantoms \t%8u\nDeleted \t%8u\n\n",
           realFound, phantomFound, deletedFound);

    //
    // If stated and found refcounts are different, print a message
    //

    for ( i=1; i < RefTableSize; i++ ) {

        // ignore weird DNTs (0,1,2,3)
        if ( RefTable[i].Dnt > 3 ) {

            //
            // if not equal
            //

            if ( RefTable[i].RefCount != RefTable[i].Actual ) {

                BOOL fFixed;

                fBad = TRUE;
                if ( fFixup ) {
                    fFixed = FixRefCount(RefTable[i].Dnt,
                                    RefTable[i].Actual,
                                    RefTable[i].RefCount);
                } else {
                    fFixed = FALSE;
                }

                Log(TRUE,"RefCount mismatch for DNT %u [RefCount %4u References %4u] [%s]\n",
                       RefTable[i].Dnt,
                       RefTable[i].Actual,
                       RefTable[i].RefCount,
                       fFixed ? "Fixed" : "Not Fixed");

                //
                // if this had been fixed, indicate this on the count
                //

                if ( fFixed ) {
                    RefTable[i].Actual = RefTable[i].RefCount;

                } else if ( fFixup &&
                            (RefTable[i].Actual == 0) &&
                            (RefTable[i].RefCount != 0) ) {

                    //
                    // This indicates that we have a reference to a
                    // non-existent object
                    //

                    fRemoveInvalidReference = TRUE;
                }
            }
        }
    }

    //
    // See if we need to run the reference fixer
    //

    if ( fRemoveInvalidReference ) {
        FixReferences();
    }

    if ( fBad ) {
        fprintf(stderr, "\nError: Inconsistent refcounts detected.\n");
    }

    return;

} // CheckRefCount


BOOL
ExpandBuffer(
    JET_RETRIEVECOLUMN *jetcol
    )
{

    PCHAR p;
    DWORD len = jetcol->cbActual + 512;

    p = LocalAlloc(0,len);
    if ( p != NULL ) {

        if ( jetcol->pvData != NULL ) {
            LocalFree(jetcol->pvData);
        }
        jetcol->pvData = p;
        jetcol->cbData = len;

        return TRUE;
    }
    return FALSE;
}




VOID
DisplayRecord(
    IN DWORD Dnt
    )
{
    JET_ERR err;
    DWORD i;

    if ( !BuildRetrieveColumnForRefCount() ) {
        return;
    }

    // seek using DNT
    err = GotoDnt(Dnt);
    if ( err ) {
        return;
    }

    szRdn[0] = L'\0';
    ulDName = 0;
    bDeleted = 0;
    bObject = 0;
    insttype = 0;
    ulNcDnt = 0;
    ClassId = 0;

do_again:
    err = JetRetrieveColumns(sesid, tblid, jrc, jrcSize);

    if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumns", GetJetErrString(err));
        return;
    }

    //
    // See if we have enough.
    //

    if ( err == JET_wrnBufferTruncated ) {

        for (i=0; i < jrcSize ;i++) {

            if ( jrc[i].err == JET_wrnBufferTruncated ) {

                if ( ExpandBuffer(&jrc[i]) ) {
                    szRdn = (PWCHAR)jrc[rdnIndex].pvData;
                    AncestorBuffer = (PDWORD)jrc[AncestorIndex].pvData;
                    goto do_again;
                }
            }
        }
    }

    //
    // display the results
    //

    szRdn[jrc[rdnIndex].cbActual/sizeof(WCHAR)] = L'\0';

    //"\n\nData for DNT %d\n\n", Dnt
    //"RDN = %ws\n", szRdn
    //"PDNT = %d\n", ulPdnt
    //"RefCount = %d\n", lCount
    RESOURCE_PRINT4 (IDS_REFC_RESULTS1, Dnt, szRdn, ulPdnt, lCount);


    if (VerboseMode) {
        //"DNT of NC = %d\n", ulNcDnt);
        //"ClassID = 0x%x\n", ClassId);
        //"Deleted? %s\n", bDeleted ? "YES" : "NO");
        //"Object? %s\n", bObject ? "YES" : "NO");

        RESOURCE_PRINT4 (IDS_REFC_RESULTS2, ulNcDnt, ClassId, bDeleted ? L"YES" : L"NO", bObject ? L"YES" : L"NO");

        if (!jrc[itIndex].err ) {
            //"Instance Type = 0x%x\n"
            RESOURCE_PRINT1 (IDS_REFC_INSTANCE_TYPE, insttype);
        } else if (jrc[itIndex].err == JET_wrnColumnNull) {
            //"No Instance Type\n"
            RESOURCE_PRINT (IDS_REFC_NOINSTANCE_TYPE);
        }

        if ( jrc[SdIndex].err == JET_errSuccess ) {
            //"Security Descriptor Present [Length %d].\n"
            RESOURCE_PRINT1 (IDS_REFC_SEC_DESC_PRESENT, jrc[SdIndex].cbActual);
        } else if (jrc[SdIndex].err == JET_wrnColumnNull ) {
            //"No Security Descriptor Found.\n"
            RESOURCE_PRINT (IDS_REFC_SEC_DESC_NOTPRESENT);
        } else {
            //"Error %d fetching security descriptor\n",jrc[SdIndex].err);
            RESOURCE_PRINT (IDS_REFC_ERR_FETCH_SEC_DESC);
        }

        //
        // Ancestor index
        //

        if ( !jrc[AncestorIndex].err ) {
            DWORD nAncestors;
            nAncestors = jrc[AncestorIndex].cbActual/sizeof(DWORD);
            for (i=0;i<nAncestors;i++) {
                fprintf(stderr,"%u ",AncestorBuffer[i]);
            }
            fprintf(stderr,"\n");
        }
    }
    return;
}

BOOL
FixSubref(
    IN DWORD Dnt,
    IN DWORD SubRef,
    IN BOOL  fAdd
    )
{
    JET_ERR err;
    INT seq = -1;
    JET_SETINFO setInfo;
    DWORD setFlags = 0;

    // seek using DNT
    err = GotoDnt(Dnt);
    if ( err ) {
        return FALSE;
    }

    //
    // Replace the value
    //

    err = JetPrepareUpdate(sesid,
                           tblid,
                           JET_prepReplace);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        return FALSE;
    }

    // if not add, then this is a delete. Look for this particular entry

    if ( !fAdd ) {

        JET_RETINFO retInfo;
        retInfo.itagSequence = 0;
        retInfo.cbStruct = sizeof(retInfo);
        do {

            DWORD alen;
            DWORD dnt;

            retInfo.itagSequence++;
            retInfo.ibLongValue = 0;

            err = JetRetrieveColumn(sesid,
                                    tblid,
                                    subRefcolid,
                                    &dnt,
                                    sizeof(dnt),
                                    &alen,
                                    0,
                                    &retInfo);

            if ( !err ) {
                if ( dnt == SubRef ) {
                    // found it!
                    seq = retInfo.itagSequence;
                    break;
                }
            }

        } while (!err);

    } else {
        seq = 0;
        setFlags = JET_bitSetUniqueMultiValues;
    }

    // !!! Should not happen. If entry not found, then bail out.
    if ( seq == -1) {
        fprintf(stderr, "Cannot find subref %d on object %d\n",
                SubRef, Dnt);
        return FALSE;
    }

    setInfo.cbStruct = sizeof(setInfo);
    setInfo.ibLongValue = 0;
    setInfo.itagSequence = seq;

    err = JetSetColumn(sesid,
                       tblid,
                       subRefcolid,
                       fAdd ? &SubRef : NULL,
                       fAdd ? sizeof(SubRef) : 0,
                       setFlags,
                       &setInfo);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        return FALSE;
    }

    err = JetUpdate(sesid,
                    tblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        return FALSE;
    }

    if ( fAdd ) {
        Log(TRUE, "Added subref %d to object %d.\n",SubRef,Dnt);
    } else {
        Log(TRUE, "Deleted subref %d from object %d.\n",SubRef,Dnt);
    }
    return TRUE;
}


BOOL
FixRefCount(
    IN DWORD Dnt,
    IN DWORD OldCount,
    IN DWORD NewCount
    )
{
    JET_ERR err;
    DWORD nActual;
    DWORD refCount;

    // seek using DNT
    err = GotoDnt(Dnt);
    if ( err ) {
        return FALSE;
    }

    err = JetRetrieveColumn(sesid,
                            tblid,
                            jrcf[REFC_ENTRY].columnid,
                            &refCount,
                            sizeof(refCount),
                            &nActual,
                            0,
                            NULL
                            );

    if (err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumn", GetJetErrString(err));
        return FALSE;
    }

    //
    // Replace the value
    //

    err = JetPrepareUpdate(sesid,
                           tblid,
                           JET_prepReplace);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        return FALSE;
    }

    err = JetSetColumn(sesid,
                       tblid,
                       jrcf[REFC_ENTRY].columnid,
                       &NewCount,
                       sizeof(NewCount),
                       0,
                       NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        return FALSE;
    }

    err = JetUpdate(sesid,
                    tblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        return FALSE;
    }

    return TRUE;
}


VOID
FixReferences(
    VOID
    )
{
    JET_ERR err;
    DWORD i;

    Log(TRUE,"\n\nRemoving Non-existent references:\n\n");
    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while ( !err ) {

        err = JetRetrieveColumns(sesid, tblid, jrc, jrcSize);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"JetRetrieveColumns error: %S.\n", GetJetErrString(err));
            goto next_rec;
        }

        //
        // make sure pdnt is referring to something valid
        //

        if ( !jrc[PDNT_ENTRY].err ) {
            CheckForBogusReference(ulPdnt, jrc[PDNT_ENTRY].columnid, NULL);
        }

        //
        // go through the entire list and ref the DNTs
        //

        for (i=0;i < jrcSize; i++) {

            //
            // Syntax is zero if this is not a distname
            //

            if ( pDNameTable[i].Syntax == 0 ) {
                continue;
            }

            if ( !jrc[i].err ) {

                DWORD dnt;
                DWORD seq;

                seq = 1;
                dnt = (*((PDWORD)jrc[i].pvData));
                CheckForBogusReference(dnt, jrc[i].columnid, &seq);

                //
                // See if we have more values
                //

                do {

                    DWORD alen;
                    JET_RETINFO retInfo;

                    retInfo.itagSequence = ++seq;
                    retInfo.cbStruct = sizeof(retInfo);
                    retInfo.ibLongValue = 0;
                    err = JetRetrieveColumn(sesid,
                                            tblid,
                                            jrc[i].columnid,
                                            jrc[i].pvData,
                                            jrc[i].cbData,
                                            &alen,
                                            0,
                                            &retInfo);

                    if ( !err ) {

                        dnt = (*((PDWORD)jrc[i].pvData));
                        CheckForBogusReference(dnt, jrc[i].columnid, &seq);
                    }

                } while (!err);
            }
        }

next_rec:

        err = JetMove(sesid, tblid, JET_MoveNext, 0);
    }

    if (err != JET_errNoCurrentRecord) {
        Log(TRUE, "Error while walking data table. Last Dnt = %d. JetMove failed [%S]\n",
             ulDnt, GetJetErrString(err));
    }

    //
    // Go through link table
    //

    //
    // Walk the link table and retrieve the backlink field to get additional
    // references.
    //

    err = JetMove(sesid, linktblid, JET_MoveFirst, 0);

    while ( !err ) {

        DWORD blinkdnt;
        DWORD alen;

        err = JetRetrieveColumn(sesid,
                                linktblid,
                                blinkid,
                                &blinkdnt,
                                sizeof(blinkdnt),
                                &alen,
                                0,
                                NULL);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"Cannot retrieve back link column. Error [%S].\n",
                GetJetErrString(err));
            return;
        }

        if (!err) {
            CheckForBogusReferenceOnLinkTable(blinkdnt);
        }
        err = JetMove(sesid, linktblid, JET_MoveNext, 0);
    }
}

VOID
CheckForBogusReference(
    IN DWORD Dnt,
    IN JET_COLUMNID ColId,
    IN PDWORD Sequence
    )
{
    JET_ERR err;
    DWORD refCount;
    PREFCOUNT_ENTRY pEntry;
    JET_SETINFO SetInfo;
    JET_SETINFO * pSetInfo = NULL;
    BOOL fTransactionInProgress = FALSE;

    if ( Dnt <= 3 ) {
        return;
    }

    pEntry = FindDntEntry(Dnt,FALSE);
    if ( pEntry == NULL ) {             // should never happen
        return;
    }

    if ( (pEntry->Actual != 0) || (pEntry->RefCount == 0) ) {   // refCount == 0 should never happen
        return;
    }

    //
    // Start a transaction
    //

    err = JetBeginTransaction(sesid);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetBeginTransaction", GetJetErrString(err));
        goto error_exit;
    }

    //
    // Remove the reference
    //

    fTransactionInProgress = TRUE;
    err = JetPrepareUpdate(sesid,
                           tblid,
                           JET_prepReplace);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        goto error_exit;
    }

    if ( Sequence != NULL ) {
        SetInfo.itagSequence = *Sequence;
        SetInfo.cbStruct = sizeof(SetInfo);
        SetInfo.ibLongValue = 0;
        pSetInfo = &SetInfo;
    }

    err = JetSetColumn(sesid,
                       tblid,
                       ColId,
                       NULL,
                       0,
                       0,
                       pSetInfo);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        goto error_exit;
    }

    err = JetUpdate(sesid,
                    tblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        goto error_exit;
    }

    err = JetCommitTransaction(sesid,0);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetCommitTransaction", GetJetErrString(err));
        goto error_exit;
    }

    fTransactionInProgress = FALSE;
    pEntry->RefCount--;

    Log(TRUE,"Object %d has reference (colid %d) to bogus DNT %d. Removed\n",
        ulDnt, ColId, Dnt);

    return;

error_exit:

    //
    // Rollback on failure
    //

    if ( fTransactionInProgress ) {
        err = JetRollback(sesid, 0);
        if (err) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2,
                             "JetRollback",
                             GetJetErrString(err));
        }
    }

    Log(TRUE,"Unable to remove reference to bogus DNT %d from object %d(colid %d)\n",
        Dnt, ulDnt, ColId);
    return;

} // CheckForBogusReference


VOID
CheckForBogusReferenceOnLinkTable(
    IN DWORD Dnt
    )
{
    JET_ERR err;
    PREFCOUNT_ENTRY pEntry;

    if ( Dnt <= 3 ) {
        return;
    }

    pEntry = FindDntEntry(Dnt,FALSE);
    if ( pEntry == NULL ) {     // should never happen
        return;
    }

    //
    // Object ok?
    //

    if ( (pEntry->Actual != 0) || (pEntry->RefCount == 0) ) {  // RefCount == 0 should never happen

        // yes, nothing else to do
        return;
    }

    //
    // Delete the record
    //

    err = JetDelete(sesid,linktblid);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetDelete", GetJetErrString(err));
        goto error_exit;
    }

    pEntry->RefCount--;
    Log(TRUE,"A LinkTable record has a backlink reference to bogus DNT %d. Record removed\n",
        Dnt);

    return;

error_exit:

    Log(TRUE,"Unable to remove backlink reference to bogus DNT %d\n", Dnt);
    return;

} // CheckForBogusReferenceOnLinkTable

VOID
AddToSubRefList(
    PREFCOUNT_ENTRY pParent,
    DWORD Subref,
    BOOL fListed
    )
{
    //
    // subref checking may be disabled by memory problems. Also ignore 0,1,2,3, these
    // are weird dnts.
    //

    if ( (fDisableSubrefChecking) || ((LONG)pParent->Dnt < 4) ) {
        return;
    }

    //
    // allocate enough for 16. Mark last with -1. If allocation failed,
    // disable all subref checking.
    //

    if ( pParent->Subrefs == NULL ) {
        pParent->Subrefs =
            LocalAlloc(LPTR, DEF_SUBREF_ENTRIES * sizeof(SUBREF_ENTRY) );

        if ( pParent->Subrefs != NULL ) {
            pParent->Subrefs[DEF_SUBREF_ENTRIES-1].Dnt = 0xFFFFFFFF;
        }

    } else if ( pParent->Subrefs[pParent->nSubrefs].Dnt == 0xFFFFFFFF ) {

        //
        // Need more space
        //

        PSUBREF_ENTRY pTmp;
        DWORD  newSize = pParent->nSubrefs * 2;

        pTmp = (PSUBREF_ENTRY)LocalReAlloc( pParent->Subrefs,
                                newSize * sizeof(SUBREF_ENTRY),
                                LMEM_MOVEABLE | LMEM_ZEROINIT);

        if ( pTmp == NULL ) {
            LocalFree(pParent->Subrefs);
            pParent->Subrefs = NULL;
            pParent->nSubrefs = 0;

        } else {

            pParent->Subrefs = pTmp;
            // set new end marker
            pTmp[newSize-1].Dnt = 0xFFFFFFFF;
        }
    }

    //
    // ok, add this entry to the subref list if it's not there yet
    //

    if ( pParent->Subrefs != NULL ) {

        PSUBREF_ENTRY pSubref = NULL;
        DWORD i;

        for (i=0; i< pParent->nSubrefs; i++ ) {

            pSubref = &pParent->Subrefs[i];

            // find an existing one?
            if ( pSubref->Dnt == Subref ) {
                break;
            }
        }

        // did we find anything? if not, initialize a new entry
        if ( i == pParent->nSubrefs ) {
            pSubref = &pParent->Subrefs[pParent->nSubrefs++];
            pSubref->Dnt = Subref;
        }

        if ( fListed ) {
            // found on a subref list of this object
            pSubref->fListed = TRUE;
        } else {
            // should be no subref list of this object
            pSubref->fFound = TRUE;
        }

        //printf("Adding subref entry %x for %d. entry %d. fListed %d\n",
        //       pSubref, pParent->Dnt, Subref, fListed);
    } else {

        printf("alloc failed\n");
        fDisableSubrefChecking = TRUE;
    }

    return;
}

#if 0
VOID
XXX()
{
    JET_ERR err;
    DWORD blink=0x99999999;
    err = JetPrepareUpdate(sesid,
                           linktblid,
                           JET_prepInsert);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        goto error_exit;
    }

    err = JetSetColumn(sesid,
                       linktblid,
                       blinkid,
                       &blink,
                       sizeof(blink),
                       0,
                       NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        goto error_exit;
    }

    err = JetUpdate(sesid,
                    linktblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        goto error_exit;
    }
    return;
error_exit:
    return;
}
#endif


JET_ERR
GotoDnt(
    IN DWORD Dnt
    )
{
    JET_ERR err;

    err = JetMakeKey(sesid, tblid, &Dnt, sizeof(Dnt), JET_bitNewKey);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetMakeKey", GetJetErrString(err));
        return err;
    }

    err = JetSeek(sesid, tblid, JET_bitSeekEQ);
    if ( err ) {
        //"Cannot find requested record with dnt = %d. JetSeek failed [%ws]\n"
        if ( VerboseMode ) {
            RESOURCE_PRINT2 (IDS_REFC_DNT_SEEK_ERR,
                    Dnt,
                    GetJetErrString(err));
        }
        return err;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\remove.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"

#include "resource.h"

#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <ntldap.h>

CParser removeParser;
BOOL    fRemoveQuit;
BOOL    fRemoveParserInitialized = FALSE;

extern DS_NAME_RESULTW *gServerInfo;

// Forward references.

extern HRESULT RemoveHelp(CArgs *pArgs);
extern HRESULT RemoveQuit(CArgs *pArgs);
extern HRESULT RemoveServer(CArgs *pArgs);
extern HRESULT RemoveDomain(CArgs *pArgs);
extern HRESULT RemoveNamingContext(CArgs *pArgs);

extern "C" {

const WCHAR *
GetWinErrorMessage(
    DWORD winError
    );

}


//
// Forwards local to this file
//
BOOL    FRSRequirementsHandled(IN LPWSTR pwszDomain,
                               IN LPWSTR pwszServer,
                               OUT BOOL *fDeleteFRS);
HRESULT FRSRemoveServer(IN LPWSTR pwszServer,IN LPWSTR pwszDomain);
HRESULT GetDNSDomainFormat(IN LPWSTR pwszDomainDn,OUT LPWSTR *pwszDnsName);

//
// A helpful macro to know if two strings are the same.
// x and y must be NULL terminated.
//
#define EQUAL_STRING(x, y)                                           \
    (CSTR_EQUAL == CompareStringW(DS_DEFAULT_LOCALE,                 \
                                  DS_DEFAULT_LOCALE_COMPARE_FLAGS,   \
                                  (x), wcslen(x), (y), wcslen(y)))


// Build a table which defines our language.

LegalExprRes removeLanguage[] = 
{
    CONNECT_SENTENCE_RES

    SELECT_SENTENCE_RES

    {   L"?",
        RemoveHelp,
        IDS_HELP_MSG, 0  },

    {   L"Help",
        RemoveHelp,
        IDS_HELP_MSG, 0  },

    {   L"Quit",
        RemoveQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Remove selected server",
        RemoveServer,
        IDS_REMOVE_SERVER_MSG, 0 },

    {   L"Remove selected domain",
        RemoveDomain,
        IDS_REMOVE_DOMAIN_MSG, 0 },

    {   L"Remove selected Naming Context",
        RemoveNamingContext,
        IDS_REMOVE_NC_MSG, 0 }
};

HRESULT
RemoveMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fRemoveParserInitialized )
    {
        cExpr = sizeof(removeLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (removeLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = removeParser.AddExpr(removeLanguage[i].expr,
                                                  removeLanguage[i].func,
                                                  removeLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fRemoveParserInitialized = TRUE;
    fRemoveQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_METADATA_CLEANUP);

    hr = removeParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fRemoveQuit,
                            FALSE,               // timing info
                            FALSE);              // quit on error

    if ( FAILED(hr) )
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    
    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT RemoveHelp(CArgs *pArgs)
{
    return(removeParser.Dump(stdout,L""));
}

HRESULT RemoveQuit(CArgs *pArgs)
{
    fRemoveQuit = TRUE;
    return(S_OK);
}

HRESULT RemoveServer(CArgs *pArgs)
{
    WCHAR   *pwszServer;
    WCHAR   *pwszDomain;
    DWORD   cBytes;
    DWORD   dwErr;
    BOOL    fLastDcInDomain;
    int     ret;
    BOOL    fDeleteFRS = FALSE;

    RETURN_IF_NOT_CONNECTED;

    if ( NULL == (pwszServer = SelectGetCurrentServer()) )
    {
        return(S_OK);
    }

    if ( NULL == (pwszDomain = SelectGetCurrentDomain()) )
    {
        return(S_OK);
    }


    //
    // See if the FRS objects can and should be removed by the
    // server we are connected to.
    //
    if (!FRSRequirementsHandled(pwszDomain, pwszServer, &fDeleteFRS))
    {
        //
        // Reason has already been printed out why the operation
        // shouldn't continue.
        //
        return (S_OK);            
    }

    if ( dwErr = DsRemoveDsServerW( ghDS,
                                    pwszServer,
                                    pwszDomain,
                                    &fLastDcInDomain,
                                    FALSE) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsRemoveDsServerW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    if ( fPopups )
    {
        const WCHAR * message_title = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_TITLE);
        const WCHAR * message_body;
        WCHAR * msg;

        if (fLastDcInDomain) 
           message_body  = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_MSG1);
        else
           message_body  = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_MSG2);

        
        cBytes =   wcslen(message_body)
                 + wcslen(pwszServer)
                 + wcslen(pwszDomain)
                 + 25; // just in case

        msg = (WCHAR *) malloc(cBytes * sizeof (WCHAR));

        if ( !msg  )
        {
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }

        wsprintfW(msg, 
                message_body, 
                pwszServer, 
                pwszDomain);
        
        ret = MessageBoxW(   GetFocus(),
                            msg,
                            message_title,
                            (   MB_APPLMODAL
                              | MB_DEFAULT_DESKTOP_ONLY
                              | MB_YESNO
                              | MB_DEFBUTTON2
                              | MB_ICONQUESTION
                              | MB_SETFOREGROUND ) );
        free(msg);
        RESOURCE_STRING_FREE (message_body);
        RESOURCE_STRING_FREE (message_title);

        switch ( ret )
        {
        case 0:
           {
              RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
           
              return(S_OK);    
           }

        case IDYES:

            break;

        default:
           {
              RESOURCE_PRINT (IDS_OPERATION_CANCELED);
           
              return(S_OK);
           }
        }
    }

    if (fDeleteFRS) {

        //
        // Call into FRS module
        //
        dwErr = FRSRemoveServer(pwszServer,
                                pwszDomain);
        if (dwErr) {
            //
            // FRSRemoveServer prints out any error.  See
            // FRSRemoveServer for error conditions.
            //
            return(S_OK);
        }
    }

    if ( dwErr = DsRemoveDsServerW( ghDS,
                                    pwszServer,
                                    NULL,
                                    NULL,
                                    TRUE) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsRemoveDsServerW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }
    
    //"\"%ws\" removed from server \"%ws\"\n"
    RESOURCE_PRINT2 (IDS_REMOVE_SERVER_SUCCESS,
                     pwszServer,
                     gpwszServer);
    return(S_OK);
}

HRESULT 
RemoveDomainOrNamingContext(
    IN PWCHAR   Name,
    IN DWORD    Title,
    IN DWORD    Body
    )
{
    DWORD   cBytes;
    WCHAR   *msg;
    DWORD   dwErr;
    int     ret;

    if ( fPopups )
    {
        const WCHAR * message_title = READ_STRING (Title);
        const WCHAR * message_body  = READ_STRING (Body);
        
        
        cBytes =   wcslen(message_body)
                 + wcslen(Name)
                 + 10;
        msg = (WCHAR *) malloc(cBytes * sizeof (WCHAR));

        if ( !msg )
        {
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }

        wsprintfW(msg, message_body, Name);
        
        ret = MessageBoxW(   GetFocus(),
                            msg,
                            message_title,
                            (   MB_APPLMODAL
                              | MB_DEFAULT_DESKTOP_ONLY
                              | MB_YESNO
                              | MB_DEFBUTTON2
                              | MB_ICONQUESTION
                              | MB_SETFOREGROUND ) );
        free(msg);
        RESOURCE_STRING_FREE (message_body);
        RESOURCE_STRING_FREE (message_title);

        switch ( ret )
        {
        case 0:
           {
             RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);

              return(S_OK);
           }

        case IDYES:

            break;

        default:
           {
              RESOURCE_PRINT (IDS_OPERATION_CANCELED);
           
              return(S_OK);
           }
        }
    }

    if ( dwErr = DsRemoveDsDomainW( ghDS, Name) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsRemoveDsDomainW", dwErr, GetW32Err (dwErr));
        return(S_OK);
    }
    //"\"%ws\" removed from server \"%ws\"\n"
    RESOURCE_PRINT2 (IDS_REMOVE_SERVER_SUCCESS, Name, gpwszServer);

    return(S_OK);
}

HRESULT RemoveDomain(CArgs *pArgs)
{
    WCHAR   *pwszDomain;
    WCHAR   *msg;
    DWORD   cBytes;
    DWORD   dwErr;
    int     ret;

    RETURN_IF_NOT_CONNECTED;

    if ( NULL == (pwszDomain = SelectGetCurrentDomain()) )
    {
        return(S_OK);
    }
    return(RemoveDomainOrNamingContext(pwszDomain,
                                       IDS_REMOVE_DOMAIN_CONFIRM_TITLE,
                                       IDS_REMOVE_DOMAIN_CONFIRM_MSG));
}

HRESULT RemoveNamingContext(CArgs *pArgs)
{
    WCHAR   *pwszNamingContext;
    WCHAR   *msg;
    DWORD   cBytes;
    DWORD   dwErr;
    int     ret;

    RETURN_IF_NOT_CONNECTED;

    if ( NULL == (pwszNamingContext = SelectGetCurrentNamingContext()) )
    {
        return(S_OK);
    }
    return(RemoveDomainOrNamingContext(pwszNamingContext,
                                       IDS_REMOVE_NC_CONFIRM_TITLE,
                                       IDS_REMOVE_NC_CONFIRM_MSG));
}

//
// This is the prototype of the API ntdsutil.exe calls from the
// ntfrsapi.dll.  Note that the code does a LoadLibrary as opposed to 
// statically linking so that ntdsutil can still be used even when the 
// ntfrsapi.dll is not available.
//
typedef DWORD (*NtdsUtil_NtFrsApi_DeleteSysvolMember) (
    IN SEC_WINNT_AUTH_IDENTITY_W *,  // credentials to bind with
    IN PWCHAR,                       // target dc
    IN PWCHAR,                       // ntds settings object dn
    IN OPTIONAL PWCHAR               // computer dn
    );

HRESULT FRSRemoveServer(
    IN LPWSTR pwszServer,
    IN LPWSTR pwszDomain
    )
//
// This routine will call NTFRSAPI::NtFrsApi_DeleteSysvolMember to remove
// the FRS related objects for pwszServer.
//
// This routine will only error if the NTFRSAPI API can't be snapped.
//
{
    DWORD dwErr = S_OK;
    HMODULE hMod = NULL;
    NtdsUtil_NtFrsApi_DeleteSysvolMember pfnFrsDelete = NULL;
    DWORD Size;

    LPWSTR ComputerDN = NULL, NtdsServerDN = NULL;
    LPWSTR NtdsaPrefix = L"CN=Ntds Settings,";

    //
    // Load the FRS API dll and snap the API
    //
    hMod = LoadLibraryA("ntfrsapi");
    if (hMod)
    {
        pfnFrsDelete = (NtdsUtil_NtFrsApi_DeleteSysvolMember) 
                        GetProcAddress(hMod,
                                      "NtFrsApi_DeleteSysvolMember");
    }

    if (NULL == pfnFrsDelete)
    {
        RESOURCE_PRINT(IDS_REMOVE_SERVER_NO_FRS_API);
        dwErr = E_FAIL;
        goto Exit;
    }


    //
    // Setup the computer DN if possible
    //
    if ( gServerInfo
    &&  (gServerInfo->cItems > DS_LIST_ACCOUNT_OBJECT_FOR_SERVER)
    &&  (DS_NAME_NO_ERROR == gServerInfo->rItems[DS_LIST_ACCOUNT_OBJECT_FOR_SERVER].status))
    {
        ComputerDN = gServerInfo->rItems[DS_LIST_ACCOUNT_OBJECT_FOR_SERVER].pName;
    }

    //
    // Add the Ntds Setting prefix
    //
    Size = ( wcslen( NtdsaPrefix )
           + wcslen( pwszServer )
           + 1 ) * sizeof( WCHAR );

    NtdsServerDN = (LPWSTR) malloc(Size);
    if (!NtdsServerDN)
    {
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        dwErr = E_FAIL;
        goto Exit;
    }
    wcscpy( NtdsServerDN, NtdsaPrefix );
    wcscat( NtdsServerDN, pwszServer );

    //
    // Call out to delete the object
    //
    dwErr =(*pfnFrsDelete)(gpCreds,      // creds to use
                           gpwszServer,  // target server
                           NtdsServerDN, // server to remove
                           ComputerDN    // computer object, if present
                           );


    if (dwErr != ERROR_SUCCESS) 
    {
        RESOURCE_PRINT2(IDS_REMOVE_SERVER_FRS_ERR, 
                        pwszServer, 
                        GetWinErrorMessage(dwErr));

        //
        // This won't fail the call
        //
        dwErr = S_OK;
        goto Exit;
    }

Exit:

    if (hMod)
    {
        FreeLibrary(hMod);
    }

    if (NtdsServerDN)
    {
        free(NtdsServerDN);
    }

    return dwErr;        
}



BOOL FRSRequirementsHandled(
    IN  LPWSTR pwszDomainDN,                                
    IN  LPWSTR pwszServerDN,                                
    OUT BOOL *fDeleteFRS
    )
//
// This routine determines if the connected server is a sufficient
// server to remove the requested Ntds Settings object from.  Ideally
// we want the destination server to in the same domain as the server
// that is being removed.  If this is not the case and a such a DC can be
// found then the operation is aborted.  Otherwise, if no such DC can be
// found then the user confirms that they want to continue (and remove
// just the Ntds Settings object).
//
// pwszDomainDN -- the DN of the domain that the to-be-deleted server
//                 belonged to
//
// pwszServerDN -- the DN of the to-be-deleted server
//
// fDeleteFRS -- set to TRUE if and only the connected server will handle
//               the request to delete the FRS objects.  FALSE otherwise.
//
//
{
    DWORD dwErr = S_OK;
    LPWSTR pwszTargetDomainDN = NULL;
    LPWSTR pwszTargetServerDN = NULL;
    LPWSTR pwszDomainDnsName = NULL;
    DOMAIN_CONTROLLER_INFOW *DCInfo = NULL;

    //
    // Validate in parameters
    //
    ASSERT(pwszDomainDN);

    //
    // Init the OUT parameter
    //
    *fDeleteFRS = FALSE;

    //
    // Extract LDAP_OPATT_SERVER_NAME_W from target server and
    // compare with pwszTargetServerDN
    //
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               LDAP_OPATT_SERVER_NAME_W,
                               &pwszTargetServerDN ) ) 
    {

        //
        // Error already printed
        //
        goto Exit;
    }

    if (EQUAL_STRING(pwszTargetServerDN, pwszServerDN)) 
    {
        //
        // Error -- can't delete one's own objects
        //
        RESOURCE_PRINT(IDS_REMOVE_SERVER_FRS_SAME);
        dwErr = E_FAIL;
        goto Exit;
    }


    //
    // Extract LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W from target server and
    // compare with pwszDomainDN
    //
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
                               &pwszTargetDomainDN ) ) 
    {

        //
        // Error already printed
        //
        goto Exit;
    }

    if (EQUAL_STRING(pwszTargetDomainDN, pwszDomainDN)) 
    {
        //
        // We are fine
        //
        *fDeleteFRS = TRUE;
        goto Exit;
    }

    //
    // The connected server is no good -- see if there is another server
    // available to service the request.
    //

    //
    // Translate DN form of domain name to DNS form
    //
    if (dwErr = GetDNSDomainFormat( pwszDomainDN,
                                   &pwszDomainDnsName)) 
    {
        //
        // Error already printed
        //
        goto Exit;
    }

    //
    // Make locator call to find if a DC that hosts this domain
    //
    dwErr = DsGetDcNameW(NULL,
                         pwszDomainDnsName,
                         NULL,
                         NULL,
                         0,
                         &DCInfo);
    if (ERROR_SUCCESS == dwErr)
    {
        //
        // A DC exists -- bail and suggest the user use another DC
        //
        RESOURCE_PRINT2(IDS_REMOVE_SERVER_FRS_SRV,
                        pwszDomainDnsName,
                        DCInfo->DomainControllerName);

        dwErr = E_FAIL;
        goto Exit;

    }
    else if (ERROR_NO_SUCH_DOMAIN == dwErr) 
    {
        //
        // We can't find a DC to remove the FRS objects from. Ensure that
        // the user really wants to continue.
        //
        if (fPopups) 
        {
            //
            // Ask the user if they really want to continue
            //
            const WCHAR * message_title = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_TITLE);
            const WCHAR * message_body;
            DWORD cBytes, ret;
            WCHAR * msg;
    
            message_body  = READ_STRING (IDS_REMOVE_SERVER_NO_FRS_SRV);
            
            cBytes =   wcslen(message_body)
                     + wcslen(pwszDomainDnsName)
                     + 1;
    
            msg = (WCHAR *) malloc(cBytes * sizeof (WCHAR));
    
            if ( !msg  )
            {
                RESOURCE_PRINT (IDS_MEMORY_ERROR);
                dwErr = E_FAIL;
                goto Exit;
            }
    
            wsprintfW(msg, 
                      message_body, 
                      pwszDomainDnsName); 
            
            ret = MessageBoxW(  GetFocus(),
                                msg,
                                message_title,
                                (   MB_APPLMODAL
                                  | MB_DEFAULT_DESKTOP_ONLY
                                  | MB_YESNO
                                  | MB_DEFBUTTON2
                                  | MB_ICONQUESTION
                                  | MB_SETFOREGROUND ) );
            free(msg);
            RESOURCE_STRING_FREE (message_body);
            RESOURCE_STRING_FREE (message_title);
    
            dwErr = E_FAIL;
            switch ( ret )
            {
            case 0:

                RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
                dwErr = E_FAIL;
                break;
    
            case IDYES:
    
                dwErr = S_OK;
                break;
    
            default:

                RESOURCE_PRINT (IDS_OPERATION_CANCELED);
                dwErr = E_FAIL;
                break;
            }
        } 
        else
        {
            //
            // No popups?  Let the operation continue
            //
            dwErr = S_OK;
        }

        goto Exit;

    }
    else
    {
        //
        // This is an unhandled error, continue and let the operation fail.
        //
        RESOURCE_PRINT2(IDS_REMOVE_SERVER_FRS_LOC_ERR,
                        pwszDomainDnsName,
                        GetWinErrorMessage(dwErr));
        
    }

Exit:

    if (pwszTargetDomainDN) 
    {
        free(pwszTargetDomainDN);
    }

    if (pwszTargetServerDN) 
    {
        free(pwszTargetServerDN);
    }

    if (pwszDomainDnsName) 
    {
        free(pwszDomainDnsName);
    }

    if (DCInfo) 
    {
        NetApiBufferFree(DCInfo);
    }

    return ( (dwErr == S_OK) ? TRUE : FALSE);
}

HRESULT
GetDNSDomainFormat(
    IN  LPWSTR pwszDomainDn,
    OUT LPWSTR *pwszDnsName
    )
//
// This routine determines the DNS domain name of the domain
// indicated by pwszDomainDn by searching the partitions container.
//
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD LdapError = 0;

    LDAPMessage  *SearchResult = NULL;

    LDAPMessage *Entry;
    WCHAR       *Attr;
    WCHAR       **Values;
    BerElement  *pBerElement;

    WCHAR  *DnsRootAttr       = L"dnsRoot";
    WCHAR  *ncName            = L"(ncName=";
    WCHAR  *Partitions        = L"CN=Partitions,";
    WCHAR  *ConfigDN          = NULL;
    WCHAR  *ncNameFilter      = NULL;
    WCHAR  *AttrArray[2];
    ULONG  Length;
    WCHAR  *BaseDn;

    //
    // Parameter check
    //
    ASSERT(pwszDomainDn);
    ASSERT(pwszDnsName);
    *pwszDnsName = NULL;


    //
    // Get the config DN
    //
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
                               &ConfigDN ) ) 
    {
        //
        // Error already printed
        //
        return E_FAIL;
    }

    //
    // Prepare the ldap search
    //
    AttrArray[0] = DnsRootAttr;
    AttrArray[1] = NULL;

    //
    // Prepare the filter
    //
    Length = wcslen( ncName ) + wcslen( pwszDomainDn ) + 3;
    Length *= sizeof( WCHAR );
    ncNameFilter = (WCHAR*) alloca( Length );
    wcscpy( ncNameFilter, ncName );
    wcscat( ncNameFilter, pwszDomainDn );
    wcscat( ncNameFilter, L")" );

    //
    // Prepare the base dn
    //
    Length = wcslen( ConfigDN ) + wcslen( Partitions ) + 1;
    Length *= sizeof( WCHAR );
    BaseDn = (WCHAR*) alloca( Length );
    wcscpy( BaseDn, Partitions );
    wcscat( BaseDn, ConfigDN );

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_sW(gldapDS,
                               BaseDn,
                               LDAP_SCOPE_ONELEVEL,
                               ncNameFilter,
                               AttrArray,
                               FALSE,  // return values, too
                               &SearchResult
                               );

    dwErr = LdapMapErrorToWin32(LdapError);

    if ( ERROR_SUCCESS == dwErr )
    {
        if ( 0 != ldap_count_entries( gldapDS, SearchResult ) )
        {
            for ( Entry = ldap_first_entry(gldapDS, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(gldapDS, Entry))
            {
                for( Attr = ldap_first_attributeW(gldapDS, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(gldapDS, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, DnsRootAttr ) )
                    {
                        Values = ldap_get_valuesW( gldapDS, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                             //
                             // Found it - these are NULL-terminated strings
                             //
                             ULONG len = wcslen(Values[0]);
                             *pwszDnsName = (WCHAR*)malloc((len+1) * sizeof(WCHAR));
                             if (*pwszDnsName) 
                             {
                                 wcscpy(*pwszDnsName, Values[0]);
                             }
                             break;
                        }
                    }
                }
            }
        }
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    if (ConfigDN)
    {
        free(ConfigDN);
    }

    if (NULL == *pwszDnsName)
    {
        RESOURCE_PRINT1(IDS_REMOVE_SERVER_NO_DNS,
                        pwszDomainDn);

        return E_FAIL;
    }
    else
    {
        return S_OK;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\reshdl.h ===
#ifndef __RESHDL_H
#define __RESHDL_H

// Helpers for reading strings from resources

extern int __cdecl ReadAllStrings ();
extern VOID __cdecl FreeAllStrings ();
extern WCHAR * __cdecl ReadStringFromResourceFile ( UINT uID );
const extern WCHAR * __cdecl ReadStringFromArray ( UINT uID );
extern int __cdecl printfRes( UINT FormatStringId, ... );


#define READ_STRING ReadStringFromArray
#define RESOURCE_STRING_FREE(res)  {res = NULL;}
#define DEFAULT_BAD_RETURN_STRING    L"*** Error: Cannot Find Resource String in memory\n"

#define RESOURCE_PRINT( resid )                          \
   {                                                     \
        const WCHAR * message = READ_STRING ( (resid) ); \
        if (message) {                                   \
           wprintf(message);                             \
        }                                                \
   }                                            

#define RESOURCE_PRINT1( resid, p1 )                     \
   {                                                     \
        const WCHAR * message = READ_STRING ( (resid) ); \
        if (message) {                                   \
           wprintf(message, (p1));                       \
        }                                                \
   }                                            

#define RESOURCE_PRINT2( resid, p1, p2 )                 \
   {                                                     \
        const WCHAR * message = READ_STRING ( (resid) ); \
        if (message) {                                   \
           wprintf(message, (p1), (p2));                 \
        }                                                \
   }

#define RESOURCE_PRINT3( resid, p1, p2, p3 )             \
   {                                                     \
        const WCHAR * message = READ_STRING ( (resid));  \
        if (message) {                                   \
           wprintf(message, (p1), (p2), (p3) );          \
        }                                                \
   }

#define RESOURCE_PRINT4( resid, p1, p2, p3, p4 )         \
   {                                                     \
        const WCHAR * message = READ_STRING ( (resid));  \
        if (message) {                                   \
           wprintf(message, (p1), (p2), (p3), (p4) );    \
        }                                                \
   }

#define RESOURCE_PRINT5( resid, p1, p2, p3, p4, p5 )     \
   {                                                     \
        const WCHAR * message = READ_STRING ( (resid));  \
        if (message) {                                   \
           wprintf(message, (p1), (p2), (p3), (p4), (p5)); \
        }                                                \
   }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\repl.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <objids.h>
#include "scheck.h"

#define COLS    4

JET_RETRIEVECOLUMN reprc[COLS] =  {
    {0, NULL, 512, 0, 0, 0, 1, 0, 0},
    {0, NULL, 2048, 0, 0, 0, 1, 0, 0},
    {0, NULL, 512, 0, 0, 0, 1, 0, 0},
    {0, NULL, sizeof(DWORD), 0, 0, 0, 1, 0, 0}
};

#define PAS     0   // partial attribute set
#define PMD     1   // property metadata vector
#define UTD     2   // up to date vector
#define SUBR    3   // subref value

VOID
CheckReplicationBlobs(
    VOID
    )
{
    JET_ERR err;
    DWORD i;
    JET_COLUMNDEF coldef;
    static BOOLEAN gotReplColumnId = FALSE;
    DWORD tmpSubRef;

    //
    // get column ids
    //

    if ( !gotReplColumnId ) {

        //
        // get the partial attribute set
        //

        if (err = JetGetTableColumnInfo(sesid, tblid, "ATTk590464", &coldef,
                sizeof(coldef), 0)) {

            Log(TRUE, "JetGetTableColumnInfo (Partial Attribute Set) for %d(%ws) failed [%S]\n",
                ulDnt, szRdn, GetJetErrString(err));
            return;
        }

        //printf("PAS: ColumnId %d type %d\n", coldef.columnid, coldef.coltyp);
        reprc[PAS].columnid = coldef.columnid;

        //
        // get the prop metadata
        //

        if (err = JetGetTableColumnInfo(sesid, tblid, "ATTk589827", &coldef,
                sizeof(coldef), 0)) {

            Log(TRUE, "JetGetTableColumnInfo (Property Metadata) for %d(%ws) failed [%S]\n",
                ulDnt, szRdn, GetJetErrString(err));
            return;
        }

        //printf("PMD: ColumnId %d type %d\n", coldef.columnid, coldef.coltyp);
        reprc[PMD].columnid = coldef.columnid;

        //
        // get the uptodate vector info
        //

        if (err = JetGetTableColumnInfo(sesid, tblid, "ATTk589828", &coldef,
                sizeof(coldef), 0)) {

            Log(TRUE, "JetGetTableColumnInfo (UpToDate Vector) for %d(%ws) failed [%S]\n",
                ulDnt, szRdn, GetJetErrString(err));
            return;
        }

        //printf("UTD: ColumnId %d type %d\n", coldef.columnid, coldef.coltyp);
        reprc[UTD].columnid = coldef.columnid;

        //
        // get the subref list
        //

        if (err = JetGetTableColumnInfo(sesid, tblid, "ATTb131079", &coldef,
                sizeof(coldef), 0)) {

            Log(TRUE, "JetGetTableColumnInfo (Subref List) for %d(%ws) failed [%S]\n",
                ulDnt, szRdn, GetJetErrString(err));
            return;
        }

        //printf("SUBREF: ColumnId %d type %d\n", coldef.columnid, coldef.coltyp);
        reprc[SUBR].columnid = coldef.columnid;
        gotReplColumnId = TRUE;
    }

    //
    // set length and buffer
    //

    for (i=0;i<COLS;i++) {

        if (reprc[i].pvData == NULL ) {
            reprc[i].pvData = LocalAlloc(0,reprc[i].cbData);

            if ( reprc[i].pvData == NULL ) {
                Log(TRUE,"Cannot allocate buffer for repl attribute #%d.\n",i);
                return;
            }
        }
    }

retry:
    err = JetRetrieveColumns(sesid, tblid, reprc, COLS);

    if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {
        Log(TRUE,"JetRetrieveColumn fetching replication blobs for %d(%ws) failed [%S]\n",
            ulDnt, szRdn, GetJetErrString(err));
    }

    if ( err == JET_wrnBufferTruncated ) {

        for (i=0;i<COLS;i++) {

            if ( reprc[i].err == JET_wrnBufferTruncated ) {
                if (ExpandBuffer(&reprc[i]) ) {
                    goto retry;
                }
            }
        }
    }

    //
    // The up to date vector is required for NCs, property metadata should be always
    // present
    //

    if ( reprc[PMD].err ) {

        err = reprc[PMD].err;

        if ( err == JET_wrnColumnNull ) {

            //
            // 1 is a real weird object.
            //

            if ( ulDnt != 1 ) {
                Log(TRUE,"Property Metadata vector missing for %d(%ws)\n",ulDnt,szRdn);
            }
        } else {
            Log(TRUE,"Retrieving property MetaData for %d(%ws) failed [%S]\n",
                ulDnt,szRdn,GetJetErrString(err));
        }
    } else {

        PROPERTY_META_DATA_VECTOR *pMDVec = (PROPERTY_META_DATA_VECTOR*)reprc[PMD].pvData;

        //
        // Check version.  Make sure we have the correct number of metadata
        //

        if ( VERSION_V1 != pMDVec->dwVersion ) {
            Log(TRUE,"Replication Metadata Vector for %d(%ws) has invalid version %d\n",
                   ulDnt, szRdn, pMDVec->dwVersion);
        } else {

            PROPERTY_META_DATA_VECTOR_V1 *pMDV1 =
                (PROPERTY_META_DATA_VECTOR_V1*)&pMDVec->V1;

            DWORD i;
            DWORD size1 = MetaDataVecV1Size(pMDVec);

            if ( size1 != reprc[PMD].cbActual ) {
                Log(TRUE,"Size[%d] of metadata vector for %d(%ws) does not match required size %d\n",
                       reprc[PMD].cbActual,ulDnt,szRdn,size1);
            }
        }
    }

    if ( (insttype & IT_NC_HEAD) != 0 ) {

        //
        // Process the up to date vector, if it exists
        //

        if ( reprc[UTD].err == 0 ) {

            UPTODATE_VECTOR *pUTD = (UPTODATE_VECTOR*)reprc[UTD].pvData;

            Log(VerboseMode,"INFO: UpToDate vector found for NC head %d(%ws)\n", ulDnt,szRdn);

            //
            // verify version
            //

            if ((pUTD->dwVersion != VERSION_V1) && (pUTD->dwVersion != VERSION_V2)) {
                Log(TRUE,"UpToDate vector for %d(%ws) has the wrong version [%d]\n",
                       ulDnt, szRdn, pUTD->dwVersion);
            }

            //
            // Make sure the size obtained matches the required one
            //

            if ( reprc[UTD].cbActual != UpToDateVecSize(pUTD) ) {

                Log(TRUE,"UpToDate vector for %d(%ws) has the wrong size [actual %d expected %d]\n",
                       ulDnt, szRdn, reprc[UTD].cbActual, UpToDateVecSize(pUTD));
            }
        } else if (reprc[UTD].err != JET_wrnColumnNull) {

            Log(TRUE,"Retrieving the UpToDate Vector for %d(%ws) failed [%S]\n",
                   ulDnt, szRdn, GetJetErrString(reprc[UTD].err));
        }

        //
        // Get The partial attributes list
        //

        if ( reprc[PAS].err == 0 ) {

            Log(VerboseMode, "INFO: Partial Attributes List found for NC head %d(%ws)\n",
                ulDnt,szRdn);
        }

        //
        // Make sure the subrefs point to NC heads
        //

        if ( reprc[SUBR].err == 0) {

            PREFCOUNT_ENTRY pEntry;
            DWORD seq;

            //
            // Find the entry and mark that it should be an NC head
            //

            tmpSubRef = (DWORD)(*((PDWORD)reprc[SUBR].pvData));
            pEntry = FindDntEntry(tmpSubRef,TRUE);
            pEntry->fSubRef = TRUE;

            //
            // See if we have more values
            //

            seq = 1;
            err = 0;
            do {

                DWORD alen;
                JET_RETINFO retInfo;

                retInfo.itagSequence = ++seq;
                retInfo.cbStruct = sizeof(retInfo);
                retInfo.ibLongValue = 0;
                err = JetRetrieveColumn(sesid,
                                        tblid,
                                        reprc[SUBR].columnid,
                                        reprc[SUBR].pvData,
                                        reprc[SUBR].cbData,
                                        &alen,
                                        0,
                                        &retInfo);

                if ( !err ) {

                    //
                    // Find the entry and mark that it should be an NC head
                    //

                    pEntry = FindDntEntry(tmpSubRef,TRUE);
                    pEntry->fSubRef = TRUE;
                }

            } while (!err);
        }
    }

    return;

} // CheckReplicationBlobs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\reshdl.cxx ===
#include <stdio.h>

#include "ntdsutil.hxx"
#include "debug.h"
#include "resource.h"


WCHAR *resource_strings [IDS_SIZE];

HINSTANCE g_hInst =  NULL;      // NULL is the current module (?)

const int ciAllocSize = 2048;   // num of unicode chars to use for buffers
                                // for the resource IDs

/*
 * ReadAllStrings
 *
 * Read all strings from resource file. (IDS_START - IDS_END)
 * 
 * Returns the number of strings read, 0 on error. 
 */
int __cdecl ReadAllStrings ()
{
    int iReturn, i, count;
    WCHAR *m_pwsz;

    count = 0;
    
    
    // Init everything to zero, just in case
    for (i=0; i<IDS_SIZE; i++) {
        resource_strings[i] = 0;
    }


    m_pwsz = (WCHAR *)malloc (ciAllocSize * sizeof (WCHAR));

    if ( ! m_pwsz ) {
        printf("Memory Allocation Error reading Resource Strings\n");
        return 0;
    }


    for (i=0; i<IDS_SIZE; i++) {
        iReturn = LoadStringW ( g_hInst, i + IDS_START, m_pwsz, ciAllocSize - 1 );

        if (iReturn) {
            resource_strings[i] = _wcsdup (m_pwsz);

            if (!resource_strings[i]) {
                printf("Error reading Resource Strings\n");
                return 0;
            }
            count++;
        }
        else {
            resource_strings[i] = 0;
        }
    }

    free (m_pwsz);

    return count;
}


VOID __cdecl FreeAllStrings ()
{
    int i;

    for (i=0; i<IDS_SIZE; i++) {
        if (resource_strings[i]) {
            free (resource_strings[i]);
            resource_strings[i] = 0;
        }
    }
}

const WCHAR * __cdecl ReadStringFromArray ( UINT uID )
/*++

  Routine Description:

    Read a particular string from the resource file in memory.
    
  Parameters:

    uID - ID of string

  Return Values:
     The string read
     Null on error
    
  Author
    Marios Zikos 12-16-98
--*/


{
    int iReturn;
    WCHAR *m_pwsz;

    m_pwsz = NULL;
    
    if (uID >= IDS_START && uID <= IDS_END && resource_strings [uID - IDS_START]) {
        m_pwsz = resource_strings [uID - IDS_START];
    }
    
    if (!m_pwsz) {
        if (resource_strings [IDS_ERR_CANNOT_READ_RESOURCE - IDS_START]){
            m_pwsz = resource_strings [IDS_ERR_CANNOT_READ_RESOURCE - IDS_START];
        }
        else {
            m_pwsz = DEFAULT_BAD_RETURN_STRING;
        }
    }

    return m_pwsz;
}



WCHAR * __cdecl ReadStringFromResourceFile ( UINT uID )
/*++

  Routine Description:

    Read a particular string from the resource file in memory.
    
  Parameters:

    uID - ID of string

  Return Values:
     The string read
     Null on error
    
  Author
    Marios Zikos 12-16-98
--*/


{
    int iReturn;
    WCHAR *m_pwsz;

    m_pwsz = (WCHAR *)malloc (ciAllocSize * sizeof (WCHAR));

    if ( ! m_pwsz ) {
        printf("Memory Allocation Error reading Resource Strings\n");
        return 0;
    }

    iReturn = LoadStringW ( g_hInst, uID, m_pwsz, ciAllocSize - 1 );

    if (iReturn == 0) {
       printf("Error reading Resource String with ID(%d)\n", uID);
       free (m_pwsz);
       m_pwsz = NULL;
    }

    return m_pwsz;
}



HRESULT
LoadResStrings ( 
      LegalExprRes *lang, 
      int cExpr 
      )
/*++

  Routine Description:

    Loads an array of strings from the resource file in memory.
    
  Parameters:

    *lang - LegalExprRes array of language expressions 
    cExpr - size of lang array

  Author
    Marios Zikos 12-16-98
--*/

{
   for ( int i = 0; i < cExpr; i++ )
   {
       // Load help string
       //
       lang[i].help = ReadStringFromArray (lang[i].u_help);
   }

   return S_OK;
}

int __cdecl printfRes( UINT FormatStringId, ... )
{
    int result;
    va_list vl;
    const WCHAR *formatString;

    va_start(vl, FormatStringId);
    
    formatString = READ_STRING (FormatStringId);


    if (formatString) {
        result = vfwprintf(stderr, formatString, vl);
    }
    else {
        result = 0;
    }

    va_end(vl);

    RESOURCE_STRING_FREE (formatString);

    return result;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_AR_AUTH_RESTORE_COMPLETE       1000
#define IDS_AR_AUTH_RESTORE_FAIL           1001
#define IDS_AR_ERR_CONVERT_FILE_TIME       1002
#define IDS_AR_ERR_CONVERT_LOCAL_TIME      1003 
#define IDS_AR_ERR_CONVERT_SYSTEM_TIME     1004
#define IDS_AR_ERR_FAIL_COMMIT_TRANS       1005
#define IDS_AR_ERR_FAIL_ROLLBACK_TRANS     1006
#define IDS_AR_ERR_FAILED_UPDATE_REC       1007
#define IDS_AR_ERR_FIND_SUBREF             1008
#define IDS_AR_ERR_GEN_INVOK_ID_DSA        1009
#define IDS_AR_ERR_MOVE_CURSOR_DIT         1010
#define IDS_AR_ERR_MOVE_IN_TABLE           1011
#define IDS_AR_ERR_PREPARE_UPDATE          1012
#define IDS_AR_ERR_SET_METADATA            1013
#define IDS_AR_ERR_SET_USN_CHANGED         1014
#define IDS_AR_ERR_SET_WHEN_CHANGED        1015
#define IDS_AR_ERR_START_TRANS             1016
#define IDS_AR_ERR_UPDATE_COLUMN           1017
#define IDS_AR_INCREASE_VERSION            1018
#define IDS_AR_OPEN_DB_DIT                 1019
#define IDS_AR_RECORDS_NON_UPDATED         1020
#define IDS_AR_RECORDS_REMAIN              1021
#define IDS_AR_RECORDS_UPDATE1             1022
#define IDS_AR_RECORDS_UPDATE2             1023
#define IDS_AR_RECORDS_UPDATE3             1024
#define IDS_AR_RECORDS_UPDATED             1025
#define IDS_AR_UPDATE_TIME                 1026
#define IDS_ASSERT_FAILED                  1027
#define IDS_AUTH_RESTORE_CONFIRM_MSG       1028
#define IDS_AUTH_RESTORE_CONFIRM_TITLE     1029
#define IDS_AUTH_RESTORE_DB_MSG            1030
#define IDS_AUTH_RESTORE_DB_VERINC_MSG     1031
#define IDS_AUTH_RESTORE_MSG               1032
#define IDS_AUTH_RESTORE_SUBTREE_MSG       1033
#define IDS_AUTH_RESTORE_SUBTREE_VINC_MSG  1034
#define IDS_BACKUP_PATH                    1035
#define IDS_BUFFER_OVERFLOW                1036
#define IDS_CANNOT_FIND_EXECUTABLE         1037
#define IDS_COMPACT_DEST_ERROR             1038
#define IDS_COMPACT_DISK_WARN              1039
#define IDS_COMPACT_FILE_EXISTS            1040
#define IDS_COMPACT_MISSING_DB             1041
#define IDS_COMPACT_PATH_ERROR             1042
#define IDS_COMPACT_SUCC_MSG               1043
#define IDS_CONNECT_BINDING1               1044
#define IDS_CONNECT_BINDING2               1045
#define IDS_CONNECT_CLEANUP1               1046
#define IDS_CONNECT_CLEANUP2               1047
#define IDS_CONNECT_CLEAR_CRED_MSG         1048
#define IDS_CONNECT_DOMAIN_MSG             1049
#define IDS_CONNECT_ERROR                  1050
#define IDS_CONNECT_INFO_MSG               1051 
#define IDS_CONNECT_INFO1                  1052
#define IDS_CONNECT_INFO2                  1053
#define IDS_CONNECT_LDAP_BIND_ERROR        1054
#define IDS_CONNECT_LDAP_OPEN_ERROR        1055
#define IDS_CONNECT_MSG                    1056
#define IDS_CONNECT_SET_CRED_MSG           1057
#define IDS_CONNECT_SRV_MSG                1058
#define IDS_CONTINUING                     1059
#define IDS_CREATING_DIR                   1060
#define IDS_CREATING_WINDOW                1061
#define IDS_DATABASE_PATH                  1062
#define IDS_DIT_ATTACH_ERR                 1063
#define IDS_DIT_CLOSE_ERR                  1064
#define IDS_DIT_CLOSEHIDENTBL_ERR          1065
#define IDS_DIT_DETACH_ERR                 1066
#define IDS_DIT_DISP_ATTR_TYPE_ERR         1067
#define IDS_DIT_DN_TOO_LONG_ERR            1068
#define IDS_DIT_FIND_OBJ_ERR               1069
#define IDS_DIT_GETDSACOL_ERR              1070
#define IDS_DIT_GETDSAINFO_ERR             1071
#define IDS_DIT_GETUSNCOL_ERR              1072
#define IDS_DIT_INVALIDKEY_DN_ERR          1073
#define IDS_DIT_MAKE_KEY_ERR               1074
#define IDS_DIT_MOVEHIDENTBL_ERR           1075
#define IDS_DIT_OPEN_ERR                   1076
#define IDS_DIT_OPENHIDENTBL_ERR           1077
#define IDS_DIT_PARSEDN_ERR                1078
#define IDS_DIT_PREPARE_HIDDENTBL_ERR      1079
#define IDS_DIT_RECOVER_ERR                1080
#define IDS_DIT_RETRUSNCOL_ERR             1081
#define IDS_DIT_SETUSNCOL_ERR              1082
#define IDS_DIT_UNEXPECTER_COLTYP_ERR      1083
#define IDS_DIT_UPDATEHIDDENTBL_ERR        1084
#define IDS_DM_MGMT_ADDING_OBJ             1085
#define IDS_DM_MGMT_ADDRESS_ERR            1086
#define IDS_DM_MGMT_BAD_RDN                1087
#define IDS_DM_MGMT_FOUND_NC               1088
#define IDS_DM_MGMT_LIST_MSG               1089
#define IDS_DM_MGMT_PRECREATE_MSG          1090
#define IDS_DM_MGMT_UNPARSABLE_DN          1091
#define IDS_DOMAIN_LIST_MSG                1092
#define IDS_DOMAIN_MGNT_MSG                1093
#define IDS_DOMAIN_PRECREATE_MSG           1094
#define IDS_DONE                           1095
#define IDS_DRIVE_FIXED                    1096
#define IDS_DRIVE_FREE_TOTAL               1097
#define IDS_DRIVE_INFO                     1098
#define IDS_DRIVE_NETWORK                  1099
#define IDS_DS_PATH_INFO                   1100
#define IDS_DSA_CLOSE_REGISTRY_KEY_ERR     1101
#define IDS_DSA_KEY_NOT_DWORD_ERR          1102
#define IDS_DSA_KEY_NOT_STRING_ERR         1103
#define IDS_DSA_OPEN_REGISTRY_KEY_ERR      1104
#define IDS_DSA_QUERY_REGISTRY_KEY_ERR     1105
#define IDS_ERR_BUFFER_OVERFLOW            1106
#define IDS_ERR_CANNOT_READ_RESOURCE       1107
#define IDS_ERR_CNV_UNICODE_ANSI           1108
#define IDS_ERR_DIR_NOT_EXIST              1109
#define IDS_ERR_FILE_EXISTS                1110
#define IDS_ERR_FINDING_1st_MATCH          1111
#define IDS_ERR_FINDING_Nth_MATCH          1112
#define IDS_ERR_GET_LOGICAL_DRIVE_STRS     1113
#define IDS_ERR_GETTING_SIZE               1114
#define IDS_ERR_INTERNAL                   1115
#define IDS_ERR_INTERNAL_FILE_LINE         1116
#define IDS_ERR_INVALID_PATH               1117
#define IDS_ERR_LOG_FILE_EXISTS            1118
#define IDS_ERR_MEMORY_ALLOCATION          1119
#define IDS_ERR_NO_DB_FILE_SPECIFIED       1120
#define IDS_ERR_NO_LOCAL_DRIVE             1121
#define IDS_ERR_NO_LOGS_IN_SOURCE          1122
#define IDS_ERR_NO_LOGS_SPECIFIED          1123
#define IDS_ERR_OLD_NEW_PATHS_SAME         1124
#define IDS_ERR_OPENING_REGISTRY           1125
#define IDS_ERR_READING_REGISTRY           1126
#define IDS_ERR_SOFT_RECOVERY              1127
#define IDS_ERR_SOURCE_FILE_EMPTY          1128
#define IDS_ERR_SOURCE_FILE_IS_DIR         1129
#define IDS_ERR_SOURCE_FILE_NOT_EXIST      1130
#define IDS_ERR_SOURCE_NOT_DIR             1131
#define IDS_ERR_WRITING_REG_KEY            1132 
#define IDS_EXECUTING_COMMAND              1133
#define IDS_FAIL_READ_ATTRIBUTE            1134
#define IDS_FAILED                         1135
#define IDS_FILES_COMPACT_MSG              1136
#define IDS_FILES_HEADER_MSG               1137
#define IDS_FILES_INFO_MSG                 1138
#define IDS_FILES_JET_INTEGRITY_MSG        1139
#define IDS_FILES_MOVE_DB_MSG              1140
#define IDS_FILES_MOVE_LOGS_MSG            1141
#define IDS_FILES_MSG                      1142
#define IDS_FILES_RECOVER_MSG              1143
#define IDS_FILES_REPAIR_MSG               1144
#define IDS_FILES_SET_BACKUP_PATH_MSG      1145
#define IDS_FILES_SET_DB_PATH_MSG          1146
#define IDS_FILES_SET_LOGS_PATH_MSG        1147
#define IDS_FILES_SET_WRK_PATH_MSG         1148
#define IDS_FSMO_ABANDON_ALL_MSG           1149
#define IDS_FSMO_SEIZE_DN_MSG              1150
#define IDS_FSMO_SEIZE_INFRASTR_MSG        1151
#define IDS_FSMO_SEIZE_PDC_MSG             1152
#define IDS_FSMO_SEIZE_RID_MSG             1153
#define IDS_FSMO_SEIZE_SCHEMA_MSG          1154
#define IDS_FSMO_TRANFER_DN_MSG            1155
#define IDS_FSMO_TRANFER_INFRASTR_MSG      1156
#define IDS_FSMO_TRANFER_PDC_MSG           1157
#define IDS_FSMO_TRANFER_RID_MSG           1158
#define IDS_FSMO_TRANFER_SCHEMA_MSG        1159
#define IDS_FSMOXFER_ABANDON_ROLES         1160
#define IDS_FSMOXFER_ATTEMPT_TRFR          1161
#define IDS_FSMOXFER_ATTEMPT_TRFR_FAIL     1162
#define IDS_FSMOXFER_ATTEMPT_TRFR_SUC      1163
#define IDS_FSMOXFER_BECOME_DM_MSTR        1164
#define IDS_FSMOXFER_BECOME_INF_MSTR       1165
#define IDS_FSMOXFER_BECOME_PDC            1166
#define IDS_FSMOXFER_BECOME_RIDMASTER      1167
#define IDS_FSMOXFER_BECOME_SCH_MSTR       1168
#define IDS_FSMOXFER_CNV_TXT_SD_ERR        1169

#define IDS_FSMOXFER_MSG1_TITLE            1171
#define IDS_FSMOXFER_MSG2                  1172
#define IDS_FSMOXFER_MSG2_TITLE            1173
#define IDS_FSMOXFER_MSG3                  1174
#define IDS_FSMOXFER_MSG3_TITLE            1175
#define IDS_FSMOXFER_NEIGHBOURHOOD_WARN    1176
#define IDS_FSMOXFER_OVERFLOW_INC_RID      1177
#define IDS_FSMOXFER_PARSE_REPL_LINKS      1178
#define IDS_FSMOXFER_PARSE_RID_POOL        1179
#define IDS_FSMOXFER_PREV_RID_ERR          1180
#define IDS_FSMOXFER_PROC_AVAIL_RID_POOL   1181
#define IDS_FSMOXFER_QUERY_CUR_SVR         1182
#define IDS_FSMOXFER_QUERY_RID_MGR         1183
#define IDS_FSMOXFER_QUERY_RID_POOL        1184
#define IDS_FSMOXFER_SVR_ALREADY_RID       1185
#define IDS_FSMOXFER_SYNCHRONIZE_WARN      1186
#define IDS_FSMOXFER_SYNCHRONIZING_MSG     1187
#define IDS_FSMOXFER_USE_ACL_REPAIR        1188
#define IDS_GENERAL_ERROR1                 1189
#define IDS_HELP_MSG                       1190
#define IDS_HELP_MSG_BANNER1               1191
#define IDS_HELP_MSG_BANNER2               1192
#define IDS_INTEGRITY_SUCC_MSG             1193
#define IDS_INVALID_ON_OFF                 1194
#define IDS_IPDENY_ADD_MSG                 1195
#define IDS_IPDENY_BAD_FORMAT_PAIR         1196
#define IDS_IPDENY_CANCEL_MSG              1197
#define IDS_IPDENY_COMMIT_MSG              1198
#define IDS_IPDENY_DELETE_MSG              1199
#define IDS_IPDENY_GET_VALUES_ERR          1200
#define IDS_IPDENY_INDEX_ERR               1201
#define IDS_IPDENY_INDEXRETR_ERR           1202
#define IDS_IPDENY_INVALID_IP              1203
#define IDS_IPDENY_INVALID_MASK            1204
#define IDS_IPDENY_IP_ALLOW                1205
#define IDS_IPDENY_IP_DENY                 1206
#define IDS_IPDENY_LDAP_ATTR_FAIL          1207
#define IDS_IPDENY_LDAP_CON_ERR            1208
#define IDS_IPDENY_LDAP_SEARCH_FAIL        1209
#define IDS_IPDENY_LIST_MSG                1210
#define IDS_IPDENY_MARK_DELETE             1211
#define IDS_IPDENY_MASK_RETR_ERR           1212
#define IDS_IPDENY_MEM_COMMIT_ERR          1213
#define IDS_IPDENY_NOTE                    1214
#define IDS_IPDENY_POLICY_RETR_ERR         1215
#define IDS_IPDENY_SHOW_MSG                1216
#define IDS_IPDENY_TEST_MSG                1217
#define IDS_IPDENY_ZERO_LIST               1218
#define IDS_JET_CRITICAL_DB_ERR            1219
#define IDS_JET_ERRBACKUPINPROGRESS        1220
#define IDS_JET_ERRBUFFERTOOSMALL          1221
#define IDS_JET_ERRCOLUMNDOESNOTFIT        1222
#define IDS_JET_ERRCOLUMNILLEGALNULL       1223
#define IDS_JET_ERRCOLUMNNOTFOUND          1224
#define IDS_JET_ERRCOLUMNNOTUPDATABLE      1225
#define IDS_JET_ERRCOLUMNTOOBIG            1226
#define IDS_JET_ERRDATABASEINCONSISTENT    1227
#define IDS_JET_ERRDATABASEINUSE           1228
#define IDS_JET_ERRDATABASENOTFOUND        1229
#define IDS_JET_ERRFILEACCESSDENIED        1230
#define IDS_JET_ERRFILENOTFOUND            1231
#define IDS_JET_ERRINVALIDBUFFERSIZE       1232
#define IDS_JET_ERRINVALIDDATABASEID       1233
#define IDS_JET_ERRINVALIDNAME             1234
#define IDS_JET_ERRINVALIDPARAMETER        1235
#define IDS_JET_ERRINVALIDSESID            1236
#define IDS_JET_ERRINVALIDTABLEID          1237
#define IDS_JET_ERRKEYDUPLICATE            1238
#define IDS_JET_ERRKEYISMADE               1239
#define IDS_JET_ERRKEYNOTMADE              1240
#define IDS_JET_ERRNOCURRENTINDEX          1241
#define IDS_JET_ERRNOCURRENTRECORD         1242
#define IDS_JET_ERRNOTINITIALIZED          1243
#define IDS_JET_ERRNOTINTRANSACTION        1244
#define IDS_JET_ERRNULLKEYDISALLOWED       1245
#define IDS_JET_ERROBJECTNOTFOUND          1246
#define IDS_JET_ERROR                      1247
#define IDS_JET_ERRPERMISSIONDENIED        1248
#define IDS_JET_ERRSUCCESS                 1249
#define IDS_JET_ERRTABLEINUSE              1250
#define IDS_JET_ERRTABLELOCKED             1251
#define IDS_JET_ERRTOOMANYACTIVEUSERS      1252
#define IDS_JET_ERRTOOMANYOPENDATABASES    1253
#define IDS_JET_ERRTOOMANYOPENTABLES       1254
#define IDS_JET_ERRTRANSTOODEEP            1255
#define IDS_JET_ERRUPDATENOTPREPARED       1256
#define IDS_JET_ERRWRITECONFLICT           1257
#define IDS_JET_GENERIC_ERR1               1258
#define IDS_JET_GENERIC_ERR2               1259
#define IDS_JET_GENERIC_WRN                1260
#define IDS_JET_OPEN_DATABASE              1261
#define IDS_JET_SET_PARAMETER_ERR          1262
#define IDS_JET_WARNING                    1263
#define IDS_JET_WRNBUFFERTRUNCATED         1264
#define IDS_JET_WRNCOLUMNNULL              1265
#define IDS_JETBEGINSESSION_ERR            1266
#define IDS_JETBEGINTRANS_ERR              1267
#define IDS_JETCLOSETABLE_ERR              1268
#define IDS_JETCOMMITTRANSACTION_ERR       1269
#define IDS_JETCOUNTREC_ERR                1270
#define IDS_JETENDSESSION_ERR              1271
#define IDS_JETGETCOLUMNINFO_ERR           1272
#define IDS_JETINIT_ERR                    1273
#define IDS_JETMAKEKEY_ERR                 1274
#define IDS_JETMOVE_ERR                    1275
#define IDS_JETOPENTABLE_ERR               1276
#define IDS_JETPREPARE_ERR                 1277
#define IDS_JETRETRIEVECOLUMN_ERR          1278
#define IDS_JETROLLBACK_ERR                1279
#define IDS_JETSEEK_ERR                    1280
#define IDS_JETSETCOLUMN_ERR               1281
#define IDS_JETSETINDEX_ERR                1282
#define IDS_JETTERM_ERR                    1283
#define IDS_JETUPDATE_ERR                  1284
#define IDS_LDAP_ADDW_FAIL                 1285
#define IDS_LDAP_EXT_ERROR                 1286
#define IDS_LDAP_MODIFY_ERR                1287
#define IDS_LDAP_MODIFY_FSMOROLE_ERR       1288
#define IDS_LDAP_MODIFY_RID_ERR            1289
#define IDS_LDAP_MODIFY_SD_ERR             1290
#define IDS_LDAP_NO_RIGHTS                 1291
#define IDS_LDAP_POLICIES_CANCEL_MSG       1292
#define IDS_LDAP_POLICIES_COMMIT_MSG       1293
#define IDS_LDAP_POLICIES_INFO             1294
#define IDS_LDAP_POLICIES_LIMIT_ERR        1295
#define IDS_LDAP_POLICIES_LIST_ERR         1296
#define IDS_LDAP_POLICIES_LIST_MSG         1297
#define IDS_LDAP_POLICIES_MEMORY1_ERR      1298
#define IDS_LDAP_POLICIES_MEMORY2_ERR      1299
#define IDS_LDAP_POLICIES_MODIFY_ERR       1300
#define IDS_LDAP_POLICIES_MSG              1301
#define IDS_LDAP_POLICIES_NAME_ERR         1302
#define IDS_LDAP_POLICIES_NO_COMMIT        1303
#define IDS_LDAP_POLICIES_NO_ENTRIES1      1304
#define IDS_LDAP_POLICIES_NO_ENTRIES2      1305
#define IDS_LDAP_POLICIES_NO_RIGHTS1       1306
#define IDS_LDAP_POLICIES_NO_RIGHTS2       1307
#define IDS_LDAP_POLICIES_NOTFOUND         1308
#define IDS_LDAP_POLICIES_RETRIVE_ERR      1309
#define IDS_LDAP_POLICIES_SEARCH_ENTRY_ERR 1310
#define IDS_LDAP_POLICIES_SEARCH1_ERR      1311
#define IDS_LDAP_POLICIES_SEARCH2_ERR      1312
#define IDS_LDAP_POLICIES_SEARCH3_ERR      1313
#define IDS_LDAP_POLICIES_SET_VAL_MSG      1314
#define IDS_LDAP_POLICIES_SHOW_VAL_MSG     1315
#define IDS_LDAP_POLICIES_SUPPORTED        1316
#define IDS_LDAP_POLICIES_VALUE_ERR        1317
#define IDS_LDAP_READ_SD_ERR               1318
#define IDS_LDAP_READ_SD_ERR1              1319
#define IDS_LDAP_SEARCH_ATTR_ERR           1320
#define IDS_LDAP_SEARCH_ERR                1321
#define IDS_LOG_PATH                       1322
#define IDS_MEMORY_ERROR                   1323
#define IDS_MESSAGE_BOX_ERROR              1324
#define IDS_METADATA_CLEANUP_MSG           1325
#define IDS_MOVE_DB_SUCC_MSG               1326
#define IDS_MOVE_LOGS_SUCC_MSG             1327
#define IDS_NO                             1328
#define IDS_NO_DN_ENTRY                    1329
#define IDS_NO_ENTRY                       1330
#define IDS_NO_ERROR_MAPPING               1331
#define IDS_NOT_CONNECTED                  1332
#define IDS_OFF                            1333
#define IDS_ON                             1334
#define IDS_OPEN_SCRIPT_ERROR              1335
#define IDS_OPERATION_CANCELED             1336
#define IDS_POPUPS_DISABLED                1337
#define IDS_POPUPS_ENABLED                 1338
#define IDS_POPUPS_MSG                     1339
#define IDS_PROMPT_AUTH_RESTORE            1340
#define IDS_PROMPT_DOMAIN_MGMT             1341
#define IDS_PROMPT_FILE_MAINTAINANCE       1342
#define IDS_PROMPT_FSMO_MAINTAINANCE       1343
#define IDS_PROMPT_IP_DENY                 1344
#define IDS_PROMPT_LDAP_POLICY             1345
#define IDS_PROMPT_METADATA_CLEANUP        1346
#define IDS_PROMPT_SCHECK                  1347
#define IDS_PROMPT_SELECT                  1348
#define IDS_PROMPT_SRV_CONNECTIONS         1349
#define IDS_QUIT_MSG                       1350
#define IDS_RECOVER_SUCC_MSG               1351
#define IDS_REFC_COL_ALLOC_ERR             1352
#define IDS_REFC_DNT_SEEK_ERR              1353
#define IDS_REFC_ERR_FETCH_SEC_DESC        1354
#define IDS_REFC_INSTANCE_TYPE             1355
#define IDS_REFC_MEM_ERR1                  1356
#define IDS_REFC_MEM_ERR2                  1357
#define IDS_REFC_MEM_ERR3                  1358
#define IDS_REFC_MEM_ERR4                  1359
#define IDS_REFC_NOINSTANCE_TYPE           1360
#define IDS_REFC_PROC_RECORDS              1361
#define IDS_REFC_REC_SCANNED               1362
#define IDS_REFC_RESULTS1                  1363
#define IDS_REFC_RESULTS2                  1364
#define IDS_REFC_SEC_DESC_NOTPRESENT       1365
#define IDS_REFC_SEC_DESC_PRESENT          1366
#define IDS_REFC_TABLE_ALLOC_ERR           1367
#define IDS_REMOVE_DOMAIN_CONFIRM_MSG      1368
#define IDS_REMOVE_DOMAIN_CONFIRM_TITLE    1369
#define IDS_REMOVE_DOMAIN_MSG              1370
#define IDS_REMOVE_SERVER_CONFIRM_MSG1     1371
#define IDS_REMOVE_SERVER_CONFIRM_MSG2     1372
#define IDS_REMOVE_SERVER_CONFIRM_TITLE    1373
#define IDS_REMOVE_SERVER_MSG              1374
#define IDS_REMOVE_SERVER_SUCCESS          1375

#define IDS_RESTORE_CHK1                   1377
#define IDS_RETURN_MENU_MSG                1378
#define IDS_ROLES_MSG                      1379
#define IDS_SAFE_MODE_ERROR                1380
#define IDS_SCHECK_GET_MSG                 1381
#define IDS_SCHECK_GET_REC_COUNT1          1382
#define IDS_SCHECK_GET_REC_COUNT2          1383
#define IDS_SCHECK_GO_MSG                  1384
#define IDS_SCHECK_OPEN_LOG_ERR            1385
#define IDS_SCHECK_VERBOSE_DISABLED        1386
#define IDS_SCHECK_VERBOSE_ENABLED         1387
#define IDS_SCHECK_VERBOSE_MSG             1388
#define IDS_SCHECK_WRITING_LOG             1389
#define IDS_SELECT_DOMAIN_MSG              1390
#define IDS_SELECT_LIST_DOMAIN_SRV_MSG     1391
#define IDS_SELECT_LIST_DOMAINS_CR_MSG     1392
#define IDS_SELECT_LIST_DOMAINS_MSG        1393
#define IDS_SELECT_LIST_MSG                1394
#define IDS_SELECT_LIST_ROLES_MSG          1395
#define IDS_SELECT_LIST_SERVERS_MSG        1396
#define IDS_SELECT_LIST_SITES_MSG          1397
#define IDS_SELECT_MSG                     1398
#define IDS_SELECT_NO_ACTIVE_DOMAIN_LIST   1399
#define IDS_SELECT_NO_ACTIVE_SERVER_LIST   1400
#define IDS_SELECT_NO_ACTIVE_SITE_LIST     1401
#define IDS_SELECT_NO_DOMAIN1              1402
#define IDS_SELECT_NO_DOMAIN2              1403
#define IDS_SELECT_NO_SERVER1              1404
#define IDS_SELECT_NO_SERVER2              1405
#define IDS_SELECT_NO_SITE1                1406
#define IDS_SELECT_NO_SITE2                1407
#define IDS_SELECT_PRINT_COMPUTER          1408
#define IDS_SELECT_PRINT_DNS               1409
#define IDS_SELECT_PRINT_DOMAIN            1410
#define IDS_SELECT_PRINT_DSA               1411
#define IDS_SELECT_PRINT_FOUND_DOMAINS     1412
#define IDS_SELECT_PRINT_FOUND_SERVERS     1413
#define IDS_SELECT_PRINT_FOUND_SITES       1414
#define IDS_SELECT_PRINT_INFRASTR          1415
#define IDS_SELECT_PRINT_PDC               1416
#define IDS_SELECT_PRINT_RID               1417
#define IDS_SELECT_PRINT_SCHEMA            1418
#define IDS_SELECT_PRINT_SERVER            1419
#define IDS_SELECT_PRINT_SITE              1420
#define IDS_SELECT_PRINT_UNKNOWN           1421
#define IDS_SELECT_ROLE_ITEM_ERR           1422
#define IDS_SELECT_SEL_OUT_OF_RANGE        1423
#define IDS_SELECT_SERVER_MSG              1424
#define IDS_SELECT_SERVER_ROLES            1425
#define IDS_SELECT_SITE_MSG                1426
#define IDS_SEMANTIC_DB_ANALYSIS_MSG       1427
#define IDS_SPAWN_EXTERNAL_COMMAND         1428
#define IDS_SPAWN_PROC_EXIT_CODE           1429
#define IDS_SUCCESS                        1430
#define IDS_TIME                           1431
#define IDS_UNKNOWN                        1432
#define IDS_USING_TEMP_PATH                1433
#define IDS_W32_ERROR                      1434
#define IDS_WORK_PATH                      1435
#define IDS_WRN_GET_FREE_SPACE             1436
#define IDS_WRN_GET_VOLUME_INFO            1437
#define IDS_WRN_READING                    1438
#define IDS_YES                            1439
#define IDS_SAM_MSG                        1440
#define IDS_PROMPT_SAM_MAINTENANCE         1441 
#define IDS_SAM_CONNECT_SERVER_MSG         1442
#define IDS_SAM_CONNECT_ERROR              1443
#define IDS_SAM_NOT_CONNECTED              1444
#define IDS_SAM_CANT_OPEN_ACCOUNT_DOMAIN   1445
#define IDS_SAM_EXCEPTION                  1446
#define IDS_SAM_DUP_SID_CLEANUP_MSG        1447
#define IDS_SAM_CANT_CREATE_LOG_FILE       1448
#define IDS_SAM_DUP_SID_CLEANUP_AND        1449
#define IDS_SAM_DUP_SID_CLEANUP_STATUS     1450
#define IDS_SAM_DUP_SID_CLEANUP_END        1451
#define IDS_SAM_DUPLICATE_SID_CHECK_ONLY   1452 
#define IDS_SAM_DUPLICATE_SID_CLEANUP      1453
#define IDS_SAM_SPECIFY_LOG_FILE           1454
#define IDS_SAM_INVALID_LOG_FILE_NAME      1455
#define IDS_SAM_DUP_SID_CHECK_FAILED       1456
#define IDS_SAM_DUP_SID_CHECK_SUCCEED      1457
#define IDS_SAM_DUP_SID_CLEANUP_FAILED     1458
#define IDS_SAM_DUP_SID_CLEANUP_SUCCEED    1459
#define IDS_SCHECK_SCHEMA_REPAIR_MSG       1460
#define IDS_SEIZURE_FORBIDDEN              1461
#define IDS_FIXUP_MSG                      1462
#define IDS_SCHECK_GO_FIXUP_MSG            1463
#define IDS_MOVE_DB_DISK_SPACE_ERR         1464
#define IDS_MOVE_LOGS_DISK_SPACE_ERR       1465
#define IDS_SCH_REPAIR_WRONG_VER           1466
#define IDS_SCH_REPAIR_LOG_ERROR           1467
#define IDS_SCH_REPAIR_CONFIRM_MSG         1468
#define IDS_SCH_REPAIR_CONFIRM_TITLE       1469
#define IDS_SCH_REPAIR_CONFLICT_FOUND      1470
#define IDS_SCH_REPAIR_GUID_NOTFOUND       1471
#define IDS_SCH_REPAIR_ATT_NOTFOUND        1472
#define IDS_SCH_REPAIR_FIND_FAILURE        1473
#define IDS_SCH_REPAIR_FIND_TITLE          1474
#define IDS_SCH_REPAIR_FIND_DETAIL         1475
#define IDS_SCH_REPAIR_DEL_SUCCESS         1476
#define IDS_SCH_REPAIR_DEL_FAILURE         1477
#define IDS_SCH_REPAIR_REF_FIXUP           1478
#define IDS_SCH_REPAIR_NONE_DETECTED       1479
//
// Support the removal of a naming context (aka cross reference)
//
#define IDS_SELECT_LIST_NCS_MSG            1480
#define IDS_SELECT_PRINT_FOUND_NCS         1481
#define IDS_SELECT_NC_MSG                  1482
#define IDS_SELECT_NO_ACTIVE_NC_LIST       1483
#define IDS_SELECT_PRINT_NC                1484
#define IDS_SELECT_NO_NC1                  1485
#define IDS_SELECT_NO_NC2                  1486
#define IDS_REMOVE_NC_MSG                  1487
#define IDS_REMOVE_NC_CONFIRM_MSG          1488
#define IDS_REMOVE_NC_CONFIRM_TITLE        1489
//
// Better error messages for List Roles
//
#define IDS_SELECT_ROLE_INFRASTRUCTURE_NOT_FOUND 1490
#define IDS_SELECT_ROLE_SCHEMA_NOT_FOUND         1491
#define IDS_SELECT_ROLE_DOMAIN_NOT_FOUND         1492
#define IDS_SELECT_ROLE_PDC_NOT_FOUND            1493
#define IDS_SELECT_ROLE_RID_NOT_FOUND            1494
//
//  added for "authoritatively restore object"
//
#define IDS_AUTH_RESTORE_OBJECT_MSG        1495
#define IDS_AUTH_RESTORE_OBJECT_VINC_MSG   1496
//
// Added for RID seizure
//
#define IDS_FSMOXFER_CREDENTIALS            1497
#define IDS_FSMOXFER_DN                     1498
#define IDS_FSMOXFER_OP_ATTR                1499
#define IDS_FSMOXFER_NO_DCS                 1500
#define IDS_FSMOXFER_SLEEP_BIND             1501
#define IDS_FSMOXFER_SLEEP_SEARCH           1502

//
// Added for Configurable Settings
//
#define IDS_CONFSET_CANCEL_MSG              1503
#define IDS_CONFSET_COMMIT_MSG              1504
#define IDS_CONFSET_INFO                    1505
#define IDS_CONFSET_SETTINGS_ERR            1506
#define IDS_CONFSET_LIST_ERR                1507
#define IDS_CONFSET_LIST_MSG                1508
#define IDS_CONFSET_MEMORY1_ERR             1509
#define IDS_CONFSET_MEMORY2_ERR             1510
#define IDS_CONFSET_MODIFY_ERR              1511
#define IDS_CONFSET_MSG                     1512
#define IDS_CONFSET_NAME_ERR                1513
#define IDS_CONFSET_NO_COMMIT               1514
#define IDS_CONFSET_NO_ENTRIES1             1515
#define IDS_CONFSET_NO_ENTRIES2             1516
#define IDS_CONFSET_NO_RIGHTS1              1517
#define IDS_CONFSET_NO_RIGHTS2              1518
#define IDS_CONFSET_NOTFOUND                1519
#define IDS_CONFSET_RETRIVE_ERR             1520
#define IDS_CONFSET_SEARCH_ENTRY_ERR        1521
#define IDS_CONFSET_SEARCH1_ERR             1522
#define IDS_CONFSET_SEARCH2_ERR             1523
#define IDS_CONFSET_SEARCH3_ERR             1524
#define IDS_CONFSET_SET_VAL_MSG             1525
#define IDS_CONFSET_SHOW_VAL_MSG            1526
#define IDS_CONFSET_SUPPORTED               1527
#define IDS_CONFSET_VALUE_ERR               1528
#define IDS_PROMPT_CONFSET                  1529
#define IDS_CONFSET_RANGE                   1530

//
// Added for Non-Domain Naming Contexts
//
#define IDS_DM_MGMT_CREATE_NDNC            1531
#define IDS_DM_MGMT_DELETE_NDNC            1532
#define IDS_DM_MGMT_ADD_NDNC_REPLICA       1533
#define IDS_DM_MGMT_REMOVE_NDNC_REPLICA    1534
#define IDS_DM_MGMT_SET_NDNC_REF_DOM       1535
#define IDS_DM_MGMT_SET_NDNC_REPL_DELAYS   1536
#define IDS_DM_MGMT_LIST_NDNC_REPLICAS     1537
#define IDS_DM_MGMT_LIST_NDNC_INFO         1538
#define IDS_DM_MGMT_NAMING_FSMO_CONN       1539

//
// Authoritative restore of linked values
//
#define IDS_AR_ERR_SET_DEL_TIME             1540
#define IDS_AR_ERR_UNKNOWN_VALUE_METADATA_FORMAT   1541

// More for Non-Domain Naming Contexts.
#define IDS_DM_MGMT_BAD_DNS                 1542
#define IDS_DM_MGMT_NDNC_LIST_HEADER        1543
#define IDS_DM_MGMT_NDNC_LIST_FOOTER        1544
#define IDS_DM_MGMT_NC_REPL_DELAY_1         1545
#define IDS_DM_MGMT_NC_REPL_DELAY_2         1546
#define IDS_DM_MGMT_NDNC_SD_REF_DOM         1547
#define IDS_DM_MGMT_NC_NO_INFO              1548
#define IDS_DM_MGMT_NDNC_LIST_NO_REPLICAS   1549
#define IDS_DM_MGMT_NDNC_SERVER_DUPLICATES  1550
#define IDS_DM_MGMT_NDNC_SERVER_COULDNT_FIND   1551

//Added for behavior version management
#define IDS_DS_VER_INFO_MSG                 1552
#define IDS_DS_VER_RAISE_DOMAIN_MSG         1553
#define IDS_DS_VER_RAISE_FOREST_MSG         1554
#define IDS_PROMPT_DS_VER                   1555

#define IDS_VER_MSG                         1557
#define IDS_DS_VER_DOMAIN_MSG               1558
#define IDS_DS_VER_FOREST_MSG               1559
#define IDS_DS_VER_CHANGE_CONFIRM_TITLE     1560
#define IDS_DS_VER_CHANGE_CONFIRM_MSG       1561


// Added for reporting errors in the connection menu
#define IDS_CONNECT_LDAP_GET_OPTION_ERROR  1565
#define IDS_CONNECT_LDAP_SET_OPTION_ERROR  1566

// Set path security errors
#define IDS_ERR_GET_SECURITY_INFO             1567
#define IDS_ERR_SET_SECURITY_INFO             1568
#define IDS_ERR_SET_ENTRIES_ACL                1569

// Description attribute value on a NDNC head object.
#define IDS_DM_MGMT_NDNC_DESC                1570

#define IDS_GET_DOMAIN_NAMING_FSMO_ERROR    1571
#define IDS_BIND_DOMAIN_NAMING_FSMO_ERROR   1572
#define IDS_DM_MGMT_NDNC_LIST_FOOTER_2      1573


//
// Support for deleting FRS objects
//
#define IDS_REMOVE_SERVER_FRS_SRV      1574
#define IDS_REMOVE_SERVER_NO_DNS       1575
#define IDS_REMOVE_SERVER_NO_FRS_SRV   1576
#define IDS_REMOVE_SERVER_NO_FRS_API   1577
#define IDS_REMOVE_SERVER_FRS_ERR      1578
#define IDS_REMOVE_SERVER_FRS_LOC_ERR  1579
#define IDS_REMOVE_SERVER_FRS_SAME     1580

// WARNING
// TRY TO UPDATE IDS_END WHEN ADDING RESOURCES

#define IDS_START 1000
#define IDS_END   1581
#define IDS_SIZE  (IDS_END - IDS_START + 1)


#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\samclean.cxx ===
/*++
Copyright (c) 1999 Microsoft Corporation

Module Name:

    samclean.cxx

Abstract:

    This file contains SAM duplicate SID cleanup routines that connect
    to the server, open the account domain (we believe there won't be 
    duplicate sid in the builtin domain), then enumerata all SAM accounts 
    in the account domain. Once get the accounts Relative ID, insert this
    account into our Sorted by RID generic table. Because the account domain
    could be very large, we use the following algorithm to find the 
    duplicate SID.

    
    Important: This algorithm is only applied for Windows 2000 DC.
               Can't be used on NT4 BDC. Because Windows 2000 will 
               use SID as index to execute the enumeration, while NT 4 
               does NOT. Thus ONLY Windows 2000 DC can guarantee the 
               order of returned accounts. The whole algorithm is based 
               on that assumption.
        
    
    while ( Enumeration is not finished )
    {
        Enumerate Normal User in Account Domain
        Enumerate Workstation Account
        Enumerate Server Accounts
        Enumerate InterDomain Trust accounts
        Enumerate Group objects
        Enumerate Alias objects
        (totally Six catagories)
        
        Put the returned entries (from above enumeration) into EnumInfo->CmpAccounts
        (Each catagory has its own EnumInfo, for example: UserEnumInfo, WksEnumInfo,
         ... AliasEnumInfo.  EnumInfo->CmpAccounts is used to hold all entries which
         need to be examined. 
         
        Find the maximum RID of each catagory's CmpAccounts. 
        It should be the last one in the CmpAccounts array. 
        
        Get the minimum value from the six maximum RID. We will call
        it MinimumRid.
   
        Scan each catagory's CmpAccounts, for each entry whose 
        RID <= MinimumRid, insert that account into the Sorted By Rid 
        Generic Table. 
            if can't insert, then it must be a Duplicate RID. ==> Duplicate SID.
        
        Scan CmpAccounts of the six catagories (Normal User, Worksation...alias)
        discard the checked entries.

        Free the Generic Table. 
    }        
       
    Note: all above depends on that SAM enumeration will guarantee the order
          of returned accounts. Thus we can check these returned accounts
          by small set instead of scan them in a whole. 
          
          Because different catagory will not follow the same order, so 
          we introduce the MinimumRid to force that every account gets a 
          chance to compare with the rest five catagory in a proper manner.


Author:

    ShaoYin

Revision History

    02-11-99 Created

--*/





#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "sam.hxx"

extern "C" {
// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>
#include <prefix.h>
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mappings.h>

#include "ntsam.h"
#include "ntldap.h"
#include "winldap.h"
#include "ntlsa.h"
#include "lmcons.h"         // MAPI constants req'd for lmapibuf.h
#include "lmapibuf.h"       // NetApiBufferFree()
}                   


#include "resource.h"




#define DBPRINT 0

#if     DBPRINT == 1
#define dbprintf(x)     printf x
#else
#define dbprintf(x) 
#endif



////////////////////////////////////////////////////////////////
//                                                            //
//          Defines                                           //
//                                                            //
////////////////////////////////////////////////////////////////

#define AVERAGE_MEMORY_PER_ENTRY    32
#define SAMP_MAXIMUM_DOMAIN_RID     0x3FFFFFFF

#define INIT_COUNT_COMPARE_ACCOUNTS 256


//
// Control the behavior of SamDuplicateSidCleanup()
// 
#define SAM_DUPLICATE_SID_CHECK_ONLY    0x0001
#define SAM_DUPLICATE_SID_CLEANUP       0x0002


#define SAM_DEFAULT_LOG_FILE        L"dupsid.log"



#define CalculateBufferSize( c )                                    \
        (sizeof(GENERIC_TABLE_ELEMENT) + c.Length - sizeof(WCHAR) + \
         sizeof(L'\0')) 




//////////////////////////////////////////////////
//                                              //
// Global Varialbes                             //
//                                              //
//////////////////////////////////////////////////


SAM_HANDLE      gSamServerHandle = NULL;

UNICODE_STRING  gServerName;
WCHAR           gpwszServerName[MAX_PATH] = { L'\0' };

BOOLEAN         gUseDefaultLogFile = TRUE;
WCHAR           gpwszLogFileName[MAX_PATH] = { L'\0' };

PWCHAR          gpszMessage = NULL;
PWCHAR          gpszAnd = NULL;

RTL_GENERIC_TABLE   gSortedByRidTable;



//////////////////////////////////////////////////
//                                              //
// TypeDefine                                   //
//                                              //
//////////////////////////////////////////////////


typedef struct _SAM_ENUMERATION_INFO
{
    BOOLEAN NotFinished;                // indicate whether enumeration ends or not
    ULONG   CheckedCount;               // number of entried had been checked.
    ULONG   PreferedCount;              // number of entries need to enumerate
    SAM_ENUMERATE_HANDLE EnumContext;   // restart the enumeration
    ULONG   ReturnedCount;              // number of entries returned 
    PSAM_RID_ENUMERATION ReturnedAccounts; // contains the returned accounts (entries) 
    ULONG   CmpCapacity;                // record how many entries CmpAccounts can contain
    ULONG   CmpCount;                   // number of entries wait to be examined.
    PSAM_RID_ENUMERATION CmpAccounts;   // contains the entries wait to be examined

} SAM_ENUMERATION_INFO, *PSAM_ENUMERATION_INFO;




typedef struct _GENERIC_TABLE_ELEMENT
{
    ULONG   Rid;            // Relative ID 
    USHORT  Length;         // Length is byte size of the name, 
                            // not include the NULL terminator.
    WCHAR   Name[1];        // Wide Char String.

} GENERIC_TABLE_ELEMENT, *PGENERIC_TABLE_ELEMENT;



//////////////////////////////////////////////////
//                                              //
// forward declaration                          //
//                                              //
//////////////////////////////////////////////////


PVOID
RidTableAllocate(
    RTL_GENERIC_TABLE   *Table, 
    CLONG               ByteSize
    );

VOID
RidTableFree(
    RTL_GENERIC_TABLE   *Table, 
    PVOID               Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
RidTableCompare(
    RTL_GENERIC_TABLE   *Table, 
    PVOID               FirstStruct, 
    PVOID               SecondStruct
    );

VOID
SamFreeGenericTable(
    VOID
    );

NTSTATUS
SamDuplicateSidCleanup(
    IN ULONG Flags
    );

NTSTATUS
SamOpenAccountDomain(
    PUNICODE_STRING ServerName,
    SAM_HANDLE      SamHandle, 
    PSAM_HANDLE     pDomainHandle 
    );


ULONG
SamGetMinimumRid(
    IN PSAM_ENUMERATION_INFO UserEnumInfo, 
    IN PSAM_ENUMERATION_INFO WksEnumInfo, 
    IN PSAM_ENUMERATION_INFO SrvEnumInfo, 
    IN PSAM_ENUMERATION_INFO InterDomEnumInfo, 
    IN PSAM_ENUMERATION_INFO GroupEnumInfo, 
    IN PSAM_ENUMERATION_INFO AliasEnumInfo
    );

NTSTATUS
SamEnumerateAccounts(
    IN SAM_HANDLE DomainHandle, 
    IN SAMP_OBJECT_TYPE ObjectType, 
    IN ULONG UserAccountControl,
    IN OUT PSAM_ENUMERATION_INFO  EnumInfo
    );

NTSTATUS
SamUpdateCmpAccountsWithReturnedAccounts(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo
    );

VOID
SamUpdateCmpAccountsAfterCheck(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG MinimumRid
    );

NTSTATUS
SamDetectAndCleanupDuplicateSid(
    IN SAM_HANDLE DomainHandle,
    IN FILE * LogFile,
    IN ULONG MinimumRid,
    IN PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG Flags
    );

VOID
SamInitEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    );

VOID
SamFreeEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    );

////////////////////////////////////////////////////////////////////
//                                                                //
//  exported API throught SAM.HXX                                 //
//                                                                //
////////////////////////////////////////////////////////////////////

HRESULT SamDuplicateSidCheckOnly(
    CArgs *pArgs
    )
/*++
Routine Descrption:
    
    This routine calls SamDuplicateSidCleanup(), with check only flag.

Parameters:

    None.
    
Return Value:

    S_OK
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = SamDuplicateSidCleanup(SAM_DUPLICATE_SID_CHECK_ONLY);

    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT(IDS_SAM_DUP_SID_CHECK_FAILED);
    }
    else
    {
        RESOURCE_PRINT1(IDS_SAM_DUP_SID_CHECK_SUCCEED, gpwszLogFileName);
    }

    return (S_OK);
    
}

HRESULT SamDuplicateSidCheckAndCleanup(
    CArgs *pArgs
    )
/*++
Routine Descrption:
    
    This routine calls SamDuplicateSidCleanup(), with check and cleanup flags.
    
Parameters:

    None.
    
Return Value:

    S_OK
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = SamDuplicateSidCleanup(SAM_DUPLICATE_SID_CHECK_ONLY |
                                      SAM_DUPLICATE_SID_CLEANUP);

    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT(IDS_SAM_DUP_SID_CLEANUP_FAILED);
    }
    else
    {
        RESOURCE_PRINT1(IDS_SAM_DUP_SID_CLEANUP_SUCCEED, gpwszLogFileName);
    }


    return (S_OK);
}




HRESULT
SamSpecifyLogFile(
    CArgs *pArgs
    )
/*++
Routine Description:

    This routine simply gets the specified log file from client

Parameter:
    
    New Log File Name    

Return Values:
    
    HRESULT
--*/
{
    HRESULT HResult = S_OK;
    PWCHAR  pLogFileName = NULL;

    if ( FAILED(HResult = pArgs->GetString(0, (const WCHAR **) &pLogFileName)) )
    {
        return (HResult);
    }

    RtlZeroMemory(gpwszLogFileName, MAX_PATH * sizeof(WCHAR) );
    gUseDefaultLogFile = FALSE;

    wcscpy(gpwszLogFileName, pLogFileName);

    return (S_OK);
}


HRESULT SamConnectToServer(
    CArgs *pArgs
    )
/*++
Routine Description:

    This routine makes the SAM connection to the server
    
Parameter:

    Server Name
    
Return Values:

    HRESULT - S_OK
--*/
{
    HRESULT     HResult = S_OK;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PWCHAR      pServerName = NULL;
    OBJECT_ATTRIBUTES Attributes;


    //
    //  Close any open connection
    //
     
    if (NULL != gSamServerHandle)
    {
        SamCloseHandle(gSamServerHandle);
        gSamServerHandle = NULL;
    }

    //
    // Init Global Variables. Hold the server name.
    // 

    RtlZeroMemory(&gServerName, sizeof(UNICODE_STRING));
    RtlZeroMemory(gpwszServerName, MAX_PATH * sizeof(WCHAR));

    if ( FAILED(HResult = pArgs->GetString(0, (const WCHAR **) &pServerName)) )
    {
        return (HResult);
    }

    wcscpy(gpwszServerName, pServerName);

    RtlInitUnicodeString(&gServerName, gpwszServerName);

    InitializeObjectAttributes(&Attributes, NULL, 0, NULL, NULL);

    //
    // Connect
    // 

    NtStatus = SamConnect(
                    &gServerName, 
                    &gSamServerHandle, 
                    MAXIMUM_ALLOWED, 
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT2(IDS_SAM_CONNECT_ERROR, pServerName, NtStatus); 
        return(S_OK);
    }

    
    return (S_OK);
}



//
// Implementation of the main algorithm
// 

NTSTATUS
SamDuplicateSidCleanup(
    IN ULONG Flags
    )
/*++
Routine Description:

    This routine enumerates all accounts in the account domain.
    Detect the duplicate SID. If any, log it and clean it up if 
    required to do so. 
 

Parameters:

    Flags - Control this function's behavior. 

Return Values:

    NtStatus
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SAM_HANDLE  DomainHandle = NULL;
    SAM_ENUMERATION_INFO    UserEnumInfo;
    SAM_ENUMERATION_INFO    GroupEnumInfo;
    SAM_ENUMERATION_INFO    AliasEnumInfo;
    SAM_ENUMERATION_INFO    WksEnumInfo;
    SAM_ENUMERATION_INFO    SrvEnumInfo;
    SAM_ENUMERATION_INFO    InterDomEnumInfo;
    ULONG       MinimumRid = 0;
    FILE        * LogFile = NULL;


    //
    // the server connection should be ready
    //
    if (NULL == gSamServerHandle)
    {
        //
        // not connect to any server yet
        // 
        RESOURCE_PRINT(IDS_SAM_NOT_CONNECTED);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    //  Create the log file
    // 

    if (gUseDefaultLogFile)
    {
        RtlZeroMemory(gpwszLogFileName, MAX_PATH * sizeof(WCHAR) );
        wcscpy(gpwszLogFileName, SAM_DEFAULT_LOG_FILE);
    }

    if (L'\0' == gpwszLogFileName[0])
    {
        RESOURCE_PRINT1(IDS_SAM_INVALID_LOG_FILE_NAME, gpwszLogFileName); 
        return (STATUS_UNSUCCESSFUL);
    }

    LogFile = _wfopen(gpwszLogFileName, L"w");

    if (NULL == LogFile)
    {
        RESOURCE_PRINT1(IDS_SAM_CANT_CREATE_LOG_FILE, gpwszLogFileName);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // open the account domain
    // 
    NtStatus = SamOpenAccountDomain(&gServerName, 
                                    gSamServerHandle, 
                                    &DomainHandle
                                    );
     
    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT(IDS_SAM_CANT_OPEN_ACCOUNT_DOMAIN);
        fclose(LogFile);
        return (NtStatus);
    }

    //
    // Initialize global variable 
    // 
    RtlInitializeGenericTable(
                &gSortedByRidTable, 
                RidTableCompare, 
                RidTableAllocate, 
                RidTableFree, 
                NULL
                );

    gpszMessage = (PWCHAR) READ_STRING(IDS_SAM_DUP_SID_CLEANUP_MSG);
    gpszAnd = (PWCHAR) READ_STRING(IDS_SAM_DUP_SID_CLEANUP_AND);


    //
    // Initialize all these enumeration info structure
    // 
    SamInitEnumInfo(&UserEnumInfo);
    SamInitEnumInfo(&WksEnumInfo);
    SamInitEnumInfo(&SrvEnumInfo);
    SamInitEnumInfo(&InterDomEnumInfo);
    SamInitEnumInfo(&GroupEnumInfo);
    SamInitEnumInfo(&AliasEnumInfo);


    if (NULL == UserEnumInfo.CmpAccounts ||
        NULL == WksEnumInfo.CmpAccounts || 
        NULL == SrvEnumInfo.CmpAccounts ||
        NULL == InterDomEnumInfo.CmpAccounts ||
        NULL == GroupEnumInfo.CmpAccounts ||
        NULL == AliasEnumInfo.CmpAccounts ) 
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    __try
    {
        while (UserEnumInfo.NotFinished || WksEnumInfo.NotFinished || 
               SrvEnumInfo.NotFinished || InterDomEnumInfo.NotFinished || 
               GroupEnumInfo.NotFinished || AliasEnumInfo.NotFinished )
        {
            RESOURCE_PRINT(IDS_SAM_DUP_SID_CLEANUP_STATUS);

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_NORMAL_ACCOUNT,
                                            &UserEnumInfo
                                            );

            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_WORKSTATION_TRUST_ACCOUNT,
                                            &WksEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_SERVER_TRUST_ACCOUNT,
                                            &SrvEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }       

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_INTERDOMAIN_TRUST_ACCOUNT,
                                            &InterDomEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampGroupObjectType, 
                                            0,
                                            &GroupEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampAliasObjectType, 
                                            0,
                                            &AliasEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }       

        
            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&UserEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&WksEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&SrvEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&InterDomEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&GroupEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&AliasEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            MinimumRid = SamGetMinimumRid(&UserEnumInfo, 
                                          &WksEnumInfo, 
                                          &SrvEnumInfo, 
                                          &InterDomEnumInfo,
                                          &GroupEnumInfo, 
                                          &AliasEnumInfo 
                                          );

            dbprintf(("MinimumRid MinimumRid MinimumRid ========> %x\n", MinimumRid));


            dbprintf(("Check User\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &UserEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Workstation\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &WksEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Server Machine\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &SrvEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Inter Domain Machine\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &InterDomEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }


            dbprintf(("Check Group\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &GroupEnumInfo,
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Alias\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &AliasEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            SamFreeGenericTable();

            SamUpdateCmpAccountsAfterCheck(&UserEnumInfo, 
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&WksEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&SrvEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&InterDomEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&GroupEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&AliasEnumInfo,
                                           MinimumRid);

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        RESOURCE_PRINT(IDS_SAM_EXCEPTION);
        NtStatus = STATUS_UNHANDLED_EXCEPTION;
    }


Error:

    RESOURCE_PRINT(IDS_SAM_DUP_SID_CLEANUP_END);

    //
    // Cleanup EnumInfo.CmpAccounts, EnumInfo.ReturnedAccounts
    // And the RtlGenericTable
    //
 
    RESOURCE_STRING_FREE( gpszAnd );
    RESOURCE_STRING_FREE( gpszMessage );

    SamFreeGenericTable();

    if (DomainHandle)
    {
        SamCloseHandle(DomainHandle);
        DomainHandle = NULL;
    }

    if (LogFile)
    {
        fclose(LogFile);
        LogFile = NULL;
    }

    //
    // Free EnumInfo
    // 
    SamFreeEnumInfo(&UserEnumInfo);
    SamFreeEnumInfo(&WksEnumInfo);
    SamFreeEnumInfo(&SrvEnumInfo);
    SamFreeEnumInfo(&InterDomEnumInfo);
    SamFreeEnumInfo(&GroupEnumInfo);
    SamFreeEnumInfo(&AliasEnumInfo);


    return (NtStatus);
}



NTSTATUS
SamOpenAccountDomain(
    PUNICODE_STRING ServerName,
    SAM_HANDLE      SamHandle, 
    PSAM_HANDLE     pDomainHandle 
    )
/*++
Routine Description:

    This routine opens the Account Domain
    
Parameters:

    ServerName - pointer to unicode structure. hold server name
    
    SamHandle - SAM Server Handle

    pDomainHandle - return the SAM Account Domain Handle

Return Values:

    NtStatus Code
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    LSA_HANDLE  LsaHandle = NULL;
    PSID        pDomainSid;
    OBJECT_ATTRIBUTES   Attributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    ULONG       SidSize = 0;


    //
    // Get the Account Domain SID
    // 

    RtlZeroMemory(&Attributes, sizeof(OBJECT_ATTRIBUTES));

    NtStatus = LsaOpenPolicy(ServerName, 
                             &Attributes, 
                             POLICY_VIEW_LOCAL_INFORMATION, 
                             &LsaHandle
                             );

    if (!NT_SUCCESS(NtStatus))
    {
        return (NtStatus);
    }

    NtStatus = LsaQueryInformationPolicy(
                            LsaHandle, 
                            PolicyAccountDomainInformation, 
                            (PVOID *) &DomainInfo
                            );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaHandle);
        return (NtStatus);
    }


    SidSize = RtlLengthSid(DomainInfo->DomainSid);

    pDomainSid = RtlAllocateHeap(RtlProcessHeap(), 0, SidSize ); 

    if (NULL == pDomainSid)
    {
        LsaFreeMemory(DomainInfo);
        LsaClose(LsaHandle);
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pDomainSid, SidSize);

    RtlCopyMemory(pDomainSid, 
                  DomainInfo->DomainSid, 
                  SidSize
                  );

    //
    // Open Account Domain
    // 

    NtStatus = SamOpenDomain(SamHandle,
                             MAXIMUM_ALLOWED, 
                             (PSID) pDomainSid, 
                             pDomainHandle
                             );

    //
    // Clean up
    // 

    LsaFreeMemory(DomainInfo);

    LsaClose(LsaHandle);

    RtlFreeHeap(RtlProcessHeap(), 0, pDomainSid);

    if (!NT_SUCCESS(NtStatus))
    {
        *pDomainHandle = NULL;
    }

    return (NtStatus);
}



NTSTATUS
SamEnumerateAccounts(
    IN SAM_HANDLE DomainHandle, 
    IN SAMP_OBJECT_TYPE ObjectType, 
    IN ULONG UserAccountControl,
    IN OUT PSAM_ENUMERATION_INFO  EnumInfo
    )
/*++
Routine Description:
    
    this routine does the SAM enumeration

Parameters:

    DomainHandle - Handle of an opened domain.

    ObjectType - Indicate the object Type, (user, group or alias)

    UserAccountControl - Used to enumerate Normal User or Machine
    
    EnumInfo - tell how many entries returned and the Rid, Account name info..
    
Return Values:

    NTSTATUS
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       PreferedMaxLength = 0;


    dbprintf(("Ask For   %d Entries\n", EnumInfo->PreferedCount));
    //
    // if Finished already, or ask for 0 entry. Return immediately.
    // 
    if (!(EnumInfo->NotFinished) || (0 == EnumInfo->PreferedCount) )
    {
        EnumInfo->ReturnedAccounts = NULL;
        EnumInfo->ReturnedCount = 0;
        return (STATUS_SUCCESS);
    }

    //
    // Calculate the length of memory.
    // Because in enum.c, they add one entry for everybody. 
    // so ( - 1 ) in below, to ensure that we always get the 
    // most clost entries to our request. 
    // 

    PreferedMaxLength = (EnumInfo->PreferedCount - 1 ) * AVERAGE_MEMORY_PER_ENTRY; 

    //
    // make the enumeration according to the object type
    // 
    switch (ObjectType) {
    case SampUserObjectType:
        NtStatus = SamEnumerateUsersInDomain(DomainHandle, 
                                             &(EnumInfo->EnumContext), 
                                             UserAccountControl,
                                             (PVOID *) &(EnumInfo->ReturnedAccounts), 
                                             PreferedMaxLength, 
                                             &(EnumInfo->ReturnedCount)
                                             );
        break;
    case SampGroupObjectType:
        NtStatus = SamEnumerateGroupsInDomain(DomainHandle, 
                                              &(EnumInfo->EnumContext), 
                                              (PVOID *) &(EnumInfo->ReturnedAccounts), 
                                              PreferedMaxLength, 
                                              &(EnumInfo->ReturnedCount)
                                              );
        break;
    case SampAliasObjectType:
        NtStatus = SamEnumerateAliasesInDomain(DomainHandle, 
                                               &(EnumInfo->EnumContext), 
                                               (PVOID *) &(EnumInfo->ReturnedAccounts), 
                                               PreferedMaxLength, 
                                               &(EnumInfo->ReturnedCount)
                                               );
        break;
    default:
        return (STATUS_INVALID_PARAMETER);
    }

    dbprintf(("Return %d entries.\n", EnumInfo->ReturnedCount));

    //
    // Set correct value, when enumeration ends.
    // 
    if (STATUS_MORE_ENTRIES == NtStatus)
    {
        EnumInfo->NotFinished = TRUE;
    }
    else
    {
        EnumInfo->NotFinished = FALSE;

        dbprintf(("Finished !!!!! \n")); 
    }

    {
        ULONG i;

        for (i = 0; i < EnumInfo->ReturnedCount; i++)
        {
            dbprintf((" %x ", EnumInfo->ReturnedAccounts[i].RelativeId));
        }
    }

    return (NtStatus);

}



ULONG
SamGetMinimumRid(
    IN PSAM_ENUMERATION_INFO UserEnumInfo, 
    IN PSAM_ENUMERATION_INFO WksEnumInfo, 
    IN PSAM_ENUMERATION_INFO SrvEnumInfo, 
    IN PSAM_ENUMERATION_INFO InterDomEnumInfo, 
    IN PSAM_ENUMERATION_INFO GroupEnumInfo, 
    IN PSAM_ENUMERATION_INFO AliasEnumInfo
    )
/*++
Routine Description:

    Compare the Upper Limits, return the smallest one.
    
Parameters:
    
    All Enumeration Info
    
Return Value:

    smallest Upper Limit

--*/
{
    ULONG   UserLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   WksLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   SrvLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   InterDomLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   GroupLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   AliasLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   Temp1 = 0;
    ULONG   Temp2 = 0;
    ULONG   Temp3 = 0;


    if ((NULL != UserEnumInfo->CmpAccounts) && 
        (0 != UserEnumInfo->CmpCount) && 
        (UserEnumInfo->NotFinished) )
    {
        UserLastRid = UserEnumInfo->CmpAccounts
                                [UserEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != WksEnumInfo->CmpAccounts) && 
        (0 != WksEnumInfo->CmpCount) &&
        (WksEnumInfo->NotFinished) )
    {
        WksLastRid = WksEnumInfo->CmpAccounts
                                [WksEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != SrvEnumInfo->CmpAccounts) && 
        (0 != SrvEnumInfo->CmpCount) && 
        (SrvEnumInfo->NotFinished) )
    {
        SrvLastRid = SrvEnumInfo->CmpAccounts
                                [SrvEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != InterDomEnumInfo->CmpAccounts) && 
        (0 != InterDomEnumInfo->CmpCount) &&
        (InterDomEnumInfo->NotFinished) )
    {
        InterDomLastRid = InterDomEnumInfo->CmpAccounts
                                [InterDomEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != GroupEnumInfo->CmpAccounts) && 
        (0 != GroupEnumInfo->CmpCount) &&
        (GroupEnumInfo->NotFinished) )
    {
        GroupLastRid = GroupEnumInfo->CmpAccounts
                                [GroupEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != AliasEnumInfo->CmpAccounts) && 
        (0 != AliasEnumInfo->CmpCount) &&
        (AliasEnumInfo->NotFinished) )
    {
        AliasLastRid = AliasEnumInfo->CmpAccounts
                                [AliasEnumInfo->CmpCount - 1].RelativeId;
    }

    Temp1 = (UserLastRid < WksLastRid) ? UserLastRid : WksLastRid;

    Temp2 = (SrvLastRid < InterDomLastRid) ? SrvLastRid : InterDomLastRid;
    
    Temp3 = (GroupLastRid < AliasLastRid) ? GroupLastRid : AliasLastRid;

    
    return( (min(Temp1, Temp2) < Temp3) ? min(Temp1, Temp2) : Temp3 );
}


NTSTATUS
SamUpdateCmpAccountsWithReturnedAccounts(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo
    )
/*++
Routine Description:

    This routine merges the EnumInfo->ReturnedAccounts with 
    EnumInfo->CmpAccounts. The merged results will be placed in 
    CmpAccounts. ReturnedAccounts should be released by calling
    SamFreeMemory(). 
    
    Note: Allocate memory for account name in the SAM_RID_ENUMERATION
          structure.
          
Parameters:

    EnumInfo - pointer to SAM_ENUMERATION_INFO

Return Values:

    NTSTATUS Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index = 0;
    ULONG       ReturnedIndex = 0;


    //
    // Nothing to merge if ReturnedAccounts does not
    // container any info
    //

    if ((NULL == EnumInfo->ReturnedAccounts) ||
        (0 == EnumInfo->ReturnedCount) )
    {
        return (STATUS_SUCCESS);
    }

    dbprintf(("ReturnedCount %d  CmpCount %d Capacity %d ", 
              EnumInfo->ReturnedCount, 
              EnumInfo->CmpCount, 
              EnumInfo->CmpCapacity
              )); 


    //
    // if the returned accounts plus the entries waiting to be examined exceed
    // our capacity. Extend the memory
    // 
    if ((EnumInfo->CmpCount + EnumInfo->ReturnedCount) > EnumInfo->CmpCapacity)
    {
        PVOID   Temp = NULL;
        ULONG   Count = 0;

        dbprintf(("Extend the memory\n"));        

        Count = EnumInfo->CmpCount + EnumInfo->ReturnedCount;

        Temp = RtlAllocateHeap(RtlProcessHeap(), 
                               0, 
                               Count * sizeof(SAM_RID_ENUMERATION)
                               );

        if (NULL == Temp)
        {
            //
            // ReturnedAccounts will be freed when we terminate 
            //
            return (STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Temp, Count * sizeof(SAM_RID_ENUMERATION));

        RtlCopyMemory(Temp, 
                      EnumInfo->CmpAccounts, 
                      EnumInfo->CmpCount * sizeof(SAM_RID_ENUMERATION)
                      );

        RtlFreeHeap(RtlProcessHeap(), 0, EnumInfo->CmpAccounts);

        EnumInfo->CmpAccounts = (PSAM_RID_ENUMERATION) Temp;
        EnumInfo->CmpCapacity = EnumInfo->CmpCount + EnumInfo->ReturnedCount;
    }

    
    //
    // copy the info in ReturnedAccounts to the 
    // end of CmpAccounts
    // 

    Index = EnumInfo->CmpCount;

    for (ReturnedIndex = 0; 
         ReturnedIndex < EnumInfo->ReturnedCount;
         ReturnedIndex++ )
    {
        USHORT   Length = 0;

        //
        // need one more WCHAR for NULL terminator
        // 
        Length = EnumInfo->ReturnedAccounts[ReturnedIndex].Name.Length + sizeof(WCHAR);

        EnumInfo->CmpAccounts[Index].RelativeId = 
                    EnumInfo->ReturnedAccounts[ReturnedIndex].RelativeId;

        EnumInfo->CmpAccounts[Index].Name.Length = Length;

        //
        // Allocate the space for account name
        // 
        EnumInfo->CmpAccounts[Index].Name.Buffer =  (PWCHAR)
                    RtlAllocateHeap(RtlProcessHeap(), 0, Length); 

        if (NULL == EnumInfo->CmpAccounts[Index].Name.Buffer)
        {
            //
            // ReturnedAccounts will be freed when we terminate
            // 
            return (STATUS_NO_MEMORY);
        }

        RtlZeroMemory(EnumInfo->CmpAccounts[Index].Name.Buffer, 
                      Length
                      );

        RtlCopyMemory(EnumInfo->CmpAccounts[Index].Name.Buffer, 
                      EnumInfo->ReturnedAccounts[ReturnedIndex].Name.Buffer, 
                      Length - sizeof(WCHAR)
                      );

        Index ++;
        EnumInfo->CmpCount ++;
    }

    dbprintf(("CmpCount after merge is %d\n", EnumInfo->CmpCount));

    //
    // SamFreeMemory will also free the memory occupied by
    // account name
    // 
    SamFreeMemory(EnumInfo->ReturnedAccounts);

    EnumInfo->ReturnedAccounts = NULL;
    EnumInfo->ReturnedCount = 0;

    return (NtStatus);
}



VOID
SamUpdateCmpAccountsAfterCheck(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG MinimumRid
    )
/*++
Routine Description:
    
    This routine will update the CmpAccounts array. Remove 
    those entries which have been examined already.

    Note: we will keep the entries whose RID is equal to the 
          MinimumRid
    
Parameters:

    EnumInfo - pointer to SAM_ENUMERATION_INFO
    
Return Values:

    None
--*/
{
    ULONG       RemovedCount;  
    ULONG       Index = 0;

    dbprintf(("CheckedCount ==> %d in CmpCount ==> %d  ", 
           EnumInfo->CheckedCount, 
           EnumInfo->CmpCount));

    //
    // if less then 1 entry has been checked, nothing 
    // to discard
    // 
    if (EnumInfo->CheckedCount >= 1)
    {
        //
        // Calculate the number of entries which should be discarded.
        //

        RemovedCount = EnumInfo->CheckedCount;

        if (EnumInfo->CmpAccounts[EnumInfo->CheckedCount - 1].RelativeId == MinimumRid )
        {
            RemovedCount --;
        }

        //
        // Release the space occupied by the account names
        // 
        for (Index = 0; Index < RemovedCount; Index ++)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, EnumInfo->CmpAccounts[Index].Name.Buffer);
        }

        //
        // move all the entries (left) to the front of this array.
        // 
        for (Index = RemovedCount; Index < EnumInfo->CmpCount; Index ++)
        {
            EnumInfo->CmpAccounts[Index - RemovedCount] = EnumInfo->CmpAccounts[Index];
        }

        //
        // zero the rest of entries
        // 
        for (Index = EnumInfo->CmpCount - RemovedCount; 
             Index < EnumInfo->CmpCount;
             Index ++)
        {
            RtlZeroMemory(&(EnumInfo->CmpAccounts[Index]), sizeof(SAM_RID_ENUMERATION) );
        }

        dbprintf(("RemovedCount is %d ", RemovedCount));
        //
        // Update counters
        //
        EnumInfo->CmpCount -= RemovedCount;

    }

    //
    // Calculate how many new entries we can ask for
    // 
    EnumInfo->PreferedCount = EnumInfo->CmpCapacity - EnumInfo->CmpCount;
    EnumInfo->CheckedCount = 0;

    dbprintf(("New CmpCount after remove %d \n", EnumInfo->CmpCount ));


    return;
}


NTSTATUS
SamDetectAndCleanupDuplicateSid(
    IN SAM_HANDLE DomainHandle,
    IN FILE * LogFile,
    IN ULONG MinimumRid,
    IN PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG Flags
    )
/*++
Routine Description:

    This routine checks all entries in EnumInfo->CmpAccounts whose Rid
    is less than MinimumRid by insert them into the gSortedByRidTable. 

Parameters:

    DomainHandle - SAM handle to an opened domain (which holds the RID)
    
    MinimumRid - Define the upper limit of Entries which we should check.
    
    EnumInfo - pointer to the SAM_ENUMERATION_INFO structure

    Flags - Control the behaivor of this function. (Whether cleanup the 
            duplicate SID or just check.

Return Values:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SAM_RID_ENUMERATION Account;
    ULONG       Index = 0;
    USHORT      BufferSize = 0;
    BOOLEAN     fNewElement = TRUE;
    PGENERIC_TABLE_ELEMENT TableElement = NULL;
    PGENERIC_TABLE_ELEMENT OldElement = NULL;



    EnumInfo->CheckedCount = 0;

    for (Index = 0; Index < EnumInfo->CmpCount; Index++)
    {
        TableElement = NULL;
        OldElement = NULL;
        fNewElement = TRUE;


        Account = EnumInfo->CmpAccounts[Index];


        if (Account.RelativeId <= MinimumRid)
        {
            // dbprintf(("Check %x %ls\n", Account.RelativeId, Account.Name.Buffer));

            //
            //  construct a new table element for insertion
            // 
            BufferSize = CalculateBufferSize(Account.Name);

            TableElement = (PGENERIC_TABLE_ELEMENT)
                            RtlAllocateHeap(RtlProcessHeap(), 0, BufferSize);

            if (NULL == TableElement)
            {
                return (STATUS_NO_MEMORY);
            }

            RtlZeroMemory(TableElement, BufferSize);

            TableElement->Rid = Account.RelativeId;
            TableElement->Length = Account.Name.Length;

            wcsncpy(TableElement->Name, 
                    Account.Name.Buffer, 
                    Account.Name.Length / sizeof(WCHAR)
                    );

            //
            // Insert it into the Generic Table
            // 
            OldElement = (PGENERIC_TABLE_ELEMENT)
                         RtlInsertElementGenericTable(
                                    &gSortedByRidTable, 
                                    TableElement, 
                                    BufferSize, 
                                    &fNewElement
                                    );


            if (!fNewElement)
            {
                PWCHAR Msg = NULL; 
                ULONG  BufferSize = 0;

                //
                // Duplicate Rid ==> SID happened
                // 

                //
                // create the message
                // 
                BufferSize = TableElement->Length + 
                             OldElement->Length +
                             (wcslen(gpszMessage) + wcslen(gpszAnd) + 1 ) * sizeof(WCHAR);

                Msg = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, BufferSize);

                if (NULL == Msg)
                {
                    RtlFreeHeap(RtlProcessHeap(), 0, TableElement);
                    return (STATUS_NO_MEMORY);
                }

                RtlZeroMemory(Msg, BufferSize);

                swprintf(Msg, L"%s%s%s%s", 
                         gpszMessage, 
                         TableElement->Name, 
                         gpszAnd, 
                         OldElement->Name
                         );

                dbprintf(("DUPLICATE DUPLICATE DUPLICATE %ls %d\n", 
                          Msg, 
                          TableElement->Rid
                          ));

                fwprintf(LogFile, L"%s", Msg);
                fwprintf(LogFile, L"\n\n");
                fflush(LogFile);

                RtlFreeHeap(RtlProcessHeap(), 0, Msg);

                //
                // clean up the duplicate sid if the client asked to do so.
                // 
                if (Flags & SAM_DUPLICATE_SID_CLEANUP)
                {
                    SAM_HANDLE UserHandle = NULL;
                    NTSTATUS   IgnoreStatus = STATUS_SUCCESS;

                    //
                    // clean up the duplicate SID by
                    // explicitly Lookup this Account
                    //

                    IgnoreStatus = SamOpenUser(DomainHandle,
                                               MAXIMUM_ALLOWED,
                                               TableElement->Rid,
                                               &UserHandle
                                               );

                    //
                    // close the SAM handle if we should do so.
                    //
                    if (UserHandle || NT_SUCCESS(IgnoreStatus))
                    {
                        SamCloseHandle(UserHandle);
                    }
                }
            }

            RtlFreeHeap(RtlProcessHeap(), 0, TableElement);
            EnumInfo->CheckedCount ++;
        }
        else
            break;
    }

    return (NtStatus);
}


VOID
SamInitEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    )
/*++
Routine Description

    Initialize an EnumInfo Structure

Parameter:

    EnumInfo - pointer to the structure needs to be intialized.

Return Values:
    
    None.
--*/
{
    RtlZeroMemory(EnumInfo, sizeof(SAM_ENUMERATION_INFO));

    EnumInfo->NotFinished = TRUE;    
    EnumInfo->PreferedCount = INIT_COUNT_COMPARE_ACCOUNTS;

    EnumInfo->CmpAccounts = (PSAM_RID_ENUMERATION) 
                            RtlAllocateHeap(
                                RtlProcessHeap(), 
                                0, 
                                sizeof(SAM_RID_ENUMERATION) * INIT_COUNT_COMPARE_ACCOUNTS
                                );

    if (NULL == EnumInfo->CmpAccounts)
    {
        return;
    }

    EnumInfo->CmpCapacity = INIT_COUNT_COMPARE_ACCOUNTS;

    RtlZeroMemory(EnumInfo->CmpAccounts, 
                  sizeof(SAM_RID_ENUMERATION) * INIT_COUNT_COMPARE_ACCOUNTS
                  );
                  
    return;
}





VOID
SamFreeEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    )
/*++
Routine Description

    Free an EnumInfo Structure and memory accociated with it.

Parameter:

    EnumInfo - pointer to the structure needs to be intialized.

Return Values:
    
    None.
--*/
{
    ULONG   Index = 0;

    if (EnumInfo->CmpAccounts)
    {
        for (Index = 0; Index < EnumInfo->CmpCount; Index ++)
        {
            RtlFreeHeap( RtlProcessHeap(), 
                         0, 
                         EnumInfo->CmpAccounts[Index].Name.Buffer
                       );
        }

        RtlFreeHeap( RtlProcessHeap(), 
                     0, 
                     EnumInfo->CmpAccounts
                    );
    }

    if (EnumInfo->ReturnedAccounts)
    {
        SamFreeMemory(EnumInfo->ReturnedAccounts);
    }

    RtlZeroMemory(EnumInfo, sizeof(SAM_ENUMERATION_INFO));

    return;
}
    



VOID
SamCleanupGlobals(
    VOID
    )
/*++
Routine Description:

    Cleanup all Global Variables when quit from security account management
    
Parameters:
    None.
    
Return Values:
    None.

--*/
{

    //
    // sam server handle
    //
    if (gSamServerHandle)
    {
        SamCloseHandle(gSamServerHandle);
        gSamServerHandle = NULL;
    }

    //
    // Server Name
    // 
    RtlZeroMemory(&gServerName, sizeof(UNICODE_STRING));
    RtlZeroMemory(gpwszServerName, MAX_PATH * sizeof(WCHAR));

    //
    // Log file Name
    // 
    gUseDefaultLogFile = TRUE;
    RtlZeroMemory(gpwszLogFileName, MAX_PATH * sizeof(WCHAR));

    return;
}




VOID
SamFreeGenericTable(
    VOID
    )
/*++
Routine Description:

    Free the memory occupied by the Generic Table element

Parameter:
    
    None.
    
Return Values:

    None.
--*/
{
    PGENERIC_TABLE_ELEMENT  TableElement = NULL;
    BOOLEAN     Restart = TRUE;

    dbprintf(("Generic Table is Empty? : %d Number of Element: %d ", 
           RtlIsGenericTableEmpty(&gSortedByRidTable), 
           RtlNumberGenericTableElements(&gSortedByRidTable)
           ));

    for( TableElement = (PGENERIC_TABLE_ELEMENT) RtlEnumerateGenericTable(&gSortedByRidTable, TRUE);
         TableElement != NULL; // !RtlIsGenericTableEmpty(&gSortedByRidTable); 
         TableElement = (PGENERIC_TABLE_ELEMENT) RtlEnumerateGenericTable(&gSortedByRidTable, TRUE)
        )
    {
        RtlDeleteElementGenericTable(&gSortedByRidTable, TableElement);
    }

    dbprintf(("Generic Table is Emptied %d\n", 
           RtlIsGenericTableEmpty(&gSortedByRidTable)
           ));
}




/////////////////////////////////////////////////////////////////////
//                                                                 //
//  Implementation for RTL Generic Table Functions                 //
//  About the parameters and return values, please refer to        //
//  ntrtl.h                                                        //
//                                                                 //
/////////////////////////////////////////////////////////////////////


PVOID
RidTableAllocate(
    RTL_GENERIC_TABLE   *Table,
    CLONG               ByteSize)
{
    return (RtlAllocateHeap(RtlProcessHeap(), 0, ByteSize));
}

//////////////////////////////////////////////////////////////////////


VOID
RidTableFree(
    RTL_GENERIC_TABLE   *Table,
    PVOID               Buffer)
{
    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
}


///////////////////////////////////////////////////////////////////////


RTL_GENERIC_COMPARE_RESULTS
RidTableCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{

    ULONG       Rid1, Rid2;

    Rid1 = ((PGENERIC_TABLE_ELEMENT) FirstStruct)->Rid;
    Rid2 = ((PGENERIC_TABLE_ELEMENT) SecondStruct)->Rid;


    //
    // use the Rid as the base of comparation.
    // 

    if (Rid1 > Rid2)
    {
        return GenericGreaterThan;
    }
    else if (Rid1 < Rid2)
    {
        return GenericLessThan;
    }
    else
    {
        return GenericEqual;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\sammain.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "sam.hxx"

#include "resource.h"

CParser         samParser;
BOOL            fSamQuit;
BOOL            fSamParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes samLanguage[] = 
{
    {   L"?", 
        SamHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help", 
        SamHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit", 
        SamQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Log File %s", 
        SamSpecifyLogFile, 
        IDS_SAM_SPECIFY_LOG_FILE, 0},

    {   L"Connect to server %s", 
        SamConnectToServer,
        IDS_SAM_CONNECT_SERVER_MSG, 0 },

    {   L"Check Duplicate SID",
        SamDuplicateSidCheckOnly,
        IDS_SAM_DUPLICATE_SID_CHECK_ONLY, 0 }, 

    {   L"Cleanup Duplicate SID", 
        SamDuplicateSidCheckAndCleanup, 
        IDS_SAM_DUPLICATE_SID_CLEANUP, 0 },

};

HRESULT
SamMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fSamParserInitialized )
    {
        cExpr = sizeof(samLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (samLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }


        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = samParser.AddExpr(samLanguage[i].expr,
                                               samLanguage[i].func,
                                               samLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fSamParserInitialized = TRUE;
    fSamQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SAM_MAINTENANCE);

    hr = samParser.Parse(gpargc,
                         gpargv,
                         stdin,
                         stdout,
                         prompt,
                         &fSamQuit,
                         FALSE,               // timing info
                         FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT SamHelp(CArgs *pArgs)
{
    return(samParser.Dump(stdout,L""));
}

HRESULT SamQuit(CArgs *pArgs)
{
    fSamQuit = TRUE;

    SamCleanupGlobals();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\scheck.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"

#include "resource.h"

CParser scheckParser;
BOOL    fScheckQuit;
BOOL    fScheckParserInitialized = FALSE;
BOOL    fVerbose = FALSE;
WCHAR   ditPath[1] = {0};

extern "C" {
VOID
StartSemanticCheck(
    IN BOOL fFixup,
    IN BOOL fVerbose
    );

VOID
SCheckGetRecord(
    IN BOOL fVerbose,
    IN DWORD Dnt
    );

VOID
SFixupCnfNc(
    VOID
    );

VOID
StartFixup(
    IN BOOL fVerbose
    );

void
DoRepairSchemaConflict(void);

}

// Forward references.

extern HRESULT SCheckHelp(CArgs *pArgs);
extern HRESULT SCheckQuit(CArgs *pArgs);
extern HRESULT SetVerbose(CArgs *pArgs);
extern HRESULT DoSCheckFixup(CArgs *pArgs);
extern HRESULT DoSCheck(CArgs *pArgs);
extern HRESULT DoSCheckGetRecord(CArgs *pArgs);
extern HRESULT RepairSchemaConflict(CArgs *pArgs);
extern HRESULT FixupCnfNc(CArgs *pArgs);


// Build a table which defines our language.

LegalExprRes scheckLanguage[] =
{
    {   L"?",
        SCheckHelp,
        IDS_HELP_MSG, 0  },

    {   L"Help",
        SCheckHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        SCheckQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Verbose %s",
        SetVerbose,
        IDS_SCHECK_VERBOSE_MSG, 0 },

    {   L"Go",
        DoSCheck,
        IDS_SCHECK_GO_MSG, 0 },

    {   L"Go Fixup",
        DoSCheckFixup,
        IDS_SCHECK_GO_FIXUP_MSG, 0 },

    {   L"Get %d",
        DoSCheckGetRecord,
        IDS_SCHECK_GET_MSG, 0  }

// Future:
//    Add this is a separate entry.
//    Currently it is embedded in DoSCheckFix
//    {   L"Fix NC Conflict",
//        FixupCnfNc,
//        IDS_SCHECK_FIXUP_CNFNC, 0  }

};

HRESULT
SCheckMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    //
    // if not in safe mode and not restored, bail
    //

    if ( !IsSafeMode() || CheckIfRestored() )
    {
        return(S_OK);
    }

    if ( !fScheckParserInitialized )
    {
        cExpr = sizeof(scheckLanguage) / sizeof(LegalExprRes);


        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (scheckLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }


        // Read in our language.

        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = scheckParser.AddExpr(scheckLanguage[i].expr,
                                                  scheckLanguage[i].func,
                                                  scheckLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fScheckParserInitialized = TRUE;
    fScheckQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SCHECK);

    hr = scheckParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fScheckQuit,
                            FALSE,               // timing info
                            FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);


    return(hr);
}

HRESULT SCheckHelp(CArgs *pArgs)
{
    return(scheckParser.Dump(stdout,L""));
}

HRESULT SCheckQuit(CArgs *pArgs)
{
    fScheckQuit = TRUE;
    return(S_OK);
}

HRESULT SetVerbose(CArgs *pArgs)
{
    const WCHAR *pwszVal;
    HRESULT     hr;

    if ( FAILED(hr = pArgs->GetString(0, &pwszVal)) )
    {
        return(hr);
    }

    const WCHAR * message_on = READ_STRING (IDS_ON);
    const WCHAR * message_off = READ_STRING (IDS_OFF);


    if ( !_wcsicmp(message_on, pwszVal) )
    {
        fVerbose = TRUE;
        RESOURCE_PRINT (IDS_SCHECK_VERBOSE_ENABLED);
    }
    else if ( !_wcsicmp(message_off, pwszVal) )
    {
        fVerbose = FALSE;
        RESOURCE_PRINT (IDS_SCHECK_VERBOSE_DISABLED);
    }
    else
    {
        //"Invalid argument - expected \"on\" or \"off\"\n"
        RESOURCE_PRINT (IDS_INVALID_ON_OFF);
    }

    RESOURCE_STRING_FREE (message_on);
    RESOURCE_STRING_FREE (message_off);

    return(S_OK);
}

HRESULT DoSCheck(CArgs *pArgs)
{
    RESOURCE_PRINT1 (IDS_FIXUP_MSG, L"off");
    StartSemanticCheck(FALSE,fVerbose);
    return S_OK;
}

HRESULT DoSCheckFixup(CArgs *pArgs)
{
    RESOURCE_PRINT1 (IDS_FIXUP_MSG, L"on");

    //
    // Fix mangled NCs
    //
    FixupCnfNc(pArgs);

    //
    // Do Semantic check & fixup.
    //
    StartSemanticCheck(TRUE,fVerbose);

    return S_OK;
}

HRESULT RepairSchemaConflict(CArgs *pArgs)
{
    DoRepairSchemaConflict();
    return S_OK;
}


HRESULT DoSCheckGetRecord(CArgs *pArgs)
{
    HRESULT hr;
    DWORD dnt;

    if ( FAILED(hr = pArgs->GetInt(0, (PINT)&dnt)) )
    {
        return hr;
    }

    SCheckGetRecord(fVerbose, dnt);
    return S_OK;
}

HRESULT FixupCnfNc(CArgs *pArgs)
{
    HRESULT hr;
    DWORD dnt;

    SFixupCnfNc();

    UNREFERENCED_PARAMETER(pArgs);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\scheck.h ===
/*++
                                            
Copyright (c) 1998  Microsoft Corporation

Module Name:

    Scheck.h

Abstract:

    Semantic Checker Main Header File

Author:

    Johnson Apacible    (JohnsonA)  1-July-1998

--*/

#ifndef _SCHECK_H_
#define _SCHECK_H_

typedef struct _SUBREF_ENTRY {

   DWORD    Dnt;            // owner of subref list
   BOOL     fListed:1;      // listed on objects subref list
   BOOL     fFound:1;       // referenced by an NC

} SUBREF_ENTRY, *PSUBREF_ENTRY;
    
//
// per entry structure used for ref count checker
//

typedef struct _REFCOUNT_ENTRY {

    DWORD   Dnt;
    INT     RefCount;
    INT     Actual;
    DWORD   Pdnt;
    DWORD   NcDnt;
    WORD    InstType;
    WORD    nAncestors;
    DWORD   AncestorCrc;

    PSUBREF_ENTRY  Subrefs;
    DWORD   nSubrefs;

    BOOL    fSubRef:1;
    BOOL    fObject:1;
    BOOL    fDeleted:1;

} REFCOUNT_ENTRY, *PREFCOUNT_ENTRY;

#define REFCOUNT_HASH_MASK          0x0000FFFF
#define REFCOUNT_HASH_INCR          0x00010000

//
// The secondary hash is always odd
//

#define GET_SECOND_HASH_INCR(_dnt)  (((_dnt) >> 16) | 1)

//
// Round allocation to a multiple of 64K
//

#define ROUND_ALLOC(_rec)   (((((_rec) + 16000 ) >> 16) + 1) << 16)

typedef struct _DNAME_TABLE_ENTRY {

    DWORD   ColId;
    DWORD   Value;
    DWORD   Syntax;
    PVOID   pValue;

} DNAME_TABLE_ENTRY, *PDNAME_TABLE_ENTRY;

//
// Routines
//

VOID
DoRefCountCheck(
    IN DWORD nRecs,
    IN BOOL fFixup
    );

VOID
PrintRoutineV(
    IN LPSTR Format,
    va_list arglist
    );

BOOL
BuildRetrieveColumnForRefCount(
    VOID
    );

int __cdecl 
fnColIdSort(
    const void * keyval, 
    const void * datum
    ) ;

VOID
ProcessResults(
    IN BOOL fFixup
    );

VOID
CheckAncestors(
    IN BOOL fFixup
    );

VOID
CheckRefCount(
    IN BOOL fFixup
    );
VOID
CheckInstanceTypes(
    VOID
    );

VOID
CheckReplicationBlobs(
    VOID
    );

PREFCOUNT_ENTRY
FindDntEntry(
    DWORD Dnt,
    BOOL  fInsert
    );

VOID
ValidateDeletionTime(
    IN LPSTR ObjectStr
    );

VOID
CheckAncestorBlob(
    PREFCOUNT_ENTRY pEntry
    );

VOID
CheckDeletedRecord(
    IN LPSTR ObjectStr
    );

VOID
ValidateSD(
    VOID
    );

VOID
ProcessLinkTable(
    VOID
    );

NTSTATUS
DsWaitUntilDelayedStartupIsDone(void);

DWORD
OpenJet(
    IN const char * pszFileName 
    );

DWORD
OpenTable (
    IN BOOL fWritable,
    IN BOOL fCountRecords
    );

VOID CloseJet(void);

VOID 
SetJetParameters (
    JET_INSTANCE *JetInst
    );

VOID
DisplayRecord(
    IN DWORD Dnt
    );

BOOL
GetLogFileName2(
    IN PCHAR Name
    );

BOOL
OpenLogFile(
    VOID
    );

VOID
CloseLogFile(
    VOID
    );

BOOL
Log(
    IN BOOL     fLog,
    IN LPSTR    Format,
    ...
    );


PWCHAR
GetJetErrString(
    IN JET_ERR JetError
    );

BOOL
ExpandBuffer(
    JET_RETRIEVECOLUMN *jetcol
    );

VOID
StartSemanticCheck(
    IN BOOL fFixup,
    IN BOOL fVerbose
    );

//
// Externs
//

extern JET_INSTANCE jetInstance;
extern JET_COLUMNID    blinkid;
extern JET_SESID    sesid;
extern JET_DBID	dbid;
extern JET_TABLEID  tblid;
extern JET_TABLEID  linktblid;
extern BOOL        VerboseMode;
extern BOOL        CheckSchema;
extern long lCount;

extern PWCHAR       szRdn;
extern DWORD        insttype;
extern BYTE         bObject;
extern ULONG        ulDnt;



// maximum number of characters that will be written to the buffer given
// by GetJetErrorDescription
#define MAX_JET_ERROR_LENGTH 128



#endif // _SCHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\scheckc.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dbopen.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <ctype.h>
#include "scheck.h"
#include <dsatools.h>
#include <mdlocal.h>        // for BAD_NAME_CHAR

#include "parsedn.h"
#include "ditlayer.h"
#include "reshdl.h"
#include "resource.h"
#include <winldap.h>
#include "utilc.h"


//
// Global Variables
//

JET_INSTANCE    jetInstance = -1;
JET_SESID       sesid = JET_sesidNil;
JET_DBID        dbid = JET_dbidNil;
JET_TABLEID     tblid = JET_tableidNil;
JET_TABLEID     linktblid = JET_tableidNil;
JET_COLUMNID    blinkid;

char        *szIndex = SZDNTINDEX;
BOOL        LogToFile = TRUE;
BOOL        fTerminateJet = FALSE;
DWORD       IndexCount = 0;

CHAR        gszFileName[MAX_PATH+1] = {0};


//
// constant definitions
//
#define MAX_PRINTF_LEN 1024        // Arbitrary.
#define SZCONFIG_W      L"CN=Configuration"
#define SZPARTITIONS_W  L"CN=Partitions"
#define SZNCNAME        "ATTb131088"

// Verbose dev debug/test
#define CNF_NC_DBG 0

#if CNF_NC_DBG
#define XDBG(str)                fprintf(stderr, str);
#define XDBG1(str, a1)           fprintf(stderr, str, a1);
#define XDBG2(str, a1, a2)       fprintf(stderr, str, a1, a2);
#define XDBG3(str, a1, a2, a3)   fprintf(stderr, str, a1, a2, a3);
#define XDBG4(str, a1, a2, a3, a4)   fprintf(stderr, str, a1, a2, a3, a4);
#else
#define XDBG(str)
#define XDBG1(str, a1)
#define XDBG2(str, a1, a2)
#define XDBG3(str, a1, a2, a3)
#define XDBG4(str, a1, a2, a3, a4)
#endif

//
// command line switches
//

BOOL        VerboseMode = FALSE;
long        lCount;
HANDLE      hsLogFile = INVALID_HANDLE_VALUE;

//
// local prototypes
//

LPWSTR
GetDN(
    IN DB_STATE *dbState,
    IN TABLE_STATE *tableState,
    IN DWORD dnt,
    IN BOOL fPrint
    );

HRESULT
FindPartitions(
    IN  DB_STATE *dbState,
    IN  TABLE_STATE *tableState,
    IN  TABLE_STATE *linkTableState,
    OUT PDWORD  pDnt
    );

HRESULT
FixMangledNC(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn
    );

HRESULT
ReParentChildren(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntNew,
    IN DWORD dntOld
    );

HRESULT
ReParent(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntKid,
    IN DWORD dntNew,
    IN DWORD dntOld
    );

HRESULT
UnmangleDn(
    IN  OUT LPWSTR pDn
    );

LPWSTR
MangleRdn(
    IN  LPWSTR  pDn,
    IN  LPWSTR  szTag,
    IN  GUID    guid
    );


//
// Implementation
//

VOID
StartSemanticCheck(
    IN BOOL fFixup,
    IN BOOL fVerbose
    )
{

    DWORD nRecs;

    VerboseMode = fVerbose;

    if ( OpenJet(NULL) == S_OK ) {
        nRecs = OpenTable(fFixup, TRUE); // read only, count records

        if ( nRecs > 0 ) {

            if ( LogToFile ) {
                OpenLogFile( );
            }

            DoRefCountCheck( nRecs, fFixup );

            CloseLogFile( );
        }
    }

    CloseJet();

    return;

} // StartSemanticCheck

VOID
SCheckGetRecord(
    IN BOOL fVerbose,
    IN DWORD Dnt
    )
{
    DWORD nRecs;

    VerboseMode = fVerbose;

    if (OpenJet (NULL) == S_OK ) {
        nRecs = OpenTable(FALSE, FALSE); // read only, don't count records

        if ( nRecs > 0 ) {

            //
            // Search for record
            //

            DisplayRecord(Dnt);
        }
    }
    CloseJet();

} // ScheckGetRecord



LPWSTR
GetDN(
    IN DB_STATE *dbState,
    IN TABLE_STATE *tableState,
    IN DWORD dnt,
    IN BOOL  fPrint )
/*++

Routine Description:

    Shells on DitGetDnFromDnt for convinience.
    Also conditionally print the DN

Arguments:

    dbState -- opened database
    tableState -- opened table
    dnt -- dnt of dn to retrieve & print
    fPrint -- basically a verbose flag (print to console)



Return Value:

    allocated dn buffer or NULL on error

remark:

    fPrint --
    In the future it'd be nice if we can change this
    to a real print as a resource string. Currently
    it'll get used only in debug mode cause we can't
    change resource strings in SP (the time this feature
    was added).

--*/
{
    // initial dn length guess, will be re-allocated if needed
#define MAX_DN_LEN_GUESS     1024

    DWORD cbBuffer;
    LPWSTR pBuffer;
    HRESULT result;

    //
    // Seek to DSA & print DN (for user)
    //

    cbBuffer = sizeof(WCHAR) * MAX_DN_LEN_GUESS;
    result = DitAlloc(&pBuffer, cbBuffer);
    if ( FAILED(result) ) {
        return NULL;
    }
    ZeroMemory(pBuffer, cbBuffer);

    result = DitGetDnFromDnt(dbState,
                             tableState,
                             dnt,
                             &pBuffer,
                             &cbBuffer);
    if ( FAILED(result) ) {
        XDBG1("Error: failed to get dn of dnt %d\n", dnt);
        DitFree(pBuffer);
        pBuffer = NULL;
    }
    else if ( fPrint ) {
         XDBG1("DN: %S\n",
               (pBuffer ? pBuffer : L"<null>") );
    }
    return pBuffer;
}

HRESULT
FixMangledNC(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn )
/*++

Routine Description:

    Attempt to fix conflicted NC name:
    a) remove conflict. If the name exist, see if it is a phantom. If so
    b) move phantom's kids to conflicted name
    c) mangle phantom name
    d) recover name (unmangle).

    (actually doesn't have to be NC, but this is how it is used today,
    if you re-use, you must re-evaluate this function)

Arguments:

    DbState -- opened database
    TableState -- opened table
    MangledDnt -- bad NC we wish to recover
    pRdn -- the rdn of this bad NC.

Return Value:

    HRESULT error space

--*/
{
    HRESULT result = S_OK;
    JET_ERR jErr;
    LPWSTR pch;
    DWORD cLen;     // watch usaged below
    LPWSTR pBuffer = NULL;
    DWORD  cbBuffer = 0;
    DWORD  pdnt, dnt, dntUnMangled;
    DWORD iKids = 0;
    GUID MangledGuid, UnMangledGuid;
    LPWSTR pDn, pMangledDn;
    BYTE bVal = 0;
    BOOL fInTransaction = FALSE;

    //
    // - fix string name (get rid of mangle)
    //



    pch = wcsrchr(pRdn, BAD_NAME_CHAR);
    if ( !pch ) {
        return E_UNEXPECTED;
    }

    *pch = '\0';
    cLen = wcslen(pRdn);        // don't overwrite. re-used below.

    XDBG2(" DBG: new RDN = %S; cLen = %d\n",
                            pRdn, cLen);

    __try {

        //
        // Start Jet transaction
        //
        jErr = JetBeginTransaction(DbState->sessionId);
        if ( jErr != JET_errSuccess ) {
            //"Could not start a new transaction: %ws.\n"
            RESOURCE_PRINT1 (IDS_JETBEGINTRANS_ERR, GetJetErrString(jErr));
            result = E_UNEXPECTED;
            goto CleanUp;
        }
        fInTransaction = TRUE;

        //
        // Set column rdn (excluding terminating \0)
        //
        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pRdn,
                        cLen*sizeof(WCHAR),
                        FALSE );
        if ( SUCCEEDED(result) ) {
            //
            // Tell user we fixed his domain
            //
            XDBG1("Successfully converted mangled Naming Context %S\n", pRdn);
            goto CleanUp;
        }

        //
        // UnMangle failed.
        // Most common reason would be due to existing object
        // (we'd lost the jet error code here)
        // -->
        //  a) seek to object w/ good name
        //  b) See if it's a phantom, thus we can take over
        //  c) move it's children to currently mangled object
        //  d) mangle other object's name
        //  e) unmangle this object
        //
        XDBG2("Error<%x>: failed to fix mangled dn %S. Retrying.\n",
              result, pRdn);

        pDn = GetDN(DbState, TableState, MangledDnt, TRUE);
        if (!pDn) {
            XDBG("Error: failed to get mangled DN\n");
            goto CleanUp;
        }
        cbBuffer = wcslen(pDn);
        result = DitAlloc(&pMangledDn, (cbBuffer+1) * sizeof(WCHAR));
        if ( FAILED(result) ) {
            XDBG("Error: failed to allocate memory for mangled DN\n");
            goto CleanUp;
        }
        wcscpy(pMangledDn, pDn);

        // verify that our mangled object is a good one
        // (has a guid)
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZGUID,
                    &MangledGuid,
                    sizeof(MangledGuid),
                    NULL);
        if ( FAILED(result)  || fNullUuid(&MangledGuid)) {
            XDBG1("Error <%x>: Invalid Guid for mangled name\n", result);
            goto CleanUp;
        }

        //
        // Now unmangle & seek to what we hope is a phantom
        //
        result = UnmangleDn(pDn);
        if ( FAILED(result) ) {
            // unexpected. syntactic unmangling should work.
            XDBG1(" [DBG] Can't unmangle name %S\n", pDn);
            goto CleanUp;
        }

        result = DitSeekToDn(
                    DbState,
                    TableState,
                    pDn);
        if ( FAILED(result) ) {
            XDBG2("Error <%x>: can't seek to %S\n", result, pDn);
            goto CleanUp;
        }

        // get its dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZDNT,
                    &dntUnMangled,
                    sizeo