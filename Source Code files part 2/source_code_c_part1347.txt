for last
	test      dl, dl					; check for INTRA-DC (block type=0)
	jz	      finish					; if only the INTRADC present


;
; Get Next Coefficient
;
;	prior codes prepares ebx and ecx as follows:
;		ebx = lBitsInOut>>3
;		ecx = lBitsInOut
;

get_next_coefficient:
;  use dword load & bitswap to achieve big endian ordering
	mov       eax, [esi+ebx]			; *** PROBABLE MALALIGNMENT ***
	and       ecx, 7					; shift value

	bswap     eax						; big endian order
										; *** NOT PAIRABLE ***

	shl       eax, cl					; left justify buffer
										; *** NOT PAIRABLE ***
										; *** 4 CYCLES ***
 	
;  do table lookups
	mov       ebx, eax					; ebx for major table
	mov       ecx, eax					; ecx for minor table

	shr       ebx, 24					; major table lookup

	shr       ecx, 17					; minor table lookup (with garbage)

	and       ecx, 0ffch				; mask off garbage for minor table
	mov       edx, [MajorTbl+4*ebx]		; get the major table value

	cmp       dl, 0						; run != 0 signals major table hit
	jne       @f						; if hit major

	test      edx, edx					; escape code's value is 0
	jz 	      escape_code				; handle escape by major table.

	mov       edx, [MinorTbl+ecx]		; else use minor table
											 
;
;  Input is edx = Table Value.
;  See function header for the meaning of its fields.
;  Now we decode the event, extracting the run, value, last.
;
@@:	
	cmp       dl, 0						; test for invalid code (run == 0)
	je        error

	movd      mm1, edx					; mm0 = table value
										;  (level = bits 31-16)
	movq      mm0, mm1
	psrad     mm1, 31					; dword mask = -1|0 for L neg|pos

	pmullw    mm0, mm2					; L *= 2Q
	mov       ecx, edx					; codeword to ecx to get run

	movq      mm4, mm3					; Q or Q-1
	and       ecx, 0ffh					; run for this coefficient

	pxor      mm4, mm1					; 1s complement if L negative
 	mov       ebx, [lCumulativeRun]		; ebx = old total run

	psubw     mm4, mm1					; 2s complement if L negative
	add       ebx, ecx					; ebx = new cumulative run

	paddw     mm0, mm4					; L +-== Q
	cmp       ebx, 03fh					; check run for bitstream error

	jg        error

  	mov       [lCumulativeRun], ebx		; update the cumulative run
	mov       ebx, [RunTbl+4*ebx]		; ebx = index of the current coefficient

	mov       [edi+4], ebx				; save coefficient's index
	add       edi, 8					; increment coefficient pointer

	movd      mm4, [Scale+4*ebx]		; get normalized scale factor

	shr       edx, 8					; last & bits to bottom
	pmaddwd   mm0, mm4					; multiply by normalized scale factor

	mov       ecx, [lBitsInOut]			; ecx = old number of bits used
	mov       eax, edx					; codeword to eax to get bits

	inc       ebp						; increment number of coefficients read
	and       eax, 07fh					; bits used for this coefficient

	add       ecx, eax					; ecx = new total bits used
	paddd     mm0, mm5					; add rounding bit

 	mov       ebx, ecx					; ebx = lBitsInOut
	psrad     mm0, 10					; shift to get 7 fraction bits rounded

	shr       ebx, 3					; offset for bitstream load
	mov       [lBitsInOut], ecx			; update number of bits used

 	movd      [edi-8], mm0				; save coefficient's signed, scaled value

	cmp       dl, 080h					; check last bit
	jb        get_next_coefficient	 	

finish:
	pop       ecx						; lpN = pointer to number of coeffients
	pop       eax						; lBitsInOut = total bits used

	pop       edx						; lCumulativeRun								
	pop       ebx								

	mov       [ecx], ebp				; store number of coefficients read
	pop       edi

	pop       esi
	pop       ebp

	ret


;
;  Input is eax = bitstream.  
;  See the H.263 spec for the meaning of its fields.
;  Now we decode the event, extracting the run, value, last.
;
escape_code:								
	test      eax, 0001fc00h			; test for invalid codes
	jz        error

	movd      mm0, eax					; mm0 = table value 
										;  (level = bits 17-10)

	mov       ecx, eax					; preserve codeword in eax
	pslld     mm0, 14					; move up to dword boundary
										;  (level = bits 31-24)

	movq      mm1, mm0					; mm1 = mask
	psraw     mm0, 8					; sign extend level

	psrad     mm1, 31					; dword mask = -1|0 for L neg|pos
	pmullw    mm0, mm2					; L *= 2Q

	shr       ecx, 18					; run to bottom
	movq      mm4, mm3					; Q or Q-1

 	mov       ebx, [lCumulativeRun]		; ebx = old total run
	pxor      mm4, mm1					; 1s complement if L negative

	and       ecx, 3fh					; mask off bottom 6 bits for run
	psubw     mm4, mm1					; 2s complement if L negative

	inc       ebx						; old run ++
	paddw     mm0, mm4					; L +-== Q
	
	add       ebx, ecx					; ebx = new cumulative run
	mov       ecx, [lBitsInOut]			; ebx = number of bits used

	cmp       ebx, 03fh					; check run for bitstream error
	ja        error

  	mov       [lCumulativeRun], ebx		; update the cumulative run
	paddsw    mm0, mm6					; add max_pos - High

	mov       ebx, [RunTbl+4*ebx]		; ebx = index of the current coefficient
	psubusw   mm0, mm7					; sub max_pos - High + Low

	paddw     mm0, [MidClip]			; add Low

	movd      mm4, [Scale+4*ebx]		; fetch normalized scale factor

	pmaddwd   mm0, mm4					; multiply by normalized scale factor
	add       ecx, 22					; escape code uses 22 bits

	mov       [edi+4], ebx				; save coefficient's index
	add       edi, 8					; increment coefficient pointer

	inc       ebp						; increment number of coefficients read
 	mov       ebx, ecx					; ebx = lBitsInOut

	shr       ebx, 3					; offset for bitstream load
	paddd     mm0, mm5					; add rounding bit

	mov       [lBitsInOut], ecx			; update number of bits used
	psrad     mm0, 10					; shift to get 7 fraction bits rounded

										; *** 1 cycle load penalty delay ***
 	movd      [edi-8], mm0				; save coefficient's signed, scaled value

	test      eax, 01000000h			; check last bit
	jz        get_next_coefficient	 	

	jmp       finish
				
error:
	pop       ecx						; lpN = pointer to number of coeffients
	pop       eax						; lBitsInOut = total bits used

	pop       edx						; lCumulativeRun
	xor       eax, eax					; zero bits used indicates ERROR

	pop	      ebx								
	pop       edi

	pop	      esi
	pop       ebp

	ret

;         11111111112222222222333333333344444444445555555555666666666677777777778
;12345678901234567890123456789012345678901234567890123456789012345678901234567890
;--------------------------------------------------------------------------------
MMX_VLD_RLD_IQ_Block ENDP

IACODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d35obmc.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/



;--------------------------------------------------------------------------;
;  $Header:   S:\h26x\src\dec\d35obmc.asv   1.2   08 Mar 1996 16:46:06   AGUPTA2  $
;  $Log:   S:\h26x\src\dec\d35obmc.asv  $
;// 
;//    Rev 1.2   08 Mar 1996 16:46:06   AGUPTA2
;// Faster and smaller version of the routine.  Code size reduction achieved
;// by avoiding 32-bit displacement in instructions.
;// 
;// 
;//    Rev 1.1   27 Dec 1995 14:35:52   RMCKENZX
;// Added copyright notice
;
;  d35obmc.asm
;
;  Description
;    This routine performs overlapped block motion compensation for
;    advanced prediction mode.
;
;  Routines:
;    H263OBMC
;
;  Data:
;    This routine assumes that the PITCH is 384.
;
;  Inputs (dwords pushed onto stack by caller):
;    pCurr     flat pointer to current block.
;              Holds values predicted using the
;              motion vector from this block.
;    pLeft     flat pointer to block left of pCurr.
;              Holds values predicted using the
;              motion vector of the left-hand block.
;    pRight    flat pointer to block right of pCurr
;              Holds values predicted using the
;              motion vector of the right-hand block.
;    pAbove    flat pointer to block above pCurr
;              Holds values predicted using the
;              motion vector of the above block.
;    pBelow    flat pointer to block below pCurr
;              Holds values predicted using the
;              motion vector of the below block.
;    pRef      flat pointer to the new predicted values
;              to be computed by this routine.
;
;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35obmc.asv   1.2   08 Mar 1996 16:46:06   AGUPTA2  $
;  $Log$
;// 
;//    Rev 1.0   29 Nov 1995 12:47:28   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;
;
;  Register Usage:
;
    Cent      EQU    esi    ; pCurr
    Comp      EQU    edi    ; pRef
    Horz      EQU    ebp    ; pLeft or pRight
    Vert      EQU    edx    ; pAbove or pBelow
;
;              eax, ebx       accumulators for new predicted values
;                   ecx       temporary
;
;--------------------------------------------------------------------------;
;
;  Notes:  	
;	This routine is fully unrolled.
;
;	The basic computational unit consists of 8 instructions and is 2-folded,
;	meaning that it works on 2 results (the new one in Stage I, the old one
;   in Stage II, see below) at a time.  It uses 3 loads, 3 additions (1 or
;   2 of which are done by the lea instruction), 1 shift, and one store per
;	result computed.  The two stages are interleaved on a 1-1 basis.
;
;  Stage 1:
;	Load Accumulator with Center Value
;	Load Temporary with Horz/Vert Value
;	Accumulator =(lea) x1 times Accumulator plus r0
;	Accumulator =(lea or add) x2 times Accumulator plus x3 times Temporary
;  Stage 2:
;	Load Temporary with other Horz/Vert Value
;	Accumulator =(add) Accumlator plus Temporary
;	Shift Accumlator right s0 bits
; 	Store Accumulator
;
;	where with various values for x1, x2, x3, round, and shift we achieve
;	the needed weighted averages:
;
;                Weights	
;            Cent    Horz/Vert         x1     x2     x3     r0     s0
;   corners   4      2       2          2      1      1      2      2      
;   edges     5      2       1          5      1      2      4      3
;   center    6      1       1          3      2      1      2      3
;
;	This routine uses 4 pointers -- 3 of the 5 input pointers and one
;	output pointer.  The horizontal pointer is adjusted at the middle
;	of each line, and all 4 pointers at the end of each line in order
;	to avoid using large offsets.  This sacrifices some speed in order
;	to hold down code size.  
;
;	If all of its inputs were at some small,
;   fixed offset from a single address, it could be considerably
;	simplified. 
;    
;--------------------------------------------------------------------------;

PITCH   =   384
.586
IACODE2 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE2 ENDS

IACODE2 SEGMENT

PUBLIC _H263OBMC
; input parameters before locals
  pCurr       EQU    esp+20
  pLeft       EQU    esp+24
  pRight      EQU    esp+28
  pAbove      EQU    esp+32
  pBelow      EQU    esp+36
  pRef        EQU    esp+40

; locals
  LeftToRight    EQU    esp+00
  RightToLeft    EQU    esp+04
  AboveToBelow   EQU    esp+08

; saved registers and other stuff
; unused             esp+12
; ebp                esp+16
; esi                esp+20
; ebx                esp+24
; edi                esp+28
; return address     esp+32

; input parameters after locals
  nCurr       EQU    esp+36
  nLeft       EQU    esp+40
  nRight      EQU    esp+44
  nAbove      EQU    esp+48
  nBelow      EQU    esp+52
  nRef        EQU    esp+56

  FRAMESIZE = 16

_H263OBMC:

;  set up
  push     edi
  push     ebx

  push     esi
  push     ebp

  mov      Vert, [pAbove]
  mov      Horz, [pLeft]

  mov      Cent, [pCurr]
  mov      ecx, [pRight]

  mov      eax, [pBelow]
  sub      esp, FRAMESIZE

  sub      ecx, Horz
  sub      eax, Vert

  mov      ebx, PITCH
  mov      [LeftToRight], ecx         ; pRight - pLeft

  add      eax, ebx
  sub      ebx, ecx

  mov      [AboveToBelow], eax        ; pBelow - pAbove + PITCH
  xor      eax, eax


;
;  We start with the upper left corner
;  we go left to right, then drop down
;  to the next row and repeat.
;
  xor      ecx, ecx
  mov      al, [Cent]                  ; start ->00=eax

  mov      [RightToLeft], ebx          ; PITCH + pLeft - pRight
  mov      cl, [Vert]                  ; 00

  xor      ebx, ebx
  lea      eax, [2*eax+2]              ; 00

  mov      Comp, [nRef]
  add      eax, ecx                    ; 00



  mov      cl, [Horz]                  ; 00
  mov      bl, 1[Cent]                 ; start ->01=ebx

  add      eax, ecx                    ; 00
  mov      cl, 1[Vert]                 ; 01

  sar      eax, 2                      ; 00
  lea      ebx, [ebx+4*ebx+4]          ; 01

  mov      [Comp], al                  ; complete <-00=al
  lea      ebx, [ebx+2*ecx]            ; 01



  mov      cl, 1[Horz]                 ; 01
  mov      al, 2[Cent]                 ; start ->02=eax

  add      ebx, ecx                    ; 01
  mov      cl, 2[Vert]                 ; 02

  sar      ebx, 3                      ; 01
  lea      eax, [eax+4*eax+4]          ; 02

  mov      1[Comp], bl                 ; complete <-01=bl
  lea      eax, [eax+2*ecx]            ; 02



  mov      cl, 2[Horz]                 ; 02
  mov      bl, 3[Cent]                 ; start ->03=ebx

  add      eax, ecx                    ; 02
  mov      cl, 3[Vert]                 ; 03

  sar      eax, 3                      ; 02
  lea      ebx, [ebx+4*ebx+4]          ; 03

  mov      2[Comp], al                 ; complete <-02=al
  lea      ebx, [ebx+2*ecx]            ; 03



  mov      cl, 3[Horz]                 ; 03
  mov      al, 4[Cent]                 ; start ->04=eax

  mov      Horz, [nRight]
  add      ebx, ecx                    ; 03

  mov      cl, 4[Vert]                 ; 04

  sar      ebx, 3                      ; 03
  lea      eax, [eax+4*eax+4]          ; 04

  mov      3[Comp], bl                 ; complete <-03=bl
  lea      eax, [eax+2*ecx]            ; 04



  mov      cl, 4[Horz]                 ; 04
  mov      bl, 5[Cent]                 ; start ->05=ebx

  add      eax, ecx                    ; 04
  mov      cl, 5[Vert]                 ; 05

  sar      eax, 3                      ; 04
  lea      ebx, [ebx+4*ebx+4]          ; 05

  mov      4[Comp], al                 ; complete <-04=al
  lea      ebx, [ebx+2*ecx]            ; 05



  mov      cl, 5[Horz]                 ; 05
  mov      al, 6[Cent]                 ; start ->06=eax

  add      ebx, ecx                    ; 05
  mov      cl, 6[Vert]                 ; 06

  sar      ebx, 3                      ; 05
  lea      eax, [eax+4*eax+4]          ; 06

  mov      5[Comp], bl                 ; complete <-05=bl
  lea      eax, [eax+2*ecx]            ; 06



  mov      cl, 6[Horz]                 ; 06
  mov      bl, 7[Cent]                 ; start ->07=ebx

  add      eax, ecx                    ; 06
  mov      cl, 7[Horz]                 ; 07

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 06
  lea      ebx, [2*ebx+2]              ; 07

  mov      6[Comp], al                 ; complete <-06=al
  add      ebx, ecx                    ; 07



  mov      cl, 7[Vert]                 ; 07
  mov      al, 0[Cent]                 ; start ->10=eax

  add      ebx, ecx                    ; 07
  mov      cl, 0[Horz]                 ; 10

  sar      ebx, 2                      ; 07
  lea      eax, [eax+4*eax+4]          ; 10

  mov      7[Comp], bl                 ; complete <-07=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 10
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 10
  mov      bl, 1[Cent]                 ; start ->11=ebx

  add      eax, ecx                    ; 10
  mov      cl, 1[Horz]                 ; 11

  sar      eax, 3                      ; 10
  lea      ebx, [ebx+4*ebx+4]          ; 11

  mov      0[Comp], al                 ; complete <-10=al
  lea      ebx, [ebx+2*ecx]            ; 11



  mov      cl, 1[Vert]                 ; 11
  mov      al, 2[Cent]                 ; start ->12=eax

  add      ebx, ecx                    ; 11
  mov      cl, 2[Vert]                 ; 12

  sar      ebx, 3                      ; 11
  lea      eax, [eax+4*eax+4]          ; 12

  mov      1[Comp], bl                 ; complete <-11=bl
  lea      eax, [eax+2*ecx]            ; 12



  mov      cl, 2[Horz]                 ; 12
  mov      bl, 3[Cent]                 ; start ->13=ebx

  add      eax, ecx                    ; 12
  mov      cl, 3[Vert]                 ; 13

  sar      eax, 3                      ; 12
  lea      ebx, [ebx+4*ebx+4]          ; 13

  mov      2[Comp], al                 ; complete <-12=al
  lea      ebx, [ebx+2*ecx]            ; 13



  mov      cl, 3[Horz]                 ; 13
  mov      al, 4[Cent]                 ; start ->14=eax

  add      ebx, ecx                    ; 13
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 14

  sar      ebx, 3                      ; 13
  lea      eax, [eax+4*eax+4]          ; 14

  mov      3[Comp], bl                 ; complete <-13=bl
  lea      eax, [eax+2*ecx]            ; 14



  mov      cl, 4[Horz]                 ; 14
  mov      bl, 5[Cent]                 ; start ->15=ebx

  add      eax, ecx                    ; 14
  mov      cl, 5[Vert]                 ; 15

  sar      eax, 3                      ; 14
  lea      ebx, [ebx+4*ebx+4]          ; 15

  mov      4[Comp], al                 ; complete <-14=al
  lea      ebx, [ebx+2*ecx]            ; 15



  mov      cl, 5[Horz]                 ; 15
  mov      al, 6[Cent]                 ; start ->16=eax

  add      ebx, ecx                    ; 15
  mov      cl, 6[Horz]                 ; 16

  sar      ebx, 3                      ; 15
  lea      eax, [eax+4*eax+4]          ; 16

  mov      5[Comp], bl                 ; complete <-15=bl
  lea      eax, [eax+2*ecx]            ; 16



  mov      cl, 6[Vert]                 ; 16
  mov      bl, 7[Cent]                 ; start ->17=ebx

  add      eax, ecx                    ; 16
  mov      cl, 7[Horz]                 ; 17

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 16
  lea      ebx, [ebx+4*ebx+4]          ; 17

  mov      6[Comp], al                 ; complete <-16=al
  lea      ebx, [ebx+2*ecx]            ; 17



  mov      cl, 7[Vert]                 ; 17
  mov      al, 0[Cent]                 ; start ->20=eax

  add      ebx, ecx                    ; 17
  mov      cl, 0[Horz]                 ; 20

  sar      ebx, 3                      ; 17
  lea      eax, [eax+4*eax+4]          ; 20

  mov      7[Comp], bl                 ; complete <-17=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 20
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 20
  mov      bl, 1[Cent]                 ; start ->21=ebx

  add      eax, ecx                    ; 20
  mov      cl, 1[Horz]                 ; 21

  sar      eax, 3                      ; 20
  lea      ebx, [ebx+4*ebx+4]          ; 21

  mov      0[Comp], al                 ; complete <-20=al
  lea      ebx, [ebx+2*ecx]            ; 21



  mov      cl, 1[Vert]                 ; 21
  mov      al, 2[Cent]                 ; start ->22=eax

  add      ebx, ecx                    ; 21
  mov      cl, 2[Vert]                 ; 22

  sar      ebx, 3                      ; 21
  lea      eax, [eax+2*eax+2]          ; 22

  mov      1[Comp], bl                 ; complete <-21=bl
  lea      eax, [2*eax+ecx]            ; 22



  mov      cl, 2[Horz]                 ; 22
  mov      bl, 3[Cent]                 ; start ->23=ebx

  add      eax, ecx                    ; 22
  mov      cl, 3[Vert]                 ; 23

  sar      eax, 3                      ; 22
  lea      ebx, [ebx+2*ebx+2]          ; 23

  mov      2[Comp], al                 ; complete <-22=al
  lea      ebx, [2*ebx+ecx]            ; 23



  mov      cl, 3[Horz]                 ; 23
  mov      al, 4[Cent]                 ; start ->24=eax

  add      ebx, ecx                    ; 23
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 24

  sar      ebx, 3                      ; 23
  lea      eax, [eax+2*eax+2]          ; 24

  mov      3[Comp], bl                 ; complete <-23=bl
  lea      eax, [2*eax+ecx]            ; 24



  mov      cl, 4[Horz]                 ; 24
  mov      bl, 5[Cent]                 ; start ->25=ebx

  add      eax, ecx                    ; 24
  mov      cl, 5[Vert]                 ; 25

  sar      eax, 3                      ; 24
  lea      ebx, [ebx+2*ebx+2]          ; 25

  mov      4[Comp], al                 ; complete <-24=al
  lea      ebx, [2*ebx+ecx]            ; 25



  mov      cl, 5[Horz]                 ; 25
  mov      al, 6[Cent]                 ; start ->26=eax

  add      ebx, ecx                    ; 25
  mov      cl, 6[Horz]                 ; 26

  sar      ebx, 3                      ; 25
  lea      eax, [eax+4*eax+4]          ; 26

  mov      5[Comp], bl                 ; complete <-25=bl
  lea      eax, [eax+2*ecx]            ; 26



  mov      cl, 6[Vert]                 ; 26
  mov      bl, 7[Cent]                 ; start ->27=ebx

  add      eax, ecx                    ; 26
  mov      cl, 7[Horz]                 ; 27

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 26
  lea      ebx, [ebx+4*ebx+4]          ; 27

  mov      6[Comp], al                 ; complete <-26=al
  lea      ebx, [ebx+2*ecx]            ; 27



  mov      cl, 7[Vert]                 ; 27
  mov      al, 0[Cent]                 ; start ->30=eax

  add      ebx, ecx                    ; 27
  mov      cl, 0[Horz]                 ; 30

  sar      ebx, 3                      ; 27
  lea      eax, [eax+4*eax+4]          ; 30

  mov      7[Comp], bl                 ; complete <-27=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 30
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 30
  mov      bl, 1[Cent]                 ; start ->31=ebx

  add      eax, ecx                    ; 30
  mov      cl, 1[Horz]                 ; 31

  sar      eax, 3                      ; 30
  lea      ebx, [ebx+4*ebx+4]          ; 31

  mov      0[Comp], al                 ; complete <-30=al
  lea      ebx, [ebx+2*ecx]            ; 31



  mov      cl, 1[Vert]                 ; 31
  mov      al, 2[Cent]                 ; start ->32=eax

  add      ebx, ecx                    ; 31
  mov      cl, 2[Vert]                 ; 32

  sar      ebx, 3                      ; 31
  lea      eax, [eax+2*eax+2]          ; 32

  mov      1[Comp], bl                 ; complete <-31=bl
  lea      eax, [2*eax+ecx]            ; 32



  mov      cl, 2[Horz]                 ; 32
  mov      bl, 3[Cent]                 ; start ->33=ebx

  add      eax, ecx                    ; 32
  mov      cl, 3[Vert]                 ; 33

  sar      eax, 3                      ; 32
  lea      ebx, [ebx+2*ebx+2]          ; 33

  mov      2[Comp], al                 ; complete <-32=al
  lea      ebx, [2*ebx+ecx]            ; 33



  mov      cl, 3[Horz]                 ; 33
  mov      al, 4[Cent]                 ; start ->34=eax

  add      ebx, ecx                    ; 33
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 34

  sar      ebx, 3                      ; 33
  lea      eax, [eax+2*eax+2]          ; 34

  mov      3[Comp], bl                 ; complete <-33=bl
  lea      eax, [2*eax+ecx]            ; 34



  mov      cl, 4[Horz]                 ; 34
  mov      bl, 5[Cent]                 ; start ->35=ebx

  add      eax, ecx                    ; 34
  mov      cl, 5[Vert]                 ; 35

  sar      eax, 3                      ; 34
  lea      ebx, [ebx+2*ebx+2]          ; 35

  mov      4[Comp], al                 ; complete <-34=al
  lea      ebx, [2*ebx+ecx]            ; 35



  mov      cl, 5[Horz]                 ; 35
  mov      al, 6[Cent]                 ; start ->36=eax

  add      ebx, ecx                    ; 35
  mov      cl, 6[Horz]                 ; 36

  sar      ebx, 3                      ; 35
  lea      eax, [eax+4*eax+4]          ; 36

  mov      5[Comp], bl                 ; complete <-35=bl
  lea      eax, [eax+2*ecx]            ; 36



  mov      cl, 6[Vert]                 ; 36
  mov      bl, 7[Cent]                 ; start ->37=ebx

  add      eax, ecx                    ; 36
  mov      cl, 7[Horz]                 ; 37

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 36
  lea      ebx, [ebx+4*ebx+4]          ; 37

  mov      6[Comp], al                 ; complete <-36=al
  lea      ebx, [ebx+2*ecx]            ; 37



  mov      cl, 7[Vert]                 ; 37
  mov      al, 0[Cent]                 ; start ->40=eax

  add      ebx, ecx                    ; 37
  mov      cl, 0[Horz]                 ; 40

  sar      ebx, 3                      ; 37
  lea      eax, [eax+4*eax+4]          ; 40

  mov      7[Comp], bl                 ; complete <-37=bl
  add      Vert, [AboveToBelow]

  lea      eax, [eax+2*ecx]            ; 40
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 40
  mov      bl, 1[Cent]                 ; start ->41=ebx

  add      eax, ecx                    ; 40
  mov      cl, 1[Horz]                 ; 41

  sar      eax, 3                      ; 40
  lea      ebx, [ebx+4*ebx+4]          ; 41

  mov      0[Comp], al                 ; complete <-40=al
  lea      ebx, [ebx+2*ecx]            ; 41



  mov      cl, 1[Vert]                 ; 41
  mov      al, 2[Cent]                 ; start ->42=eax

  add      ebx, ecx                    ; 41
  mov      cl, 2[Vert]                 ; 42

  sar      ebx, 3                      ; 41
  lea      eax, [eax+2*eax+2]          ; 42

  mov      1[Comp], bl                 ; complete <-41=bl
  lea      eax, [2*eax+ecx]            ; 42



  mov      cl, 2[Horz]                 ; 42
  mov      bl, 3[Cent]                 ; start ->43=ebx

  add      eax, ecx                    ; 42
  mov      cl, 3[Vert]                 ; 43

  sar      eax, 3                      ; 42
  lea      ebx, [ebx+2*ebx+2]          ; 43

  mov      2[Comp], al                 ; complete <-42=al
  lea      ebx, [2*ebx+ecx]            ; 43



  mov      cl, 3[Horz]                 ; 43
  mov      al, 4[Cent]                 ; start ->44=eax

  add      ebx, ecx                    ; 43
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 44

  sar      ebx, 3                      ; 43
  lea      eax, [eax+2*eax+2]          ; 44

  mov      3[Comp], bl                 ; complete <-43=bl
  lea      eax, [2*eax+ecx]            ; 44



  mov      cl, 4[Horz]                 ; 44
  mov      bl, 5[Cent]                 ; start ->45=ebx

  add      eax, ecx                    ; 44
  mov      cl, 5[Vert]                 ; 45

  sar      eax, 3                      ; 44
  lea      ebx, [ebx+2*ebx+2]          ; 45

  mov      4[Comp], al                 ; complete <-44=al
  lea      ebx, [2*ebx+ecx]            ; 45



  mov      cl, 5[Horz]                 ; 45
  mov      al, 6[Cent]                 ; start ->46=eax

  add      ebx, ecx                    ; 45
  mov      cl, 6[Horz]                 ; 46

  sar      ebx, 3                      ; 45
  lea      eax, [eax+4*eax+4]          ; 46

  mov      5[Comp], bl                 ; complete <-45=bl
  lea      eax, [eax+2*ecx]            ; 46



  mov      cl, 6[Vert]                 ; 46
  mov      bl, 7[Cent]                 ; start ->47=ebx

  add      eax, ecx                    ; 46
  mov      cl, 7[Horz]                 ; 47

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 46
  lea      ebx, [ebx+4*ebx+4]          ; 47

  mov      6[Comp], al                 ; complete <-46=al
  lea      ebx, [ebx+2*ecx]            ; 47



  mov      cl, 7[Vert]                 ; 47
  mov      al, 0[Cent]                 ; start ->50=eax

  add      ebx, ecx                    ; 47
  mov      cl, 0[Horz]                 ; 50

  sar      ebx, 3                      ; 47
  lea      eax, [eax+4*eax+4]          ; 50

  mov      7[Comp], bl                 ; complete <-47=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 50
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 50
  mov      bl, 1[Cent]                 ; start ->51=ebx

  add      eax, ecx                    ; 50
  mov      cl, 1[Horz]                 ; 51

  sar      eax, 3                      ; 50
  lea      ebx, [ebx+4*ebx+4]          ; 51

  mov      0[Comp], al                 ; complete <-50=al
  lea      ebx, [ebx+2*ecx]            ; 51



  mov      cl, 1[Vert]                 ; 51
  mov      al, 2[Cent]                 ; start ->52=eax

  add      ebx, ecx                    ; 51
  mov      cl, 2[Vert]                 ; 52

  sar      ebx, 3                      ; 51
  lea      eax, [eax+2*eax+2]          ; 52

  mov      1[Comp], bl                 ; complete <-51=bl
  lea      eax, [2*eax+ecx]            ; 52



  mov      cl, 2[Horz]                 ; 52
  mov      bl, 3[Cent]                 ; start ->53=ebx

  add      eax, ecx                    ; 52
  mov      cl, 3[Vert]                 ; 53

  sar      eax, 3                      ; 52
  lea      ebx, [ebx+2*ebx+2]          ; 53

  mov      2[Comp], al                 ; complete <-52=al
  lea      ebx, [2*ebx+ecx]            ; 53



  mov      cl, 3[Horz]                 ; 53
  mov      al, 4[Cent]                 ; start ->54=eax

  add      ebx, ecx                    ; 53
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 54

  sar      ebx, 3                      ; 53
  lea      eax, [eax+2*eax+2]          ; 54

  mov      3[Comp], bl                 ; complete <-53=bl
  lea      eax, [2*eax+ecx]            ; 54



  mov      cl, 4[Horz]                 ; 54
  mov      bl, 5[Cent]                 ; start ->55=ebx

  add      eax, ecx                    ; 54
  mov      cl, 5[Vert]                 ; 55

  sar      eax, 3                      ; 54
  lea      ebx, [ebx+2*ebx+2]          ; 55

  mov      4[Comp], al                 ; complete <-54=al
  lea      ebx, [2*ebx+ecx]            ; 55



  mov      cl, 5[Horz]                 ; 55
  mov      al, 6[Cent]                 ; start ->56=eax

  add      ebx, ecx                    ; 55
  mov      cl, 6[Horz]                 ; 56

  sar      ebx, 3                      ; 55
  lea      eax, [eax+4*eax+4]          ; 56

  mov      5[Comp], bl                 ; complete <-55=bl
  lea      eax, [eax+2*ecx]            ; 56



  mov      cl, 6[Vert]                 ; 56
  mov      bl, 7[Cent]                 ; start ->57=ebx

  add      eax, ecx                    ; 56
  mov      cl, 7[Horz]                 ; 57

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 56
  lea      ebx, [ebx+4*ebx+4]          ; 57

  mov      6[Comp], al                 ; complete <-56=al
  lea      ebx, [ebx+2*ecx]            ; 57



  mov      cl, 7[Vert]                 ; 57
  mov      al, 0[Cent]                 ; start ->60=eax

  add      ebx, ecx                    ; 57
  mov      cl, 0[Horz]                 ; 60

  sar      ebx, 3                      ; 57
  lea      eax, [eax+4*eax+4]          ; 60

  mov      7[Comp], bl                 ; complete <-57=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 60
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 60
  mov      bl, 1[Cent]                 ; start ->61=ebx

  add      eax, ecx                    ; 60
  mov      cl, 1[Horz]                 ; 61

  sar      eax, 3                      ; 60
  lea      ebx, [ebx+4*ebx+4]          ; 61

  mov      0[Comp], al                 ; complete <-60=al
  lea      ebx, [ebx+2*ecx]            ; 61



  mov      cl, 1[Vert]                 ; 61
  mov      al, 2[Cent]                 ; start ->62=eax

  add      ebx, ecx                    ; 61
  mov      cl, 2[Vert]                 ; 62

  sar      ebx, 3                      ; 61
  lea      eax, [eax+4*eax+4]          ; 62

  mov      1[Comp], bl                 ; complete <-61=bl
  lea      eax, [eax+2*ecx]            ; 62



  mov      cl, 2[Horz]                 ; 62
  mov      bl, 3[Cent]                 ; start ->63=ebx

  add      eax, ecx                    ; 62
  mov      cl, 3[Vert]                 ; 63

  sar      eax, 3                      ; 62
  lea      ebx, [ebx+4*ebx+4]          ; 63

  mov      2[Comp], al                 ; complete <-62=al
  lea      ebx, [ebx+2*ecx]            ; 63



  mov      cl, 3[Horz]                 ; 63
  mov      al, 4[Cent]                 ; start ->64=eax

  add      ebx, ecx                    ; 63
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 64

  sar      ebx, 3                      ; 63
  lea      eax, [eax+4*eax+4]          ; 64

  mov      3[Comp], bl                 ; complete <-63=bl
  lea      eax, [eax+2*ecx]            ; 64



  mov      cl, 4[Horz]                 ; 64
  mov      bl, 5[Cent]                 ; start ->65=ebx

  add      eax, ecx                    ; 64
  mov      cl, 5[Vert]                 ; 65

  sar      eax, 3                      ; 64
  lea      ebx, [ebx+4*ebx+4]          ; 65

  mov      4[Comp], al                 ; complete <-64=al
  lea      ebx, [ebx+2*ecx]            ; 65



  mov      cl, 5[Horz]                 ; 65
  mov      al, 6[Cent]                 ; start ->66=eax

  add      ebx, ecx                    ; 65
  mov      cl, 6[Horz]                 ; 66

  sar      ebx, 3                      ; 65
  lea      eax, [eax+4*eax+4]          ; 66

  mov      5[Comp], bl                 ; complete <-65=bl
  lea      eax, [eax+2*ecx]            ; 66



  mov      cl, 6[Vert]                 ; 66
  mov      bl, 7[Cent]                 ; start ->67=ebx

  add      eax, ecx                    ; 66
  mov      cl, 7[Horz]                 ; 67

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 66
  lea      ebx, [ebx+4*ebx+4]          ; 67

  mov      6[Comp], al                 ; complete <-66=al
  lea      ebx, [ebx+2*ecx]            ; 67



  mov      cl, 7[Vert]                 ; 67
  mov      al, 0[Cent]                 ; start ->70=eax

  add      ebx, ecx                    ; 67
  mov      cl, 0[Horz]                 ; 70

  sar      ebx, 3                      ; 67
  lea      eax, [2*eax+2]              ; 70

  mov      7[Comp], bl                 ; complete <-67=bl
  add      Vert, PITCH

  add      eax, ecx                    ; 70
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 70
  mov      bl, 1[Cent]                 ; start ->71=ebx

  add      eax, ecx                    ; 70
  mov      cl, 1[Vert]                 ; 71

  sar      eax, 2                      ; 70
  lea      ebx, [ebx+4*ebx+4]          ; 71

  mov      0[Comp], al                 ; complete <-70=al
  lea      ebx, [ebx+2*ecx]            ; 71



  mov      cl, 1[Horz]                 ; 71
  mov      al, 2[Cent]                 ; start ->72=eax

  add      ebx, ecx                    ; 71
  mov      cl, 2[Vert]                 ; 72

  sar      ebx, 3                      ; 71
  lea      eax, [eax+4*eax+4]          ; 72

  mov      1[Comp], bl                 ; complete <-71=bl
  lea      eax, [eax+2*ecx]            ; 72



  mov      cl, 2[Horz]                 ; 72
  mov      bl, 3[Cent]                 ; start ->73=ebx

  add      eax, ecx                    ; 72
  mov      cl, 3[Vert]                 ; 73

  sar      eax, 3                      ; 72
  lea      ebx, [ebx+4*ebx+4]          ; 73

  mov      2[Comp], al                 ; complete <-72=al
  lea      ebx, [ebx+2*ecx]            ; 73



  mov      cl, 3[Horz]                 ; 73
  mov      al, 4[Cent]                 ; start ->74=eax

  add      ebx, ecx                    ; 73
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 74

  sar      ebx, 3                      ; 73
  lea      eax, [eax+4*eax+4]          ; 74

  mov      3[Comp], bl                 ; complete <-73=bl
  lea      eax, [eax+2*ecx]            ; 74



  mov      cl, 4[Horz]                 ; 74
  mov      bl, 5[Cent]                 ; start ->75=ebx

  add      eax, ecx                    ; 74
  mov      cl, 5[Vert]                 ; 75

  sar      eax, 3                      ; 74
  lea      ebx, [ebx+4*ebx+4]          ; 75

  mov      4[Comp], al                 ; complete <-74=al
  lea      ebx, [ebx+2*ecx]            ; 75



  mov      cl, 5[Horz]                 ; 75
  mov      al, 6[Cent]                 ; start ->76=eax

  add      ebx, ecx                    ; 75
  mov      cl, 6[Vert]                 ; 76

  sar      ebx, 3                      ; 75
  lea      eax, [eax+4*eax+4]          ; 76

  mov      5[Comp], bl                 ; complete <-75=bl
  lea      eax, [eax+2*ecx]            ; 76



  mov      cl, 6[Horz]                 ; 76
  mov      bl, 7[Cent]                 ; start ->77=ebx

  add      eax, ecx                    ; 76
  mov      cl, 7[Horz]                 ; 77

  sar      eax, 3                      ; 76
  lea      ebx, [2*ebx+2]              ; 77

  mov      6[Comp], al                 ; complete <-76=al
  add      ebx, ecx                    ; 77



  mov      cl, 7[Vert]                 ; 77
  add      esp, FRAMESIZE

  add      ebx, ecx                    ; 77

  sar      ebx, 2                      ; 77
  pop      ebp

  mov      7[Comp], bl                 ; complete <-77=bl
  pop      esi

;
;  wrap up and go home with the job well done
;


  pop      ebx
  pop      edi

  ret

IACODE2 ENDS

END
//  h263obmc1.asm	page 17	5:02 PM, 10/29/95  //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mmc.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/
;/* *************************************************************************
;** $Header:   S:\h26x\src\dec\d3mmc.asv   1.1   14 Mar 1996 14:34:54   AGUPTA2  $
;** $Log:   S:\h26x\src\dec\d3mmc.asv  $
;// 
;//    Rev 1.1   14 Mar 1996 14:34:54   AGUPTA2
;// 
;// Added alignment directives.
;// 
;//    Rev 1.0   14 Mar 1996 14:32:58   AGUPTA2
;// Initial revision.
;** *************************************************************************
;*/
.586
.model flat
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
C0101010101010101H DD 001010101H, 001010101H
CfefefefefefefefeH DD 0fefefefeH, 0fefefefeH
CfcfcfcfcfcfcfcfcH DD 0fcfcfcfcH, 0fcfcfcfcH
C0303030303030303H DD 003030303H, 003030303H
TWO                DD 002020202H, 002020202H
MMXDATA1 ENDS

PITCH TEXTEQU <384>

MMXCODE1 SEGMENT
;  @MMX_Interpolate_Int_Half
;    This routine computes interpolated pels shown by 'x' for a an 8x8 block
;    of pels.  'x' is computed by the formula (A+B+1)/2.  The input and output
;    pitch is assumed to be 384 (PITCH).
;      A   .   .   .   .   .   .   .
;      x   x   x   x   x   x   x   x
;      B   .   .   .   .   .   .   .
;    The basic instruction sequence is:
;      movq  V0, A
;      movq  V2, B
;      movq  V1, V0
;      por   V1, V2
;      pand  V1, 0x0101010101010101
;      pand  V0, 0xfefefefefefefefe
;      psrlq V0, 1
;      pand  V2, 0xfefefefefefefefe
;      psrlq V2, 1
;      paddb V0, V1
;      paddb V0, V2
;      movq  dest, V0
;    The instruction sequence for line 0 is 12 instructions.  The instruction
;    sequence for line 1 should be 12 instructions but is not because some of
;    the values needed for line 1 have already been computed for line 0.
;
;    Registers used for lines 0-7 are:
;      line 0: mm0, mm1, mm2
;      line 1: mm2, mm3, mm4
;      line 2: mm4, mm5, mm0
;      line 3: mm0, mm1, mm2
;      line 4: mm2, mm3, mm4
;      line 5: mm4, mm5, mm0
;      line 6: mm0, mm1, mm2
;      line 7: mm2, mm3, mm4
;    Constants 0x0101010101010101 and 0xfefefefefefefefe are in mm6 and mm7,
;    respectively.
;  Parameters:
;    The source block parameter should be in ecx and the destination block
;    parameter should be in edx; i.e. it uses fastcall calling convention.
;    (I am not aware of a way to declare a MASM function of type __fastcall.)
;  Performance:
;    41 cycles ignoring unaligned memory accesses
;    68 cycles if all loads are unaligned (41+9*3); stores should always be
;    aligned.
ALIGN 4
@MMX_Interpolate_Int_Half@8 PROC
  EXTRACTLOWBIT TEXTEQU <mm6>
  CLEARLOWBIT   TEXTEQU <mm7>
  movq       mm0, [ecx]                      ;0
   ;
  movq       mm2, [ecx+PITCH]                ;0
   movq      mm1, mm0                        ;0
  movq       mm6, C0101010101010101H         ;
   movq      mm3, mm2                        ;1
  movq       mm7, CfefefefefefefefeH         ;
   por       mm1, mm2                        ;0
  pand       mm0, CLEARLOWBIT                ;0
   pand      mm2, CLEARLOWBIT                ;0
  psrlq      mm0, 1                          ;0
   pand      mm1, EXTRACTLOWBIT              ;0
  movq       mm4, [ecx+2*PITCH]              ;1
   psrlq     mm2, 1                          ;0
  paddb      mm0, mm1                        ;0
   movq      mm5, mm4                        ;2
  paddb      mm0, mm2                        ;0
   por       mm3, mm4                        ;1
  pand       mm4, CLEARLOWBIT                ;1
   pand      mm3, EXTRACTLOWBIT              ;1
  movq       [edx+0*PITCH], mm0              ;0
   psrlq     mm4, 1                          ;1
  movq       mm0, [ecx+3*PITCH]              ;2
   paddb     mm2, mm3                        ;1
  movq       mm1, mm0                        ;3
   paddb     mm2, mm4                        ;1
  por        mm5, mm0                        ;2
   pand      mm0, CLEARLOWBIT                ;2
  movq       [edx+1*PITCH], mm2              ;1
   psrlq     mm0, 1                          ;2
  paddb      mm4, mm0                        ;2
   pand      mm5, EXTRACTLOWBIT              ;2
  movq       mm2, [ecx+4*PITCH]              ;3
   paddb     mm4, mm5                        ;2
  por        mm1, mm2                        ;3
   movq      mm3, mm2                        ;4
  movq       [edx+2*PITCH],mm4               ;2
   pand      mm2, CLEARLOWBIT                ;3
  psrlq      mm2, 1                          ;3
   pand      mm1, EXTRACTLOWBIT              ;3
  movq       mm4, [ecx+5*PITCH]              ;4
   paddb     mm0, mm1                        ;3
  movq       mm5, mm4                        ;5
   paddb     mm0, mm2                        ;3
  por        mm3, mm4                        ;4
   pand      mm4, CLEARLOWBIT                ;4
  movq       [edx+3*PITCH],mm0               ;3
   pand      mm3, EXTRACTLOWBIT              ;4
  movq       mm0, [ecx+6*PITCH]              ;5
   psrlq     mm4, 1                          ;4
  movq       mm1, mm0                        ;6
   paddb     mm2, mm3                        ;4
  paddb      mm2, mm4                        ;4
   por       mm5, mm0                        ;5
  pand       mm0, CLEARLOWBIT                ;5
   pand      mm5, EXTRACTLOWBIT              ;5
  movq       [edx+4*PITCH], mm2              ;4
   psrlq     mm0, 1                          ;5
  movq       mm2, [ecx+7*PITCH]              ;6
   paddb     mm4, mm5                        ;5
  movq       mm3, mm2                        ;7
   paddb     mm4, mm0                        ;5
  por        mm1, mm2                        ;6
   pand      mm2, CLEARLOWBIT                ;6
  movq       [edx+5*PITCH], mm4              ;5
   pand      mm1, EXTRACTLOWBIT              ;6
  movq       mm4, [ecx+8*PITCH]              ;7
   psrlq     mm2, 1                          ;6
  por        mm3, mm4                        ;7
   paddb     mm0, mm1                        ;6
  paddb      mm0, mm2                        ;6
   pand      mm3, EXTRACTLOWBIT              ;7
  pand       mm4, CLEARLOWBIT                ;7
   paddb     mm3, mm2                        ;7
  movq       [edx+6*PITCH], mm0              ;6
   psrlq     mm4, 1                          ;7
  paddb      mm3, mm4                        ;7
   ;
  ;
   ;
  movq       [edx+7*PITCH], mm3              ;7
   ret
  EXTRACTLOWBIT TEXTEQU <>
  CLEARLOWBIT   TEXTEQU <>
@MMX_Interpolate_Int_Half@8 endp


;  @MMX_Interpolate_Half_Int
;    This routine computes interpolated pels shown by 'x' for a an 8x8 block
;    of pels.  'x' is computed by the formula (A+B+1)/2.  The input and output
;    pitch is assumed to be 384 (PITCH).
;      A X B X . X . X . X . X . X . X
;    The basic instruction sequence is:
;      movq  V0, A
;      movq  V2, B
;      movq  V1, V0
;      por   V1, V2
;      pand  V1, 0x0101010101010101
;      pand  V0, 0xfefefefefefefefe
;      psrlq V0, 1
;      pand  V2, 0xfefefefefefefefe
;      psrlq V2, 1
;      paddb V0, V1
;      paddb V0, V2
;      movq  dest, V0
;    The instruction sequence for all lines is 12 instructions.
;
;    Registers used for lines 0-7 are:
;      line 0: mm0, mm1, mm2
;      line 1: mm3, mm4, mm5
;      line 2: mm0, mm1, mm2
;      line 3: mm3, mm4, mm5
;      line 4: mm0, mm1, mm2
;      line 5: mm3, mm4, mm5
;      line 6: mm0, mm1, mm2
;      line 7: mm3, mm4, mm5
;    Constants 0x0101010101010101 and 0xfefefefefefefefe are in mm6 and mm7,
;    respectively.
;  Parameters:
;    The source block parameter should be in ecx and the destination block
;    parameter should be in edx; i.e. it uses fastcall calling convention.
;  Performance:
;    51 cycles ignoring unaligned memory accesses
;    99 cycles if all loads are unaligned (51+8*6); stores should always be
;    aligned.
ALIGN 4
@MMX_Interpolate_Half_Int@8  proc
  EXTRACTLOWBIT TEXTEQU <mm6>
  CLEARLOWBIT   TEXTEQU <mm7>
  movq       mm0, [ecx]                      ;0 mm0,mm1=left pels
   ;                                         ;  mm2    =right pels
  movq       mm2, [ecx+1]                    ;0 mm1    =interp pels
   movq      mm1, mm0                        ;0
  movq       mm7, CfefefefefefefefeH         ;
   por       mm1, mm2                        ;0
  movq       mm6, C0101010101010101H         ;
   pand      mm0, CLEARLOWBIT                ;0
  pand       mm2, CLEARLOWBIT                ;0
   psrlq     mm0, 1                          ;0
  psrlq      mm2, 1                          ;0
   pand      mm1, EXTRACTLOWBIT              ;0
  movq       mm3, [ecx+1*PITCH]              ;1 mm3,mm4=left pels
   paddb     mm1, mm0                        ;0 mm5    =right pels
  movq       mm5, [ecx+1*PITCH+1]            ;1 mm4    =interp pels
   paddb     mm1, mm2                        ;0
  movq       mm4, mm3                        ;1
   pand      mm3, CLEARLOWBIT                ;1
  movq       [edx], mm1                      ;0
   por       mm4, mm5                        ;1
  psrlq      mm3, 1                          ;1
   pand      mm5, CLEARLOWBIT                ;1
  psrlq      mm5, 1                          ;1
   pand      mm4, EXTRACTLOWBIT              ;1
  movq       mm0, [ecx+2*PITCH]              ;2 mm0,mm1=left pels
   paddb     mm4, mm3                        ;1 mm2    =right pels
  movq       mm2, [ecx+2*PITCH+1]            ;2 mm1    =interp pels
   paddb     mm4, mm5                        ;1
  movq       mm1, mm0                        ;2
   pand      mm0, CLEARLOWBIT                ;2
  movq       [edx+1*PITCH], mm4              ;1
   por       mm1, mm2                        ;2
  psrlq      mm0, 1                          ;2
   pand      mm2, CLEARLOWBIT                ;2
  psrlq      mm2, 1                          ;2
   pand      mm1, EXTRACTLOWBIT              ;2
  movq       mm3, [ecx+3*PITCH]              ;3 mm3,mm4=left pels
   paddb     mm1, mm0                        ;2 mm5    =right pels
  movq       mm5, [ecx+3*PITCH+1]            ;3 mm4    =interp pels
   paddb     mm1, mm2                        ;2
  movq       mm4, mm3                        ;3
   pand      mm3, CLEARLOWBIT                ;3
  movq       [edx+2*PITCH], mm1              ;2
   por       mm4, mm5                        ;3
  psrlq      mm3, 1                          ;3
   pand      mm5, CLEARLOWBIT                ;3
  psrlq      mm5, 1                          ;3
   pand      mm4, EXTRACTLOWBIT              ;3
  movq       mm0, [ecx+4*PITCH]              ;4 mm0,mm1=left pels
   paddb     mm4, mm3                        ;3 mm2    =right pels
  movq       mm2, [ecx+4*PITCH+1]            ;4 mm1    =interp pels
   paddb     mm4, mm5                        ;3
  movq       mm1, mm0                        ;4
   pand      mm0, CLEARLOWBIT                ;4
  movq       [edx+3*PITCH], mm4              ;3
   por       mm1, mm2                        ;4
  psrlq      mm0, 1                          ;4
   pand      mm2, CLEARLOWBIT                ;4
  psrlq      mm2, 1                          ;4
   pand      mm1, EXTRACTLOWBIT              ;4
  movq       mm3, [ecx+5*PITCH]              ;5 mm3,mm4=left pels
   paddb     mm1, mm0                        ;4 mm5    =right pels
  movq       mm5, [ecx+5*PITCH+1]            ;5 mm4    =interp pels
   paddb     mm1, mm2                        ;4
  movq       mm4, mm3                        ;5
   pand      mm3, CLEARLOWBIT                ;5
  movq       [edx+4*PITCH], mm1              ;4
   por       mm4, mm5                        ;5
  psrlq      mm3, 1                          ;5
   pand      mm5, CLEARLOWBIT                ;5
  psrlq      mm5, 1                          ;5
   pand      mm4, EXTRACTLOWBIT              ;5
  movq       mm0, [ecx+6*PITCH]              ;6 mm0,mm1=left pels
   paddb     mm4, mm3                        ;5 mm2    =right pels
  movq       mm2, [ecx+6*PITCH+1]            ;6 mm1    =interp pels
   paddb     mm4, mm5                        ;5
  movq       mm1, mm0                        ;6
   pand      mm0, CLEARLOWBIT                ;6
  movq       [edx+5*PITCH], mm4              ;5
   por       mm1, mm2                        ;6
  psrlq      mm0, 1                          ;6
   pand      mm2, CLEARLOWBIT                ;6
  psrlq      mm2, 1                          ;6
   pand      mm1, EXTRACTLOWBIT              ;6
  movq       mm3, [ecx+7*PITCH]              ;7 mm3,mm4=left pels
   paddb     mm1, mm0                        ;6 mm5    =right pels
  movq       mm5, [ecx+7*PITCH+1]            ;7 mm4    =interp pels
   paddb     mm1, mm2                        ;6
  movq       mm4, mm3                        ;7
   pand      mm3, CLEARLOWBIT                ;7
  por        mm4, mm5                        ;7
   psrlq     mm3, 1                          ;7
  pand       mm4, EXTRACTLOWBIT              ;7
   pand      mm5, CLEARLOWBIT                ;7
  psrlq      mm5, 1                          ;7
   paddb     mm4, mm3                        ;7
  movq       [edx+6*PITCH], mm1              ;6
   paddb     mm4, mm5                        ;7
  ;
   ;
  movq       [edx+7*PITCH], mm4              ;7
   ret
  EXTRACTLOWBIT TEXTEQU <>
  CLEARLOWBIT   TEXTEQU <>
@MMX_Interpolate_Half_Int@8 endp


;  @MMX_Interpolate_Half_Half
;    This routine computes interpolated pels shown by 'X' for a an 8x8 block
;    of pels.  'x' is computed by the formula (A+B+C+D+2)/4.  The input and
;    output pitch is assumed to be 384 (PITCH).
;      A   B
;        X
;      C   D
;    The value (A+B+C+D+2)/4 is computed as (A'+B'+C'+D')+((A*+B*+C*+D*+2)/4)
;    where A = 4*A' + A*, etc.
;  Parameters:
;    The source block parameter should be in ecx and the destination block
;    parameter should be in edx; i.e. it uses fastcall calling convention.
;  Performance:
;    84  cycles ignoring unaligned memory accesses
;    138 cycles if all loads are unaligned (84+9*2*3); stores should always be
;    aligned.  Average cycle count will be less than 138.
ALIGN 4
@MMX_Interpolate_Half_Half@8 proc
  EXTRACTLOWBITS TEXTEQU <mm6>
  CLEARLOWBITS   TEXTEQU <mm7>
  movq       mm0, [ecx]                      ;0   A(mm0,mm1)  B(mm4,mm5)
   ;                                                     0
  movq       mm7, CfcfcfcfcfcfcfcfcH         ;    C(mm2,mm3)  D(mm4,mm5)
   movq      mm1, mm0                        ;0
  movq       mm4, [ecx+1]                    ;0
   pand      mm0, CLEARLOWBITS               ;0
  movq       mm6, C0303030303030303H         ;
   movq      mm5, mm4                        ;0
  pand       mm4, CLEARLOWBITS               ;0
   pand      mm1, EXTRACTLOWBITS             ;0
  psrlq      mm0, 2                          ;0
   pand      mm5, EXTRACTLOWBITS             ;0
  psrlq      mm4, 2                          ;0
   paddb     mm1, mm5                        ;0 (A+B) low
  movq       mm2, [ecx+1*PITCH]              ;0
   paddb     mm0, mm4                        ;0 (A+B)/4 high
  movq       mm4, [ecx+1*PITCH+1]            ;0
   movq      mm3, mm2                        ;0
  pand       mm3, EXTRACTLOWBITS             ;0
   movq      mm5, mm4                        ;0
  pand       mm5, EXTRACTLOWBITS             ;0
   pand      mm2, CLEARLOWBITS               ;0
  pand       mm4, CLEARLOWBITS               ;0
   paddb     mm3, mm5                        ;0 (C+D) low
  paddb      mm3, TWO                        ;0 (C+D+2) low = mm3
   psrlq     mm2, 2                          ;0
  paddb      mm1, mm3                        ;0 (A+B+C+D+2) low
   psrlq     mm4, 2                          ;0
  paddb      mm2, mm4                        ;0 (C+D)/4 high = mm2
   psrlq     mm1, 2                          ;0 (A+B+C+D+2)/4 low dirty
  paddb      mm0, mm2                        ;0 (A+B+C+D)/4 high
   pand      mm1, EXTRACTLOWBITS             ;0 (A+B+C+D+2)/4 low clean
  movq       mm4, [ecx+2*PITCH]              ;1   high(mm2)   low(mm3)
   paddb     mm0, mm1                        ;0	         1
  movq       mm1, [ecx+2*PITCH+1]            ;1   C(mm4,mm5)  D(mm0,mm1)
   movq      mm5, mm4                        ;1
  movq       [edx], mm0                      ;0
   movq      mm0, mm1                        ;1
  pand       mm0, CLEARLOWBITS               ;1
   pand      mm4, CLEARLOWBITS               ;1
  psrlq      mm0, 2                          ;1
   pand      mm1, EXTRACTLOWBITS             ;1
  psrlq      mm4, 2                          ;1
   pand      mm5, EXTRACTLOWBITS             ;1
  paddb      mm0, mm4                        ;1 (C+D)/4 high = mm0
   paddb     mm1, mm5                        ;1 (C+D) low
  paddb      mm2, mm0                        ;1 (A+B+C+D)/4 high
   paddb     mm3, mm1                        ;1 (A+B+C+D+2) low
  movq       mm4, [ecx+3*PITCH]              ;2
   psrlq     mm3, 2                          ;1 (A+B+C+D+2)/4 low dirty
  movq       mm5, mm4                        ;2   high(mm0)   low(mm1)
   pand      mm3, EXTRACTLOWBITS             ;1	         2
  paddb      mm2, mm3                        ;1	  C(mm4,mm5)  D(mm2,mm3)
   pand      mm5, EXTRACTLOWBITS             ;2
  movq       mm3, [ecx+3*PITCH+1]            ;2
   pand      mm4, CLEARLOWBITS               ;2
  movq       [edx+1*PITCH], mm2              ;1
   movq      mm2, mm3                        ;2
  pand       mm3, EXTRACTLOWBITS             ;2
   pand      mm2, CLEARLOWBITS               ;2
  psrlq      mm4, 2                          ;2
   paddb     mm3, mm5                        ;2
  paddb      mm3, TWO                        ;2 (C+D+2) low = mm3
   psrlq     mm2, 2                          ;2
  paddb      mm1, mm3                        ;2 (A+B+C+D+2) low
   paddb     mm2, mm4                        ;2 (C+D)/4 hign = mm2
  psrlq      mm1, 2                          ;2 (A+B+C+D+2)/4 low dirty
   paddb     mm0, mm2                        ;2 (A+B+C+D)/4 high
  movq       mm4, [ecx+4*PITCH]              ;3   high(mm2)   low(mm3)
   pand      mm1, EXTRACTLOWBITS             ;2	         3
  movq       mm5, mm4                        ;3	  C(mm4,mm5)  D(mm0,mm1)
   paddb     mm0, mm1                        ;2
  movq       mm1, [ecx+4*PITCH+1]            ;3
   pand      mm4, CLEARLOWBITS               ;3
  movq       [edx+2*PITCH], mm0              ;2
   movq      mm0, mm1                        ;3
  pand       mm0, CLEARLOWBITS               ;3
   pand      mm1, EXTRACTLOWBITS             ;3
  psrlq      mm0, 2                          ;3
   pand      mm5, EXTRACTLOWBITS             ;3
  psrlq      mm4, 2                          ;3
   paddb     mm1, mm5                        ;3 (C+D) low = mm1
  paddb      mm0, mm4                        ;3 (C+D)/4 high = mm0
   paddb     mm3, mm1                        ;3 (A+B+C+D+2) low
  paddb      mm2, mm0                        ;3 (A+B+C+D)/4 high
   psrlq     mm3, 2                          ;3 (A+B+C+D+2)/4 low dirty
  movq       mm4, [ecx+5*PITCH]              ;4
   pand      mm3, EXTRACTLOWBITS             ;3 (A+B+C+D+2)/4 low clean
  movq       mm5, mm4                        ;4
   paddb     mm2, mm3                        ;3   high(mm0)   low(mm1)
  movq       mm3, [ecx+5*PITCH+1]            ;4	         4
   pand      mm4, CLEARLOWBITS               ;4	  C(mm4,mm5)  D(mm2,mm3)
  movq       [edx+3*PITCH], mm2              ;3
   movq      mm2, mm3                        ;4
  pand       mm2, CLEARLOWBITS               ;4
   pand      mm5, EXTRACTLOWBITS             ;4
  psrlq      mm4, 2                          ;4
   pand      mm3, EXTRACTLOWBITS             ;4
  psrlq      mm2, 2                          ;4
   paddb     mm3, mm5                        ;4
  paddb      mm3, TWO                        ;4 (C+D+2) low  = mm3
   paddb     mm2, mm4                        ;4 (C+D)/4 high = mm2
  paddb      mm1, mm3                        ;4 (A+B+C+D+2) low
   paddb     mm0, mm2                        ;4 (A+B+C+D)/4 high
  movq       mm4, [ecx+6*PITCH]              ;5
   psrlq     mm1, 2                          ;4 (A+B+C+D+2)/4 low dirty
  movq       mm5, mm4                        ;5
   pand      mm1, EXTRACTLOWBITS             ;4 (A+B+C+D+2)/4 low clean
  paddb      mm0, mm1                        ;4
   pand      mm4, CLEARLOWBITS               ;5   high(mm2)   low(mm3)
  movq       mm1, [ecx+6*PITCH+1]            ;5	         5
   psrlq     mm4, 2                          ;5	  C(mm4,mm5)  D(mm0,mm1)
  movq       [edx+4*PITCH], mm0              ;4
   movq      mm0, mm1                        ;5
  pand       mm1, EXTRACTLOWBITS             ;5
   pand      mm5, EXTRACTLOWBITS             ;5
  pand       mm0, CLEARLOWBITS               ;5
   paddb     mm1, mm5                        ;5 (C+D) low = mm1
  psrlq      mm0, 2                          ;5
   paddb     mm3, mm1                        ;5 (A+B+C+D+2) low
  psrlq      mm3, 2                          ;5 (A+B+C+D+2)/4 low dirty
   paddb     mm0, mm4                        ;5 (C+D)/4 high = mm0
  pand       mm3, EXTRACTLOWBITS             ;5 (A+B+C+D+2)/4 low clean
   paddb     mm2, mm0                        ;5 (A+B+C+D)/4 high
  movq       mm4, [ecx+7*PITCH]              ;6   high(mm0)   low(mm1)
   paddb     mm2, mm3                        ;5	         6
  movq       mm3, [ecx+7*PITCH+1]            ;6	  C(mm4,mm5)  D(mm2,mm3)
   movq      mm5, mm4                        ;6
  movq       [edx+5*PITCH], mm2              ;5
   movq      mm2, mm3                        ;6
  pand       mm5, EXTRACTLOWBITS             ;6
   pand      mm3, EXTRACTLOWBITS             ;6
  pand       mm2, CLEARLOWBITS               ;6
   paddb     mm3, mm5                        ;6
  pand       mm4, CLEARLOWBITS               ;6
   psrlq     mm2, 2                          ;6
  paddb      mm3, TWO                        ;6 (C+D+2) low = mm3
   psrlq     mm4, 2                          ;6
  paddb      mm2, mm4                        ;6 (C+D)/4 high = mm2
   paddb     mm1, mm3                        ;6 (A+B+C+D+2) low
  paddb      mm0, mm2                        ;6 (A+B+C+D)/4 high
   psrlq     mm1, 2                          ;6 (A+B+C+D+2)/4 low dirty
  movq       mm4, [ecx+8*PITCH]              ;7   high(mm2)   low(mm3)
   pand      mm1, EXTRACTLOWBITS             ;6	         7
  movq       mm5, mm4                        ;7	  C(mm4,mm5)  D(mm0,mm1)
   paddb     mm0, mm1                        ;6
  movq       mm1, [ecx+8*PITCH+1]            ;7
   pand      mm4, CLEARLOWBITS               ;7
  movq       [edx+6*PITCH], mm0              ;6
   movq      mm0, mm1                        ;7
  pand       mm0, CLEARLOWBITS               ;7
   pand      mm5, EXTRACTLOWBITS             ;7
  psrlq      mm4, 2                          ;7
   pand      mm1, EXTRACTLOWBITS             ;7
  psrlq      mm0, 2                          ;7
   paddb     mm1, mm5                        ;7 (C+D) low
  paddb      mm0, mm4                        ;7 (C+D)/4 high
   paddb     mm3, mm1                        ;7 (A+B+C+D+2) low
  psrlq      mm3, 2                          ;7 (A+B+C+D+2)/4 low dirty
   paddb     mm2, mm0                        ;7 (A+B+C+D)/4 high
  pand       mm3, EXTRACTLOWBITS             ;7 (A+B+C+D+2)/4 low clean
   ;
  paddb      mm2, mm3                        ;7
   ;
  ;
   ;
  movq       [edx+7*PITCH], mm2              ;7
   ret
  EXTRACTLOWBITS TEXTEQU <>
  CLEARLOWBITS   TEXTEQU <>
@MMX_Interpolate_Half_Half@8 endp

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3dctc.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3dctc.inv   1.2   27 Dec 1995 15:32:58   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCDCTC_INC_
ELSE
_ENCDCTC_INC = 1

;
; Field offsets for DCT coefficients for the H26x encoder.
;

T_CoeffBlk STRUCT
  UNION
    C50C52      DWORD ?   ;    0
    BlockAddr   DWORD ?   ;    0
  ENDS
  UNION
    C00C02        DWORD ?  ;   4
    LinesDefined  BYTE  ?  ;   4
  ENDS
  UNION
    C10C12        DWORD ?  ;   8
    Cols03Defined DWORD ?  ;   8
  ENDS
  UNION
    C30C32        DWORD ?  ;  12
    Cols47Defined DWORD ?  ;  12
  ENDS
  C20C22      DWORD ?   ;   16
  C40C42      DWORD ?   ;   20
  C60C62      DWORD ?   ;   24
  C70C72      DWORD ?   ;   28
  C51C53      DWORD ?   ;   32
  C01C03      DWORD ?   ;   36
  C31C33      DWORD ?   ;   40
  C11C13      DWORD ?   ;   44
  C21C23      DWORD ?   ;   48
  C41C43      DWORD ?   ;   52
  C61C63      DWORD ?   ;   56
  C71C73      DWORD ?   ;   60
  C54C56      DWORD ?   ;   64
  C04C06      DWORD ?   ;   68
  C14C16      DWORD ?   ;   72
  C34C36      DWORD ?   ;   76
  C24C26      DWORD ?   ;   80
  C44C46      DWORD ?   ;   84
  C64C66      DWORD ?   ;   88
  C74C76      DWORD ?   ;   92
  C57C55      DWORD ?   ;   96
  C07C05      DWORD ?   ;  100
  C17C15      DWORD ?   ;  104
  C37C35      DWORD ?   ;  108
  C27C25      DWORD ?   ;  112
  C47C45      DWORD ?   ;  116
  C67C65      DWORD ?   ;  120
  C77C75      DWORD ?   ;  124
T_CoeffBlk ENDS


ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3inst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3inst.inv   1.6   27 Dec 1995 15:33:00   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCINST_INC_
ELSE
_ENCINST_INC = 1

;
; Global definitions for the H26x encoder.
;
;

PITCH = 384     ; Pitch for each plane
VOFFSET = 192   ; Dist from U to corresponding V

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3mbad.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3mbad.inv   1.10   04 Oct 1996 08:47:58   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\e3mbad.inv  $
;// 
;//    Rev 1.10   04 Oct 1996 08:47:58   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.9   14 May 1996 12:18:46   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.8   02 May 1996 13:41:08   BNICKERS
;// started integration of MMX PB-frames
;// 
;//    Rev 1.7   22 Feb 1996 15:02:38   BNICKERS
;// Add unionized field for MMx implementation.
;// 
;//    Rev 1.6   22 Jan 1996 17:13:44   BNICKERS
;// Add MBEdgeType to MacroBlock Action Descriptor.
;// 
;//    Rev 1.5   27 Dec 1995 15:33:00   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENDMBAD_INC_
ELSE
_ENDMBAD_INC = 1

;
; Fields for MacroBlock Action Stream Descriptors for the H26x encoder.
;


T_Blk STRUCT
  BlkOffset         DWORD ? ;  0  -- Offset from upper left viewable pel of Y
                            ;        plane to upper left pel of block.
  UNION
    PastRef         DWORD ? ;  4  -- Addr of 8*8 reference block, passed from
                            ;        P-Frame ME to P-Frame frame differencing.
    STRUCT
      CandidateHMVf BYTE ?  ;  4  -- Scratch area for figuring BestHMVf values.
      CandidateVMVf BYTE ?  ;  5  -- Must be 4 bytes after Best...
      CandidateHMVb BYTE ?  ;  6
      CandidateVMVb BYTE ?  ;  7
    ENDS
    CandidateBiDiMVs DWORD ? ; 4
  ENDS
  UNION
    STRUCT
      BestHMVf      BYTE ?  ;  8  -- "Real" MVs for B-Frame block, passed from
      BestVMVf      BYTE ?  ;  9  -- B-Frame ME to P-Frame frame differencing.
      BestHMVb      BYTE ?  ; 10  -- (Biased by 060H)
      BestVMVb      BYTE ?  ; 11
    ENDS
    BestBiDiMVs     DWORD ? ;  8
  ENDS
  UNION
    STRUCT
      PHMV        BYTE  ?   ; 12  -- Horz motion vector for P frame ref blk.
      PVMV        BYTE  ?   ; 13  -- Vert motion vector for P frame ref blk.
      BHMV        BYTE  ?   ; 14  -- Horz motion vector adjustment for B frm.
      BVMV        BYTE  ?   ; 15  -- Vert motion vector adjustment for B frame.
    ENDS
    MVs           DWORD ?   ; 12
  ENDS
T_Blk ENDS

; Symbolic offsets for MMx version:

T_MacroBlockActionDescr STRUCT 
  BlockType     BYTE  ? ;  0  -- See Block Types below.
  MBEdgeType    BYTE  ? ;  1  -- 1 left | 2 right | 4 top | 8 bottom
  Unassigned1   BYTE  ?
  FirstMEState  BYTE  ? ;  3  -- First State Num for Motion Estimation engine.
  UNION
    STRUCT
      CodedBlocks   BYTE  ? ;  4  -- [6] End-Of-Stream indicator
                            ;        [0] indicates Y1 non-empty.
                            ;        [1..5] indicate Y2, Y3, Y4, U, V non-empty.
                            ;        Other bits zero.
      CodedBlocksB  BYTE  ? ;  5  -- [0..5] like CodedBlocks, but for B frame.
                            ;        Set 0 for non-bi-di prediction.
      BestFullPelMBHMV BYTE ? ; 6 -- Best full pel HMV at macroblock level.
      BestFullPelMBVMV BYTE ? ; 7 -- Best full pel VMV at macroblock level.
    ENDS
    BestFullPelMBMVs DWORD ? ; 4
  ENDS
  SWD           DWORD ? ;  8  -- Sum of weighted diffs, from motion estimation.
  SWDB          DWORD ? ; 12  -- Sum of weighted diffs, from ME for B frame.
  BlkY1         T_Blk { }
  Blk           EQU       BlkY1
  BlkY2         T_Blk { }
  BlkY3         T_Blk { }
  BlkY4         T_Blk { }
  BlkU          T_Blk { }
  BlkV          T_Blk { }
  Unassigned4	BYTE  16 DUP (?) ; pad out 16 bytes to 128 bytes total to match C struct
T_MacroBlockActionDescr ENDS
T_MBAD TEXTEQU <T_MacroBlockActionDescr>

IF SIZEOF T_MacroBlockActionDescr-128
**** Size of T_MacroBlockActionDescr MUST BE a power of 2 bytes long.
ENDIF

IF 3*SIZEOF T_MBAD-PITCH
  **** Next instr works if PITCH==384 and SizeOf T_MacroBlockActionDescr==128.
  **** Here and throughout this file.
ELSE
BlkLvlSWD       TEXTEQU <BestBiDiMVs>
CandBlkLvlSWD   TEXTEQU <[CONST_384*1-128+CandidateBiDiMVs]>
BestBlkLvlSWD   TEXTEQU <[CONST_384*1-128+BestBiDiMVs]>
BlkLvlSWD0Delta TEXTEQU <[CONST_384*1-128+MVs]>
CandBiDiMVs     TEXTEQU <[CONST_384*1+CandidateBiDiMVs]>
CandHMVf        TEXTEQU <[CONST_384*1+CandidateHMVf]>
CandVMVf        TEXTEQU <[CONST_384*1+CandidateVMVf]>
CandHMVb        TEXTEQU <[CONST_384*1+CandidateHMVb]>
CandVMVb        TEXTEQU <[CONST_384*1+CandidateVMVb]>
BiDiMVs0Delta   TEXTEQU <[CONST_384*1+BestBiDiMVs]>
HMVf0Delta      TEXTEQU <[CONST_384*1+BestHMVf]>
VMVf0Delta      TEXTEQU <[CONST_384*1+BestVMVf]>
HMVb0Delta      TEXTEQU <[CONST_384*1+BestHMVb]>
VMVb0Delta      TEXTEQU <[CONST_384*1+BestVMVb]>
ENDIF

; Memory layout constraints:
;
; T_MacroBlockActionDescr structure must be 16-byte aligned.
; Each T_Blk structure must be 16-byte aligned.
; FirstMEState must be 3rd byte of a DWORD.
; CodedBlocks must be DWORD aligned.
; CodedBlocksB must be CodedBlocks plus one.
; CodedBlocks & CodedBlocksB should be in different memory bank than BlockType.
; Offset must be 16-byte aligned.
; PastRef must be at Targ plus four.
; Candidate MVs must be at DWORD before Best MVs.  MVs must be in order given.
;

; Block Types
;
;  Only INTER, INTRA, and INTERSLF used for H261.
;  Only INTER1MV, INTRA, INTER4MV used presently for H263.

INTER1MV  = 0
INTER     = INTER1MV
INTRA     = 1
INTERBIDI = 2
INTRABIDI = 3
INTER4MV  = 4
INTERSLF  = 2

IsINTRA   = 1  ; Mask to check for INTRA or INTER
IsBIDI    = 2  ; Mask to check for BIDI or not
Is4MV     = 4  ; Mask to check for 4 motion vectors or just 1.

LeftEdge   = 1 ; Mask to indicate MB is at left edge of picture.
RightEdge  = 2 ; Mask to indicate MB is at right edge of picture.
TopEdge    = 4 ; Mask to indicate MB is at top edge of picture.
BottomEdge = 8 ; Mask to indicate MB is at bottom edge of picture.
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e35bme.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e35bme.asv   1.10   29 May 1996 15:37:38   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\e35bme.asv  $
;// 
;//    Rev 1.10   29 May 1996 15:37:38   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.9   14 May 1996 12:18:18   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.8   09 Jan 1996 16:14:46   BNICKERS
;// Avoid generating delta MV's that make B frame MV's out of range.
;// 
;//    Rev 1.7   27 Dec 1995 15:32:34   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////
;
; BFrameMotionEstimation -- This function performs B frame motion estimation for the macroblocks identified in the
;                           input list.  This is only applicable for H263.  This version is tuned for best performance
;                           on the Pentium Microprocessor.
;
;                           This function works correctly only if Unrestricted Motion Vectors is enabled.  It is not
;                           possible to select full pel resolution only;  half pel resolution is always selected.
;
; Input Arguments:
;
;   MBlockActionStream
;
;     The list of macroblocks for which we need to perform motion estimation.
;
;     Upon input, the following fields must be defined:
;
;       CodedBlocks -- Bit 6 must be set for the last macroblock to be processed.
;
;       BlkOffset -- must be defined for each of the blocks in the macroblocks.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.
;
;   PreviousFrameBaseAddress -- Address of upper left viewable pel in the Y plane of the previous P frame.  Whether this
;                               is the reconstructed previous frame, or the original, is up to the caller to decide.
;
;   FutureFrameBaseAddress -- Address of upper left viewable pel in the Y plane of the future P frame.  Whether this
;                             is the reconstructed previous frame, or the original, is up to the caller to decide.
;
;   WeightForwardMotion -- Array of 64 signed chars, each element I equal to ((TRb * (I-32)) / TRd).  (See H263 spec.)
;
;   WeightBackwardMotion -- Array of 64 signed chars, each element I equal to ((TRb - TRd) * (I-32) / TRd).  (See spec.)
;
;   ZeroVectorThreshold -- If the SWDB for a macroblock is less than this threshold, we do not bother searching for a
;                          better motion vector.  Compute as follows, where D is the average tolerable pel difference
;                          to satisfy this threshold.  (Initial recommendation:  D=2  ==> ZVT=384)
;                             ZVT = (128 * ((int)((D**1.6)+.5)))
;
;   NonZeroDifferential -- After searching for the best motion vector (or individual block motion vectors, if enabled),
;                          if the macroblock's SWDB is not better than it was for the zero vector -- not better by at
;                          least this amount -- then we revert to the zero vector.  We are comparing two macroblock
;                          SWDs, both calculated as follows:   (Initial recommendation:	 NZD=128)
;                            For each of 128 match points, where D is its Abs Diff, accumulate ((int)(M**1.6)+.5)))
;
;   EmptyThreshold -- If the SWD for a block is less than this, the block is forced empty.  Compute as follows, where D
;                     is the average tolerable pel diff to satisfy threshold.  (Initial recommendation:  D=3 ==> ET=96)
;                        ET = (32 * ((int)((D**1.6)+.5)))
;
; Output Arguments
;
;   MBlockActionStream
;
;     These fields are defined as follows upon return:
;
;       BHMV and BVMV -- The horizontal and vertical motion vectors,  in units of a half pel.  These values are intended
;                        for coding in the macroblock layer.
;
;                  If Horizontal MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+1.
;
;                  If Vertical MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+PITCH.
;
;                  If both MVs indicate half pel positions, the prediction for the upper left pel of the block is the
;                  average of the pels at PastRef, PastRef+1, PastRef+PITCH, and PastRef+PITCH+1.
;
;       BestHMVf, BestVMVf, BestHMVb, BestVMVb -- Motion vector components, as described in H263 spec.  They are biased
;                                                 by 060H.  Only defined for luma blocks.  Caller must define for
;                                                 chroma blocks.
;
;       CandidateHMVf, CandidateVMVf, CandidateHMVb, CandidateVMVb -- Scratch space for this function.
;
;       CodedBlocksB -- Bits 4 and 5 are turned on, indicating that the U and V blocks should be processed.  (If the
;                       FDCT function finds them to quantize to empty, it will mark them as empty.)
;
;                       Bits 0 thru 3 are cleared for each of blocks 1 thru 4 that BFrameMotionEstimation forces empty;
;                       they are set otherwise.
;
;                       Bits 6 and 7 are left unchanged.
;                      
;       SWDB -- Set to the sum of the SWDBs for the four luma blocks in the macroblock.  The SWD for any block that is
;               forced empty, is NOT included in the sum.
;
;   InterSWDTotal  -- The sum of the block SWDBs for all Intercoded macroblocks.  None of the blocks forced empty are
;                     included in this.
;
;   InterSWDBlocks -- The number of blocks that make up the InterSWDTotal.
;
;
; Other assumptions:
;
;   For performance reasons, it is assumed that the current and previous frame are 32-byte aligned, and the pitch is a
;   constant 384.  Moreover, the current and previous frames must be out of phase by 2K bytes, i.e.  must be an odd
;   multiple of 2K bytes apart.  This will assure best utilization of the on-chip cache.
;
; Many of the techniques described in MotionEstimation are used here.  It is wise to study that module before trying
;to understand this one.
;
; Data structures used for bi-directional motion search:
;
;  Target Macroblock:
;
;     The target macroblock is copied to the stack frame so that esp can be used as an induction variable for the block:
;
;     esp+   0  AAAABBBB        AAAABBBB        AAAABBBB        AAAABBBB
;     esp+  64  CCCCDDDDEEEEFFFFCCCCDDDDEEEEFFFFCCCCDDDDEEEEFFFFCCCCDDDDEEEEFFFF
;     esp+ 128  LLLLDDDDLLLLLLLLLLLLLLLLLLLLLLLL
;     esp+ 160  +------++------++------++------++------++------++------++------+
;     esp+ 224  | Blk1 || Blk1 || Blk2 || Blk2 || Blk3 || Blk3 || Blk4 || Blk4 |
;     esp+ 288  |Ln 0-3||Ln 4-7||Ln 0-3||Ln 4-7||Ln 0-3||Ln 4-7||Ln 0-3||Ln 4-7|
;     esp+ 352  +------++------++------++------++------++------++------++------+
;     esp+ 416
;
;     AAAA is the address of the Future Reference Block to be used.
;     BBBB is the address of the Past Reference Block to be used.
;         AAAA, BBBB, and the next 8 bytes are overwritten by the offset to apply when interpolating future ref block or
;         past ref block.
;     CCCC is the accumulated SWD for the current candidate motion vector.
;     DDDD is the accumulated SWD for the best motion vector so far.
;          One extra DDDD occupies esp+132.
;     EEEE is the address at which to transfer control after calculating SWD.
;     FFFF is the accumulated SWD for the zero motion vector.
;     LLLL is space for local variables.
;
;   Future reference:
;
;     For each macroblock, the corresponding macroblock from the future frame is copied into the following reference
;     area, wherein all the X's are bytes initialized to 255.  When the projection of the B-frame's future motion
;     vector component falls on a byte valued at 255, we know that it is outside the future macroblock, and thus this
;     is a pel that is only predicted from the past reference.
;
;     esp+ 704    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  \
;     esp+ 744    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \
;     esp+ 784    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    \ 
;     esp+ 824    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     \
;     esp+ 864    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \
;     esp+ 904    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       > Rarely used
;     esp+ 944    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      /
;     esp+ 984    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     /
;     esp+1024    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    /
;     esp+1064    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   /
;     esp+1104    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  /
;     esp+1144    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1184    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1224    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1264    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1304    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1344    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1384    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1424    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1464    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1504    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1544    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1584    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+1624    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+1664    XXXXXXXXXXXXXXXXXXXXXXXX|Future||Future|
;     esp+1704    XXXXXXXXXXXXXXXXXXXXXXXX| Ref  || Ref  |
;     esp+1744    XXXXXXXXXXXXXXXXXXXXXXXX| Blk  || Blk  |
;     esp+1784    XXXXXXXXXXXXXXXXXXXXXXXX|  1   ||  2   |
;     esp+1824    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+1864    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+1904    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+1944    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+1984    XXXXXXXXXXXXXXXXXXXXXXXX|Future||Future|
;     esp+2024    XXXXXXXXXXXXXXXXXXXXXXXX| Ref  || Ref  |
;     esp+2064    XXXXXXXXXXXXXXXXXXXXXXXX| Blk  || Blk  |
;     esp+2104    XXXXXXXXXXXXXXXXXXXXXXXX|  3   ||  4   |
;     esp+2144    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+2184    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+2224    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2264    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2304    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2344    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2384    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2424    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2464    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2504    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2544    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2584    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2624    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2664    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  \
;     esp+2704    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \
;     esp+2744    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    \
;     esp+2784    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     \
;     esp+2824    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \
;     esp+2864    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       > Rarely used
;     esp+2904    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      /
;     esp+2944    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     /
;     esp+2984    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    /
;     esp+3024    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   /
;     esp+3064    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  /
;     esp+3104    XXXXXXXXXXXXXXXXXXXXXXXX________         /
;     esp+3136
;
;  Past Reference:
;
;     The past reference search area is taken directly from the past frame.  It is not necessary to copy any portion
;     of the past frame to a scratch area.
;
;
; Memory layout of the target macroblock, the future reference macroblock, and the full range for the reference area
; (as restricted to +/- 7 in vertical, and +/- 7 (expandable to +/- 15) in horizontal, is as shown here.  Each box
; represents a cache line (32 bytes), increasing incrementally from left to right, and then to the next row (like
; reading a book).  The 128 boxes taken as a whole represent 4Kbytes.  The boxes are populated as follows:
;
;   R -- Data from the past reference area.  Each box contains 23 of the pels belonging to a line of the reference
;   area.  The remaining 7 pels of the line is either in the box to the left (for reference areas used to provide
;   predictions for target macroblocks that begin at an address 0-mod-32), or to the right (for target MBs that begin
;   at an address 16-mod-32).  There are 30 R's corresponding to the 30-line limit on the vertical distance we might
;   search.  The lowercase r's correspond to the lines above and below zero-vertical-motion.
;
;   F -- Data from the future reference area.  Eacg box contains a full line (16 pels) for each of two adjacent
;   macroblocks.  There are 16 F's corresponding to the 16 lines of the macroblocks.
; 
;   T -- Data from the target macroblock.  Each box contains a full line (16 pels) for each of two adjacent
;   macroblocks.  There are 16 C's corresponding to the 16 lines of the macroblocks.
;
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | F |   | R |   |
;      +---+---+---+---+---+---+---+---+
;
; Thus, in a logical sense, the above data fits into one of the 4K data cache pages, leaving the other for all other
; data.  Care has been taken to assure that the tables and the stack space needed by this function fit nicely into
; the other data cache page.    Only the MBlockActionStream remains to conflict with the above data structures.  That
; is both unavoidable, and of minimal consequence.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list
.DATA

LocalStorage LABEL DWORD  ; Local storage goes on the stack at addresses whose lower 12 bits match this address.

DB 544 DUP (?)   ; Low 12 bits match those of heavily used part of stack frame.

SWDState LABEL BYTE  ; State engine rules for finding best motion vector.

; 1st number:  Horizontal Motion displacement to try, in half pel increments.
; 2nd number:  Vertical Motion displacement to try, in half pel increments.
; 3rd number:  Next state to enter if this motion is better than previous best.
; 4th number:  Next state to enter if previous best is still best.

   DB    -2,   0,  8,  4   ;  0 -- ( 0, 0) Try (-2, 0)
   DB     2,   0, 12, 12   ;  4 -- ( 0, 0) Try ( 2, 0)
   DB     4,   0, 12, 12   ;  8 -- (-2, 0) Try ( 2, 0)
   DB     0,  -2, 20, 16   ; 12 -- ( N, 0) Try ( N,-2)  (N = {-2,0,2})
   DB     0,   2, 24, 24   ; 16 -- ( N, 0) Try ( N, 2)
   DB     0,   4, 24, 24   ; 20 -- ( N,-2) Try ( N, 2)

   DB    -1,   0, 32, 28   ; 24
   DB     1,   0, 36, 36   ; 28
   DB     2,   0, 36, 36   ; 32
   DB     0,  -1, 44, 40   ; 36
   DB     0,   1,  0,  0   ; 40
   DB     0,   2,  0,  0   ; 44

   DB    48 DUP (?)        ; Additional space for more states, if needed.

DB 64 DUP (?)   ; Low 12 bits match those of heavily used part of stack frame.

InterpFutureRef LABEL BYTE  ; Map FPEL+FPEL to its average.  If one FPEL is out
                            ; of range (255), map FPEL+FPEL to 255.
CNT = 0
REPEAT 127
  DB CNT,CNT
  CNT = CNT + 1
ENDM
  DB 127
  DB 257 DUP (255)

DB 1472 DUP (?)  ; Low 12 bits match those of heavily used part of stack frame.

Interp2PastAndFutureRef LABEL BYTE  ; Map PPEL+PPEL+FPELavg*2 to 2*average.  If
                                    ; FPELavg out of range, map PPEL+PPEL to
                                    ; -(PPEL+PPEL).
CNT = 0
REPEAT 255
  DB CNT,CNT
  CNT = CNT - 1
ENDM
InterpPastAndFutureRef LABEL BYTE   ; Map PPEL+FPELavg to 2*average.  If
                                    ; FPELavg out of range, map PPEL to
                                    ; 2(PPEL).
CNT = 0
REPEAT 255
  DB CNT
  CNT = CNT + 1
ENDM
CNT = 0
REPEAT 128
  DB CNT
  CNT = CNT + 2
ENDM
  DB ?,?,?
  
  DB 255
WeightedDiff LABEL BYTE  ; Label placed here because negative pel value is
                         ; not sign extended, so we need to subtract 256.
  DB 191 DUP (255)
  DB 255,250,243,237,231,225,219,213,207,201,195,189,184,178,172,167
  DB 162,156,151,146,141,135,130,126,121,116,111,107,102, 97, 93, 89
  DB  84, 80, 76, 72, 68, 64, 61, 57, 53, 50, 46, 43, 40, 37, 34, 31
  DB  28, 25, 22, 20, 18, 15, 13, 11,  9,  7,  6,  4,  3,  2,  1,  0
  DB   0
  DB   0,  1,  2,  3,  4,  6,  7,  9, 11, 13, 15, 18, 20, 22, 25, 28
  DB  31, 34, 37, 40, 43, 46, 50, 53, 57, 61, 64, 68, 72, 76, 80, 84
  DB  89, 93, 97,102,107,111,116,121,126,130,135,141,146,151,156,162
  DB 167,172,178,184,189,195,201,207,213,219,225,231,237,243,250,255
  DB 191 DUP (255)

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

BFRAMEMOTIONESTIMATION  proc C AMBAS:   DWORD,
ATFBA: DWORD,
APFBA: DWORD,
AFFBA: DWORD,
AWFM:  DWORD,
AWBM:  DWORD,
AZVT:  DWORD,
ANZMVD:DWORD,
AEBT:  DWORD,
ASWDT: DWORD,
ASWDB: DWORD

RegisterStorageSize = 16

; Arguments:

MBlockActionStream_arg       = RegisterStorageSize +  4
TargetFrameBaseAddress_arg   = RegisterStorageSize +  8
PreviousFrameBaseAddress_arg = RegisterStorageSize + 12
FutureFrameBaseAddress_arg   = RegisterStorageSize + 16
WeightForwardMotion_arg      = RegisterStorageSize + 20
WeightBackwardMotion_arg     = RegisterStorageSize + 24
ZeroVectorThreshold_arg      = RegisterStorageSize + 28
NonZeroMVDifferential_arg    = RegisterStorageSize + 32
EmptyBlockThreshold_arg      = RegisterStorageSize + 36
InterSWDTotal_arg            = RegisterStorageSize + 40
InterSWDBlocks_arg           = RegisterStorageSize + 44
EndOfArgList                 = RegisterStorageSize + 48

; Locals (on local stack frame)

; 0 thru 415 are Target MV scratch structure, described above, with room for
; 7 DWORDs of local variables.

Block1                 EQU [esp+   0]
Block2                 EQU [esp+  16]
Block3                 EQU [esp+  32]
Block4                 EQU [esp+  48]
BlockN                 EQU [esp+  64]
BlockNM1               EQU [esp+  48]

TargetBlock            EQU 160
FutureRefBlockAddr     EQU   0
PastRefBlockAddr       EQU   4
FutureRefInterpOffset  EQU FutureRefBlockAddr
CandidateSWDAccum      EQU  64
BestSWDAccum           EQU  68
SWD0MVAccum            EQU  72
TransferCase           EQU  76
TPITCH                 EQU  64

; 416 thru 479 and 640 thru 703 for weighting motion vectors.

WeightForwardMotion    EQU [esp+ 416]   ; 32 bytes at 416 for positive MV; 32
                                        ; bytes at 640 for negative MV.
WeightBackwardMotion   EQU [esp+ 448]   ; 32 bytes at 448 for positive MV; 32
                                        ; bytes at 672 for negative MV.

; 480 thru 543 are stack storage for more local variables.
; 128:131, 136:159, and 480:543 are available for local variables.

TargetFrameBaseAddress    EQU [esp+  128]
PreviousFrameBaseAddress  EQU [esp+  136]
FutureFrameBaseAddress    EQU [esp+  140]
MBlockActionStream        EQU [esp+  144]
ZeroVectorThreshold       EQU [esp+  148]
NonZeroMVDifferential     EQU [esp+  152]
EmptyBlockThreshold       EQU [esp+  156]
InterSWDTotal             EQU [esp+  480]
InterSWDBlocks            EQU [esp+  484]
StashESP                  EQU [esp+  488]
PastMBAddr                EQU [esp+  492]
CurrSWDState              EQU [esp+  496]
CandidateMV               EQU [esp+  500]
BestMV                    EQU [esp+  504]
BlkY1_0deltaBiDiMVs       EQU [esp+  508]
BlkY2_0deltaBiDiMVs       EQU [esp+  512]
BlkY3_0deltaBiDiMVs       EQU [esp+  516]
BlkY4_0deltaBiDiMVs       EQU [esp+  520]
FirstTransferCase         EQU [esp+  524]

; 544: 639 is for static data, namely the state engine rules.
; 640 thru 703, as stated above is for weighting motion vectors.

; 704 thru 1215 hit static data structure to interpolate 2 future pels.

; Future Reference Area also starts at 704 on stack, but collision at 704
; thru 1215 will occur very infrequently.  Future Reference Area continues
; thru 3135.  2688 thru 3135 collide with the static data structure to
; interpolate between past and future pels, but that portion of the Future
; Reference Area is rarely accessed.  3136 thru 3583 continue that static
; structure.  3584 thru 4095 have the static structure to look up the
; weighted difference for a target pel and it's prediction.

FutureRefArea             EQU [esp+ 704]
FutureBlock               EQU [esp+1608]
FPITCH                    EQU  40


  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov   esi,esp
   sub  esp,000001000H
  mov   ebx, [esp]
   sub  esp,000001000H
  and   esp,0FFFFF000H
   mov  ebx,OFFSET LocalStorage+63
  and   ebx,000000FC0H
   mov  edx,PD [esi+MBlockActionStream_arg]
  or    esp,ebx
   mov  eax,PD [esi+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,eax
   mov  eax,PD [esi+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,eax
   mov  eax,PD [esi+FutureFrameBaseAddress_arg]
  mov   FutureFrameBaseAddress,eax
   mov  eax,PD [esi+EmptyBlockThreshold_arg]
  mov   EmptyBlockThreshold,eax
   mov  eax,PD [esi+ZeroVectorThreshold_arg]
  mov   ZeroVectorThreshold,eax
   mov  eax,PD [esi+NonZeroMVDifferential_arg]
  mov   NonZeroMVDifferential,eax
   mov  ebx,3116
@@:
  mov   [esp+ebx],0FFFFFFFFH
   sub  ebx,4
  cmp   ebx,688
   jae  @b
  xor   ebx,ebx
   mov  StashESP,esi
  mov   edi,[esi+WeightForwardMotion_arg]
   mov  esi,[esi+WeightBackwardMotion_arg]
  mov   InterSWDBlocks,ebx
   mov  InterSWDTotal,ebx
  mov   eax,[edi]
   mov  ebx,[edi+4]
  mov   ecx,03F3F3F3FH
   mov 	ebp,060606060H
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+224,eax
   mov  WeightForwardMotion+228,ebx
  mov   eax,[edi+8]
   mov  ebx,[edi+12]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+232,eax
   mov  WeightForwardMotion+236,ebx
  mov   eax,[edi+16]
   mov  ebx,[edi+20]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+240,eax
   mov  WeightForwardMotion+244,ebx
  mov   eax,[edi+24]
   mov  ebx,[edi+28]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+248,eax
   mov  WeightForwardMotion+252,ebx
  mov   eax,[edi+32]
   mov  ebx,[edi+36]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+0,eax
   mov  WeightForwardMotion+4,ebx
  mov   eax,[edi+40]
   mov  ebx,[edi+44]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+8,eax
   mov  WeightForwardMotion+12,ebx
  mov   eax,[edi+48]
   mov  ebx,[edi+52]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+16,eax
   mov  WeightForwardMotion+20,ebx
  mov   eax,[edi+56]
   mov  ebx,[edi+60]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+24,eax
   mov  WeightForwardMotion+28,ebx
  mov   eax,[esi]
   mov  ebx,[esi+4]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+224,eax
   mov  WeightBackwardMotion+228,ebx
  mov   eax,[esi+8]
   mov  ebx,[esi+12]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+232,eax
   mov  WeightBackwardMotion+236,ebx
  mov   eax,[esi+16]
   mov  ebx,[esi+20]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+240,eax
   mov  WeightBackwardMotion+244,ebx
  mov   eax,[esi+24]
   mov  ebx,[esi+28]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+248,eax
   mov  WeightBackwardMotion+252,ebx
  mov   eax,[esi+32]
   mov  ebx,[esi+36]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+0,eax
   mov  WeightBackwardMotion+4,ebx
  mov   eax,[esi+40]
   mov  ebx,[esi+44]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+8,eax
   mov  WeightBackwardMotion+12,ebx
  mov   eax,[esi+48]
   mov  ebx,[esi+52]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+16,eax
   mov  WeightBackwardMotion+20,ebx
  mov   eax,[esi+56]
   mov  ebx,[esi+60]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+24,eax
   mov  WeightBackwardMotion+28,ebx
  jmp   FirstMacroBlock

ALIGN 16

NextMacroBlock:

  mov   bl,[edx].CodedBlocks
   add  edx,SIZEOF T_MacroBlockActionDescr
  and   ebx,000000040H                ; Check for end-of-stream
   jne  Done

FirstMacroBlock:

  mov   esi,[edx].BlkY1.BlkOffset     ; Get address of next macroblock to do.
   mov  edi,TargetFrameBaseAddress
  mov   eax,FutureFrameBaseAddress
   mov  ebp,PreviousFrameBaseAddress
  lea   edi,[esi+edi+PITCH*3]
   mov  MBlockActionStream,edx        ; Stash list ptr.
  add   ebp,esi
   lea  esi,[esi+eax+PITCH*15]
  mov   PastMBAddr,ebp                ; Stash addr of past MB w/ zero motion.
   mov  ecx,FPITCH*15
  mov   ebp,PITCH
   xor  eax,eax


@@:                                   ; Copy future reference to scratch area
                                      ; that is surrounded by "255" so we can
                                      ; handle access to this surrounding area
                                      ; as the future ref falls out of the MB.
  mov   eax,[esi]
   mov  ebx,[esi+4]
  mov   FutureBlock[ecx],eax
   mov  FutureBlock[ecx+4],ebx
  mov   eax,[esi+8]
   mov  ebx,[esi+12]
  mov   FutureBlock[ecx+8],eax
   mov  FutureBlock[ecx+12],ebx
  sub   esi,ebp
   sub  ecx,FPITCH
  lea   edx,Block1.TargetBlock
   jge  @b

  sar   ecx,31
   lea  ebx,Block1.TargetBlock+TPITCH*3
   
@@:                                   ; Copy target macroblock to scratch area
                                      ; so that we can pick up the target points
                                      ; from a static offset added to esp.  
  mov   eax,[edi]
   mov  esi,[edi+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx],eax
   mov  [ebx+16],esi
  mov   eax,[edi+ebp*4]
   mov  esi,[edi+ebp*4+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx+8],eax
   mov  [ebx+24],esi
  mov   eax,[edi+ebp*8]
   mov  esi,[edi+ebp*8+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx+32],eax
   mov  [ebx+48],esi
  mov   eax,[edi+PITCH*12]
   mov  esi,[edi+PITCH*12+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx+40],eax
   mov  [ebx+56],esi
  sub   edi,ebp
   sub  ebx,TPITCH
  cmp   ebx,edx
   jge  @b

  mov   eax,16
   lea  edi,[edi+ebp*4+4]
  test  edi,4
  lea   ebx,Block1.TargetBlock+TPITCH*3+4
   jne  @b

  mov   edx,MBlockActionStream
   xor  ebx,ebx
  mov   Block4.TransferCase,eax       ; After block 4, transfer to done 0-MV.
   xor  ecx,ecx
  mov   bl,[edx].BlkY4.PVMV
   mov  esi,PastMBAddr
  mov   al,[edx].BlkY4.PHMV
   xor  ebp,ebp
  mov   bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY4.BestVMVf,bl
  sar   ebx,1                         ; CF == 1 if past vert is at half pel.
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp                       ; ebp == 1 if past vert is at half pel.
   mov  [edx].BlkY4.BestHMVf,cl
  sar   ecx,1                         ; CF == 1 if past horz is at half pel.
IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
   lea  edi,[ebx+ebx*2]               ; Multiply vertical component by PITCH.
  adc   ebp,ebp                       ; ebp odd if past horz is at half pel.
   mov  bl,[edx].BlkY4.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH+PITCH*8+8]; Add horz full pel disp to ref addr.
  add   esi,edi                       ; Add vert full pel disp to past ref addr.
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY4.BestVMVb,bl
   mov  Block4.PastRefBlockAddr,esi   ; Stash address of ref block from past.
  sar   ebx,1                         ; CF == 1 if future vert is at half pel.
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp                       ; ebp odd if future vert is at half pel.
   mov  [edx].BlkY4.BestHMVb,al
  sar   eax,1                         ; CF == 1 if future horz is at half pel.
IF FPITCH-40
  **** The magic leaks out if FPITCH != 40
ENDIF
   lea  edi,[ebx+ebx*4]               ; Multiply vertical component by FPITCH.
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   lea  esi,FutureBlock+80-48-48*FPITCH+FPITCH*8+8
  lea   edi,[eax+edi*8]               ; Linearized MV for future ref.
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  add   esi,edi
   mov  bl,[edx].BlkY3.PVMV
  mov   Block4.FutureRefBlockAddr,esi ; Stash address of ref block from future.
   mov  al,[edx].BlkY3.PHMV
  mov   esi,PastMBAddr
   mov  bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY3.BestVMVf,bl
   xor  ebp,ebp
  sar   ebx,1
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY3.BestHMVf,cl
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[edx].BlkY3.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH+PITCH*8]
  add   esi,edi
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY3.BestVMVb,bl
   mov  Block3.PastRefBlockAddr,esi
  sar   ebx,1
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY3.BestHMVb,al
  sar   eax,1
   lea  edi,[ebx+ebx*4]
  adc   ebp,ebp
   lea  esi,FutureBlock+80-48-48*FPITCH+FPITCH*8
  lea   edi,[eax+edi*8]
   mov  Block2.TransferCase,ebp
  add   esi,edi
   mov  bl,[edx].BlkY2.PVMV
  mov   Block3.FutureRefBlockAddr,esi
   mov  al,[edx].BlkY2.PHMV
  mov   esi,PastMBAddr
   mov  bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY2.BestVMVf,bl
   xor  ebp,ebp
  sar   ebx,1
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY2.BestHMVf,cl
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[edx].BlkY2.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH+8]
  add   esi,edi
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY2.BestVMVb,bl
   mov  Block2.PastRefBlockAddr,esi
  sar   ebx,1
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY2.BestHMVb,al
  sar   eax,1
   lea  edi,[ebx+ebx*4]
  adc   ebp,ebp
   lea  esi,FutureBlock+80-48-48*FPITCH+8
  lea   edi,[eax+edi*8]
   mov  Block1.TransferCase,ebp
  add   esi,edi
   mov  bl,[edx].BlkY1.PVMV
  mov   Block2.FutureRefBlockAddr,esi
   mov  al,[edx].BlkY1.PHMV
  mov   esi,PastMBAddr
   mov  bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY1.BestVMVf,bl
   xor  ebp,ebp
  sar   ebx,1
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY1.BestHMVf,cl
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[edx].BlkY1.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH]
  add   esi,edi
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY1.BestVMVb,bl
   mov  Block1.PastRefBlockAddr,esi
  sar   ebx,1
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY1.BestHMVb,al
  sar   eax,1
   lea  ecx,[ebx+ebx*4]
  adc   ebp,ebp
   lea  edi,FutureBlock+80-48-48*FPITCH
  lea   ecx,[eax+ecx*8]
   mov  eax,ebp
  add   edi,ecx
   mov  ebp,00BADBEEFH
  mov   Block1.BestSWDAccum,ebp
   mov  Block2.BestSWDAccum,ebp
  mov   Block3.BestSWDAccum,ebp
   mov  Block4.BestSWDAccum,ebp
  mov   BlockN.BestSWDAccum,ebp
   xor  ebp,ebp
  sub   esp,64

  jmp   PD JumpTable[eax*4]

ZeroVectorSWDDone:

  mov   eax,ZeroVectorThreshold
   mov  ebx,Block2.CandidateSWDAccum
  cmp   eax,ebp
   mov  edi,Block1.CandidateSWDAccum
  mov   ecx,Block3.CandidateSWDAccum
   mov  Block1.BestSWDAccum,edi
  mov   Block2.BestSWDAccum,ebx
   mov  Block3.BestSWDAccum,ecx
  mov   Block4.BestSWDAccum,ebp
   mov  eax,0                         ; Set best MV to zero.
  mov   esi,MBlockActionStream
   jge  BelowZeroThreshold

  mov   Block1.SWD0MVAccum,edi
   mov  Block2.SWD0MVAccum,ebx
  mov   Block3.SWD0MVAccum,ecx
   mov  Block4.SWD0MVAccum,ebp
  mov   ebx,[esi].BlkY1.BestBiDiMVs
   mov  ecx,[esi].BlkY2.BestBiDiMVs
  mov   BlkY1_0deltaBiDiMVs,ebx
   mov  BlkY2_0deltaBiDiMVs,ecx
  mov   ebx,[esi].BlkY3.BestBiDiMVs
   mov  ecx,[esi].BlkY4.BestBiDiMVs
  mov   BlkY3_0deltaBiDiMVs,ebx
   mov  BlkY4_0deltaBiDiMVs,ecx
  mov   ecx,17
   xor  ebx,ebx                       ; First ME engine state is zero.
  mov   Block4.TransferCase,ecx       ; After block 4, transfer to done non0-MV.
   xor  ecx,ecx
  mov   BlockN.BestSWDAccum,ebp

SWDLoop:

  mov   CurrSWDState,ebx              ; Record ME engine state.
   mov  edx,PD SWDState[ebx]          ; dl == HMV; dh == VMV offsets to try.
  mov   bl,[esi].BlkY4.PVMV
   add  dl,al                         ; Try this horizontal MV delta.
  add   dh,ah                         ; Try this vertical MV delta.
   mov  cl,[esi].BlkY4.PHMV
  mov   BestMV,eax                    ; Record what the best MV so far is.
   mov  CandidateMV,edx               ; Record the candidate MV delta.
  mov   bl,WeightForwardMotion[ebx]   ; TRb * VMV / TRd
   xor  ebp,ebp
  add   bl,dh                         ; VMVf = TRb * VMV / TRd + VMVd
   mov  cl,WeightForwardMotion[ecx]   ; TRb * HMV / TRd
  cmp   bl,040H                       ; If too far up or down, take quick out.
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY4.CandidateVMVf,bl
   add  cl,dl                         ; HMVf = TRb * HMV / TRd + HMVd
  cmp   cl,040H                       ; If too far left or right, quick out.
   jbe  MVDeltaOutOfRange

  sar   ebx,1                         ; CF == 1 if past vert is at half pel.
   mov  [esi].BlkY4.CandidateHMVf,cl
  adc   ebp,ebp                       ; ebp == 1 if past vert is at half pel.
   mov  eax,PastMBAddr
  sar   ecx,1                         ; CF == 1 if past horz is at half pel.
IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
   lea  edi,[ebx+ebx*2]               ; Multiply vertical component by PITCH.
  adc   ebp,ebp                       ; ebp odd if past horz is at half pel.
   mov  bl,[esi].BlkY3.PVMV
  shl   edi,7
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  lea   ebp,[eax+ecx-48-48*PITCH+PITCH*8+8] ;Add horz full pel disp to ref addr.
   mov  cl,[esi].BlkY3.PHMV
  add   edi,ebp                       ; Add vert full pel disp to past ref addr.
   mov  bl,WeightForwardMotion[ebx]
  mov   Block4.PastRefBlockAddr,edi   ; Stash address of ref block from past.
   xor  ebp,ebp
  add   bl,dh
   mov  cl,WeightForwardMotion[ecx]
  cmp   bl,040H
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY3.CandidateVMVf,bl
   add  cl,dl
  cmp   cl,040H
   jbe  MVDeltaOutOfRange

  sar   ebx,1
   mov  [esi].BlkY3.CandidateHMVf,cl
  adc   ebp,ebp
   sub  eax,48+48*PITCH
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[esi].BlkY2.PVMV
  shl   edi,7
   mov  Block2.TransferCase,ebp
  lea   ebp,[eax+ecx+PITCH*8]
   mov  cl,[esi].BlkY2.PHMV
  add   edi,ebp
   mov  bl,WeightForwardMotion[ebx]
  mov   Block3.PastRefBlockAddr,edi
   xor  ebp,ebp
  add   bl,dh
   mov  cl,WeightForwardMotion[ecx]
  cmp   bl,040H
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY2.CandidateVMVf,bl
   add  cl,dl
  cmp   cl,040H
   jbe  MVDeltaOutOfRange

  sar   ebx,1
   mov  [esi].BlkY2.CandidateHMVf,cl
  adc   ebp,ebp
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[esi].BlkY1.PVMV
  shl   edi,7
   mov  Block1.TransferCase,ebp
  lea   ebp,[eax+ecx+8]
   mov  cl,[esi].BlkY1.PHMV
  add   edi,ebp
   mov  bl,WeightForwardMotion[ebx]
  mov   Block2.PastRefBlockAddr,edi
   xor  ebp,ebp
  add   bl,dh
   mov  cl,WeightForwardMotion[ecx]
  cmp   bl,040H
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY1.CandidateVMVf,bl
   add  cl,dl
  cmp   cl,040H
   jbe  MVDeltaOutOfRange

  sar   ebx,1
   mov  [esi].BlkY1.CandidateHMVf,cl
  adc   ebp,ebp
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   add  eax,ecx
  shl   edi,7
   mov  FirstTransferCase,ebp
  add   edi,eax
   test dh,dh                         ; Is vertical component MV delta zero?
  mov   Block1.PastRefBlockAddr,edi
   je   VMVdIsZero

  lea   edi,FutureBlock+80-48-48*FPITCH
   xor  eax,eax
  mov   bl,[esi].BlkY4.PVMV
   mov  al,[esi].BlkY4.CandidateVMVf
  mov   ebp,Block3.TransferCase       ; Reload transfer case (computed goto idx)
   sub  al,bl                         ; -VMVb = -(VMVf - VMV)
  mov   [esi].BlkY4.CandidateVMVb,al
   mov  cl,[esi].BlkY3.PVMV
  sar   eax,1                         ; CF == 1 if future vert is at half pel.
   mov  bl,[esi].BlkY3.CandidateVMVf
  adc   ebp,ebp                       ; ebp odd if future vert is at half pel.
IF FPITCH-40
  **** The magic leaks out if FPITCH != 40
ENDIF
  mov   Block3.TransferCase,ebp       ; Stash case to do after block 3.
   lea  eax,[eax+eax*4]               ; Multiply vertical component by FPITCH.
  mov   ebp,Block2.TransferCase
   sub  bl,cl
  lea   eax,[edi+eax*8+FPITCH*8+8] ; Addr of ref blk w/ vert MV.
   mov  [esi].BlkY3.CandidateVMVb,bl
  sar   ebx,1
   mov  Block4.FutureRefBlockAddr,eax ; Stash address of ref block from future.
  adc   ebp,ebp
   mov  cl,[esi].BlkY2.PVMV
  mov   Block2.TransferCase,ebp
   lea  eax,[ebx+ebx*4]
  mov   bl,[esi].BlkY2.CandidateVMVf
   mov  ebp,Block1.TransferCase
  lea   eax,[edi+eax*8+FPITCH*8]
   sub  bl,cl
  mov   Block3.FutureRefBlockAddr,eax
   mov  [esi].BlkY2.CandidateVMVb,bl
  sar   ebx,1
   mov  dh,[esi].BlkY1.PVMV		    
  adc   ebp,ebp
   mov  cl,[esi].BlkY1.CandidateVMVf
  mov   Block1.TransferCase,ebp
   sub  cl,dh
  mov   [esi].BlkY1.CandidateVMVb,cl
   lea  eax,[ebx+ebx*4]
  sar   ecx,1
   mov  ebp,FirstTransferCase
  adc   ebp,ebp
   lea  eax,[edi+eax*8+8]
  mov   Block2.FutureRefBlockAddr,eax
   lea  eax,[ecx+ecx*4]
  mov   FirstTransferCase,ebp
   test dl,dl                         ; Is horizontal component MV delta zero?
  lea   edi,[edi+eax*8]
   mov  eax,0
  mov   Block1.FutureRefBlockAddr,edi
   je   HMVdIsZero

HMVdIsNonZero:

  mov   cl,[esi].BlkY4.CandidateHMVf
   mov  bl,[esi].BlkY4.PHMV
  mov   ebp,Block3.TransferCase
   sub  cl,bl                         ; -HMVb = -(HMVf - HMV)
  mov   [esi].BlkY4.CandidateHMVb,cl
   mov  edi,Block4.FutureRefBlockAddr ; Load addr of ref blk to factor in horz.
  sar   ecx,1                         ; CF == 1 if future horz is at half pel.
   mov  bl,[esi].BlkY3.PHMV
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   add  edi,ecx                       ; Factor in HMVb.
  mov   Block3.TransferCase,ebp       ; Stash case to do after block 3.
   mov  cl,[esi].BlkY3.CandidateHMVf
  sub   cl,bl
   mov  Block4.FutureRefBlockAddr,edi ; Stash address of ref block from future.
  mov   ebp,Block2.TransferCase
   mov  [esi].BlkY3.CandidateHMVb,cl
  sar   ecx,1
   mov  edi,Block3.FutureRefBlockAddr
  adc   ebp,ebp
   add  edi,ecx
  mov   Block2.TransferCase,ebp
   mov  Block3.FutureRefBlockAddr,edi
  mov   cl,[esi].BlkY2.CandidateHMVf
   mov  bl,[esi].BlkY2.PHMV
  mov   ebp,Block1.TransferCase
   sub  cl,bl
  mov   [esi].BlkY2.CandidateHMVb,cl
   mov  edi,Block2.FutureRefBlockAddr
  sar   ecx,1
   mov  bl,[esi].BlkY1.PHMV
  adc   ebp,ebp
   add  edi,ecx
  mov   Block1.TransferCase,ebp
   mov  cl,[esi].BlkY1.CandidateHMVf
  sub   cl,bl
   mov  Block2.FutureRefBlockAddr,edi
  mov   eax,FirstTransferCase
   mov  [esi].BlkY1.CandidateHMVb,cl
  sar   ecx,1
   mov  edi,Block1.FutureRefBlockAddr
  adc   eax,eax
   add  edi,ecx
  mov   esi,Block1.PastRefBlockAddr
   sub  esp,64
  xor   ebp,ebp

  jmp   PD JumpTable[eax*4]


VMVdIsZero:

  mov   bl,[esi].BlkY4.PVMV
   mov  cl,[esi].BlkY3.PVMV
  mov   ebp,Block3.TransferCase
   mov  dh,PB Block2.TransferCase
  mov   bl,WeightBackwardMotion[ebx]
   lea  edi,FutureBlock+80-48-48*FPITCH
  mov   [esi].BlkY4.CandidateVMVb,bl
   mov  cl,WeightBackwardMotion[ecx]
  sar   ebx,1                         ; CF == 1 if future vert is at half pel.
   mov  [esi].BlkY3.CandidateVMVb,cl
  adc   ebp,ebp                       ; ebp odd if future vert is at half pel.
  sar   ecx,1
   lea  eax,[ebx+ebx*4]               ; Multiply vertical component by FPITCH.
  adc   dh,dh
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  lea   ebp,[edi+eax*8+FPITCH*8+8]    ; Addr of ref blk w/ vert MV factored in.
   lea  eax,[ecx+ecx*4]
  mov   PB Block2.TransferCase,dh
   mov  Block4.FutureRefBlockAddr,ebp ; Stash address of ref block from future.
  lea   ebp,[edi+eax*8+FPITCH*8]
   mov  bl,[esi].BlkY2.PVMV
  mov   Block3.FutureRefBlockAddr,ebp
   mov  cl,[esi].BlkY1.PVMV
  mov   ebp,Block1.TransferCase
   mov  bl,WeightBackwardMotion[ebx]
  mov   dh,PB FirstTransferCase
   mov  [esi].BlkY2.CandidateVMVb,bl
  sar   ebx,1
   mov  cl,WeightBackwardMotion[ecx]
  adc   ebp,ebp
   mov  [esi].BlkY1.CandidateVMVb,cl
  sar   ecx,1
   lea  eax,[ebx+ebx*4]
  adc   dh,dh
   mov  Block1.TransferCase,ebp
  lea   ebp,[edi+eax*8+8]
   lea  eax,[ecx+ecx*4]
  mov   PB FirstTransferCase,dh
   mov  Block2.FutureRefBlockAddr,ebp
  lea   ebp,[edi+eax*8]
   test dl,dl
  mov   Block1.FutureRefBlockAddr,ebp
   jne  HMVdIsNonZero

HMVdIsZero:

  mov   bl,[esi].BlkY4.PHMV
   mov  cl,[esi].BlkY3.PHMV
  mov   ebp,Block3.TransferCase
   mov  edx,Block2.TransferCase
  mov   bl,WeightBackwardMotion[ebx]
   mov  eax,Block4.FutureRefBlockAddr
  mov   [esi].BlkY4.CandidateHMVb,bl
   mov  cl,WeightBackwardMotion[ecx]
  sar   ebx,1                         ; CF == 1 if future horz is at half pel.
   mov  [esi].BlkY3.CandidateHMVb,cl
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   add  eax,ebx                       ; Addr of ref blk w/ horz MV factored in.
  sar   ecx,1
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  adc   edx,edx
   mov  edi,Block3.FutureRefBlockAddr
  mov   Block4.FutureRefBlockAddr,eax ; Stash address of ref block from future.
   add  edi,ecx
  mov   Block2.TransferCase,edx
   mov  Block3.FutureRefBlockAddr,edi
  mov   bl,[esi].BlkY2.PHMV
   mov  cl,[esi].BlkY1.PHMV
  mov   ebp,Block1.TransferCase
   mov  edx,FirstTransferCase
  mov   bl,WeightBackwardMotion[ebx]
   mov  eax,Block2.FutureRefBlockAddr
  mov   [esi].BlkY2.CandidateHMVb,bl
   mov  cl,WeightBackwardMotion[ecx]
  sar   ebx,1                         ; CF == 1 if future horz is at half pel.
   mov  [esi].BlkY1.CandidateHMVb,cl
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   add  eax,ebx                       ; Addr of ref blk w/ horz MV factored in.
  sar   ecx,1
   mov  Block1.TransferCase,ebp       ; Stash case to do after block 3.
  adc   edx,edx
   mov  edi,Block1.FutureRefBlockAddr
  mov   Block2.FutureRefBlockAddr,eax ; Stash address of ref block from future.
   add  edi,ecx
  mov   esi,Block1.PastRefBlockAddr
   sub  esp,64
  xor   ebp,ebp

  jmp   PD JumpTable[edx*4]


MVDeltaOutOfRange:

  xor   ebp,ebp
   mov  ebx,CurrSWDState             ; Restore ME engine state.
  jmp   OutOfRangeHandlingDone

TakeEarlyOut:

  sub   esp,4
   xor  ecx,ecx
  and   esp,0FFFFFFC0H
  mov   ebx,CurrSWDState+64
   mov  esi,MBlockActionStream+64
  mov   eax,BestMV+64
   add  esp,64
  mov   bl,SWDState[ebx+3]
  test  bl,bl
   jne  SWDLoop

  mov   ecx,Block4.SWD0MVAccum
   mov  ebp,Block4.BestSWDAccum
  jmp   CandidatesDone

NonZeroVectorSWDDone:

  mov   ebx,CurrSWDState
   mov  esi,MBlockActionStream
  xor   ecx,ecx
   mov  ebp,-1
  mov   eax,[esi].BlkY1.CandidateBiDiMVs
   mov  edx,[esi].BlkY2.CandidateBiDiMVs
  mov   [esi].BlkY1.BestBiDiMVs,eax
   mov  [esi].BlkY2.BestBiDiMVs,edx
  mov   eax,[esi].BlkY3.CandidateBiDiMVs
   mov  edx,[esi].BlkY4.CandidateBiDiMVs
  mov   [esi].BlkY3.BestBiDiMVs,eax
   mov  [esi].BlkY4.BestBiDiMVs,edx
  mov   eax,Block1.CandidateSWDAccum
   mov  edx,Block2.CandidateSWDAccum
  mov   Block1.BestSWDAccum,eax
   mov  Block2.BestSWDAccum,edx
  mov   eax,Block3.CandidateSWDAccum
   mov  edx,Block4.CandidateSWDAccum
  mov   Block3.BestSWDAccum,eax
   mov  Block4.BestSWDAccum,edx
  mov   BlockN.BestSWDAccum,edx

OutOfRangeHandlingDone:

  mov   bl,SWDState[ebx+ebp*1+3]
   mov  eax,BestMV[ebp*4]
  test  bl,bl
   jne  SWDLoop

  mov   ecx,Block4.SWD0MVAccum
   mov  ebp,Block4.BestSWDAccum

CandidatesDone:

  sub   ecx,ebp
   mov  ebx,NonZeroMVDifferential
  cmp   ecx,ebx
   jge  ZeroMVNotGoodEnough

ZeroMVGoodEnough:

  xor   eax,eax
   mov  esi,MBlockActionStream
  mov   edi,Block1.SWD0MVAccum
   mov  ebx,Block2.SWD0MVAccum
  mov   ecx,Block3.SWD0MVAccum
   mov  ebp,Block4.SWD0MVAccum
  mov   Block1.BestSWDAccum,edi
   mov  Block2.BestSWDAccum,ebx
  mov   Block3.BestSWDAccum,ecx
   mov  Block4.BestSWDAccum,ebp
  mov   ebx,BlkY1_0deltaBiDiMVs
   mov  edi,BlkY2_0deltaBiDiMVs
  mov   [esi].BlkY1.BestBiDiMVs,ebx
   mov  [esi].BlkY2.BestBiDiMVs,edi
  mov   ebx,BlkY3_0deltaBiDiMVs
   mov  edi,BlkY4_0deltaBiDiMVs
  mov   [esi].BlkY3.BestBiDiMVs,ebx
   mov  [esi].BlkY4.BestBiDiMVs,edi

BelowZeroThreshold:
ZeroMVNotGoodEnough:

  mov   [esi].BlkY1.BHMV,al
   mov  [esi].BlkY2.BHMV,al
  mov   [esi].BlkY3.BHMV,al
   mov  [esi].BlkY4.BHMV,al
  mov   [esi].BlkY1.BVMV,ah
   mov  [esi].BlkY2.BVMV,ah
  mov   [esi].BlkY3.BVMV,ah
   mov  [esi].BlkY4.BVMV,ah
  mov   al,[esi].CodedBlocksB      ; Fetch coded block pattern.
   mov  edi,EmptyBlockThreshold    ; Get threshold for forcing block empty?
  or    al,03FH                    ; Initially set all blocks coded.
   mov  ecx,Block3.BestSWDAccum
  mov   ebx,InterSWDBlocks
   mov  edx,ebp
  sub   edx,ecx                    ; Get SWD for block 4.
  cmp   edx,edi                    ; Is it below empty threshold?
   jg   @f

  and   al,0F7H                    ; If so, indicate block 4 is NOT coded.
   dec  ebx
  sub   ebp,edx

@@:

  mov   edx,Block2.BestSWDAccum
  sub   ecx,edx
  cmp   ecx,edi
   jg   @f

  and   al,0FBH
   dec  ebx
  sub   ebp,ecx

@@:

  mov   ecx,Block1.BestSWDAccum
  sub   edx,ecx
  cmp   edx,edi
   jg   @f

  and   al,0FDH
   dec  ebx
  sub   ebp,edx

@@:

  mov   edx,InterSWDTotal
  cmp   ecx,edi
   jg   @f

  and   al,0FEH
   dec  ebx
  sub   ebp,ecx

@@:

  mov   [esi].CodedBlocksB,al    ; Store coded block pattern.
   add  ebx,4
  mov   InterSWDBlocks,ebx
   add  edx,ebp                    ; Add to total for this macroblock class.
  mov   InterSWDTotal,edx
   mov  edx,esi
  mov   PD [esi].SWDB,ebp
   jmp  NextMacroBlock




BiDiNoInterp:

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Pointer to block of reference in future frame + 80.
;  al, bl, cl, dl -- Scratch.

  xor   eax,eax
   xor  ebx,ebx
  mov   al,[edi-80]                        ; 00A Fetch pel from future ref.
   mov  bl,[esi]                           ; 00B Fetch pel from previous ref.
  xor   ecx,ecx
   xor  edx,edx
@@:
  mov   al,InterpPastAndFutureRef[eax+ebx] ; 00C (past+future) or 2*past
   mov  bl,BlockN.TargetBlock[0]           ; 00D Fetch -2 * target pel.
  mov   cl,[edi+FPITCH*2+2-80]             ; 22A
   mov  dl,[esi+PITCH*2+2]                 ; 22B
  mov   bl,WeightedDiff[ebx+eax]           ; 00E Weighted difference.
   mov  cl,InterpPastAndFutureRef[ecx+edx] ; 22C
  add   ebp,ebx                            ; 00F Accumulate weighted difference.
   mov  dl,BlockN.TargetBlock[TPITCH*2+2]  ; 22D
  mov   al,[esi+PITCH*0+2]                 ; 02a Fetch pel from previous ref.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2]  ; 02b Fetch -2 * target pel.
  mov   dl,WeightedDiff[edx+ecx]           ; 22E
   mov  cl,[esi+PITCH*2+0]                 ; 20a
  add   ebp,edx                            ; 22F
   mov  dl,BlockN.TargetBlock[TPITCH*2+0]  ; 20b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 02c Weighted difference.
   mov  al,[esi+PITCH*1+1]                 ; 11a
  add   ebp,ebx                            ; 02d Accumulate weighted difference.
   mov  bl,BlockN.TargetBlock[TPITCH*1+1]  ; 11b
  mov   dl,WeightedDiff[edx+ecx*2]         ; 20c
   mov  cl,[esi+PITCH*1+3]                 ; 13a
  add   ebp,edx                            ; 20d
   mov  dl,BlockN.TargetBlock[TPITCH*1+3]  ; 13b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 11c
   mov  al,[esi+PITCH*3+1]                 ; 31a
  add   ebp,ebx                            ; 11d
   mov  bl,BlockN.TargetBlock[TPITCH*3+1]  ; 31b
  mov   dl,WeightedDiff[edx+ecx*2]         ; 13c
   mov  cl,[esi+PITCH*3+3]                 ; 33a
  add   ebp,edx                            ; 13d
   mov  dl,BlockN.TargetBlock[TPITCH*3+3]  ; 33b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 31c
   add  edi,4                              ;      Move to next 4 columns.
  add   ebp,ebx                            ; 31d
   mov  dl,WeightedDiff[edx+ecx*2]         ; 33c
  add   ebp,edx                            ; 33d
   add  esi,4                              ;      Move to next 4 columns.
  add   esp,4                              ;      Move to next 4 columns.
   mov  al,[edi-80]                        ; 04A
  mov   bl,[esi]                           ; 04B
   mov  cl,4
  and   ecx,esp                            ;      Twice, 4 cols each time.
   jne  @b

  mov   al,[edi-80+FPITCH*4-8]             ; 40A
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  mov   cl,8
   add  edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
  and   ecx,esp                            ; Twice, 4 rows each time.
   mov  bl,[esi]                           ; 40B
  jne   @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]


BiDiFutureHorz LABEL DWORD
  mov   edx,1
   xor  ecx,ecx
  jmp   BiDiSWDCalc_InterpFuture

BiDiFutureVert:
  mov   edx,FPITCH
   xor  ecx,ecx
  jmp   BiDiSWDCalc_InterpFuture

BiDiFutureBoth:
  mov   edx,FPITCH+1
   xor  ecx,ecx

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Pointer to block of reference in future frame + 80.
;  edx -- Distance from future pel to other future pel with which to interp.
;  al, bl, cl, dl -- Scratch.

BiDiSWDCalc_InterpFuture:

  mov   al,[edi-80]                        ; 00A Fetch pel from future ref.
   xor  ebx,ebx
@@:

  mov   bl,[edi+edx-80]                    ; 00B Fetch other future ref pel.
   and  eax,0000000FFH
  mov   BlockN.FutureRefInterpOffset,edx   ; Stash interp offset.
   mov  dl,[edi+edx+FPITCH*2+2-80]         ; 22B
  mov   al,InterpFutureRef[eax+ebx]        ; 00C Get interpolated future ref.
   mov  bl,[esi]                           ; 00D Fetch pel from previous ref.
  mov   cl,[edi+FPITCH*2+2-80]             ; 22A
   and  edx,0000000FFH                     ;     Extract pel value.
  mov   al,InterpPastAndFutureRef[eax+ebx] ; 00E (past+future) or 2*past
   mov  bl,BlockN.TargetBlock[0]           ; 00F Fetch -2 * target pel.
  mov   cl,InterpFutureRef[ecx+edx]        ; 22C
   mov  dl,[esi+PITCH*2+2]                 ; 22D
  mov   bl,WeightedDiff[ebx+eax]           ; 00G Weighted difference.
   mov  al,[esi+PITCH*0+2]                 ; 02a Fetch pel from previous ref.
  add   ebp,ebx                            ; 00H Accumulate weighted difference.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2]  ; 02b Fetch -2 * target pel.
  mov   cl,InterpPastAndFutureRef[ecx+edx] ; 22E
   mov  dl,BlockN.TargetBlock[TPITCH*2+2]  ; 22F
  mov   bl,WeightedDiff[ebx+eax*2]         ; 02c Weighted difference.
   mov  al,[esi+PITCH*2+0]                 ; 20a
  mov   dl,WeightedDiff[edx+ecx]           ; 22G
   add  ebp,ebx                            ; 02d Accumulate weighted difference.
  add   ebp,edx                            ; 22H
   mov  bl,BlockN.TargetBlock[TPITCH*2+0]  ; 20b
  mov   cl,[esi+PITCH*1+1]                 ; 11a
   mov  dl,BlockN.TargetBlock[TPITCH*1+1]  ; 11b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 20c
   mov  al,[esi+PITCH*1+3]                 ; 13a
  add   ebp,ebx                            ; 20d
   mov  dl,WeightedDiff[edx+ecx*2]         ; 11c
  add   ebp,edx                            ; 11d
   mov  bl,BlockN.TargetBlock[TPITCH*1+3]  ; 13b
  mov   cl,[esi+PITCH*3+1]                 ; 31a
   mov  dl,BlockN.TargetBlock[TPITCH*3+1]  ; 31b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 13c
   mov  al,[esi+PITCH*3+3]                 ; 33a
  add   ebp,ebx                            ; 13d
   mov  bl,BlockN.TargetBlock[TPITCH*3+3]  ; 33b
  mov   dl,WeightedDiff[edx+ecx*2]         ; 31c
   add  edi,4                              ;      Move to next 4 columns.
  add   ebp,edx                            ; 31d
   mov  bl,WeightedDiff[ebx+eax*2]         ; 33c
  add   ebp,ebx                            ; 33d
   mov  edx,BlockN.FutureRefInterpOffset   ;     Prepare for next iteration.
  add   esi,4                              ;      Move to next 4 columns.
   add  esp,4                              ;      Move to next 4 columns.
  mov   al,[edi-80]                        ; 04A
   mov  cl,4
  and   ecx,esp                            ;      Twice, 4 cols each time.
   jne  @b

  mov   al,[edi-80+FPITCH*4-8]             ; 40A
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  mov   cl,8
   add  edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
  and   ecx,esp                            ; Twice, 4 rows each time.
   jne  @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]


BiDiPastHorz LABEL DWORD
  mov   edx,edi
   mov  edi,1
  xor   eax,eax
   jmp  BiDiSWDCalc_InterpPast

BiDiPastVert:
  mov   edx,edi
   mov  edi,PITCH
  xor   eax,eax
   jmp  BiDiSWDCalc_InterpPast

BiDiPastBoth:
  mov   edx,edi
   mov  edi,PITCH+1
  xor   eax,eax

BiDiSWDCalc_InterpPast:

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Distance from future pel to other future pel with which to interp.
;  edx -- Pointer to block of reference in future frame + 80.
;  al, bl, cl, dl -- Scratch.

  mov   al,[esi]                              ; 00A Fetch pel from previous ref.
   xor  ebx,ebx
  mov   bl,[esi+edi]                          ; 00B Fetch other past ref pel.
   xor  ecx,ecx
@@:
  add   al,bl                                 ; 00C Interp'd past ref, times 2.
   mov  bl,[edx-80]                           ; 00D Fetch pel from future ref.
  mov   BlockN.FutureRefBlockAddr,edx
   mov  dl,[edx+FPITCH*2+2-80]                ; 22D
  mov   al,Interp2PastAndFutureRef[eax+ebx*2] ; 00E (past+future) or 2*past.
   mov  bl,BlockN.TargetBlock[0]              ; 00F Fetch target pel.
  mov   cl,[esi+PITCH*2+2]                    ; 22A
   and  edx,0000000FFH
  mov   bl,WeightedDiff[eax+ebx]              ; 00G Weighted difference.
   mov  al,[esi+edi+PITCH*2+2]                ; 22B
  add   cl,al                                 ; 22C
   mov  al,[esi+PITCH*0+2]                    ; 02a Fetch pel from previous ref.
  add   ebp,ebx                               ; 00H Accumulate weighted diff.
   mov  bl,[esi+edi+PITCH*0+2]                ; 02b Fetch other past ref pel.
  mov   cl,Interp2PastAndFutureRef[ecx+edx*2] ; 22E
   mov  dl,BlockN.TargetBlock[TPITCH*2+2]     ; 22F
  add   al,bl                                 ; 02c Interp'd past ref, times 2.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2]     ; 02d Fetch -2 * target pel.
  mov   dl,WeightedDiff[ecx+edx]              ; 22G Weighted difference.
   mov  cl,[esi+PITCH*2+0]                    ; 20a
  add   ebp,edx                               ; 22H
   mov  dl,[esi+edi+PITCH*2+0]                ; 20b
  add   cl,dl                                 ; 20c
   mov  dl,BlockN.TargetBlock[TPITCH*2+0]     ; 20d
  mov   bl,WeightedDiff[eax+ebx]              ; 02e Weighted difference.
   mov  al,[esi+PITCH*1+1]                    ; 11a
  add   ebp,ebx                               ; 02f Accumulate weighted diff.
   mov  bl,[esi+edi+PITCH*1+1]                ; 11b
  add   al,bl                                 ; 11c
   mov  bl,BlockN.TargetBlock[TPITCH*1+1]     ; 11d
  mov   dl,WeightedDiff[ecx+edx]              ; 20e
   mov  cl,[esi+PITCH*1+3]                    ; 13a
  add   ebp,edx                               ; 20f
   mov  dl,[esi+edi+PITCH*1+3]                ; 13b
  add   cl,dl                                 ; 13c
   mov  dl,BlockN.TargetBlock[TPITCH*1+3]     ; 13d
  mov   bl,WeightedDiff[eax+ebx]              ; 11e
   mov  al,[esi+PITCH*3+1]                    ; 31a
  add   ebp,ebx                               ; 11f
   mov  bl,[esi+edi+PITCH*3+1]                ; 31b
  add   al,bl                                 ; 31c
   mov  bl,BlockN.TargetBlock[TPITCH*3+1]     ; 31d
  mov   dl,WeightedDiff[ecx+edx]              ; 13e
   mov  cl,[esi+PITCH*3+3]                    ; 33a
  add   ebp,edx                               ; 13f
   mov  dl,[esi+edi+PITCH*3+3]                ; 33b
  add   cl,dl                                 ; 33c
   mov  dl,BlockN.TargetBlock[TPITCH*3+3]     ; 33d
  mov   bl,WeightedDiff[eax+ebx]              ; 31e
   add  esi,4                                 ;     Move to next 4 columns.
  add   ebp,ebx                               ; 31f
   mov  dl,WeightedDiff[ecx+edx]              ; 33e
  add   ebp,edx                               ; 33f
   mov  edx,BlockN.FutureRefBlockAddr
  add   edx,4                                 ;     Move to next 4 columns.
   add  esp,4                                 ;     Move to next 4 columns.
  mov   al,[esi]                              ; 04A
   mov  cl,4
  mov   bl,[esi+edi]                          ; 04B
   and  ecx,esp                               ;     Twice, 4 cols each time.
  mov   cl,8
   jne  @b

  add   edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
   mov  al,[esi+PITCH*4-8]                 ; 40A
  mov   bl,[esi+edi+PITCH*4-8]             ; 40B
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  and   ecx,esp                            ; Twice, 4 rows each time.
   jne  @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]


BiDiSWDCalc_InterpBoth MACRO PastRefInterpOffset

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Pointer to block of reference in future frame + 80.
;  al, bl, cl, dl -- Scratch.

@@:
  
  mov   bl,[edi-80]                        ; 00A Fetch pel from future ref.
   mov  BlockN.FutureRefBlockAddr,edx
  mov   al,[edi+edx-80]                    ; 00B Fetch other future ref pel.
   mov  dl,[edi+edx+FPITCH*2+2-80]                     ; 22B
  mov   cl,[edi+FPITCH*2+2-80]                         ; 22A
   add  esp,4                              ;     Move to next 4 columns.
  mov   bl,InterpFutureRef[eax+ebx]        ; 00C Get interpolated future ref.
   mov  al,[esi]                           ; 00D Fetch pel from previous ref.
  mov   dl,InterpFutureRef[ecx+edx]                    ; 22C
   mov  cl,[esi+PITCH*2+2]                             ; 22D
  lea   ebx,[eax+ebx*2]                    ; 00E Interp'ed future plus one past.
   mov  al,[esi+PastRefInterpOffset]       ; 00F Fetch other pel from past ref.
  lea   edx,[ecx+edx*2]                                ; 22E
   mov  cl,[esi+PITCH*2+2+PastRefInterpOffset]         ; 22F
  mov   al,Interp2PastAndFutureRef[ebx+eax]; 00G (past+future) or 2*past.
   xor  ebx,ebx
  mov   bl,BlockN.TargetBlock[0-4]         ; 00H Fetch target pel.
   mov  cl,Interp2PastAndFutureRef[edx+ecx]            ; 22G
  mov   dl,BlockN.TargetBlock[TPITCH*2+2-4]            ; 22H
   add  esi,4                                 ;     Move to next 4 columns.
  and   edx,0000000FFH
   mov  bl,WeightedDiff[eax+ebx]           ; 00I Weighted difference.
  add   ebp,ebx                            ; 00J Accum weighted difference.
   mov  al,[esi+PITCH*0+2-4]                    ; 02a Fetch pel from prev ref.
  mov   dl,WeightedDiff[ecx+edx]                       ; 22I
   mov  bl,[esi+PastRefInterpOffset+PITCH*0+2-4]; 02b Fetch other past ref pel.
  add   al,bl                                   ; 02c Interp'd past ref, *2.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2-4]     ; 02d Fetch -2 * target pel.
  add   ebp,edx                                        ; 22J
   mov  cl,[esi+PITCH*2+0-4]                    ; 20a
  add   edi,4                              ;     Move to next 4 columns.
   mov  dl,[esi+PastRefInterpOffset+PITCH*2+0-4]; 20b
  mov   bl,WeightedDiff[eax+ebx]                ; 02e Weighted difference.
   mov  al,[esi+PITCH*1+1-4]                    ; 11a
  add   ebp,ebx                                 ; 02f Accumulate weighted diff.
   mov  bl,[esi+PastRefInterpOffset+PITCH*1+1-4]; 11b
  add   cl,dl                                   ; 20c
   mov  dl,BlockN.TargetBlock[TPITCH*2+0-4]     ; 20d
  add   al,bl                                   ; 11c
   mov  bl,BlockN.TargetBlock[TPITCH*1+1-4]     ; 11d
  mov   dl,WeightedDiff[ecx+edx]                ; 20e
   mov  cl,[esi+PITCH*1+3-4]                    ; 13a
  add   ebp,edx                                 ; 20f
   mov  dl,[esi+PastRefInterpOffset+PITCH*1+3-4]; 13b
  mov   bl,WeightedDiff[eax+ebx]                ; 11e
   mov  al,[esi+PITCH*3+1-4]                    ; 31a
  add   ebp,ebx                                 ; 11f
   mov  bl,[esi+PastRefInterpOffset+PITCH*3+1-4]; 31b
  add   cl,dl                                   ; 13c
   mov  dl,BlockN.TargetBlock[TPITCH*1+3-4]     ; 13d
  add   al,bl                                   ; 31c
   mov  bl,BlockN.TargetBlock[TPITCH*3+1-4]     ; 31d
  mov   dl,WeightedDiff[ecx+edx]                ; 13e
   mov  cl,[esi+PITCH*3+3-4]                    ; 33a
  add   ebp,edx                                 ; 13f
   mov  dl,[esi+PastRefInterpOffset+PITCH*3+3-4]; 33b
  add   cl,dl                                   ; 33c
   mov  dl,BlockN.TargetBlock[TPITCH*3+3-4]     ; 33d
  mov   bl,WeightedDiff[eax+ebx]                ; 31e
   mov  al,4
  add   ebp,ebx                                 ; 31f
   mov  dl,WeightedDiff[ecx+edx]                ; 33e
  add   ebp,edx                                 ; 33f
   mov  edx,BlockN.FutureRefBlockAddr-4
  and   eax,esp                                 ;     Twice, 4 cols each time.
   jne  @b

  add   edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  mov   cl,8
  and   ecx,esp                            ; Twice, 4 rows each time.
   jne  @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]

ENDM

BiDiPastHorzFutureHorz LABEL DWORD

  xor   ecx,ecx
   mov  edx,1
  jmp   BiDiSWDCalc_InterpBoth_PastByHorz

BiDiPastHorzFutureVert LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH
  jmp   BiDiSWDCalc_InterpBoth_PastByHorz

BiDiPastHorzFutureBoth LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH+1

BiDiSWDCalc_InterpBoth_PastByHorz:

  xor   eax,eax
   xor  ebx,ebx
  BiDiSWDCalc_InterpBoth 1

BiDiPastVertFutureHorz LABEL DWORD

  xor   ecx,ecx
   mov  edx,1
  jmp   BiDiSWDCalc_InterpBoth_PastByVert

BiDiPastVertFutureVert LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH
  jmp   BiDiSWDCalc_InterpBoth_PastByVert

BiDiPastVertFutureBoth LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH+1

BiDiSWDCalc_InterpBoth_PastByVert:

  xor   eax,eax
   xor  ebx,ebx
  BiDiSWDCalc_InterpBoth PITCH

BiDiPastBothFutureHorz LABEL DWORD

  xor   ecx,ecx
   mov  edx,1
  jmp   BiDiSWDCalc_InterpBoth_PastByBoth

BiDiPastBothFutureVert LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH
  jmp   BiDiSWDCalc_InterpBoth_PastByBoth

BiDiPastBothFutureBoth LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH+1

BiDiSWDCalc_InterpBoth_PastByBoth:

  xor   eax,eax
   xor  ebx,ebx
  BiDiSWDCalc_InterpBoth PITCH+1

ALIGN 4
JumpTable:
  
  DD   BiDiNoInterp
  DD   BiDiFutureHorz
  DD   BiDiFutureVert
  DD   BiDiFutureBoth
  DD   BiDiPastHorz
  DD   BiDiPastHorzFutureHorz
  DD   BiDiPastHorzFutureVert
  DD   BiDiPastHorzFutureBoth
  DD   BiDiPastVert
  DD   BiDiPastVertFutureHorz
  DD   BiDiPastVertFutureVert
  DD   BiDiPastVertFutureBoth
  DD   BiDiPastBoth
  DD   BiDiPastBothFutureHorz
  DD   BiDiPastBothFutureVert
  DD   BiDiPastBothFutureBoth
  DD   ZeroVectorSWDDone
  DD   NonZeroVectorSWDDone

Done:

  mov   ecx,InterSWDTotal
  mov   edx,InterSWDBlocks
  mov   esp,StashESP
  mov   edi,[esp+InterSWDTotal_arg]
  mov   [edi],ecx
  mov   edi,[esp+InterSWDBlocks_arg]
  mov   [edi],edx
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn


BFRAMEMOTIONESTIMATION endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ex5fdct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5fdct.asv   1.5   14 May 1996 12:18:50   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\ex5fdct.asv  $
;// 
;//    Rev 1.5   14 May 1996 12:18:50   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.4   11 Apr 1996 16:02:06   AKASAI
;// Updated H261 encoder to new interface and macroblock action stream
;// data structure in e3mbad.inc for FORWARDDCT.  Files updated together
;// e1enc.cpp, e1enc.h, ex5fdct.asm, e3mbad.inc.
;// 
;// Added IFNDEF H261 in ex5fdct so that code used only in H263 is
;// not assembled for H261.
;// 
;//    Rev 1.3   24 Jan 1996 13:21:28   BNICKERS
;// Implement OBMC
;// 
;//    Rev 1.1   27 Dec 1995 15:32:42   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////
;
; e35fdct -- This function performs a Forward Discrete Cosine Transform for H263, on a stream of macroblocks comprised
;            of 8*8 blocks of pels or pel diffs.  This version is tuned for the Pentium Microprocessor.
;
; Arguments:
;
;   MBlockActionStream (Input)
;
;     A stream of MacroBlock Action Descriptors.  Each descriptor indicates which blocks of a macroblock are non-empty
;     and thus need to be transformed.  There are from 0 to 12 non-empty blocks in each macroblock.
;
;     Processing commences with the macroblock described by the first descriptor in the stream (regardless of whether
;     it's End-Of-Stream bit is set).  Processing continues up to but not including the next descriptor that has the
;     End-Of-Stream bit set.
;
;     This function requires each descripgor in the MBlockActionStream to be 16-byte aligned.  Moreover, each of the
;     T_Blk elements in the descriptor must also be 16-byte aligned, and ordered as they are now.  (Note that I am
;     talking about the address of these pointer variables, not the alignement of the data they point to.)
;
;     Best performance will be attained when 8*8 blocks are (or usually are) DWORD aligned.  MMx implementations will
;     probably prefer 8-byte alignment.
;
;     The complete format of the MacroBlock Action Descriptors is provided in e3mbad.inc.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.  When doing B frames, this
;                             is the Target B Frame Base Address.
;
;   PreviousFrameBaseAddress -- Address of the reconstructed previous frame.  This really isn't needed for P-frame
;                               processing, estimation since the address of each block's prediction was recorded by
;                               MotionEstimation.  It's only used by B-frame processing.
;
;   FutureFrameBaseAddress -- Address of the reconstructed future (a.k.a. current) P-frame.  Only used when processing
;                             B frames.
;
;   CoeffStream (Output)
;
;     A stream of storage blocks which receive the DCT output coefficient
;     blocks for each non-empty blocks described in the MBlockActionStream.
;     Each coefficient block is 128 bytes.  The stream must be large enough
;     to hold all the output coefficient blocks.
;
;     Best performance will be attained by assuring the storage is 32-byte
;     aligned.  Best performance will be attained by using the output before
;     the data cache gets changed by other data.  Consuming the coefficient
;     blocks in forward order is best, since they are defined in reverse
;     order (and thus the first blocks are most likely to be in cache).
;
;     The complete format of the coefficient blocks is provided in encdctc.inc.
;
;   IsBFrame (Input)
;
;     0 (False) if doing Key or P frame.  1 (True) if doing B frame.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc   ; Encoder instance data
include e3mbad.inc   ; MacroBlock Action Descriptor struct layout
include e3dctc.inc   ; DCT Coefficient block layout

.xlist
include memmodel.inc
.list
.DATA

InitTbl MACRO WeightHi,WeightLo,TableLabel
TableLabel LABEL DWORD
  CNT = -128
  REPEAT 128
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)+((WeightLo*CNT-08000H)/010000H)
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)-((WeightLo*CNT-08000H)/010000H)
   CNT = CNT + 1
  ENDM
  REPEAT 128
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)+((WeightLo*CNT+08000H)/010000H)
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)-((WeightLo*CNT+08000H)/010000H)
   CNT = CNT + 1
  ENDM
ENDM

InitTbl  080000H,04545FH,P80000_P4545F
P80000_N4545F = P80000_P4545F + 4

InitTbl  080000H,0A73D7H,P80000_PA73D7
P80000_NA73D7 = P80000_PA73D7 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl  02350BH, 06491AH,P2350B_P6491A
P2350B_N6491A = P2350B_P6491A + 4

InitTbl -0B18A8H,-096831H,NB18A8_N96831
NB18A8_P96831 = NB18A8_N96831 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl -096831H, 02350BH,N96831_P2350B
N96831_N2350B = N96831_P2350B + 4

InitTbl 06491AH, 0B18A8H,P6491A_PB18A8
P6491A_NB18A8 = P6491A_PB18A8 + 4


ColsDefined        DD 000000000H,000000000H,07F7F7F7FH,07F7F7F7FH
                   DD 000000000H,07F7F7F00H,07F7F7F7FH,00000007FH
                   DD 000000000H,07F7F0000H,07F7F7F7FH,000007F7FH
                   DD 000000000H,07F000000H,07F7F7F7FH,0007F7F7FH,000000000H

                           ;  Right   Left  Chroma
                   DB   0  ;         -22.0
                   DB   0  ;         -21.5
                   DB   0  ;         -21.0
                   DB   0  ;         -20.5
                   DB   0  ;         -20.0
                   DB   0  ;         -19.5
                   DB   0  ;         -19.0
                   DB   0  ;         -18.5
                   DB   0  ;         -18.0
                   DB   0  ;         -17.5
                   DB   0  ;         -17.0
                   DB   0  ;         -16.5
                   DB   0  ;         -16.0
                   DB   0  ;         -15.5
                   DB   0  ;         -15.0
                   DB   0  ;         -14.5
                   DB   0  ;  -22.0  -14.0
                   DB   0  ;  -21.5  -13.5
                   DB   0  ;  -21.0  -13.0
                   DB   0  ;  -20.5  -12.5
                   DB   0  ;  -20.0  -12.0
                   DB   0  ;  -19.5  -11.5
                   DB   0  ;  -19.0  -11.0
                   DB   0  ;  -18.5  -10.5
                   DB   0  ;  -18.0  -10.0
                   DB   0  ;  -17.5   -9.5
                   DB   0  ;  -17.0   -9.0
                   DB   0  ;  -16.5   -8.5
                   DB   0  ;  -16.0   -8.0
                   DB   0  ;  -15.5   -7.5
                   DB  48  ;  -15.0   -7.0
                   DB  48  ;  -14.5   -6.5
                   DB  32  ;  -14.0   -6.0
                   DB  32  ;  -13.5   -5.5
                   DB  16  ;  -13.0   -5.0
                   DB  16  ;  -12.5   -4.5
                   DB   4  ;  -12.0   -4.0
                   DB   4  ;  -11.5   -3.5
                   DB  52  ;  -11.0   -3.0
                   DB  52  ;  -10.5   -2.5
                   DB  36  ;  -10.0   -2.0
                   DB  36  ;   -9.5   -1.5
                   DB  20  ;   -9.0   -1.0
                   DB  20  ;   -8.5    -.5
LeftYBlkColsDef    DB   8  ;   -8.0      0
                   DB   8  ;   -7.5     .5
                   DB   8  ;   -7.0    1.0
                   DB   8  ;   -6.5    1.5
                   DB   8  ;   -6.0    2.0
                   DB   8  ;   -5.5    2.5
                   DB   8  ;   -5.0    3.0
                   DB   8  ;   -4.5    3.5
                   DB   8  ;   -4.0    4.0
                   DB   8  ;   -3.5    4.5
                   DB   8  ;   -3.0    5.0
                   DB   8  ;   -2.5    5.5
                   DB   8  ;   -2.0    6.0
                   DB   8  ;   -1.5    6.5
                   DB   8  ;   -1.0    7.0
                   DB   8  ;    -.5    7.5
RightYBlkColsDef   DB   8  ;      0    8.0
                   DB  56  ;     .5    8.5
                   DB  56  ;    1.0    9.0
                   DB  40  ;    1.5    9.5
                   DB  40  ;    2.0   10.0
                   DB  24  ;    2.5   10.5
                   DB  24  ;    3.0   11.0
                   DB  12  ;    3.5   11.5
                   DB  12  ;    4.0   12.0
                   DB  60  ;    4.5   12.5
                   DB  60  ;    5.0   13.0
                   DB  44  ;    5.5   13.5
                   DB  44  ;    6.0   14.0
                   DB  28  ;    6.5   14.5
                   DB  28  ;    7.0   15.0
                   DB   0  ;    7.5   15.5
                   DB   0  ;    8.0   16.0
                   DB   0  ;    8.5   16.5
                   DB   0  ;    9.0   17.0
                   DB   0  ;    9.5   17.5
                   DB   0  ;   10.0   18.0
                   DB   0  ;   10.5   18.5
                   DB   0  ;   11.0   19.0
                   DB   0  ;   11.5   19.5
                   DB   0  ;   12.0   20.0
                   DB   0  ;   12.5   20.5
                   DB   0  ;   13.0   21.0
                   DB   0  ;   13.5   21.5
                   DB   0  ;   14.0   22.0
                   DB   0  ;   14.5
                   DB   0  ;   15.0
                   DB   0  ;   15.5
                   DB   0  ;   16.0
                   DB   0  ;   16.5
                   DB   0  ;   17.0
                   DB   0  ;   17.5
                   DB   0  ;   18.0
                   DB   0  ;   18.5         -11.0
                   DB   0  ;   19.0         -10.5
                   DB   0  ;   19.5         -10.0
                   DB   0  ;   20.0          -9.5
                   DB   0  ;   20.5          -9.0
                   DB   0  ;   21.0          -8.5
                   DB   0  ;   21.5          -8.0
                   DB   0  ;   22.0          -7.5
                   DB  48  ;                 -7.0
                   DB  48  ;                 -6.5
                   DB  32  ;                 -6.0
                   DB  32  ;                 -5.5
                   DB  16  ;                 -5.0
                   DB  16  ;                 -4.5
                   DB   4  ;                 -4.0
                   DB   4  ;                 -3.5
                   DB  52  ;                 -3.0
                   DB  52  ;                 -2.5
                   DB  36  ;                 -2.0
                   DB  36  ;                 -1.5
                   DB  20  ;                 -1.0
                   DB  20  ;                  -.5
ChromaColsDef      DB   8  ;                    0
                   DB  56  ;                   .5
                   DB  56  ;                  1.0
                   DB  40  ;                  1.5
                   DB  40  ;                  2.0
                   DB  24  ;                  2.5
                   DB  24  ;                  3.0
                   DB  12  ;                  3.5
                   DB  12  ;                  4.0
                   DB  60  ;                  4.5
                   DB  60  ;                  5.0
                   DB  44  ;                  5.5
                   DB  44  ;                  6.0
                   DB  28  ;                  6.5
                   DB  28  ;                  7.0
                   DB   0  ;                  7.5
                   DB   0  ;                  8.0
                   DB   0  ;                  8.5
                   DB   0  ;                  9.0
                   DB   0  ;                  9.5
                   DB   0  ;                 10.0
                   DB   0  ;                 10.5
                   DB   0  ;                 11.0

                           ;  Lower  Upper  Chroma
                   DB 000H ;         -22.0
                   DB 000H ;         -21.5
                   DB 000H ;         -21.0
                   DB 000H ;         -20.5
                   DB 000H ;         -20.0
                   DB 000H ;         -19.5
                   DB 000H ;         -19.0
                   DB 000H ;         -18.5
                   DB 000H ;         -18.0
                   DB 000H ;         -17.5
                   DB 000H ;         -17.0
                   DB 000H ;         -16.5
                   DB 000H ;         -16.0
                   DB 000H ;         -15.5
                   DB 000H ;         -15.0
                   DB 000H ;         -14.5
                   DB 000H ;  -22.0  -14.0
                   DB 000H ;  -21.5  -13.5
                   DB 000H ;  -21.0  -13.0
                   DB 000H ;  -20.5  -12.5
                   DB 000H ;  -20.0  -12.0
                   DB 000H ;  -19.5  -11.5
                   DB 000H ;  -19.0  -11.0
                   DB 000H ;  -18.5  -10.5
                   DB 000H ;  -18.0  -10.0
                   DB 000H ;  -17.5   -9.5
                   DB 000H ;  -17.0   -9.0
                   DB 000H ;  -16.5   -8.5
                   DB 000H ;  -16.0   -8.0
                   DB 000H ;  -15.5   -7.5
                   DB 001H ;  -15.0   -7.0
                   DB 001H ;  -14.5   -6.5
                   DB 003H ;  -14.0   -6.0
                   DB 003H ;  -13.5   -5.5
                   DB 007H ;  -13.0   -5.0
                   DB 007H ;  -12.5   -4.5
                   DB 00FH ;  -12.0   -4.0
                   DB 00FH ;  -11.5   -3.5
                   DB 01FH ;  -11.0   -3.0
                   DB 01FH ;  -10.5   -2.5
                   DB 03FH ;  -10.0   -2.0
                   DB 03FH ;   -9.5   -1.5
                   DB 07FH ;   -9.0   -1.0
                   DB 07FH ;   -8.5    -.5
UpperYBlkLinesDef  DB 0FFH ;   -8.0      0
                   DB 0FFH ;   -7.5     .5
                   DB 0FFH ;   -7.0    1.0
                   DB 0FFH ;   -6.5    1.5
                   DB 0FFH ;   -6.0    2.0
                   DB 0FFH ;   -5.5    2.5
                   DB 0FFH ;   -5.0    3.0
                   DB 0FFH ;   -4.5    3.5
                   DB 0FFH ;   -4.0    4.0
                   DB 0FFH ;   -3.5    4.5
                   DB 0FFH ;   -3.0    5.0
                   DB 0FFH ;   -2.5    5.5
                   DB 0FFH ;   -2.0    6.0
                   DB 0FFH ;   -1.5    6.5
                   DB 0FFH ;   -1.0    7.0
                   DB 0FFH ;    -.5    7.5
LowerYBlkLinesDef  DB 0FFH ;      0    8.0
                   DB 0FEH ;     .5    8.5
                   DB 0FEH ;    1.0    9.0
                   DB 0FCH ;    1.5    9.5
                   DB 0FCH ;    2.0   10.0
                   DB 0F8H ;    2.5   10.5
                   DB 0F8H ;    3.0   11.0
                   DB 0F0H ;    3.5   11.5
                   DB 0F0H ;    4.0   12.0
                   DB 0E0H ;    4.5   12.5
                   DB 0E0H ;    5.0   13.0
                   DB 0C0H ;    5.5   13.5
                   DB 0C0H ;    6.0   14.0
                   DB 080H ;    6.5   14.5
                   DB 080H ;    7.0   15.0
                   DB 000H ;    7.5   15.5
                   DB 000H ;    8.0   16.0
                   DB 000H ;    8.5   16.5
                   DB 000H ;    9.0   17.0
                   DB 000H ;    9.5   17.5
                   DB 000H ;   10.0   18.0
                   DB 000H ;   10.5   18.5
                   DB 000H ;   11.0   19.0
                   DB 000H ;   11.5   19.5
                   DB 000H ;   12.0   20.0
                   DB 000H ;   12.5   20.5
                   DB 000H ;   13.0   21.0
                   DB 000H ;   13.5   21.5
                   DB 000H ;   14.0   22.0
                   DB 000H ;   14.5
                   DB 000H ;   15.0
                   DB 000H ;   15.5
                   DB 000H ;   16.0
                   DB 000H ;   16.5
                   DB 000H ;   17.0
                   DB 000H ;   17.5
                   DB 000H ;   18.0
                   DB 000H ;   18.5         -11.0
                   DB 000H ;   19.0         -10.5
                   DB 000H ;   19.5         -10.0
                   DB 000H ;   20.0          -9.5
                   DB 000H ;   20.5          -9.0
                   DB 000H ;   21.0          -8.5
                   DB 000H ;   21.5          -8.0
                   DB 000H ;   22.0          -7.5
                   DB 001H ;                 -7.0
                   DB 001H ;                 -6.5
                   DB 003H ;                 -6.0
                   DB 003H ;                 -5.5
                   DB 007H ;                 -5.0
                   DB 007H ;                 -4.5
                   DB 00FH ;                 -4.0
                   DB 00FH ;                 -3.5
                   DB 01FH ;                 -3.0
                   DB 01FH ;                 -2.5
                   DB 03FH ;                 -2.0
                   DB 03FH ;                 -1.5
                   DB 07FH ;                 -1.0
                   DB 07FH ;                  -.5
ChromaLinesDef     DB 0FFH ;                    0
                   DB 0FEH ;                   .5
                   DB 0FEH ;                  1.0
                   DB 0FCH ;                  1.5
                   DB 0FCH ;                  2.0
                   DB 0F8H ;                  2.5
                   DB 0F8H ;                  3.0
                   DB 0F0H ;                  3.5
                   DB 0F0H ;                  4.0
                   DB 0E0H ;                  4.5
                   DB 0E0H ;                  5.0
                   DB 0C0H ;                  5.5
                   DB 0C0H ;                  6.0
                   DB 080H ;                  6.5
                   DB 080H ;                  7.0
                   DB 000H ;                  7.5
                   DB 000H ;                  8.0
                   DB 000H ;                  8.5
                   DB 000H ;                  9.0
                   DB 000H ;                  9.5
                   DB 000H ;                 10.0
                   DB 000H ;                 10.5
                   DB 000H ;                 11.0


.CODE

;ASSUME cs : FLAT
;ASSUME ds : FLAT
;ASSUME es : FLAT
;ASSUME fs : FLAT
;ASSUME gs : FLAT
;ASSUME ss : FLAT

FORWARDDCT proc C AMBlockActionStream:       DWORD,
ATargetFrameBaseAddress: DWORD, APreviousFrameBaseAddress: DWORD, 
AFutureFrameBaseAddress: DWORD, ACoeffStream: DWORD, AIsBFrame: DWORD,
AIsAdvancedPrediction: DWORD, AIsPOfPBPair: DWORD, AScratchBlocks: DWORD,
ANumMBlksInGOB: DWORD

LocalFrameSize = 196
RegisterStorageSize = 16

; Arguments:

MBlockActionStream                    = RegisterStorageSize +  4
TargetFrameBaseAddress_arg            = RegisterStorageSize +  8
PreviousFrameBaseAddress_arg          = RegisterStorageSize + 12
FutureFrameBaseAddress_arg            = RegisterStorageSize + 16
CoeffStream_arg                       = RegisterStorageSize + 20
IsBFrame                              = RegisterStorageSize + 24
IsAdvancedPrediction                  = RegisterStorageSize + 28
IsPOfPBPair                           = RegisterStorageSize + 32
ScratchBlocks                         = RegisterStorageSize + 36
NumMBlksInGOB                         = RegisterStorageSize + 40
EndOfArgList                          = RegisterStorageSize + 44

; Locals (on local stack frame)

P00                      EQU [esp+  8] ; Biased Pels or Biased Pel Differences
P01                      EQU [esp+  9]
P02                      EQU [esp+ 10]
P03                      EQU [esp+ 11]
P04                      EQU [esp+ 12]
P05                      EQU [esp+ 13]
P06                      EQU [esp+ 14]
P07                      EQU [esp+ 15]
P10                      EQU [esp+ 16]
P11                      EQU [esp+ 17]
P12                      EQU [esp+ 18]
P13                      EQU [esp+ 19]
P14                      EQU [esp+ 20]
P15                      EQU [esp+ 21]
P16                      EQU [esp+ 22]
P17                      EQU [esp+ 23]
P20                      EQU [esp+ 24]
P21                      EQU [esp+ 25]
P22                      EQU [esp+ 26]
P23                      EQU [esp+ 27]
P24                      EQU [esp+ 28]
P25                      EQU [esp+ 29]
P26                      EQU [esp+ 30]
P27                      EQU [esp+ 31]
P30                      EQU [esp+ 32]
P31                      EQU [esp+ 33]
P32                      EQU [esp+ 34]
P33                      EQU [esp+ 35]
P34                      EQU [esp+ 36]
P35                      EQU [esp+ 37]
P36                      EQU [esp+ 38]
P37                      EQU [esp+ 39]
P40                      EQU [esp+ 40]
P41                      EQU [esp+ 41]
P42                      EQU [esp+ 42]
P43                      EQU [esp+ 43]
P44                      EQU [esp+ 44]
P45                      EQU [esp+ 45]
P46                      EQU [esp+ 46]
P47                      EQU [esp+ 47]
P50                      EQU [esp+ 48]
P51                      EQU [esp+ 49]
P52                      EQU [esp+ 50]
P53                      EQU [esp+ 51]
P54                      EQU [esp+ 52]
P55                      EQU [esp+ 53]
P56                      EQU [esp+ 54]
P57                      EQU [esp+ 55]
P60                      EQU [esp+ 56]
P61                      EQU [esp+ 57]
P62                      EQU [esp+ 58]
P63                      EQU [esp+ 59]
P64                      EQU [esp+ 60]
P65                      EQU [esp+ 61]
P66                      EQU [esp+ 62]
P67                      EQU [esp+ 63]
P70                      EQU [esp+ 64]
P71                      EQU [esp+ 65]
P72                      EQU [esp+ 66]
P73                      EQU [esp+ 67]
P74                      EQU [esp+ 68]
P75                      EQU [esp+ 69]
P76                      EQU [esp+ 70]
P77                      EQU [esp+ 71]
I00I02                   EQU  P00  ; Intermed for row 0, columns 0 and 2. 
I01I03                   EQU  P04  ; Share storage with pels.
I04I06                   EQU [esp+ 72]
Mask00                   EQU [esp+ 72]
I07I05                   EQU [esp+ 76]
Mask04                   EQU [esp+ 76]
I10I12                   EQU  P10
I11I13                   EQU  P14
I14I16                   EQU [esp+ 80]
Mask10                   EQU [esp+ 80]
I17I15                   EQU [esp+ 84]
Mask14                   EQU [esp+ 84]
I20I22                   EQU  P20
I21I23                   EQU  P24
I24I26                   EQU [esp+ 88]
Mask20                   EQU [esp+ 88]
I27I25                   EQU [esp+ 92]
Mask24                   EQU [esp+ 92]
I30I32                   EQU  P30
I31I33                   EQU  P34
I34I36                   EQU [esp+ 96]
Mask30                   EQU [esp+ 96]
I37I35                   EQU [esp+100]
Mask34                   EQU [esp+100]
I40I42                   EQU  P40
I41I43                   EQU  P44
I44I46                   EQU [esp+104]
Mask40                   EQU [esp+104]
I47I45                   EQU [esp+108]
Mask44                   EQU [esp+108]
I50I52                   EQU  P50
I51I53                   EQU  P54
I54I56                   EQU [esp+112]
Mask50                   EQU [esp+112]
I57I55                   EQU [esp+116]
Mask54                   EQU [esp+116]
I60I62                   EQU  P60
I61I63                   EQU  P64
I64I66                   EQU [esp+120]
Mask60                   EQU [esp+120]
I67I65                   EQU [esp+124]
Mask64                   EQU [esp+124]
I70I72                   EQU  P70
I71I73                   EQU  P74
I74I76                   EQU [esp+128]
Mask70                   EQU [esp+128]
I77I75                   EQU [esp+132]
Mask74                   EQU [esp+132]
S4                       EQU  I10I12  ; Temp storage, shared.
S7                       EQU  I00I02  ; Temp storage, shared.
S3                       EQU  I30I32  ; Temp storage, shared.
S0                       EQU  I40I42  ; Temp storage, shared.

CoeffStreamStart         EQU [esp+  0]
CoeffStream              EQU [esp+  4]
BlkActionDescrAddr       EQU [esp+136]
FutureFrameBaseAddress   EQU [esp+140]
DistFromTargetToPastP    EQU [esp+144]
TargetFrameBaseAddress   EQU [esp+148]
PredictionsBaseAddress   EQU [esp+152]
IsPlainPFrame            EQU [esp+156]
PreviousFrameBaseAddress EQU [esp+160]
DistToBlockToLeft        EQU [esp+164]
DistToBlockAbove         EQU [esp+168]
DistToBlockToRight       EQU [esp+172]
DistToBlockBelow         EQU [esp+176]
DistFromBlk1ToBlk3Above  EQU [esp+180]
MBActionCursor           EQU [esp+184]
CentralRefAddrAndInterps EQU [esp+188]
StashESP                 EQU [esp+192]

  push  esi
   push edi
  push  ebp
   push ebx
  mov   ebx,esp
  sub   esp,LocalFrameSize+4
   mov  edi,[ebx+CoeffStream_arg]           ; Get address of storage for coeffs.
  and   esp,0FFFFFFC0H                      ; Get 64-byte aligned.
   xor  ebp,ebp
  add   esp,4                               ; esp at cache line plus 4.
   mov  esi,[ebx+MBlockActionStream]        ; Get address of MB action stream.
  mov   StashESP,ebx
   mov  edx,[ebx+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,edx
   mov  eax,[ebx+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,eax
   sub  eax,edx
  mov   ecx,[ebx+FutureFrameBaseAddress_arg]
  mov   FutureFrameBaseAddress,ecx
   mov  DistFromTargetToPastP,eax
  mov   CoeffStreamStart,edi
   xor  eax,eax
  xor   ecx,ecx

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
   cmp  ebp,[ebx+IsBFrame]
  mov   edx,PITCH
   jne  NextBMacroBlock

  cmp   ebp,[ebx+IsAdvancedPrediction]
   je   NextMacroBlock

  mov   eax,[ebx+ScratchBlocks]   ; We must do OBMC.
   mov  ecx,[esi].BlkY1.BlkOffset
  sub   eax,ecx
   mov  ebp,[ebx+IsPOfPBPair]
  xor   ebp,1
   mov  PredictionsBaseAddress,eax
  mov   IsPlainPFrame,ebp
   mov  ebp,[ebx+NumMBlksInGOB]
  imul  ebp,-SIZEOF T_MacroBlockActionDescr
  add   ebp,2*SIZEOF T_Blk
  mov   DistFromBlk1ToBlk3Above,ebp
  

;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  edx -- Address of a block to do
;  bl  -- BlockType;
;         MB edge condition:  1 off if left edge | 2: right | 4: top | 8: bottom
;  eax -- Coded block pattern for P block;
;         (Block_number - 1) *  SIZEOF T_Blk

NextMacroBlock_OBMC:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks        ; Bits  0- 3  set for non-empty Y blks.
                                       ; Bit      4  set for non-empty U blk.
                                       ; Bit      5  set for non-empty V blk.
                                       ; Bit      6  clear except at stream end.
                                       ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded_OBMC

  lea   edx,[esi].BlkY1+12             ; Addr of block addr (plus 12).
   test al,1                           ; Check if block 1 empty.
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block1DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax           ; Blk to left is blk 2 of mb to the left, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToLeft,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 2 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 3 of current macroblock.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY1
   jmp  BuildOBMCPrediction

Block1DescrBuilt:

  test  al,2                           ; Check if block 2 empty.
   lea  edx,[esi].BlkY2+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block2DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax          ; Blk to right is blk 1 of mb to right, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToRight,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,-SIZEOF T_Blk ; Blk to left is blk 1 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 4 of current macroblock.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY2
   jmp  BuildOBMCPrediction

Block1or2DescrBuilt:

  mov   al,PB [esi].CodedBlocks         ; Bits  0- 3  set for non-empty Y blks.
   mov  edi,CoeffStream                 ; Restore block descriptor ptr.
  jl    Block1DescrBuilt

Block2DescrBuilt:

  test  al,4                           ; Check if block 3 empty.
   lea  edx,[esi].BlkY3+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block3DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to left is blk 4 of mb to the left, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 1 of current mb.
  mov   DistToBlockToLeft,eax
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 4 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY3
   jmp  BuildOBMCPrediction

Block3DescrBuilt:

  test  al,8                           ; Check if block 4 empty.
   lea  edx,[esi].BlkY4+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block4DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to right is blk 3 of mb to right, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 2 of current mb.
  mov   DistToBlockToRight,eax
   mov  eax,-SIZEOF T_Blk  ; Blk to left is blk 3 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY4

BuildOBMCPrediction:

;  esi -- MacroBlockActionStream cursor
;  ebp -- T_MacroBlockActionDescr.BlkYN
;  edi -- Address at which to put prediction block

  mov   edi,PredictionsBaseAddress
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset; BlkOffset
  add   edi,eax                        ; Compute addr at which to put OBMC pred.
   mov  eax,[esi+ebp*1].T_Blk.MVs      ; al = horz MV;  ah = vert MV.
  test  eax,1
   mov  edx,[esi+ebp*1].T_Blk.PastRef  ; Fetch address for ref block.
  mov   MBActionCursor,esi
   jne  HorzInterpInCentralPred

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,PITCH
   jne  VertInterpInCentralPred

  ; No half pel interpolation for central point required.  Just copy it.

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8-080000000H    ; Address of ref, xor 10 in high 2 bits.
  jmp   CentralPredGottenForOBMC

HorzInterpInCentralPred:

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,1
   jne  BothInterpInCentralPred

VertInterpInCentralPred:

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  add   eax,[edx+ecx+0]
   add  ebx,[edx+ecx+4]
  add   eax,001010101H
   add  ebx,001010101H
  shr   eax,1
   and  ebx,0FEFEFEFEH
  shr   ebx,1
   and  eax,07F7F7F7FH
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8
  shl   ecx,30
  xor   edx,ecx            ; Address of ref, xor 00 in high 2 bits if vertically
  ;                        ; interpolated;  xor 01 if horizontally interpolated.
   jmp  CentralPredGottenForOBMC

BothInterpInCentralPred:
@@:
   
  mov   eax,[edx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[edx]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment OBMC prediction block pointer.
  mov   ecx,[edx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[edx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,ecx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  edx,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  eax,4
  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   and  eax,edi
  mov   [edi-4],ebx
   mov  [edi+8-4],ebx
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8         ; Advance to next line of block.
   add  edx,PITCH-8         ; Advance to next line of block.
  add   ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
   jnc  @b

   sub  edx,PITCH*8
  xor   edx,0C0000000H      ; Address of ref, xor 11 in high 2 bits.
   sub  edi,PITCH*8

CentralPredGottenForOBMC:

;  At this point, the central contribution to OBMC prediction is in its scratch
;  block, whose address has been written to PastRef in the block action descr.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to left.

  mov   eax,DistToBlockToLeft
   lea  ebx,[esi+ebp]
  add   ebx,eax            ; Address of block descriptor for block to the left.
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx            ; Address of macroblock descr for block to the left.
   mov  ah,IsPlainPFrame   ; 0 if P of PB;  1 if run-of-the-mill P frame.
  mov   ebx,[ebx].T_Blk.MVs
   mov  CentralRefAddrAndInterps,edx  ; Stash function of ref addr and interps.
  mov   al,[ecx].BlockType ; Bottom bit set if left neighbor is INTRA.
   mov  cl,bh
  and   al,ah              ; 0 if PB frame or if not INTRA
   jne  LeftPredGottenForOBMC  ; Jump if INTRA in plain P frame.  (Use central)
   
  shl   ebx,24             ; Get horz MV in [24:31].
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1              ; CF==1 if interp vertically.
   jc   InterpVertForTheLeftContrib

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpHorzForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,080000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also was not interpolated.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0]
  mov   [edi+PITCH*0+8],ebx
   mov  ebx,[ecx+PITCH*1]
  mov   [edi+PITCH*1+8],ebx
   mov  ebx,[ecx+PITCH*2]
  mov   [edi+PITCH*2+8],ebx
   mov  ebx,[ecx+PITCH*3]
  mov   [edi+PITCH*3+8],ebx
   mov  ebx,[ecx+PITCH*4]
  mov   [edi+PITCH*4+8],ebx
   mov  ebx,[ecx+PITCH*5]
  mov   [edi+PITCH*5+8],ebx
   mov  ebx,[ecx+PITCH*6]
  mov   [edi+PITCH*6+8],ebx
   mov  ebx,[ecx+PITCH*7]
  mov   [edi+PITCH*7+8],ebx
   jmp  LeftPredGottenForOBMC

InterpVertForTheLeftContrib:

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpBothForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax            ; Continue to accumulate left ref addr in eax.
  ;                        ; Hi 2 bits of central ref same as this ref if
  ;                        ; central ref also interpolated vertically.
  add   ecx,ebx            ; Finish accumulating left ref addr in ecx.
   mov  ebx,PITCH
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

DoInterpHorzForTheLeftContrib:
@@:

  mov   eax,[ecx+0]
   add  edi,PITCH
  mov   edx,[ecx+ebx+0]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+ 8-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpBothForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,0C0000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated both ways.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

@@:

  mov   eax,[ecx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[ecx]           ; <P03 P02 P01 P00>.
   add  edi,PITCH           ; Pre-increment OBMC prediction block pointer.
  mov   edx,[ecx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[ecx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,edx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  ecx,PITCH           ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.

  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   add  ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
  mov   [edi+8-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpHorzForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,040000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated horizontally.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
   mov  ebx,1
  cmp   ecx,edx            ; Is central ref the same?
   jne  DoInterpHorzForTheLeftContrib


LeftPredGottenForOBMC:

;  At this point, the left contribution to OBMC prediction is in its scratch
;  half block.  Now do the right contribution.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to right.

  mov   eax,DistToBlockToRight
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps  ; Reload function of ref addr and interps.
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  RightPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheRightContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+12],ebx
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+12],ebx
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+12],ebx
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+12],ebx
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+12],ebx
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+12],ebx
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+12],ebx
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+12],ebx
   jmp  RightPredGottenForOBMC

InterpVertForTheRightContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   RightPredGottenForOBMC

DoInterpHorzForTheRightContrib:
@@:

  mov   eax,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+ebx+4]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpBothForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

@@:

  mov   eax,[ecx+5]
   mov  esi,001010101H
  mov   ebx,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+PITCH+5]
   add  eax,ebx
  mov   ebx,[ecx+PITCH+4]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,PITCH
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax

  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpHorzForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheRightContrib

RightPredGottenForOBMC:

;  At this point, the left and right contributions to OBMC prediction are in
;  their scratch half blocks.  Now do the contribution for the block above.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockAbove
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  AbovePredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheAboveContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

  mov   edx,[ecx+PITCH*0+0]
   mov  ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+28],edx
   mov  [edi+PITCH*0+32],ebx
  mov   edx,[ecx+PITCH*1+0]
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+32],ebx
   mov  [edi+PITCH*1+28],edx
  mov   edx,[ecx+PITCH*2+0]
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+28],edx
   mov  [edi+PITCH*2+32],ebx
  mov   edx,[ecx+PITCH*3+0]
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+32],ebx
   mov  [edi+PITCH*3+28],edx
  jmp   AbovePredGottenForOBMC

InterpVertForTheAboveContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

DoInterpHorzForTheAboveContrib:
@@:

  mov   eax,[ecx+0]
   mov  edx,[ecx+4]
  add   eax,[ecx+ebx+0]
   add  edx,[ecx+ebx+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+28],eax
   mov  [edi+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpBothForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

@@:

  mov   eax,[ecx+1]
   mov  esi,001010101H
  mov   ebx,[ecx]
   add  edi,4
  mov   edx,[ecx+PITCH+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpHorzForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheAboveContrib

AbovePredGottenForOBMC:

;  At this point, the left, right, and above contributions to OBMC prediction
;  are in their scratch half blocks.  Now do contribution for the block below.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockBelow
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  BelowPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheBelowContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

  mov   edx,[ecx+PITCH*4+0]
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+28],edx
   mov  [edi+PITCH*4+32],ebx
  mov   edx,[ecx+PITCH*5+0]
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+32],ebx
   mov  [edi+PITCH*5+28],edx
  mov   edx,[ecx+PITCH*6+0]
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+28],edx
   mov  [edi+PITCH*6+32],ebx
  mov   edx,[ecx+PITCH*7+0]
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+32],ebx
   mov  [edi+PITCH*7+28],edx
  jmp   BelowPredGottenForOBMC

InterpVertForTheBelowContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
  add   ecx,eax
   mov  ebx,PITCH
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

DoInterpHorzForTheBelowContrib:
@@:

  mov   eax,[ecx+PITCH*4+0]
   mov  edx,[ecx+PITCH*4+4]
  add   eax,[ecx+ebx+PITCH*4+0]
   add  edx,[ecx+ebx+PITCH*4+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+PITCH*4+28],eax
   mov  [edi+PITCH*4+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpBothForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

@@:

  mov   eax,[ecx+PITCH*4+1]
   mov  esi,001010101H
  mov   ebx,[ecx+PITCH*4]
   add  edi,4
  mov   edx,[ecx+PITCH*5+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH*5]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+PITCH*4+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpHorzForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheBelowContrib

BelowPredGottenForOBMC:

;  At this point all the contributions to OBMC prediction are in their scratch
; half blocks.  Now combine them to get the OBMC prediction.
;
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
  
@@:

  mov   eax,[edi+4]             ; <C07 C05 C05 C04> or <C77 C76 C75 C74>
   mov  ebx,[edi+12]            ; <R07 R06 R05 R04> or <R77 R76 R75 R74>
  mov   ecx,[edi+32]            ; <A07 A06 A05 A04> or <B77 B76 B75 B74>
   mov  esi,[edi]               ; <C03 C02 C01 C00> or <C73 C72 C71 C70>
  lea   edx,[eax+ebx]           ; <junk C6+R6 C5+R5 C4+R4>
   and  ebx,0FF000000H          ; <R7 __ __ __>
  shr   edx,1                   ; <junk (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> dirty
   add  ecx,ebx                 ; <A7+R7 A6 A5 A4>
  and   edx,0007F7F7FH          ; <__ (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> clean
   mov  ebx,[edi+8]             ; <L03 L02 L01 L00> or <L73 L72 L71 L70>
  add   edx,ecx                 ; <(2A7+2R7)/2 (2A6+C5+R5)/2 ...>
   add  edi,PITCH*7             ; Move from line 0 to 7 (or 7 to 14)
  shr   edx,1                   ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> dirty
   add  ebx,esi                 ; <C3+L3 C2+L2 C1+L1 junk>
  shr   ebx,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> dirty
   and  edx,07F7F7F7FH          ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> clean
   mov  ecx,[edi+28-PITCH*7]    ; <A03 A02 A01 A00> or <B73 B72 B71 B70>
  lea   eax,[eax+edx+001010101H]; <(2A7+4C7+2R7+4)/4 (2A6+5C5+R5+4)/4 ...>
   mov  bl,[edi+8-PITCH*7]      ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 L0>
  shr   eax,1                   ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> dirty
   add  ebx,ecx                 ; <... (2A1+C1+L1)/2 (2A0+2L0)/2>
  shr   ebx,1                   ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> dirty
   and  eax,07F7F7F7FH          ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> clean
  and   ebx,07F7F7F7FH          ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> clean
   add  esi,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  add   ebx,esi                 ; <... (2A1+5C1+L1+4)/4 (2A0+4C0+2L0+4)/4>
   mov  [edi+4-PITCH*7],eax     ; Store OBMC pred for pels 4-7 of line 0 or 7.
  shr   ebx,1                   ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> dirty
   lea  esi,[edi-PITCH*13]      ; Speculatively advance to line 1.
  and   ebx,07F7F7F7FH          ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> clean
   add  ebp,080000000H
  mov   [edi-PITCH*7],ebx       ; Store OBMC pred for pels 0-3 of line 0 or 7.
   jnc  @b

@@:

  mov   edx,[esi+28]            ; <A13 A12 A11 A10> or <B63 B62 B61 B60>
   mov  eax,[esi+8]             ; <L13 L12 L11 L10> or <L63 L62 L61 L60>
  mov   ecx,[esi+32]            ; <A17 A16 A15 A14> or <B67 B66 B65 B64>
   mov  ebx,[esi+12]            ; <R17 R16 R15 R14> or <R67 R66 R65 R64>
  mov   edi,[esi]               ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   add  esi,PITCH*5             ; Move from line 1 to 6 (or 6 to 11)
  xchg  dx,ax                   ; edx: <A3 A2 L1 L0>   eax: <L3 L2 A1 A0>
  xchg  cx,bx                   ; ecx: <A7 A6 R5 R4>   ebx: <R7 R6 A5 A4>
  add   eax,edi                 ; <C3+L3 C2+L2 C1+A1 C0+A0>
   mov  edi,[esi+4-PITCH*5]     ; <C17 C15 C15 C14> or <C67 C66 C65 C64>
  shr   eax,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   add  ecx,edi                 ; <C7+A7 C6+A6 C5+R5 C4+R4>
  shr   ecx,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>dirty
   and  eax,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>clean
  add   eax,edx                 ; <(C3+L3+2A3)/2 ... (C1+2L1+A1)/2 ...>
   and  ecx,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>clean
  shr   eax,1                   ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,ebx                 ; <(C7+2R7+A7)/2 ... (C5+R5+2A5)/2 ...>
  mov   ebx,[esi-PITCH*5]       ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   and  eax,07F7F7F7FH          ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> clean
  shr   ecx,1                   ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> dirty
   add  edi,001010101H          ; <C7+1 C6+1 C5+1 C4+1>
  and   ecx,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> clean
   lea  eax,[eax+ebx+001010101H]; <(5C3+L3+2A3+4)/4 ... (5C1+2L1+A1)/4 ...>
  shr   eax,1                   ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>dirty
   add  ecx,edi                 ; <(5C7+2R7+A7+4)/4 ... (5C5+R5+2A5)/4 ...>
  shr   ecx,1                   ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>dirty
   and  eax,07F7F7F7FH          ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>clean
  and   ecx,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>clean
   mov  [esi-PITCH*5],eax       ; Store OBMC pred for pels 4-7 of line 1 or 6.
  mov   [esi+4-PITCH*5],ecx     ; Store OBMC pred for pels 0-3 of line 1 or 6.
   lea  edi,[esi-PITCH*9]       ; Speculatively advance to line 2.
  add   ebp,080000000H
   jnc  @b

@@:

  mov   eax,[edi+4]             ; <C27 C26 C25 C24> ... <C57 C56 C55 C54>
   mov  ebx,[edi+12]            ; <R27 R26 R25 R24> ... <R57 R56 R55 R54>
  add   bl,al                   ; <R7 R6 R5 C4+R4>
   mov  ecx,[edi]               ; <C23 C22 C21 C20> ... <C53 C52 C51 C50>
  shr   bl,1                    ; <R7 R6 R5 (C4+R4)/2>
   mov  edx,[edi+8]             ; <L23 L22 L21 L20> ... <L53 L52 L51 L50>
  add   bh,ah                   ; <R7 R6 C5+R5 (C4+R4)/2>
   add  edx,ecx                 ; <C3+L3 C2+L2 junk junk>
  shr   bh,1                    ; <2R7/2 2R6/2 (C5+R5)/2 (C4+R4)/2>
   mov  esi,[edi+32]            ; <A27 A26 A25 A24> ... <B57 B56 B55 B54>
  shr   edx,1                   ; <(C3+L3)/2 (C2+L2)/2 junk junk> dirty
   add  esi,eax                 ; <C7+A7 C6+A6 C5+A5 C4+A4>
  shr   esi,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>dirty
   and  edx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 junk junk> clean
  and   esi,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>clean
   mov  dl,[edi+8]              ; <(C3+L3)/2 (C2+L2)/2 junk 2L0/2>
  add   esi,ebx                 ; <(C7+2R7+A7)/2 ... (2C5+R5+A5)/2 ...>
   mov  ebx,[edi+28]            ; <A23 A22 A21 A20> ... <B53 B52 B51 B50>
  shr   esi,1                   ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> dirty
   add  ebx,ecx                 ; <C3+A3 C2+A2 C1+A1 C0+A0>
  shr   ebx,1                   ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   and  esi,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>clean
   mov  dh,[edi+9]              ; <(C3+L3)/2 (C2+L2)/2 2L1/2 2L0/2>
  add   ebx,edx                 ; <(2C3+L3+A3)/2 ... (C1+2L1+A1)/2 ...>
   lea  eax,[eax+esi+001010101H]; <(5C7+2R7+A7+4)/4 ... (6C5+R5+A5+4)/4 ...>
  shr   ebx,1                   ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  shr   eax,1                   ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>dirty
   and  ebx,07F7F7F7FH          ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> clean
  add   ebx,ecx                 ; <(6C3+L3+A3+4)/4 ... (5C1+2L1+A1+4)/4 ...>
   and  eax,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>clean
  shr   ebx,1                   ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>dirty
   mov  [edi+4],eax             ; Store OBMC pred for pels 4-7 of line 2 thru 5.
  and   ebx,07F7F7F7FH          ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>clean
   mov  [edi],ebx               ; Store OBMC pred for pels 0-3 of line 2 thru 5.
  add   edi,PITCH               ; Advance to next line.
   add  ebp,040000000H
  jnc   @b

  mov   esi,MBActionCursor
   cmp  ebp,T_MacroBlockActionDescr.BlkY2
  jle   Block1or2DescrBuilt

  mov   al,PB [esi].CodedBlocks
   mov  edi,CoeffStream                ; Restore block descriptor ptr.
  cmp   ebp,T_MacroBlockActionDescr.BlkY3
   je   Block3DescrBuilt

Block4DescrBuilt:

  shr   al,5                           ; Check if block 5 (U) empty.
   lea  edx,[esi].BlkU+4               ; Addr of block addr (plus 4).
  sbb   ebp,ebp                        ; -1 iff block not empty.
   mov  [edi].BlockAddr,edx            ; Store address of block address.
  shr   al,1                           ; Check if block 6 (Y) empty.
   lea  edx,[esi].BlkV+4               ; Addr of block addr (plus 4).
  sbb   ebx,ebx                        ; -1 iff block not empty.
   and  ebp,T_CoeffBlk                 ; 0 iff block empty, else inc. 
  and   ebx,T_CoeffBlk                 ; 0 iff block empty, else inc. 
   add  esi,SIZEOF T_MacroBlockActionDescr ; Move to next macroblock descriptor.
  mov   [edi+ebp*1].BlockAddr,edx      ; Store address of block address.
   add  edi,ebp                        ; Inc block descr ptr if blk non-empty.
  add   edi,ebx                        ; Inc block descr ptr if blk non-empty.
   xor  ebp,ebp
  and   al,1                           ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; partial end of section only defined when H261 not defined.
ENDIF
  
BuildBlockActionDescr MACRO BlockNumber,AddrOffset
  shr   al,1                                  ; Check if block empty.
   lea  edi,[edi+ebp]                         ; Adjust BlockActionDescr cursor.
  sbb   ebp,ebp                               ; -1 iff block not empty.
   lea  edx,[esi].Blk[BlockNumber*SIZEOF T_Blk]+AddrOffset ; Addr of block addr.
  and   ebp,T_CoeffBlk                        ; 0 iff block empty, else inc. 
   mov  [edi].BlockAddr,edx                   ; Store address of block address.
ENDM

IFNDEF H261
;; more code only used when H261 not defined

MBIsIntraCoded_OBMC:

  shr   al,1        ; Same as BuildBlockActionDescr macro, except don't inc edi.
  sbb   ebp,ebp
   lea  edx,[esi].BlkY1
  and   ebp,T_CoeffBlk
   mov  [edi].BlockAddr,edx
  BuildBlockActionDescr 1,0  ; If blk 2 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   add  edi,ebp
  test  al,1                                ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; end of section only defined when H261 not defined.
ENDIF
;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  al  -- Coded block pattern for I or P block
;  bl  -- BlockType

NextMacroBlock:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks  ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded

  BuildBlockActionDescr 0,4  ; If blk 1 non-empty, record BAD to do as inter.
  BuildBlockActionDescr 1,4  ; blk 2
  BuildBlockActionDescr 2,4  ; blk 3
  BuildBlockActionDescr 3,4  ; blk 4
  BuildBlockActionDescr 4,4  ; blk 5
  BuildBlockActionDescr 5,4  ; blk 6
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt
  
MBIsIntraCoded:

  BuildBlockActionDescr 0,0  ; If blk 1 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 1,0  ; blk 2
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt


NextBMacroBlock:

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  cl  -- Used to compute defined columns mask case.
;  bh  -- Coded block pattern for B block
;  bl  -- Coded block pattern for I or P block
;  al  -- Used to compute defined rows mask.

BuildBBlockActionDescr MACRO BlkNum,LinesDefFutureFrame,ColsDefFutureFrame
  shr   bh,1                                        ; Check if block empty.
   mov  cl,[esi].Blk[BlkNum*SIZEOF T_Blk].BestHMVb  ; HMVb for block.
  lea   edi,[edi+ebp]                               ; Adjust BlockActionDescr.
   mov  al,[esi].Blk[BlkNum*SIZEOF T_Blk].BestVMVb  ; VMVb for block.
  sbb   ebp,ebp                                     ; -1 iff block not empty.
   mov  cl,ColsDefFutureFrame[ecx-96]           ; Case of columns to do bidi.
  and   ebp,T_CoeffBlk                          ; 0 iff block empty, else inc. 
   mov  al,LinesDefFutureFrame[eax-96]          ; Mask for lines to do bidi.
  mov   [edi].LinesDefined,al                   ; Stash it.
   mov  edx,ColsDefined[ecx]
  mov   [edi].Cols03Defined,edx                 ; Stash it.
   mov  edx,ColsDefined[ecx+4]
  mov   [edi].Cols47Defined,edx                 ; Stash it.
   lea  edx,[esi].Blk[BlkNum*SIZEOF T_Blk]+8    ; Addr of block addr.
  mov   [edi].BlockAddr,edx                     ; Store address of blk address.
ENDM

  mov   ebx,PD [esi].CodedBlocks ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
                                 ; Bits  8-13  like bits 0-5, but for B frame.
                                 ; Bit  14-15  clear.  Unused.

  BuildBBlockActionDescr 0, UpperYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 1, UpperYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 2, LowerYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 3, LowerYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 4, ChromaLinesDef,    ChromaColsDef
  BuildBBlockActionDescr 5, ChromaLinesDef,    ChromaColsDef
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  bl,040H                             ; Are we at end-of-stream?
  je    NextBMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
  
BlockActionStreamBuilt:

  mov   CoeffStream,edi         ; Stash address of last block of coeffs.

NextBlock:

;===============================================================================
;===============================================================================
; Second pass performs frame differencing of Inters and Forward DCT.
;===============================================================================
;===============================================================================

  mov   eax,[edi].BlockAddr          ; Fetch address of block to do
   mov  ebp,PITCH
  test  eax,4                        ; Is it an Inter block.
   jne  InterOrOBMCBlock             ; Jump if doing inter block.

  mov   edx,[eax].T_Blk.BlkOffset    ; BlkOffset if INTRA;  BestMVs if BiDi.
   mov  ecx,TargetFrameBaseAddress
  add   ecx,edx                      ; Target block address if INTRA
   mov  esi,[eax-8].T_Blk.BlkOffset  ; Addr of BlkOffset if BiDi

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;
  test  eax,8                        ; Is it a BiDi block?
   jne  BiDiBlock                    ; Jump if doing BiDi block.
ENDIF

IntraBlock:

; Register usage:
;   ecx,edi -- Address of block.
;   ebp -- Pitch.
;   ebx, eax -- Scratch.

  mov   ebx,[ecx]
   mov  eax,[ecx+4]
  mov   P00,ebx
   mov  P04,eax
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  lea   edi,[ecx+PITCH*5]
   lea  ecx,[ecx+ebp*2]
  mov   P10,eax
   mov  P14,edx
  mov   eax,[ecx]
   mov  edx,[ecx+4]
  mov   P20,eax
   mov  P24,edx
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  mov   P30,eax
   mov  P34,edx
  mov   eax,[ecx+ebp*2]
   mov  edx,[ecx+ebp*2+4]
  mov   P40,eax
   mov  P44,edx
  mov   eax,[edi]
   mov  edx,[edi+4]
  mov   P50,eax
   mov  P54,edx
  mov   eax,[edi+ebp*1]
   mov  edx,[edi+ebp*1+4]
  mov   P60,eax
   mov  P64,edx
  mov   eax,[edi+ebp*2]
   mov  edx,[edi+ebp*2+4]
  mov   P74,edx
   xor  ecx,ecx
  and   ebx,00000007FH                      ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  mov   P70,eax
   jmp  DoForwardDCT

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;

BiDiBlock:

  mov   BlkActionDescrAddr,eax               ; Extract VMVb.
   mov  ebp,FutureFrameBaseAddress
  shr   edx,25                               ; CF == 1 iff VMVb is half pel.
   mov  bl,[edi].LinesDefined
  lea   esi,[esi+ebp-48]                     ; Addr 0-MV blk in Future P Frame.
   mov  ebp,[edi].Cols47Defined
IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF
  lea   ecx,[edx+edx*2-48*3]                 ; Mult integer pel VMVb by PITCH.
   mov  edi,[edi].Cols03Defined
  mov   dl,[eax-8].T_Blk.BestHMVb            ; Fetch HMVb.
   jc   InterpVert_FuturePFrame

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpHorz_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   mov  Mask00+4,eax                    ; 0E  Stash Mask for use with past pred.
  and   eax,ecx                         ; 0F  Select in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  mov   P00+4,eax                       ; 0G  Stash in-range pels.
   and  edx,edi                         ; 1D
  mov   Mask10+4,edx                    ; 1E
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1F
  mov   P10+4,edx                       ; 1G
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   mov  Mask20+4,eax                    ; 2E
  and   eax,ecx                         ; 2F
   mov  ecx,[esi+PITCH*3]               ; 3C
  mov   P20+4,eax                       ; 2G
   and  edx,edi                         ; 3D
  mov   Mask30+4,edx                    ; 3E
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3F
  mov   P30+4,edx                       ; 3G
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   mov  Mask40+4,eax                    ; 4E
  and   eax,ecx                         ; 4F
   mov  ecx,[esi+PITCH*5]               ; 5C
  mov   P40+4,eax                       ; 4G
   and  edx,edi                         ; 5D
  mov   Mask50+4,edx                    ; 5E
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5F
  mov   P50+4,edx                       ; 5G
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   mov  Mask60+4,eax                    ; 6E
  and   eax,ecx                         ; 6F
   mov  ecx,[esi+PITCH*7]               ; 7C
  mov   P60+4,eax                       ; 6G
   and  edx,edi                         ; 7D
  mov   Mask70+4,edx                    ; 7E
   and  edx,ecx                         ; 7F
  mov   P70+4,edx                       ; 7G
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   add  esi,4
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpVert_FuturePFrame:

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpBoth_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+PITCH*1]               ; 0E  Fetch Future P10:P13.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P10:P13.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*2]               ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*3]               ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*4]               ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*5]               ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*6]               ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*7]               ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*8-4]             ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpHorz_FuturePFrame:

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Horizontally.

  add   esi,edx                              ; Add HMVb contrib to block addr.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+1]                     ; 0E  Fetch Future P01:P04.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P01:P04.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*1+1]             ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*2+1]             ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*3+1]             ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*4+1]             ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*5+1]             ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*6+1]             ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*7+1-4]           ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpBoth_FuturePFrame:

  add   esi,edx                              ; Add HMVb contrib to block addr.
   sub  esp,68

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  add   esp,8
   mov  eax,[esi]           ; Fetch Future P00:P03.
  mov   ecx,001010101H      ; Mask to extract halves.
   mov  edx,[esi+1]         ; Fetch Future P01:P04.
  add   eax,edx             ; <P04+P03 ...>.
   mov  edx,[esi+PITCH+1]   ; Fetch Future P11:P14.
  and   ecx,eax             ; <(P04+P03)&1 ...>.
   add  esi,PITCH           ; Advance to next line.
  xor   eax,ecx             ; <(P04+P03)/2*2 ...>.
   add  edx,ecx             ; <P14+((P04+P03)&1) ...>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   mov  ecx,[esi]           ; Fetch Future P10:P13.
  add   edx,ecx             ; <P14+P13+((P04+P03)&1) ...>.
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>
  shr   edx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  bl,bl               ; CF == 1 iff line 0 in range.
  sbb   ecx,ecx             ; ecx == -1 if line 0 in range.
   and  edx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
  add   eax,edx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   and  ecx,edi             ; In range among P00,P01,P02,P03.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  Mask00+60,ecx       ; Stash Mask for use with past prediction.
  and   eax,ecx             ; Select in-range pels from future pred (and clean).
  test  esp,000000038H
  mov   P00+60,eax          ; Stash in-range pels.
   jne  @b

  sub   esi,PITCH*8-4       ; Move to right 4 columns.
   mov  edx,BlkActionDescrAddr
  mov   edi,ebp
   sub  esp,60
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   jne  @b

  add   esp,60
   xor  eax,eax
  mov   edi,[edx-8].T_Blk.BlkOffset
   mov  al,[edx-8].T_Blk.BestVMVf

BiDiFuturePredDone:

  shr   al,1                                 ; CF == 1 iff VMVf is half pel.
   mov  esi,TargetFrameBaseAddress
  mov   cl,[edx-8].T_Blk.BestHMVf
   mov  edx,DistFromTargetToPastP
  lea   edi,[edi+esi]
   jc   InterpVert_PastPFrame

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpHorz_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  ebx,Mask00+64       ; 0B  Fetch bidi-prediction mask.
  mov   ecx,P00+64          ; 0C  Fetch future pred for bidi predicted pels.
   and  ebx,eax             ; 0D  Extract past for bidi predicted pels.
  mov   edx,[esi+4]         ; 4A
   mov  ebp,Mask04+64       ; 4B
  lea   eax,[ecx+eax*2]     ; 0E  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4C
  sub   eax,ebx             ; 0F  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4D
  shr   eax,1               ; 0G  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4E
  and   eax,07F7F7F7FH      ; 0H  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4F
  shr   edx,1               ; 4G
   mov  ebx,[edi]           ; 0I  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4H
   mov  ebp,[edi+4]         ; 4I
  sub   ebx,eax             ; 0J  Compute correction.
   sub  ebp,edx             ; 4J
  add   ebx,080808080H      ; 0K  Bias correction.
   add  ebp,080808080H      ; 4K
  mov   P00+64,ebx          ; 0K  Store correction.
   mov  P04+64,ebp          ; 4K
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT
   

InterpVert_PastPFrame:

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpBoth_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+PITCH]     ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+PITCH+4]   ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorz_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+1]         ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+5]         ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpBoth_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi+1]       ; 0A <P04 P03 P02 P01> prediction pels.
   mov  ebx,001010101H    ; 0B Mask for extraction of halves.
  mov   ebp,[esi+PITCH+1] ; 0C <P14 P13 P12 P11>.
   mov  ecx,[esi]         ; 0D <P03 P02 P01 P00>.
  add   eax,ecx           ; 0E <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ecx,[esi+PITCH]   ; 0F <P13 P12 P11 P10>.
  and   ebx,eax           ; 0G <(P04+P03)&1 ...>.
   and  eax,0FEFEFEFEH    ; 0H Pre-Clean
  shr   eax,1             ; 0I <(P04+P03)/2 ...>.
   add  ecx,ebp           ; 0J <P14+P13 P13+P12 P12+P11 P11+P10>.
  add   eax,001010101H    ; 0K <(P04+P03)/2+1 ...>.
   add  ecx,ebx           ; 0L <P14+P13+((P04+P03)&1) ...>.
  shr   ecx,1             ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   mov  edx,[esi+5]       ; 4A
  and   ecx,07F7F7F7FH    ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   mov  ebx,001010101H    ; 4B
  add   eax,ecx           ; 0N <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebp,[esi+PITCH+5] ; 4C
  shr   eax,1             ; 0O <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>
   mov  ecx,[esi+4]       ; 4D
  and   eax,07F7F7F7FH    ; 0P Interpolated prediction.
   add  edx,ecx           ; 4E
  mov   ecx,[esi+PITCH+4] ; 4F
   and  ebx,edx           ; 4G
  and   edx,0FEFEFEFEH    ; 4H
   add  ecx,ebp           ; 4J
  shr   edx,1             ; 4I
   add  ecx,ebx           ; 4L
  shr   ecx,1             ; 4M
   add  edx,001010101H    ; 4K
  and   ecx,07F7F7F7FH    ; 4M
   mov  ebx,Mask00+64     ; 0Q  Fetch bidi-prediction mask.
  add   edx,ecx           ; 4N
   mov  ecx,P00+64        ; 0R  Fetch future pred for bidi predicted pels.
  shr   edx,1             ; 4O
   and  ebx,eax           ; 0S  Extract past for bidi predicted pels.
  and   edx,07F7F7F7FH    ; 4P
   mov  ebp,Mask04+64     ; 4Q
  lea   eax,[ecx+eax*2]   ; 0T  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64        ; 4R
  sub   eax,ebx           ; 0U  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx           ; 4S
  shr   eax,1             ; 0V  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]   ; 4T
  and   eax,07F7F7F7FH    ; 0W  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp           ; 4U
  shr   edx,1             ; 4V
   mov  ebx,[edi]         ; 0X  Fetch target pels.
  and   edx,07F7F7F7FH    ; 4W
   mov  ebp,[edi+4]       ; 4X
  sub   ebx,eax           ; 0Y  Compute correction.
   sub  ebp,edx           ; 4Y
  add   ebx,080808080H    ; 0Z  Bias correction.
   add  ebp,080808080H    ; 4Z
  mov   P00+64,ebx        ; 0a  Store correction.
   mov  P04+64,ebp        ; 4a
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT

;; end of section of code not define when H261 defined
ENDIF

InterOrOBMCBlock:

  mov   esi,TargetFrameBaseAddress
   mov  edi,[eax-4].T_Blk.BlkOffset   ; Compute Addr of Target block.

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
  test  eax,8
   jne  OBMCBlock
ENDIF

  add   edi,esi
   mov  esi,[eax-4].T_Blk.PastRef     ; Addr of PrevRef block.
  mov   eax,[eax-4].T_Blk.MVs         ; al = Horz MV;  ah = Vert MV
   mov  ecx,080808080H

IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;
  test  al,1
   jne  InterpHorzOrBoth

ENDIF

  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]
  test  ah,1
   je   NoInterp


IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;

InterpVert:
InterpHorz:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebx -- Address of reference plus either 1 or PITCH, for interpolation.
;   ebp, edx, ecx, eax -- Scratch.

  sub   esp,16

@@:
  add   esp,4
   mov  eax,[esi]               ; 0A  <P03 P02 P01 P00> prediction pels.
  mov   ecx,[ebx]               ; 0B  <P04 ...> or <P13 ...> prediction pels.
   mov  edx,[edi]               ; 0C  <C03 C02 C01 C00> current pels.
  add   edx,080808080H          ; 0D  Add bias.
   mov  ebp,[esi+PITCH*2]       ; 2A
  lea   eax,[eax+ecx+001010101H]; 0E  Sum of pred pels to interpolate.
   mov  ecx,[ebx+PITCH*2]       ; 2B
  shr   eax,1                   ; 0F  Average of prediction pels (dirty).
  and   eax,07F7F7F7FH          ; 0G  Average of prediction pels (clean). 
   lea  ebp,[ebp+ecx+001010101H]; 2E
  sub   edx,eax                 ; 0H  Current - interpolated prediction, biased.
   mov  eax,[edi+PITCH*2]       ; 2C
  mov   P00+12,edx              ; 0I  Save correction.
   add  eax,080808080H          ; 2D
  shr   ebp,1                   ; 2F
   mov  edx,[esi+PITCH*4]       ; 4A
  and   ebp,07F7F7F7FH          ; 2G
   mov  ecx,[ebx+PITCH*4]       ; 4B
  sub   eax,ebp                 ; 2H
   mov  ebp,[edi+PITCH*4]       ; 4C
  mov   P20+12,eax              ; 2I
   lea  ecx,[ecx+edx+001010101H]; 4E
  shr   ecx,1                   ; 4F
   add  ebp,080808080H          ; 4D
  and   ecx,07F7F7F7FH          ; 4G
   mov  eax,[esi+PITCH*6]       ; 6A
  sub   ebp,ecx                 ; 4H
   mov  ecx,[ebx+PITCH*6]       ; 6B
  mov   P40+12,ebp              ; 4I
   mov  ebp,[edi+PITCH*6]       ; 6C
  lea   ecx,[ecx+eax+001010101H]; 6E
   add  ebp,080808080H          ; 6D
  shr   ecx,1                   ; 6F
   add  esi,4
  and   ecx,07F7F7F7FH          ; 6G
   add  ebx,4
  sub   ebp,ecx                 ; 6H
   add  edi,4
  test  esp,4
  mov   P60+12,ebp              ; 6I
   je   @b

  add   esi,PITCH-8
   add  edi,PITCH-8
  test  esp,8
  lea   ebx,[ebx+PITCH-8]
   jne  @b

  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorzOrBoth:

  lea   ebx,[esi+1]
  test  ah,1
   je   InterpHorz


InterpBoth:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebp -- Pitch and scratch.
;   edx, ebx, eax -- Scratch.

  sub   esp,64

@@:

  mov   eax,[esi+1]         ; <P04 P03 P02 P01> prediction pels.
   lea  edx,[ecx*2+1]       ; Get 001010101H mask.
  mov   ebx,[esi]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment target block pointer.
  add   eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ebx,[esi+ebp*1+1]   ; <P14 P13 P12 P11>.
  and   edx,eax             ; <(P04+P03)&1 ...>.
   mov  ebp,[esi+ebp*1]     ; <P13 P12 P11 P10>.
  xor   eax,edx             ; Clear insignificant fractional bit in each byte.
   add  ebx,ebp             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   add  ebx,edx             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  esi,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   lea  eax,[eax+ecx*2+1]   ; <(P04+P03)/2+1 ...>.
  add   eax,ebx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebx,[edi-4]         ; <C03 C02 C01 C00> current pels.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   add  ebx,ecx             ; Add bias.
  and   eax,07F7F7F7FH      ; Interpolated prediction.
   add  esp,4               ; Advance frame difference pointer.
  sub   ebx,eax             ; Correction.
   mov  ebp,PITCH           ; Reload Pitch.
  test  esp,4
  mov   P00+60,ebx          ; Save correction.
   je   @b

  lea   esi,[esi+ebp-8]
   xor  ebx,ebx
  test  esp,000000038H
  lea   edi,[edi+ebp-8]
   jne  @b

  mov   bl,P00                              ; Fetch P0.
   xor  ecx,ecx
  mov   cl,P03                              ; Fetch P3.
   jmp  DoForwardDCT


OBMCBlock:   ; Do OBMC frame differencing.  OBMC prediction computed above. 

  mov   ecx,080808080H
   mov  edi,[eax-12].T_Blk.BlkOffset  ; Compute Addr of Target block.
  add   edi,esi
   mov  esi,[eax-12].T_Blk.PastRef     ; Addr of PrevRef block.
  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]

;; end of section of code not included when H261 defined
ENDIF

NoInterp:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebp -- Pitch.
;   edx -- Pitch times 3.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebx, eax -- Scratch.

@@:

  xor   esp,4                   ; 1st time: Back off to cache line;
   mov  eax,[edi]               ; 0A  <C3 C2 C1 C0> current pels.
  add   eax,ecx                 ; 0C  Add bias.
   mov  ebx,[esi]               ; 0B  <P3 P2 P1 P0> prediction pels.
  sub   eax,ebx                 ; 0D  <Cn-Pn> Current - pred, biased.
   mov  ebx,[esi+ebp*1]         ; 1B
  mov   P00+4,eax               ; 0E  Save <Corr3 Corr2 Corr1 Corr0>
   mov  eax,[edi+ebp*1]         ; 1A
  sub   eax,ebx                 ; 1D
   mov  ebx,[esi+ebp*2]         ; 2B
  add   eax,ecx                 ; 1C
   sub  ebx,ecx                 ; 2C
  mov   P10+4,eax               ; 1E
   mov  eax,[edi+ebp*2]         ; 2A
  sub   eax,ebx                 ; 2D
   mov  ebx,[esi+ebp*4]         ; 4B
  mov   P20+4,eax               ; 2E
   mov  eax,[edi+ebp*4]         ; 4A
  sub   eax,ebx                 ; 4D
   mov  ebx,[esi+edx*1]         ; 3B
  add   eax,ecx                 ; 4C
   sub  ebx,ecx                 ; 3C
  mov   P40+4,eax               ; 4E
   mov  eax,[edi+edx*1]         ; 3A
  sub   eax,ebx                 ; 3D
   mov  ebx,[esi+edx*2]         ; 6B
  mov   P30+4,eax               ; 3E
   lea  esi,[esi+ebp+4]         ; Advance to line 1.
  mov   eax,[edi+edx*2]         ; 6A
   lea  edi,[edi+ebp+4]         ; Advance to line 1.
  sub   eax,ebx                 ; 6D
   mov  ebx,[esi+ebp*4-4]       ; 5B
  add   eax,ecx                 ; 6C
   sub  ebx,ecx                 ; 5C
  mov   P60+4,eax               ; 6E
   mov  eax,[edi+ebp*4-4]       ; 5A
  sub   eax,ebx                 ; 5D
   mov  ebx,[esi+edx*2-4]       ; 7B
  mov   P50+4,eax               ; 5E
   mov  eax,[edi+edx*2-4]       ; 7A
  sub   eax,ebx                 ; 7D
   sub  edi,ebp                 ; Back off to line 0.
  add   eax,ecx                 ; 7C
   sub  esi,ebp                 ; Back off to line 0.
  test  esp,4                   ; Do twice.
  mov   P70+4,eax               ; 7E
   je   @b

  xor   ecx,ecx
   xor  ebx,ebx
  mov   bl,P00                  ; Fetch P0.
   mov  cl,P03                  ; Fetch P3.

DoForwardDCT:

;=============================================================================
;
;  This section does the Forward Discrete Cosine Transform.  It performs a DCT
;  on a 8*8 block of pels or pel differences.  The row transforms are done
;  first using a table lookup method.  Then the columns are done, using
;  computation.
;
;
; Each intermediate and coefficient is a short.  There are four fractional
; bits.  All coefficients except an intrablock's DC are biased by 08000H.

; Perform row transforms.
;
; Register usage:
;   ebp - Accumulator for contributions to intermediates I0 (hi) and I2 (lo).
;   edi - Accumulator for contributions to intermediates I1 (hi) and I3 (lo).
;   esi - Accumulator for contributions to intermediates I4 (hi) and I6 (lo).
;   edx - Accumulator for contributions to intermediates I7 (hi) and I5 (lo).
;   ecx - Pel or pel difference.
;   ebx - Pel or pel difference.
;   eax - Place in which to fetch a pel's contribution to two intermediates.

  mov   esi,PD P80000_P4545F [ebx*8]   ; P0's contribution to I4|I6.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P3's contribution to I4|I6.
  mov   edx,PD P2350B_P6491A [ebx*8]   ; P0's contribution to I7|I5.
   mov  edi,PD NB18A8_P96831 [ecx*8]   ; P3's contribution to I7|I5.
  lea   esi,[esi+eax+40004000H]        ; P0, P3 contribs to   I4|I6, biased.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P3's contribution to I0|I2.
  lea   edx,[edx+edi+40004000H]        ; P0, P3 contribs to   I7|I5, biased.
   mov  ebp,PD P80000_PA73D7 [ebx*8]   ; P0's contribution to I0|I2.
  mov   edi,PD P2350B_N6491A [ecx*8]   ; P3's contribution to I1|I3.
   mov  cl,P01                         ; Fetch P1.
  lea   ebp,[ebp+eax+40004000H]        ; P0, P3 contribs to   I0|I2, biased.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P0's contribution to I1|I3.
  sub   edi,eax                        ; P0, P3 contribs to   I1|I3, unbiased.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P1's contribution to I0|I2.
  add   ebp,eax                        ; P0, P1, P3 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P1's contribution to I1|I3.
  sub   edi,eax                        ; P0, P1, P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P1's contribution to I4|I6.
  sub   esi,eax                        ; P0, P1, P3 contribs to I4|I6.
   mov  bl,P02                         ; Fetch P2.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P1's contribution to I7|I5.
   mov  cl,P04                         ; Fetch P4.
  sub   edx,eax                        ; P0, P1, P3 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P2's contribution to I0|I2.
  add   ebp,eax                        ; P0-P3 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P2's contribution to I1|I3.
  add   edi,eax                        ; P0-P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P2's contribution to I4|I6.
  sub   esi,eax                        ; P0-P3 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P2's contribution to I7|I5.
  sub   edx,eax                        ; P0-P3 contribs to I7|I5.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P4's contribution to I0|I2.
  add   ebp,eax                        ; P0-P4 contribs to I0|I2.
   mov  eax,PD P2350B_N6491A [ecx*8]   ; P4's contribution to I1|I3.
  sub   edi,eax                        ; P0-P4 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P4's contribution to I4|I6.
  add   esi,eax                        ; P0-P4 contribs to I4|I6.
   mov  bl,P05                         ; Fetch P5.
  mov   eax,PD NB18A8_P96831 [ecx*8]   ; P4's contribution to I7|I5.
   mov  cl,P06                         ; Fetch P6.
  sub   edx,eax                        ; P0-P4 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P5's contribution to I0|I2.
  add   ebp,eax                        ; P0-P5 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P5's contribution to I1|I3.
  sub   edi,eax                        ; P0-P5 contribs to I1|I3.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P5's contribution to I4|I6.
  sub   esi,eax                        ; P0-P5 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P5's contribution to I7|I5.
  add   edx,eax                        ; P0-P5 contribs to I3|I4.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P6's contribution to I0|I2.
  add   ebp,eax                        ; P0-P6 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P6's contribution to I1|I3.
  add   edi,eax                        ; P0-P6 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P6's contribution to I4|I6.
  sub   esi,eax                        ; P0-P6 contribs to I4|I6.
   mov  bl,P07                         ; Fetch P7.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P6's contribution to I7|I5.
   mov  cl,P13                         ; Fetch P0.
  add   edx,eax                        ; P0-P6 contribs to I7|I5.
   mov  eax,PD P80000_PA73D7 [ebx*8]   ; P7's contribution to I0|I2.
  add   ebp,eax                        ; P0-P7 contribs to I0|I2.
   mov  eax,PD P80000_P4545F [ebx*8]   ; P7's contribution to I4|I6.
  add   esi,eax                        ; P0-P7 contribs to I4|I6.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P7's contribution to I1|I3.
  mov   I00I02,ebp                     ; Store I0|I2 for line 0.
   mov  I04I06,esi                     ; Store I4|I6 for line 0.
  lea   edi,[edi+eax+40004000H]        ; P0-P7 contribs to I1|I3, biased.
   mov  eax,PD P2350B_P6491A [ebx*8]   ; P7's contribution to I7|I5.
  sub   edx,eax                        ; P0-P7 contribs to I7|I5.
   mov  bl,P10                         ; Fetch P3 of line 1.
  mov   I01I03,edi                     ; Store I1|I3 for line 0.
   mov  I07I05,edx                     ; Store I7|I5 for line 0.

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P11
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P12
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P14
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P15
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P16
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P17
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P23
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I10I12,ebp
   mov  I14I16,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P20
  mov   I11I13,edi
   mov  I17I15,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P21
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P22
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P24
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P25
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P26
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P27
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P33
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I20I22,ebp
   mov  I24I26,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P30
  mov   I21I23,edi
   mov  I27I25,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P31
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P32
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P34
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P35
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P36
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P37
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P43
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I30I32,ebp
   mov  I34I36,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P40
  mov   I31I33,edi
   mov  I37I35,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P41
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P42
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P44
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P45
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P46
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P47
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P53
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I40I42,ebp
   mov  I44I46,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P50
  mov   I41I43,edi
   mov  I47I45,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P51
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P52
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P54
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P55
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P56
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P57
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P63
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I50I52,ebp
   mov  I54I56,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P60
  mov   I51I53,edi
   mov  I57I55,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P61
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P62
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P64
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P65
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P66
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P67
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P73
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I60I62,ebp
   mov  I64I66,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P70
  mov   I61I63,edi
   mov  I67I65,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P71
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P72
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P74
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P75
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P76
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P77
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  ecx,I00I02                 ; Fetch I0  (upper_lim <skew>) = 2000  4000 
   ;                               ; (lower_lim is -upper_limit)
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax                    ; I70I72, aka I7.                2000  0000 
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I74I76,esi
   mov  esi,I30I32                 ; Fetch I3                       2000  4000 
  add   edi,eax
   mov  eax,I40I42                 ; Fetch I4                       2000  0000 
  sub   esi,eax                    ; I3 - I4                        4000  4000 
   sub  ecx,ebp                    ; I0 - I7                        4000  4000 
  shr   ecx,1                      ; R7 = (I0-I7)/2 (dirty)         2000  2000 
   and  esi,0FFFEFFFFH             ; pre-clean R4
  shr   esi,1                      ; R4 = (I3-I4)/2 (dirty)         2000  2000 
   and  ecx,0FFFF7FFFH             ; R7 = (I0-I7)/2 (clean)         2000  2000 
  mov   ebx,PD P2350B_P6491A [ebx*8]
   mov  I71I73,edi
  sub   edx,ebx
   lea  ebx,[ecx+ecx*2]            ; 3R7                            6000  6000
  mov   I77I75,edx
   lea  edi,[esi+esi*2]            ; 3R4                            6000  6000

                                   ; eax:  I4                       2000  0000
                                   ; ebx:  3R7                      6000  6000
                                   ; ecx:  R7                       2000  2000
                                   ; edx:  available
                                   ; esi:  R4                       2000  2000
                                   ; edi:  3R4                      6000  6000
                                   ; ebp:  I7                       2000  0000

  lea   ebp,[ebp+ecx+40004000H]    ; R0 = (I0+I7)/2                 2000  6000
   add  eax,esi                    ; R3 = (I3+I4)/2                 2000  2000
  shr   ecx,1                      ; R7/2 (dirty)                   1000  1000
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; R4/2 (clean)                   1000  1000
   and  ecx,0FFFF7FFFH             ; clean
  add   ebx,ecx                    ; 7R7/2                          7000  7000
   add  edi,esi                    ; 7R4/2                          7000  7000
  shr   ebx,6                      ; 7R7/128 (dirty)                01C0  01C0
   and  edi,0FFC0FFFFH             ; pre-clean
  shr   edi,6                      ; 7R4/128 (clean)                01C0  01C0
   and  ebx,0FFFF03FFH             ; clean
  add   ebx,ecx                    ; 71R7/128                       11C0  11C0
   add  edi,esi                    ; 71R4/128                       11C0  11C0
  lea   edx,[eax+ebp-40004000H]    ; S0 = R0 + R3                   4000  4000
   sub  ebp,eax                    ; S3 = R0 - R3                   4000  4000
  lea   ecx,[ebx+ebx*2+6E406E40H]  ; 213R7/128                      3540  A380
   lea  esi,[edi+edi*2+27402740H]  ; 213R4/128                      3540  5C80
  shr   ecx,1                      ; 213R7/256 (dirty)              1AA0  51C0
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; 213R4/256 (clean)              1AA0  2E40
   and  ecx,0FFFF7FFFH             ; clean
  sub   ecx,edi                    ; S7 = (213R7 - 142R4)/256       2C60  4000
   mov  S0,edx                     ; Free register for work.
  mov   S3,ebp                     ; Free register for work.
   lea  esi,[esi+ebx+80008000H]    ; S4 = (142R7 + 213R3)/256       2C60  C000
  mov   S7,ecx                     ; Free register for work.
   mov  eax,I10I12                 ; Fetch I1                       2000  4000
  mov   S4,esi                     ; Free register for work.

                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

   mov  ebx,I20I22                 ; Fetch I2                       2000  4000
  mov   ecx,I50I52                 ; Fetch I5                       2000  0000
   mov  edx,I60I62                 ; Fetch I6                       2000  0000
  sub   eax,edx                    ; I1 - I6                        4000  4000
   sub  ebx,ecx                    ; I2 - I5                        4000  4000
  shr   eax,1                      ; R6 = (I1-I6)/2 (dirty)         2000  2000 
   and  ebx,0FFFEFFFFH             ; pre-clean R4
  shr   ebx,1                      ; R5 = (I2-I5)/2 (dirty)         2000  2000 
   and  eax,0FFFF7FFFH             ; R6 = (I1-I6)/2 (clean)         2000  2000 

                                   ; eax:  R6                       2000  2000
                                   ; ebx:  R5                       2000  2000
                                   ; ecx:  I5                       2000  0000
                                   ; edx:  I6                       2000  0000
                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

  mov   esi,ebx                    ; R5                             2000  2000
   mov  edi,eax                    ; R6                             2000  2000
  shr   esi,6                      ; R5/64                          0080  0080
   and  edi,0FFC0FFFFH             ; pre-clean 
  shr   edi,6                      ; R6/65                          0080  0080
   and  esi,0FFFF03FFH             ; clean
  lea   edx,[eax+edx+20002000H]    ; R1 = (I1+I6)/2                 2000  4000
   lea  ecx,[ecx+ebx-20002000H]    ; R2 = (I2+I5)/2                 2000  0000
  lea   ebp,[ebx+ebx*2]            ; 3R5                            6000  6000
   sub  ebx,esi                    ; 63R5/64                        1F80  1F80
  shr   ebp,4                      ; 3R5/16 (dirty)                 0600  0600
   lea  esi,[eax+eax*2]            ; 3R6                            6000  6000
  sub   eax,edi                    ; 63R6/64                        1F80  1F80
   mov  edi,ebx                    ; 63R5/64                        1F80  1F80
  shr   edi,7                      ; 63R5/8192 (dirty)              003F  003F
   and  ebp,0FFFF0FFFH             ; clean
  shr   esi,4                      ; 3R6/16 (dirty)                 0600  0600
   and  edi,0FFFF01FFH             ; clean
  and   esi,0FFFF0FFFH             ; clean
   sub  edx,ecx                    ; S2 = R1 - R2                   4000  4000
  lea   edi,[edi+ebp-46BF46BFH]    ; 1599R5/8192                    063F -4080
   mov  ebp,eax                    ; 63R6/64                        1F80  1F80
  shr   ebp,7                      ; 63R6/8192 (dirty)              003F  003F
   sub  eax,edi                    ; S6 = 8064R6/8192 - 1599R5/8192 25BF  6000
  and   ebp,0FFFF01FFH             ; clean
   lea  ecx,[edx+ecx*2-80008000H]  ; S1 = R1 + R2                   4000 -4000
  add   ebp,esi                    ; 1599R6/8192                    063F  063F
   mov  esi,S0                     ; Reload S0                      4000  4000
  mov   edi,CoeffStream            ; Fetch addr at which to place blk of coeffs.
   sub  esi,ecx                    ; C4 = T1 = S0 - S1              8000  8000
  lea   ebx,[ebx+ebp-45BF45BFH]    ; S5 = 8064R5/8192 + 1599R6/8192 25BF -2000
   mov  ebp,S4                     ; Reload S4                      2C60  C000

                                   ; eax:  S6                       25BF  6000
                                   ; ebx:  S5                       25BF -2000
                                   ; ecx:  S0                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C4                       8000  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S3                       4000  4000

  sub   ebp,eax                    ; T6 = S4 - S6                   521F  6000
   mov  PD [edi+C40C42],esi        ; Store coeffs C40 and C42.
  lea   ecx,[esi+ecx*2+80008000H]  ; C0 = T0 = S0 + S1              8000  8000
   mov  esi,S7                     ; Reload S7                      2C60  4000
  sub   esi,ebx                    ; T5 = S7 - S5                   521F  6000
   lea  eax,[ebp+eax*2-0C000C000H] ; T4 = S4 + S6                   521F  6000
  mov   PD [edi+C00C02],ecx        ; Store coeffs C00 and C02.
   mov  ecx,ebp                    ; T6                             521F  6000
  shr   ebp,2                      ; T6/4 (dirty)                   1487  1800
   lea  ebx,[esi+ebx*2+0C000C000H] ; T7 = S7 + S5                   521F  E000

                                   ; eax:  T4                       521F  6000
                                   ; ebx:  T7                       521F  6000
                                   ; ecx:  T6                       521F  6000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  T5                       521F  6000
                                   ; edi:  Destination pointer.
                                   ; ebp:  T6/4 (dirty)             1487  1800
                                   ; mem:  S3                       4000  4000
                                   ; done:  C0, C4

  and   ebp,0FFFF3FFFH             ; T6/4 (clean)                   1487  1800
   sub  ebx,eax                    ; C7 = T7 - T4                  <7642> 8000
  add   ecx,ebp                    ; 5T6/4                          66A6  7800
   mov  PD [edi+C70C72],ebx        ; Store coeffs C70 and C72.
  mov   ebp,ecx                    ; 5T6/4                          66A6  7800
   and  ecx,0FFF8FFFFH             ; pre-clean
  shr   ecx,3                      ; 5T6/32 (clean)                 0CD4  0F00
   lea  eax,[ebx+eax*2-0C000C000H] ; C1 = T7 + T4                  <7642> 8000 
  mov   ebx,esi                    ; T5                             521F  6000
   and  esi,0FFFCFFFFH             ; pre-clean
  shr   esi,2                      ; T5/4 (clean)                   1487  1800
   lea  ecx,[ecx+ebp-07000700H]    ; C5 = 45T6/32                   737A  8000
  mov   PD [edi+C50C52],ecx        ; Store coeffs C50 and C52.
   add  esi,ebx                    ; 5T5/4                          66A6  7800
  mov   ebx,esi                    ; 5T5/4                          66A6  7800
   and  esi,0FFF8FFFFH             ; pre-clean
  shr   esi,3                      ; 5T5/32 (clean)                 0CD4  0F00
   mov  ebp,S3                     ; Reload S3                      4000  4000
  mov   ecx,edx                    ; S2                             4000  4000
   lea  esi,[esi+ebx-07000700H]    ; C3 = 45T5/32                   737A  8000
  mov   ebx,ebp                    ; S3                             4000  4000
   ;

                                   ; eax:  C1                       521E  8000
                                   ; ebx:  S3                       4000  4000
                                   ; ecx:  S2                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C3                       737A  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S3                       4000  4000
                                   ; done:  C0, C4, C5, C7

  shr   ebp,2                      ; S3/4 (dirty)                   1000  1000
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/4 (clean)                   1000  1000
   and  ebp,0FFFF3FFFH             ; S3/4 (clean)                   1000  1000
  mov   PD [edi+C10C12],eax        ; Store coeffs C10 and C12.
   mov  PD [edi+C30C32],esi        ; Store coeffs C30 and C32.
  lea   eax,[edx+ecx]              ; 5S2/4                          5000  5000
   lea  esi,[ebx+ebp]              ; 5S3/4                          5000  5000
  shr   ebp,2                      ; S3/16 (dirty)                  0400  0400
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/16 (clean)                  0400  0400
   and  ebp,0FFFF3FFFH             ; S3/16 (clean)                  0400  0400
  add   ecx,eax                    ; 21S2/16                        5400  5400
   add  ebp,esi                    ; 21S3/16                        5400  5400
  shr   eax,5                      ; 5S2/128 (dirty)                0280  0280
   and  esi,0FFE0FFFFH             ; pre-clean
  shr   esi,5                      ; 5S3/128 (clean)                0280  0280
   and  eax,0FFFF07FFH             ; 5S2/128 (clean)                0280  0280
  shr   edx,1                      ; S2/2 (dirty)                   2000  2000
   and  ebx,0FFFEFFFFH             ; pre-clean
  shr   ebx,1                      ; S3/2 (clean)                   2000  2000
   and  edx,0FFFF7FFFH             ; S2/2 (clean)                   2000  2000
  sub   ebx,ecx                    ; (64S3 - 168S2) / 128           7400 -3400
   add  eax,ebp                    ; (5S2 + 168S3) / 128            5680  5680

  mov   ecx,I01I03
   mov  ebp,I71I73
  lea   ebx,[ebx+esi+0B180B180H]   ; C6 = (69S3 - 168S2) / 128      7680  8000
   lea  edx,[eax+edx+009800980H]   ; C2 = (69S2 + 168S3) / 128      7680  8000
  mov   esi,I31I33
   mov  eax,I41I43
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C60C62],ebx
   mov  PD [edi+C20C22],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I11I13
  mov   S4,esi
   mov  ebx,I21I23
  mov   ecx,I51I53
   mov  edx,I61I63
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C41C43],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C01C03],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C71C73],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C51C53],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C11C13],eax
   mov  PD [edi+C31C33],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I04I06
   mov  ebp,I74I76
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I34I36
   mov  eax,I44I46
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C61C63],ebx
   mov  PD [edi+C21C23],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I14I16
  mov   S4,esi
   mov  ebx,I24I26
  mov   ecx,I54I56
   mov  edx,I64I66
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C44C46],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C04C06],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C74C76],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C54C56],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C14C16],eax
   mov  PD [edi+C34C36],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I07I05
   mov  ebp,I77I75
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I37I35
   mov  eax,I47I45
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C64C66],ebx
   mov  PD [edi+C24C26],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I17I15
  mov   S4,esi
   mov  ebx,I27I25
  mov   ecx,I57I55
   mov  edx,I67I65
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C47C45],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C07C05],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C77C75],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C57C55],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C17C15],eax
   mov  PD [edi+C37C35],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,CoeffStreamStart
   lea  ebp,[edi-SIZEOF T_CoeffBlk]  ; Advance cursor for block action stream.
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   PD [edi+C67C65],ebx
   mov  PD [edi+C27C25],edx

; Forward Slant Transform is done

  cmp   ebp,ecx
   mov  edi,ebp
  mov   CoeffStream,edi
   jae  NextBlock               ; Process next block.


Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FORWARDDCT endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exedtq.inc ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\exedtq.inv   1.15   06 Nov 1996 16:18:34   BNICKERS  $
;//
;// $Log:   S:\h26x\src\enc\exedtq.inv  $
;// 
;//    Rev 1.15   06 Nov 1996 16:18:34   BNICKERS
;// Improve performance.
;// 
;//    Rev 1.14   18 Oct 1996 16:57:14   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.13   10 Oct 1996 16:42:54   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.12   04 Oct 1996 08:48:00   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.11   12 Sep 1996 10:56:18   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.10   22 Jul 1996 15:23:32   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.9   25 Jun 1996 14:24:54   BNICKERS
;// Implement heuristic motion estimation for MMX, AP mode.
;// 
;//    Rev 1.8   14 May 1996 12:18:54   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.7   03 May 1996 14:03:46   BNICKERS
;// 
;// Minor bug fixes and integration refinements.
;// 
;//    Rev 1.6   02 May 1996 12:00:58   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.5   16 Apr 1996 16:41:02   BNICKERS
;// Start adding storage for B frame ME.
;// 
;//    Rev 1.4   10 Apr 1996 13:14:12   BNICKERS
;// Recoding of Motion Estimation, Advanced Prediction.
;// 
;//    Rev 1.3   05 Apr 1996 12:27:54   BNICKERS
;// Improvements to baseline half pel ME.
;// 
;//    Rev 1.2   26 Mar 1996 12:00:20   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.1   20 Mar 1996 15:26:56   KLILLEVO
;// changed quantization to match IA quantization
;// 
;//    Rev 1.0   15 Mar 1996 15:54:14   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.0   16 Feb 1996 17:12:12   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; exEDTQ.inc -- Include file for MMx versions of Motion Estimation and Frame
;               Differencing, Forward DC Transform, and Quant/RLE.
;
; Storage on local stack frame for variables that survive only for the duration
; of one of the four phases (Motion Est, Frame Diff, FDCT, Quant RLE).  This
; storage is prime in that it is accessed by the 3-byte addressing form,
; esp+8_bit_Disp.  This is particularly important for MMx instructions, which
; would be 8 bytes long if a 32-bit Displacement was used.  There's a penalty
; for such a long instruction.
; (128 bytes; 32:159)


;                            ********************************************
;   Motion Estimation Locals * THAT DO NOT SURVIVE DURING OTHER PASSES. *
;                            ********************************************

HalfPelMBMESWDAccum      TEXTEQU <[esp+   0+StackOffset]>; 4 QWORDs + bit bucket
BestOfFourStartingPoints TEXTEQU HalfPelMBMESWDAccum+4
BitBucket1               TEXTEQU <[esp+  32+StackOffset]>; 8 bytes (QWORD)
StashMM6                 TEXTEQU <[esp+  32+StackOffset]>; QWORD
PartSWDForLLBlk          TEXTEQU <[esp+  32+StackOffset]>; QWORD
SWDULandLR               TEXTEQU <[esp+  40+StackOffset]>; QWORD

BitBucket2               TEXTEQU <[esp+  48+StackOffset]>; QWORD
PartSWDForLRBlk          TEXTEQU <[esp+  48+StackOffset]>; QWORD
Addr0MVRefBlk            TEXTEQU <[esp+  48+StackOffset]>; DWORD
LimitForSWDForBlkMV      TEXTEQU <[esp+  52+StackOffset]>; DWORD
SWDURandLL               TEXTEQU <[esp+  56+StackOffset]>; QWORD

PartSWDForURBlk          TEXTEQU <[esp+  64+StackOffset]>; QWORD
SWD0MVURandLL            TEXTEQU <[esp+  72+StackOffset]>; QWORD
SWD0MVULandLR            TEXTEQU <[esp+  80+StackOffset]>; QWORD
SWDForNon0MVToBeat       TEXTEQU <[esp+  88+StackOffset]>; DWORD
BestMBFullPelSWD         TEXTEQU <[esp+  92+StackOffset]>; DWORD
BestMBHalfPelSWD         TEXTEQU <[esp+  96+StackOffset]>; DWORD
BestMBHalfPelRefAddr     TEXTEQU <[esp+ 100+StackOffset]>; DWORD
BestHalfPelHorzSWD       TEXTEQU <[esp+ 104+StackOffset]>; DWORD
BestHalfPelVertSWD       TEXTEQU <[esp+ 108+StackOffset]>; DWORD
Addr0MVRef               TEXTEQU <[esp+ 112+StackOffset]>; DWORD
BestBlockRefAddrVP1      TEXTEQU <[esp+ 116+StackOffset]>; DWORD
BestBlkFullPelSWD        TEXTEQU <[esp+ 120+StackOffset]>; DWORD
SWDForBlock2Or4          TEXTEQU <[esp+ 124+StackOffset]>; DWORD

;   Frame Differencing Locals, passed to FDCT.
;
;   The output of frame differencing is the input to the forward DCT.
;   The intermediate coefficients are also stored here.  This keeps the
;   addressing forms as small as possible.  This is particularly important
;   for MMx instructions, to keep them 7 bytes or shorter.
;   (32:167)

PelDiffs      TEXTEQU <[esp+StackOffset]>  ; Must stay here!
PelDiffsLine0 TEXTEQU <PelDiffs>
PelDiffsLine1 TEXTEQU <PelDiffs+16>
PelDiffsLine2 TEXTEQU <PelDiffs+32>
PelDiffsLine3 TEXTEQU <PelDiffs+48>
PelDiffsLine4 TEXTEQU <PelDiffs+64>
PelDiffsLine5 TEXTEQU <PelDiffs+80>
PelDiffsLine6 TEXTEQU <PelDiffs+96>
PelDiffsLine7 TEXTEQU <PelDiffs+112>
Coeffs        TEXTEQU <[esp+StackOffset+8]>   ; 16 QWORDs

;                   *****************************************
;   Local variables * THAT SURVIVE FROM ONE PASS TO ANOTHER *
;                   *****************************************
;
; QWORD aligned:
; (184:191)

BlockAbove                     TEXTEQU <[esp+StackOffset+152]> ; 2 DWORDs

;                             ************************************************
;   Frame Differencing Locals * THAT NEED NOT SURVIVE OTHER PASSES (but do). *
;                             ************************************************
;   These three blocks of 8*8 storage are needed for the left, right, and
;   central remote prediction contributions.
; (192:383)

LeftPred                       TEXTEQU <[esp+StackOffset+160]>
RightPred                      TEXTEQU <[esp+StackOffset+224]>
CentralPred                    TEXTEQU <[esp+CONST_384*1+StackOffset-96]>

;   Temp space used by Heuristic ME.

TargetSigContribForRowPairs    TEXTEQU CentralPred

;                   *****************************************
;   Local variables * THAT SURVIVE FROM ONE PASS TO ANOTHER *
;                   *****************************************
; (384:511)
DoHalfPelME                    TEXTEQU <[esp+CONST_384*1+StackOffset- 32]>
DoBlockLevelVectors            TEXTEQU <[esp+CONST_384*1+StackOffset- 28]>
DoAdvancedPrediction           TEXTEQU <[esp+CONST_384*1+StackOffset- 27]>
DoSpatialFiltering             TEXTEQU <[esp+CONST_384*1+StackOffset- 26]>
IsPlainPFrame                  TEXTEQU <[esp+CONST_384*1+StackOffset- 25]>
TargetFrameBaseAddress         TEXTEQU <[esp+CONST_384*1+StackOffset- 24]>
PreviousFrameBaseAddress       TEXTEQU <[esp+CONST_384*1+StackOffset- 20]>
TargToRef                      TEXTEQU <[esp+CONST_384*1+StackOffset- 16]>
BFrameBaseAddress              TEXTEQU <[esp+CONST_384*1+StackOffset- 12]>
SpatiallyFilteredMB            TEXTEQU <BFrameBaseAddress>
BFrameToFuture                 TEXTEQU <[esp+CONST_384*1+StackOffset-  8]>
SpatialFiltThreshold           TEXTEQU <BFrameToFuture>
PendingOBMC                    TEXTEQU <[esp+CONST_384*1+StackOffset-  4]>
SpatialFiltDifferential        TEXTEQU <PendingOBMC>
DistToBADforBlockAbove         TEXTEQU <[esp+CONST_384*1+StackOffset+  0]>
DistToBADforBlockBelow         TEXTEQU <[esp+CONST_384*1+StackOffset+  4]>
AddrOfLeftPred                 TEXTEQU <[esp+CONST_384*1+StackOffset+  8]>
AddrOfRightPred                TEXTEQU <[esp+CONST_384*1+StackOffset+ 12]>
Recip2QPToUse                  TEXTEQU <[esp+CONST_384*1+StackOffset+ 16]>
QPDiv2                         TEXTEQU <[esp+CONST_384*1+StackOffset+ 20]>
BRecip2QPToUse                 TEXTEQU <[esp+CONST_384*1+StackOffset+ 24]>
BQPDiv2                        TEXTEQU <[esp+CONST_384*1+StackOffset+ 28]>
CodeStreamCursor               TEXTEQU <[esp+CONST_384*1+StackOffset+ 32]>
BCodeStreamCursor              TEXTEQU <[esp+CONST_384*1+StackOffset+ 36]>
C00Copy                        TEXTEQU <[esp+CONST_384*1+StackOffset+ 40]>
StashBlockType                 TEXTEQU <[esp+CONST_384*1+StackOffset+ 44]>
TargetMacroBlockBaseAddr       TEXTEQU <[esp+CONST_384*1+StackOffset+ 48]>
BestMV                         TEXTEQU <[esp+CONST_384*1+StackOffset+ 52]>
BestMBHalfPelMV                TEXTEQU <[esp+CONST_384*1+StackOffset+ 56]>
CandidateMV                    TEXTEQU <BestMBHalfPelMV>
SWDTotal                       TEXTEQU <[esp+CONST_384*1+StackOffset+ 60]>
BSWDTotal                      TEXTEQU <[esp+CONST_384*1+StackOffset+ 64]>
BlockActionDescrCursor         TEXTEQU <[esp+CONST_384*1+StackOffset+ 68]>
MBlockActionStream             TEXTEQU BlockActionDescrCursor
BFrmCBP                        TEXTEQU <[esp+CONST_384*1+StackOffset+ 72]>
PastRefPitchDiv4               TEXTEQU <[esp+CONST_384*1+StackOffset+ 76]>
CurrSWDState                   TEXTEQU <[esp+CONST_384*1+StackOffset+ 80]>
StashPartialRefBlkAddr         TEXTEQU <[esp+CONST_384*1+StackOffset+ 84]>

StashESP                       TEXTEQU <[esp+CONST_384*1+StackOffset+ 92]>

; These two arrays use esp+384+96:esp+384+223, and esp+384*2-96:esp+384*2+31.
; (512:639, 704:831)

WeightForwardMotion            TEXTEQU <[esp+384+StackOffset+96]>
WeightBackwardMotion           TEXTEQU <[esp+384+StackOffset+160]>

; 32 more bytes of local variables here:
; (832:863)

DoHeuristicME                  TEXTEQU <[esp+CONST_384*2+StackOffset+ 32]>
TargetToSig_Debiased           TEXTEQU <[esp+CONST_384*2+StackOffset+ 36]>
SigToTarget                    TEXTEQU <[esp+CONST_384*2+StackOffset+ 40]>
BFrmZeroVectorThreshold        TEXTEQU <[esp+CONST_384*2+StackOffset+ 44]>
EMVLimitsForThisMB             TEXTEQU <[esp+CONST_384*2+StackOffset+ 48]> ; 8
DoExtendedMotionVectors        TEXTEQU <[esp+CONST_384*2+StackOffset+ 56]>
StackSpaceAvailable            TEXTEQU <[esp+CONST_384*2+StackOffset+ 60]>

EXTERNDEF C0100010001000100:DWORD
EXTERNDEF C1:DWORD
EXTERNDEF C2:DWORD
EXTERNDEF C3:DWORD
EXTERNDEF C4:DWORD
EXTERNDEF C5:DWORD
EXTERNDEF C6:DWORD
EXTERNDEF C7:DWORD
EXTERNDEF Diff_IdxRefWts:BYTE
EXTERNDEF FutureWt_FF_or_00:DWORD
EXTERNDEF BFrmSWDState:BYTE
EXTERNDEF Pel_Rnd:DWORD
EXTERNDEF LeftRightBlkPosition:DWORD
EXTERNDEF UpDownBlkPosition:DWORD
EXTERNDEF BlkEmptyFlag:BYTE
EXTERNDEF NextZigZagCoeff:BYTE

C00      = 0
C04      = 8
C10      = 16
C14      = 24
C20      = 32
C24      = 40
C30      = 48
C34      = 56
C40      = 64
C44      = 72
C50      = 80
C54      = 88
C60      = 96
C64      = 104
C70      = 112
C74      = 120
Q00      = C00      ;  C00
Q01      = C10      ;  C00+1
Q02      = C20      ;  C00+2
Q03      = C30      ;  C00+3
Q04      = C40      ;  C00+4
Q05      = C50      ;  C00+5
Q06      = C60      ;  C00+6
Q07      = C70      ;  C00+7
Q10      = C00+1    ;  C10
Q11      = C10+1    ;  C10+1
Q12      = C20+1    ;  C10+2
Q13      = C30+1    ;  C10+3
Q14      = C40+1    ;  C10+4
Q15      = C50+1    ;  C10+5
Q16      = C60+1    ;  C10+6
Q17      = C70+1    ;  C10+7
Q20      = C00+2    ;  C20
Q21      = C10+2    ;  C20+1
Q22      = C20+2    ;  C20+2
Q23      = C30+2    ;  C20+3
Q24      = C40+2    ;  C20+4
Q25      = C50+2    ;  C20+5
Q26      = C60+2    ;  C20+6
Q27      = C70+2    ;  C20+7
Q30      = C00+3    ;  C30
Q31      = C10+3    ;  C30+1
Q32      = C20+3    ;  C30+2
Q33      = C30+3    ;  C30+3
Q34      = C40+3    ;  C30+4
Q35      = C50+3    ;  C30+5
Q36      = C60+3    ;  C30+6
Q37      = C70+3    ;  C30+7
Q40      = C00+4    ;  C40
Q41      = C10+4    ;  C40+1
Q42      = C20+4    ;  C40+2
Q43      = C30+4    ;  C40+3
Q44      = C40+4    ;  C40+4
Q45      = C50+4    ;  C40+5
Q46      = C60+4    ;  C40+6
Q47      = C70+4    ;  C40+7
Q50      = C00+5    ;  C50
Q51      = C10+5    ;  C50+1
Q52      = C20+5    ;  C50+2
Q53      = C30+5    ;  C50+3
Q54      = C40+5    ;  C50+4
Q55      = C50+5    ;  C50+5
Q56      = C60+5    ;  C50+6
Q57      = C70+5    ;  C50+7
Q60      = C00+6    ;  C60
Q61      = C10+6    ;  C60+1
Q62      = C20+6    ;  C60+2
Q63      = C30+6    ;  C60+3
Q64      = C40+6    ;  C60+4
Q65      = C50+6    ;  C60+5
Q66      = C60+6    ;  C60+6
Q67      = C70+6    ;  C60+7
Q70      = C00+7    ;  C70
Q71      = C10+7    ;  C70+1
Q72      = C20+7    ;  C70+2
Q73      = C30+7    ;  C70+3
Q74      = C40+7    ;  C70+4
Q75      = C50+7    ;  C70+5
Q76      = C60+7    ;  C70+6
Q77      = C70+7    ;  C70+7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3msig.asm ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3msig.asv   1.2   04 Oct 1996 08:47:58   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\e3msig.asv  $
;// 
;//    Rev 1.2   04 Oct 1996 08:47:58   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.1   08 Jul 1996 16:55:42   BNICKERS
;// Fix register initialization
;// 
;//    Rev 1.0   25 Jun 1996 14:24:54   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; MMXMotionEstimationSignaturePrep -- This function pre-computes the signature
;                                     inputs for the reference frame.  It is
;                                     used only by MMX ME, and only in AP mode.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510
OPTION CASEMAP:NONE

include iammx.inc
include e3inst.inc

.xlist
include memmodel.inc
.list

;=============================================================================

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

MMxMESignaturePrep  proc C APrev:   DWORD,
ASig:    DWORD,
AFrmWd:  DWORD,
AFrmHt:  DWORD

RegStoSize = 16

; Arguments:

PreviousFrameBaseAddress     = RegStoSize +  4
SignatureFrameBaseAddress    = RegStoSize +  8
FrameWidth                   = RegStoSize + 12
FrameHeight                  = RegStoSize + 16
EndOfArgList                 = RegStoSize + 20

  push       esi
  push       edi
  push       ebp
  push       ebx

; ebp -- PITCH
; esi -- Cursor over reference frame.
; edi -- Cursor over frame of signature sums.
; edx -- Skip distance.
; ebx -- Outer loop counter.
; cl  -- Initial value for inner loop counter.
; al  -- Inner loop counter.
; ch  -- Scratch.
; ah  -- Scratch.

  mov        esi,[esp+PreviousFrameBaseAddress]
   mov       edi,[esp+SignatureFrameBaseAddress]
  mov        ebx,[esp+FrameHeight]
   mov       eax,[esp+FrameWidth]

  mov        edx,PITCH*4-32
   mov       ebp,PITCH
  sub        edx,eax           ; Distance from end of one row to start of next.
   add       eax,32            ; Add the macroblocks off left and right edges.
  shr        eax,4             ; Number of macroblocks in row.
   sub       esi,16            ; Start at macroblock off left edge.
  mov        cl,al             ; To re-init inner loop counter.
   sub       edi,16            ; Start at macroblock off left edge.

  pxor       mm5,mm5
   pcmpeqb   mm0,mm0
  pcmpeqb    mm4,mm4
   psrlw     mm0,8                 ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  pxor       mm6,mm6
   psrlw     mm4,15                ; W:<0x0001  0x0001  0x0001  0x0001>
  movq       mm2,[esi]             ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   movq      mm1,mm0               ; W:<   00FF    00FF    00FF    00FF>
  movq       mm3,[esi+8]
   pand      mm0,mm2               ; W:<P06 P04 P02 P00>
  pxor       mm7,mm7

@@:

  pand       mm1,mm3
   psllw     mm0,2                 ; W:<P06*4 P04*4 P02*4 P00*4>
  mov        ah,[edi-PITCH*12]
   psrlw     mm2,7                 ; W:<P07*2 P05*2 P03*2 P01*2>
  movq       [edi-PITCH*12],mm0    ; Save W:<P06*4 P04*4 P02*4 P00*4>
   pmaddwd   mm2,mm4               ; D:<(P07+P05)*2 (P03+P01)*2>
  mov        ch,[edi-PITCH*8+16]
   mov       ah,[edi-PITCH*4]   
  movq       [edi-PITCH*8],mm0     ; Save W:<P06*4 P04*4 P02*4 P00*4>
   psllw     mm1,2
  mov        ch,[edi+16]
   psrlw     mm3,7                 ; W:<P07*2 P05*2 P03*2 P01*2>
  movq       [edi-PITCH*4],mm0     ; Save W:<P06*4 P04*4 P02*4 P00*4>
   pmaddwd   mm3,mm4
  movq       [edi],mm0             ; Save W:<P06*4 P04*4 P02*4 P00*4>
   psllq     mm0,2                 ; W:<P06*16 P04*16 P02*16 P00*16>
  mov        ah,[edi-PITCH*10-16]
   mov       ch,[edi-PITCH*16]
  movq       [edi-PITCH*16],mm0    ; Save W:<P06*16 P04*16 P02*16 P00*16>
   packssdw  mm2,mm2               ; [0:31] W:<(P07+P05)*2 (P03+P01)*2>
  movq       [edi-PITCH*12+8],mm1
   punpcklwd mm2,mm2               ; W:<(P07+P05)*2 (P07+P05)*2 (P03+P01)*2 ...>
  movq       [edi-PITCH*8+8],mm1
   psubw     mm2,mm5           ; Subtract sum of pels 15, 13, 11, and 9 to left.
  movq       [edi-PITCH*4+8],mm1
   paddw     mm7,mm2           ; Low DWORD: W:<sum(P0*)*2 sum(P0*)*2>, where
   ;                           ; "*" is odd columns from -11 thru +3.
  movq       [edi+8],mm1
   paddw     mm5,mm2           ; Save W:<(P27+P37+P25+P35) (P07+P17+P05+P15)...>
  mov        ah,[edi-PITCH*14-32]
  mov        ah,[edi-PITCH*6-32]
   mov       ch,[edi-PITCH*2-16]
  movdf      [edi-PITCH*14-12],mm7; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
  movdf      [edi-PITCH*10-12],mm7; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
   psrlq     mm2,32            ; Position 7, 5, and negative of 9, 11 to left.
  movdf      [edi-PITCH*6-12],mm7 ; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
   paddw     mm2,mm7           ; Low DWORD: W:<sum(P0*)*2 sum(P0*)*2>, where
   ;                           ; "*" is odd columns from -7 thru +7.
  movdf      [edi-PITCH*2-12],mm7 ; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
   packssdw  mm3,mm3
  movdf      [edi-PITCH*10-8],mm2
   punpcklwd mm3,mm3
  movdf      [edi-PITCH*6-8],mm2
   psubw     mm3,mm6
  movdf      [edi-PITCH*2-8],mm2
   paddw     mm2,mm3
  add        esi,16            ; Advance input cursor.
   dec       al
  movdf      [edi-PITCH*14-4],mm2
  movdf      [edi-PITCH*10-4],mm2
   paddw     mm6,mm3
  movdf      [edi-PITCH*6-4],mm2
   psrlq     mm3,32
  movdf      [edi-PITCH*2-4],mm2
   paddw     mm3,mm2
  movq       mm2,[esi]             ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   movq      mm7,mm3
  movq       mm3,[esi+8]
   psllq     mm1,2
  movdf      [edi-PITCH*10],mm7
   pcmpeqb   mm0,mm0
  movq       [edi-PITCH*16+8],mm1
   psrlw     mm0,8
  movdf      [edi-PITCH*6],mm7
   movq      mm1,mm0
  movdf      [edi-PITCH*2],mm7
   pand      mm0,mm2
  lea        edi,[edi+16]      ; Advance output cursor.
   jne       @b


  lea        esi,[esi+edx-PITCH*4] ; Get back to start of line 0.
   lea       edi,[edi+edx-PITCH*4] ; Get back to start of line 0.
  pxor       mm7,mm7 
   add       ebx,16            ; Do 4 extra sets of 4 lines at bottom.
  mov        al,cl

Next4LinesRefQuickSig:

  pxor       mm5,mm5
   pcmpeqb   mm0,mm0
  movq       mm3,[esi+ebp*2]   ; B:<P27 P26 P25 P24 P23 P22 P21 P20>
   psrlw     mm0,8             ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  paddb      mm3,[esi+PITCH*3] ; B:<P27+P37 P26+P36 P25+P35 P24+P34 ...>
   pcmpeqb   mm4,mm4
  pxor       mm6,mm6
   psrlw     mm4,15            ; W:<0x0001  0x0001  0x0001  0x0001>

@@:

  movq       mm2,[esi]         ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   movq      mm1,mm3           ; B:<P27+P37 P26+P36 P25+P35 P24+P34 ...>
  paddb      mm2,[esi+ebp*1]   ; B:<P07+P17 P06+P16 P05+P15 P04+P14 ...>
   psrlw     mm3,8             ; W:<P27+P37 P25+P35 P23+P33 P21+P31>
  pmaddwd    mm3,mm4           ; D:<P27+P37+P25+P35 P23+P33+P21+P31>
   pand      mm1,mm0           ; W:<P26+P36 P24+P34 P22+P32 P20+P30>
  pand       mm0,mm2           ; W:<P06+P16 P04+P14 P02+P12 P00+P10>
   psrlw     mm2,8             ; W:<P07+P17 P05+P15 P03+P13 P01+P11>
  pmaddwd    mm2,mm4           ; D:<P07+P17+P05+P15 P03+P13+P01+P11>
   paddw     mm1,mm0           ; W:<(P06+P16+P26+P36) (P04+P14+P24+P34) ...>
  mov        ah,[edi+ebp*2-16] ; Initiate cache line load.
   pslld     mm3,16            ; D:<(P27+P37+P25+P35)<<16 (P23+P33+P21+P31)<<16>
  movq       [edi+ebp*4],mm1   ; Save W:<(P06+P16+P26+P36) ...>
   pcmpeqb   mm0,mm0
  paddw      mm1,[edi-PITCH*16]; W:<Sum(P*6) Sum(P*4) Sum(P*2) Sum(P*0)>, where
  ;                            ;   "*" is the 20 lines P-16 thru P3
   por       mm2,mm3           ; W:<(P27+P37+P25+P35) (P07+P17+P05+P15)
   ;                           ;    (P23+P33+P21+P31) (P03+P13+P01+P11)>
  psubw      mm1,[edi-PITCH*12]; W:<Sum(P*6) Sum(P*4) Sum(P*2) Sum(P*0)>, where
   ;                           ;   "*" is the 16 lines P-12 thru P3
   psubw     mm2,mm5           ; Subtract sum of pels 15, 13, 11, and 9 to left.
  movq       mm3,[esi+ebp*2+8]
   paddw     mm7,mm2           ; Low DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)> where
   ;                           ; "*" is odd columns from -11 thru +3.
  movq       [edi-PITCH*12],mm1; Save W:<P*6 P*4 P*2 P*0> where * is 16 rows.
   paddw     mm5,mm2           ; Save W:<(P27+P37+P25+P35) (P07+P17+P05+P15)...>
  movdf      [edi+ebp*2-12],mm7; Save DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)>
   psrlq     mm2,32            ; Position 7, 5, and negative of 9, 11 to left.
  paddb      mm3,[esi+PITCH*3+8]
   paddw     mm7,mm2           ; Low DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)> where
   ;                           ; "*" is odd columns from -7 thru +7.
  movq       mm2,[esi+8]
   psrlw     mm0,8
  movdf      [edi+ebp*2-8],mm7 ; Save DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)>
   movq      mm1,mm3
  paddb      mm2,[esi+ebp*1+8]
   psrlw     mm3,8
  pmaddwd    mm3,mm4
   pand      mm1,mm0
  pand       mm0,mm2
   psrlw     mm2,8
  pmaddwd    mm2,mm4
   paddw     mm1,mm0
  mov        ch,[edi+ebp*4+16] ; Initiate cache line load.
   pslld     mm3,16
  movq       [edi+ebp*4+8],mm1
   pcmpeqb   mm0,mm0
  paddw      mm1,[edi-PITCH*16+8]
   por       mm2,mm3
  psubw      mm1,[edi-PITCH*12+8]
   psubw     mm2,mm6
  movq       mm3,[esi+ebp*2+16]
   paddw     mm7,mm2
  movq       [edi-PITCH*12+8],mm1
   paddw     mm6,mm2
  movdf      [edi+ebp*2-4],mm7
   psrlq     mm2,32
  paddb      mm3,[esi+PITCH*3+16]
   paddw     mm7,mm2
  add        esi,16            ; Advance input cursor.
   dec       al
  movdf      [edi+ebp*2],mm7
   psrlw     mm0,8
  lea        edi,[edi+16]      ; Advance output cursor.
   jne       @b

  add        esi,edx
   add       edi,edx
  mov        al,cl
   sub       ebx,4
  pxor       mm7,mm7 
   jne       Next4LinesRefQuickSig

  emms
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  rturn

MMxMESignaturePrep endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3mbme.asm ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3mbme.asv   1.5   18 Oct 1996 16:57:08   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\e3mbme.asv  $
;// 
;//    Rev 1.5   18 Oct 1996 16:57:08   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.4   12 Sep 1996 10:56:16   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.3   22 Jul 1996 15:22:48   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.2   14 May 1996 12:18:48   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.1   03 May 1996 14:03:30   BNICKERS
;// 
;// Minor bug fixes and integration refinements.
;// 
;//    Rev 1.0   02 May 1996 12:00:56   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; MMxBFrameMotionEstimation -- This function performs motion estimation for the
;                              B frame macroblocks identified in the input list.
;                              This is the MMx version.
;

OPTION M510
OPTION CASEMAP:NONE

BFRMNONZEROMVDIFFERENTIAL    =  400
BFRMEMPTYTHRESHOLD           =  256

.xlist
include e3inst.inc
include memmodel.inc
include iammx.inc
include exEDTQ.inc
include e3mbad.inc
.list

.CODE EDTQ

EXTERN MMxDoForwardDCT:NEAR

PUBLIC MMxDoBFrameLumaBlocks
PUBLIC MMxDoBFrameChromaBlocks

StackOffset TEXTEQU <4>
CONST_384   TEXTEQU <ebp>

MMxDoBFrameLumaBlocks:

  mov        eax,QPDiv2        ; Swap these so Quantizer uses right level.
   mov       ebx,BQPDiv2
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       cl,INTER1MV
  mov        BRecip2QPToUse,eax
   mov       StashBlockType,cl

BFrameSWDLoop_0MV:

  mov        ecx,[edx].BlkY1.MVs
   xor       ebx,ebx
  mov        bl,[edx].BlkY1.PVMV          ; P-frame Vertical MV
   lea       edi,WeightForwardMotion
  xor        eax,eax
   and       ecx,0FFH                     ; P-frame Horizontal MV
  mov        al,[edi+ebx]                 ; VMV for past ref.
   mov       bl,[edi+ebx+64]              ; VMV for future ref.
  mov        [edx].BlkY1.VMVb0Delta,bl
   mov       bl,[edi+ecx+64]              ; HMV for future ref.
  mov        [edx].BlkY1.HMVb0Delta,bl
   mov       bl,[edi+ecx]                 ; HMV for past ref.
  mov        [edx].BlkY1.VMVf0Delta,al    ; Record candidate VMVf.
   xor       ecx,ecx                      ; Keep pairing happy.
  mov        [edx].BlkY1.HMVf0Delta,bl    ; Record candidate HMVf.
   mov       edi,[edx].BlkY1.BlkOffset    ; Address of 0-MV blk within frame.

  call       ComputeBFrameSWDForCandRef

  movdf      [edx].BlkY1.BlkLvlSWD0Delta,mm7   ; Stash SWD.
  add        edx,SIZEOF T_Blk
   lea       edi,WeightForwardMotion
  test       dl,4*SIZEOF T_Blk          ; Quit when fourth block done.
  je         BFrameSWDLoop_0MV

  mov        eax,[edx-4*SIZEOF T_Blk].BlkY1.MVs
   mov       cl,[edx-4*SIZEOF T_Blk].BlockType
  xor        cl,INTER1MV 
   or        al,ah
  lea        esi,[edx-4*SIZEOF T_Blk]     ; Reset MacroBlockActionDescr cursor.
   or        al,cl
  mov        ecx,[edx-SIZEOF T_Blk].BlkY1.BlkLvlSWD0Delta
   je        BelowBFrmZeroThreshold  ; Jump if P frm macroblock uses 0 motion vector.
  
  xor        eax,eax
   cmp       ecx,BFrmZeroVectorThreshold
  mov        CurrSWDState,eax             ; Record ME engine state.
   jle       BelowBFrmZeroThreshold

  mov        edx,[esi].BlkY1.BlkLvlSWD0Delta    ; Remember 0-MV SWDs.
   mov       ecx,[esi].BlkY2.BlkLvlSWD0Delta
  mov        [esi].BlkY1.BestBlkLvlSWD,edx 
   mov       [esi].BlkY2.BestBlkLvlSWD,ecx
  mov        edx,[esi].BlkY3.BlkLvlSWD0Delta
   mov       ecx,[esi].BlkY4.BlkLvlSWD0Delta
  mov        [esi].BlkY3.BestBlkLvlSWD,edx
   mov       [esi].BlkY4.BestBlkLvlSWD,ecx
  mov        [esi].BlkU.BestBlkLvlSWD,ecx ; Avoid unintended early out, below.
   xor       edx,edx                      ; Set best MV to zero.

BFrmSWDLoop:

  mov        ecx,PD BFrmSWDState[eax]     ; cl == HMV; ch == VMV offsets to try.
   mov       BestMV,edx                   ; Record what the best MV so far is.
  add        cl,dl                        ; Try this horizontal MV delta.
   je        HMVdIsZero

  mov        PB CandidateMV,cl            ; Record the candidate HMV delta.
   add       ch,dh                        ; Try this vertical MV delta.
  mov        PB CandidateMV+1,ch          ; Record the candidate VMV delta.
   je        VMVdIsZero

VMVdAndHMVdAreNonZero_Loop:

  mov        edx,[esi].BlkY1.MVs
   xor       ebx,ebx
  mov        bl,dl
   xor       eax,eax
  mov        al,dh
   add       esi,SIZEOF T_Blk
  mov        bl,[edi+ebx]                 ; TRb * HMV / TRd
   pxor      mm7,mm7                      ; Initialize SWD accumulator
  add        bl,cl                        ; HMVf = TRb * HMV / TRd + HMVd
   mov       al,[edi+eax]                 ; TRb * VMV / TRd
  cmp        bl,040H                      ; If too far left or right, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVf,bl
   add       al,ch                        ; VMVf = TRb * VMV / TRd + VMVd
  cmp        al,040H                      ; If too far up or down, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVf,al
   sub       bl,dl                        ; -HMVb = -(HMVf - HMV)
  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVb,bl
   sub       al,dh                        ; -VMVb = -(VMVf - VMV)
  test       esi,4*SIZEOF T_Blk
  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVb,al
   je        VMVdAndHMVdAreNonZero_Loop

  sub        esi,4*SIZEOF T_Blk
   jmp       CandidateMVsGotten

VMVdIsZero:
VMVdIsZero_Loop:

  mov        edx,[esi].BlkY1.MVs
   xor       eax,eax
  mov        al,dh
   xor       ebx,ebx
  mov        bl,dl
   add       esi,SIZEOF T_Blk
  mov        dh,[edi+eax+64]              ; -VMVb = -((TRb - TRd) * VMV) / TRd
   mov       al,[edi+eax]                 ; TRb * VMV / TRd
  mov        bl,[edi+ebx]                 ; TRb * HMV / TRd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandVMVf,al
  add        bl,cl                        ; HMVf = TRb * HMV / TRd + HMVd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandVMVb,dh
  cmp        bl,040H                      ; If too far left or right, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVf,bl
   sub       bl,dl                        ; -HMVb = -(HMVf - HMV)
  test       esi,4*SIZEOF T_Blk
  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVb,bl
   je        VMVdIsZero_Loop

  sub        esi,4*SIZEOF T_Blk
   pxor      mm7,mm7                      ; Initialize SWD accumulator
  jmp        CandidateMVsGotten

BFrameEarlyOutForCandidateMV:
MVDeltaOutOfRange:

  and        esi,-1-7*SIZEOF T_Blk        ; Reset block action descr cursor.
   mov       ebx,CurrSWDState             ; Reload ME engine state.
  xor        eax,eax
   mov       edx,BestMV                   ; Previous best MV is still best.
  mov        al,BFrmSWDState[ebx+2]       ; Get next State number.
   jmp       ProceedWithNextCand

HMVdIsZero:

  mov        PB CandidateMV,cl            ; Record the candidate HMV delta.
   add       ch,dh                        ; Try this vertical MV delta.
  mov        PB CandidateMV+1,ch          ; Record the candidate VMV delta.

HMVdIsZeroLoop:

  mov        edx,[esi].BlkY1.MVs
   xor       ebx,ebx
  mov        bl,dl
   xor       eax,eax
  mov        al,dh
   add       esi,SIZEOF T_Blk
  mov        dl,[edi+ebx+64]              ; -HMVb = -((TRb - TRd) * HMV) / TRd
   mov       bl,[edi+ebx]                 ; TRb * HMV / TRd
  mov        al,[edi+eax]                 ; TRb * VMV / TRd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandHMVf,bl
  add        al,ch                        ; VMVf = TRb * VMV / TRd + VMVd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandHMVb,dl
  cmp        al,040H                      ; If too far up or down, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVf,al
   sub       al,dh                        ; -VMVb = -(VMVf - VMV)
  test       esi,4*SIZEOF T_Blk
  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVb,al
   je        HMVdIsZeroLoop

  sub        esi,4*SIZEOF T_Blk
   pxor      mm7,mm7                      ; Initialize SWD accumulator

CandidateMVsGotten:
BFrameSWDLoop_Non0MVCandidate:

  xor        eax,eax
   xor       ebx,ebx
  mov        al,[esi].BlkY1.CandVMVf
   mov       edi,[esi].BlkY1.BlkOffset    ; Address of 0-MV blk within frame.
  mov        bl,[esi].BlkY1.CandHMVf
   mov       edx,esi

  call       ComputeBFrameSWDForCandRef

  movdf      ecx,mm7
  mov        eax,[edx].BlkY2.BestBlkLvlSWD
   lea       esi,[edx+SIZEOF T_Blk]       ; Early out if the first N blocks for
  cmp        ecx,eax                      ; this cand are worse than the first
   jge       BFrameEarlyOutForCandidateMV ; N+1 blocks for previous best.

  test       esi,4*SIZEOF T_Blk           ; Quit when fourth block done.
  mov        [esi-SIZEOF T_Blk].BlkY1.CandBlkLvlSWD,ecx   ; Stash SWD.
   je        BFrameSWDLoop_Non0MVCandidate

  ; This candidate is best so far.

  mov        [esi-4*SIZEOF T_Blk].BlkY4.BestBlkLvlSWD,ecx
   mov       ebx,CurrSWDState             ; Reload ME engine state.
  mov        [esi-4*SIZEOF T_Blk].BlkU.BestBlkLvlSWD,ecx
   sub       esi,4*SIZEOF T_Blk
  xor        eax,eax
   mov       edx,CandidateMV              ; Candidate was best MV.
  mov        ecx,[esi].BlkY3.CandBlkLvlSWD
  mov        [esi].BlkY3.BestBlkLvlSWD,ecx
   mov       ecx,[esi].BlkY2.CandBlkLvlSWD
  mov        [esi].BlkY2.BestBlkLvlSWD,ecx
   mov       ecx,[esi].BlkY1.CandBlkLvlSWD
  mov        [esi].BlkY1.BestBlkLvlSWD,ecx
   mov       ecx,[esi].BlkY4.CandBiDiMVs
  mov        [esi].BlkY4.BestBiDiMVs,ecx
   mov       ecx,[esi].BlkY3.CandBiDiMVs
  mov        [esi].BlkY3.BestBiDiMVs,ecx
   mov       ecx,[esi].BlkY2.CandBiDiMVs
  mov        [esi].BlkY2.BestBiDiMVs,ecx
   mov       ecx,[esi].BlkY1.CandBiDiMVs
  mov        [esi].BlkY1.BestBiDiMVs,ecx
   mov       al,BFrmSWDState[ebx+3]       ; Get next State number.

ProceedWithNextCand:

  mov        CurrSWDState,eax             ; Record ME engine state.
   test      eax,eax
  lea        edi,WeightForwardMotion
   jne       BFrmSWDLoop

  mov        ecx,[esi].BlkY4.BlkLvlSWD0Delta          ; 0MV SWD
  sub        ecx,BFRMNONZEROMVDIFFERENTIAL
   mov       ebx,[esi].BlkY4.BestBlkLvlSWD            ; Best non-0 MV SWD.
  cmp        ebx,ecx
   jge       NonZeroBFrmVectorNotGoodEnoughGain

  mov        [esi].BlkY1.BHMV,dl
   mov       [esi].BlkY2.BHMV,dl
  mov        [esi].BlkY3.BHMV,dl
   mov       [esi].BlkY4.BHMV,dl
  mov        [esi].BlkY1.BVMV,dh
   mov       [esi].BlkY2.BVMV,dh
  mov        [esi].BlkY3.BVMV,dh
   mov       [esi].BlkY4.BVMV,dh
  mov        eax,[esi].BlkY4.BestBlkLvlSWD
   mov       ebx,[esi].BlkY3.BestBlkLvlSWD
  sub        eax,ebx
   mov       ecx,[esi].BlkY2.BestBlkLvlSWD
  sub        ebx,ecx
   mov       edx,[esi].BlkY1.BestBlkLvlSWD
  sub        ecx,edx
   mov       [esi].BlkY4.BestBlkLvlSWD,eax
  mov        [esi].BlkY3.BestBlkLvlSWD,ebx
   mov       [esi].BlkY2.BestBlkLvlSWD,ecx
  mov        [esi].BlkY1.BestBlkLvlSWD,edx
   jmp       BFrmMVSettled

BelowBFrmZeroThreshold:
NonZeroBFrmVectorNotGoodEnoughGain:

  mov        ebx,[esi].BlkY4.BlkLvlSWD0Delta
   mov       ecx,[esi].BlkY3.BlkLvlSWD0Delta
  sub        ebx,ecx
   mov       edx,[esi].BlkY2.BlkLvlSWD0Delta
  sub        ecx,edx
   mov       edi,[esi].BlkY1.BlkLvlSWD0Delta
  sub        edx,edi
   mov       [esi].BlkY4.BestBlkLvlSWD,ebx
  mov        [esi].BlkY3.BestBlkLvlSWD,ecx
   mov       [esi].BlkY2.BestBlkLvlSWD,edx
  mov        [esi].BlkY1.BestBlkLvlSWD,edi
   mov       eax,[esi].BlkY1.BiDiMVs0Delta
  mov        [esi].BlkY1.BestBiDiMVs,eax
   mov       eax,[esi].BlkY2.BiDiMVs0Delta
  mov        [esi].BlkY2.BestBiDiMVs,eax
   mov       eax,[esi].BlkY3.BiDiMVs0Delta
  mov        [esi].BlkY3.BestBiDiMVs,eax
   mov       eax,[esi].BlkY4.BiDiMVs0Delta
  mov        [esi].BlkY4.BestBiDiMVs,eax
   xor       eax,eax
  mov        [esi].BlkY1.BHMV,al
   mov       [esi].BlkY2.BHMV,al
  mov        [esi].BlkY3.BHMV,al
   mov       [esi].BlkY4.BHMV,al
  mov        [esi].BlkY1.BVMV,al
   mov       [esi].BlkY2.BVMV,al
  mov        [esi].BlkY3.BVMV,al
   mov       [esi].BlkY4.BVMV,al

BFrmMVSettled:

  mov        edx,esi
   mov       bl,8                       ; Init coded block pattern

BFrmLumaBlkLoop:

  mov        esi,[edx].BlkY1.BestBlkLvlSWD  ; Get SWD for block.
   xor       eax,eax
  mov        BFrmCBP,bl
   cmp       esi,BFRMEMPTYTHRESHOLD     ; Below threshold for forcing empty?
  mov        ecx,BSWDTotal
   jl        BFrmLumaBlkEmpty

  mov        eax,[edx].BlkY1.BestBiDiMVs
   xor       ebx,ebx
  add        ecx,esi
   mov       bl,ah
  mov        BSWDTotal,ecx
   and       eax,0FFH

  call       BFrameDTQ

  mov        bl,BlkEmptyFlag[ebx]       ; Fetch 16 if block not empty; else 0.
   mov       al,BFrmCBP

BFrmLumaBlkEmpty:

  or         bl,al                      ; Factor in CBP bit for this block.
   add       edx,SIZEOF T_Blk
  shr        bl,1                       ; CF == 1 when sentinel shifted off
   jnc       BFrmLumaBlkLoop

  mov        [edx-4*SIZEOF T_Blk].CodedBlocksB,bl
   sub       edx,4*SIZEOF T_Blk
  mov        eax,QPDiv2                 ; Restore these for P frame blocks.
   mov       ebx,BQPDiv2
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       BRecip2QPToUse,eax
  ret

MMxDoBFrameChromaBlocks:

; mov        eax,QPDiv2        ; Swap these so Quantizer uses right level.
;  mov       ebx,BQPDiv2       ; (Loaded in caller.)
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       cl,INTER1MV
  mov        BRecip2QPToUse,eax
   mov       StashBlockType,cl
  mov        eax,[edx].BlkU.BestBiDiMVs
   xor       ebx,ebx
  mov        bl,ah
   and       eax,0FFH
  add        edx,4*SIZEOF T_Blk			; To know we're working on chroma.

  call       BFrameDTQ

  mov        bl,BlkEmptyFlag[ebx]       ; Fetch 16 if block not empty; else 0.
   mov       al,[edx-4*SIZEOF T_Blk].CodedBlocksB
  or         bl,al                      ; Factor in CBP bit for this block.
   mov       eax,[edx-4*SIZEOF T_Blk].BlkV.BestBiDiMVs
  mov        [edx-4*SIZEOF T_Blk].CodedBlocksB,bl
   xor       ebx,ebx
  mov        bl,ah
   and       eax,0FFH
  add        edx,SIZEOF T_Blk

  call       BFrameDTQ

  mov        bl,BlkEmptyFlag[ebx+2]     ; Fetch 32 if block not empty; else 0.
   mov       al,[edx-5*SIZEOF T_Blk].CodedBlocksB
  or         bl,al                      ; Factor in CBP bit for this block.
   mov       eax,QPDiv2                 ; Restore these for P frame blocks.
  mov        [edx-5*SIZEOF T_Blk].CodedBlocksB,bl
   mov       ebx,BQPDiv2
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       BRecip2QPToUse,eax
  sub        edx,5*SIZEOF T_Blk
  ret


;===============================================================================

; ebp -- Pitch
; edi -- Address of (0-MV) block within frame.
; edx -- Block Action Decriptor cursor
; ebx -- HMVf (HMV to apply to past reference) biased by 96.
; eax -- VMVf (VMV to apply to past reference) biased by 96.

StackOffset TEXTEQU <8>
ComputeBFrameSWDForCandRef:

  test       al,1
   mov       ecx,PreviousFrameBaseAddress
  lea        eax,[eax+eax*2]                 ; Start of VMVf*384
   jne       ME_VMVfAtHalfPelPosition

ME_VMVfAtFullPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF

  shl        eax,6
   add       ecx,edi
  shr        ebx,1                      ; CF == 1 iff HMVf is at half pel.
   jc        ME_VMVfAtFull_HMVfAtHalfPelPosition

ME_VMVfAtFull_HMVfAtFullPelPosition:

  lea        esi,[ecx+eax-48*PITCH-48]
   lea       ecx,[ebp+ebp*2]
  add        esi,ebx                     ; Address of past reference block.
   mov       eax,BFrameBaseAddress
  add        edi,eax                     ; Address of target block.
   lea       ebx,[ebp+ebp*4]
  movq       mm0,[esi+ebp*1]
  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.
  movq       mm1,[esi+ecx]     ; Ref MB, upper left block, Line 3.
   psllw     mm0,8             ; Extract diffs for line 1 even pels.
  psubw      mm1,[edi+ecx]     ; Diff for line 3.
   pmaddwd   mm0,mm0           ; Square of diffs for even pels of line 1.
  movq       mm2,[esi+ebx]
   psllw     mm1,8
  psubw      mm2,[edi+ebx]
   pmaddwd   mm1,mm1
  movq       mm3,[esi+PITCH*7]
   psllw     mm2,8
  psubw      mm3,[edi+PITCH*7]
   pmaddwd   mm2,mm2
  movq       mm4,[esi]         ; Ref MB, upper left blk, Line 0.
   psllw     mm3,8
  psubw      mm4,[edi]         ; Diff for line 0.
   paddusw   mm0,mm1           ; Accumulate SWD (lines 0 and 2).
  movq       mm1,[esi+ebp*2]
   pmaddwd   mm3,mm3
  psubw      mm1,[edi+ebp*2]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebp*4]
   pmaddwd   mm4,mm4           ; Square of diffs for odd pels of line 0.
  psubw      mm2,[edi+ebp*4]
   paddusw   mm0,mm3
  movq       mm3,[esi+ecx*2]
   pmaddwd   mm1,mm1
  psubw      mm3,[edi+ecx*2]
   pmaddwd   mm2,mm2
  paddusw    mm0,mm4
   pmaddwd   mm3,mm3
  paddusw    mm0,mm1
   ;
  paddusw    mm0,mm2
   ;
  paddusw    mm0,mm3
   ;
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   ;
  paddusw    mm0,mm1           ; mm0[48:63] is SWD for block.
   ;
  psrlq      mm0,48            ; SWD for block.
   ;
  paddd      mm7,mm0           ; mm7 is SWD for all four blocks.
   ;
  ret

ME_VMVfAtFull_HMVfAtHalfPelPosition:

  lea        esi,[ecx+eax-48*PITCH-48]
   mov       eax,BFrameBaseAddress
  add        esi,ebx                     ; Address of past reference block.
   add       edi,eax                     ; Address of target block.
  lea        ecx,[ebp+ebp*2]
   movq      mm0,mm6                     ; 8 bytes of 1
  pmullw     mm0,[esi]                   ; <(P07+P06)*256+junk ...>
   movq      mm1,mm6
  pmullw     mm1,[esi+ebp*2]
   movq      mm2,mm6
  pmullw     mm2,[esi+ebp*4]
   movq      mm3,mm6
  movq       mm4,[edi]                   ; <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlw     mm0,1                       ; <(P07+P06)*256/2+junk ...>
  pmullw     mm3,[esi+ecx*2]
   psllw     mm4,8                       ; <C06*256 C04*256 C02*256 C00*256>
  movq       mm5,[edi+ebp*2]
   psrlw     mm1,1
  psubw      mm0,mm4                     ; <(P07+P06)*256/2-C06*256+junk ...>
   psllw     mm5,8
  movq       mm4,[edi+ebp*4]
   psrlw     mm2,1
  psubw      mm1,mm5
   psllw     mm4,8
  movq       mm5,[edi+ecx*2]
   psrlw     mm3,1
  psubw      mm2,mm4
   pmaddwd   mm0,mm0                     ; SSD fof even pels of line 0.
  pmaddwd    mm1,mm1
   psllw     mm5,8
  psubw      mm3,mm5
   pmaddwd   mm2,mm2
  pmaddwd    mm3,mm3
   movq      mm5,mm6
  pmullw     mm6,[esi+ebp*1+1]           ; <(P18+P17)*256+junk ...>
   movq      mm4,mm5
  pmullw     mm5,[esi+ecx+1]
   paddusw   mm0,mm1                     ; Accum SSD for lines 0 and 2.
  paddusw    mm2,mm3
   movq      mm1,mm4
  pmullw     mm4,[esi+PITCH*5+1]
   paddusw   mm0,mm2
  pmullw     mm1,[esi+PITCH*7+1]
   psrlw     mm6,1                       ; <(P18+P17)*256/2+junk ...>
  psubw      mm6,[edi+ebp*1]             ; <(P18+P17)*256/2-C17*256+junk ...>
   psrlw     mm5,1
  psubw      mm5,[edi+ecx]
   psrlw     mm4,1
  psubw      mm4,[edi+PITCH*5]
   pmaddwd   mm6,mm6                     ; SSD for odd pels of line 1.
  pmaddwd    mm5,mm5
   psrlw     mm1,1
  psubw      mm1,[edi+PITCH*7]
   pmaddwd   mm4,mm4
  pmaddwd    mm1,mm1
   paddusw   mm0,mm6
  pxor       mm6,mm6
   paddusw   mm0,mm5
  pcmpeqb    mm5,mm5
   paddusw   mm0,mm4
  psubb      mm6,mm5                     ; Restore 8 bytes of -1.
   paddusw   mm0,mm1
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   ;
  paddusw    mm0,mm1           ; mm0[48:63] is SWD for block.
   ;
  psrlq      mm0,48            ; SWD for block.
   ;
  paddd      mm7,mm0           ; mm7 is SWD for all four blocks.
   ;
  ret

ME_VMVfAtHalfPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
  shl        eax,6
   lea       ecx,[ecx+edi-48*PITCH-48-PITCH/2]
  add        ecx,eax
   mov       eax,BFrameBaseAddress
  shr        ebx,1             ; CF == 1 iff HMVf is at half pel.
   mov       esi,ecx           ; esi and ecx same if HMVf at full pel,
  adc        ecx,ebx           ; but inc ecx if HMVf is at half pel.
   add       esi,ebx
  add        edi,eax           ; Address of target block.
   lea       ebx,[ebp+ebp*2]

  movq       mm0,[esi]         ; <P07 P06 ...>
   pcmpeqb   mm6,mm6
  movq       mm1,[ecx+ebp*1]   ; <P17 P16 ...> or <P18 P17 ...>
   psrlw     mm6,8
  movq       mm2,[esi+ebp*2]   ; <P27 P26 ...>
   paddb     mm0,mm1           ; <P07+P17 junk ...> or <P07+P18 junk ...>
  movq       mm3,[ecx+ebx]     ; <P37 P36 ...> or <P38 P37 ...>
   paddb     mm1,mm2           ; <junk P16+P26 ...> or <junk P17+P26 ...>
  movq       mm4,[esi+ebp*4]   ; <P47 P46 ...>
   paddb     mm2,mm3           ; <P27+P37 junk ...> or <P27+P38 junk ...>
  paddb      mm3,mm4           ; <junk P36+P46 ...> or <junk P37+P46 ...>
   psrlw     mm0,1             ; <(P07+P17)/2 junk ...> or (P07+P18)/2 junk ...>
  pand       mm1,mm6           ; <P16+P26 ...> or <P17+P26 ...>
   psrlw     mm2,1             ; <(P27+P37)/2 junk ...> or (P27+P38)/2 junk ...>
  movq       mm5,[edi+ebp*1]   ; <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm3,mm6           ; <P36+P46 ...> or <P37+P46 ...>
  movq       mm6,[edi+ebx]     ; <C37 C36 C35 C34 C33 C32 C31 C30>
   psllw     mm5,8             ; <C16   0 C14   0 C12   0 C10   0>
  psubw      mm0,[edi]         ; <(P07+P17)/2-C07 junk ...> or ...
   psllw     mm1,7             ; <(P16+P26)/2 ...> or <(P17+P26)/2 ...>
  psubw      mm2,[edi+ebp*2]   ; <(P27+P37)/2-C27 junk ...> or ...
   psllw     mm6,8             ; <C36   0 C34   0 C32   0 C30   0>
  pmaddwd    mm0,mm0           ; SSD of even pels of line 0.
   psubw     mm1,mm5           ; <(P16+P26)/2-C16 junk ...> or ...
  pmaddwd    mm1,mm1           ; SSD of odd pels of line 1.
   psllw     mm3,7             ; <(P36+P46)/2 ...> or <(P37+P46)/2 ...>
  pmaddwd    mm2,mm2           ; SSD of even pels of line 2.
   psubw     mm3,mm6           ; <(P36+P46)/2-C36 junk ...> or ...
  pmaddwd    mm3,mm3           ; SSD of odd pels of line 3.
   pcmpeqb   mm6,mm6
  paddusw    mm0,mm1

  movq       mm1,[ecx+PITCH*5]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebx*2]
   paddusw   mm0,mm3
  movq       mm3,[ecx+PITCH*7]
   paddb     mm4,mm1
  paddb      mm1,mm2
   paddb     mm2,mm3
  paddb      mm3,[esi+ebp*8]
   psrlw     mm6,8
  pand       mm1,mm6
   psrlw     mm4,1
  movq       mm5,[edi+PITCH*5]
   psrlw     mm2,1
  pand       mm3,mm6
   psllw     mm5,8
  movq       mm6,[edi+PITCH*7]
   psllw     mm1,7
  psubw      mm4,[edi+ebp*4]
   psllw     mm3,7
  psubw      mm2,[edi+ebx*2]
   psllw     mm6,8
  pmaddwd    mm4,mm4
   psubw     mm1,mm5
  pmaddwd    mm2,mm2
   psubw     mm3,mm6
  pmaddwd    mm1,mm1
   pxor      mm6,mm6
  pmaddwd    mm3,mm3
   paddusw   mm0,mm4
  pcmpeqb    mm5,mm5
   paddusw   mm0,mm1
  psubb      mm6,mm5  ; Restore 8 bytes of 1.
   paddusw   mm0,mm2
  paddusw    mm0,mm3
   ;
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   ;
  paddusw    mm0,mm1           ; mm0[48:63] is SWD for block.
   ;
  psrlq      mm0,48            ; SWD for block.
   ;
  paddd      mm7,mm0           ; mm7 is SWD for all four blocks.
   ;
  ret

;===============================================================================

; ebp -- Pitch
; edx -- Block Action Decriptor cursor
; ebx -- VMVf (VMV to apply to past reference) biased by 96.
; eax -- HMVf (HMV to apply to past reference) biased by 96.

StackOffset TEXTEQU <8>

BFrameDTQ:

  test       bl,1
   lea       ebx,[ebx+ebx*2]                 ; Start of VMVf*384
  mov        ecx,PreviousFrameBaseAddress
   jne       Diff_VMVfAtHalfPelPosition

Diff_VMVfAtFullPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
  shl        ebx,6
   mov       edi,[edx].BlkY1.BlkOffset   ; Address of 0-MV blk within frame.
  shr        eax,1                       ; CF == 1 iff HMVf is at half pel.
   jc        Diff_VMVfAtFull_HMVfAtHalfPelPosition

Diff_VMVfAtFull_HMVfAtFullPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48]
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   mov       ecx,PITCH/4                 ; Pitch for past reference blk, div 4.
  mov        eax,BFrameBaseAddress       ; Address of target block.
   mov       PastRefPitchDiv4,ecx
  add        edi,eax                     ; Address of target block.
   jmp       Diff_GetFutureContribToPred

Diff_VMVfAtHalfPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
  shl        ebx,6
   mov       edi,[edx].BlkY1.BlkOffset   ; Address of 0-MV blk within frame.
  shr        eax,1                       ; CF == 1 iff HMVf is at half pel.
   jc        Diff_VMVfAtHalf_HMVfAtHalfPelPosition

Diff_VMVfAtHalf_HMVfAtFullPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48-PITCH/2]; Begin get pastrefaddr. Del bias.
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   lea       eax,PelDiffs-32
  pcmpeqb    mm6,mm6
   pcmpeqb   mm7,mm7                     ; 8 bytes -1
  movq       mm2,[esi]                   ; Line0
   paddb     mm6,mm6                     ; 8 bytes of 0xFE.

@@:

  movq       mm1,[esi+ebp*1]             ; Line1
   movq      mm0,mm2                     ; Line0
  movq       mm2,[esi+ebp*2]             ; Line2
   psubb     mm1,mm7                     ; Line1+1
  paddb      mm0,mm1                     ; Line0+Line1+1
   paddb     mm1,mm2                     ; Line1+Line2+1
  pand       mm0,mm6                     ; pre-clean
   pand      mm1,mm6                     ; pre-clean
  add        eax,32                      ; Advance pointer for PelDiffs output.
   psrlq     mm0,1                       ; (Line0+Line1+1)/2
  lea        esi,[esi+ebp*2]             ; Advance input ptr 2 lines.
   psrlq     mm1,1                       ; (Line1+Line2+1)/2
  movq       [eax],mm0                   ; Store Past Ref for Line0
  movq       [eax+16],mm1                ; Store Past Ref for Line1
  test       al,32                       ; Iterate twice
   jne       @b

  test       al,64                       ; Iterate twice.
   mov       ecx,4                       ; Pitch for past reference blk, div 4.
  mov        PastRefPitchDiv4,ecx
   jne       @b

  mov        eax,BFrameBaseAddress
   lea       esi,PelDiffs                ; Address of interpolated past ref blk.
  add        edi,eax                     ; Address of target block.
   jmp       Diff_GetFutureContribToPred
  
Diff_VMVfAtFull_HMVfAtHalfPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48]   ; Begin get pastrefaddr. Del bias.
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   lea       eax,PelDiffs-32
  lea        ebx,Pel_Rnd
   xor       ecx,ecx

@@:

  movq       mm0,[esi+1]                 ; <P08 P07 P06 P05 P04 P03 P02 P01>
   pcmpeqb   mm7,mm7
  mov        cl,[esi]                    ; P00
   movq      mm2,mm0                     ; <P08 P07 P06 P05 P04 P03 P02 P01>
  movq       mm1,[esi+ebp*1+1]
   psllq     mm2,8                       ; <P07 P06 P05 P04 P03 P02 P01   0>
  paddb      mm0,[ebx+ecx*8]             ; <P08+1 P07+1 ... P01+P00+1>
   movq      mm3,mm1
  mov        cl,[esi+ebp*1]
   psllq     mm3,8
  paddb      mm1,mm3
   paddb     mm0,mm2                     ; <P08+P07+1 P07+P06+1 ... P01+P00+1>
  paddb      mm1,[ebx+ecx*8]
   paddb     mm7,mm7                     ; 8 bytes of 0xFE.
  pand       mm0,mm7                     ; pre-clean
   pand      mm1,mm7                     ; pre-clean
  add        eax,32                      ; Advance pointer for PelDiffs output.
   psrlq     mm0,1                       ; <(P08+P07+1)/2 ...>
  lea        esi,[esi+ebp*2]             ; Advance input ptr 2 lines.
   psrlq     mm1,1
  movq       [eax],mm0                   ; Store Past Ref for Line0
  movq       [eax+16],mm1                ; Store Past Ref for Line1
  test       al,32                       ; Iterate twice
   jne       @b

  test       al,64                       ; Iterate twice.
   mov       cl,4                        ; Pitch for past reference blk, div 4.
  mov        PastRefPitchDiv4,ecx
   jne       @b

  mov        eax,BFrameBaseAddress
   lea       esi,PelDiffs                ; Address of interpolated past ref blk.
  add        edi,eax                     ; Address of target block.
   jmp       Diff_GetFutureContribToPred

Diff_VMVfAtHalf_HMVfAtHalfPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48-PITCH/2]; Begin get pastrefaddr. Del bias.
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   lea       eax,PelDiffs-32
  lea        ebx,Pel_Rnd
   xor       ecx,ecx

  movq       mm3,[esi+1]             ; 0A: <P08 P07 P06 P05 P04 P03 P02 P01>
   pcmpeqb   mm7,mm7
  mov        cl,[esi]                ; 0B: P00
   movq      mm0,mm3                 ; 0C: <P08 P07 P06 P05 P04 P03 P02 P01>
  paddb      mm7,mm7                 ;     8 bytes of 0xFE.
   psllq     mm0,8                   ; 0D: <P07 P06 P05 P04 P03 P02 P01   0>
  paddb      mm3,[ebx+ecx*8]         ; 0E: <P08+1 P07+1 ... P01+P00+1>
   movq      mm6,mm7                 ;     8 bytes of 0xFE.

@@:

  movq       mm1,[esi+ebp*1+1]       ; 1A: <P18 P17 P16 P15 P14 P13 P12 P11>
   paddb     mm0,mm3                 ; 0F: <P08+P07+1 ... P01+P00+1>
  mov        cl,[esi+ebp*1]          ; 1B: P10
   movq      mm3,mm1                 ; 1C: <P18 P17 P16 P15 P14 P13 P12 P11>
  movq       mm2,[esi+ebp*2+1]       ; 2A: <P28 P27 P26 P25 P24 P23 P22 P21>
   psllq     mm3,8                   ; 1D: <P17 P16 P15 P14 P13 P12 P11   0>
  paddb      mm1,[ebx+ecx*8]         ; 1E: <P18+1 P17+1 ... P11+P10+1>
   movq      mm4,mm2                 ; 2C: <P28 P27 P26 P25 P24 P23 P22 P21>
  mov        cl,[esi+ebp*2]          ; 2B: P20
   paddb     mm1,mm3                 ; 1F: <P18+P17+1 ... P11+P10+1>
  pandn      mm6,mm1                 ; 0G: <(P18+P17+1)&1 ...>
   psllq     mm4,8                   ; 2D: <P27 P26 P25 P24 P23 P22 P21   0>
  paddb      mm2,[ebx+ecx*8]         ; 2E: <P28+1 P27+1 ... P21+P20+1>
   movq      mm5,mm6                 ; 1G: <(P18+P17+1)&1 ...>
  paddb      mm2,mm4                 ; 2F: <P28+P27+1 ... P21+P20+1>
   pand      mm6,mm0                 ; 0H: <(P18+P17+1)&(P08+P07+1)&1 ...>
  pand       mm5,mm2                 ; 1H: <(P18+P17+1)&(P28+P27+1)&1 ...>
   pand      mm0,mm7                 ; 0I: pre-clean for divide
  pand       mm1,mm7                 ; 1I: pre-clean for divide
   psrlq     mm0,1                   ; 0J: <(P08+P07+1)/2 ...>
  movq       mm3,mm2                 ;     Save line 2 for next iter's line 0.
   psrlq     mm1,1                   ; 1J: <(P18+P17+1)/2 ...>
  pand       mm2,mm7                 ; 2I: pre-clean for divide
   paddb     mm0,mm1                 ; 0K: <(P08+P07+1)/2+(P18+P17+1)/2 ...>
  paddb      mm6,mm0                 ; 0L: <(P08+P07+P18+P17+2)/2 ...>
   psrlq     mm2,1                   ; 2J: <(P28+P27+1)/2 ...>
  paddb      mm1,mm2                 ; 1K: <(P18+P17+1)/2+(P28+P27+1)/2 ...>
   pand      mm6,mm7                 ; 0M: pre-clean for divide
  paddb      mm5,mm1                 ; 1L: <(P18+P17+P28+P27+2)/2 ...>
   psrlq     mm6,1                   ; 0M: <(P08+P07+P18+P17+2)/4 ...>
  add        eax,32                  ;     Advance pointer for PelDiffs output.
   pand      mm5,mm7                 ; 1M: pre-clean for divide
  lea        esi,[esi+ebp*2]         ;     Advance input ptr 2 lines.
   psrlq     mm5,1                   ; 1N: <(P18+P17+P28+P27+2)/4 ...>
  movq       [eax],mm6               ; 0O: Store Past Ref for Line0
   pxor      mm0,mm0                 ;     So that add of mm3 is just like movq.
  movq       [eax+16],mm5            ; 1O: Store Past Ref for Line1
   movq      mm6,mm7                 ;     8 bytes of 0xFE.
  test       al,32                   ;     Iterate twice
   jne       @b

  test       al,64                       ; Iterate twice.
   mov       cl,4                        ; Pitch for past reference blk, div 4.
  jne        @b

  mov        eax,BFrameBaseAddress
   lea       esi,PelDiffs                ; Address of interpolated past ref blk.
  add        edi,eax                     ; Address of target block.
   mov       PastRefPitchDiv4,ecx

Diff_GetFutureContribToPred:

;===============================================================================
;
; Registers at entry:
; edi -- Pointer to target block.
; esi -- Pointer to past reference.
; edx -- Block Descriptor within MacroBlockActionDescritptorStream
;
; Subsequent assignments:
;
; ebp -- Pitch for past reference block, div 4.  Loop counter in high 2 bits.
; ecx -- Pointer to future reference block
; ebx -- Pointer to list of indices of multipliers to wt past and future refs.
; eax,edx -- Index of multiplier to weight past and future ref.

  xor        ecx,ecx
   mov       eax,edx
IF SIZEOF T_Blk-16
  **** The magic leaks out if size of block descriptor is not 16.
ENDIF
  mov        cl,[edx].BlkY1.BestHMVb      ; HMV for future reference block.
   and       edx,112                      ; Extract block number (times 16).
  xor        ebx,ebx
   mov       BlockActionDescrCursor,eax
  mov        bl,[eax].BlkY1.BestVMVb      ; VMV for future reference block.
   mov       eax,LeftRightBlkPosition[edx]
  mov        ebp,ecx
CONST_384   TEXTEQU <384>
   mov       edx,UpDownBlkPosition[edx]
  mov        cl,[eax+ecx*2]              ; Get horz part of past/future wt sel.
IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
   lea       eax,[ebx+ebx*2]             ; Start of VMVb*384
  mov        bl,[edx+ebx*2]              ; Get vert part of past/future wt sel.
  shl        eax,6
   mov       edx,BFrameToFuture
  lea        ebx,Diff_IdxRefWts[ecx+ebx] ; Addr of list of wts for refs.
   test      al,64                       ; Is VMVb odd?
  lea        eax,[eax+edx]               ; Begin to get addr futr ref.
   jne       Diff_VMVbAtHalfPelPosition

Diff_VMVbAtFullPelPosition:

CONST_384   TEXTEQU <384>

  shr        ebp,1                     ; CF == 1 iff HMVf is at half pel.
   lea       esp,[esp-128]
StackOffset TEXTEQU <136>
  lea        ecx,[eax+edi-48*PITCH-48]
   jc        Diff_VMVbAtFull_HMVbAtHalfPelPosition

Diff_VMVbAtFull_HMVbAtFullPelPosition:

CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   xor       edx,edx

@@:

StackOffset TEXTEQU <undefined>

  mov        al,[ebx]                  ; 0A: Index of weights for line 0.
   add       esp,32                    ;     Advance Pel Difference cursor
  mov        dl,[ebx+1]                ; 1A: Index of weights for line 1.
   add       ebx,2                     ;     Advance list ptr for ref weights.
  movq       mm0,[ecx]                 ; 0B: <F07 F06 F05 F04 F03 F02 F01 F00>
   pcmpeqb   mm7,mm7
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   paddb     mm7,mm7                   ;     8 bytes of 0xFE
  movq       mm3,[esi]                 ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   pand      mm0,mm2                   ; 0E: <In?F07:00 In?F06:00 ...>
  pandn      mm2,mm3                   ; 0F: <In?00:P07 In?00:P06 ...>
   paddb     mm0,mm3                   ; 0G: <In?F07+P07:P07 ...>
  movq       mm1,[ecx+PITCH]           ; 1B: <F17 F16 F15 F14 F13 F12 F11 F10>
   paddb     mm0,mm2                   ; 0H: <In?F07+P07:2P07 ...>
  movq       mm2,FutureWt_FF_or_00[edx]; 1C: <In?FF:00 ...>
   pand      mm0,mm7                   ; 0I: pre-clean
  movq       mm3,[esi+ebp*4]           ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   pand      mm1,mm2                   ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm2,mm3                   ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                   ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]                 ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                     ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                   ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   paddb     mm1,mm2                   ; 1H: <In?F17+P17:2P17 ...>
  movq       mm4,[edi+PITCH]           ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm1,mm7                   ; 1I: pre-clean
  add        edi,PITCH*2               ;     Advance Target Blk cursor
   psrlq     mm1,1                     ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3              ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm4,mm1                   ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  add        ecx,PITCH*2               ;     Advance Future Ref Blk cursor
   lea       esi,[esi+ebp*8]           ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm4           ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
  add        ebp,080000000H            ;     Iterate twice
   jnc       @b

  test       ebp,040000000H            ;     Iterate twice
  lea        ebp,[ebp+040000000H]
   je        @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

Diff_VMVbAtHalfPelPosition:

CONST_384   TEXTEQU <384>

  shr        ebp,1                     ; CF == 1 iff HMVf is at half pel.
   lea       esp,[esp-128]
StackOffset TEXTEQU <136>
  lea        ecx,[eax+edi-48*PITCH-48-PITCH/2]
   jc        Diff_VMVbAtHalf_HMVbAtHalfPelPosition

Diff_VMVbAtHalf_HMVbAtFullPelPosition:

CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   xor       edx,edx
  movq       mm6,[ecx]                 ; 0B: <F07 F06 F05 F04 F03 F02 F01 F00>
   pcmpeqb   mm7,mm7                   ;     8 bytes -1

@@:

StackOffset TEXTEQU <undefined>

  movq       mm1,[ecx+PITCH]           ; 1a: <f17 f16 f15 f14 f13 f12 f11 f10>
   movq      mm0,mm6                   ; 0a: <f07 f06 f05 f04 f03 f02 f01 f00>
  mov        al,[ebx]                  ; 0A: Index of weights for line 0.
   psubb     mm1,mm7                   ;  b: <f17+1 ...>
  movq       mm6,[ecx+PITCH*2]         ; 2a: <f27 f26 f25 f24 f23 f22 f21 f20>
   paddb     mm0,mm1                   ; 0c: <f07+f17+1..>
  mov        dl,[ebx+1]                ; 1A: Index of weights for line 1.
   paddb     mm7,mm7                   ;     8 bytes of 0xFE
  paddb      mm1,mm6                   ; 1c: <f17+f27+1..>
   pand      mm0,mm7                   ; 0d: pre-clean
  pand       mm1,mm7                   ; 1d: pre-clean
   psrlq     mm0,1                     ; 0B: <(F07 = f07+f17+1)/2>
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   psrlq     mm1,1                     ; 1B: <(F17 = f17+f27+1)/2>
  movq       mm3,[esi]                 ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   pand      mm0,mm2                   ; 0E: <In?F07:00 In?F06:00 ...>
  pandn      mm2,mm3                   ; 0F: <In?00:P07 In?00:P06 ...>
   paddb     mm0,mm3                   ; 0G: <In?F07+P07:P07 ...>
  add        ebx,2                     ;     Advance list ptr for ref weights.
   paddb     mm0,mm2                   ; 0H: <In?F07+P07:2P07 ...>
  movq       mm2,FutureWt_FF_or_00[edx]; 1C: <In?FF:00 ...>
   pand      mm0,mm7                   ; 0I: pre-clean
  movq       mm3,[esi+ebp*4]           ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   pand      mm1,mm2                   ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm2,mm3                   ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                   ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]                 ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                     ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                   ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   add       esp,32                    ;     Advance Pel Difference cursor
  movq       mm4,[edi+PITCH]           ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   paddb     mm1,mm2                   ; 1H: <In?F17+P17:2P17 ...>
  add        ecx,PITCH*2               ;     Advance Future Ref Blk cursor
   pand      mm1,mm7                   ; 1I: pre-clean
  add        edi,PITCH*2               ;     Advance Target Blk cursor
   psrlq     mm1,1                     ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3              ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm4,mm1                   ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  pcmpeqb    mm7,mm7                   ;     8 bytes -1
   lea       esi,[esi+ebp*8]           ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm4           ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
   pcmpeqb   mm7,mm7                   ;     8 bytes -1
  add        ebp,080000000H            ;     Iterate twice
   jnc       @b

  add        ebp,040000000H            ;     Iterate twice
  test       ebp,ebp
   jns       @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

Diff_VMVbAtFull_HMVbAtHalfPelPosition:

StackOffset TEXTEQU <136>
CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   lea       edx,Pel_Rnd

@@:

StackOffset TEXTEQU <undefined>

  movq       mm0,[ecx+1]               ; 0a: <f08 f07 f06 f05 f04 f03 f02 f01>
   pcmpeqb   mm7,mm7
  mov        al,[ecx]                  ; 0b: f00
   movq      mm2,mm0                   ; 0c: <f08 f07 f06 f05 f04 f03 f02 f01>
  movq       mm1,[ecx+PITCH+1]         ; 1a: <f18 f17 f16 f15 f14 f13 f12 f11>
   psllq     mm2,8                     ; 0d: <f07 f06 f05 f04 f03 f02 f01   0>
  paddb      mm0,[edx+eax*8]           ; 0e: <f08+1 f07+1 ... f01+f00+1>
   movq      mm3,mm1                   ; 1c: <f18 f17 f16 f15 f14 f13 f12 f11>
  mov        al,[ecx+PITCH]            ; 1b: f10
   psllq     mm3,8                     ; 1d: <f17 f16 f15 f14 f13 f12 f11   0>
  paddb      mm0,mm2                   ; 0f: <f08+f07+1 f07+f06+1 ... f01+f00+1>
   paddb     mm1,mm3                   ; 1f: <f18+f17   f17+f16   ... f11      >
  paddb      mm1,[edx+eax*8]           ; 1e: <f18+f17+1 f17+f16+1 ... f11+f10+1>
   paddb     mm7,mm7                   ;     8 bytes of 0xFE.
  mov        al,[ebx]                  ; 0A: Index of weights for line 0.
   pand      mm0,mm7                   ; 0g: pre-clean
  movq       mm3,[esi]                 ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   psrlq     mm0,1                     ; 0B: <F07 = (f08+f07+1)/2 ...>
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   pand      mm1,mm7                   ; 1g: pre-clean
  mov        al,[ebx+1]                ; 1A: Index of weights for line 1.
   psrlq     mm1,1                     ; 1B: <F17 = (f18+f17+1)/2 ...>
  pand       mm0,mm2                   ; 0E: <In?F07:00 In?F06:00 ...>
   pandn     mm2,mm3                   ; 0F: <In?00:P07 In?00:P06 ...>
  movq       mm4,FutureWt_FF_or_00[eax]; 1C: <In?FF:00 ...>
   paddb     mm0,mm3                   ; 0G: <In?F07+P07:P07 ...>
  movq       mm3,[esi+ebp*4]           ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   paddb     mm0,mm2                   ; 0H: <In?F07+P07:2P07 ...>
  pand       mm0,mm7                   ; 0I: pre-clean
   pand      mm1,mm4                   ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm4,mm3                   ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                   ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]                 ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                     ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                   ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   add       esp,32                    ;     Advance Pel Difference cursor
  add        ecx,PITCH*2               ;     Advance Future Ref Blk cursor
   paddb     mm1,mm4                   ; 1H: <In?F17+P17:2P17 ...>
  movq       mm4,[edi+PITCH]           ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm1,mm7                   ; 1I: pre-clean
  add        edi,PITCH*2               ;     Advance Target Blk cursor
   psrlq     mm1,1                     ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3              ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm4,mm1                   ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  add        ebx,2                     ;     Advance list ptr for ref weights.
   lea       esi,[esi+ebp*8]           ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm4           ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
  add        ebp,080000000H            ;     Iterate twice
   jnc       @b

  add        ebp,040000000H            ;     Iterate twice
  test       ebp,ebp
   jns       @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

Diff_VMVbAtHalf_HMVbAtHalfPelPosition:

StackOffset TEXTEQU <136>
CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   lea       edx,Pel_Rnd
  movq       mm4,[ecx+1]               ; 0a: <f08 f07 f06 f05 f04 f03 f02 f01>
   pcmpeqb   mm7,mm7
  mov        al,[ecx]                  ; 0b: f00
   movq      mm0,mm4                   ; 0c: <f08 f07 f06 f05 f04 f03 f02 f01>
  paddb      mm7,mm7                   ;     8 bytes of 0xFE.
   psllq     mm0,8                     ; 0d: <f07 f06 f05 f04 f03 f02 f01   0>
  paddb      mm4,[edx+eax*8]           ; 0e: <f08+1 f07+1 ... f01+f00+1>
   movq      mm6,mm7                   ;     8 bytes of 0xFE.

@@:

StackOffset TEXTEQU <undefined>

  movq       mm1,[ecx+PITCH+1]       ; 1a: <f18 f17 f16 f15 f14 f13 f12 f11>
   paddb     mm0,mm4                 ; 0f: <f08+f07+1 ... f01+f00+1>
  mov        al,[ecx+PITCH]          ; 1b: f10
   movq      mm3,mm1                 ; 1c: <f18 f17 f16 f15 f14 f13 f12 f11>
  movq       mm2,[ecx+PITCH*2+1]     ; 2a: <f28 f27 f26 f25 f24 f23 f22 f21>
   psllq     mm3,8                   ; 1d: <f17 f16 f15 f14 f13 f12 f11   0>
  paddb      mm1,[edx+eax*8]         ; 1e: <f18+1 f17+1 ... f11+f10+1>
   movq      mm4,mm2                 ; 2c: <f28 f27 f26 f25 f24 f23 f22 f21>
  mov        al,[ecx+PITCH*2]        ; 2b: f20
   paddb     mm1,mm3                 ; 1f: <f18+f17+1 ... f11+f10+1>
  pandn      mm6,mm1                 ; 0g: <(f18+f17+1)&1 ...>
   psllq     mm4,8                   ; 2d: <f27 f26 f25 f24 f23 f22 f21   0>
  paddb      mm2,[edx+eax*8]         ; 2e: <f28+1 f27+1 ... f21+f20+1>
   movq      mm5,mm6                 ; 1g: <(f18+f17+1)&1 ...>
  paddb      mm2,mm4                 ; 2f: <f28+f27+1 ... f21+f20+1>
   pand      mm6,mm0                 ; 0h: <(f18+f17+1)&(f08+f07+1)&1 ...>
  pand       mm5,mm2                 ; 1h: <(f18+f17+1)&(f28+f27+1)&1 ...>
   pand      mm0,mm7                 ; 0i: pre-clean for divide
  pand       mm1,mm7                 ; 1i: pre-clean for divide
   psrlq     mm0,1                   ; 0j: <(f08+f07+1)/2 ...>
  movq       mm4,mm2                 ;     Save line 2 for next iter's line 0.
   psrlq     mm1,1                   ; 1j: <(f18+f17+1)/2 ...>
  pand       mm2,mm7                 ; 2i: pre-clean for divide
   paddb     mm0,mm1                 ; 0k: <(f08+f07+1)/2+(f18+f17+1)/2 ...>
  paddb      mm0,mm6                 ; 0l: <(f08+f07+f18+f17+2)/2 ...>
   psrlq     mm2,1                   ; 2j: <(f28+f27+1)/2 ...>
  paddb      mm1,mm2                 ; 1k: <(f18+f17+1)/2+(f28+f27+1)/2 ...>
   pand      mm0,mm7                 ; 0m: pre-clean for divide
  mov        al,[ebx]                ; 0A: Index of weights for line 0.
   paddb     mm1,mm5                 ; 1l: <(f18+f17+f28+f27+2)/2 ...>
  movq       mm3,[esi]               ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   pand      mm1,mm7                 ; 1m: pre-clean for divide
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   psrlq     mm0,1                   ; 0B: <F07 = (f08+f07+f18+f17+2)/4 ...>
  mov        al,[ebx+1]              ; 1A: Index of weights for line 1.
   psrlq     mm1,1                   ; 1B: <F17 = (f18+f17+f28+f27+2)/4 ...>
  pand       mm0,mm2                 ; 0E: <In?F07:00 In?F06:00 ...>
   pandn     mm2,mm3                 ; 0F: <In?00:P07 In?00:P06 ...>
  movq       mm5,FutureWt_FF_or_00[eax]; 1C: <In?FF:00 ...>
   paddb     mm0,mm3                 ; 0G: <In?F07+P07:P07 ...>
  movq       mm3,[esi+ebp*4]         ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   paddb     mm0,mm2                 ; 0H: <In?F07+P07:2P07 ...>
  pand       mm0,mm7                 ; 0I: pre-clean
   pand      mm1,mm5                 ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm5,mm3                 ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                 ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]               ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                   ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                 ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   add       esp,32                  ;     Advance Pel Difference cursor
  paddb      mm1,mm5                 ; 1H: <In?F17+P17:2P17 ...>
   add       ecx,PITCH*2             ;     Advance Future Ref Blk cursor
  movq       mm5,[edi+PITCH]         ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm1,mm7                 ; 1I: pre-clean
  add        edi,PITCH*2             ;     Advance Target Blk cursor
   psrlq     mm1,1                   ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3            ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm5,mm1                 ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  add        ebx,2                   ;     Advance list ptr for ref weights.
   lea       esi,[esi+ebp*8]         ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm5         ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
   pxor      mm0,mm0                 ;     So that add of mm4 is just like movq.
  add        ebp,080000000H          ;     Iterate twice
   movq      mm6,mm7                 ;     8 bytes of 0xFE.
  jnc        @b

  add        ebp,040000000H            ;     Iterate twice
  test       ebp,ebp
   jns       @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

CONST_384   TEXTEQU <ebp>

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ex5me.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5me.asv   1.17   24 Sep 1996 11:27:00   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\ex5me.asv  $
;// 
;//    Rev 1.17   24 Sep 1996 11:27:00   BNICKERS
;// 
;// Fix register colision.
;// 
;//    Rev 1.16   24 Sep 1996 10:40:32   BNICKERS
;// For H261, zero out motion vectors when classifying MB as Intra.
;// 
;//    Rev 1.13   19 Aug 1996 13:48:26   BNICKERS
;// Provide threshold and differential variables for spatial filtering.
;// 
;//    Rev 1.12   17 Jun 1996 15:19:34   BNICKERS
;// Fix recording of block and MB SWDs for Spatial Loop Filtering case in H261.
;// 
;//    Rev 1.11   30 May 1996 16:40:14   BNICKERS
;// Fix order of arguments.
;// 
;//    Rev 1.10   30 May 1996 15:08:36   BNICKERS
;// Fixed minor error in recent IA ME speed improvements.
;// 
;//    Rev 1.9   29 May 1996 15:37:58   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.8   15 Apr 1996 10:48:48   AKASAI
;// Fixed bug in Spatial loop filter code.  Code had been unrolled and
;// the second case had not been updated in the fix put in place of
;// (for) the first case.  Basically an ebx instead of bl that cased 
;// and overflow from 7F to 3F.
;// 
;//    Rev 1.7   15 Feb 1996 15:39:26   BNICKERS
;// No change.
;// 
;//    Rev 1.6   15 Feb 1996 14:39:00   BNICKERS
;// Fix bug wherein access to area outside stack frame was occurring.
;// 
;//    Rev 1.5   15 Jan 1996 14:31:40   BNICKERS
;// Fix decrement of ref area addr when half pel upward is best in block ME.
;// Broadcast macroblock level MV when block gets classified as Intra.
;// 
;//    Rev 1.4   12 Jan 1996 13:16:08   BNICKERS
;// Fix SLF so that 3 7F pels doesn't overflow, and result in 3F instead of 7F.
;// 
;//    Rev 1.3   27 Dec 1995 15:32:46   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   19 Dec 1995 17:11:16   RMCKENZX
;// fixed 2 bugs:
;//   1.  do +-15 pel search if central and NOT 4 mv / macroblock
;//      (was doing when central AND 4 mv / macroblock)
;//   2.  correctly compute motion vectors when doing 4 motion
;//      vectors per block.
;// 
;//    Rev 1.1   28 Nov 1995 15:25:48   AKASAI
;// Added white space so that will complie with the long lines.
;// 
;//    Rev 1.0   28 Nov 1995 14:37:00   BECHOLS
;// Initial revision.
;// 
;// 
;//    Rev 1.13   22 Nov 1995 15:32:42   DBRUCKS
;// Brian made this change on my system.
;// Increased a value to simplify debugging
;// 
;// 
;// 
;//    Rev 1.12   17 Nov 1995 10:43:58   BNICKERS
;// Fix problems with B-Frame ME.
;// 
;// 
;// 
;//    Rev 1.11   31 Oct 1995 11:44:26   BNICKERS
;// Save/restore ebx.
;//
;////////////////////////////////////////////////////////////////////////////
;
; MotionEstimation -- This function performs motion estimation for the macroblocks identified
;                     in the input list.
;                     Conditional assembly selects either the H263 or H261 version.
;
; Input Arguments:
;
;   MBlockActionStream
;
;     The list of macroblocks for which we need to perform motion estimation.
;
;     Upon input, the following fields must be defined:
;
;       CodedBlocks -- Bit 6 must be set for the last macroblock to be processed.
;
;       FirstMEState -- must be 0 for macroblocks that are forced to be Intracoded.  An
;                       IntraSWD will be calculated.
;                       Other macroblocks must have the following values:
;                        1:  upper left, without advanced prediction.  (Advanced prediction
;                            only applies to H263.)
;                        2:  upper edge, without advanced prediction.
;                        3:  upper right, without advanced prediction.
;                        4:  left edge, without advanced prediction.
;                        5:  central block, or any block if advanced prediction is being done.
;                        6:  right edge, without advanced prediction.
;                        7:  lower left, without advanced prediction.
;                        8:  lower edge, without advanced prediction.
;                        9:  lower right, without advanced prediction.
;                       If vertical motion is NOT allowed:
;                       10:  left edge, without advanced prediction.
;                       11:  central block, or any block if advanced prediction is being done.
;                       12:  right edge, without advanced prediction.
;                       *** Note that with advanced prediction, only initial states 0, 4, or
;                           11 can be specified.  Doing block level motion vectors mandates
;                           advanced prediction, but in that case, only initial
;                           states 0 and 4 are allowed.
;
;       BlkOffset -- must be defined for each of the blocks in the macroblocks.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.
;
;   PreviousFrameBaseAddress -- Address of upper left viewable pel in the previous Y plane.  Whether this is the
;                               reconstructed previous frame, or the original, is up to the caller to decide.
;
;   FilteredFrameBaseAddress -- Address of upper left viewable pel in the scratch area that this function can record
;                               the spatially filtered prediction for each block, so that frame differencing can
;                               utilize it rather than have to recompute it.  (H261 only)
;
;   DoRadius15Search -- TRUE if central macroblocks should search a distance of 15 from center.  Else searches 7 out.
;
;   DoHalfPelEstimation -- TRUE if we should do ME to half pel resolution.  This is only applicable for H263 and must
;                          be FALSE for H261.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   DoBlockLevelVectors -- TRUE if we should do ME at block level.  This is only applicable for H263 and must be FALSE
;                          for H261.  (Note:  TRUE must be 1; FALSE must be 0).
;   DoSpatialFiltering -- TRUE if we should determine if spatially filtering the prediction reduces the SWD.  Only
;                         applicable for H261 and must be FALSE for H263.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   ZeroVectorThreshold -- If the SWD for a macroblock is less than this threshold, we do not bother searching for a
;                          better motion vector.  Compute as follows, where D is the average tolerable pel difference
;                          to satisfy this threshold.  (Initial recommendation:  D=2  ==> ZVT=384)
;                             ZVT = (128 * ((int)((D**1.6)+.5)))
;
;   NonZeroDifferential -- After searching for the best motion vector (or individual block motion vectors, if enabled),
;                          if the macroblock's SWD is not better than it was for the zero vector -- not better by at
;                          least this amount -- then we revert to the zero vector.  We are comparing two macroblock
;                          SWDs, both calculated as follows:   (Initial recommendation:	 NZD=128)
;                            For each of 128 match points, where D is its Abs Diff, accumulate ((int)(M**1.6)+.5)))
;
;   BlockMVDifferential -- The amount by which the sum of four block level SWDs must be better than a single macroblock
;                          level SWD to cause us to choose block level motion vectors.  See NonZeroDifferential for
;                          how the SWDs are calculated.  Only applicable for H261.  (Initial recommendation:  BMVD=128)
;
;   EmptyThreshold -- If the SWD for a block is less than this, the block is forced empty.  Compute as follows, where D
;                     is the average tolerable pel diff to satisfy threshold.  (Initial recommendation:  D=3 ==> ET=96)
;                        ET = (32 * ((int)((D**1.6)+.5)))
;
;   InterCodingThreshold -- If any of the blocks are forced empty, we can simply skip calculating the INTRASWD for the
;                           macroblock.  If none of the blocks are forced empty, we will compare the macroblock's SWD
;                           against this threshold.  If below the threshold, we will likewise skip calculating the
;                           INTRASWD.  Otherwise, we will calculate the INTRASWD, and if it is less than the [Inter]SWD,
;                           we will classify the block as INTRA-coded.  Compute as follows, where D is the average
;                           tolerable pel difference to satisfy threshold.  (Initial recommendation:  D=4 ==> ICT=1152)
;                             ICT = (128 * ((int)((D**1.6)+.5)))
;
;   IntraCodingDifferential -- For INTRA coding to occur, the INTRASWD must be better than the INTERSWD by at least
;                              this amount.
;
; Output Arguments
;
;   MBlockActionStream
;
;     These fields are defined as follows upon return:
;
;       BlockType -- Set to INTRA, INTER1MV, or (H263 only) INTER4MV.
;
;       PHMV and PVMV -- The horizontal and vertical motion vectors,  in units of a half pel.
;
;       BHMV and BVMV -- These fields get clobbered.
;
;       PastRef -- If BlockType != INTRA, set to the address of the reference block.
;
;                  If Horizontal MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+1.
;
;                  If Vertical MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+PITCH.
;
;                  If both MVs indicate half pel positions, the prediction for the upper left pel of the block is the
;                  average of the pels at PastRef, PastRef+1, PastRef+PITCH, and PastRef+PITCH+1.
;
;                  Indications of a half pel position can only happen for H263.
;
;                  In H261, when spatial filtering is done, the address will be in the SpatiallyFilteredFrame, where
;                  this function stashes the spatially filtered prediction for subsequent reuse by frame differencing.
;
;       CodedBlocks -- Bits 4 and 5 are turned on, indicating that the U and V blocks should be processed.  (If the
;                      FDCT function finds them to quantize to empty, it will mark them as empty.)
;
;                      Bits 0 thru 3 are cleared for each of blocks 1 thru 4 that MotionEstimation forces empty;
;                      they are set otherwise.
;
;                      Bits 6 and 7 are left unchanged.
;                      
;       SWD -- Set to the sum of the SWDs for the four luma blocks in the macroblock.  The SWD for any block that is
;              forced empty, is NOT included in the sum.
;
;
;
;   IntraSWDTotal  -- The sum of the block SWDs for all Intracoded macroblocks.
;
;   IntraSWDBlocks -- The number of blocks that make up the IntraSWDTotal.
;
;   InterSWDTotal  -- The sum of the block SWDs for all Intercoded macroblocks.
;                     None of the blocks forced empty are included in this.
;
;   InterSWDBlocks -- The number of blocks that make up the InterSWDTotal.
;
;
; Other assumptions:
;
;   For performance reasons, it is assumed that the layout of current and previous frames (and spatially filtered
;   frame for H261) rigourously conforms to the following guide.
;
;   The spatially filtered frame (only present and applicable for H261) is an output frame into which MotionEstimation
;   places spatially filtered macroblocks as it determines if filtering is good for a macroblock.  If it determines
;   such, frame differencing will be able to re-use the spatially filtered macroblock, rather than recomputing it.
;
;   Cache
;   Alignment
;   Points:  v       v       v       v       v       v       v       v       v       v       v       v       v
;             16 | 352 (narrower pictures are left justified)                                            | 16
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Current Frame Y Plane                                                                | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected.)                                                                |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Current Frame U Plane                    | D |  Current Frame V Plane                    |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;            72 dummy bytes.  I.e. enough dummy space to assure that MOD ((Previous_Frame - Current_Frame), 128) == 80
;            +-----------------------------------------------------------------------------------------------+
;            |                                                                                               |
;   16 lines | If Unrestricted Motion Vectors selected, 16 lines must appear above and below previous frame, |
;            | and these lines plus the 16 columns to the left and 16 columns to the right of the previous   |
;            | frame must be initialized to the values at the edges and corners, propagated outward.  If     |
;            | Unrestricted Motion Vectors is off, these lines don't have to be allocated.                   |
;            |                                                                                               |
;            |   +---------------------------------------------------------------------------------------+   +
;   Frame    |   |  Previous Frame Y Plane                                                               |   |
;   Height   |   |                                                                                       |   |
;   Lines    |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   +---------------------------------------------------------------------------------------+   +
;            |                                                                                               |
;   16 lines | See comment above Previous Y Plane                                                            |
;            |                                                                                               |
;            |+--- 8 bytes of dummy space.  Must be there, whether unrestricted MV or not.                   |
;            ||                                                                                              |
;            |v+-----------------------------------------------+---------------------------------------------+-+
;            +-+                                               |                                               |
;              | See comment above Previous Y Plane.           | See comment above Previous Y Plane.           |
;   8 lines    | Same idea here, but 8 lines are needed above  | Same idea here, but 8 lines are needed        |
;              | and below U plane, and 8 columns on each side.| and below V plane, and 8 columns on each side.|
;              |                                               |                                               |
;              |8  176                                        8|8  176                                        8|
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              | |  Previous Frame U Plane                   | | |  Previous Frame V Plane                   | |
;   Frame      | |                                           | | |                                           | |
;   Height     | |                                           | | |                                           | |
;   Div By 2   | |                                           | | |                                           | |
;   Lines      | |                                           | | |                                           | |
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              |                                               |                                               |
;   8 lines    | See comment above Previous U Plane            | See comment above Previous V Plane            |
;              |                                               |                                               |
;              |                                               |                                               |
;              |                                               |                                               |
;              +-----------------------------------------------+---------------------------------------------+-+
;            Enough dummy space to assure that MOD ((Spatial_Frame - Previous_Frame), 4096) == 2032
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Spatially Filtered Y Plane (present only for H261)                                   | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected, which is certainly the case for H261.)                          |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Spatially Filtered U plane (H261 only)   | D |  Spatially Filtered V plane (H261 only)   |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;
; Cache layout of the target block and the full range for the reference area (as restricted to +/- 7 in vertical,
; and +/- 7 (expandable to +/- 15) in horizontal, is as shown here.  Each box represents a cache line (32 bytes),
; increasing incrementally from left to right, and then to the next row (like reading a book).  The 128 boxes taken
; as a whole represent 4Kbytes.  The boxes are populated as follows:
;
;   R -- Data from the reference area.  Each box contains 23 of the pels belonging to a line of the reference area.
;        The remaining 7 pels of the line is either in the box to the left (for reference areas used to provide
;        predictions for target macroblocks that begin at an address 0-mod-32), or to the right (for target MBs that
;        begin at an address 16-mod-32).  There are 30 R's corresponding to the 30-line limit on the vertical distance
;        we might search.
; 
;   T -- Data from the target macroblock.  Each box contains a full line (16 pels) for each of two adjacent
;        macroblocks.  There are 16 T's corresponding to the 16 lines of the macroblocks.
;
;   S -- Space for the spatially filtered macroblock (H261 only).
;
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+
;
; Thus, in a logical sense, the above data fits into one of the 4K data cache pages, leaving the other for all other
; data.  Care has been taken to assure that the tables and the stack space needed by this function fit nicely into
; the other data cache page.    Only the MBlockActionStream remains to conflict with the above data structures.  That
; is both unavoidable, and of minimal consequence.
; An algorithm has been selected that calculates fewer SWDs (Sum of Weighted Differences) than the typical log search.
; In the typical log search, a three level search is done, in which the SWDs are compared for the center point and a
; point at each 45 degrees, initially 4 pels away, then 2, then 1.  This requires a total of 25 SWDs for each
; macroblock (except those near edges or corners).
;
; In this algorithm, six levels are performed, with each odd level being a horizontal search, and each even level being
; a vertical search.  Each search compares the SWD for the center point with that of a point in each direction on the
; applicable axis.  This requires 13 SWDs, and a lot simpler control structure.  Here is an example picture of a
; search, in which "0" represents the initial center point (the 0,0 motion vector), "A", and "a" represent the first
; search points, etc.  In this example, the "winner" of each level of the search proceeds as follows:  a, B, C, C, E, F,
; arriving at a motion vector of -1 horizontal, 5 vertical.
;
;                ...............
;                ...............
;                ...............
;                ...b...........
;                ...............
;                ...............
;                ...............
;                ...a...0...A...
;                ...............
;                .....d.........
;                ......f........
;                .c.BeCE........
;                ......F........
;                .....D.........
;                ...............
;
;
; A word about data cache performance.  Conceptually, the tables and local variables used by this function are placed
; in memory such that they will fit in one 4K page of the on-chip data cache.  For the Pentium (tm) microprocessor,
; this leaves the other 4K page for other purposes.  The other data structures consist of:
;
;   The current frame, from which we need to access the lines of the 16*16 macroblock.  Since cache lines are 32 bytes
;   wide, the cache fill operations that fetch one target macroblock will serve to fetch the macroblock to the right,
;   so an average of 8 cache lines are fetched for each macroblock.
;
;   The previous frame, from which we need to access a reference area of 30*30 pels.  For each macroblock for which we
;   need to search for a motion vector, we will typically need to access no more than about 25 of these, but in general
;   these lines span the 30 lines of the search area.  Since cache lines are 32 bytes wide, the cache fill operations
;   that fetch reference data for one macroblock, will tend to fetch data that is useful as reference data for the
;   macroblock to the right, so an average of about 15 (rounded up to be safe) cache lines are fetched for each
;   macroblock.
;
;   The MBlockActionStream, which controls the searching (since we don't need to motion estimate blocks that are
;   legislated to be intra) will disrupt cache behaviour of the other data structures, but not to a significant degree.
;
; By setting the pitch to a constant of 384, and by allocating the frames as described above, the one available 4K page
; of data cache will be able to contain the 30 lines of the reference area, the 16 lines of the target area, and the
; 16 lines of the spatially filtered area (H261 only) without any collisions.
;
;
; Here is a flowchart of the major sections of this function:
;
; +-- Execute once for Y part of each macroblock that is NOT Intra By Decree --+
; |                                                                            |
; |   +---------------------------------------------------------------+        |
; |   |  1) Compute average value for target match points.            |        |
; |   |  2) Prepare match points in target MB for easier matching.    |        |
; |   |  3) Compute the SWD for (0,0) motion vector.                  |        |
; |   +---------------------------------------------------------------+        |
; |                 |                                                          |
; |                 v                                                          |
; |           /---------------------------------\  Yes                         |
; |          < 4) Is 0-motion SWD good enough?   >-------------------------+   |
; |           \---------------------------------/                          |   |
; |                                          |                             |   |
; |                                          |No                           |   |
; |                                          v                             |   |
; |     +--- 5) While state engine has more motion vectors to check ---+   |   |
; |     |                                                              |   |   |
; |     |                                                              |   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |   | 5) Compute SWDs for 2 ref MBs and pick best of 3. |----->|   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |                                                              |   |   |
; |     +--------------------------------------------------------------+   |   |
; |                             |                                          |   |
; |                             v                                          |   |
; |                /-----------------------------------------\             |   |
; |               <  6) Is best motion vector the 0-vector?   >            |   |
; |                \-----------------------------------------/             |   |
; |                   |              |                                     |   |
; |                   |No            |Yes                                  |   |
; |                   v              v                                     |   |
; |     +-----------------+ +-------------------------------------------+  |   |
; |     | Mark all blocks | |  6) Identify as empty block any in which: |<-+   |
; |  +--| non-empty.      | |     -->  0-motion SWD < EmptyThresh, and  |      |
; |  |  +-----------------+ +-------------------------------------------+      |
; |  |                          |                                              |
; |  |                          v                                              |
; |  |   /--------------------------------\ Yes +--------------------------+   |
; |  |  <  6) Are all blocks marked empty? >--->|  6) Classify FORCEDEMPTY |-->|
; |  |   \--------------------------------/     +--------------------------+   |
; |  |                |                                                        |
; |  |                |No                                                      |
; |  |                v                                                        |
; |  |        /--------------------------------------------\                   |
; |  |       <  7) Are any non-phantom blocks marked empty? >                  |
; |  |        \--------------------------------------------/                   |
; |  |                |            |                                           |
; |  |                |No          |Yes                                        |
; |  v                v            v                                           |
; | +---------------------+   +--------------------------------+               |
; | | 8) Compute IntraSWD |   | Set IntraSWD artificially high |               |
; | +---------------------+   +--------------------------------+               |
; |              |                 |                                           |
; |              v                 v                                           |
; |         +-------------------------------+                                  |
; |         | 10) Classify block as one of: |                                  |
; |         |       INTRA                   |--------------------------------->|
; |         |       INTER                   |                                  |
; |         +-------------------------------+                                  |
; |                                                                            |
; +----------------------------------------------------------------------------+
;
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list
.DATA

;  Storage for tables and temps used by Motion Estimation function.  Fit into
;  4Kbytes contiguous memory so that it uses one cache page, leaving other
;  for reference area of previous frame and target macroblock of current frame.

PickPoint     DB  0,4,?,4,0,?,2,2 ; Map CF accum to new central pt selector.
PickPoint_BLS DB  6,4,?,4,6,?,2,2 ; Same, for when doing block level search.

OffsetToRef LABEL DWORD    ; Linearized adjustments to affect horz/vert motion.
   DD  ?        ; This index used when zero-valued motion vector is good enough.
   DD  0        ; Best fit of 3 SWDs is previous center.
   DD  1        ; Best fit of 3 SWDs is the ref block 1 pel to the right.
   DD -1        ; Best fit of 3 SWDs is the ref block 1 pel to the left.
   DD  1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel above.
   DD -1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel below.
   DD  2        ; Best fit of 3 SWDs is the ref block 2 pels to the right.
   DD -2        ; Best fit of 3 SWDs is the ref block 2 pels to the left.
   DD  2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel above.
   DD -2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel below.
   DD  4        ; Best fit of 3 SWDs is the ref block 4 pels to the right.
   DD -4        ; Best fit of 3 SWDs is the ref block 4 pels to the left.
   DD  4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel above.
   DD -4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel below.
   DD  7        ; Best fit of 3 SWDs is the ref block 7 pels to the right.
   DD -7        ; Best fit of 3 SWDs is the ref block 7 pels to the left.
   DD  7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel above.
   DD -7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel below.

M0   =  4  ; Define symbolic indices into OffsetToRef lookup table.
MHP1 =  8
MHN1 = 12
MVP1 = 16
MVN1 = 20
MHP2 = 24
MHN2 = 28
MVP2 = 32
MVN2 = 36
MHP4 = 40
MHN4 = 44
MVP4 = 48
MVN4 = 52
MHP7 = 56
MHN7 = 60
MVP7 = 64
MVN7 = 68

                ; Map linearized motion vector to vertical part.
                ; (Mask bottom byte of linearized MV to zero, then use result
                ; as index into this array to get vertical MV.)
IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
   DB -32, -32
   DB -30
   DB -28, -28
   DB -26
   DB -24, -24
   DB -22
   DB -20, -20
   DB -18
   DB -16, -16
   DB -14
   DB -12, -12
   DB -10
   DB  -8,  -8
   DB  -6
   DB  -4,  -4
   DB  -2
   DB   0
UnlinearizedVertMV  DB 0
   DB   2
   DB   4,   4
   DB   6
   DB   8,   8
   DB  10
   DB  12,  12
   DB  14
   DB  16,  16
   DB  18
   DB  20,  20
   DB  22
   DB  24,  24
   DB  26
   DB  28,  28
   DB  30

; Map initial states to initializers for half pel search.  Where search would
; illegally take us off edge of picture, set initializer artificially high.

InitHalfPelSearchHorz LABEL DWORD
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H

InitHalfPelSearchVert LABEL DWORD
  DD 040000000H, 040000000H, 040000000H
  DD 000000000H, 000000000H, 000000000H
  DD 000004000H, 000004000H, 000004000H
  DD 040004000H, 040004000H, 040004000H


SWDState LABEL BYTE ; Rules that govern state engine of motion estimator.

   DB   8 DUP (?)       ; 0:  not used.

                        ; 1:  Upper Left Corner.  Explore 4 right and 4 down.
   DB  21, M0           ; (0,0)
   DB  22, MHP4         ; (0,4)
   DB  23, MVP4, ?, ?   ; (4,0)

                        ; 2:  Upper Edge.  Explore 4 left and 4 right.
   DB  22, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  22, MHP4, ?, ?   ; (0, 4)

                        ; 3:  Upper Right Corner.  Explore 4 right and 4 down.
   DB  31, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  32, MVP4, ?, ?   ; (4, 0)

                        ; 4:  Left Edge.  Explore 4 up and 4 down.
   DB  23, M0           ; ( 0,0)
   DB  23, MVN4         ; (-4,0)
   DB  23, MVP4, ?, ?   ; ( 4,0)

                        ; 5:  Interior Macroblock.  Explore 4 up and 4 down.
   DB  37, M0           ; ( 0,0)
   DB  37, MVN4         ; (-4,0)
   DB  37, MVP4, ?, ?   ; ( 4,0)

                        ; 6:  Right Edge.  Explore 4 up and 4 down.
   DB  32, M0           ; ( 0,0)
   DB  32, MVN4         ; (-4,0)
   DB  32, MVP4, ?, ?   ; ( 4,0)

                        ; 7:  Lower Left Corner.  Explore 4 up and 4 right.
   DB  38, M0           ; ( 0,0)
   DB  39, MHP4         ; ( 0,4)
   DB  23, MVN4, ?, ?   ; (-4,0)

                        ; 8:  Lower Edge.  Explore 4 left and 4 right.
   DB  39, M0           ; (0, 0)
   DB  39, MHN4         ; (0,-4)
   DB  39, MHP4, ?, ?   ; (0, 4)

                        ; 9:  Lower Right Corner.  Explore 4 up and 4 left.
   DB  44, M0           ; ( 0, 0)
   DB  39, MHN4         ; ( 0,-4)
   DB  32, MVN4, ?, ?   ; (-4, 0)

                        ; 10: Left Edge, No Vertical Motion Allowed.
   DB  46, M0           ; (0,0)
   DB  48, MHP2         ; (0,2)
   DB  47, MHP4, ?, ?   ; (0,4)

                        ; 11: Interior Macroblock, No Vertical Motion Allowed.
   DB  47, M0           ; (0, 0)
   DB  47, MHN4         ; (0,-4)
   DB  47, MHP4, ?, ?   ; (0, 4)

                        ; 12: Right Edge, No Vertical Motion Allowed.
   DB  49, M0           ; (0, 0)
   DB  48, MHN2         ; (0,-2)
   DB  47, MHN4, ?, ?   ; (0,-4)

                        ; 13: Horz by 2, Vert by 2, Horz by 1, Vert by 1.
   DB  14, M0 
   DB  14, MHP2 
   DB  14, MHN2, ?, ? 

                        ; 14: Vert by 2, Horz by 1, Vert by 1.
   DB  15, M0 
   DB  15, MVP2 
   DB  15, MVN2, ?, ? 

                        ; 15: Horz by 1, Vert by 1.
   DB  16, M0 
   DB  16, MHP1 
   DB  16, MHN1, ?, ? 

                        ; 16: Vert by 1.
   DB   0, M0
   DB   0, MVP1
   DB   0, MVN1, ?, ?

                        ; 17: Vert by 2, Horz by 2, Vert by 1, Horz by 1.
   DB  18, M0
   DB  18, MVP2
   DB  18, MVN2, ?, ?

                        ; 18: Horz by 2, Vert by 1, Horz by 1.
   DB  19, M0
   DB  19, MHP2
   DB  19, MHN2, ?, ?

                        ; 19: Vert by 1, Horz by 1.
   DB  20, M0
   DB  20, MVP1
   DB  20, MVN1, ?, ?

                        ; 20: Horz by 1.
   DB   0, M0
   DB   0, MHP1
   DB   0, MHN1, ?, ?

                        ; 21: From 1A.  Upper Left.  Try 2 right and 2 down.
   DB  24, M0           ; (0, 0)
   DB  25, MHP2         ; (0, 2)
   DB  26, MVP2, ?, ?   ; (2, 0)

                        ; 22: From  1B.
                        ;     From  2  center point would be (0,-4/0/4).
                        ;     From  3B center point would be (0,-4).
   DB  27, M0           ; (0, 4)
   DB  18, MVP2         ; (2, 4) Next: Horz 2, Vert 1, Horz 1.         (1:3,1:7)
   DB  13, MVP4, ?, ?   ; (4, 4) Next: Horz 2, Vert 2, Horz 1, Vert 1. (1:7,1:7)

                        ; 23: From  1C.
                        ;     From  4  center point would be (-4/0/4,0).
                        ;     From  7C center point would be (-4,0).
   DB  29, M0           ; (4, 0)
   DB  14, MHP2         ; (4, 2) Next: Vert 2, Horz 1, Vert 1.         (1:7,1:3)
   DB  17, MHP4, ?, ?   ; (4, 4) Next: Vert 2, Horz 2, Vert 1, Horz 1. (1:7,1:7)

                        ; 24: From 21A.  Upper Left.  Try 1 right and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHP1         ; (1, 0)
   DB   0, MVP1, ?, ?   ; (0, 1)

                        ; 25: From 21B.
                        ;     From 31B center point would be (0,-2).
   DB  20, M0           ; (0, 2) Next: Horz 1                            (0,1:3)
   DB  20, MVP1         ; (1, 2) Next: Horz 1                            (1,1:3)
   DB  15, MVP2, ?, ?   ; (2, 2) Next: Horz 1, Vert 1                  (1:3,1:3)

                        ; 26: From 21C.
                        ;     From 38C center point would be (-2,0).
   DB  16, M0           ; (2, 0) Next: Vert 1                            (1:3,0)
   DB  16, MHP1         ; (2, 1) Next: Vert 1                            (1:3,1)
   DB  19, MHP2, ?, ?   ; (2, 2) Next: Vert 1, Horz 1                  (1:3,1:3)

                        ; 27: From 22A.
   DB  28, M0           ; (0, 4)
   DB  28, MHN2         ; (0, 2)
   DB  28, MHP2, ?, ?   ; (0, 6)

                        ; 28: From 27.
   DB  20, M0           ; (0, 2/4/6) Next: Horz 1.                       (0,1:7)
   DB  20, MVP1         ; (1, 2/4/6) Next: Horz 1.                       (1,1:7)
   DB  20, MVP2, ?, ?   ; (2, 2/4/6) Next: Horz 1.                       (2,1:7)

                        ; 29: From 23A.
   DB  30, M0           ; (4, 0)
   DB  30, MVN2         ; (2, 0)
   DB  30, MVP2, ?, ?   ; (6, 0)

                        ; 30: From 29.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                       (1:7,0)
   DB  16, MHP1         ; (2/4/6, 1) Next: Vert 1.                       (1:7,1)
   DB  16, MHP2, ?, ?   ; (2/4/6, 2) Next: Vert 1.                       (1:7,2)

                        ; 31: From  3A.  Upper Right.  Try 2 left and 2 down.
   DB  33, M0           ; (0, 0)
   DB  25, MHN2         ; (0,-2)
   DB  34, MVP2, ?, ?   ; (2, 0)

                        ; 32: From  3C.
                        ;     From  6  center point would be (-4/0/4, 0)
                        ;     From  9C center point would be (-4, 0)
   DB  35, M0           ; (4, 0)
   DB  14, MHN2         ; (4,-2) Next: Vert2,Horz1,Vert1.            (1:7,-1:-3)
   DB  17, MHN4, ?, ?   ; (4,-4) Next: Vert2,Horz2,Vert1,Horz1.      (1:7,-1:-7)

                        ; 33: From 31A.  Upper Right.  Try 1 left and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MVP1, ?, ?   ; (1, 0)

                        ; 34: From 31C.
                        ;     From 44C center point would be (-2, 0)
   DB  16, M0           ; (2, 0) Next: Vert 1                           (1:3, 0)
   DB  16, MHN1         ; (2,-1) Next: Vert 1                           (1:3,-1)
   DB  19, MHN2, ?, ?   ; (2,-2) Next: Vert 1, Horz 1                (1:3,-1:-3)

                        ; 35: From 32A.
   DB  36, M0           ; (4, 0)
   DB  36, MVN2         ; (2, 0)
   DB  36, MVP2, ?, ?   ; (6, 0)

                        ; 36: From 35.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                      (1:7, 0)
   DB  16, MHN1         ; (2/4/6,-1) Next: Vert 1.                      (1:7,-1)
   DB  16, MHN2, ?, ?   ; (2/4/6,-2) Next: Vert 1.                      (1:7,-2)

                        ; 37: From  5.
   DB  17, M0           ; (-4/0/4, 0) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-3: 3)
   DB  17, MHP4         ; (-4/0/4,-4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7, 1: 7)
   DB  17, MHN4, ?, ?   ; (-4/0/4, 4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-7:-1)

                        ; 38: From 7A.  Lower Left.  Try 2 right and 2 up.
   DB  42, M0           ; ( 0,0)
   DB  43, MHP2         ; ( 0,2)
   DB  26, MVN2, ?, ?   ; (-2,0)

                        ; 39: From 13B.
                        ;     From 14  center point would be (0,-4/0/4)
                        ;     From 16B center point would be (0,-4)
   DB  40, M0           ; ( 0,4)
   DB  18, MVN2         ; (-2,4) Next: Horz2,Vert1,Horz1.            (-3:-1,1:7)
   DB  13, MVN4, ?, ?   ; (-4,4) Next: Horz2,Vert2,Horz1,Vert1.      (-7:-1,1:7)

                        ; 40: From 39A.
   DB  41, M0           ; (0, 4)
   DB  41, MHN2         ; (0, 2)
   DB  41, MHP2, ?, ?   ; (0, 6)

                        ; 41: From 40.
   DB  20, M0           ; ( 0,2/4/6) Next: Horz 1.                      ( 0,1:7)
   DB  20, MVN1         ; (-1,2/4/6) Next: Horz 1.                      (-1,1:7)
   DB  20, MVN2, ?, ?   ; (-2,2/4/6) Next: Horz 1.                      (-2,1:7)

                        ; 42: From 38A.  Lower Left.  Try 1 right and 1 up.
   DB   0, M0           ; ( 0,0)
   DB   0, MHP1         ; ( 0,1)
   DB   0, MVN1, ?, ?   ; (-1,0)

                        ; 43: From 38B.
                        ;     From 44B center point would be (0,-2)
   DB  20, M0           ; ( 0,2) Next: Horz 1                           ( 0,1:3)
   DB  20, MVN1         ; (-1,2) Next: Horz 1                           (-1,1:3)
   DB  15, MVN2, ?, ?   ; (-2,2) Next: Horz 1, Vert 1                (-1:-3,1:3)

                        ; 44: From 9A.  Lower Right.  Try 2 left and 2 up.
   DB  45, M0           ; ( 0, 0)
   DB  43, MHN2         ; ( 0,-2)
   DB  34, MVN2, ?, ?   ; (-2, 0)

                        ; 45: From 44A.  Lower Right.  Try 1 left and 1 up.
   DB   0, M0           ; ( 0, 0)
   DB   0, MHN1         ; ( 0,-1)
   DB   0, MVN1, ?, ?   ; (-1, 0)

                        ; 46: From 17A.
   DB   0, M0           ; (0,0)
   DB   0, MHP1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,1)

                        ; 47: From 10C.
                        ;     From 11 center point would be (0,4/0/-4)
                        ;     From 12C center point would be (0,-4)
   DB  48, M0           ; (0,4)
   DB  48, MHN2         ; (0,2)
   DB  48, MHP2, ?, ?   ; (0,6)

                        ; 48 From 10B.
                        ;    From 47  center point would be (0,2/4/6)
                        ;    From 12B center point would be (0,-2)
   DB   0, M0           ; (0,2)
   DB   0, MHN1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,3)

                        ; 49 From 12A.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MHN1, ?, ?   ; (0,-1)

                        ; 50:  Interior Macroblock.  Explore 7 up and 7 down.
   DB  51, M0           ; ( 0,0)
   DB  51, MVN7         ; (-7,0)
   DB  51, MVP7, ?, ?   ; ( 7,0)

                        ; 51:  Explore 7 left and 7 right.
   DB   5, M0           ; (-7|0|7, 0)
   DB   5, MHN7         ; (-7|0|7,-7)
   DB   5, MHP7, ?, ?   ; (-7|0|7, 7)

MulByNeg8 LABEL DWORD

CNT = 0
REPEAT 128
  DD WeightedDiff+CNT
  CNT = CNT - 8
ENDM


  ; The following treachery puts the numbers into byte 2 of each aligned DWORD.
  DB   0,  0
  DD 193 DUP (255)
  DD 250,243,237,231,225,219,213,207,201,195,189,184,178,172,167,162,156
  DD 151,146,141,135,130,126,121,116,111,107,102, 97, 93, 89, 84, 80, 76
  DD  72, 68, 64, 61, 57, 53, 50, 46, 43, 40, 37, 34, 31, 28, 25, 22, 20
  DD  18, 15, 13, 11,  9,  7,  6,  4,  3,  2,  1
  DB   0,  0
WeightedDiff LABEL DWORD
  DB   0,  0
  DD   0,  0,  1,  2,  3,  4,  6,  7,  9, 11, 13, 15, 18
  DD  20, 22, 25, 28, 31, 34, 37, 40, 43, 46, 50, 53, 57, 61, 64, 68, 72
  DD  76, 80, 84, 89, 93, 97,102,107,111,116,121,126,130,135,141,146,151
  DD 156,162,167,172,178,184,189,195,201,207,213,219,225,231,237,243,250
  DD 191 DUP (255)
  DB 255,  0


MotionOffsets DD 1*PITCH,0,?,?

RemnantOfCacheLine DB 8 DUP (?)


LocalStorage LABEL DWORD  ; Local storage goes on the stack at addresses
                          ; whose lower 12 bits match this address.

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

MOTIONESTIMATION proc C AMBAS: DWORD,
ATargFrmBase: DWORD,
APrevFrmBase: DWORD,
AFiltFrmBase: DWORD,
ADo15Search: DWORD,
ADoHalfPelEst: DWORD,
ADoBlkLvlVec: DWORD,
ADoSpatialFilt: DWORD,
AZeroVectorThresh: DWORD,
ANonZeroMVDiff: DWORD,
ABlockMVDiff: DWORD,
AEmptyThresh: DWORD,
AInterCodThresh: DWORD,
AIntraCodDiff: DWORD,
ASpatialFiltThresh: DWORD,
ASpatialFiltDiff: DWORD,
AIntraSWDTot: DWORD,
AIntraSWDBlks: DWORD,
AInterSWDTot: DWORD,
AInterSWDBlks: DWORD

LocalFrameSize = 128 + 168*4 + 32   ; 128 for locals;  168*4 for blocks;  32 for dummy block.
RegStoSize = 16

; Arguments:

MBlockActionStream_arg       = RegStoSize +  4
TargetFrameBaseAddress_arg   = RegStoSize +  8
PreviousFrameBaseAddress_arg = RegStoSize + 12
FilteredFrameBaseAddress_arg = RegStoSize + 16
DoRadius15Search_arg         = RegStoSize + 20
DoHalfPelEstimation_arg      = RegStoSize + 24
DoBlockLevelVectors_arg      = RegStoSize + 28
DoSpatialFiltering_arg       = RegStoSize + 32
ZeroVectorThreshold_arg      = RegStoSize + 36
NonZeroMVDifferential_arg    = RegStoSize + 40
BlockMVDifferential_arg      = RegStoSize + 44
EmptyThreshold_arg           = RegStoSize + 48
InterCodingThreshold_arg     = RegStoSize + 52
IntraCodingDifferential_arg  = RegStoSize + 56
SpatialFiltThreshold_arg     = RegStoSize + 60
SpatialFiltDifferential_arg  = RegStoSize + 64
IntraSWDTotal_arg            = RegStoSize + 68
IntraSWDBlocks_arg           = RegStoSize + 72
InterSWDTotal_arg            = RegStoSize + 76
InterSWDBlocks_arg           = RegStoSize + 80
EndOfArgList                 = RegStoSize + 84

; Locals (on local stack frame)

MBlockActionStream       EQU [esp+   0]
CurrSWDState             EQU [esp+   4]
MotionOffsetsCursor      EQU CurrSWDState
HalfPelHorzSavings       EQU CurrSWDState
VertFilterDoneAddr       EQU CurrSWDState
IntraSWDTotal            EQU [esp+   8]
IntraSWDBlocks           EQU [esp+  12]
InterSWDTotal            EQU [esp+  16]
InterSWDBlocks           EQU [esp+  20]

MBCentralInterSWD        EQU [esp+  24]
MBRef1InterSWD           EQU [esp+  28]
MBRef2InterSWD           EQU [esp+  32]
MBCentralInterSWD_BLS    EQU [esp+  36]
MB0MVInterSWD            EQU [esp+  40]
MBAddrCentralPoint       EQU [esp+  44]
MBMotionVectors          EQU [esp+  48]

DoHalfPelEstimation      EQU [esp+  52]
DoBlockLevelVectors      EQU [esp+  56]
DoSpatialFiltering       EQU [esp+  60]
ZeroVectorThreshold      EQU [esp+  64]
NonZeroMVDifferential    EQU [esp+  68]
BlockMVDifferential      EQU [esp+  72]
EmptyThreshold           EQU [esp+  76]
InterCodingThreshold     EQU [esp+  80]
IntraCodingDifferential  EQU [esp+  84]
SpatialFiltThreshold     EQU [esp+  88]
SpatialFiltDifferential  EQU [esp+  92]
TargetMBAddr             EQU [esp+  96]
TargetFrameBaseAddress   EQU [esp+ 100]
PreviousFrameBaseAddress EQU [esp+ 104]
TargToRef                EQU [esp+ 108]
TargToSLF                EQU [esp+ 112]
DoRadius15Search         EQU [esp+ 116]

StashESP                 EQU [esp+ 120]

BlockLen                 EQU 168
Block1                   EQU [esp+  128+40]      ; "128" is for locals.  "40" is so offsets range from -40 to 124.
Block2                   EQU Block1  + BlockLen
Block3                   EQU Block2  + BlockLen
Block4                   EQU Block3  + BlockLen
BlockN                   EQU Block4  + BlockLen
BlockNM1                 EQU Block4
BlockNM2                 EQU Block3
BlockNP1                 EQU Block4  + BlockLen + BlockLen
DummyBlock               EQU Block4  + BlockLen


Ref1Addr                 EQU  -40
Ref2Addr                 EQU  -36
AddrCentralPoint         EQU  -32
CentralInterSWD          EQU  -28
Ref1InterSWD             EQU  -24
Ref2InterSWD             EQU  -20
CentralInterSWD_BLS      EQU  -16  ; CentralInterSWD, when doing blk level search.
CentralInterSWD_SLF      EQU  -16  ; CentralInterSWD, when doing spatial filter.
HalfPelSavings           EQU  Ref2Addr
ZeroMVInterSWD           EQU  -12
BlkHMV                   EQU   -8
BlkVMV                   EQU   -7
BlkMVs                   EQU   -8
AccumTargetPels          EQU   -4

; Offsets for Negated Quadrupled Target Pels:
N8T00                    EQU    0
N8T04                    EQU    4
N8T02                    EQU    8
N8T06                    EQU   12
N8T20                    EQU   16
N8T24                    EQU   20
N8T22                    EQU   24
N8T26                    EQU   28
N8T40                    EQU   32
N8T44                    EQU   36
N8T42                    EQU   40
N8T46                    EQU   44
N8T60                    EQU   48
N8T64                    EQU   52
N8T62                    EQU   56
N8T66                    EQU   60
N8T11                    EQU   64
N8T15                    EQU   68
N8T13                    EQU   72
N8T17                    EQU   76
N8T31                    EQU   80
N8T35                    EQU   84
N8T33                    EQU   88
N8T37                    EQU   92
N8T51                    EQU   96
N8T55                    EQU  100
N8T53                    EQU  104
N8T57                    EQU  108
N8T71                    EQU  112
N8T75                    EQU  116
N8T73                    EQU  120
N8T77                    EQU  124

  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov   esi,esp
   sub  esp,000001000H
  mov   eax,[esp]                   ; Cause system to commit page.
   sub  esp,000001000H
  and   esp,0FFFFF000H
   mov  ebx,OFFSET LocalStorage+31
  and   ebx,000000FE0H
   mov  edx,PD [esi+MBlockActionStream_arg]
  or    esp,ebx
   mov  eax,PD [esi+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,eax
   mov  ebx,PD [esi+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,ebx
   sub  ebx,eax
  mov   ecx,PD [esi+FilteredFrameBaseAddress_arg]
  sub   ecx,eax
   mov  TargToRef,ebx
  mov   TargToSLF,ecx
   mov  eax,PD [esi+EmptyThreshold_arg]
  mov   EmptyThreshold,eax
   mov  eax,PD [esi+DoHalfPelEstimation_arg]
  mov   DoHalfPelEstimation,eax
   mov  eax,PD [esi+DoBlockLevelVectors_arg]
  mov   DoBlockLevelVectors,eax
   mov  eax,PD [esi+DoRadius15Search_arg]
  mov   DoRadius15Search,eax
   mov  eax,PD [esi+DoSpatialFiltering_arg]
  mov   DoSpatialFiltering,eax
   mov  eax,PD [esi+ZeroVectorThreshold_arg]
  mov   ZeroVectorThreshold,eax
   mov  eax,PD [esi+NonZeroMVDifferential_arg]
  mov   NonZeroMVDifferential,eax
   mov  eax,PD [esi+BlockMVDifferential_arg]
  mov   BlockMVDifferential,eax
   mov  eax,PD [esi+InterCodingThreshold_arg]
  mov   InterCodingThreshold,eax
   mov  eax,PD [esi+IntraCodingDifferential_arg]
  mov   IntraCodingDifferential,eax
   mov  eax,PD [esi+SpatialFiltThreshold_arg]
  mov   SpatialFiltThreshold,eax
   mov  eax,PD [esi+SpatialFiltDifferential_arg]
  mov   SpatialFiltDifferential,eax
   xor  ebx,ebx
  mov   IntraSWDBlocks,ebx
   mov  InterSWDBlocks,ebx
  mov   IntraSWDTotal,ebx
   mov  InterSWDTotal,ebx
  mov   Block1.BlkMVs,ebx
   mov  Block2.BlkMVs,ebx
  mov   Block3.BlkMVs,ebx
   mov  Block4.BlkMVs,ebx
  mov   DummyBlock.Ref1Addr,esp
   mov  DummyBlock.Ref2Addr,esp
  mov   StashESP,esi
   jmp  FirstMacroBlock

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     1)  To calculate an average value for the target match points of each
;         block, we sum the 32 match points.  The totals for each of the 4
;         blocks is output seperately.
;
;     2)  Define each prepared match point in the target macroblock as the
;         real match point times negative 8, with the base address of the
;         WeightedDiff lookup table added.  I.e.
;
;           for (i = 0; i < 16; i += 2)
;             for (j = 0; j < 16; j += 2)
;               N8T[i][j] = ( -8 * Target[i][j]) + ((U32) WeightedDiff);
;
;         Both the multiply and the add of the WeightedDiff array base are
;         effected by a table lookup into the array MulByNeg8.
;
;         Then the SWD of a reference macroblock can be calculated as follows:
;
;           SWD = 0;
;           for each match point (i,j)
;               SWD += *((U32 *) (N8T[i][j] + 8 * Ref[i][j]));
;
;         In assembly, the fetch of WeightedDiff array element amounts to this:
;
;           mov edi,DWORD PTR N8T[i][j]   ; Fetch N8T[i][j]
;           mov dl,BYTE PTR Ref[i][j]     ; Fetch Ref[i][j]
;           mov edi,DWORD PTR[edi+edx*8]  ; Fetch WeithtedDiff of target & ref.
;
;     3)  We calculate the 0-motion SWD, as described just above.  We use 32
;         match points per block, and write the result seperately for each
;         block.  The result is accumulated into the high half of ebp.
;
;     4)  If the SWD for the 0-motion vector is below a threshold, we don't
;         bother searching for other possibly better motion vectors.  Presently,
;         this threshold is set such that an average difference of less than
;         three per match point causes the 0-motion vector to be accepted.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edx -- MBlockActionStream
;
;   Predominate usage for body of this section:
;
;     esi -- Target block address.
;     edi -- 0-motion reference block address.
;     ebp[ 0:12] -- Accumulator for target pels.
;     ebp[13:15] -- Loop control
;     ebp[16:31] -- Accumulator for weighted diff between target and 0-MV ref. 
;     edx -- Address at which to store -8 times pels.
;     ecx -- A reference pel.
;     ebx -- A target pel.
;     eax -- A target pel times -8;  and a weighted difference.
;
; Expected Pentium (tm) microprocessor performance for section:
;
;   Executed once per macroblock.
;
;   520 clocks for instruction execution
;     8 clocks for bank conflicts (64 dual mem ops with 1/8 chance of conflict)
;    80 clocks generously estimated for an average of 8 cache line fills for
;       the target macroblock and 8 cache line fills for the reference area.
;  ----
;   608 clocks total time for this section.
;

NextMacroBlock:

  mov   bl,[edx].CodedBlocks
   add  edx,SIZEOF T_MacroBlockActionDescr
  and   ebx,000000040H                ; Check for end-of-stream
   jne  Done

FirstMacroBlock:

  mov   cl,[edx].CodedBlocks          ; Init CBP for macroblock.
   mov  ebp,TargetFrameBaseAddress
  mov   bl,[edx].FirstMEState         ; First State
   mov  eax,DoRadius15Search          ; Searching 15 full pels out, or just 7?
  neg   al                            ; doing blk lvl => al=0, not => al=-1
  or    cl,03FH                       ; Indicate all 6 blocks are coded.
   and  al,bl
  mov   esi,[edx].BlkY1.BlkOffset     ; Get address of next macroblock to do.
   cmp  al,5
  jne   @f
  mov   bl,50                         ; Cause us to search +/- 15 if central
  ;                                   ; block and willing to go that far.
@@:
   mov  edi,TargToRef
  add   esi,ebp
   mov  CurrSWDState,ebx              ; Stash First State Number as current.
  add   edi,esi
   xor  ebp,ebp
  mov   TargetMBAddr,esi              ; Stash address of target macroblock.
   mov  MBlockActionStream,edx        ; Stash list ptr.
  mov   [edx].CodedBlocks,cl
   mov  ecx,INTER1MV                  ; Speculate INTER-coding, 1 motion vector.
  mov   [edx].BlockType,cl
   lea  edx,Block1

PrepMatchPointsNextBlock:

  mov   bl,PB [esi+6]                 ; 06A -- Target Pel 00.
  add   ebp,ebx                       ; 06B -- Accumulate target pels.
   mov  cl,PB [edi+6]                 ; 06C -- Reference Pel 00.
  mov   eax,MulByNeg8[ebx*4]          ; 06D -- Target Pel 00 * -8.
   mov  bl,PB [esi+4]                 ; 04A
  mov   [edx].N8T06,eax               ; 06E -- Store negated quadrupled Pel 00.
   add  ebp,ebx                       ; 04B
  mov   eax,PD [eax+ecx*8]            ; 06F -- Weighted difference for Pel 00.
   mov  cl,PB [edi+4]                 ; 04C
  add   ebp,eax                       ; 06G -- Accumulate weighted difference.
   mov  eax,MulByNeg8[ebx*4]          ; 04D
  mov   bl,PB [esi+2]                 ; 02A
   mov  [edx].N8T04,eax               ; 04E
  add   ebp,ebx                       ; 02B
   mov  eax,PD [eax+ecx*8]            ; 04F
  mov   cl,PB [edi+2]                 ; 02C
   add  ebp,eax                       ; 04G
  mov   eax,MulByNeg8[ebx*4]          ; 02D
   mov  bl,PB [esi]                   ; 00A
  mov   [edx].N8T02,eax               ; 02E
   add  ebp,ebx                       ; 00B
  mov   eax,PD [eax+ecx*8]            ; 02F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 00C
   add  edi,PITCH+1
  lea   ebp,[ebp+eax+000004000H]      ; 02G  (plus loop control)
   mov  eax,MulByNeg8[ebx*4]          ; 00D
  mov   bl,PB [esi+6]                 ; 17A
   mov  [edx].N8T00,eax               ; 00E
  add   ebp,ebx                       ; 17B
   mov  eax,PD [eax+ecx*8]            ; 00F
  mov   cl,PB [edi+6]                 ; 17C
   add  ebp,eax                       ; 00G
  mov   eax,MulByNeg8[ebx*4]          ; 17D
   mov  bl,PB [esi+4]                 ; 15A
  mov   [edx].N8T17,eax               ; 17E
   add  ebp,ebx                       ; 15B
  mov   eax,PD [eax+ecx*8]            ; 17F
   mov  cl,PB [edi+4]                 ; 15C
  add   ebp,eax                       ; 17G
   mov  eax,MulByNeg8[ebx*4]          ; 15D
  mov   bl,PB [esi+2]                 ; 13A
   mov  [edx].N8T15,eax               ; 15E
  add   ebp,ebx                       ; 13B
   mov  eax,PD [eax+ecx*8]            ; 15F
  mov   cl,PB [edi+2]                 ; 13C
   add  ebp,eax                       ; 15G
  mov   eax,MulByNeg8[ebx*4]          ; 13D
   mov  bl,PB [esi]                   ; 11A
  mov   [edx].N8T13,eax               ; 13E
   add  ebp,ebx                       ; 11B
  mov   eax,PD [eax+ecx*8]            ; 13F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 11C
   add  edi,PITCH-1
  add   ebp,eax                       ; 13G
   mov  eax,MulByNeg8[ebx*4]          ; 11D
  mov   bl,PB [esi+6]                 ; 26A
   mov  [edx].N8T11,eax               ; 11E
  add   ebp,ebx                       ; 26B
   mov  eax,PD [eax+ecx*8]            ; 11F
  mov   cl,PB [edi+6]                 ; 26C
   add  ebp,eax                       ; 11G
  mov   eax,MulByNeg8[ebx*4]          ; 26D
   mov  bl,PB [esi+4]                 ; 24A
  mov   [edx].N8T26,eax               ; 26E
   add  ebp,ebx                       ; 24B
  mov   eax,PD [eax+ecx*8]            ; 26F
   mov  cl,PB [edi+4]                 ; 24C
  add   ebp,eax                       ; 26G
   mov  eax,MulByNeg8[ebx*4]          ; 24D
  mov   bl,PB [esi+2]                 ; 22A
   mov  [edx].N8T24,eax               ; 24E
  add   ebp,ebx                       ; 22B
   mov  eax,PD [eax+ecx*8]            ; 24F
  mov   cl,PB [edi+2]                 ; 22C
   add  ebp,eax                       ; 24G
  mov   eax,MulByNeg8[ebx*4]          ; 22D
   mov  bl,PB [esi]                   ; 20A
  mov   [edx].N8T22,eax               ; 22E
   add  ebp,ebx                       ; 20B
  mov   eax,PD [eax+ecx*8]            ; 22F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 20C
   add  edi,PITCH+1
  add   ebp,eax                       ; 22G
   mov  eax,MulByNeg8[ebx*4]          ; 20D
  mov   bl,PB [esi+6]                 ; 37A
   mov  [edx].N8T20,eax               ; 20E
  add   ebp,ebx                       ; 37B
   mov  eax,PD [eax+ecx*8]            ; 20F
  mov   cl,PB [edi+6]                 ; 37C
   add  ebp,eax                       ; 20G
  mov   eax,MulByNeg8[ebx*4]          ; 37D
   mov  bl,PB [esi+4]                 ; 35A
  mov   [edx].N8T37,eax               ; 37E
   add  ebp,ebx                       ; 35B
  mov   eax,PD [eax+ecx*8]            ; 37F
   mov  cl,PB [edi+4]                 ; 35C
  add   ebp,eax                       ; 37G
   mov  eax,MulByNeg8[ebx*4]          ; 35D
  mov   bl,PB [esi+2]                 ; 33A
   mov  [edx].N8T35,eax               ; 35E
  add   ebp,ebx                       ; 33B
   mov  eax,PD [eax+ecx*8]            ; 35F
  mov   cl,PB [edi+2]                 ; 33C
   add  ebp,eax                       ; 35G
  mov   eax,MulByNeg8[ebx*4]          ; 33D
   mov  bl,PB [esi]                   ; 31A
  mov   [edx].N8T33,eax               ; 33E
   add  ebp,ebx                       ; 31B
  mov   eax,PD [eax+ecx*8]            ; 33F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 31C
   add  edi,PITCH-1
  add   ebp,eax                       ; 33G
   mov  eax,MulByNeg8[ebx*4]          ; 31D
  mov   bl,PB [esi+6]                 ; 46A
   mov  [edx].N8T31,eax               ; 31E
  add   ebp,ebx                       ; 46B
   mov  eax,PD [eax+ecx*8]            ; 31F
  mov   cl,PB [edi+6]                 ; 46C
   add  ebp,eax                       ; 31G
  mov   eax,MulByNeg8[ebx*4]          ; 46D
   mov  bl,PB [esi+4]                 ; 44A
  mov   [edx].N8T46,eax               ; 46E
   add  ebp,ebx                       ; 44B
  mov   eax,PD [eax+ecx*8]            ; 46F
   mov  cl,PB [edi+4]                 ; 44C
  add   ebp,eax                       ; 46G
   mov  eax,MulByNeg8[ebx*4]          ; 44D
  mov   bl,PB [esi+2]                 ; 42A
   mov  [edx].N8T44,eax               ; 44E
  add   ebp,ebx                       ; 42B
   mov  eax,PD [eax+ecx*8]            ; 44F
  mov   cl,PB [edi+2]                 ; 42C
   add  ebp,eax                       ; 44G
  mov   eax,MulByNeg8[ebx*4]          ; 42D
   mov  bl,PB [esi]                   ; 40A
  mov   [edx].N8T42,eax               ; 42E
   add  ebp,ebx                       ; 40B
  mov   eax,PD [eax+ecx*8]            ; 42F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 40C
   add  edi,PITCH+1
  add   ebp,eax                       ; 42G
   mov  eax,MulByNeg8[ebx*4]          ; 40D
  mov   bl,PB [esi+6]                 ; 57A
   mov  [edx].N8T40,eax               ; 40E
  add   ebp,ebx                       ; 57B
   mov  eax,PD [eax+ecx*8]            ; 40F
  mov   cl,PB [edi+6]                 ; 57C
   add  ebp,eax                       ; 40G
  mov   eax,MulByNeg8[ebx*4]          ; 57D
   mov  bl,PB [esi+4]                 ; 55A
  mov   [edx].N8T57,eax               ; 57E
   add  ebp,ebx                       ; 55B
  mov   eax,PD [eax+ecx*8]            ; 57F
   mov  cl,PB [edi+4]                 ; 55C
  add   ebp,eax                       ; 57G
   mov  eax,MulByNeg8[ebx*4]          ; 55D
  mov   bl,PB [esi+2]                 ; 53A
   mov  [edx].N8T55,eax               ; 55E
  add   ebp,ebx                       ; 53B
   mov  eax,PD [eax+ecx*8]            ; 55F
  mov   cl,PB [edi+2]                 ; 53C
   add  ebp,eax                       ; 55G
  mov   eax,MulByNeg8[ebx*4]          ; 53D
   mov  bl,PB [esi]                   ; 51A
  mov   [edx].N8T53,eax               ; 53E
   add  ebp,ebx                       ; 51B
  mov   eax,PD [eax+ecx*8]            ; 53F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 51C
   add  edi,PITCH-1
  add   ebp,eax                       ; 53G
   mov  eax,MulByNeg8[ebx*4]          ; 51D
  mov   bl,PB [esi+6]                 ; 66A
   mov  [edx].N8T51,eax               ; 51E
  add   ebp,ebx                       ; 66B
   mov  eax,PD [eax+ecx*8]            ; 51F
  mov   cl,PB [edi+6]                 ; 66C
   add  ebp,eax                       ; 51G
  mov   eax,MulByNeg8[ebx*4]          ; 66D
   mov  bl,PB [esi+4]                 ; 64A
  mov   [edx].N8T66,eax               ; 66E
   add  ebp,ebx                       ; 64B
  mov   eax,PD [eax+ecx*8]            ; 66F
   mov  cl,PB [edi+4]                 ; 64C
  add   ebp,eax                       ; 66G
   mov  eax,MulByNeg8[ebx*4]          ; 64D
  mov   bl,PB [esi+2]                 ; 62A
   mov  [edx].N8T64,eax               ; 64E
  add   ebp,ebx                       ; 62B
   mov  eax,PD [eax+ecx*8]            ; 64F
  mov   cl,PB [edi+2]                 ; 62C
   add  ebp,eax                       ; 64G
  mov   eax,MulByNeg8[ebx*4]          ; 62D
   mov  bl,PB [esi]                   ; 60A
  mov   [edx].N8T62,eax               ; 62E
   add  ebp,ebx                       ; 60B
  mov   eax,PD [eax+ecx*8]            ; 62F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 60C
   add  edi,PITCH+1
  add   ebp,eax                       ; 62G
   mov  eax,MulByNeg8[ebx*4]          ; 60D
  mov   bl,PB [esi+6]                 ; 77A
   mov  [edx].N8T60,eax               ; 60E
  add   ebp,ebx                       ; 77B
   mov  eax,PD [eax+ecx*8]            ; 60F
  mov   cl,PB [edi+6]                 ; 77C
   add  ebp,eax                       ; 60G
  mov   eax,MulByNeg8[ebx*4]          ; 77D
   mov  bl,PB [esi+4]                 ; 75A
  mov   [edx].N8T77,eax               ; 77E
   add  ebp,ebx                       ; 75B
  mov   eax,PD [eax+ecx*8]            ; 77F
   mov  cl,PB [edi+4]                 ; 75C
  add   ebp,eax                       ; 77G
   mov  eax,MulByNeg8[ebx*4]          ; 75D
  mov   bl,PB [esi+2]                 ; 73A
   mov  [edx].N8T75,eax               ; 75E
  add   ebp,ebx                       ; 73B
   mov  eax,PD [eax+ecx*8]            ; 75F
  mov   cl,PB [edi+2]                 ; 73C
   add  ebp,eax                       ; 75G
  mov   eax,MulByNeg8[ebx*4]          ; 73D
   mov  bl,PB [esi]                   ; 71A
  mov   [edx].N8T73,eax               ; 73E
   add  ebp,ebx                       ; 71B
  mov   eax,PD [eax+ecx*8]            ; 73F
   mov  cl,PB [edi]                   ; 71C
  add   esi,PITCH-1-PITCH*8+8
   add  edi,PITCH-1-PITCH*8+8
  add   ebp,eax                       ; 73G
   mov  eax,MulByNeg8[ebx*4]          ; 71D
  mov   ebx,ebp
   mov  [edx].N8T71,eax               ; 71E
  and   ebx,000001FFFH                ; Extract sum of target pels.
   add  edx,BlockLen                  ; Move to next output block
  mov   eax,PD [eax+ecx*8]            ; 71F
   mov  [edx-BlockLen].AccumTargetPels,ebx ; Store acc of target pels for block.
  add   eax,ebp                       ; 71G
   and  ebp,000006000H                ; Extract loop control
  shr   eax,16                        ; Extract SWD;  CF == 1 every second iter.
   mov  ebx,ecx
  mov   [edx-BlockLen].CentralInterSWD,eax ; Store SWD for 0-motion vector.
   jnc  PrepMatchPointsNextBlock

  add   esi,PITCH*8-16                ; Advance to block 3, or off end.
   add  edi,PITCH*8-16                ; Advance to block 3, or off end.
  xor   ebp,000002000H
   jne  PrepMatchPointsNextBlock      ; Jump if advancing to block 3.

  mov   ebx,CurrSWDState              ; Fetch First State Number for engine.
   mov  edi,Block1.CentralInterSWD
  test  bl,bl                         ; Test for INTRA-BY-DECREE.
   je   IntraByDecree

  add   eax,Block2.CentralInterSWD
   add  edi,Block3.CentralInterSWD
  add   eax,edi
   mov  edx,ZeroVectorThreshold
  cmp   eax,edx                       ; Compare 0-MV against ZeroVectorThresh
   jle  BelowZeroThresh               ; Jump if 0-MV is good enough.

  mov   cl,PB SWDState[ebx*8+3]       ; cl == Index of inc to apply to central
  ;                                   ; point to get to ref1.
   mov  bl,PB SWDState[ebx*8+5]       ; bl == Same as cl, but for ref2.
  mov   edx,TargToRef
   mov  MB0MVInterSWD,eax             ; Stash SWD for zero motion vector.
  mov   edi,PD OffsetToRef[ebx]       ; Get inc to apply to ctr to get to ref2.
   mov  ebp,PD OffsetToRef[ecx]       ; Get inc to apply to ctr to get to ref1.
  lea   esi,[esi+edx-PITCH*16]        ; Calculate address of 0-MV ref block.
   ;
  mov   MBAddrCentralPoint,esi        ; Set central point to 0-MV.
   mov  MBCentralInterSWD,eax
  mov   eax,Block1.CentralInterSWD    ; Stash Zero MV SWD, in case we decide
   mov  edx,Block2.CentralInterSWD    ; the best non-zero MV isn't enough
  mov   Block1.ZeroMVInterSWD,eax     ; better than the zero MV.
   mov  Block2.ZeroMVInterSWD,edx
  mov   eax,Block3.CentralInterSWD
   mov  edx,Block4.CentralInterSWD
  mov   Block3.ZeroMVInterSWD,eax
   mov  Block4.ZeroMVInterSWD,edx

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     5)  The SWD for two different reference macroblocks is calculated; ref1
;         into the high order 16 bits of ebp, and ref2 into the low 16 bits.
;         This is performed for each iteration of the state engine.  A normal,
;         internal macroblock will perform 6 iterations, searching +/- 4
;         horizontally, then +/- 4 vertically, then +/- 2 horizontally, then
;         +/- 2 vertically, then +/- 1 horizontally, then +/- 1 vertically.
;
; Register usage for this section:
;
;   Input:
;
;     esi -- Addr of 0-motion macroblock in ref frame.
;     ebp -- Increment to apply to get to first ref1 macroblock.
;     edi -- Increment to apply to get to first ref2 macroblock.
;     ebx, ecx -- High order 24 bits are zero.
;     
;   Output:
;
;     ebp -- SWD for the best-fit reference macroblock.
;     ebx -- Index of increment to apply to get to best-fit reference MB.
;     MBAddrCentralPoint -- the best-fit of the previous iteration;  it is the
;                         value to which OffsetToRef[ebx] must be added.
;
;
; Expected performance for SWDLoop code:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

MBFullPelMotionSearchLoop:

  lea   edi,[esi+edi+PITCH*8+8]
   lea  esi,[esi+ebp+PITCH*8+8]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   esi,MBCentralInterSWD     ; Get SWD for central point of these 3 refs
   xor  eax,eax
  add   ebp,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ebp,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ebp,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD

  cmp   ebp,edx                   ; Carry flag == 1 iff ref1 SWD < ref2 SWD.
   mov  edi,CurrSWDState          ; Restore current state number.
  adc   eax,eax                   ; eax == 1 iff ref1 SWD < ref2 SWD.
   cmp  ebp,esi                   ; Carry flag == 1 iff ref1 SWD < central SWD.
  adc   eax,eax                   ;
   cmp  edx,esi                   ; Carry flag == 1 iff ref2 SWD < central SWD.
  adc   eax,eax                   ; 0 --> Pick central point.
  ;                               ; 1 --> Pick ref2.
  ;                               ; 2 --> Not possible.
  ;                               ; 3 --> Pick ref2.
  ;                               ; 4 --> Pick central point.
  ;                               ; 5 --> Not possible.
  ;                               ; 6 --> Pick ref1.
  ;                               ; 7 --> Pick ref1.
   mov  MBRef2InterSWD,edx
  mov   MBRef1InterSWD,ebp
   xor  edx,edx
  mov   dl,PB PickPoint[eax]        ; dl == 0: central pt;  2: ref1;  4: ref2
   mov  esi,MBAddrCentralPoint      ; Reload address of central ref block.
  ;
   ;
  mov   ebp,Block1.CentralInterSWD[edx*2] ; Get SWD for each block, picked pt.
   mov  al,PB SWDState[edx+edi*8+1] ; al == Index of inc to apply to old central
   ;                                ;       point to get new central point.
  mov   Block1.CentralInterSWD,ebp  ; Stash SWD for new central point.
   mov  ebp,Block2.CentralInterSWD[edx*2]
  mov   Block2.CentralInterSWD,ebp
   mov  ebp,Block3.CentralInterSWD[edx*2]
  mov   Block3.CentralInterSWD,ebp
   mov  ebp,Block4.CentralInterSWD[edx*2]
  mov   Block4.CentralInterSWD,ebp
   mov  ebp,MBCentralInterSWD[edx*2]; Get the SWD for the point we picked.
  mov   dl,PB SWDState[edx+edi*8]   ; dl == New state number.
   mov  MBCentralInterSWD,ebp       ; Stash SWD for new central point.
  mov   edi,PD OffsetToRef[eax]     ; Get inc to apply to get to new central pt.
   mov  CurrSWDState,edx            ; Stash current state number.
  mov   bl,PB SWDState[edx*8+3]     ; bl == Index of inc to apply to central
  ;                                 ;       point to get to next ref1.
   mov  cl,PB SWDState[edx*8+5]     ; cl == Same as bl, but for ref2.
  add   esi,edi                     ; Move to new central point.
   test dl,dl
  mov   ebp,PD OffsetToRef[ebx]     ; Get inc to apply to ctr to get to ref1.
   mov  edi,PD OffsetToRef[ecx]     ; Get inc to apply to ctr to get to ref2.
  mov   MBAddrCentralPoint,esi      ; Stash address of new central ref block.
   jne  MBFullPelMotionSearchLoop   ; Jump if not done searching.

;Done searching for integer motion vector for full macroblock

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF
  mov   ecx,TargToRef            ; To Linearize MV for winning ref blk.
   mov  eax,esi                  ; Copy of ref macroblock addr.
  sub   eax,ecx                  ; To Linearize MV for winning ref blk.
   mov  ecx,TargetMBAddr
  sub   eax,ecx
   mov  edx,MBlockActionStream   ; Fetch list ptr.
  mov   ebx,eax
   mov  ebp,DoHalfPelEstimation  ; Are we doing half pel motion estimation?
  shl   eax,25                   ; Extract horz motion component.
   mov  [edx].BlkY1.PastRef,esi  ; Save address of reference MB selected.
  sar   ebx,8                    ; Hi 24 bits of linearized MV lookup vert MV.
   mov  ecx,MBCentralInterSWD
  sar   eax,24                   ; Finish extract horz motion component.
   test ebp,ebp
  mov   bl,PB UnlinearizedVertMV[ebx] ; Look up proper vert motion vector.
   mov  [edx].BlkY1.PHMV,al      ; Save winning horz motion vector.
  mov   [edx].BlkY1.PVMV,bl      ; Save winning vert motion vector.

IFDEF H261
ELSE
   je   SkipHalfPelSearch_1MV

;Search for half pel motion vector for full macroblock.

  mov   Block1.AddrCentralPoint,esi
   lea  ebp,[esi+8]
  mov   Block2.AddrCentralPoint,ebp
   add  ebp,PITCH*8-8
  mov   Block3.AddrCentralPoint,ebp
   xor  ecx,ecx
  mov   cl,[edx].FirstMEState
   add  ebp,8
  mov   edi,esi
   mov  Block4.AddrCentralPoint,ebp
  mov   ebp,InitHalfPelSearchHorz[ecx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  mov   esi,MBlockActionStream
   xor  eax,eax                   ; Keep pairing happy
  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  mov   bl,[esi].FirstMEState
   mov  edi,Block1.AddrCentralPoint
  cmp   ecx,edx
   jl   MBHorz_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the right is best.
   mov  ecx,Block1.Ref2InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref2InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref2InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref2InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   inc  al
  mov   [esi].BlkY1.PHMV,al
   jmp  MBHorz_Done

MBHorz_CenterBest:

  mov   ecx,Block1.CentralInterSWD
   xor  ebp,ebp
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.CentralInterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   jmp  MBHorz_Done

MBHorz_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the left is best.
   mov  edx,[esi].BlkY1.PastRef
  dec   al
   mov  ecx,Block1.Ref1InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref1InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref1InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref1InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   dec  edx
  mov   [esi].BlkY1.PHMV,al
   mov  [esi].BlkY1.PastRef,edx

MBHorz_Done:

  mov   HalfPelHorzSavings,ebp
   mov  ebp,InitHalfPelSearchVert[ebx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  cmp   ecx,edx
   jl   MBVert_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel below is best.
  mov   Block1.CentralInterSWD,edx
   inc  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  [esi].BlkY1.PVMV,al
  mov   Block4.CentralInterSWD,edx
   jmp  MBVert_Done

MBVert_CenterBest:

  mov   ecx,Block1.CentralInterSWD_BLS
   xor  ebp,ebp
  mov   Block1.CentralInterSWD,ecx
   mov  ecx,Block2.CentralInterSWD_BLS
  mov   Block2.CentralInterSWD,ecx
   mov  ecx,Block3.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,ecx
   mov  ecx,Block4.CentralInterSWD_BLS
  mov   Block4.CentralInterSWD,ecx
   jmp  MBVert_Done

MBVert_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel above is best.
  mov   Block1.CentralInterSWD,edx
   dec  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,[esi].BlkY1.PastRef
  mov   Block4.CentralInterSWD,edx
   sub  ecx,PITCH
  mov   [esi].BlkY1.PVMV,al
   mov  [esi].BlkY1.PastRef,ecx

MBVert_Done:

  mov   ecx,HalfPelHorzSavings
   mov  edx,esi
  add   ebp,ecx                    ; Savings for horz and vert half pel motion.
   mov  ecx,MBCentralInterSWD      ; Reload SWD for new central point.
  sub   ecx,ebp                    ; Approx SWD for prescribed half pel motion.
   mov  esi,[edx].BlkY1.PastRef    ; Reload address of reference MB selected.
  mov   MBCentralInterSWD,ecx

SkipHalfPelSearch_1MV:

ENDIF ; H263

  mov   ebp,[edx].BlkY1.MVs    ; Load Motion Vectors
   add  esi,8
  mov   [edx].BlkY2.PastRef,esi
   mov  [edx].BlkY2.MVs,ebp
  lea   edi,[esi+PITCH*8]
   add  esi,PITCH*8-8
  mov   [edx].BlkY3.PastRef,esi
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,edi
   mov  [edx].BlkY4.MVs,ebp
IFDEF H261
ELSE ; H263
  mov   MBMotionVectors,ebp        ; Stash macroblock level motion vectors.
   mov  ebp,640 ; ??? BlockMVDifferential
  cmp   ecx,ebp
   jl   NoBlockMotionVectors

  mov   ecx,DoBlockLevelVectors
  test  ecx,ecx                    ; Are we doing block level motion vectors?
   je   NoBlockMotionVectors

;  Activity Details for this section of code  (refer to flow diagram above):
;
;  The following search is done similarly to the searches done above, except
;  these are block searches, instead of macroblock searches.
;
; Expected performance:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

;
;    Set up for the "BlkFullPelSWDLoop_4blks" loop to follow.
;    -  Store the SWD values for blocks 4, 3, 2, 1.
;    -  Compute and store the address of the central reference
;       point for blocks 1, 2, 3, 4.
;	 -  Compute and store the first address for ref 1 (minus 4 
;       pels horizontally) and ref 2 (plus 4 pels horizontally)
;       for blocks 4, 3, 2, 1 (in that order).
;    -  Initialize MotionOffsetsCursor
;    -  On exit:
;       esi = ref 1 address for block 1
;       edi = ref 2 address for block 1
;
  mov   esi,Block4.CentralInterSWD
   mov  edi,Block3.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,esi
   mov  Block3.CentralInterSWD_BLS,edi
  mov   esi,Block2.CentralInterSWD
   mov  edi,Block1.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,esi
   mov  eax,MBAddrCentralPoint   ; Reload addr of central, integer pel ref MB.
  mov   Block1.CentralInterSWD_BLS,edi
   mov  Block1.AddrCentralPoint,eax
  lea   edi,[eax+PITCH*8+8+1]
   lea  esi,[eax+PITCH*8+8-1]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   add  eax,8
  mov   Block2.AddrCentralPoint,eax
   add  eax,PITCH*8-8
  mov   Block3.AddrCentralPoint,eax
   add  eax,8
  mov   Block4.AddrCentralPoint,eax
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   mov  eax,OFFSET MotionOffsets
  mov   MotionOffsetsCursor,eax
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;
;  This loop will execute 6 times:
;    +- 4 pels horizontally
;    +- 4 pels vertically
;    +- 2 pels horizontally
;    +- 2 pels vertically
;    +- 1 pel horizontally
;    +- 1 pel vertically
;  It terminates when ref1 = ref2.  This simple termination
;  condition is what forces unrestricted motion vectors (UMV)
;  to be ON when advanced prediction (4MV) is ON.  Otherwise
;  we would need a state engine as above to distinguish edge
;  pels.
;
BlkFullPelSWDLoop_4blks:

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   eax,MotionOffsetsCursor

BlkFullPelSWDLoop_1blk:

  xor   esi,esi
   cmp  ebp,edx                         ; CF == 1 iff ref1 SWD < ref2 SWD.
  mov   edi,BlockNM1.CentralInterSWD_BLS; Get SWD for central pt of these 3 refs
   adc  esi,esi                         ; esi == 1 iff ref1 SWD < ref2 SWD.
  cmp   ebp,edi                         ; CF == 1 iff ref1 SWD < central SWD.
   mov  ebp,BlockNM2.Ref1InterSWD       ; Fetch next block's Ref1 SWD.
  adc   esi,esi
   cmp  edx,edi                         ; CF == 1 iff ref2 SWD < central SWD.
  adc   esi,esi                         ; 0 --> Pick central point.
  ;                                     ; 1 --> Pick ref2.
  ;                                     ; 2 --> Not possible.
  ;                                     ; 3 --> Pick ref2.
  ;                                     ; 4 --> Pick central point.
  ;                                     ; 5 --> Not possible.
  ;                                     ; 6 --> Pick ref1.
  ;                                     ; 7 --> Pick ref1.
   mov  edx,BlockNM2.Ref2InterSWD       ; Fetch next block's Ref2 SWD.
  sub   esp,BlockLen                    ; Move ahead to next block.
   mov  edi,[eax]                       ; Next ref2 motion vector offset.
  mov   cl,PickPoint_BLS[esi]           ; cl == 6: central pt; 2: ref1; 4: ref2
   mov  ebx,esp                         ; For testing completion.
  ;
   ;
  mov   esi,BlockN.AddrCentralPoint[ecx*2-12] ; Get the addr for pt we picked.
   mov  ecx,BlockN.CentralInterSWD[ecx*2]    ; Get the SWD for point we picked.
  mov   BlockN.AddrCentralPoint,esi          ; Stash addr for new central point.
   sub  esi,edi                              ; Compute next ref1 addr.
  mov   BlockN.Ref1Addr,esi                  ; Stash next ref1 addr.
   mov  BlockN.CentralInterSWD_BLS,ecx       ; Stash the SWD for central point.
  lea   edi,[esi+edi*2]                      ; Compute next ref2 addr.
   xor  ecx,ecx
  mov   BlockN.Ref2Addr,edi                  ; Stash next ref2 addr.
   and  ebx,00000001FH                       ; Done when esp at 32-byte bound.
  jne   BlkFullPelSWDLoop_1blk

  add   esp,BlockLen*4
   add  eax,4                       ; Advance MotionOffsets pointer.
  mov   MotionOffsetsCursor,eax
   cmp  esi,edi
  jne   BlkFullPelSWDLoop_4blks

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF

;
;  The following code has been modified to correctly decode the motion vectors
;  The previous code was simply subtracting the target frame base address
;  from the chosen (central) reference block address.
;  What is now done is the begining reference macroblock address computed
;  in ebp, then subtracted from the chosen (central) reference block address.
;  Then, for blocks 2, 3, and 4, the distance from block 1 to that block
;  is subtracted.  Care was taken to preserve the original pairing.
; 
  mov   esi,Block1.AddrCentralPoint ; B1a  Reload address of central ref block.
   mov  ebp,TargetMBAddr			; ****  CHANGE  ****  addr. of target MB

  mov   edi,Block2.AddrCentralPoint ; B2a
   add  ebp,TargToRef				; ****  CHANGE	****  add Reference - Target

; mov   ebp,PreviousFrameBaseAddress  ****  CHANGE  ****  DELETED

  mov   Block1.Ref1Addr,esi         ; B1b  Stash addr central ref block.
   sub  esi,ebp                     ; B1c  Addr of ref blk, but in target frame.

  mov   Block2.Ref1Addr,edi         ; B2b
   sub  edi,ebp                     ; B2c

  sub   edi,8                       ; ****  CHANGE  ****  Correct for block 2
   mov  eax,esi                     ; B1e Copy linearized MV.

  sar   esi,8                       ; B1f High 24 bits of lin MV lookup vert MV.
   mov  ebx,edi                     ; B2e

  sar   edi,8                       ; B2f
   add  eax,eax                     ; B1g Sign extend HMV;  *2 (# of half pels).

  mov   Block1.BlkHMV,al            ; B1h Save winning horz motion vector.
   add  ebx,ebx                     ; B2g

  mov   Block2.BlkHMV,bl            ; B2h
   mov  al,UnlinearizedVertMV[esi]  ; B1i Look up proper vert motion vector.

  mov   Block1.BlkVMV,al            ; B1j Save winning vert motion vector.
   mov  al,UnlinearizedVertMV[edi]  ; B2i

  mov   esi,Block3.AddrCentralPoint ; B3a
   mov  edi,Block4.AddrCentralPoint ; B4a

  mov   Block3.Ref1Addr,esi         ; B3b
   mov  Block4.Ref1Addr,edi         ; B4b

  mov   Block2.BlkVMV,al            ; B2j
   sub  esi,ebp                     ; B3c

  sub   esi,8*PITCH                 ; ****  CHANGE  ****  Correct for block 3
   sub  edi,ebp                     ; B4c

  sub   edi,8*PITCH+8               ; ****  CHANGE  ****  Correct for block 4
   mov  eax,esi                     ; B3e

  sar   esi,8                       ; B3f
   mov  ebx,edi                     ; B4e

  sar   edi,8                       ; B4f
   add  eax,eax                     ; B3g

  mov   Block3.BlkHMV,al            ; B3h
   add  ebx,ebx                     ; B4g

  mov   Block4.BlkHMV,bl            ; B4h
   mov  al,UnlinearizedVertMV[esi]  ; B3i

  mov   Block3.BlkVMV,al            ; B3j
   mov  al,UnlinearizedVertMV[edi]  ; B4i

  mov   ebp,Block1.CentralInterSWD_BLS
   mov  ebx,Block2.CentralInterSWD_BLS

  add   ebp,Block3.CentralInterSWD_BLS
   add  ebx,Block4.CentralInterSWD_BLS

  add   ebx,ebp
   mov  Block4.BlkVMV,al            ; B4j

  mov   ecx,DoHalfPelEstimation
   mov  MBCentralInterSWD_BLS,ebx

  test  ecx,ecx
   je   NoHalfPelBlockLevelMVs

HalfPelBlockLevelMotionSearch:

  mov   edi,Block1.AddrCentralPoint
   xor  ebp,ebp

;    ebp -- Initialized to 0, implying can search both left and right.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkHorz:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   BlockNM1.HalfPelSavings,ebp
   jl   BlkHorz_Ref1LTRef2

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,edx
   jle  BlkHorz_CenterBest

  inc   al
   mov  BlockN.HalfPelSavings,ebx
  mov   BlockN.BlkHMV,al
   jmp  BlkHorz_Done

BlkHorz_Ref1LTRef2:

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,ecx
   jle  BlkHorz_CenterBest

  mov   ecx,BlockN.Ref1Addr
   dec  al
  mov   BlockN.HalfPelSavings,ebx
   dec  ecx
  mov   BlockN.BlkHMV,al
   mov  BlockN.Ref1Addr,ecx

BlkHorz_CenterBest:
BlkHorz_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  jne   NextBlkHorz

  mov   edi,BlockN.AddrCentralPoint
   add  esp,BlockLen*4

;    ebp -- Initialized to 0, implying search both up and down is okay.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkVert:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   edi,BlockNM1.HalfPelSavings 
   jl   BlkVert_Ref1LTRef2

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   edx,ebx
   jge  BlkVert_CenterBest

  inc   al
   sub  edi,edx
  mov   BlockN.BlkVMV,al
   jmp  BlkVert_Done

BlkVert_Ref1LTRef2:

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   ecx,ebx
   jge  BlkVert_CenterBest

  sub   edi,ecx
   mov  ecx,BlockN.Ref1Addr
  dec   al
   sub  ecx,PITCH
  mov   BlockN.BlkVMV,al
   mov  BlockN.Ref1Addr,ecx

BlkVert_CenterBest:
BlkVert_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   sub  ebx,edi
  mov   BlockN.CentralInterSWD_BLS,ebx
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  lea   ebp,[ebp+edi]
   jne  NextBlkVert

  mov   ebx,MBCentralInterSWD_BLS+BlockLen*4
   add  esp,BlockLen*4
  sub   ebx,ebp
   xor  eax,eax  ; ??? Keep pairing happy

NoHalfPelBlockLevelMVs:

  mov   eax,MBCentralInterSWD
   mov  ecx,BlockMVDifferential
  sub   eax,ebx
   mov  edi,MB0MVInterSWD
  cmp   eax,ecx
   jle  BlockMVNotBigEnoughGain

  sub   edi,ebx
   mov  ecx,NonZeroMVDifferential
  cmp   edi,ecx
   jle  NonZeroMVNotBigEnoughGain

; Block motion vectors are best.

  mov   MBCentralInterSWD,ebx           ; Set MBlock's SWD to sum of 4 blocks.
   mov  edx,MBlockActionStream
  mov   eax,Block1.CentralInterSWD_BLS  ; Set each block's SWD.
   mov  ebx,Block2.CentralInterSWD_BLS
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,ebx
  mov   eax,Block3.CentralInterSWD_BLS
   mov  ebx,Block4.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,ebx
  mov   eax,Block1.BlkMVs               ; Set each block's motion vector.
   mov  ebx,Block2.BlkMVs
  mov   [edx].BlkY1.MVs,eax
   mov  [edx].BlkY2.MVs,ebx
  mov   eax,Block3.BlkMVs
   mov  ebx,Block4.BlkMVs
  mov   [edx].BlkY3.MVs,eax
   mov  [edx].BlkY4.MVs,ebx
  mov   eax,Block1.Ref1Addr             ; Set each block's reference blk addr.
   mov  ebx,Block2.Ref1Addr
  mov   [edx].BlkY1.PastRef,eax
   mov  [edx].BlkY2.PastRef,ebx
  mov   eax,Block3.Ref1Addr
   mov  ebx,Block4.Ref1Addr
  mov   [edx].BlkY3.PastRef,eax
   mov  eax,INTER4MV                    ; Set type for MB to INTER-coded, 4 MVs.
  mov   [edx].BlkY4.PastRef,ebx
   mov  [edx].BlockType,al
  jmp   MotionVectorSettled

NoBlockMotionVectors:

ENDIF ; H263

  mov   edi,MB0MVInterSWD

BlockMVNotBigEnoughGain:                ; Try MB-level motion vector.

  mov   eax,MBCentralInterSWD
   mov  ecx,NonZeroMVDifferential
  sub   edi,eax
   mov  edx,MBlockActionStream
  cmp   edi,ecx
   jg   MotionVectorSettled

NonZeroMVNotBigEnoughGain:              ; Settle on zero MV.

  mov   eax,Block1.ZeroMVInterSWD       ; Restore Zero MV SWD.
   mov  edx,Block2.ZeroMVInterSWD
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,edx
  mov   eax,Block3.ZeroMVInterSWD
   mov  edx,Block4.ZeroMVInterSWD
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,edx
  mov   eax,MB0MVInterSWD               ; Restore SWD for zero motion vector.

BelowZeroThresh:

  mov   edx,MBlockActionStream
   mov  ebx,TargetMBAddr              ; Get address of this target macroblock.
  mov   MBCentralInterSWD,eax         ; Save SWD.
   xor  ebp,ebp
  add   ebx,TargToRef
   mov  [edx].BlkY1.MVs,ebp           ; Set horz and vert MVs to 0 in all blks.
  mov   [edx].BlkY1.PastRef,ebx       ; Save address of ref block, all blks.
   add  ebx,8
  mov   [edx].BlkY2.PastRef,ebx
   mov  [edx].BlkY2.MVs,ebp
  lea   ecx,[ebx+PITCH*8]
   add  ebx,PITCH*8-8
  mov   [edx].BlkY3.PastRef,ebx
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,ecx
   mov  [edx].BlkY4.MVs,ebp

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     6)  We've settled on the motion vector that will be used if we do indeed
;         code the macroblock with inter-coding.  We need to determine if some
;         or all of the blocks can be forced as empty (copy).
;         blocks.  If all the blocks can be forced empty, we force the whole
;         macroblock to be empty.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per macroblock.
;
;    23 clocks.
;

MotionVectorSettled:

IFDEF H261
   mov  edi,MBCentralInterSWD
  mov   eax,DoSpatialFiltering   ; Are we doing spatial filtering?
   mov  edi,TargetMBAddr
  test  eax,eax
   je   SkipSpatialFiltering

  mov   ebx,MBCentralInterSWD
   mov  esi,SpatialFiltThreshold
  cmp   ebx,esi
   jle  SkipSpatialFiltering

  add   edi,TargToSLF            ; Compute addr at which to put SLF prediction.
   xor  ebx,ebx
  mov   esi,[edx].BlkY1.PastRef
   xor  edx,edx
  mov   ebp,16
   xor  ecx,ecx

SpatialFilterHorzLoop:

  mov   dl,[edi]        ; Pre-load cache line for output.
   mov  bl,[esi+6]      ; p6
  mov   al,[esi+7]      ; p7
   inc  bl              ; p6+1
  mov   cl,[esi+5]      ; p5
   mov  [edi+7],al      ; p7' = p7
  add   al,bl           ; p7 + p6 + 1
   add  bl,cl           ; p6 + p5 + 1
  mov   dl,[esi+4]      ; p4
   add  eax,ebx         ; p7 + 2p6 + p5 + 2
  shr   eax,2           ; p6' = (p7 + 2p6 + p5 + 2) / 4
   inc  dl              ; p4 + 1
  add   cl,dl           ; p5 + p4 + 1
   mov  [edi+6],al      ; p6'
  mov   al,[esi+3]      ; p3
   add  ebx,ecx         ; p6 + 2p5 + p4 + 2
  shr   ebx,2           ; p5' = (p6 + 2p5 + p4 + 2) / 4
   add  dl,al           ; p4 + p3 + 1
  mov   [edi+5],bl      ; p5'
   mov  bl,[esi+2]      ; p2
  add   ecx,edx         ; p5 + 2p4 + p3 + 2
   inc  bl              ; p2 + 1
  shr   ecx,2           ; p4' = (p5 + 2p4 + p3 + 2) / 4
   add  al,bl           ; p3 + p2 + 1
  mov   [edi+4],cl      ; p4'
   add  edx,eax         ; p4 + 2p3 + p2 + 2
  shr   edx,2           ; p3' = (p4 + 2p3 + p2 + 2) / 4
   mov  cl,[esi+1]      ; p1
  add   bl,cl           ; p2 + p1 + 1
   mov  [edi+3],dl      ; p3'
  add   eax,ebx         ; p3 + 2p2 + p1 + 2
   mov  dl,[esi]        ; p0
  shr   eax,2           ; p2' = (p3 + 2p2 + p1 + 2) / 4
   inc  ebx             ; p2 + p1 + 2
  mov   [edi+2],al      ; p2'
   add  ebx,ecx         ; p2 + 2p1 + 2
  mov   [edi],dl        ; p0' = p0
   add  ebx,edx         ; p2 + 2p1 + p0 + 2
  shr   ebx,2           ; p1' = (p2 + 2p1 + p0 + 2) / 4
   mov  al,[esi+7+8]
  mov   [edi+1],bl      ; p1'
   mov  bl,[esi+6+8]
  inc   bl
   mov  cl,[esi+5+8]
  mov   [edi+7+8],al
   add  al,bl
  add   bl,cl
   mov  dl,[esi+4+8]
  add   eax,ebx
   ;
  shr   eax,2
   inc  dl
  add   cl,dl
   mov  [edi+6+8],al
  mov   al,[esi+3+8]
   add  ebx,ecx
  shr   ebx,2
   add  dl,al
  mov   [edi+5+8],bl
   mov  bl,[esi+2+8]
  add   ecx,edx
   inc  bl
  shr   ecx,2
   add  al,bl
  mov   [edi+4+8],cl
   add  edx,eax
  shr   edx,2
   mov  cl,[esi+1+8]
  add   bl,cl
   mov  [edi+3+8],dl
  add   eax,ebx
   mov  dl,[esi+8]
  shr   eax,2
   inc  ebx
  mov   [edi+2+8],al
   add  ebx,ecx
  mov   [edi+8],dl
   add  ebx,edx
  shr   ebx,2
   add  esi,PITCH
  mov   [edi+1+8],bl
   add  edi,PITCH
  dec   ebp             ; Done?
   jne  SpatialFilterHorzLoop

  mov   VertFilterDoneAddr,edi
   sub  edi,PITCH*16

SpatialFilterVertLoop:

  mov   eax,[edi]                ;  p0
   ;                             ;  Bank conflict for sure.
  ;
   mov  ebx,[edi+PITCH]          ;  p1
  add   eax,ebx                  ;  p0+p1
   mov  ecx,[edi+PITCH*2]        ;  p2
  add   ebx,ecx                  ;  p1+p2
   mov  edx,[edi+PITCH*3]        ;  p3
  shr   eax,1                    ; (p0+p1)/2                       dirty
   mov  esi,[edi+PITCH*4]        ;  p4
  add   ecx,edx                  ;  p2+p3
   mov  ebp,[edi+PITCH*5]        ;  p5
  shr   ebx,1                    ; (p1+p2)/2                       dirty
   add  edx,esi                  ;  p3+p4
  and   eax,07F7F7F7FH           ; (p0+p1)/2                       clean
   and  ebx,07F7F7F7FH           ; (p1+p2)/2                       clean
  and   ecx,0FEFEFEFEH           ;  p2+p3                          pre-cleaned
   and  edx,0FEFEFEFEH           ;  p3+p4                          pre-cleaned
  shr   ecx,1                    ; (p2+p3)/2                       clean
   add  esi,ebp                  ;  p4+p5
  shr   edx,1                    ; (p3+p4)/2                       clean
   lea  eax,[eax+ebx+001010101H] ; (p0+p1)/2+(p1+p2)/2+1
  shr   esi,1                    ; (p4+p5)/2                       dirty
   ;
  and   esi,07F7F7F7FH           ; (p4+p5)/2                       clean
   lea  ebx,[ebx+ecx+001010101H] ; (p1+p2)/2+(p2+p3)/2+1
  shr   eax,1                    ; p1' = ((p0+p1)/2+(p1+p2)/2+1)/2 dirty
   lea  ecx,[ecx+edx+001010101H] ; (p2+p3)/2+(p3+p4)/2+1
  shr   ebx,1                    ; p2' = ((p1+p2)/2+(p2+p3)/2+1)/2 dirty
   lea  edx,[edx+esi+001010101H] ; (p3+p4)/2+(p4+p5)/2+1
  and   eax,07F7F7F7FH           ; p1'                             clean
   and  ebx,07F7F7F7FH           ; p2'                             clean
  shr   ecx,1                    ; p3' = ((p2+p3)/2+(p3+p4)/2+1)/2 dirty
   mov  [edi+PITCH],eax          ; p1'
  shr   edx,1                    ; p4' = ((p3+p4)/2+(p4+p5)/2+1)/2 dirty
   mov  eax,[edi+PITCH*6]        ;  p6
  and   ecx,07F7F7F7FH           ; p3'                             clean
   and  edx,07F7F7F7FH           ; p4'                             clean
  mov   [edi+PITCH*2],ebx        ; p2'
   add  ebp,eax                  ;  p5+p6
  shr   ebp,1                    ; (p5+p6)/2                       dirty
   mov  ebx,[edi+PITCH*7]        ;  p7
  add   eax,ebx                  ;  p6+p7
   and  ebp,07F7F7F7FH           ; (p5+p6)/2                       clean
  mov   [edi+PITCH*3],ecx        ; p3'
   and  eax,0FEFEFEFEH           ; (p6+p7)/2                       pre-cleaned
  shr   eax,1                    ; (p6+p7)/2                       clean
   lea  esi,[esi+ebp+001010101H] ; (p4+p5)/2+(p5+p6)/2+1
  shr   esi,1                    ; p5' = ((p4+p5)/2+(p5+p6)/2+1)/2 dirty
   mov  [edi+PITCH*4],edx        ; p4'
  lea   ebp,[ebp+eax+001010101H] ; (p5+p6)/2+(p6+p7)/2+1
   and  esi,07F7F7F7FH           ; p5'                             clean
  shr   ebp,1                    ; p6' = ((p5+p6)/2+(p6+p7)/2+1)/2 dirty
   mov  [edi+PITCH*5],esi        ; p5'
  and   ebp,07F7F7F7FH           ; p6'                             clean
   add  edi,4
  test  edi,00000000FH
  mov   [edi+PITCH*6-4],ebp      ; p6'
   jne  SpatialFilterVertLoop

  add   edi,PITCH*8-16
   mov  eax,VertFilterDoneAddr
  cmp   eax,edi
   jne  SpatialFilterVertLoop
  

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     9)  The SAD for the spatially filtered reference macroblock is calculated
;         with half the pel differences accumulating into the low order half
;         of ebp, and the other half into the high order half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;
;   Predominate usage for body of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;     esi, eax -- -8 times pel values from target macroblock.
;     ebp[ 0:15] -- SAD Accumulator for half of the match points.
;     ebp[16:31] -- SAD Accumulator for other half of the match points.
;     edx[ 0: 7] -- Weighted difference for one pel.
;     edx[ 8:15] -- Zero.
;     edx[16:23] -- Weighted difference for another pel.
;     edx[24:31] -- Zero.
;     bl, cl -- Pel values from the spatially filtered reference macroblock.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
;   146 clocks instruction execution (typically).
;     6 clocks for bank conflicts (1/8 chance with 48 dual mem ops).
;     0 clocks for new cache line fills.
;  ----
;   152 clocks total time for this section.
;

SpatialFilterDone:

  sub   edi,PITCH*8-8             ; Get to block 4.
   xor  ebp,ebp
  xor   ebx,ebx
   xor  ecx,ecx

SLFSWDLoop:

  mov   eax,BlockNM1.N8T00        ; Get -8 times target Pel00.
   mov  bl,[edi]                  ; Get Pel00 in spatially filtered reference.
  mov   esi,BlockNM1.N8T04
   mov  cl,[edi+4]
  mov   edx,[eax+ebx*8]           ; Get abs diff for spatial filtered ref pel00.
   mov  eax,BlockNM1.N8T02
  mov   dl,[esi+ecx*8+2]          ; Get abs diff for spatial filtered ref pel04.
   mov  bl,[edi+2]
  mov   esi,BlockNM1.N8T06
   mov  cl,[edi+6]
  mov   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T11
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*1+1]
   mov  cl,[edi+PITCH*1+5]
  mov   esi,BlockNM1.N8T15
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T13
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*1+3]
  mov   cl,[edi+PITCH*1+7]
   mov  esi,BlockNM1.N8T17
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T20
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*2+0]
   mov  cl,[edi+PITCH*2+4]
  mov   esi,BlockNM1.N8T24
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T22
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*2+2]
  mov   cl,[edi+PITCH*2+6]
   mov  esi,BlockNM1.N8T26
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T31
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*3+1]
   mov  cl,[edi+PITCH*3+5]
  mov   esi,BlockNM1.N8T35
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T33
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*3+3]
  mov   cl,[edi+PITCH*3+7]
   mov  esi,BlockNM1.N8T37
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T40
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*4+0]
   mov  cl,[edi+PITCH*4+4]
  mov   esi,BlockNM1.N8T44
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T42
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*4+2]
  mov   cl,[edi+PITCH*4+6]
   mov  esi,BlockNM1.N8T46
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T51
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*5+1]
   mov  cl,[edi+PITCH*5+5]
  mov   esi,BlockNM1.N8T55
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T53
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*5+3]
  mov   cl,[edi+PITCH*5+7]
   mov  esi,BlockNM1.N8T57
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T60
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*6+0]
   mov  cl,[edi+PITCH*6+4]
  mov   esi,BlockNM1.N8T64
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T62
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*6+2]
  mov   cl,[edi+PITCH*6+6]
   mov  esi,BlockNM1.N8T66
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T71
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*7+1]
   mov  cl,[edi+PITCH*7+5]
  mov   esi,BlockNM1.N8T75
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T73
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*7+3]
  mov   cl,[edi+PITCH*7+7]
   mov  esi,BlockNM1.N8T77
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  add   edx,ebp   
   mov  cl,[esi+ecx*8+2]
  shr   edx,16 
   add  ebp,ecx
  and   ebp,0FFFFH
   sub  esp,BlockLen
  add   ebp,edx
   sub  edi,8
  test  esp,000000008H
  mov   BlockN.CentralInterSWD_SLF,ebp
   jne  SLFSWDLoop

  test  esp,000000010H
  lea   edi,[edi-PITCH*8+16]
   jne  SLFSWDLoop

  mov   eax,Block2.CentralInterSWD_SLF+BlockLen*4
   mov  ebx,Block3.CentralInterSWD_SLF+BlockLen*4
  mov   ecx,Block4.CentralInterSWD_SLF+BlockLen*4
   add  esp,BlockLen*4
  add   ebp,ecx
   lea  edx,[eax+ebx]
  add   ebp,edx
   mov  edx,SpatialFiltDifferential
  lea   esi,[edi+PITCH*8-8]
   mov  edi,MBCentralInterSWD
  sub   edi,edx
   mov  edx,MBlockActionStream
  cmp   ebp,edi
   jge  SpatialFilterNotAsGood

  mov   MBCentralInterSWD,ebp            ; Spatial filter was better.  Stash
   mov  ebp,Block1.CentralInterSWD_SLF   ; pertinent calculations.
  mov   Block2.CentralInterSWD,eax
   mov  Block3.CentralInterSWD,ebx
  mov   Block4.CentralInterSWD,ecx
   mov  Block1.CentralInterSWD,ebp
  mov   [edx].BlkY1.PastRef,esi
   mov  al,INTERSLF
  mov   [edx].BlockType,al

SkipSpatialFiltering:
SpatialFilterNotAsGood:
ENDIF ; H261

  mov   al,[edx].CodedBlocks       ; Fetch coded block pattern.
   mov  edi,EmptyThreshold         ; Get threshold for forcing block empty?
  mov   ebp,MBCentralInterSWD
   mov  esi,InterSWDBlocks
  mov   ebx,Block4.CentralInterSWD ; Is SWD > threshold?
  cmp   ebx,edi
   jg   @f

  and   al,0F7H                    ; If not, indicate block 4 is NOT coded.
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block3.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FBH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block2.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FDH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block1.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FEH
   dec  esi
  sub   ebp,ebx

@@:

  mov   [edx].CodedBlocks,al     ; Store coded block pattern.
   add  esi,4
  mov   InterSWDBlocks,esi
   xor  ebx,ebx
  and   eax,00FH
   mov  MBCentralInterSWD,ebp
  cmp   al,00FH                  ; Are any blocks marked empty?
   jne  InterBest                ; If some blocks are empty, can't code as Intra

  cmp   ebp,InterCodingThreshold ; Is InterSWD below inter-coding threshhold.
   lea  esi,Block1+128
  mov   ebp,0
   jae  CalculateIntraSWD

InterBest:

  mov   ecx,InterSWDTotal
   mov  ebp,MBCentralInterSWD
  add   ecx,ebp                    ; Add to total for this macroblock class.
   mov  PD [edx].SWD,ebp
  mov   InterSWDTotal,ecx
   jmp  NextMacroBlock


;  Activity Details for this section of code  (refer to flow diagram above):
;
;    11)  The IntraSWD is calculated as two partial sums, one in the low order
;         16 bits of ebp and one in the high order 16 bits.  An average pel
;         value for each block will be calculated to the nearest half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     None
;
;   Predominate usage for body of this section:
;
;     esi -- Address of target block 1 (3), plus 128.
;     ebp[ 0:15] -- IntraSWD Accumulator for block 1 (3).
;     ebp[16:31] -- IntraSWD Accumulator for block 2 (4).
;     edi -- Block 2 (4) target pel, times -8, and with WeightedDiff added.
;     edx -- Block 1 (3) target pel, times -8, and with WeightedDiff added.
;     ecx[ 0: 7] -- Weighted difference for one pel in block 2 (4).
;     ecx[ 8:15] -- Zero.
;     ecx[16:23] -- Weighted difference for one pel in block 1 (3).
;     ecx[24:31] -- Zero.
;     ebx -- Average block 2 (4) target pel to nearest .5.
;     eax -- Average block 1 (3) target pel to nearest .5.
;
;   Output of this section:
;
;     edi -- Scratch.
;     ebp[ 0:15] -- IntraSWD.  (Also written to MBlockActionStream.)
;     ebp[16:31] -- garbage.
;     ebx -- Zero.
;     eax -- MBlockActionStream.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Executed once per macroblock, (except for those for which one of more blocks
;   are marked empty, or where the InterSWD is less than a threshold).
;
;   183 clocks for instruction execution
;    12 clocks for bank conflicts  (94 dual mem ops with 1/8 chance of conflict)
;  ----
;   195 clocks total time for this section.

IntraByDecree:

  mov   eax,InterSWDBlocks            ; Inc by 4, because we will undo it below.
   xor  ebp,ebp
  mov   MBMotionVectors,ebp           ; Stash zero for MB level motion vectors.
   mov  ebp,040000000H                ; Set Inter SWD artificially high.
  lea   esi,Block1+128
   add  eax,4
  mov   MBCentralInterSWD,ebp
   mov  InterSWDBlocks,eax

CalculateIntraSWD:
CalculateIntraSWDLoop:

  mov   eax,[esi-128].AccumTargetPels  ; Fetch acc of target pels for 1st block.
   mov  edx,[esi-128].N8T00
  add   eax,8
   mov  ebx,[esi-128+BlockLen].AccumTargetPels
  shr   eax,4                ; Average block 1 target pel rounded to nearest .5.
   add  ebx,8
  shr   ebx,4
   mov  edi,[esi-128+BlockLen].N8T00
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T02
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T02
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T04
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T04
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T06
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T06
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T11
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T11
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T13
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T13
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T15
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T15
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T17
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T17
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T20
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T20
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T22
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T22
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T24
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T24
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T26
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T26
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T31
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T31
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T33
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T33
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T35
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T35
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T37
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T37
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T40
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T40
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T42
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T42
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T44
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T44
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T46
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T46
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T51
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T51
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T53
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T53
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T55
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T55
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T57
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T57
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T60
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T60
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T62
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T62
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T64
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T64
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T66
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T66
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T71
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T71
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T73
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T73
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T75
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T75
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T77
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T77
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   cl,PB [edi+ebx*4+2]
   mov  eax,000007FFFH
  add   ebp,ecx
   add  esi,BlockLen*2
  and   eax,ebp
   mov  ecx,MBCentralInterSWD
  shr   ebp,16
   sub  ecx,IntraCodingDifferential
  add   ebp,eax
   mov  edx,MBlockActionStream    ; Reload list ptr.
  cmp   ecx,ebp                    ; Is IntraSWD > InterSWD - differential?
   jl   InterBest

  lea   ecx,Block1+128+BlockLen*2
  cmp   ecx,esi
   je   CalculateIntraSWDLoop


;  ebp  -- IntraSWD
;  edx  -- MBlockActionStream

DoneCalcIntraSWD:

IntraBest:

  mov   ecx,IntraSWDTotal
   mov  edi,IntraSWDBlocks
  add   ecx,ebp                    ; Add to total for this macroblock class.
   add  edi,4                      ; Accumulate # of blocks for this type.
  mov   IntraSWDBlocks,edi
   mov  edi,InterSWDBlocks
  sub   edi,4
   mov  IntraSWDTotal,ecx
  mov   InterSWDBlocks,edi
   mov  bl,INTRA
  mov   PB [edx].BlockType,bl      ; Indicate macroblock handling decision.
IFDEF H261
   xor  ebx,ebx
ELSE ; H263
   mov  ebx,MBMotionVectors        ; Set MVs to best MB level motion vectors.
ENDIF
  mov   PD [edx].BlkY1.MVs,ebx
   mov  PD [edx].BlkY2.MVs,ebx
  mov   PD [edx].BlkY3.MVs,ebx
   mov  PD [edx].BlkY4.MVs,ebx
  xor   ebx,ebx
  mov   PD [edx].SWD,ebp
   jmp  NextMacroBlock

;==============================================================================
; Internal functions
;==============================================================================

DoSWDLoop:

;  Upon entry:
;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   bl,PB [esi]               ; 00A -- Get Pel 00 in reference ref1.
   mov  eax,Block1.N8T00+4        ; 00B -- Get -8 times target pel 00.
  mov   cl,PB [edi]               ; 00C -- Get Pel 00 in reference ref2.
   sub  esp,BlockLen*4+28

SWDLoop:

  mov   edx,PD [eax+ebx*8]        ; 00D -- Get weighted diff for ref1 pel 00.
   mov  bl,PB [esi+2]             ; 02A
  mov   dl,PB [eax+ecx*8+2]       ; 00E -- Get weighted diff for ref2 pel 00.
   mov  eax,BlockN.N8T02+32       ; 02B
  mov   ebp,edx                   ; 00F -- Accum weighted diffs for pel 00.
   mov  cl,PB [edi+2]             ; 02C
  mov   edx,PD [eax+ebx*8]        ; 02D
   mov  bl,PB [esi+4]             ; 04A
  mov   dl,PB [eax+ecx*8+2]       ; 02E
   mov  eax,BlockN.N8T04+32       ; 04B
  mov   cl,PB [edi+4]             ; 04C
   add  ebp,edx                   ; 02F
  mov   edx,PD [eax+ebx*8]        ; 04D
   mov  bl,PB [esi+6]
  mov   dl,PB [eax+ecx*8+2]       ; 04E
   mov  eax,BlockN.N8T06+32
  mov   cl,PB [edi+6]
   add  ebp,edx                   ; 04F
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T11+32
  mov   cl,PB [edi+PITCH*1+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T13+32
  mov   cl,PB [edi+PITCH*1+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T15+32
  mov   cl,PB [edi+PITCH*1+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T17+32
  mov   cl,PB [edi+PITCH*1+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T20+32
  mov   cl,PB [edi+PITCH*2+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T22+32
  mov   cl,PB [edi+PITCH*2+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T24+32
  mov   cl,PB [edi+PITCH*2+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T26+32
  mov   cl,PB [edi+PITCH*2+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T31+32
  mov   cl,PB [edi+PITCH*3+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T33+32
  mov   cl,PB [edi+PITCH*3+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T35+32
  mov   cl,PB [edi+PITCH*3+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T37+32
  mov   cl,PB [edi+PITCH*3+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T40+32
  mov   cl,PB [edi+PITCH*4+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T42+32
  mov   cl,PB [edi+PITCH*4+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T44+32
  mov   cl,PB [edi+PITCH*4+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T46+32
  mov   cl,PB [edi+PITCH*4+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T51+32
  mov   cl,PB [edi+PITCH*5+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T53+32
  mov   cl,PB [edi+PITCH*5+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T55+32
  mov   cl,PB [edi+PITCH*5+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T57+32
  mov   cl,PB [edi+PITCH*5+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T60+32
  mov   cl,PB [edi+PITCH*6+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T62+32
  mov   cl,PB [edi+PITCH*6+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T64+32
  mov   cl,PB [edi+PITCH*6+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T66+32
  mov   cl,PB [edi+PITCH*6+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T71+32
  mov   cl,PB [edi+PITCH*7+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T73+32
  mov   cl,PB [edi+PITCH*7+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T75+32
  mov   cl,PB [edi+PITCH*7+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T77+32
  mov   cl,PB [edi+PITCH*7+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   add  esp,BlockLen
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,ebp
  add   ebp,edx
   add  edx,eax
  shr   ebp,16                       ; Extract SWD for ref1.
   and  edx,00000FFFFH               ; Extract SWD for ref2.
  mov   esi,BlockN.Ref1Addr+32       ; Get address of next ref1 block.
   mov  edi,BlockN.Ref2Addr+32       ; Get address of next ref2 block.
  mov   BlockNM1.Ref1InterSWD+32,ebp ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,edx ; Store SWD for ref2.
  mov   bl,PB [esi]                  ; 00A -- Get Pel 02 in reference ref1.
   mov  eax,BlockN.N8T00+32          ; 00B -- Get -8 times target pel 00.
  test  esp,000000018H               ; Done when esp is 32-byte aligned.
  mov   cl,PB [edi]                  ; 00C -- Get Pel 02 in reference ref2.
   jne  SWDLoop

; Output:
;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  add   esp,28
  ret

IFDEF H261
ELSE ; H263

DoSWDHalfPelHorzLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelHorzLoop:

  mov   al,[edi]           ; 00A -- Fetch center ref pel 00.
   mov  esi,BlockN.N8T00+32; 00B -- Target pel 00 (times -8).
  mov   bl,[edi+2]         ; 02A -- Fetch center ref pel 02.
   mov  edx,BlockN.N8T02+32; 02B -- Target pel 02 (times -8).
  lea   esi,[esi+eax*4]    ; 00C -- Combine target pel 00 and center ref pel 00.
   mov  al,[edi-1]         ; 00D -- Get pel to left for match against pel 00.
  lea   edx,[edx+ebx*4]    ; 02C -- Combine target pel 02 and center ref pel 02.
   mov  bl,[edi+1]         ; 00E -- Get pel to right for match against pel 00,
   ;                       ; 02D -- and pel to left for match against pel 02.
  mov   ecx,[esi+eax*4]    ; 00F -- [16:23]  weighted diff for left ref pel 00.
   mov  al,[edi+3]         ; 02E -- Get pel to right for match against pel 02.
  add   ebp,ecx            ; 00G -- Accumulate left ref pel 00.
   mov  ecx,[edx+ebx*4]    ; 02F -- [16:23]  weighted diff for left ref pel 02.
  mov   cl,[edx+eax*4+2]   ; 02H -- [0:7] is weighted diff for right ref pel 02.
   mov  al,[edi+4]         ; 04A
  add   ebp,ecx            ; 02I -- Accumulate right ref pel 02,
  ;                        ; 02G -- Accumulate left ref pel 02.
   mov  bl,[esi+ebx*4+2]   ; 00H -- [0:7] is weighted diff for right ref pel 00.
  add   ebp,ebx            ; 00I -- Accumulate right ref pel 00.
   mov  esi,BlockN.N8T04+32; 04B
  mov   bl,[edi+6]         ; 06A
   mov  edx,BlockN.N8T06+32; 06B
  lea   esi,[esi+eax*4]    ; 04C
   mov  al,[edi+3]         ; 04D
  lea   edx,[edx+ebx*4]    ; 06C
   mov  bl,[edi+5]         ; 04E & 06D
  mov   ecx,[esi+eax*4]    ; 04F
   mov  al,[edi+7]         ; 06E
  add   ebp,ecx            ; 04G
   mov  ecx,[edx+ebx*4]    ; 06F
  mov   cl,[edx+eax*4+2]   ; 06H
   mov  al,[edi+PITCH*1+1] ; 11A
  add   ebp,ecx            ; 04I & 06G
   mov  bl,[esi+ebx*4+2]   ; 04H
  add   ebp,ebx            ; 04I
   mov  esi,BlockN.N8T11+32; 11B
  mov   bl,[edi+PITCH*1+3] ; 13A
   mov  edx,BlockN.N8T13+32; 13B
  lea   esi,[esi+eax*4]    ; 11C
   mov  al,[edi+PITCH*1+0] ; 11D
  lea   edx,[edx+ebx*4]    ; 13C
   mov  bl,[edi+PITCH*1+2] ; 11E & 13D
  mov   ecx,[esi+eax*4]    ; 11F
   mov  al,[edi+PITCH*1+4] ; 13E
  add   ebp,ecx            ; 11G
   mov  ecx,[edx+ebx*4]    ; 13F
  mov   cl,[edx+eax*4+2]   ; 13H
   mov  al,[edi+PITCH*1+5] ; 15A
  add   ebp,ecx            ; 11I & 13G
   mov  bl,[esi+ebx*4+2]   ; 11H
  add   ebp,ebx            ; 11I
   mov  esi,BlockN.N8T15+32; 15B
  mov   bl,[edi+PITCH*1+7] ; 17A
   mov  edx,BlockN.N8T17+32; 17B
  lea   esi,[esi+eax*4]    ; 15C
   mov  al,[edi+PITCH*1+4] ; 15D
  lea   edx,[edx+ebx*4]    ; 17C
   mov  bl,[edi+PITCH*1+6] ; 15E & 17D
  mov   ecx,[esi+eax*4]    ; 15F
   mov  al,[edi+PITCH*1+8] ; 17E
  add   ebp,ecx            ; 15G
   mov  ecx,[edx+ebx*4]    ; 17F
  mov   cl,[edx+eax*4+2]   ; 17H
   mov  al,[edi+PITCH*2+0] ; 20A
  add   ebp,ecx            ; 15I & 17G
   mov  bl,[esi+ebx*4+2]   ; 15H
  add   ebp,ebx            ; 15I
   mov  esi,BlockN.N8T20+32; 20B
  mov   bl,[edi+PITCH*2+2] ; 22A
   mov  edx,BlockN.N8T22+32; 22B
  lea   esi,[esi+eax*4]    ; 20C
   mov  al,[edi+PITCH*2-1] ; 20D
  lea   edx,[edx+ebx*4]    ; 22C
   mov  bl,[edi+PITCH*2+1] ; 20E & 22D
  mov   ecx,[esi+eax*4]    ; 20F
   mov  al,[edi+PITCH*2+3] ; 22E
  add   ebp,ecx            ; 20G
   mov  ecx,[edx+ebx*4]    ; 22F
  mov   cl,[edx+eax*4+2]   ; 22H
   mov  al,[edi+PITCH*2+4] ; 24A
  add   ebp,ecx            ; 20I & 22G
   mov  bl,[esi+ebx*4+2]   ; 20H
  add   ebp,ebx            ; 20I
   mov  esi,BlockN.N8T24+32; 24B
  mov   bl,[edi+PITCH*2+6] ; 26A
   mov  edx,BlockN.N8T26+32; 26B
  lea   esi,[esi+eax*4]    ; 24C
   mov  al,[edi+PITCH*2+3] ; 24D
  lea   edx,[edx+ebx*4]    ; 26C
   mov  bl,[edi+PITCH*2+5] ; 24E & 26D
  mov   ecx,[esi+eax*4]    ; 24F
   mov  al,[edi+PITCH*2+7] ; 26E
  add   ebp,ecx            ; 24G
   mov  ecx,[edx+ebx*4]    ; 26F
  mov   cl,[edx+eax*4+2]   ; 26H
   mov  al,[edi+PITCH*3+1] ; 31A
  add   ebp,ecx            ; 24I & 26G
   mov  bl,[esi+ebx*4+2]   ; 24H
  add   ebp,ebx            ; 24I
   mov  esi,BlockN.N8T31+32; 31B
  mov   bl,[edi+PITCH*3+3] ; 33A
   mov  edx,BlockN.N8T33+32; 33B
  lea   esi,[esi+eax*4]    ; 31C
   mov  al,[edi+PITCH*3+0] ; 31D
  lea   edx,[edx+ebx*4]    ; 33C
   mov  bl,[edi+PITCH*3+2] ; 31E & 33D
  mov   ecx,[esi+eax*4]    ; 31F
   mov  al,[edi+PITCH*3+4] ; 33E
  add   ebp,ecx            ; 31G
   mov  ecx,[edx+ebx*4]    ; 33F
  mov   cl,[edx+eax*4+2]   ; 33H
   mov  al,[edi+PITCH*3+5] ; 35A
  add   ebp,ecx            ; 31I & 33G
   mov  bl,[esi+ebx*4+2]   ; 31H
  add   ebp,ebx            ; 31I
   mov  esi,BlockN.N8T35+32; 35B
  mov   bl,[edi+PITCH*3+7] ; 37A
   mov  edx,BlockN.N8T37+32; 37B
  lea   esi,[esi+eax*4]    ; 35C
   mov  al,[edi+PITCH*3+4] ; 35D
  lea   edx,[edx+ebx*4]    ; 37C
   mov  bl,[edi+PITCH*3+6] ; 35E & 37D
  mov   ecx,[esi+eax*4]    ; 35F
   mov  al,[edi+PITCH*3+8] ; 37E
  add   ebp,ecx            ; 35G
   mov  ecx,[edx+ebx*4]    ; 37F
  mov   cl,[edx+eax*4+2]   ; 37H
   mov  al,[edi+PITCH*4+0] ; 40A
  add   ebp,ecx            ; 35I & 37G
   mov  bl,[esi+ebx*4+2]   ; 35H
  add   ebp,ebx            ; 35I
   mov  esi,BlockN.N8T40+32; 40B
  mov   bl,[edi+PITCH*4+2] ; 42A
   mov  edx,BlockN.N8T42+32; 42B
  lea   esi,[esi+eax*4]    ; 40C
   mov  al,[edi+PITCH*4-1] ; 40D
  lea   edx,[edx+ebx*4]    ; 42C
   mov  bl,[edi+PITCH*4+1] ; 40E & 42D
  mov   ecx,[esi+eax*4]    ; 40F
   mov  al,[edi+PITCH*4+3] ; 42E
  add   ebp,ecx            ; 40G
   mov  ecx,[edx+ebx*4]    ; 42F
  mov   cl,[edx+eax*4+2]   ; 42H
   mov  al,[edi+PITCH*4+4] ; 44A
  add   ebp,ecx            ; 40I & 42G
   mov  bl,[esi+ebx*4+2]   ; 40H
  add   ebp,ebx            ; 40I
   mov  esi,BlockN.N8T44+32; 44B
  mov   bl,[edi+PITCH*4+6] ; 46A
   mov  edx,BlockN.N8T46+32; 46B
  lea   esi,[esi+eax*4]    ; 44C
   mov  al,[edi+PITCH*4+3] ; 44D
  lea   edx,[edx+ebx*4]    ; 46C
   mov  bl,[edi+PITCH*4+5] ; 44E & 46D
  mov   ecx,[esi+eax*4]    ; 44F
   mov  al,[edi+PITCH*4+7] ; 46E
  add   ebp,ecx            ; 44G
   mov  ecx,[edx+ebx*4]    ; 46F
  mov   cl,[edx+eax*4+2]   ; 46H
   mov  al,[edi+PITCH*5+1] ; 51A
  add   ebp,ecx            ; 44I & 46G
   mov  bl,[esi+ebx*4+2]   ; 44H
  add   ebp,ebx            ; 44I
   mov  esi,BlockN.N8T51+32; 51B
  mov   bl,[edi+PITCH*5+3] ; 53A
   mov  edx,BlockN.N8T53+32; 53B
  lea   esi,[esi+eax*4]    ; 51C
   mov  al,[edi+PITCH*5+0] ; 51D
  lea   edx,[edx+ebx*4]    ; 53C
   mov  bl,[edi+PITCH*5+2] ; 51E & 53D
  mov   ecx,[esi+eax*4]    ; 51F
   mov  al,[edi+PITCH*5+4] ; 53E
  add   ebp,ecx            ; 51G
   mov  ecx,[edx+ebx*4]    ; 53F
  mov   cl,[edx+eax*4+2]   ; 53H
   mov  al,[edi+PITCH*5+5] ; 55A
  add   ebp,ecx            ; 51I & 53G
   mov  bl,[esi+ebx*4+2]   ; 51H
  add   ebp,ebx            ; 51I
   mov  esi,BlockN.N8T55+32; 55B
  mov   bl,[edi+PITCH*5+7] ; 57A
   mov  edx,BlockN.N8T57+32; 57B
  lea   esi,[esi+eax*4]    ; 55C
   mov  al,[edi+PITCH*5+4] ; 55D
  lea   edx,[edx+ebx*4]    ; 57C
   mov  bl,[edi+PITCH*5+6] ; 55E & 57D
  mov   ecx,[esi+eax*4]    ; 55F
   mov  al,[edi+PITCH*5+8] ; 57E
  add   ebp,ecx            ; 55G
   mov  ecx,[edx+ebx*4]    ; 57F
  mov   cl,[edx+eax*4+2]   ; 57H
   mov  al,[edi+PITCH*6+0] ; 60A
  add   ebp,ecx            ; 55I & 57G
   mov  bl,[esi+ebx*4+2]   ; 55H
  add   ebp,ebx            ; 55I
   mov  esi,BlockN.N8T60+32; 60B
  mov   bl,[edi+PITCH*6+2] ; 62A
   mov  edx,BlockN.N8T62+32; 62B
  lea   esi,[esi+eax*4]    ; 60C
   mov  al,[edi+PITCH*6-1] ; 60D
  lea   edx,[edx+ebx*4]    ; 62C
   mov  bl,[edi+PITCH*6+1] ; 60E & 62D
  mov   ecx,[esi+eax*4]    ; 60F
   mov  al,[edi+PITCH*6+3] ; 62E
  add   ebp,ecx            ; 60G
   mov  ecx,[edx+ebx*4]    ; 62F
  mov   cl,[edx+eax*4+2]   ; 62H
   mov  al,[edi+PITCH*6+4] ; 64A
  add   ebp,ecx            ; 60I & 62G
   mov  bl,[esi+ebx*4+2]   ; 60H
  add   ebp,ebx            ; 60I
   mov  esi,BlockN.N8T64+32; 64B
  mov   bl,[edi+PITCH*6+6] ; 66A
   mov  edx,BlockN.N8T66+32; 66B
  lea   esi,[esi+eax*4]    ; 64C
   mov  al,[edi+PITCH*6+3] ; 64D
  lea   edx,[edx+ebx*4]    ; 66C
   mov  bl,[edi+PITCH*6+5] ; 64E & 66D
  mov   ecx,[esi+eax*4]    ; 64F
   mov  al,[edi+PITCH*6+7] ; 66E
  add   ebp,ecx            ; 64G
   mov  ecx,[edx+ebx*4]    ; 66F
  mov   cl,[edx+eax*4+2]   ; 66H
   mov  al,[edi+PITCH*7+1] ; 71A
  add   ebp,ecx            ; 64I & 66G
   mov  bl,[esi+ebx*4+2]   ; 64H
  add   ebp,ebx            ; 64I
   mov  esi,BlockN.N8T71+32; 71B
  mov   bl,[edi+PITCH*7+3] ; 73A
   mov  edx,BlockN.N8T73+32; 73B
  lea   esi,[esi+eax*4]    ; 71C
   mov  al,[edi+PITCH*7+0] ; 71D
  lea   edx,[edx+ebx*4]    ; 73C
   mov  bl,[edi+PITCH*7+2] ; 71E & 73D
  mov   ecx,[esi+eax*4]    ; 71F
   mov  al,[edi+PITCH*7+4] ; 73E
  add   ebp,ecx            ; 71G
   mov  ecx,[edx+ebx*4]    ; 73F
  mov   cl,[edx+eax*4+2]   ; 73H
   mov  al,[edi+PITCH*7+5] ; 75A
  add   ebp,ecx            ; 71I & 73G
   mov  bl,[esi+ebx*4+2]   ; 71H
  add   ebp,ebx            ; 71I
   mov  esi,BlockN.N8T75+32; 75B
  mov   bl,[edi+PITCH*7+7] ; 77A
   mov  edx,BlockN.N8T77+32; 77B
  lea   esi,[esi+eax*4]    ; 75C
   mov  al,[edi+PITCH*7+4] ; 75D
  lea   edx,[edx+ebx*4]    ; 77C
   mov  bl,[edi+PITCH*7+6] ; 75E & 77D
  mov   ecx,[esi+eax*4]    ; 75F
   mov  al,[edi+PITCH*7+8] ; 77E
  add   ebp,ecx            ; 75G
   mov  ecx,[edx+ebx*4]    ; 77F
  mov   cl,[edx+eax*4+2]   ; 77H
   add  esp,BlockLen
  add   ecx,ebp            ; 75I & 77G
   mov  bl,[esi+ebx*4+2]   ; 75H
  add   ebx,ecx            ; 75I
   mov  edi,BlockN.AddrCentralPoint+32 ; Get address of next ref1 block.
  shr   ecx,16                         ; Extract SWD for ref1.
   and  ebx,00000FFFFH                 ; Extract SWD for ref2.
  mov   BlockNM1.Ref1InterSWD+32,ecx   ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,ebx   ; Store SWD for ref2.
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelHorzLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret


DoSWDHalfPelVertLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel up.  Ref2 is .5 down.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelVertLoop:

  mov   al,[edi]
   mov  esi,BlockN.N8T00+32
  mov   bl,[edi+2*PITCH]
   mov  edx,BlockN.N8T20+32
  lea   esi,[esi+eax*4]
   mov  al,[edi-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T40+32
  mov   bl,[edi+6*PITCH]
   mov  edx,BlockN.N8T60+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T11+32
  mov   bl,[edi+1+3*PITCH]
   mov  edx,BlockN.N8T31+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T51+32
  mov   bl,[edi+1+7*PITCH]
   mov  edx,BlockN.N8T71+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T02+32
  mov   bl,[edi+2+2*PITCH]
   mov  edx,BlockN.N8T22+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T42+32
  mov   bl,[edi+2+6*PITCH]
   mov  edx,BlockN.N8T62+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T13+32
  mov   bl,[edi+3+3*PITCH]
   mov  edx,BlockN.N8T33+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T53+32
  mov   bl,[edi+3+7*PITCH]
   mov  edx,BlockN.N8T73+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T04+32
  mov   bl,[edi+4+2*PITCH]
   mov  edx,BlockN.N8T24+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T44+32
  mov   bl,[edi+4+6*PITCH]
   mov  edx,BlockN.N8T64+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T15+32
  mov   bl,[edi+5+3*PITCH]
   mov  edx,BlockN.N8T35+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T55+32
  mov   bl,[edi+5+7*PITCH]
   mov  edx,BlockN.N8T75+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T06+32
  mov   bl,[edi+6+2*PITCH]
   mov  edx,BlockN.N8T26+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T46+32
  mov   bl,[edi+6+6*PITCH]
   mov  edx,BlockN.N8T66+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T17+32
  mov   bl,[edi+7+3*PITCH]
   mov  edx,BlockN.N8T37+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T57+32
  mov   bl,[edi+7+7*PITCH]
   mov  edx,BlockN.N8T77+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   add  esp,BlockLen
  add   ecx,ebp
   mov  bl,[esi+ebx*4+2]
  add   ebx,ecx
   mov  edi,BlockN.AddrCentralPoint+32
  shr   ecx,16
   and  ebx,00000FFFFH
  mov   BlockNM1.Ref1InterSWD+32,ecx
   mov  BlockNM1.Ref2InterSWD+32,ebx
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelVertLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret

ENDIF ; H263


; Performance for common macroblocks:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;  1412 clocks:  6-level search for best SWD.
;    16 clocks:  record best fit.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  2913 clocks total
;
; Performance for macroblocks in which 0-motion vector is "good enough":
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    16 clocks:  record best fit.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  1559 clocks total
;
; Performance for macroblocks marked as intrablock by decree of caller:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;    20 clocks:  classify (just weight the SWD for # of match points).
;  ----
;   476 clocks total
;
; 160*120 performance, generously estimated (assuming lots of motion):
;
;  2913 * 80 = 233000 clocks for luma.
;  2913 * 12 =  35000 clocks for chroma.
;              268000 clocks per frame * 15 = 4,020,000 clocks/sec.
;
; 160*120 performance, assuming typical motion:
;
;  2913 * 40 + 1559 * 40 = 179000 clocks for luma.
;  2913 *  8 + 1559 *  4 =  30000 clocks for chroma.
;                          209000 clocks per frame * 15 = 3,135,000 clocks/sec.
;
; Add 10-20% to allow for initial cache-filling, and unfortunate cases where
; cache-filling policy preempts areas of the tables that are not locally "hot",
; instead of preempting macroblocks upon which the processing was just finished.


Done:

  mov   eax,IntraSWDTotal
  mov   ebx,IntraSWDBlocks
  mov   ecx,InterSWDTotal
  mov   edx,InterSWDBlocks
  mov   esp,StashESP
  mov   edi,[esp+IntraSWDTotal_arg]
  mov   [edi],eax
  mov   edi,[esp+IntraSWDBlocks_arg]
  mov   [edi],ebx
  mov   edi,[esp+InterSWDTotal_arg]
  mov   [edi],ecx
  mov   edi,[esp+InterSWDBlocks_arg]
  mov   [edi],edx
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn


MOTIONESTIMATION endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e35vlc.asm ===
; ++ ========================================================================
;
;              INTEL CORPORATION PROPRIETARY INFORMATION
;
;       This software is supplied under the terms of a license
;       agreement or nondisclosure agreement with Intel Corporation
;       and may not be copied or disclosed except in accordance
;       with the terms of that agreement.
;
;       Copyright (c) 1995 Intel Corporation.  All Rights Reserved.
;
;    ========================================================================
;
;       Declaration:
;               void MBEncodeVLC (
;                       char *                  pMBRVS_Luma,
;                       char *                  pMBRVS_Chroma,
;                       unsigned int            CodedBlkPattern,
;                       unsigned char **        pBitStream,
;                       unsigned char *         pBitOffset,
;                       int                     IntraFlag,
;                       int                     MMxFlag
;               );
;
;       Description:
;               This function encodes a macroblock's worth of RLE values.
;               The RLE values are provided to me in a list of triplets
;               where the triplets consist of RUN, LEVEL, and SIGN, where
;               each element is a BYTE.
;
;       Register Usage:
;               ESI -- RLE stream cursor
;               EDI -- Bit stream cursor
;               EDX -- Bit stream offset
;
; $Header:   S:\h26x\src\enc\e35vlc.asv   1.6   11 Oct 1996 16:44:22   BECHOLS  $
;
; $Log:   S:\h26x\src\enc\e35vlc.asv  $
;// 
;//    Rev 1.6   11 Oct 1996 16:44:22   BECHOLS
;// Added a check, so that I won't choke on a zero level, even though
;// by rights the level should never be zero.
;// 
;//    Rev 1.5   05 Sep 1996 18:37:46   KLILLEVO
;// fixed bug which occured when value is zero after quantization
;// and run-length encoding
;// 
;//    Rev 1.4   15 Mar 1996 15:56:48   BECHOLS
;// 
;// Changed to support separate passes over the luma and chroma.
;// 
;//    Rev 1.3   03 Oct 1995 20:40:40   BECHOLS
;// 
;// Modified the code to reduce the code size to about .5K of cache and 
;// about 4K of data.  Added cache preloading, and write the VLC and sign
;// in one operation.  I believe I handle the clamping correctly.
;// 
;//    Rev 1.2   22 Sep 1995 18:31:04   BECHOLS
;// Added clamping for the positive values as well as the negative.
;// 
;//    Rev 1.1   14 Sep 1995 11:45:36   BECHOLS
;// I used WDIS.EXE to determine where I could get better performance.
;// The changes I made have improved the performance by 30%.
;
; -- ========================================================================
.486
.MODEL flat, c

; ++ ========================================================================
; Name mangling in C++ forces me to declare these tables in the ASM file
; and make them externally available to C++ as extern "C" ...
; -- ========================================================================
PUBLIC FLC_INTRADC
PUBLIC VLC_TCOEF_TBL
PUBLIC VLC_TCOEF_LAST_TBL

; ++ ========================================================================
; These constants were variable in the C version, but will actually never
; change being set by the H263 specification.
; -- ========================================================================
TCOEF_ESCAPE_FIELDLEN   EQU     7
TCOEF_ESCAPE_FIELDVAL   EQU     3
TCOEF_RUN_FIELDLEN      EQU     6
TCOEF_LEVEL_FIELDLEN    EQU     8

; ++ ========================================================================
; RLS (Run Level Sign) Structure is defined just to make the code a little
; more readable.
; -- ========================================================================
RLS     STRUCT
        Run     BYTE    ?
        Level   BYTE    ?
        Sign    BYTE    ?
RLS     ENDS

; ++ ========================================================================
; The PutBits macro puts a Variable Length Code into the bit stream.  It
; expects registers to contain the correct information as follows.
;       EDX -- Field Length
;       EAX -- Field Value
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutBits MACRO
        push    esi
        push    ecx
        xor     ecx, ecx
        mov     cl,  BYTE PTR [ebx]     ;; Get the Bit Offset.
        add     edx, ecx                ;;  Add it to the field length.
        mov     ecx, 32                 ;; EAX <<= (32 - (EDX + [EBX]))
        sub     ecx, edx                ;;  EDX = Field Length + Bit Offset.
        mov     esi, DWORD PTR [edi]    ;; Set ESI to Bit Stream.
        shl     eax, cl                 ;;
        bswap   eax                     ;; Swaps byte order in EAX.
        mov     ecx, DWORD PTR [esi]    ;; Preload cache.
        or      DWORD PTR [esi], eax    ;; Write value to bit stream.
        mov     eax, edx
        shr     eax, 3
        add     [edi], eax              ;; Update Bit Stream Pointer.
        and     edx, 000000007h
        mov     BYTE PTR [ebx], dl      ;; Update Bit Stream Offset.
        pop     ecx
        pop     esi
ENDM

; ++ ========================================================================
; PutRunLev macro writes the ESCAPE code and Last bit, then the RUN length,
; and then the LEVEL into the stream.  It assumes the following registers.
;       ECX -- Last Bit
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutRunLev MACRO
        LOCAL   NoClamp, NotNegative, NotZero
        mov     eax, TCOEF_ESCAPE_FIELDVAL
        mov     edx, TCOEF_ESCAPE_FIELDLEN
        PutBits                         ;; Write ESCAPE.
        mov     eax, ecx                ;; Retrieve Last Bit.
        mov     edx, 1
        PutBits
        mov     al, (RLS PTR [esi]).Run ;; Retrieve Run Length.
        mov     edx, TCOEF_RUN_FIELDLEN
        PutBits                         ;; Write RUN length.
        mov     al, (RLS PTR [esi]).Level ;; Retrieve Level.
        sub     eax, 1  ; in case it is zero we want it to be modified to 127
NotZero:
        cmp     eax, 127
        jb      NoClamp
        mov     eax, 126
NoClamp:
        add     eax, 1
        cmp     (RLS PTR [esi]).Sign, 0FFh
        jne     NotNegative
        mov     ecx, eax
        xor     eax, eax
        sub     eax, ecx
        and     eax, 0000000FFh         
NotNegative:
        mov     edx, TCOEF_LEVEL_FIELDLEN
        PutBits                         ;; Write LEVEL.
ENDM

; ++ ========================================================================
; PutVLC macro writes the Variable Length Code and its sign bit into the
; bit stream.  It expects the registers to be set up as follows.
;       EDX -- VLC Code Length
;       EAX -- VLC Bit Code
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutVLC MACRO
        mov     cl, (RLS PTR [esi]).Sign ;; Get sign bit which is [ 0 | -1 ]
        and     ecx, 000000001h         ;;  Mask off all but the low bit
        or      eax, ecx                ;;  and place it in VLC.
        PutBits                         ;; Write the signed VLC into stream.
ENDM

; ++ ========================================================================
; CheckLast macro determines whether this is last RLE code for the block.
; It assumes the following register.
;       ESI -- Pointer to RLE stream.
; It sets the following registers for subsequent use.
;       EAX -- Last bit.
;       ECX -- Max Table Level.
;       EDX -- Pointer to the appropriate VLC table.
; -- ========================================================================
CheckLast MACRO
        LOCAL   IsLast, CheckDone
        cmp     (RLS PTR [esi + 3]).Run, 0FFh ;; Check if the last RLE.
        je      IsLast
        xor     eax, eax                ;; If not then clear last bit,
        lea     edx, VLC_TCOEF_TBL      ;;  and point to proper table,
        mov     ecx, 12                 ;;  and set max table level.
        jmp     CheckDone
IsLast:
        mov     eax, 1                  ;; Otherwise set the last bit,
        lea     edx, VLC_TCOEF_LAST_TBL ;;  and point to last coef table,
        mov     ecx, 3                  ;;  and set the max table level.
CheckDone:
ENDM

; ++ ========================================================================
; IndexTable macro determines the pointer value as indexed into the table
; of coefficients.  It assumes the following registers.
;       ESI -- Pointer to RLE stream.
;       EAX -- The level which is one (1) based.
;       EDX -- The base pointer to the coefficient array.
; The EDX register is modified, EAX is trashed, and ECX is preserved
; -- ========================================================================
IndexTable MACRO
        push    ecx                     ;; Save the last bit
        dec     eax                     ;; Zero base the level value.
        shl     eax, 6                  ;; EAX is # of run values per level
        mov     ecx, eax                ;;  added to the run value.
        xor     eax, eax                ;;
        mov     al, (RLS PTR [esi]).Run ;;
        add     eax, ecx                ;;
        shl     eax, 2                  ;; The array has DWORDs (4 bytes)
        add     edx, eax                ;; Add the index to the array.
        pop     ecx                     ;; Restore the last bit.
ENDM

; ++ ========================================================================
; WriteOneCode macro takes one RLE code from the triplet list and VLC
; encodes it, and writes it to the bit stream.  It expects that the
; following registers will be set as shown.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX , ECX, and EAX
; are trashed.
; -- ========================================================================
WriteOneCode MACRO
        LOCAL   RunLevel, VLCDone, NotZero
        CheckLast
        push    eax                     ;; Save last bit
        mov     al, (RLS PTR [esi]).Level ;; Get the level value and check
        test    al, al                  ;; The level should never be zero
        jnz     NotZero                 ;;  but this fixes the unlikely
        mov     al, 127                 ;;  event.
NotZero:
        cmp     eax, ecx                ;;  it against the max table level.
        pop     ecx                     ;; Restore the last bit.
        jg      RunLevel                ;; 
        IndexTable                      ;; Sets EDX to table index
        mov     eax, DWORD PTR [edx]    ;; Get the VLC code from table.
        cmp     eax, 00000FFFFh         ;; Is this an escape indicator?
        je      RunLevel                ;; If so then do RLE processing.
        mov     edx, eax
        and     eax, 00000FFFFh
        shr     edx, 16
        PutVLC                          ;; Write the Variable code.
        jmp     VLCDone
RunLevel:
        PutRunLev                       ;; Write the ESC RUN LEV stuff.
VLCDone:
ENDM

; ++ ========================================================================
; WriteIntraDC macro writes the Intra DC value into the bit stream.  It
; expects the following registers to be set correctly.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified, ESI is updated, and EDX and
; EAX are preserved.
; -- ========================================================================
WriteIntraDC MACRO
        push    eax
        push    edx
        lea     edx, FLC_INTRADC        ;; Form index into Intra DC
        mov     al, (RLS PTR [esi]).Level ;;  array.
        add     edx, eax                ;;
        mov     al, BYTE PTR [edx]      ;; Get Intra DC value.
        mov     edx, 8                  ;; Set size of write to 8 bits.
        PutBits                         ;; Write the Intra DC value.
        add     esi, SIZEOF RLS         ;; Point to next triplet.
        pop     edx
        pop     eax
ENDM

; ++ ========================================================================
; WriteOneBlock macro writes all the coefficients for a single block of the
; macroblock.  It assumes that the registers will be set as follows.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
;       EDX -- Coded Block Pattern (CBP)
;       ECX -- Intra/Inter Flag
;       EAX -- CBP Mask.
; The contents of EDI and EBX are modified and EDX , ECX, and EAX are
; preserved.
; -- ========================================================================
WriteOneBlock MACRO
        LOCAL   NotIntra, WriteDone, WriteCodes, WriteExit
        push    eax
        push    edx
        cmp     ecx, 1                  ;; Check to see if this is an 
        jne     NotIntra                ;;  Intra block, and if so,
        WriteIntraDC                    ;;  write the DC value.
NotIntra:
        and     eax, edx                ;; Check CBP to see if done.
        jz      WriteExit
WriteCodes:
        mov     al, BYTE PTR [esi]      ;; Get the RUN value.
        cmp     eax, 0000000FFh         ;; Check to see if done.
        je      WriteDone
        WriteOneCode                    ;; Continue to write the codes
        add     esi, SIZEOF RLS         ;;  in this block until done.
        jmp     WriteCodes              ;;
WriteDone:
        add     esi, SIZEOF RLS         ;; Bump to next block.
WriteExit:
        pop     edx
        pop     eax
ENDM

.DATA

FLC_INTRADC             DB      256 DUP (?)
VLC_TCOEF_TBL           DD      (64*12) DUP (?)
VLC_TCOEF_LAST_TBL      DD      (64*3) DUP (?)

.CODE

; ++ ========================================================================
; This is the C function call entry point.  This function variable length
; encodes an entire macroblock, one block at a time.
; -- ========================================================================
MBEncodeVLC     PROC PUBLIC USES edi esi ebx ecx, pMBRVS_Luma:DWORD, pMBRVS_Chroma:DWORD, CodedBlockPattern:DWORD, ppBitStream:DWORD, pBitOffset:DWORD, IntraFlag:DWORD, MMxFlag:DWORD

        mov     esi, pMBRVS_Luma
        mov     edi, ppBitStream
        mov     ebx, pBitOffset
        mov     edx, CodedBlockPattern
        mov     esi, [esi]
        mov     eax, 1                  ; CBP Mask.
LumaWriteLoop:
        test    eax, 000000010h         ; When EAX bit shifts to this
        jnz     LumaBlocksDone          ;  position, we are done with Luma.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     LumaWriteLoop
LumaBlocksDone:
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      ChromaWriteLoop
        mov     ecx, pMBRVS_Luma
        mov     [ecx],esi
        mov     ecx, pMBRVS_Chroma
        mov     esi,[ecx]
ChromaWriteLoop:
        test    eax, 000000040h         ; When EAX bit shifts to this
        jnz     ChromaBlocksDone          ;  position, we are done.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     ChromaWriteLoop
ChromaBlocksDone:
        mov     eax, pMBRVS_Chroma
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      MacroBlockDone
        mov     [eax],esi
MacroBlockDone:

        ret

MBEncodeVLC     ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ex5qrle.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\ex5qrle.asv   1.2   06 Feb 1996 09:12:10   KLILLEVO  $
;// $Log:   S:\h26x\src\enc\ex5qrle.asv  $
;// 
;//    Rev 1.2   06 Feb 1996 09:12:10   KLILLEVO
;// now quantizes INTER blocks as TMN5 specifies and simulator does
;// 
;//    Rev 1.1   27 Dec 1995 15:32:48   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

; QuantRLE -- This function performs quantization on a block of coefficients
;             and produces (run,level,sign) triples. (These triples are VLC by 
;             another routine.)  'run' is unsigned byte integer, 'level' is 
;             unsigned byte integer, and 'sign' is a signed byte integer with 
;             a value of either 0  or -1.
; Arguments:
;   CoeffStr: Starting Address of coefficient stream
;   CodeStr:  Starting address of code stream; i.e. starting address for code 
;             stream triples
; Returns:
; Dependencies:
;   The order of coefficient storage comes from e3dctc.inc file.  These coeff
;   appear as CxxCxx in this file.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

.xlist
include locals.inc
include memmodel.inc
include e3dctc.inc
.list

; READ-ONLY TABLE
.CONST

; QP can range from 1 to 31; but we build the following table for QP from 0 to
; 31 so that we can use indexing without subtracting 1 from QP or subtracting
; 8 from the displacement term.  In each pair, the first value is "2^32/2*QP"
; or "2^31/QP".  For some QP values, e.g. QP = 3, "2^31/QP" is an infinite
; bit string.  We check the most significant bit of the bit string that we are
; throwing away, if it is 1 then we increment the value.  For eaxmple,
; 2^31/3 is 2AAAAAAA.AAAAAA... but we use 2AAAAAAB as the table value.

ALIGN 8                       ; so that each pair is in a cache line

RecipINTER2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTERSubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP - QP/2, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FBH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07F0H                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F6H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F4H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F1H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07EFH                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07ECH                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EAH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07E7H                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07E5H                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E2H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E0H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07DDH                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07DBH                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07D8H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07D6H                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07D3H                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07D1H                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07CEH                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07CCH                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07C9H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07C7H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07C4H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07C2H                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07BFH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07BDH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07BAH                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07B8H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07B5H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07B3H                 ; QP = 31
QuantINTERSubTerm = RecipINTER2QP + 4

RecipINTRA2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTRASubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FCH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07FAH                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F8H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F6H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F4H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07F2H                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07F0H                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EEH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07ECH                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07EAH                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E8H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E6H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07E4H                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07E2H                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07E0H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07DEH                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07DCH                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07DAH                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07D8H                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07D6H                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07D4H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07D2H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07D0H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07CEH                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07CCH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07CAH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07C8H                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07C6H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07C4H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07C2H                 ; QP = 31
QuantINTRASubTerm = RecipINTRA2QP + 4

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

QUANTRLE  proc C ACoeffStr: DWORD, ACodeStr:DWORD, AQP:DWORD, AIntraFlag:DWORD

LocalFrameSize = 8
RegisterStorageSize = 16
SIGNHIGH = 1
SIGNLOW  = 17
IsINTRA  = 1
;;;;; Arguments:
ACoeffStr_arg = LocalFrameSize + RegisterStorageSize +  4
ACodeStr_arg  = LocalFrameSize + RegisterStorageSize +  8
AQP_arg       = LocalFrameSize + RegisterStorageSize + 12
AIntraFlag_arg= LocalFrameSize + RegisterStorageSize + 16
;;;;; Locals (on local stack frame)
QST	EQU 0
R2P	EQU 4

  push  esi
   push edi
  push  ebp
   push ebx
  sub   esp, LocalFrameSize

   mov cl,  63                       ; Initialize run-length (64 - 1)

  mov  ebx, PD [esp+AQP_arg]         ; copy parameters
   mov  esi, PD [esp+ACoeffStr_arg]  
  mov edx, RecipINTRA2QP[ebx*8]      ; RecipINTRA2QP = RecipINTER2QP
   mov edi, PD [esp+ACodeStr_arg]
  mov [esp + R2P], edx		     ; store Recip2QP[QP] as local variable
   mov al,  PB [esp+AIntraFlag_arg]
  mov  edx, PD [esi+C00C02]          ; First coeff
   test al,  IsINTRA
  je  QuantINTERC00

  
;
; OPTIMIZATIONS:
;   The usual code to compute absolute value has been enhanced to subtract the 
;   bias without using extra instructions or cycles.  Division is achieved by
;   multiplying with the reciprocal value.  High AC coefficients that will 
;   almost always be 0 are moved out-of-line towards the end of the routine.
;   This reduces the execution time if the conditional branch is not in the BTB;
;   it also reduces L1 footprint.
;   There is one more optimization I want to implement: pair instructions such
;   that the conditional branch instruction is executed in the U pipe.  The 
;   mispredicted branch penalty for U pipe is 3 and for V pipe is 4.  Since the 
;   low AC branches will frequently be mispredicted, this is a worthwhile 
;   optimization.
;
; esi -- base addr of coefficients; the order expected is the same as produced 
;        by Fast DCT
; edi -- RLE stream cursor
; ebx -- QP
; ecx -- run value indicator
; edx -- normally used to load coefficients
; eax,ebp -- scratch registers
;
QuantINTRAC00:
  mov edx, QuantINTRASubTerm[ebx*8] ; Fetch QuantSubTerm for INTRA
   mov  eax, PD [esi+C00C02]
  mov [esp + QST], edx		    ; Store QuantSubTerm as local variable
   mov PB [edi], 0H                 ; Run-length
  sar  eax, 23                      ; 8-bit signed INTRA-DC value
   mov edx, PD [esi+C01C03]         ; Pre-load next coefficient
  mov  PB [edi+2], ah               ; sign of DC 
   jnz @f
  mov  al, 1
@@:
  mov  PB [edi+1], al               ; DC
   add edi, 3
  mov  cl, 62                       ; 64 - Index (2 for C01)
   jmp QuantC01
QuantINTERC00:
  mov   eax, QuantINTERSubTerm[ebx*8]	; Fetch QuantSubTerm for INTER
   sal  edx, SIGNHIGH                   ; C == sign of the coefficient
  sbb  ebp, ebp                         ; -1 if coeff is negative else 0
   mov   [esp + QST], eax							; store QuantSubTerm as local variable
                                    
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C01C03]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC01
  lea   eax, [eax+2*ebx]
   mov  cl, 62                      ; Initialize run length counter
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], 0H                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C01C03]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   add  edi, 3                      ; Increment output pointer
QuantC01:
  sal   edx, SIGNHIGH               ; C == sign of the coefficient
   mov  eax, [esp + QST]    ; 0 for INTRA, QP for INTER
  sbb   ebp, ebp                    ; -1 if coeff is negative else 0
   ;                                ; 
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C10C12]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC10
  lea   eax, [eax+2*ebx]
   sub  cl, 62                      ; compute run-length
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], cl                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C10C12]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   mov  cl, 61                      ; Initialize run length counter
  add   edi, 3                      ; Increment output pointer
   mov  eax, eax                    ; To keep pairing happy
QuantC10:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC20
  lea   eax, [eax+2*ebx]
   sub  cl, 61                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 60                     
  add   edi, 3
   mov  eax, eax
QuantC20:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC11
  lea   eax, [eax+2*ebx]
   sub  cl, 60                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C11C13]       
  mov   PB [edi+2], al
   mov  cl, 59                      ;
  add   edi, 3
   mov  eax, eax
QuantC11:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C00C02]       
  sub   eax, ebp
   jl   QuantC02
  lea   eax, [eax+2*ebx]
   sub  cl, 59                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C00C02]       
  mov   PB [edi+2], al
   mov  cl, 58                     
  add   edi, 3
   mov  eax, eax
QuantC02:
  sal   edx, SIGNLOW
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C01C03]       
  sub   eax, ebp
   jl   QuantC03
  lea   eax, [eax+2*ebx]
   sub  cl, 58                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 57
  mov   edx, PD [esi+C01C03]
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC03:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C10C12]       
  sub   eax, ebp
   jl   QuantC12
  lea   eax, [eax+2*ebx]
   sub  cl, 57                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 56                    
  mov   edx, PD [esi+C10C12]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC12:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC21
  lea   eax, [eax+2*ebx]
   sub  cl, 56                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 55                    
  mov   edx, PD [esi+C21C23]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC21:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC30
  lea   eax, [eax+2*ebx]
   sub  cl, 55                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C30C32]       
  mov   PB [edi+2], al
   mov  cl, 54                    
  add   edi, 3
   mov  eax, eax
QuantC30:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC40
  lea   eax, [eax+2*ebx]
   sub  cl, 54                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 53                    
  add   edi, 3
   mov  eax, eax
QuantC40:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC31
  lea   eax, [eax+2*ebx]
   sub  cl, 53                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C31C33]       
  mov   PB [edi+2], al
   mov  cl, 52                    
  add   edi, 3
   mov  eax, eax
QuantC31:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC22
  lea   eax, [eax+2*ebx]
   sub  cl, 52                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 51                    
  add   edi, 3
   mov  eax, eax
QuantC22:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC13
  lea   eax, [eax+2*ebx]
   sub  cl, 51                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 50                    
  mov   edx, PD [esi+C11C13]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC13:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC04
  lea   eax, [eax+2*ebx]
   sub  cl, 50                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 49                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC04:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC05
  lea   eax, [eax+2*ebx]
   sub  cl, 49                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C07C05]       
  mov   PB [edi+2], al
   mov  cl, 48                    
  add   edi, 3
   mov  eax, eax
QuantC05:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC14
  lea   eax, [eax+2*ebx]
   sub  cl, 48                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 47                    
  mov   edx, PD [esi+C14C16]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC14:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC23
  lea   eax, [eax+2*ebx]
   sub  cl, 47                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C21C23]       
  mov   PB [edi+2], al
   mov  cl, 46                    
  add   edi, 3
   mov  eax, eax
QuantC23:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC32
  lea   eax, [eax+2*ebx]
   sub  cl, 46                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 45                    
  mov   edx, PD [esi+C30C32]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC32:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC41
  lea   eax, [eax+2*ebx]
   sub  cl, 45                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 44                    
  mov   edx, PD [esi+C41C43]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC41:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC50
  lea   eax, [eax+2*ebx]
   sub  cl, 44                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C50C52]       
  mov   PB [edi+2], al
   mov  cl, 43                    
  add   edi, 3
   mov  eax, eax
QuantC50:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jl   QuantC60
  lea   eax, [eax+2*ebx]
   sub  cl, 43                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 42                    
  add   edi, 3 
   mov  eax, eax
QuantC60:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC51
  lea   eax, [eax+2*ebx]
   sub  cl, 42                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C51C53]       
  mov   PB [edi+2], al
   mov  cl, 41                    
  add   edi, 3 
   mov  eax, eax
QuantC51:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC42
  lea   eax, [eax+2*ebx]
   sub  cl, 41                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 40                    
  add   edi, 3 
   mov  eax, eax
QuantC42:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC33
  lea   eax, [eax+2*ebx]
   sub  cl, 40                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 39                    
  mov   edx, PD [esi+C31C33]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC33:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC24
  lea   eax, [eax+2*ebx]
   sub  cl, 39                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 38                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC24:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC15
  lea   eax, [eax+2*ebx]
   sub  cl, 38                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C17C15]       
  mov   PB [edi+2], al
   mov  cl, 37                    
  add   edi, 3  
   mov  eax, eax
QuantC15:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC06
  lea   eax, [eax+2*ebx]
   sub  cl, 37                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 36                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC06:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC07
  lea   eax, [eax+2*ebx]
   sub  cl, 36                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 35                    
  mov   edx, PD [esi+C07C05]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3 
QuantC07:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC16
  lea   eax, [eax+2*ebx]
   sub  cl, 35                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C14C16]       
  mov   PB [edi+2], al
   mov  cl, 34                    
  add   edi, 3             
   mov  eax, eax
QuantC16:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jl   QuantC25
  lea   eax, [eax+2*ebx]
   sub  cl, 34                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 33                    
  mov   edx, PD [esi+C27C25]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC25:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jl   QuantC34
  lea   eax, [eax+2*ebx]
   sub  cl, 33                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 32                    
  mov   edx, PD [esi+C34C36]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC34:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC43
  lea   eax, [eax+2*ebx]
   sub  cl, 32                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C41C43]       
  mov   PB [edi+2], al
   mov  cl, 31                    
  add   edi, 3                    
   mov  eax, eax
QuantC43:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC52
  lea   eax, [eax+2*ebx]
   sub  cl, 31                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 30                    
  mov   edx, PD [esi+C50C52]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC52:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jl   QuantC61
  lea   eax, [eax+2*ebx]
   sub  cl, 30                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 29                    
  mov   edx, PD [esi+C61C63]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC61:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jge  QuantNZC61
QuantC70:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jge  QuantNZC70
QuantC71:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jge  QuantNZC71
QuantC62:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC53
  lea   eax, [eax+2*ebx]
   sub  cl, 26                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 25                    
  mov   edx, PD [esi+C51C53]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC53:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC44
  lea   eax, [eax+2*ebx]
   sub  cl, 25                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 24                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC44:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jge  QuantNZC44
QuantC35:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC26
  lea   eax, [eax+2*ebx]
   sub  cl, 23                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 22                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC26:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC17
  lea   eax, [eax+2*ebx]
   sub  cl, 22                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 21                    
  mov   edx, PD [esi+C17C15]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC17:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jge  QuantNZC17
QuantC27:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jge  QuantNZC27
QuantC36:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jl   QuantC45
  lea   eax, [eax+2*ebx]
   sub  cl, 19                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 18                    
  mov   edx, PD [esi+C47C45]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC45:
  sal   edx, SIGNLOW                      
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jl   QuantC54
  lea   eax, [eax+2*ebx]
   sub  cl, 18                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 17                    
  mov   edx, PD [esi+C54C56]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC54:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jge  QuantNZC54
QuantC63:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jl   QuantC72
  lea   eax, [eax+2*ebx]
   sub  cl, 16                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 15                    
  mov   edx, PD [esi+C70C72]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC72:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jl   QuantC73
  lea   eax, [eax+2*ebx]
   sub  cl, 15                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 14                    
  mov   edx, PD [esi+C71C73]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC73:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC64
  lea   eax, [eax+2*ebx]
   sub  cl, 14                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 13                    
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC64:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jge  QuantNZC64
QuantC55:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC46
  lea   eax, [eax+2*ebx]
   sub  cl, 12                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 11                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC46:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jl   QuantC37
  lea   eax, [eax+2*ebx]
   sub  cl, 11                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 10                    
  mov   edx, PD [esi+C37C35]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC37:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jge  QuantNZC37
QuantC47:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jge  QuantNZC47
QuantC56:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jl   QuantC65
  lea   eax, [eax+2*ebx]
   sub  cl, 8                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 7                     
  mov   edx, PD [esi+C67C65]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC65:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jl   QuantC74
  lea   eax, [eax+2*ebx]
   sub  cl, 7                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 6                     
  mov   edx, PD [esi+C74C76]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC74:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jge  QuantNZC74
QuantC75:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC66
  lea   eax, [eax+2*ebx]
   sub  cl, 5                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 4                     
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC66:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jl   QuantC57
  lea   eax, [eax+2*ebx]
   sub  cl, 4                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 3                     
  mov   edx, PD [esi+C57C55]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC57:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jge  QuantNZC57
QuantC67:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jge  QuantNZC67
QuantC76:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jl   QuantC77
  lea   eax, [eax+2*ebx]
   sub  cl, 1                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 0                     
  mov   edx, PD [esi+C77C75]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC77:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, edx                  
  sub   eax, ebp
   jge  QuantNZC77

; Quantization and RLE is done
QuantDone:
  mov   eax, edi                   ; Return value

  add   esp,LocalFrameSize
  pop   ebx
   pop  ebp
  pop   edi
   pop  esi
  rturn

QuantNZC61:
  lea   eax, [eax+2*ebx]
   sub  cl, 29                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C70C72]       
  mov   PB [edi+2], al
   mov  cl, 28                    
  add   edi, 3                    
   jmp  QuantC70
QuantNZC70:
  lea   eax, [eax+2*ebx]
   sub  cl, 28                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C71C73]       
  mov   PB [edi+2], al
   mov  cl, 27                    
  add   edi, 3                    
   jmp  QuantC71
QuantNZC71:
  lea   eax, [eax+2*ebx]
   sub  cl, 27                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 26                    
  add   edi, 3                    
   jmp  QuantC62
QuantNZC44:
  lea   eax, [eax+2*ebx]
   sub  cl, 24                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C37C35]       
  mov   PB [edi+2], al
   mov  cl, 23                    
  add   edi, 3                    
   jmp  QuantC35
QuantNZC17:
  lea   eax, [eax+2*ebx]
   sub  cl, 21                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C27C25]       
  mov   PB [edi+2], al
   mov  cl, 20                    
  add   edi, 3                    
   jmp  QuantC27
QuantNZC27:
  lea   eax, [eax+2*ebx]
   sub  cl, 20                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C34C36]       
  mov   PB [edi+2], al
   mov  cl, 19                    
  add   edi, 3                    
   jmp  QuantC36
QuantNZC54:
  lea   eax, [eax+2*ebx]
   sub  cl, 17                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C61C63]       
  mov   PB [edi+2], al
   mov  cl, 16                    
  add   edi, 3                    
   jmp  QuantC63
QuantNZC64:
  lea   eax, [eax+2*ebx]
   sub  cl, 13                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C57C55]       
  mov   PB [edi+2], al
   mov  cl, 12                    
  add   edi, 3                    
   jmp  QuantC55
QuantNZC37:
  lea   eax, [eax+2*ebx]
   sub  cl, 10                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C47C45]       
  mov   PB [edi+2], al
   mov  cl, 9                     
  add   edi, 3                    
   jmp  QuantC47
QuantNZC47:
  lea   eax, [eax+2*ebx]
   sub  cl, 9                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C54C56]       
  mov   PB [edi+2], al
   mov  cl, 8                     
  add   edi, 3                    
   jmp  QuantC56
QuantNZC74:
  lea   eax, [eax+2*ebx]
   sub  cl, 6                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C77C75]       
  mov   PB [edi+2], al
   mov  cl, 5                     
  add   edi, 3                    
   jmp  QuantC75
QuantNZC57:
  lea   eax, [eax+2*ebx]
   sub  cl, 3                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C67C65]       
  mov   PB [edi+2], al
   mov  cl, 2                     
  add   edi, 3                    
   jmp  QuantC67
QuantNZC67:
  lea   eax, [eax+2*ebx]
   sub  cl, 2                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C74C76]       
  mov   PB [edi+2], al
   mov  cl, 1                     
  add   edi, 3                    
   jmp  QuantC76
QuantNZC77:
  lea   eax, [eax+2*ebx]
   sub  cl, 0                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, edx                  
  mov   PB [edi+2], al  
  add   edi, 3                    
   jmp  QuantDone

QUANTRLE endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exmqrle.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;**  $Header:   R:\h26x\h26x\src\enc\exmqrle.asv   1.11   18 Oct 1996 16:57:20   BNICKERS  $
;**
;**  $Log:   R:\h26x\h26x\src\enc\exmqrle.asv  $
;// 
;//    Rev 1.11   18 Oct 1996 16:57:20   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.10   10 Oct 1996 16:42:32   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.9   22 Jul 1996 15:23:28   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.8   02 May 1996 12:00:50   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.7   10 Apr 1996 13:14:16   BNICKERS
;// No change.
;// 
;//    Rev 1.6   26 Mar 1996 12:00:26   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.5   20 Mar 1996 15:26:58   KLILLEVO
;// changed quantization to match IA quantization
;// 
;//    Rev 1.4   15 Mar 1996 15:52:06   BECHOLS
;// 
;// Completed Monolithic - Brian
;// 
;//    Rev 1.3   27 Feb 1996 08:28:04   KLILLEVO
;// now saves ebx in order not to crash in release build
;// 
;//    Rev 1.2   22 Feb 1996 18:38:38   BECHOLS
;// 
;// Rescaled the quantization constants, Intra DC scaling, and accounted
;// for the inter bias that frame differencing performs.
;// 
;//    Rev 1.1   25 Jan 1996 08:20:32   BECHOLS
;// Changed the zigzag path to match the output of the MMx Forward DCT.
;// 
;//    Rev 1.0   17 Oct 1995 13:35:10   AGUPTA2
;// Initial revision.
;** *************************************************************************
;*/

;/* MMXQuantRLE This function performs quantization on a block of coefficients
;**          and produces (run,level,sign) triples. (These triples are VLC by 
;**          another routine.)  'run' is unsigned byte integer, 'level' is 
;**          unsigned byte integer, and 'sign' is a signed byte integer with 
;**          a value of either 0  or -1.  Since 'level' is an unsigned byte 
;**          integer, it needs to be clamped, to the right range for AC coeff,
;**          outside this routine.
;** Arguments:
;**   CoeffStr: Starting Address of coefficient stream; each coeff is a
;**             signed 16-bit value and stored in an 8X8 matrix
;**   CodeStr:  Starting address of code stream; i.e. starting address for code 
;**             stream triples
;**   QP:       Quantizer value 1..31
;**   IntraFlag:Odd for INTRA and even for INTER
;** Returns:
;**   Ending code stream address
;** Dependencies:
;**   Clamping of 'level' must be done by the caller.   
;*/

.xlist
include e3inst.inc
include memmodel.inc
include iammx.inc
include exEDTQ.inc
include e3mbad.inc
.list

.CODE EDTQ
PUBLIC MMxQuantRLE

StackOffset TEXTEQU <8>
CONST_384   TEXTEQU <ebp>

MMxQuantRLE:

  lea         esi, Coeffs+128
   mov        edi, CodeStreamCursor
  mov         bl, StashBlockType
   mov        eax, -128
  cmp         bl, INTRA        
   mov        ebx, Coeffs+C00
  pxor        mm6, mm6                        ; clear mm6
   je         @f

  movdt       mm6,QPDiv2                      ; load mm6 with 4 copies of QP/2

@@:

; Register usage:
;  esi -- base addr of coefficients; the order expected is the same as produced 
;         by Fast DCT
;  edi -- RLE stream cursor
;  edx -- Reserved.  MacroBlockActionStream cursor, perturbed by block offsets.
;  eax -- Loop induction variable.
;  ebx -- DC
;  ebp -- Reserved.  PITCH
;  mm7 -- Reciprocal of quantization level.

  movdt       mm7, Recip2QPToUse
   punpckldq  mm6, mm6    
  movq        mm0, C00[esi+eax]           ;00A  Load 4 coeffs
   punpckldq  mm7, mm7                    ; 4 words of Recip2QP
  movq        mm2, C04[esi+eax]           ;04A
   movq       mm1, mm0                    ;00B  Copy
  psraw       mm0, 15                     ;00C  Extract sign
   movq       mm3, mm2                    ;04B

QuantCoeffs:

  psraw       mm3, 15                     ;04C
   pxor       mm1, mm0                    ;00D  1's complement
  pxor        mm2, mm3                    ;04D
   psubsw     mm1, mm0                    ;00E  Absolute value
  psubsw      mm2, mm3                    ;04E
   psubusw    mm1, mm6                    ;00S  Subtract QP/2 in case of inter
  pmulhw      mm1, mm7                    ;00F  Quantize
   psubusw    mm2, mm6                    ;04S
  movq        mm4, C10[esi+eax]           ;10A
   pmulhw     mm2, mm7                    ;04F
  movq        mm5, mm4                    ;10B
   packsswb   mm0, mm3                    ;0*A  Sign for 8 coeffs
  movq        mm3, C14[esi+eax]           ;14A
   psraw      mm4, 15                     ;10C
  packsswb    mm1, mm2                    ;0*C  Quantized 8 coeffs
   movq       mm2, mm3                    ;14B
  psraw       mm2, 15                     ;14C
   pxor       mm5, mm4                    ;10D
  pxor        mm3, mm2                    ;14D
   psubsw     mm5, mm4                    ;10E
  psubsw      mm3, mm2                    ;14E
   psubusw    mm5, mm6                    ;10S
  pmulhw      mm5, mm7                    ;10F
   psubusw    mm3, mm6                    ;14S
  movq        C04[esi+eax], mm0           ;0*B  Save sign
   pmulhw     mm3, mm7                    ;14F
  movq        mm0, C20[esi+eax]           ;20A
   packsswb   mm4, mm2                    ;1*A
  movq        C00[esi+eax], mm1           ;0*D  Save quantized 8 coeffs
   movq       mm1, mm0                    ;20B
  movq        C14[esi+eax], mm4           ;1*B
   packsswb   mm5, mm3                    ;1*C
  movq        mm2, C24[esi+eax]           ;24A
   psraw      mm0, 15                     ;20C
  movq        C10[esi+eax], mm5           ;1*D
   movq       mm3, mm2                    ;24B
  add         eax,32
   jne        QuantCoeffs

  pcmpeqb   mm7,mm7
   mov      cl,  StashBlockType
  cmp       cl,  INTRA                  ;
   mov      cl, [edi]                   ; Get output line into cache.
  mov       cl, [edi+32]                ; Get output line into cache.
   jne      RunValSignINTER00

RunValSignINTRAC00:

  mov       ecx, ebx
   sub      esi, 128
  shl       ecx, 16
   mov      PB [edi], 0H                ; Run-length
  shr       ecx, 20                     ; 8-bit unsigned INTRA-DC value
   jnz      @f
  mov       cl, 1
@@:
  mov       [edi+1], cl                 ; DC
   xor      ecx, ecx
  mov       [edi+2], al                 ; sign of DC 
   xor      ebx, ebx
  mov       bl, [esi+Q01]
   mov      cl, Q01                     ; Index to Zigzag table.
  add       edi, 3
   jmp      QuantizeFirstACCoeff

RunValSignINTER00:
  
  xor       ecx, ecx                    ; Index to Zigzag table.
   xor      ebx, ebx
  mov       bl, [esi+Q00-128]
   sub      esi, 128

QuantizeFirstACCoeff:

  xor       al, al                      ; Zero run counter

QuantizeNextCoeff:

  mov       [edi+1], bl            ; Store quantized value.
   add      bl,255                 ; CF == 1 iff did not quantize to zero.
  sbb       bl,bl                  ; bl == 0xFF iff did not quant to zero.
   mov      ah, [esi+ecx+8]        ; Fetch sign.
  mov       [edi],al               ; Store zero run counter.
   or       al,bl                  ; Zero cnt == -1 iff did not quant to zero.
  inc       al                     ; Increment zero count.
   mov      cl,NextZigZagCoeff[ecx]
  and       bl,3                   ; bl == 3 iff did not quant to 0, else 0.
   mov      [edi+2],ah             ; Store sign.
  add       edi,ebx                ; Inc output ptr iff did not quant to zero.
   mov      bl,[esi+ecx]           ; Fetch next quantized coeff.
  test      cl,cl                  ; More coeffs to do?
   jne      QuantizeNextCoeff

QuantDone:

  mov       ebx,CodeStreamCursor
   mov      al,StashBlockType
  sub       ebx,edi
   je       ReturnBlockEmptyFlag

  mov       ah,[edi-3]
  cmp       ah,16
   jl       @f

  mov       ah,[edi-2]
  cmp       ah,1
   jne      @f

  sub       edi,3
   jmp      QuantDone

@@:

  add       ebx,3
   xor      al,INTRA
  or        al,bl
   je       ReturnBlockEmptyFlag

  mov       ebx,-1       ; Set to -1
  mov       [edi],bl
   add      edi,3

ReturnBlockEmptyFlag:

  mov       CodeStreamCursor, edi
   pcmpeqb  mm6,mm6
  inc       ebx                    ; 0 if block not empty;  1 if block empty.
   paddb    mm6,mm6
  ret

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exmfdct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\exmfdct.asv   1.3   22 Jul 1996 15:23:20   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\exmfdct.asv  $
;// 
;//    Rev 1.3   22 Jul 1996 15:23:20   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.2   02 May 1996 12:00:54   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.1   15 Mar 1996 15:52:44   BECHOLS
;// 
;// Completed monolithic - Brian
;// 
;//    Rev 1.0   22 Feb 1996 20:04:46   BECHOLS
;// Initial revision.
;// 
;//
;////////////////////////////////////////////////////////////////////////////
;
; exmfdct -- This function performs a Forward Discrete Cosine Transform for
; H263, on a stream of macroblocks comprised of 8*8 blocks of pels or pel
; differences.  It is tightly coupled with its caller, the frame differencing
; code, and its callee, the Quantization/Run-length-encoding code.
;

.xlist
include memmodel.inc
include e3inst.inc   ; Encoder instance data
include e3mbad.inc   ; MacroBlock Action Descriptor struct layout
include exEDTQ.inc   ; Data structures for motion -E-stimation, frame -D-iff,
                     ; Forward DCT -T-ransform, and -Q-uant/RLE.
include iammx.inc    ; MMx instructions
.list

.CODE EDTQ

EXTERN MMxQuantRLE:NEAR

;ASSUME cs : FLAT
;ASSUME ds : FLAT
;ASSUME es : FLAT
;ASSUME fs : FLAT
;ASSUME gs : FLAT
;ASSUME ss : FLAT

PUBLIC MMxDoForwardDCT
PUBLIC MMxDoForwardDCTx
PUBLIC MMxDoForwardDCTy

MMxDoForwardDCTx:
  movq       PelDiffsLine7,mm1
MMxDoForwardDCTy:
  mov        ebp,16
  lea        esi,PelDiffs
MMxDoForwardDCT:

StackOffset TEXTEQU <8>

; ++ ========================================================================
; The Butterfly macro performs a 4x8 symetrical butterfly on half of an
; 8x8 block of memory.  Given rows r0 to r7 the Butterfly gives the following
; results.      q0 = r0+r7,  q7 = r0-r7
;               q1 = r1+r6,  q6 = r1-r6
;               q2 = r2+r5,  q5 = r2-r5
;               q3 = r3+r4,  q4 = r3-r4
; This code has been optimized, but still gives up three half clocks.  The
; butterflies are numbered 10 -> 16, 20 -> 26, 30 -> 36, and 40 -> 46.
; -- ========================================================================
Butterfly1     MACRO
   punpcklbw   mm7,[esi]           ;10  -- Fetch line 0 of input.
   punpcklbw   mm0,[esi+ecx*1]     ;11  -- Fetch line 7 of input.
    pmulhw     mm7,mm4             ;12  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm6,[esi+ebp*1]     ;  20
    pmulhw     mm0,mm4             ;13  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm1,[esi+eax*2]     ;  21
    pmulhw     mm6,mm4             ;  22
   punpcklbw   mm5,[esi+ebp*2]     ;    30
    pmulhw     mm1,mm4             ;  23
   punpcklbw   mm2,[esi+ebx*1]     ;    31
    psubw      mm7,mm0             ;14  -- Line0 - Line7
   punpcklbw   mm4,[esi+eax*1]     ;       40
    paddw      mm0,mm0             ;15  -- 2 * Line7
   punpcklbw   mm3,[esi+ebp*4]     ;       41
    paddw      mm0,mm7             ;16  -- Line0 + Line7
   psraw       mm5,8               ;    32
    psubw      mm6,mm1             ;  24
   psraw       mm2,8               ;    33
    paddw      mm1,mm1             ;  25
   psraw       mm4,8               ;      42
    paddw      mm1,mm6             ;  26
   psraw       mm3,8               ;      43
    psubw      mm5,mm2             ;    34
   movq        [edi+7*8*2],mm7     ;17  -- Save Line0 - Line7
    psubw      mm4,mm3             ;      44
   movq        [edi+0*8*2],mm0     ;18  -- Save Line0 + Line7
    paddw      mm2,mm2             ;    35
   movq        [edi+6*8*2],mm6     ;  27
    paddw      mm3,mm3             ;      45
   movq        [edi+1*8*2],mm1     ;  28
    paddw      mm2,mm5             ;    36
   movq        [edi+5*8*2],mm5     ;    37
    paddw      mm3,mm4             ;      46
   movq        [edi+2*8*2],mm2     ;    38
   movq        [edi+4*8*2],mm4     ;      47
   movq        [edi+3*8*2],mm3     ;      48
ENDM

Butterfly2     MACRO
   movq        mm0,[edi+0*8*2]        ;10
   movq        mm1,[edi+7*8*2]        ;11
     movq      mm2,mm0                 ;12
   movq        mm3,[edi+1*8*2]        ;  20
     paddw     mm0,mm1                 ;13
   movq        mm4,[edi+6*8*2]        ;  21
     psubw     mm2,mm1                 ;14
   movq        [edi+0*8*2],mm0        ;15
   movq        [edi+7*8*2],mm2        ;16
     movq      mm5,mm3                 ;  22
   movq        mm6,[edi+2*8*2]        ;    30
     paddw     mm3,mm4                 ;  23
   movq        mm7,[edi+5*8*2]        ;    31
     psubw     mm5,mm4                 ;  24
   movq        [edi+1*8*2],mm3        ;  25
     movq      mm0,mm6                 ;    32
   movq        [edi+6*8*2],mm5        ;  26
     paddw     mm6,mm7                 ;    33
   movq        mm1,[edi+3*8*2]        ;      40
     psubw     mm0,mm7                 ;    34
   movq        mm2,[edi+4*8*2]        ;      41
     movq      mm3,mm1                 ;      42
   movq        [edi+2*8*2],mm6        ;    35
     paddw     mm1,mm2                 ;      43
   movq        [edi+5*8*2],mm0        ;    36
     psubw     mm3,mm2                 ;      44
   movq        [edi+3*8*2],mm1        ;      45
   movq        [edi+4*8*2],mm3        ;      46
ENDM

; ++ ========================================================================
; The StageOne macro performs a 4x4 Butterfly on rows q0 to q4 such that:
;               p0 = q0+q3,  p3 = q0-q3
;               p1 = q1+q2,  p2 = q1-q2
; A scaled butterflyon rows q5 and q6 yield the following equations.
;               p5 = C4*(q6-q5), p6 = C4*(q6+q5)
; This has been optimized, but gives up four half clocks.  The two simple
; butterflies are numbered 10 -> 16 and 30 -> 36.
; The scaled butterfly is numbered 20 -> 2c.
; -- ========================================================================
StageOne       MACRO
   movq        mm4,[edi+0*8*2]        ;10
   movq        mm5,[edi+3*8*2]        ;11
     movq      mm6,mm4                 ;12
   movq        mm0,[edi+6*8*2]        ;  20
     paddw     mm4,mm5                 ;13
   movq        mm1,[edi+5*8*2]        ;  21
     psubw     mm6,mm5                 ;14
   movq        [edi+0*8*2],mm4        ;15
     movq      mm2,mm0                 ;  22
   movq        [edi+3*8*2],mm6        ;16
     paddw     mm2,mm1                 ;  23
   psubw       mm0,mm1                 ;  24
   movq        mm3,[edi+1*8*2]        ;    30
     psllw     mm0,2                   ;  25
   movq        mm4,[edi+2*8*2]        ;    31
     psllw     mm2,2                   ;  26
   pmulhw      mm0,PD C4               ;  27
     movq      mm5,mm3                 ;    32
   pmulhw      mm2,PD C4               ;  28
     paddw     mm3,mm4                 ;    33
   psubw       mm5,mm4                 ;    34
   movq        [edi+1*8*2],mm3        ;    35
     psraw     mm0,1                   ;  29
   movq        [edi+2*8*2],mm5        ;    36
     psraw     mm2,1                   ;  2a
   movq        [edi+5*8*2],mm0        ;  2b
   movq        [edi+6*8*2],mm2        ;  2c
ENDM

; ++ ========================================================================
; The StageTwo macro performs two simple butterflies on rows p4,p5 and
; p6,p7 such that:
;               n4 = p4+p5,  n5 = p4-p5
;               n6 = p7-p6,  n7 = p7+p6
; They are numbered 20 -> 26 and 40 -> 46.
;
; It also performs a scaled butterflies on rows p0,p1 such that:
;               n0 = C4*(p0+p1), n1 = C4*(p0-p1)
; This are numbered 10 -> 1c.
;
; Finally, it performs a butterfly on the scaled rows p2,p3 such that:
;               n2 = C2*p3+C6*p2, n3 = C6*p6-C2*p2
; This is numbered 30 -> 3f.
;
; This macro has been optimized, but gives up four half clocks.
; -- ========================================================================
StageTwo       MACRO
   movq        mm1,[edi+3*8*2]        ;    30
   movq        mm2,[edi+2*8*2]        ;    31
     psllw     mm1,2                   ;    32
   movq        mm5,[edi+4*8*2]        ;  20
     psllw     mm2,2                   ;    33
   movq        mm6,[edi+5*8*2]        ;  21
     movq      mm3,mm1                 ;    34
   pmulhw      mm1,PD C2               ;    36
     movq      mm4,mm2                 ;    35
   pmulhw      mm2,PD C6               ;    37
     movq      mm7,mm5                 ;  22
   pmulhw      mm3,PD C6               ;    38
     paddw     mm5,mm6                 ;  23
   pmulhw      mm4,PD C2               ;    39
     psubw     mm7,mm6                 ;  24
   movq        [edi+4*8*2],mm5        ;  25
     paddw     mm1,mm2                 ;    3a
   movq        [edi+5*8*2],mm7        ;  26
     psraw     mm1,1                   ;    3c
   movq        mm6,[edi+0*8*2]        ;10
     psubw     mm3,mm4                 ;    3b
   movq        mm0,[edi+1*8*2]        ;11
     psraw     mm3,1                   ;    3d
   movq        [edi+2*8*2],mm1        ;    3e
     movq      mm7,mm6                 ;12
   movq        [edi+3*8*2],mm3        ;    3f
     paddw     mm6,mm0                 ;13
   movq        mm3,[edi+7*8*2]        ;      40
     psubw     mm7,mm0                 ;14
   movq        mm5,[edi+6*8*2]        ;      41
     psllw     mm6,2                   ;15
   psllw       mm7,2                   ;16
   pmulhw      mm6,PD C4               ;17
     movq      mm4,mm3                 ;      42
   pmulhw      mm7,PD C4               ;18
     paddw     mm3,mm5                 ;      43
   psubw       mm4,mm5                 ;      44
   movq        [edi+7*8*2],mm3        ;      45
     psraw     mm6,1                   ;19
   movq        [edi+6*8*2],mm4        ;      46
     psraw     mm7,1                   ;1a
   movq        [edi+0*8*2],mm6        ;1b
   movq        [edi+1*8*2],mm7        ;1c
ENDM

; ++ ========================================================================
; The StageThree macro performs a butterfly on the scaled rows n4,n7 and
; n5,n6 such that:
;               m4 = C7*n4+C1*n7,  m7 = C1*n7-C7*n4
;               m5 = C5*n6+C3*n5,  m6 = C3*n6-C5*n5
; Steps 10 -> 1f determine m4,m7 and 20 -> 2f determine m5,m6.
; The outputs m0-m7 are put into reverse binary order as follows:
;               0 = 000  ->  000 = 0
;               1 = 001  ->  100 = 4
;               2 = 010  ->  010 = 2
;               3 = 011  ->  110 = 6
;               4 = 100  ->  001 = 1
;               5 = 101  ->  101 = 5
;               6 = 110  ->  011 = 3
;               7 = 111  ->  111 = 7
;
; This macro has been optimized, but I had to give up 10 half clocks.
; -- ========================================================================
StageThree     MACRO
   movq        mm0,[edi+7*8*2]        ;10
   movq        mm4,[edi+6*8*2]        ;  20
   movq        mm1,[edi+4*8*2]        ;11
     psllw     mm0,2                  ;12
   movq        mm5,[edi+5*8*2]        ;  21
     psllw     mm4,2                  ;  22
   movq        mm3,[edi+1*8*2]        ;
     psllw     mm1,2                  ;13
   movq        mm7,[edi+3*8*2]        ;
     psllw     mm5,2                  ;  23
   movq        [edi+4*8*2],mm3        ;
     movq      mm2,mm0                ;14
   movq        [edi+6*8*2],mm7        ;
     movq      mm6,mm4                ;  24
   pmulhw      mm0,PD C1              ;16
     movq      mm3,mm1                ;15
   pmulhw      mm1,PD C7              ;17
   pmulhw      mm2,PD C7              ;18
   pmulhw      mm3,PD C1              ;19
     movq      mm7,mm5                ;  25
   pmulhw      mm4,PD C5              ;  26
     paddw     mm0,mm1                ;1a
   pmulhw      mm5,PD C3              ;  27
     psubw     mm2,mm3                ;1b
   pmulhw      mm6,PD C3              ;  28
   pmulhw      mm7,PD C5              ;  29
     psraw     mm0,1                  ;1c
   psraw       mm2,1                  ;1d
     paddw     mm4,mm5                ;  2a
   movq        [edi+1*8*2],mm0        ;1e
     psubw     mm6,mm7                ;  2b
   movq        [edi+7*8*2],mm2        ;1f
     psraw     mm4,1                  ;  2c
   psraw       mm6,1                  ;  2d
   movq        [edi+5*8*2],mm4        ;  2e
   movq        [edi+3*8*2],mm6        ;  2f
ENDM

OPTION NOM510

;============================================================================
; This section does the Forward Discrete Cosine Transform.  It performs a
;  DCT on an 8*8 block of pels or pel differences.
;
; Upon input:
;
; esi -- Address of block of pels or pel differences on which to perform FDCT.
; ebp -- Pitch of block (8, 16, or 384).
; edx -- Reserved.
;
; After setup:
;
; esi -- Address of block of pels or pel differences on which to perform FDCT.
; ebp -- Pitch of block (8, 16, or 384).  After Quant RLE, this gets set to 384.
; edx -- Reserved.
; edi -- Address at which to place intermediate and final coefficients.
; eax -- Pitch times 3
; ebx -- Pitch times 5
; ecx -- Pitch times 7
; mm5 -- 4 words of 256.
; mm0:mm7 -- Scratch.

   lea         edi,Coeffs
    lea        eax,[ebp+ebp*2]
   movq        mm4,PD C0100010001000100
   lea         ebx,[ebp+ebp*4]
    lea        ecx,[eax+ebp*4]

RepeatFirstTransform:

; ++ ========================================================================
; The Butterfly performs a 4x8 symetrical butterfly on half of an
; 8x8 block of memory.  Given rows r0 to r7 the Butterfly gives the following
; results.      q0 = r0+r7,  q7 = r0-r7
;               q1 = r1+r6,  q6 = r1-r6
;               q2 = r2+r5,  q5 = r2-r5
;               q3 = r3+r4,  q4 = r3-r4
; This code has been optimized, but still gives up three half clocks.  The
; butterflies are numbered 10 -> 16, 20 -> 26, 30 -> 36, and 40 -> 46.
; -- ========================================================================

   punpcklbw   mm7,[esi]           ;10  -- Fetch line 0 of input.
   punpcklbw   mm0,[esi+ecx*1]     ;11  -- Fetch line 7 of input.
    pmulhw     mm7,mm4             ;12  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm6,[esi+ebp*1]     ;  20
    pmulhw     mm0,mm4             ;13  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm1,[esi+eax*2]     ;  21
    pmulhw     mm6,mm4             ;  22
   punpcklbw   mm5,[esi+ebp*2]     ;    30
    pmulhw     mm1,mm4             ;  23
   punpcklbw   mm2,[esi+ebx*1]     ;    31
    psubw      mm7,mm0             ;14  -- Line0 - Line7
   punpcklbw   mm4,[esi+eax*1]     ;       40
    paddw      mm0,mm0             ;15  -- 2 * Line7
   punpcklbw   mm3,[esi+ebp*4]     ;       41
    paddw      mm0,mm7             ;16  -- Line0 + Line7
   psraw       mm5,8               ;    32
    psubw      mm6,mm1             ;  24
   psraw       mm2,8               ;    33
    paddw      mm1,mm1             ;  25
   psraw       mm4,8               ;      42
    paddw      mm1,mm6             ;  26
   psraw       mm3,8               ;      43
    psubw      mm5,mm2             ;    34
   psubw       mm4,mm3             ;      44
    paddw      mm2,mm2             ;    35
   paddw       mm3,mm3             ;      45
    paddw      mm2,mm5             ;    36
   paddw       mm3,mm4             ;      46

; ++ ========================================================================
; The StageOne performs a 4x4 Butterfly on rows q0 to q4 such that:
;               p0 = q0+q3,  p3 = q0-q3
;               p1 = q1+q2,  p2 = q1-q2
; A scaled butterflyon rows q5 and q6 yield the following equations.
;               p5 = C4*(q6-q5), p6 = C4*(q6+q5)
; This has been optimized, but gives up four half clocks.  The two simple
; butterflies are numbered 10 -> 16 and 30 -> 36.
; The scaled butterfly is numbered 20 -> 2c.
; -- ========================================================================

    psubw      mm1,mm2              ;     30  -- p2 = q1 - q2
   psubw       mm6,mm5              ;   20    -- q6 - q5
    paddw      mm5,mm5              ;   21    -- 2q5
   paddw       mm5,mm6              ;   22    -- q6 + q5
    psllw      mm6,2                ;   23    -- scale
   pmulhw      mm6,PD C4            ;   24    -- C4*(q6-q5) scaled
    psllw      mm5,2                ;   23    -- scale
   pmulhw      mm5,PD C4            ;   24    -- C4*(q6+q5) scaled
    psubw      mm0,mm3              ; 10      -- p3 = q0 - q3
   paddw       mm3,mm3              ; 11      -- 2q3
    paddw      mm2,mm2              ;     31  -- 2q2
   paddw       mm3,mm0              ; 12      -- p0 = q0 + q3
    psraw      mm6,1                ;   25    -- p5 = C4*(q6-q5)
   paddw       mm2,mm1              ;     32  -- p1 = q1 + q2
    psraw      mm5,1                ;   26    -- p6 = C4*(q6+q5)

; ++ ========================================================================
; The StageTwo performs two simple butterflies on rows p4,p5 and
; p6,p7 such that:
;               n4 = p4+p5,  n5 = p4-p5
;               n6 = p7-p6,  n7 = p7+p6
; They are numbered 20 -> 26 and 40 -> 46.
;
; It also performs a scaled butterflies on rows p0,p1 such that:
;               n0 = C4*(p0+p1), n1 = C4*(p0-p1)
; This are numbered 10 -> 1c.
;
; Finally, it performs a butterfly on the scaled rows p2,p3 such that:
;               n2 = C2*p3+C6*p2, n3 = C6*p6-C2*p2
; This is numbered 30 -> 3f.
; -- ========================================================================

   psubw       mm3,mm2              ; 10        -- p0 - p1
    paddw      mm2,mm2              ; 11        -- 2p1
   paddw       mm2,mm3              ; 12        -- p0 + p1
    psllw      mm3,2                ; 13        -- scale
   pmulhw      mm3,PD C4            ; 14        -- C4*(p0-p1)
    psllw      mm2,2                ; 15        -- scale
   pmulhw      mm2,PD C4            ; 16        -- C4*(p0+p1)
    psllw      mm0,2                ;     30    -- scale p3
   psubw       mm4,mm6              ;   20      -- n5 = p4 - p5
    psllw      mm1,2                ;     31    -- scale p2
   psubw       mm7,mm5              ;       40  -- n6 = p7 - p6
    psraw      mm3,1                ; 17        -- n1 = C4*(p0-p1)
   paddw       mm6,mm6              ;   21      -- 2p5
    psraw      mm2,1                ; 18        -- n0 = C4*(p0+p1)
   movq        [edi+4*8*2],mm3      ; 19        -- Save n1             (stage 3)
    movq       mm3,mm0              ;     32    -- Copy scaled p3
   movq        [edi+0*8*2],mm2      ; 1a        -- Save n0             (stage 3)
    movq       mm2,mm1              ;     33    -- Copy scaled p2
   pmulhw      mm0,PD C2            ;     34    -- C2*p3 scaled
    paddw      mm5,mm5              ;       41  -- 2p6
   pmulhw      mm1,PD C6            ;     35    -- C6*p2 scaled
    paddw      mm6,mm4              ;   22      -- n4 = p4 + p5
   pmulhw      mm3,PD C6            ;     36    -- C6*p3 scaled
    paddw      mm5,mm7              ;       42  -- n7 = p7 + p6
   pmulhw      mm2,PD C2            ;     37    -- C2*p2 scaled
    psllw      mm5,2                ; 10        -- scale n7            (stage 3)
   paddw       mm0,mm1              ;     38    -- C2*p3 + C6*p2 scaled
    psllw      mm7,2                ;   20      -- scale n6            (stage 3)
   movq        mm1,mm5              ; 11        -- copy scaled n7      (stage 3)
    psraw      mm0,1                ;     39    -- n2 = C2*p3 + C6*p2
   pmulhw      mm5,PD C1            ; 12        -- C1*n7 scaled        (stage 3)
    psllw      mm6,2                ; 13        -- scale n4            (stage 3)
   movq        [edi+2*8*2],mm0      ;     3c    -- Save n2             (stage 3)
    psubw      mm3,mm2              ;     3a    -- C6*p3 - C2*p2 scaled

; ++ ========================================================================
; The StageThree macro performs a butterfly on the scaled rows n4,n7 and
; n5,n6 such that:
;               m4 = C7*n4+C1*n7,  m7 = C7*n7-C1*n4
;               m5 = C5*n6+C3*n5,  m6 = C3*n6-C5*n5
; Steps 10 -> 1f determine m4,m7 and 20 -> 2f determine m5,m6.
; The outputs m0-m7 are put into reverse binary order as follows:
;               0 = 000  ->  000 = 0
;               1 = 001  ->  100 = 4
;               2 = 010  ->  010 = 2
;               3 = 011  ->  110 = 6
;               4 = 100  ->  001 = 1
;               5 = 101  ->  101 = 5
;               6 = 110  ->  011 = 3
;               7 = 111  ->  111 = 7
; -- ========================================================================

   pmulhw      mm1,PD C7            ; 14        -- C7*n7 scaled
    movq       mm0,mm6              ; 15        -- copy scaled n4
   pmulhw      mm6,PD C7            ; 16        -- C7*n4 scaled
    psraw      mm3,1                ;     3b    -- n3 = C6*p6 - C2*p2
   pmulhw      mm0,PD C1            ; 17        -- C1*n4 scaled
    movq       mm2,mm7              ;   21      -- copy scaled n6
   movq        [edi+6*8*2],mm3      ;     3d    -- Save n3
    psllw      mm4,2                ;   22      -- scale n5
   pmulhw      mm7,PD C5            ;   23      -- C5*n6 scaled
    movq       mm3,mm4              ;   24      -- copy scaled n5
   pmulhw      mm4,PD C3            ;   25      -- C3*n5 scaled
    paddw      mm5,mm6              ; 18        -- C7*n4+C1*n7 scaled
   pmulhw      mm2,PD C3            ;   26      -- C3*n6 scaled
    psubw      mm1,mm0              ; 19        -- C7*n7-C1*n4 scaled
   pmulhw      mm3,PD C5            ;   27      -- C5*n5 scaled
    psraw      mm5,1                ; 1a        -- m4 = C7*n4+C1*n7
   paddw       mm7,mm4              ;   28      -- C5*n6+C3*n5 scaled
    psraw      mm1,1                ; 1b        -- m7 = C7*n7-C1*n4
   movq        [edi+1*8*2],mm5      ; 1c        -- Save m4
    psraw      mm7,1                ;   29      -- m5 = C5*n6+C3*n5
   movq        [edi+7*8*2],mm1      ; 1d        -- Save m7
    psubw      mm2,mm3              ;   2a      -- C3*n6-C5*n5 scaled
   movq        [edi+5*8*2],mm7      ;   2b      -- Save m5
    psraw      mm2,1                ;   2c      -- m6 = C3*n6-C5*n5
   movq        mm4,PD C0100010001000100  ; Prepare for next iteration.
    ;
   movq        [edi+3*8*2],mm2      ;   2d      -- Save m6
    ;
   add         edi,8
    add        esi,4
   test        esi,4
    ;
   jne         RepeatFirstTransform

   sub         edi,16
    mov        esi,2

; ++ ========================================================================
; The Transpose performs four 4x4 transpositions as described in the
; MMx User's Guide.  This of course rotates the 8x8 matrix on its diagonal.
;
; This routine is more expensive than I had hoped.  I need to revisit this.
; -- ========================================================================

   movq        mm0,[edi+0*8*2]        ;10  <C03 C02 C01 C00>
    ;
   movq        mm1,[edi+1*8*2]        ;11  <C13 C12 C11 C01>
    movq       mm4,mm0                ;12  <C03 C02 C01 C00>
   movq        mm2,[edi+2*8*2]        ;13  <C23 C22 C21 C20>
    punpckhwd  mm0,mm1                ;14  <C13 C03 C12 C02>
   movq        mm3,[edi+3*8*2]        ;15  <C33 C32 C31 C30>
    punpcklwd  mm4,mm1                ;16  <C11 C01 C10 C00>
   movq        mm6,mm2                ;17  <C23 C22 C21 C20>
    punpckhwd  mm2,mm3                ;18  <C33 C23 C32 C22>
   movq        mm1,mm0                ;19  <C13 C03 C12 C02>
    punpckldq  mm0,mm2                ;1a  <C32 C22 C12 C02>
   movq        mm7,[edi+4*8*2]        ;  20
    punpcklwd  mm6,mm3                ;1b  <C31 C21 C30 C20>
   movq        [edi+2*8*2],mm0        ;1c  <C32 C22 C12 C02> saved
    punpckhdq  mm1,mm2                ;1d  <C33 C23 C13 C03>
   movq        mm5,mm4                ;1e  <C11 C01 C10 C00>
    punpckldq  mm4,mm6                ;1f  <C30 C20 C10 C00>
   movq        [edi+3*8*2],mm1        ;1g  <C33 C23 C13 C03> saved
    punpckhdq  mm5,mm6                ;1h  <C31 C21 C11 C01>
   movq        mm3,[edi+5*8*2]        ;  21
    movq       mm0,mm7                ;  22
   movq        mm2,[edi+6*8*2]        ;  23
    punpckhwd  mm7,mm3                ;  24
   movq        mm1,[edi+7*8*2]        ;  25
    punpcklwd  mm0,mm3                ;  26
   movq        [edi+0*8*2],mm4        ;1i  <C30 C20 C10 C00> saved
    movq       mm6,mm2                ;  27
   movq        [edi+1*8*2],mm5        ;1j  <C31 C21 C11 C01> saved
    punpckhwd  mm2,mm1                ;  28
   movq        mm3,mm7                ;  29
    punpckldq  mm7,mm2                ;  2a
   movq        mm4,[edi+0*8*2+8]      ;    30
    punpcklwd  mm6,mm1                ;  2b
   movq        mm1,[edi+2*8*2+8]      ;    33
    punpckhdq  mm3,mm2                ;  2d
   movq        [edi+2*8*2+8],mm7      ;  2c
    movq       mm5,mm0                ;  2e
   movq        mm7,[edi+1*8*2+8]      ;    31
    punpckldq  mm0,mm6                ;  2f
   movq        mm2,[edi+3*8*2+8]      ;    35
    punpckhdq  mm5,mm6                ;  2h
   movq        [edi+3*8*2+8],mm3      ;  2g
    movq       mm6,mm4                ;    32
   movq        [edi+0*8*2+8],mm0      ;  2i
    punpckhwd  mm4,mm7                ;    34
   movq        [edi+1*8*2+8],mm5      ;  2j
    punpcklwd  mm6,mm7                ;    36
   movq        mm3,mm1                ;    37
    punpckhwd  mm1,mm2                ;    38
   movq        mm7,mm4                ;    39
    punpckldq  mm4,mm1                ;    3a
   movq        mm0,[edi+4*8*2+8]      ;      40
    punpcklwd  mm3,mm2                ;    3b
   movq        [edi+6*8*2],mm4        ;    3c
    punpckhdq  mm7,mm1                ;    3d
   movq        mm5,mm6                ;    3e
    punpckldq  mm6,mm3                ;    3f
   movq        [edi+7*8*2],mm7        ;    3g
    punpckhdq  mm5,mm3                ;    3h
   movq        mm2,[edi+5*8*2+8]      ;      41
    movq       mm4,mm0                ;      42
   movq        mm1,[edi+6*8*2+8]      ;      43
    punpckhwd  mm0,mm2                ;      44
   movq        mm7,[edi+7*8*2+8]      ;      45
    punpcklwd  mm4,mm2                ;      46
   movq        [edi+4*8*2],mm6        ;    3i
    movq       mm3,mm1                ;      47
   movq        [edi+5*8*2],mm5        ;    3j
    punpckhwd  mm1,mm7                ;      48
   movq        mm2,mm0                ;      49
    punpckldq  mm0,mm1                ;      4a
   punpcklwd   mm3,mm7                ;      4b
    ;
   movq        [edi+6*8*2+8],mm0      ;      4c
    punpckhdq  mm2,mm1                ;      4d
   movq        mm6,mm4                ;      4e
    punpckldq  mm4,mm3                ;      4f
   movq        [edi+7*8*2+8],mm2      ;      4g
    punpckhdq  mm6,mm3                ;      4h
   movq        [edi+4*8*2+8],mm4      ;      4i
    ;
   movq        [edi+5*8*2+8],mm6      ;      4j
    ;

RepeatSecondTransform:

; ++ ========================================================================
; The Butterfly performs a 4x8 symetrical butterfly on half of an
; 8x8 block of memory.  Given rows r0 to r7 the Butterfly gives the following
; results.      q0 = r0+r7,  q7 = r0-r7
;               q1 = r1+r6,  q6 = r1-r6
;               q2 = r2+r5,  q5 = r2-r5
;               q3 = r3+r4,  q4 = r3-r4
; This code has been optimized, but still gives up three half clocks.  The
; butterflies are numbered 10 -> 16, 20 -> 26, 30 -> 36, and 40 -> 46.
; -- ========================================================================

   movq        mm7,[edi]           ;10  -- Fetch line 0 of input.
   movq        mm0,[edi+7*8*2]     ;11  -- Fetch line 7 of input.
   movq        mm6,[edi+1*8*2]     ;  20
    psubw      mm7,mm0             ;14  -- Line0 - Line7
   movq        mm1,[edi+6*8*2]     ;  21
    paddw      mm0,mm0             ;15  -- 2 * Line7
   movq        mm5,[edi+2*8*2]     ;    30
    paddw      mm0,mm7             ;16  -- Line0 + Line7
   movq        mm2,[edi+5*8*2]     ;    31
    psubw      mm6,mm1             ;  24
   paddw       mm1,[edi+1*8*2]     ;  26
    psubw      mm5,mm2             ;    34
   movq        mm4,[edi+3*8*2]     ;       40
   movq        mm3,[edi+4*8*2]     ;       41
    psubw      mm6,mm5             ;   20    -- q6 - q5                (Stage 1)
   paddw       mm2,[edi+2*8*2]     ;    36
    psubw      mm4,mm3             ;      44
   paddw       mm3,[edi+3*8*2]     ;      46
    psubw      mm1,mm2             ;     30  -- p2 = q1 - q2           (Stage 1)

; ++ ========================================================================
; The StageOne performs a 4x4 Butterfly on rows q0 to q4 such that:
;               p0 = q0+q3,  p3 = q0-q3
;               p1 = q1+q2,  p2 = q1-q2
; A scaled butterflyon rows q5 and q6 yield the following equations.
;               p5 = C4*(q6-q5), p6 = C4*(q6+q5)
; This has been optimized, but gives up four half clocks.  The two simple
; butterflies are numbered 10 -> 16 and 30 -> 36.
; The scaled butterfly is numbered 20 -> 2c.
; -- ========================================================================

    paddw      mm5,mm5              ;   21    -- 2q5
   paddw       mm5,mm6              ;   22    -- q6 + q5
    psllw      mm6,2                ;   23    -- scale
   pmulhw      mm6,PD C4            ;   24    -- C4*(q6-q5) scaled
    psllw      mm5,2                ;   23    -- scale
   pmulhw      mm5,PD C4            ;   24    -- C4*(q6+q5) scaled
    psubw      mm0,mm3              ; 10      -- p3 = q0 - q3
   paddw       mm3,mm3              ; 11      -- 2q3
    paddw      mm2,mm2              ;     31  -- 2q2
   paddw       mm3,mm0              ; 12      -- p0 = q0 + q3
    psraw      mm6,1                ;   25    -- p5 = C4*(q6-q5)
   paddw       mm2,mm1              ;     32  -- p1 = q1 + q2
    psraw      mm5,1                ;   26    -- p6 = C4*(q6+q5)

; ++ ========================================================================
; The StageTwo performs two simple butterflies on rows p4,p5 and
; p6,p7 such that:
;               n4 = p4+p5,  n5 = p4-p5
;               n6 = p7-p6,  n7 = p7+p6
; They are numbered 20 -> 26 and 40 -> 46.
;
; It also performs a scaled butterflies on rows p0,p1 such that:
;               n0 = C4*(p0+p1), n1 = C4*(p0-p1)
; This are numbered 10 -> 1c.
;
; Finally, it performs a butterfly on the scaled rows p2,p3 such that:
;               n2 = C2*p3+C6*p2, n3 = C6*p6-C2*p2
; This is numbered 30 -> 3f.
; -- ========================================================================

   psubw       mm3,mm2              ; 10        -- p0 - p1
    paddw      mm2,mm2              ; 11        -- 2p1
   paddw       mm2,mm3              ; 12        -- p0 + p1
    psllw      mm3,2                ; 13        -- scale
   pmulhw      mm3,PD C4            ; 14        -- C4*(p0-p1)
    psllw      mm2,2                ; 15        -- scale
   pmulhw      mm2,PD C4            ; 16        -- C4*(p0+p1)
    psllw      mm0,2                ;     30    -- scale p3
   psubw       mm4,mm6              ;   20      -- n5 = p4 - p5
    psllw      mm1,2                ;     31    -- scale p2
   psubw       mm7,mm5              ;       40  -- n6 = p7 - p6
    psraw      mm3,1                ; 17        -- n1 = C4*(p0-p1)
   paddw       mm6,mm6              ;   21      -- 2p5
    psraw      mm2,1                ; 18        -- n0 = C4*(p0+p1)
   movq        [edi+4*8*2],mm3      ; 19        -- Save n1             (stage 3)
    movq       mm3,mm0              ;     32    -- Copy scaled p3
   movq        [edi+0*8*2],mm2      ; 1a        -- Save n0             (stage 3)
    movq       mm2,mm1              ;     33    -- Copy scaled p2
   pmulhw      mm0,PD C2            ;     34    -- C2*p3 scaled
    paddw      mm5,mm5              ;       41  -- 2p6
   pmulhw      mm1,PD C6            ;     35    -- C6*p2 scaled
    paddw      mm6,mm4              ;   22      -- n4 = p4 + p5
   pmulhw      mm3,PD C6            ;     36    -- C6*p3 scaled
    paddw      mm5,mm7              ;       42  -- n7 = p7 + p6
   pmulhw      mm2,PD C2            ;     37    -- C2*p2 scaled
    psllw      mm5,2                ; 10        -- scale n7            (stage 3)
   paddw       mm0,mm1              ;     38    -- C2*p3 + C6*p2 scaled
    psllw      mm7,2                ;   20      -- scale n6            (stage 3)
   movq        mm1,mm5              ; 11        -- copy scaled n7      (stage 3)
    psraw      mm0,1                ;     39    -- n2 = C2*p3 + C6*p2
   pmulhw      mm5,PD C1            ; 12        -- C1*n7 scaled        (stage 3)
    psllw      mm6,2                ; 13        -- scale n4            (stage 3)
   movq        [edi+2*8*2],mm0      ;     3c    -- Save n2             (stage 3)
    psubw      mm3,mm2              ;     3a    -- C6*p3 - C2*p2 scaled

; ++ ========================================================================
; The StageThree macro performs a butterfly on the scaled rows n4,n7 and
; n5,n6 such that:
;               m4 = C7*n4+C1*n7,  m7 = C7*n7-C1*n4
;               m5 = C5*n6+C3*n5,  m6 = C3*n6-C5*n5
; Steps 10 -> 1f determine m4,m7 and 20 -> 2f determine m5,m6.
; The outputs m0-m7 are put into reverse binary order as follows:
;               0 = 000  ->  000 = 0
;               1 = 001  ->  100 = 4
;               2 = 010  ->  010 = 2
;               3 = 011  ->  110 = 6
;               4 = 100  ->  001 = 1
;               5 = 101  ->  101 = 5
;               6 = 110  ->  011 = 3
;               7 = 111  ->  111 = 7
; -- ========================================================================

   pmulhw      mm1,PD C7            ; 14        -- C7*n7 scaled
    movq       mm0,mm6              ; 15        -- copy scaled n4
   pmulhw      mm6,PD C7            ; 16        -- C7*n4 scaled
    psraw      mm3,1                ;     3b    -- n3 = C6*p6 - C2*p2
   pmulhw      mm0,PD C1            ; 17        -- C1*n4 scaled
    movq       mm2,mm7              ;   21      -- copy scaled n6
   movq        [edi+6*8*2],mm3      ;     3d    -- Save n3
    psllw      mm4,2                ;   22      -- scale n5
   pmulhw      mm7,PD C5            ;   23      -- C5*n6 scaled
    movq       mm3,mm4              ;   24      -- copy scaled n5
   pmulhw      mm4,PD C3            ;   25      -- C3*n5 scaled
    paddw      mm5,mm6              ; 18        -- C7*n4+C1*n7 scaled
   pmulhw      mm2,PD C3            ;   26      -- C3*n6 scaled
    psubw      mm1,mm0              ; 19        -- C7*n7-C1*n4 scaled
   pmulhw      mm3,PD C5            ;   27      -- C5*n5 scaled
    psraw      mm5,1                ; 1a        -- m4 = C7*n4+C1*n7
   paddw       mm7,mm4              ;   28      -- C5*n6+C3*n5 scaled
    psraw      mm1,1                ; 1b        -- m7 = C7*n7-C1*n4
   movq        [edi+1*8*2],mm5      ; 1c        -- Save m4
    psraw      mm7,1                ;   29      -- m5 = C5*n6+C3*n5
   movq        [edi+7*8*2],mm1      ; 1d        -- Save m7
    psubw      mm2,mm3              ;   2a      -- C3*n6-C5*n5 scaled
   movq        [edi+5*8*2],mm7      ;   2b      -- Save m5
    psraw      mm2,1                ;   2c      -- m6 = C3*n6-C5*n5
    dec        esi
   movq        [edi+3*8*2],mm2      ;   2d      -- Save m6
    ;
   lea         edi,[edi+8]
    jne        RepeatSecondTransform

   mov         ebp,PITCH
    jmp        MMxQuantRLE

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exmme.asm ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\exmme.asv   1.37   13 Dec 1996 17:19:38   MBODART  $
;//
;// $Log:   S:\h26x\src\enc\exmme.asv  $
;// 
;//    Rev 1.37   13 Dec 1996 17:19:38   MBODART
;// Tuned the ME parameters for H.261.
;// 
;//    Rev 1.36   06 Nov 1996 16:18:24   BNICKERS
;// Improve performance.
;// 
;//    Rev 1.35   30 Oct 1996 17:30:36   BNICKERS
;// Fix UMV table for right edge macroblocks.
;// 
;//    Rev 1.34   30 Oct 1996 14:49:20   KLILLEVO
;// zero motion vectors for intra blocks in PB-frame mode.
;// This is necesseary in the Extended Motion Vector mode
;// 
;//    Rev 1.33   18 Oct 1996 16:57:16   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.32   15 Oct 1996 17:53:04   BNICKERS
;// 
;// Fix major bug w.r.t. EMV ME.
;// 
;//    Rev 1.31   14 Oct 1996 13:10:14   BNICKERS
;// 
;// Correct several problems wrt H261 ME.
;// 
;//    Rev 1.30   11 Oct 1996 16:53:12   KLILLEVO
;// 
;// Fix threshold
;// 
;//    Rev 1.29   11 Oct 1996 16:52:18   KLILLEVO
;// Another EMV fix.
;// 
;//    Rev 1.28   11 Oct 1996 15:43:16   KLILLEVO
;// Really fix the handling of the top row of MBs for EMV ME.
;// 
;//    Rev 1.27   11 Oct 1996 15:24:38   BNICKERS
;// Special handling of top row of MBs for EMV ME.
;// 
;//    Rev 1.26   11 Oct 1996 14:47:42   KLILLEVO
;// Kill full pel MV for Intra blocks so that EMV of adjacent blocks will work.
;// 
;//    Rev 1.25   10 Oct 1996 16:42:56   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.24   04 Oct 1996 08:48:02   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.23   24 Sep 1996 10:42:24   BNICKERS
;// For H261, zero out motion vectors when classifying MB as intra.
;// 
;//    Rev 1.22   12 Sep 1996 10:56:24   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.21   22 Jul 1996 15:23:24   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.20   18 Jul 1996 16:54:26   KLILLEVO
;// changed emptythreshold to 40 instead of 128 to remove some blockiness
;// from the still frame mode on MMX
;// 
;//    Rev 1.19   26 Jun 1996 12:49:02   KLILLEVO
;// Fix minor booboo left in by Brian.
;// 
;//    Rev 1.18   26 Jun 1996 12:21:50   BNICKERS
;// Make heuristic ME work without unrestricted motion vectors.
;// 
;//    Rev 1.17   25 Jun 1996 14:24:58   BNICKERS
;// Implement heuristic motion estimation for MMX, AP mode.
;// 
;//    Rev 1.16   15 May 1996 16:57:14   BNICKERS
;// Fix SWD tabulation (again)! @#$%!%
;// 
;//    Rev 1.15   15 May 1996 16:53:24   BNICKERS
;// 
;// Fix SWD tabulation.
;// 
;//    Rev 1.14   15 May 1996 11:33:28   BNICKERS
;// Bug fix for calc of total SWD.
;// 
;//    Rev 1.13   14 May 1996 12:18:58   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.12   03 May 1996 14:03:50   BNICKERS
;// 
;// Minor bug fixes and integration refinements.
;// 
;//    Rev 1.11   02 May 1996 12:00:32   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.10   16 Apr 1996 16:40:14   BNICKERS
;// Fix some important but simple bugs.  Start adding table inits for B frm ME.
;// 
;//    Rev 1.9   10 Apr 1996 13:13:44   BNICKERS
;// Recoding of Motion Estimation, Advanced Prediction.
;// 
;//    Rev 1.8   05 Apr 1996 12:28:10   BNICKERS
;// Improvements to baseline half pel ME.
;// 
;//    Rev 1.7   26 Mar 1996 12:00:22   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.6   20 Mar 1996 17:01:44   KLILLEVO
;// fixed bug in new quant code
;// 
;//    Rev 1.5   20 Mar 1996 15:26:40   KLILLEVO
;// changed quantization to match IA quantization
;// 
;//    Rev 1.3   15 Mar 1996 15:51:16   BECHOLS
;// Completed monolithic - Brian
;// 
;//    Rev 1.0   16 Feb 1996 17:12:12   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; MMxMotionEstimation -- This function performs motion estimation for the
;                        macroblocks identified in the input list.  This is
;                        the MMx version.  Conditional assembly selects either
;                        the H263 or H261 version.
;
; Arguments:   See ex5me.asm.
;
; Other assumptions:  See ex5me.asm.  Most of the read-only tables needed in
;                     ex5me.asm are not needed here.
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510
OPTION CASEMAP:NONE

IFDEF H261
ZEROVECTORTHRESHOLD          =  600
NONZEROMVDIFFERENTIAL        =  256
BLOCKMOTIONTHRESHOLD         = 1152
BLOCKMVDIFFERENTIAL          =  768
EMPTYTHRESHOLD               =   40
INTERCODINGTHRESHOLD         =  300
INTRACODINGDIFFERENTIAL      =  200
ELSE
ZEROVECTORTHRESHOLD          =  450
NONZEROMVDIFFERENTIAL        =  375
BLOCKMOTIONTHRESHOLD         = 1152
BLOCKMVDIFFERENTIAL          =  768
EMPTYTHRESHOLD               =   40
INTERCODINGTHRESHOLD         = 1152
INTRACODINGDIFFERENTIAL      = 1000
ENDIF

include iammx.inc
include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list

include exEDTQ.inc

MMXMEDATA SEGMENT PAGE
ALIGN 16

;  Storage for Target and Reference frames can interleave into 8K of the 16K
;  cache.  Pitch must be 384.
;
;     C# -- Stands for row number "#" of target macroblock in *C*urrent P frame.
;     B# -- Stands for row number "#" of target macroblock in current *B* frame.
;     R# -- Stands for row number "#" of 0MV *R*ef macroblock in past frame.
;     v  -- Stands for a row below 0MV, reference macroblock.
;           These same cache lines would hit reference lines >8 above the 0MV.
;     ^  -- Stands for a row below 0MV, reference macroblock.
;           These same cache lines would hit reference lines >8 below the 0MV.
;     +-+-+
;     |   | -- A cache line (32 bytes).  Position of letters,<, and > indicate
;     +-+-+    which 16 bytes may be used in the cache line.
;
;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
;     |C0 |   |  v|   |Cb |   |  ^|   |B6 |   | R6|   |
;     |C1 |   |  v|   |Cc |   |  ^|   |B7 |   | R7|   |
;     |C2 |   |  v|   |Cd |   |  ^|   |B8 |   | R8|   |
;     |C3 |   |  v|   |Ce |   |  ^|   |B9 |   | R9|   |
;     |C4 |   |  v|   |Cf |   |  ^|   |Ba |   | Ra|   |
;     |C5 |   |  v|   |B0 |   | R0|   |Bb |   | Rb|   |
;     |C6 |   |  v|   |B1 |   | R1|   |Bc |   | Rc|   |
;     |C7 |   |  v|   |B2 |   | R2|   |Bd |   | Rd|   |
;     |C8 |   |  ^|   |B3 |   | R3|   |Be |   | Re|   |
;     |C9 |   |  ^|   |B4 |   | R4|   |Bf |   | Rf|   |
;     |Ca |   |  ^|   |B5 |   | R5|   +-+-+-+-+-+-+-+-+
;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
;

; The static storage space used for read-only tables, and the stack usage
; are coordinated such that they mesh in the data cache, and use only one
; 4K way of the 4-way, 16K cache.
;
; The first 32 bytes of the static storage space are unallocated, because
; the top of stack ranges in this area.  As local procedure calls are made
; within this function, return addresses get pushed into these 32 bytes.
; (32 bytes;    0:  31)

  DB 32 DUP (?)   ; Static space place-holder.  Stack frame hits these addrs.

;
; The next 608 bytes of the static storage space are unallocated, because
; the local stack frame is made to hit cache at these addresses.  More of
; the local stack frame is allocated after a gap of 64 bytes.
; (608 bytes;   32: 639)

LocalStorage LABEL DWORD 

  DB 608 DUP (?)   ; Static space place-holder.  Stack frame hits these addrs.

; Motion Estimation State Engine adjustments to reference block address to get
; to next candidate reference block.
; (64 bytes; 640: 703)

FullPelMotionVectorAdjustment LABEL DWORD

        DD   -16*PITCH-8
VMG     EQU  000H+0+8
VMGHM8  EQU  000H-8+8

        DD   -8*PITCH-8-010H
VM8HM8  EQU  010H

        DD   -8*PITCH-020H
VM8     EQU  020H
VM8HP8  EQU  020H+8

        DD   -4*PITCH-8-030H
VM4HM8  EQU  030H-8+8
VM4HM4  EQU  030H-4+8
VM4     EQU  030H+0+8
VM4HP4  EQU  030H+4+8

        DD   -4*PITCH+8-040H
VM4HP8  EQU  040H+8-8
VM4HPG  EQU  040H+16-8

        DD   -2*PITCH-4-050H
VM2HM4  EQU  050H-4+4
VM2HM2  EQU  050H-2+4
VM2HM1  EQU  050H-1+4
VM2     EQU  050H+0+4
VM2HP1  EQU  050H+1+4
VM2HP2  EQU  050H+2+4
VM2HP4  EQU  050H+4+4
VM2HP8  EQU  050H+8+4

        DD   -1*PITCH-2-060H
VM1HM2  EQU  060H-2+2
VM1HM1  EQU  060H-1+2
VM1     EQU  060H+0+2
VM1HP1  EQU  060H+1+2
VM1HP2  EQU  060H+2+2
VM1HP4  EQU  060H+4+2

        DD   -16-070H
HMG     EQU  070H-16+16
HM8     EQU  070H-8+16
HM4     EQU  070H-4+16
HM3     EQU  070H-3+16
HM2     EQU  070H-2+16
HM1     EQU  070H-1+16

        DD   -080H
NOADJ   EQU  080H
HP1     EQU  080H+1
HP2     EQU  080H+2
HP4     EQU  080H+4
HP8     EQU  080H+8

        DD   1*PITCH-2-090H
VP1HM2  EQU  090H-2+2
VP1HM1  EQU  090H-1+2
VP1     EQU  090H+0+2
VP1HP1  EQU  090H+1+2
VP1HP2  EQU  090H+2+2
VP1HP4  EQU  090H+4+2

        DD   2*PITCH-4-0A0H
VP2HM4  EQU  0A0H-4+4
VP2HM2  EQU  0A0H-2+4
VP2HM1  EQU  0A0H-1+4
VP2     EQU  0A0H+0+4
VP2HP1  EQU  0A0H+1+4
VP2HP2  EQU  0A0H+2+4
VP2HP4  EQU  0A0H+4+4
VP2HP8  EQU  0A0H+8+4

        DD   4*PITCH-8-0B0H
VP4HM8  EQU  0B0H-8+8
VP4HM4  EQU  0B0H-4+8
VP4HM2  EQU  0B0H-2+8
VP4     EQU  0B0H+0+8
VP4HP2  EQU  0B0H+2+8
VP4HP4  EQU  0B0H+4+8

        DD   4*PITCH+8-0C0H
VP4HP8  EQU  0C0H+8-8
VP4HPG  EQU  0C0H+16-8

        DD   8*PITCH-8-0D0H
VP8HM8  EQU  0D0H-8+8
VP8HM4  EQU  0D0H-4+8

        DD   8*PITCH-0E0H
VP8     EQU  0E0H+0
VP8HP4  EQU  0E0H+4
VP8HP8  EQU  0E0H+8

        DD   16*PITCH-0F0H
VPG     EQU  0F0H+0
VPGHP8  EQU  0F0H+8

; Additional space reserved for stack variables.  If more space is needed,
; it should go here.
; (160 bytes; 704: 863)

  DB 160 DUP (?)   ; Static space place-holder.  Stack frame hits these addrs.

; QWORD Constants used by motion estimation, frame differencing, and FDCT.
; (144 bytes;   864:1007)

C0101010101010101 DD 001010101H, 001010101H
CFFFF0000FFFF0000 DD 0FFFF0000H, 0FFFF0000H
C0200010101010101 DD 001010101H, 002000101H
C0001000200020001 DD 000020001H, 000010002H
CFFFF00000000FFFF DD 00000FFFFH, 0FFFF0000H
C0000FFFFFFFF0000 DD 0FFFF0000H, 00000FFFFH
CFF000000000000FF DD 0000000FFH, 0FF000000H
C0101010101010002 DD 001010002H, 001010101H
C0100010001000100 DD 001000100H, 001000100H
C0001000100010001 DD 000010001H, 000010001H
C7F7F7F7F7F7F7F7F DD 07F7F7F7FH, 07F7F7F7FH
C1                DD 07D8A7D8AH, 07D8A7D8AH
C2                DD 076417641H, 076417641H
C3                DD 06A6D6A6DH, 06A6D6A6DH
C4                DD 05A825A82H, 05A825A82H
C5                DD 0471D471DH, 0471D471DH
C6                DD 030FC30FCH, 030FC30FCH
C7                DD 018F818F8H, 018F818F8H

; Distances to Block Action Descriptors for blocks that provide remote vectors
; for OBMC.  Which element accessed depends on edge condition.  Top edge is
; stack based variable, since different instances may have different distances
; to BAD of block above.  Bottom edge is always a constant, regardless of
; edge condition.  This is used in OBMC frame differencing.
; (16 bytes; 1008:1023)

BlockToLeft  DD 0, -SIZEOF T_MacroBlockActionDescr+SIZEOF T_Blk
BlockToRight DD 0,  SIZEOF T_MacroBlockActionDescr-SIZEOF T_Blk

; Table to map linearized motion vector to vertical part, used by motion
; estimation.  (Shift linearized motion vector right by 8 bits, and then
; use result as index into this array to get vertical MV.)
; (96 bytes; 1024:1119)

IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
   DB -64, -64
   DB -62
   DB -60, -60
   DB -58
   DB -56, -56
   DB -54
   DB -52, -52
   DB -50
   DB -48, -48
   DB -46
   DB -44, -44
   DB -42
   DB -40, -40
   DB -38
   DB -36, -36
   DB -34
   DB -32, -32
   DB -30
   DB -28, -28
   DB -26
   DB -24, -24
   DB -22
   DB -20, -20
   DB -18
   DB -16, -16
   DB -14
   DB -12, -12
   DB -10
   DB  -8,  -8
   DB  -6
   DB  -4,  -4
   DB  -2
   DB   0
UnlinearizedVertMV  DB 0
   DB   2
   DB   4,   4
   DB   6
   DB   8,   8
   DB  10
   DB  12,  12
   DB  14
   DB  16,  16
   DB  18
   DB  20,  20
   DB  22
   DB  24,  24
   DB  26
   DB  28,  28
   DB  30
   DB  32,  32
   DB  34
   DB  36,  36
   DB  38
   DB  40,  40
   DB  42
   DB  44,  44
   DB  46
   DB  48,  48
   DB  50
   DB  52,  52
   DB  54
   DB  56,  56
   DB  58
   DB  60,  60
   DB  62
; Table to provide index value in low byte, and rounding term of 1 in all bytes.
; Used in frame differencing, when half pel horizontal interpolation is needed.
; (1024 bytes; 1120:2143)

Pel_Rnd LABEL DWORD
CNT = 0
REPEAT 128
 DD CNT+001010101H, 001010101H
 CNT = CNT + 1
ENDM

; Motion Estimation State Engine Rules.
; (896 bytes;2144:3039)

StateEngineFirstRule LABEL BYTE ; Rules that govern state engine of estimator.
StateEngine EQU StateEngineFirstRule-20+2

   ; Starting States:

IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
 DB       ?      ;  0:  not used.
 DB       3      ;  1: Upper left corner.
 DB       3      ;  2: Upper edge.
 DB       3      ;  3: Upper right corner.
 DB       3      ;  4: Left edge.
 DB       3      ;  5: Interior MB, not doing block search.
 DB       0      ;  6: Right edge.
 DB       0      ;  7: Lower left corner.
 DB       0      ;  8: Lower edge.
 DB       0      ;  9: Lower right corner.

 DB       ?      ;  0:  not used.
 DB      34      ;  1: Upper left corner.
 DB      66      ;  2: Upper edge.
 DB      42      ;  3: Upper right corner.
 DB      98      ;  4: Left edge.
 DB      16      ;  5: Interior MB, not doing block search.
 DB     114      ;  6: Right edge.
 DB      50      ;  7: Lower left corner.
 DB      82      ;  8: Lower edge.
 DB      58      ;  9: Lower right corner.

 DB     ?,?      ; Skip 2 bytes.

LASTINITIALMESTATE EQU 9

   ; Interior Telescoping States:

      ;  Try +/- 8,4,2,1, vertically first, then horizontally.

FIRSTBLOCKMESTATE EQU 10

 DB     VM2,    VM2,   12,   11  ;  10: V+1 better/worse than central.  Try V-1.
 DB  VP2HP1,    HP1,   13,   13  ;  11: Accept V+1/V-1 as best.         Try H+1.
 DB  VP1HP1,    HP1,   13,   13  ;  12: Accept central/V-1 as best.     Try H+1.
 DB     HM2,    HM2,   15,   14  ;  13: H+1 better/worse than central.  Try H-1.
 DB     HP2,  NOADJ, 0FFH, 0FFH  ;  14: Accept H+1/H-1 as best.         Done.
 DB     HP1,  NOADJ, 0FFH, 0FFH  ;  15: Accept central/H-1 as best.     Done.

 DB     VMG,    VMG,   18,   17  ;  16: V+8 better/worse than central.  Try V-8.
 DB  VPGHP8,    HP8,   19,   19  ;  17: Accept V+8/V-8 as best.         Try H+8.
 DB  VP8HP8,    HP8,   19,   19  ;  18: Accept central/V-8 as best.     Try H+8.
 DB     HMG,    HMG,   21,   20  ;  19: H+8 better/worse than central.  Try H-8.
 DB  VP4HPG,    VP4,   22,   22  ;  20: Accept H+8/H-8 as best.         Try V+4.
 DB  VP4HP8,    VP4,   22,   22  ;  21: Accept central/H-8 as best.     Try V+4.

 DB     VM8,    VM8,   24,   23  ;  22: V+4 better/worse than central.  Try V-4.
 DB  VP8HP4,    HP4,   25,   25  ;  23: Accept V+4/V-4 as best.         Try H+4.
 DB  VP4HP4,    HP4,   25,   25  ;  24: Accept central/V-4 as best.     Try H+4.
 DB     HM8,    HM8,   27,   26  ;  25: H+4 better/worse than central.  Try H-4.
 DB  VP2HP8,    VP2,   28,   28  ;  26: Accept H+4/H-4 as best.         Try V+2.
 DB  VP2HP4,    VP2,   28,   28  ;  27: Accept central/H-4 as best.     Try V+2.

 DB     VM4,    VM4,   30,   29  ;  28: V+2 better/worse than central.  Try V-2.
 DB  VP4HP2,    HP2,   31,   31  ;  29: Accept V+2/V-2 as best.         Try H+2.
 DB  VP2HP2,    HP2,   31,   31  ;  30: Accept central/V-2 as best.     Try H+2.
 DB     HM4,    HM4,   33,   32  ;  31: H+2 better/worse than central.  Try H-2.
 DB  VP1HP4,    VP1,   10,   10  ;  32: Accept H+2/H-2 as best.         Try V+1.
 DB  VP1HP2,    VP1,   10,   10  ;  33: Accept central/H-2 as best.     Try V+1.

   ; Boundary States:

     ; Upper left corner:

 DB  VM8HP8,    HP8,   35,  101  ;  34: Accept corner/V+8.              Try H+8.
 DB  VP4HM8,    VP4,   36,   70  ;  35: Accept corner/H+8.              Try V+4.
 DB  VM4HP4,    HP4,   37,  105  ;  36: Accept corner/V+4.              Try H+4.
 DB  VP2HM4,    VP2,   38,   74  ;  37: Accept corner/H+4.              Try V+2.
 DB  VM2HP2,    HP2,   39,  109  ;  38: Accept corner/V+2.              Try H+2.
 DB  VP1HM2,    VP1,   40,   78  ;  39: Accept corner/H+2.              Try V+1.
 DB  VM1HP1,    HP1,   41,  113  ;  40: Accept corner/V+1.              Try H+1.
 DB     HM1,  NOADJ, 0F5H, 0F7H  ;  41: Accept corner/H+1.              Done.

     ; Upper right corner:

 DB  VM8HM8,    HM8,   43,  117  ;  42: Accept corner/V+8.              Try H-8.
 DB  VP4HP8,    VP4,   44,   70  ;  43: Accept corner/H-8.              Try V+4.
 DB  VM4HM4,    HM4,   45,  121  ;  44: Accept corner/V+4.              Try H-4.
 DB  VP2HP4,    VP2,   46,   74  ;  45: Accept corner/H-4.              Try V+2.
 DB  VM2HM2,    HM2,   47,  125  ;  46: Accept corner/V+2.              Try H-2.
 DB  VP1HP2,    VP1,   48,   78  ;  47: Accept corner/H-2.              Try V+1.
 DB  VM1HM1,    HM1,   49,  129  ;  48: Accept corner/V+1.              Try H-1.
 DB     HP1,  NOADJ, 0F6H, 0F7H  ;  49: Accept corner/H-1.              Done

     ; Lower left corner:

 DB  VP8HP8,    HP8,   51,  101  ;  50: Accept corner/V-8.              Try H+8.
 DB  VM4HM8,    VM4,   52,   86  ;  51: Accept corner/H+8.              Try V-4.
 DB  VP4HP4,    HP4,   53,  105  ;  52: Accept corner/V-4.              Try H+4.
 DB  VM2HM4,    VM2,   54,   90  ;  53: Accept corner/H+4.              Try V-2.
 DB  VP2HP2,    HP2,   55,  109  ;  54: Accept corner/V-2.              Try H+2.
 DB  VM1HM2,    VM1,   56,   94  ;  55: Accept corner/H+2.              Try V-1.
 DB  VP1HP1,    HP1,   57,  113  ;  56: Accept corner/V-1.              Try H+1.
 DB     HM1,  NOADJ, 0F9H, 0FBH  ;  57: Accept corner/H+1.              Done.

     ; Lower right corner:

 DB  VP8HM8,    HM8,   59,  117  ;  58: Accept corner/V-8.              Try H-8.
 DB  VM4HP8,    VM4,   60,   86  ;  59: Accept corner/H-8.              Try V-4.
 DB  VP4HM4,    HM4,   61,  121  ;  60: Accept corner/V-4.              Try H-4.
 DB  VM2HP4,    VM2,   62,   90  ;  61: Accept corner/H-4.              Try V-2.
 DB  VP2HM2,    HM2,   63,  125  ;  62: Accept corner/V-2.              Try H-2.
 DB  VM1HP2,    VM1,   64,   94  ;  63: Accept corner/H-2.              Try V-1.
 DB  VP1HM1,    HM1,   65,  129  ;  64: Accept corner/V-1.              Try H-1.
 DB     HP1,  NOADJ, 0FAH, 0FBH  ;  65: Accept corner/H-1.              Done.

     ; Upper edge:

 DB  VM8HP8,    HP8,   67,   19  ;  66: Accept central/V+8 as best.     Try H+8.
 DB     HMG,    HMG,   69,   68  ;  67: H+8 worse/better than central.  Try H-8.
 DB  VP4HPG,    VP4,   70,   70  ;  68: Accept H+8/H-8 as best.         Try V+4.
 DB  VP4HP8,    VP4,   70,   70  ;  69: Accept central/H-8 as best.     Try V+4.
 DB  VM4HP4,    HP4,   71,   25  ;  70: Accept central/V+4 as best.     Try H+4.
 DB     HM8,    HM8,   73,   72  ;  71: H+4 worse/better than central.  Try H-4.
 DB  VP2HP8,    VP2,   74,   74  ;  72: Accept H+4/H-4 as best.         Try V+2.
 DB  VP2HP4,    VP2,   74,   74  ;  73: Accept central/H-4 as best.     Try V+2.
 DB  VM2HP2,    HP2,   75,   31  ;  74: Accept central/V+2 as best.     Try H+2.
 DB     HM4,    HM4,   77,   76  ;  75: H+2 worse/better than central.  Try H-2.
 DB  VP1HP4,    VP1,   78,   78  ;  76: Accept H+2/H-2 as best.         Try V+1.
 DB  VP1HP2,    VP1,   78,   78  ;  77: Accept central/H-2 as best.     Try V+1.
 DB  VM1HP1,    HP1,   79,   13  ;  78: Accept central/V+1 as best.     Try H+1.
 DB     HM2,    HM2,   81,   80  ;  79: H+1 worse/better than central.  Try H-1.
 DB     HP2,  NOADJ, 0F7H, 0F7H  ;  80: Accept H+1/H-1 as best.         Done.
 DB     HP1,  NOADJ, 0F7H, 0F7H  ;  81: Accept central/H-1 as best.     Done.

     ; Lower edge:

 DB  VP8HP8,    HP8,   83,   19  ;  82: Accept central/V-8 as best.     Try H+8.
 DB     HMG,    HMG,   85,   84  ;  83: H+8 worse/better than central.  Try H-8.
 DB  VM4HPG,    VM4,   86,   86  ;  84: Accept H+8/H-8 as best.         Try V-4.
 DB  VM4HP8,    VM4,   86,   86  ;  85: Accept central/H-8 as best.     Try V-4.
 DB  VP4HP4,    HP4,   87,   25  ;  86: Accept central/V-4 as best.     Try H+4.
 DB     HM8,    HM8,   89,   88  ;  87: H+4 worse/better than central.  Try H-4.
 DB  VM2HP8,    VM2,   90,   90  ;  88: Accept H+4/H-4 as best.         Try V-2.
 DB  VM2HP4,    VM2,   90,   90  ;  89: Accept central/H-4 as best.     Try V-2.
 DB  VP2HP2,    HP2,   91,   31  ;  90: Accept central/V-2 as best.     Try H+2.
 DB     HM4,    HM4,   93,   92  ;  91: H+2 worse/better than central.  Try H-2.
 DB  VM1HP4,    VM1,   94,   94  ;  92: Accept H+2/H-2 as best.         Try V-1.
 DB  VM1HP2,    VM1,   94,   94  ;  93: Accept central/H-2 as best.     Try V-1.
 DB  VP1HP1,    HP1,   95,   13  ;  94: Accept central/V-1 as best.     Try H+1.
 DB     HM2,    HM2,   97,   96  ;  95: H+1 worse/better than central.  Try H-1.
 DB     HP2,  NOADJ, 0FBH, 0FBH  ;  96: Accept H+1/H-1 as best.         Done.
 DB     HP1,  NOADJ, 0FBH, 0FBH  ;  97: Accept central/H-1 as best.     Done.

     ; Left edge:

 DB     VMG,    VMG,  100,   99  ;  98: V+8 worse/better than central.  Try V-8.
 DB  VPGHP8,    HP8,  101,  101  ;  99: Accept V+8/V-8 as best.         Try H+8.
 DB  VP8HP8,    HP8,  101,  101  ; 100: Accept central/V-8 as best.     Try H+8.
 DB  VP4HM8,    VP4,  102,   22  ; 101: Accept central/H+8 as best.     Try V+4.
 DB     VM8,    VM8,  104,  103  ; 102: V+4 worse/better than central.  Try V-4.
 DB  VP8HP4,    HP4,  105,  105  ; 103: Accept V+4/V-4 as best.         Try H+4.
 DB  VP4HP4,    HP4,  105,  105  ; 104: Accept central/V-4 as best.     Try H+4.
 DB  VP2HM4,    VP2,  106,   28  ; 105: Accept central/H+4 as best.     Try V+2.
 DB     VM4,    VM4,  108,  107  ; 106: V+2 worse/better than central.  Try V-2.
 DB  VP4HP2,    HP2,  109,  109  ; 107: Accept V+2/V-2 as best.         Try H+2.
 DB  VP2HP2,    HP2,  109,  109  ; 108: Accept central/V-2 as best.     Try H+2.
 DB  VP1HM2,    VP1,  110,   10  ; 109: Accept central/H+2 as best.     Try V+1.
 DB     VM2,    VM2,  112,  111  ; 110: V+1 worse/better than central.  Try V-1.
 DB  VP2HP1,    HP1,  113,  113  ; 111: Accept V+1/V-1 as best.         Try H+1.
 DB  VP1HP1,    HP1,  113,  113  ; 112: Accept central/V-1 as best.     Try H+1.
 DB     HM1,  NOADJ, 0FDH, 0FDH  ; 113: Accept central/H+1 as best.     Done.

     ; Right edge:

 DB     VPG,    VPG,  116,  115  ; 114: V-8 worse/better than central.  Try V+8.
 DB  VMGHM8,    HM8,  117,  117  ; 115: Accept V-8/V+8 as best.         Try H-8.
 DB  VM8HM8,    HM8,  117,  117  ; 116: Accept central/V+8 as best.     Try H-8.
 DB  VP4HP8,    VP4,  118,   22  ; 117: Accept central/H+8 as best.     Try V+4.
 DB     VM8,    VM8,  120,  119  ; 118: V+4 worse/better than central.  Try V-4.
 DB  VP8HM4,    HM4,  121,  121  ; 119: Accept V+4/V-4 as best.         Try H-4.
 DB  VP4HM4,    HM4,  121,  121  ; 120: Accept central/V-4 as best.     Try H-4.
 DB  VP2HP4,    VP2,  122,   28  ; 121: Accept central/H+4 as best.     Try V+2.
 DB     VM4,    VM4,  124,  123  ; 122: V+2 worse/better than central.  Try V-2.
 DB  VP4HM2,    HM2,  125,  125  ; 123: Accept V+2/V-2 as best.         Try H-2.
 DB  VP2HM2,    HM2,  125,  125  ; 124: Accept central/V-2 as best.     Try H-2.
 DB  VP1HP2,    VP1,  126,   10  ; 125: Accept central/H+2 as best.     Try V+1.
 DB     VM2,    VM2,  128,  127  ; 126: V+1 worse/better than central.  Try V-1.
 DB  VP2HM1,    HM1,  129,  129  ; 127: Accept V+1/V-1 as best.         Try H-1.
 DB  VP1HM1,    HM1,  129,  129  ; 128: Accept central/V-1 as best.     Try H-1.
 DB     HP1,  NOADJ, 0FEH, 0FEH  ; 129: Accept central/H+1 as best.     Done.

     ; Exhaustive search, radius 1 here, reaching out to radius 2 further below.
     ;     .   .   .   .   .
     ;     .   2   5   3   .   C = center.
     ;     .   7   C   8   .
     ;     .   4   6   1   .   # = order to try additional candidates.
     ;     .   .   .   .   .

FIRST_HEURISTIC_EXHAUSTIVE = 130

 DB  VM2HM2, VM2HM2,  131, 138 ; 130: #1 worse/better than  C. Try #2.
 DB     HP2,    HP2,  132, 145 ; 131: #2 worse/better than  C. Try #3.
 DB  VP2HM2, VP2HM2,  133, 151 ; 132: #3 worse/better than  C. Try #4.
 DB  VM2HP1, VM2HP1,  134, 156 ; 133: #4 worse/better than  C. Try #5.
 DB     VP2,    VP2,  135, 160 ; 134: #5 worse/better than  C. Try #6.
 DB  VM1HM1, VM1HM1,  136, 163 ; 135: #6 worse/better than  C. Try #7.
 DB     HP2,    HP2,  137, 165 ; 136: #7 worse/better than  C. Try #8.
 DB     HM1,    HP1, 0FFH, 166 ; 137: If C best, quit.  If 8 best, keep going.
 DB     HP2,    HP2,  139, 145 ; 138: #2 worse/better than #1. Try #3.
 DB  VP2HM2, VP2HM2,  140, 151 ; 139: #3 worse/better than #1. Try #4.
 DB  VM2HP1, VM2HP1,  141, 156 ; 140: #4 worse/better than #1. Try #5.
 DB     VP2,    VP2,  142, 160 ; 141: #5 worse/better than #1. Try #6.
 DB  VM1HM1, VM1HM1,  143, 163 ; 142: #6 worse/better than #1. Try #7.
 DB     HP2,    HP2,  144, 165 ; 143: #7 worse/better than #1. Try #8.
 DB     HP1,    HP1,  199, 166 ; 144: #8 worse/better than #1. Take best, go on.
 DB  VP2HM2, VP2HM2,  146, 151 ; 145: #3 worse/better than #2. Try #4.
 DB  VM2HP1, VM2HP1,  147, 156 ; 146: #4 worse/better than #2. Try #5.
 DB     VP2,    VP2,  148, 160 ; 147: #5 worse/better than #2. Try #6.
 DB  VM1HM1, VM1HM1,  149, 163 ; 148: #6 worse/better than #2. Try #7.
 DB     HP2,    HP2,  150, 165 ; 149: #7 worse/better than #2. Try #8.
 DB     HM3,    HP1,  208, 166 ; 150: #8 worse/better than #2. Take best, go on.
 DB  VM2HP1, VM2HP1,  152, 156 ; 151: #4 worse/better than #3. Try #5.
 DB     VP2,    VP2,  153, 160 ; 152: #5 worse/better than #3. Try #6.
 DB  VM1HM1, VM1HM1,  154, 163 ; 153: #6 worse/better than #3. Try #7.
 DB     HP2,    HP2,  155, 165 ; 154: #7 worse/better than #3. Try #8.
 DB     HP1,    HP1,  217, 166 ; 155: #8 worse/better than #3. Take best, go on.
 DB     VP2,    VP2,  157, 160 ; 156: #5 worse/better than #4. Try #6.
 DB  VM1HM1, VM1HM1,  158, 163 ; 157: #6 worse/better than #4. Try #7.
 DB     HP2,    HP2,  159, 165 ; 158: #7 worse/better than #4. Try #8.
 DB     HM3,    HP1,  190, 166 ; 159: #8 worse/better than #4. Take best, go on.
 DB  VM1HM1, VM1HM1,  161, 163 ; 160: #6 worse/better than #5. Try #7.
 DB     HP2,    HP2,  162, 165 ; 161: #7 worse/better than #5. Try #8.
 DB  VM2HM1,    HP1,  184, 166 ; 162: #8 worse/better than #5. Take best, go on.
 DB     HP2,    HP2,  164, 165 ; 163: #7 worse/better than #6. Try #8.
 DB  VP2HM1,    HP1,  176, 166 ; 164: #8 worse/better than #6. Take best, go on.
 DB     HM3,    HP1,  172, 166 ; 165: #8 worse/better than #7. Take best, go on.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   2   ~ = tried, but not as good.
     ;     .   ~   C   X   1   X = best so far.
     ;     .   ~   ~   ~   3   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  167, 169 ; 166: #1 better/worse than  X.  Try #2.
 DB     VP2,    VP2,  168, 171 ; 167: #2 better/worse than  X.  Try #3.
 DB  VM1HM1,  NOADJ, 0FFH,0FFH ; 168: #3 better/worse than  X.  Take best, quit.
 DB     VP2,    VP2,  170, 171 ; 169: #2 better/worse than #1.  Try #3.
 DB     VM1,  NOADJ, 0FFH,0FFH ; 170: #3 better/worse than #1.  Take best, quit.
 DB     VM2,  NOADJ, 0FFH,0FFH ; 171: #3 better/worse than #2.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     2   ~   ~   ~   .   ~ = tried, but not as good.
     ;     1   X   C   ~   .   X = best so far.
     ;     3   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  173, 175 ; 172: #1 better/worse than  X.  Try #2.
 DB     VP2,    VP2,  174, 177 ; 173: #2 better/worse than  X.  Try #3.
 DB  VM1HP1,  NOADJ, 0FFH,0FFH ; 174: #3 better/worse than  X.  Take best, quit.
 DB     VP2,    VP2,  176, 177 ; 175: #2 better/worse than #1.  Try #3.
 DB     VM1,  NOADJ, 0FFH,0FFH ; 176: #3 better/worse than #1.  Take best, quit.
 DB     VM2,  NOADJ, 0FFH,0FFH ; 177: #3 better/worse than #2.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   .   ~ = tried, but not as good.
     ;     .   ~   C   ~   .   X = best so far.
     ;     .   ~   X   ~   .   # = order to try additional candidates.
     ;     .   2   1   3   .

 DB     HM1,    HM1,  179, 181 ; 178: #1 better/worse than  X.  Try #2.
 DB     HP2,    HP2,  180, 183 ; 179: #2 better/worse than  X.  Try #3.
 DB  VM1HM1,  NOADJ, 0FFH,0FFH ; 180: #3 better/worse than  X.  Take best, quit.
 DB     HP2,    HP2,  182, 183 ; 181: #2 better/worse than #1.  Try #3.
 DB     HM1,  NOADJ, 0FFH,0FFH ; 182: #3 better/worse than #1.  Take best, quit.
 DB     HM2,  NOADJ, 0FFH,0FFH ; 183: #3 better/worse than #2.  Take best, quit.

     ;     .   2   1   3   .   C = center.
     ;     .   ~   X   ~   .   ~ = tried, but not as good.
     ;     .   ~   C   ~   .   X = best so far.
     ;     .   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     HM1,    HM1,  185, 187 ; 184: #1 better/worse than  X.  Try #2.
 DB     HP2,    HP2,  186, 189 ; 185: #2 better/worse than  X.  Try #3.
 DB  VP1HM1,  NOADJ, 0FFH,0FFH ; 186: #3 better/worse than  X.  Take best, quit.
 DB     HP2,    HP2,  188, 189 ; 187: #2 better/worse than #1.  Try #3.
 DB     HM1,  NOADJ, 0FFH,0FFH ; 188: #3 better/worse than #1.  Take best, quit.
 DB     HM2,  NOADJ, 0FFH,0FFH ; 189: #3 better/worse than #2.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   .   ~ = tried, but not as good.
     ;     1   ~   C   ~   .   X = best so far.
     ;     2   X   ~   ~   .   # = order to try additional candidates.
     ;     4   3   5   .   .

 DB     VP1,    VP1,  191, 195 ; 190: #1 better/worse than  X.  Try #2.
 DB  VP1HP1, VP1HP1,  178, 192 ; 191: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  193, 181 ; 192: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  194, 183 ; 193: #4 better/worse than #2.  Try #5.
 DB  VM1HM2,  NOADJ, 0FFH,0FFH ; 194: #5 better/worse than #2.  Take best, quit.
 DB  VP1HP1, VP1HP1,  196, 192 ; 195: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  197, 181 ; 196: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  198, 183 ; 197: #4 better/worse than #1.  Try #5.
 DB  VM2HM2,  NOADJ, 0FFH,0FFH ; 198: #5 better/worse than #1.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   .   ~ = tried, but not as good.
     ;     .   ~   C   ~   1   X = best so far.
     ;     .   ~   ~   X   2   # = order to try additional candidates.
     ;     .   .   4   3   5

 DB     VP1,    VP1,  200, 204 ; 199: #1 better/worse than  X.  Try #2.
 DB  VP1HM1, VP1HM1,  178, 201 ; 200: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  202, 181 ; 201: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  203, 183 ; 202: #4 better/worse than #2.  Try #5.
 DB     VM1,  NOADJ, 0FFH,0FFH ; 203: #5 better/worse than #2.  Take best, quit.
 DB  VP1HM1, VP1HM1,  205, 201 ; 204: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  206, 181 ; 205: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  207, 183 ; 206: #4 better/worse than #1.  Try #5.
 DB     VM2,  NOADJ, 0FFH,0FFH ; 207: #5 better/worse than #1.  Take best, quit.

     ;     4   3   5   .   .   C = center.
     ;     2   X   ~   ~   .   ~ = tried, but not as good.
     ;     1   ~   C   ~   .   X = best so far.
     ;     .   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  209, 213 ; 208: #1 better/worse than  X.  Try #2.
 DB  VM1HP1, VM1HP1,  184, 210 ; 209: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  211, 187 ; 210: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  212, 189 ; 211: #4 better/worse than #2.  Try #5.
 DB  VP1HM2,  NOADJ, 0FFH,0FFH ; 212: #5 better/worse than #2.  Take best, quit.
 DB  VM1HP1, VM1HP1,  214, 210 ; 213: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  215, 187 ; 214: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  216, 189 ; 215: #4 better/worse than #1.  Try #5.
 DB  VP2HM2,  NOADJ, 0FFH,0FFH ; 216: #5 better/worse than #1.  Take best, quit.

     ;     .   .   4   3   5   C = center.
     ;     .   ~   ~   X   2   ~ = tried, but not as good.
     ;     .   ~   C   ~   1   X = best so far.
     ;     .   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  218, 222 ; 217: #1 better/worse than  X.  Try #2.
 DB  VM1HM1, VM1HM1,  184, 219 ; 218: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  220, 187 ; 219: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  221, 189 ; 220: #4 better/worse than #2.  Try #5.
 DB     VP1,  NOADJ, 0FFH,0FFH ; 221: #5 better/worse than #2.  Take best, quit.
 DB  VM1HM1, VM1HM1,  223, 219 ; 222: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  224, 187 ; 223: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  225, 189 ; 224: #4 better/worse than #1.  Try #5.
 DB     VP2,  NOADJ, 0FFH,0FFH ; 225: #5 better/worse than #1.  Take best, quit.

FIRST_HEURISTIC_EXHAUSTIVE_NEW_CTR = 226

 DB  VP1HP1, VP1HP1,  130, 130 ; 226: Redoing ctr, away from limiting edge.

 DB  ?, ?, ?, ?, ?, ?

; Table of values to add to SWDs for half pel reference macroblocks, to cause
; those that are off the edge of the frame to produce artificially high SWDs.
; (64 bytes;3040:3103)

InvalidateBadHalfPelMVs LABEL DWORD

  DD    0FFFFFFFFH, 0FFFFFF00H, 0FFFF00FFH, 0FFFF0000H
  DD    0FF00FFFFH, 0FF00FF00H, 0FF0000FFH, 0FF000000H
  DD    000FFFFFFH, 000FFFF00H, 000FF00FFH, 000FF0000H
  DD    00000FFFFH, 00000FF00H, 0000000FFH, 000000000H

; Tables (interleaved) to select case from next table (below these) to drive
; the weighting of the future and past predictions in the construction of
; B-frame reference blocks.
; (448 bytes;3104:3551)

VertWtSel LABEL BYTE
  DB   0
HorzWtSel LABEL BYTE
  DB   240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   1,   0
  DB   1,   0
  DB   2,  16
  DB   2,  16
  DB   3,  32
  DB   3,  32
  DB   4,  48
  DB   4,  48
  DB   5,  64
  DB   5,  64
  DB   6,  80
  DB   6,  80
  DB   7,  96
  DB   7,  96
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   9, 128
  DB   9, 128
  DB  10, 144
  DB  10, 144
  DB  11, 160
  DB  11, 160
  DB  12, 176
  DB  12, 176
  DB  13, 192
  DB  13, 192
  DB  14, 208
  DB  14, 208
  DB  15, 224
  DB  15, 224
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240  ; Chroma starts here
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240  ; Luma ends here
  DB   0, 240
  DB   0, 240
  DB   1,   0
  DB   1,   0
  DB   2,  16
  DB   2,  16
  DB   3,  32
  DB   3,  32
  DB   4,  48
  DB   4,  48
  DB   5,  64
  DB   5,  64
  DB   6,  80
  DB   6,  80
  DB   7,  96
  DB   7,  96
  DB   8, 112
  DB   9, 128
  DB   9, 128
  DB  10, 144
  DB  10, 144
  DB  11, 160
  DB  11, 160
  DB  12, 176
  DB  12, 176
  DB  13, 192
  DB  13, 192
  DB  14, 208
  DB  14, 208
  DB  15, 224
  DB  15, 224
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240

; Table indexed by VertWtSel and HorzWtSel to get index of weight to apply to
; future and past predictions in the construction of B-frame reference blocks
; for frame differencing.
; (264 bytes;3552:3815)
;
; Indexed by VertWtSel[VMV]+HorzWtSel[HMV]+N  to get idx of weight for line N.

P8F0 =  0*8
F1P7 =  1*8
F2P6 =  2*8
F3P5 =  3*8
F4P4 =  4*8
F5P3 =  5*8
F6P2 =  6*8
F7P1 =  7*8
F8P0 =  8*8
P1F7 =  9*8
P2F6 = 10*8
P3F5 = 11*8
P4F4 = 12*8
P5F3 = 13*8
P6F2 = 14*8
P7F1 = 15*8

Diff_IdxRefWts LABEL BYTE

  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F1P7, F1P7, F1P7, F1P7, F1P7, F1P7, F1P7, F1P7
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F2P6, F2P6, F2P6, F2P6, F2P6, F2P6, F2P6, F2P6
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F3P5, F3P5, F3P5, F3P5, F3P5, F3P5, F3P5, F3P5
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F4P4, F4P4, F4P4, F4P4, F4P4, F4P4, F4P4, F4P4
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F5P3, F5P3, F5P3, F5P3, F5P3, F5P3, F5P3, F5P3
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F6P2, F6P2, F6P2, F6P2, F6P2, F6P2, F6P2, F6P2
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F7P1, F7P1, F7P1, F7P1, F7P1, F7P1, F7P1, F7P1
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F8P0, F8P0, F8P0, F8P0, F8P0, F8P0, F8P0, F8P0
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P1F7, P1F7, P1F7, P1F7, P1F7, P1F7, P1F7, P1F7
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P2F6, P2F6, P2F6, P2F6, P2F6, P2F6, P2F6, P2F6
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P3F5, P3F5, P3F5, P3F5, P3F5, P3F5, P3F5, P3F5
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P4F4, P4F4, P4F4, P4F4, P4F4, P4F4, P4F4, P4F4
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P5F3, P5F3, P5F3, P5F3, P5F3, P5F3, P5F3, P5F3
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P6F2, P6F2, P6F2, P6F2, P6F2, P6F2, P6F2, P6F2
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P7F1, P7F1, P7F1, P7F1, P7F1, P7F1, P7F1, P7F1
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0

BFrmSWDState LABEL BYTE  ; State engine rules for finding best motion vector.
; (48 bytes; 3816:3863)

; 1st number:  Horizontal Motion displacement to try, in half pel increments.
; 2nd number:  Vertical Motion displacement to try, in half pel increments.
; 3rd number:  Next state to enter if previous best is still best.
; 4th number:  Next state to enter if this motion is better than previous best.

   DB    -2,   0,  4,  8   ;  0 -- ( 0, 0) Try (-2, 0)
   DB     2,   0, 12, 12   ;  4 -- ( 0, 0) Try ( 2, 0)
   DB     4,   0, 12, 12   ;  8 -- (-2, 0) Try ( 2, 0)
   DB     0,  -2, 16, 20   ; 12 -- ( N, 0) Try ( N,-2)  (N = {-2,0,2})
   DB     0,   2, 24, 24   ; 16 -- ( N, 0) Try ( N, 2)
   DB     0,   4, 24, 24   ; 20 -- ( N,-2) Try ( N, 2)

   DB    -1,   0, 28, 32   ; 24
   DB     1,   0, 36, 36   ; 28
   DB     2,   0, 36, 36   ; 32
   DB     0,  -1, 40, 44   ; 36
   DB     0,   1,  0,  0   ; 40
   DB     0,   2,  0,  0   ; 44

; Table used by Quant RLE to navigate the zigzag order of quantized coeffs.
; Contents of this table are initialized by first entry to MMxEDTQ.  In
; unlikely event of race condition, it will just get initialized by more
; than one encoder instance.
; (128 bytes; 3864:3991)

NextZigZagCoeff LABEL BYTE

  DB 128 DUP (0FFH)

; Table used to initial above table.
; (64 bytes: 3992:4055)

InitZigZagCoeff LABEL BYTE

  DB Q01,Q10,Q20,Q11,Q02,Q03,Q12,Q21,Q30,Q40,Q31,Q22,Q13,Q04,Q05,Q14
  DB Q23,Q32,Q41,Q50,Q60,Q51,Q42,Q33,Q24,Q15,Q06,Q07,Q16,Q25,Q34,Q43
  DB Q52,Q61,Q70,Q71,Q62,Q53,Q44,Q35,Q26,Q17,Q27,Q36,Q45,Q54,Q63,Q72
  DB Q73,Q64,Q55,Q46,Q37,Q47,Q56,Q65,Q74,Q75,Q66,Q57,Q67,Q76,Q77,  0

; Constants needed by the Quant RLE phase.
; (128 bytes; 4056:4183)

Recip2QP LABEL DWORD
  WORD 0H, 0H           ; QP = 000h
  WORD 04000H, 04000H   ; QP = 001h
  WORD 02000H, 02000H   ; QP = 002h
  WORD 01555H, 01555H   ; QP = 003h
  WORD 01000H, 01000H   ; QP = 004h
  WORD 00CCCH, 00CCCH   ; QP = 005h
  WORD 00AAAH, 00AAAH   ; QP = 006h
  WORD 00924H, 00924H   ; QP = 007h
  WORD 00800H, 00800H   ; QP = 008h
  WORD 0071CH, 0071CH   ; QP = 009h
  WORD 00666H, 00666H   ; QP = 00Ah
  WORD 005D1H, 005D1H   ; QP = 00Bh
  WORD 00555H, 00555H   ; QP = 00Ch
  WORD 004ECH, 004ECH   ; QP = 00Dh
  WORD 00492H, 00492H   ; QP = 00Eh
  WORD 00444H, 00444H   ; QP = 00Fh
  WORD 00400H, 00400H   ; QP = 010h
  WORD 003C3H, 003C3H   ; QP = 011h
  WORD 0038EH, 0038EH   ; QP = 012h
  WORD 0035EH, 0035EH   ; QP = 013h
  WORD 00333H, 00333H   ; QP = 014h
  WORD 0030CH, 0030CH   ; QP = 015h
  WORD 002E8H, 002E8H   ; QP = 016h
  WORD 002C8H, 002C8H   ; QP = 017h
  WORD 002AAH, 002AAH   ; QP = 018h
  WORD 0028FH, 0028FH   ; QP = 019h
  WORD 00276H, 00276H   ; QP = 01Ah
  WORD 0025EH, 0025EH   ; QP = 01Bh
  WORD 00249H, 00249H   ; QP = 01Ch
  WORD 00234H, 00234H   ; QP = 01Dh
  WORD 00222H, 00222H   ; QP = 01Eh
  WORD 00210H, 00210H   ; QP = 01Fh

; Skip over space to get to where the following tables can go.  They will
; hit the cache at the same point as a portion of the StateEngine states
; that aren't used in the heuristic ME mode.
; (2056 bytes; 4184:6239)

  DB 2056 DUP (?)   ; Static space place-holder.

; Table to select base address in next table below to use for particular block
; of macroblock.  First column provides address of base element of HorzWtSel
; to use to map horizontal MV to list of weighting indices to use.  ; Second
; column is similar, but for Vertical MV.  Third and fourth columns not used.
; 6 rows; one for each block in a macroblock.
; (88 bytes; 6240:6327)

LeftRightBlkPosition LABEL DWORD
  DD HorzWtSel+0-64
UpDownBlkPosition LABEL DWORD
  DD                   VertWtSel+0-64,   0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+32-64,  VertWtSel+0-64,   0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+0-64,   VertWtSel+32-64,  0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+32-64,  VertWtSel+32-64,  0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+128,    VertWtSel+128,    0DEADBEEFH
BlkEmptyFlag LABEL BYTE  ; sneak this in here
  DB       16, 0, 32, 0
  DD HorzWtSel+128,    VertWtSel+128


; The following table, indexed by MBEdgeType&7, returns a mask which is used to
; zero-out the motion vectors for predictors that are off the edge of the
; frame.  The index is a 3 bit value, each bit being set if the macroblock
; is NOT on the corresponding edge.  1 == left;  2 == right;  4 == top;
; The value gotten out is (where A==left; B==above; C==above right):
;    <mask(A) mask(A) mask(C) mask(C) mask(B) mask(B) mask(A) mask(A)>
; The mask is 0xFF if the corresponding remote block is NOT off the edge, and
; 0x00 if it is off the edge.
; (32 bytes: 6328: 6359)

ValidRemoteVectors LABEL DWORD
  DWORD 0DEADBEEFH   ;  0: Can't be on left and right edges at once.
  DWORD 0FF0000FFH   ;  1: Top right corner.
  DWORD 000000000H   ;  2: Top left corner.
  DWORD 0FF0000FFH   ;  3: Top edge.
  DWORD 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  DWORD 0FF00FFFFH   ;  5: Right edge.
  DWORD 000FFFF00H   ;  6: Left edge.
  DWORD 0FFFFFFFFH   ;  7: Central macroblock.

; The following table, indexed by MBEdgeType, returns a QWORD of unsigned bytes
; to be subtracted with saturation to the predicted motion vector for extended
; motion vector search.  Since saturation occurs at 0, the values here are
; such that the motion vectors are biased to the appropriate point for the
; clamping effect.  The index is a 4 bit value, each bit being set if the
; macroblock is NOT on the corresponding edge.  1 == left;  2 == right;
; 4 == top;  8 == bottom.  The 8 values being calculated are as follows:
;    ; [ 0: 7] -- HMV lower limit for signature search
;    ; [ 8:15] -- HMV lower limit
;    ; [16:23] -- HMV upper limit for signature search
;    ; [24:31] -- HMV upper limit
;    ; [32:39] -- VMV lower limit for signature search
;    ; [40:47] -- VMV lower limit
;    ; [48:55] -- VMV upper limit for signature search
;    ; [56:63] -- VMV upper limit
; (88 bytes: 6360:6447)

EMV_ClampLowerEnd LABEL DWORD
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  0: Can't be on all edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  1: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  2: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  3: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  BYTE   87,  94,  97, 100,      ;  5: Bottom right corner.
         87,  94,  97, 100
  BYTE  119, 126,  97, 100,      ;  6: Bottom left corner.
         87,  94,  97, 100
  BYTE   87,  94,  97, 100,      ;  7: Bottom edge.
         87,  94,  97, 100
  DWORD 0DEADBEEFH, 0DEADBEEFH   ;  8: Can't be on left and right edges at once.
  BYTE   87,  94,  97, 100,      ;  9: Top right corner.
        119, 126,  97, 100
  BYTE  119, 126,  97, 100,      ; 10: Top left corner.
        119, 126,  97, 100
  BYTE   87,  94,  97, 100,      ; 11: Top edge.
        119, 126,  97, 100
  DWORD 0DEADBEEFH, 0DEADBEEFH   ; 12: Can't be on left and right edges at once.
  BYTE   87,  94,  97, 100,      ; 13: Right edge.
         87,  94,  97, 100
  BYTE  119, 126,  97, 100,      ; 14: Left edge.
         87,  94,  97, 100
  BYTE   87,  94,  97, 100,      ; 15: Central macroblock.
         87,  94,  97, 100

; The following table, indexed by MBEdgeType, returns a QWORD of unsigned bytes
; to be added with saturation to the result of the application of the preceed-
; ing table, to clamp the upper limit on the motion vector search parameters.
; Since saturation occurs at 255, the values here are such that the motion
; vectors are biased to the appropriate point for the clamping effect.
; (88 bytes: 6448:6535)

EMV_ClampUpperEnd LABEL DWORD
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  0: Can't be on all edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  1: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  2: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  3: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  BYTE  184, 193, 216, 225,      ;  5: Bottom right corner.
        184, 193, 216, 225
  BYTE  216, 225, 184, 193,      ;  6: Bottom left corner.
        184, 193, 216, 225
  BYTE  184, 193, 184, 193,      ;  7: Bottom edge.
        184, 193, 216, 225
  DWORD 0DEADBEEFH, 0DEADBEEFH   ;  8: Can't be on left and right edges at once.
  BYTE  184, 193, 216, 225,      ;  9: Top right corner.
        216, 225, 184, 193
  BYTE  216, 225, 184, 193,      ; 10: Top left corner.
        216, 225, 184, 193
  BYTE  184, 193, 184, 193,      ; 11: Top edge.
        216, 225, 184, 193
  DWORD 0DEADBEEFH, 0DEADBEEFH   ; 12: Can't be on left and right edges at once.
  BYTE  184, 193, 216, 225,      ; 13: Right edge.
        184, 193, 184, 193
  BYTE  216, 225, 184, 193,      ; 14: Left edge.
        184, 193, 184, 193
  BYTE  184, 193, 184, 193,      ; 15: Central macroblock.
        184, 193, 184, 193

; The following table, indexed by MBEdgeType, returns a QWORD of unsigned bytes
; to be added without saturation to the result of the application of the
; preceeding table, to return the the motion vector search parameters to the
; proper range for subsequent use.
; (88 bytes: 6536:6623)

EMV_RestoreRange LABEL DWORD
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  0: Can't be on all edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  1: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  2: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  3: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  BYTE  120, 255,  88, 225,      ;  5: Bottom right corner.
        120, 255,  88, 225
  BYTE  120, 255,  56, 193,      ;  6: Bottom left corner.
        120, 255,  88, 225
  BYTE  120, 255,  56, 193,      ;  7: Bottom edge.
        120, 255,  88, 225
  DWORD 0DEADBEEFH, 0DEADBEEFH   ;  8: Can't be on left and right edges at once.
  BYTE  120, 255,  88, 225,      ;  9: Top right corner.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 10: Top left corner.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 11: Top edge.
        120, 255,  56, 193
  DWORD 0DEADBEEFH, 0DEADBEEFH   ; 12: Can't be on left and right edges at once.
  BYTE  120, 255,  88, 225,      ; 13: Right edge.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 14: Left edge.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 15: Central macroblock.
        120, 255,  56, 193

; Tables indexed by indices fetched from Diff_IdxRefWts.  These tables return
; a multipler to apply to past or future predictions to construct the
; B-frame candidate reference blocks.
; (128 bytes;6624:6751)

FutureWt_FF_or_00 LABEL DWORD

  DD 000000000H, 000000000H
  DD 000000000H, 0FF000000H
  DD 000000000H, 0FFFF0000H
  DD 000000000H, 0FFFFFF00H
  DD 000000000H, 0FFFFFFFFH
  DD 0FF000000H, 0FFFFFFFFH
  DD 0FFFF0000H, 0FFFFFFFFH
  DD 0FFFFFF00H, 0FFFFFFFFH
  DD 0FFFFFFFFH, 0FFFFFFFFH
  DD 0FFFFFFFFH, 000FFFFFFH
  DD 0FFFFFFFFH, 00000FFFFH
  DD 0FFFFFFFFH, 0000000FFH
  DD 0FFFFFFFFH, 000000000H
  DD 000FFFFFFH, 000000000H
  DD 00000FFFFH, 000000000H
  DD 0000000FFH, 000000000H

MMXMEDATA ENDS

;=============================================================================

.CODE EDTQ

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

EXTERN MMxDoForwardDCT:NEAR
EXTERN MMxDoForwardDCTx:NEAR
EXTERN MMxDoForwardDCTy:NEAR
IFDEF H261
ELSE
EXTERN MMxDoBFrameLumaBlocks:NEAR
EXTERN MMxDoBFrameChromaBlocks:NEAR
ENDIF

MMxEDTQ  proc C AMBAS:   DWORD,
ATarg:   DWORD,
APrev:   DWORD,
ABTarg:  DWORD,
AWtFwd:  DWORD,
AWtBwd:  DWORD,
AFrmWd:  DWORD,
ADoHalf: DWORD,
ADoBlk:  DWORD,
ADoSF:   DWORD,
ADoAP:   DWORD,
ADoB:    DWORD,
ADoLuma: DWORD,
ADoExtMV:DWORD,
AQP:     DWORD,
ABQP:    DWORD,
AB0VecT: DWORD,
ASpaFilT:DWORD,
ASpaFilD:DWORD,
ASWDTot: DWORD,
ABSWDTot:DWORD,
ACodStr: DWORD,
ABCodStr:DWORD

LocalFrameSize = 1536   ; Space needed for locals

RegStoSize = 16

; Arguments:

MBlockActionStream_arg       = RegStoSize +   4
TargetFrameBaseAddress_arg   = RegStoSize +   8
PreviousFrameBaseAddress_arg = RegStoSize +  12
BTargetFrameBaseAddress_arg  = RegStoSize +  16
SignatureBaseAddress_arg     = RegStoSize +  20
WeightForwardMotion_arg      = RegStoSize +  24
WeightBackwardMotion_arg     = RegStoSize +  28
FrameWidth                   = RegStoSize +  32
DoHalfPelEstimation_arg      = RegStoSize +  36
DoBlockLevelVectors_arg      = RegStoSize +  40
DoSpatialFiltering_arg       = RegStoSize +  44
DoAdvancedPrediction_arg     = RegStoSize +  48
DoBFrame_arg                 = RegStoSize +  52
DoLumaBlocksInThisPass_arg   = RegStoSize +  56
DoExtendedMotionVectors_arg  = RegStoSize +  60
QuantizationLevel            = RegStoSize +  64
BQuantizationLevel           = RegStoSize +  68
BFrmZeroVectorThreshold_arg  = RegStoSize +  72
SpatialFiltThreshold_arg     = RegStoSize +  76
SpatialFiltDifferential_arg  = RegStoSize +  80
PSWDTotal                    = RegStoSize +  84
PBSWDTotal                   = RegStoSize +  88
CodeStreamCursor_arg         = RegStoSize +  92
BCodeStreamCursor_arg        = RegStoSize +  96
EndOfArgList                 = RegStoSize + 100

StackOffset TEXTEQU <0>
CONST_384   TEXTEQU <384>

  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov        esi,esp
   and       esp,0FFFFF000H
  sub        esp,000000FE0H
IFDEF H261

   mov       ebp,PITCH
  
CONST_384   TEXTEQU <ebp>

  mov        eax,[esi+SpatialFiltThreshold_arg]
   mov       ebx,[esi+SpatialFiltDifferential_arg]
  mov        SpatialFiltThreshold,eax
   mov       SpatialFiltDifferential,ebx
  mov        ecx,[esi+TargetFrameBaseAddress_arg]
   mov       ebx,[esi+SignatureBaseAddress_arg]
  sub        ecx,ebx
   mov       eax,[esi+TargetFrameBaseAddress_arg]
  mov        SigToTarget,ecx
   add       ecx,PITCH*80+64
  neg        ecx
  mov        TargetToSig_Debiased,ecx
   mov       ebx,[esi+PreviousFrameBaseAddress_arg]
  mov        PreviousFrameBaseAddress,ebx
   mov       TargetFrameBaseAddress,eax
  sub        ebx,eax
   mov       ecx,[esi+QuantizationLevel]
  mov        TargToRef,ebx
   mov       eax,[esi+CodeStreamCursor_arg]
  mov        ebx,ecx
   mov       CodeStreamCursor,eax
  shl        ebx,16
   xor       edx,edx
  or         ebx,ecx
   mov       ecx,Recip2QP[ecx*4]
  mov        QPDiv2,ebx
   mov       Recip2QPToUse,ecx
  mov        eax,[esi+DoSpatialFiltering_arg]
   mov       DoExtendedMotionVectors,edx
  test       eax,eax
   je        @f
  mov        eax,3
@@:
  mov        DoSpatialFiltering,al
   mov       SWDTotal,edx
  mov        BestMBHalfPelMV,edx
   mov       ebx,PreviousFrameBaseAddress
  mov        BlockAbove[0],edx
   sub       ebx,16
  mov        edx,[esi+FrameWidth]
   mov       SpatiallyFilteredMB,ebx
  imul       edx,-SIZEOF T_MacroBlockActionDescr/16
  add        edx,2*SIZEOF T_Blk
   mov       eax,14           ; 14 if restricted MVs and doing heuristic ME.
  mov        BlockAbove[4],edx
   mov       DoHeuristicME,eax

ELSE
 
   mov       eax,[esi+DoExtendedMotionVectors_arg]
  test       eax,eax
   je        @f
  mov        eax,7
@@:
  mov        DoExtendedMotionVectors,eax
   mov       eax,[esi+BFrmZeroVectorThreshold_arg]
  mov        edi,[esi+WeightForwardMotion_arg]
   mov       BFrmZeroVectorThreshold,eax
  mov        ecx,60
   mov       ebx,060606060H
  lea        edx,WeightForwardMotion+128
@@:
   mov       eax,[edi+ecx]
  and        eax,03F3F3F3FH    ; ???
   mov       ebp,[edi+ecx+64]
  and        ebp,03F3F3F3FH    ; ???
   xor       eax,ebx
  xor        ebp,ebx
   mov       [edx+ecx+64],eax
  mov        [edx+ecx-128],ebp
   sub       ecx,4
  mov        ebp,PITCH
   jge       @b

  mov        edi,[esi+WeightBackwardMotion_arg]
   mov       eax,edx
  lea        edx,WeightBackwardMotion+128
   mov       ecx,60
  sub        eax,edx
   jne       @b
  
CONST_384   TEXTEQU <ebp>

  mov        ebx,[esi+PreviousFrameBaseAddress_arg]
   mov       eax,[esi+TargetFrameBaseAddress_arg]
  mov        PreviousFrameBaseAddress,ebx
   mov       TargetFrameBaseAddress,eax
  mov        ecx,[esi+BTargetFrameBaseAddress_arg]
   sub       ebx,eax
  mov        TargToRef,ebx
   sub       eax,ecx
  mov        BFrameBaseAddress,ecx
   mov       BFrameToFuture,eax
  mov        ecx,[esi+TargetFrameBaseAddress_arg]
   mov       ebx,[esi+SignatureBaseAddress_arg]
  sub        ecx,ebx
   mov       edx,[esi+FrameWidth]
  mov        SigToTarget,ecx
   add       ecx,PITCH*80+64
  neg        ecx
  imul       edx,-SIZEOF T_MacroBlockActionDescr/16
  mov        TargetToSig_Debiased,ecx
   mov       ecx,[esi+DoBFrame_arg]
  add        edx,2*SIZEOF T_Blk
   xor       cl,1
  mov        BlockAbove[4],edx
   mov       IsPlainPFrame,cl
  mov        ecx,[esi+QuantizationLevel]
   mov       eax,[esi+CodeStreamCursor_arg]
  mov        ebx,ecx
   mov       CodeStreamCursor,eax
  mov        eax,[esi+BCodeStreamCursor_arg]
   mov       BCodeStreamCursor,eax
  shl        ebx,16
   mov       eax,[esi+DoHalfPelEstimation_arg]
  or         ebx,ecx
   mov       ecx,Recip2QP[ecx*4]
  mov        QPDiv2,ebx
   mov       Recip2QPToUse,ecx
  mov        ecx,[esi+BQuantizationLevel]
   xor       edx,edx
  mov        ebx,ecx
  shl        ebx,16
   mov       BestMBHalfPelMV,edx
  or         ebx,ecx
   mov       ecx,Recip2QP[ecx*4]
  mov        BQPDiv2,ebx
   mov       BRecip2QPToUse,ecx
  test       eax,eax
   je        @f
  mov        eax,-4
@@:
  mov        DoHalfPelME,eax
   mov       eax,[esi+DoBlockLevelVectors_arg]
  mov        DoBlockLevelVectors,al
   mov       eax,[esi+DoAdvancedPrediction_arg]
  mov        DoAdvancedPrediction,al
   mov       SWDTotal,edx
  test       eax,eax
   lea       eax,[eax+14]     ; 14 if restricted MVs and doing heuristic ME.
  je         @f
  xor        eax,eax          ; 0 if unrestricted MVs and doing heuristic ME.
@@:
  mov        DoHeuristicME,eax
   mov       BSWDTotal,edx
  mov        PendingOBMC,edx
   mov       BlockAbove[0],edx
ENDIF
  mov        eax,01E98E268H
  mov        EMVLimitsForThisMB,eax 
  ;               ; [ 0: 7] -- HMV lower limit for sig search (biased 128)
  ;               ; [ 8:15] -- HMV lower limit (signed)
  ;               ; [16:23] -- HMV upper limit for sig search (biased 128)
  ;               ; [24:31] -- HMV upper limit (signed)
   mov       EMVLimitsForThisMB+4,eax ; Same as for HMV.
  mov        edx,[esi+MBlockActionStream_arg]
   mov       al,NextZigZagCoeff[Q77]
  test       al,al
   je        ZigZagCoeffInitialized

  xor        ecx,ecx
   lea       ebx,InitZigZagCoeff
  xor        eax,eax

@@:

  mov        al,[ebx]
   inc       ebx
  mov        NextZigZagCoeff[ecx],al
   mov       ecx,eax
  test       eax,eax
   jne       @b

ZigZagCoeffInitialized:

  mov        StashESP,esi
   mov       eax,[esi+DoLumaBlocksInThisPass_arg]
  test       eax,eax
   jne       FirstMacroBlock   ; Jump if doing luma plane

  jmp        FirstMacroBlock_ChromaProcessing

IntraCodedChromaProcessingDone:

IFDEF H261
ELSE
  mov        al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock_ChromaProcessing

  mov        eax,QPDiv2
   mov       ebx,BQPDiv2

  call       MMxDoBFrameChromaBlocks
ENDIF

NextMacroBlock_ChromaProcessing:

  mov        bl,[edx].CodedBlocks
   sub       edx,-SIZEOF T_MacroBlockActionDescr
  and        bl,040H               ; Check for end-of-stream
   jne       TrulyDone

FirstMacroBlock_ChromaProcessing:

  mov        al,[edx].BlockType         ; Chroma handling.  Intra?  Or Inter?
   mov       ecx,TargetFrameBaseAddress
  cmp        al,INTRA
   jne       ChromaIsInterCoded

  mov        esi,[edx].BlkU.BlkOffset
   mov       StashBlockType,al
  add        esi,ecx
   push      eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCT       ; Block is in target frame;  Pitch is PITCH

  shl        bl,4
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       esi,[edx].BlkV.BlkOffset
  mov        [edx].CodedBlocks,al
   mov       ecx,TargetFrameBaseAddress
  add        esi,ecx

  call       MMxDoForwardDCT       ; Block is in target frame;  Pitch is PITCH

  shl        bl,5
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       ecx                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        [edx].CodedBlocks,al
   jmp       IntraCodedChromaProcessingDone

ChromaIsInterCoded:

  mov        edi,[edx].BlkU.BlkOffset   ; Get address of next macroblock to do.
   mov       ebx,[edx].BlkU.MVs
  add        edi,ecx
   mov       esi,[edx].BlkU.PastRef
  mov        StashBlockType,al
IFDEF H261
   mov       ecx,2+256*1        ; cl==2 tells SpatialLoopFilter code to do one
   ;                            ; block.  ch==1 causes it to return to here.
  mov        TargetMacroBlockBaseAddr,edi  ; Store address of U block.
   cmp       al,INTERSLF
  je         DoSpatialFilterForChroma

ReturnFromSpatialFilterForU:

ENDIF

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,4
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       ecx,TargetFrameBaseAddress
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        edi,[edx].BlkV.BlkOffset   ; Get address of next macroblock to do.
   mov       ebx,[edx].BlkV.MVs
  add        edi,ecx
   mov       esi,[edx].BlkV.PastRef
IFDEF H261
   mov       ecx,2-256*1        ; cl==2 tells SpatialLoopFilter code to do one
   ;                            ; block.  ch==-1 causes it to return to here.
  mov        TargetMacroBlockBaseAddr,edi  ; Store address of U block.
   mov       al,[edx].BlockType
  cmp        al,INTERSLF
   je        DoSpatialFilterForChroma

ReturnFromSpatialFilterForV:

ENDIF

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4     ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,5
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       ecx                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        [edx].CodedBlocks,al
   jmp       IntraCodedChromaProcessingDone

;============================================================================
;  Here we copy the target macroblock, and interpolate left, right, and both.
;  We also accumulate the target pels for each block.  Result is four partial
;  sums in four packed words.  After summing them all up, the final sum will
;  be the sum of the 64 pels of each block, divided by 2.

NextMacroBlock:

  mov        bl,[edx].CodedBlocks
   sub       edx,-SIZEOF T_MacroBlockActionDescr
  and        bl,040H               ; Check for end-of-stream
   jne       Done

FirstMacroBlock:

  mov        edi,TargetFrameBaseAddress
   mov       esi,[edx].BlkY1.BlkOffset   ; Get address of next macroblock to do.
  add        edi,esi
   mov       esi,TargToRef
  add        esi,edi
   mov       TargetMacroBlockBaseAddr,edi
  mov        Addr0MVRef,esi

;============================================================================
; We calculate the 0-motion SWD.  We use 32 match points per block, and
; write the result seperately for each block.  If the SWD for the 0-motion
; vector is below a threshold, we don't bother searching for other possibly
; better motion vectors.
;
;  ebp -- PITCH
;  esi -- Address of ref block.
;  edi -- Address of target block.
;  edx -- MBlockActionStream
;  ecx -- Not used.  Will be linearized MV in non-zero MV search.
;  ebx -- CurrSWDState, i.e. FirstMEState, times 8
;  eax -- Scratch
;  mm7 -- Best SWD for macroblock.
;  mm0-mm6 Scratch
;

   mov       cl,[edx].CodedBlocks        ; Init CBP for macroblock.
  or         cl,03FH                     ; Indicate all 6 blocks are coded.
   mov       eax,DoHeuristicME           ; 0  if unrestricted MVs and heur ME.
   ;                                     ; 14 if restricted MVs and heur ME.
   ;                                     ; 15 if suppressing heuristic ME.
  mov        [edx].CodedBlocks,cl
   js        IntraByDecree

  xor        ebx,ebx                     ; Avoid partial register stall.
   xor       ecx,ecx
  mov        cl,[edx].MBEdgeType         ; 1 left | 2 right | 4 top | 8 bottom
   pcmpeqd   mm7,mm7                     ; Init previous best SWD to huge.
  mov        bl,[edx].FirstMEState       ; Test for INTRA-BY-DECREE.
   sub       eax,ecx                     ; Negative iff should do heuristic ME
   ;                                     ; for this macroblock.
  test       bl,bl
   je        IntraByDecree

  sar        eax,31
   psrlq     mm7,2
  or         ebx,eax                     ; -1 if doing heuristic ME.
   mov       al,INTER1MV                 ; Speculate INTER, 1 motion vector.
  mov        [edx].BlockType,al
   psrld     mm7,14       ; mm7[32:63]:  Previous best SWD = 0x0000FFFF.
   ;                      ; mm7[ 0:31]:  Prev SWD that we diminish = 0x0003FFFF.
   ;                      ; Since we can't diminish it below 0x00020000, we
   ;                      ; won't take the short circuit exit from MblkEstQWA.

; At this point:
;  ebp -- PITCH
;  esi -- Address of upper left block of 0,0 ref area.
;  edi -- Address of upper left block of target.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- CurrSWDState, i.e. FirstMEState.
;  eax -- Scratch
;  mm7 -- Previous best SWD initialized to huge (0xFFFF, 0x3FFFF).
;  mm0-mm6 -- Scratch

;============================================================================
; Compute SWD for macroblock.

ComputeMBSWD:

;  Registers at this point:
;  ebp -- PITCH
;  esi -- Address of upper left block of candidate ref area.
;  edi -- Address of upper left block of target.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- CurrSWDState
;  eax -- Scratch
;  mm7 -- Previous best SWD.
;  mm0-mm6 -- Scratch
;

  lea        ecx,[ebp+ebp*4]       ; Get PITCH*5
   lea       eax,[ebp+ebp*2]       ; Get PITCH*3
  movq       mm0,[esi+PITCH*15]    ; FL A:  Ref MB, lower left block, line 15.
  psubw      mm0,[edi+PITCH*15]    ; FL B:  Diff for lower left block, line 15.
  movq       mm6,[esi+PITCH*15+8]  ; FR A
   psllw     mm0,8                 ; FL C:  Extract diffs for line 15 even pels.
  psubw      mm6,[edi+PITCH*15+8]  ; FR B
   pmaddwd   mm0,mm0               ; FL D:  Square of diffs for even pels.
  movq       mm1,[esi+PITCH*9]     ; 9L A
   psllw     mm6,8                 ; FR C
  psubw      mm1,[edi+PITCH*9]     ; 9L B
   pmaddwd   mm6,mm6               ; FR D
  movq       mm5,[esi+PITCH*9+8]   ; 9R A
   psllw     mm1,8                 ; 9L C
  psubw      mm5,[edi+PITCH*9+8]   ; 9R B
   pmaddwd   mm1,mm1               ; 9L D
  movq       mm2,[esi+eax*4]       ; CL a
   psllw     mm5,8                 ; 9R C
  psubw      mm2,[edi+eax*4]       ; CL b
   pmaddwd   mm5,mm5               ; 9R D
  movq       mm3,[esi+eax*4+8]     ; CR a
   pmaddwd   mm2,mm2               ; CL c:  Square of diffs for odd pels.
  psubw      mm3,[edi+eax*4+8]     ; CR b
   paddusw   mm0,mm1               ; LL +   Accumulate SWD for lower left block.
  movq       mm1,[esi+eax*1]       ; 3L A
   pmaddwd   mm3,mm3               ; CR c
  psubw      mm1,[edi+eax*1]       ; 3L B
   paddusw   mm6,mm5               ; LR +
  movq       mm5,[esi+eax*1+8]     ; 3R A
   psllw     mm1,8                 ; 3L C
  psubw      mm5,[edi+eax*1+8]     ; 3R B
   paddusw   mm0,mm2               ; LL +
  movq       mm2,[esi]             ; 0L a
   pmaddwd   mm1,mm1               ; 3L D
  psubw      mm2,[edi]             ; 0L b
   paddusw   mm6,mm3               ; LR +
  movq       mm3,[esi+8]           ; 0R a
   psllw     mm5,8                 ; 3R C
  psubw      mm3,[edi+8]           ; 0R b
   pmaddwd   mm5,mm5               ; 3R D
  movq       mm4,[esi+eax*2]       ; 6L a
   pmaddwd   mm2,mm2               ; 0L c
  psubw      mm4,[edi+eax*2]       ; 6L b
   pmaddwd   mm3,mm3               ; 0R c
  movq       PartSWDForLLBlk,mm0   ;       Stash SWD for lines 9,12,15, LL blk.
   paddusw   mm0,mm6               ;       Sum SWD for lines 9,12,15 LL and LR.
  movq       PartSWDForLRBlk,mm6   ;       Stash SWD for lines 9,12,15, LR blk.
   pmaddwd   mm4,mm4               ; 6L c
  movq       mm6,[esi+eax*2+8]     ; 6R a
   paddusw   mm1,mm2               ; UL +
  psubw      mm6,[edi+eax*2+8]     ; 6R b
   paddusw   mm5,mm3               ; UR +
  movq       mm2,[esi+ebp*1]       ; 1L A
   pmaddwd   mm6,mm6               ; 6R c
  psubw      mm2,[edi+ebp*1]       ; 1L B
   paddusw   mm1,mm4               ; UL +
  movq       mm3,[esi+ecx*1]       ; 5L A
   paddusw   mm0,mm1               ;       Sum partial SWD for LL, LR, and UL.
  psubw      mm3,[edi+ecx*1]       ; 5L B
   paddusw   mm5,mm6               ; UR +
  movq       mm6,[esi+ebp*4]       ; 4L a
   paddusw   mm0,mm5               ;       Sum partial SWD for all blocks.
  movq       PartSWDForURBlk,mm5   ;       Stash SWD for lines 0,3,6, UR blk.
   punpckldq mm5,mm0               ;       Get low sum into high bits.
  psubw      mm6,[edi+ebp*4]       ; 4L b
   paddusw   mm5,mm0               ;       Total up SWD for every third line.
  movq       mm0,[esi+ebp*2]       ; 2L a
   psrlq     mm5,47                ;       Position, and double.
  psubw      mm0,[edi+ebp*2]       ; 2L b
   pcmpgtd   mm5,mm7               ;       Is 2 * SWD for 6 lines > prev SWD?
  pmaddwd    mm0,mm0               ; 2L c
   psllw     mm2,8                 ; 1L C
  movdf      eax,mm5
   pmaddwd   mm2,mm2               ; 1L D
  test       eax,eax 
   jne       MblkEst_EarlyOut

  lea        eax,[ecx+ebp*2]       ; PITCH*7
   psllw     mm3,8                 ; 5L C
  paddusw    mm1,mm2               ; UL +
   pmaddwd   mm3,mm3               ; 5L D
  movq       mm5,[esi+eax*1]       ; 7L A
  psubw      mm5,[edi+eax*1]       ; 7L B
   pmaddwd   mm6,mm6               ; 4L c
  movq       mm2,[esi+PITCH*11+8]  ; BR A
   psllw     mm5,8                 ; 7L C
  psubw      mm2,[edi+PITCH*11+8]  ; BR B
   paddusw   mm1,mm3               ; UL +
  movq       mm3,[esi+PITCH*13+8]  ; DR A
   paddusw   mm1,mm0               ; UL +
  psubw      mm3,[edi+PITCH*13+8]  ; DR B
   pmaddwd   mm5,mm5               ; 7L D
  movq       mm0,[esi+ebp*8+8]     ; 8R a
   paddusw   mm1,mm6               ; UL +
  psubw      mm0,[edi+ebp*8+8]     ; 8R b
   psllw     mm2,8                 ; BR C
  movq       mm4,[esi+ecx*2+8]     ; AR a
   paddusw   mm1,mm5               ; UL +
  psubw      mm4,[edi+ecx*2+8]     ; AR b
   punpckldq mm6,mm1               ;      Get low SWD accum to hi order of mm6.
  movq       mm5,[esi+eax*2+8]     ; ER a
   paddusw   mm6,mm1               ;      mm6[48:63] is SWD for upper left blk.
  psubw      mm5,[edi+eax*2+8]     ; ER b
   psrlq     mm6,48                ;      mm6 is SWD for upper left block.
  psubusw    mm7,mm6               ;      Diminish prev best SWD by cand UL blk.
   pmaddwd   mm2,mm2               ; BR D
  pmaddwd    mm0,mm0               ; 8R c
   psllw     mm3,8                 ; DR C
  movq       mm1,[esi+ebp*1+8]     ; 1R A
   pmaddwd   mm3,mm3               ; DR D
  paddusw    mm2,PartSWDForLRBlk   ; LR +
   pmaddwd   mm4,mm4               ; AR c
  psubw      mm1,[edi+ebp*1+8]     ; 1R B
   paddusw   mm2,mm0               ; LR +
  movq       mm0,[esi+ecx*1+8]     ; 5R A
   pmaddwd   mm5,mm5               ; ER c
  psubw      mm0,[edi+ecx*1+8]     ; 5R B
   paddusw   mm2,mm3               ; LR +
  movq       mm3,[esi+eax*1+8]     ; 7R A
   paddusw   mm2,mm4               ; LR +
  paddusw    mm2,mm5               ; LR +
   psllw     mm1,8                 ; 1R C
  psubw      mm3,[edi+eax*1+8]     ; 7R B
   punpckldq mm5,mm2               ;      Get low SWD accum to hi order of mm5.
  paddusw    mm5,mm2               ;      mm5[48:63] is SWD for lower right blk.
   pmaddwd   mm1,mm1               ; 1R D
  movq       mm2,[esi+ebp*2+8]     ; 2R a
   psrlq     mm5,48                ;      mm5 is SWD for lower right block.
  psubusw    mm7,mm5               ;      Diminish prev best SWD by cand LR blk.
   punpckldq mm6,mm5               ;      mm6[0:31] UL SWD;  mm6[32:63] LR SWD.
  psubw      mm2,[edi+ebp*2+8]     ; 2R b
   psllw     mm0,8                 ; 5R C
  movq       mm5,[esi+ebp*4+8]     ; 4R a
   pmaddwd   mm0,mm0               ; 5R D
  psubw      mm5,[edi+ebp*4+8]     ; 4R b
   psllw     mm3,8                 ; 7R C
  paddusw    mm1,PartSWDForURBlk   ; UR +
   pmaddwd   mm3,mm3               ; 7R D
  paddusw    mm1,mm0               ; UR +
   pmaddwd   mm2,mm2               ; 2R c
  movq       mm0,[esi+PITCH*11]    ; BL A
   pmaddwd   mm5,mm5               ; 4R c
  psubw      mm0,[edi+PITCH*11]    ; BL B
   paddusw   mm1,mm3               ; UR +
  movq       mm3,[esi+ecx*2]       ; AL a
   paddusw   mm1,mm2               ; UR +
  psubw      mm3,[edi+ecx*2]       ; AL b
   paddusw   mm1,mm5               ; UR +
  pmaddwd    mm3,mm3               ; AL c
   psllw     mm0,8                 ; BL C
  movq       mm2,[esi+PITCH*13]    ; DL A
   pmaddwd   mm0,mm0               ; BL D
  psubw      mm2,[edi+PITCH*13]    ; DL B
   punpckldq mm5,mm1               ;      Get low SWD accum to hi order of mm5.
  movq       mm4,[esi+ebp*8]       ; 8L a
   paddusw   mm5,mm1               ;      mm5[48:63] is SWD for upper right blk.
  psubw      mm4,[edi+ebp*8]       ; 8L b
   psllw     mm2,8                 ; DL C
  movq       mm1,[esi+eax*2]       ; EL a
   pmaddwd   mm2,mm2               ; DL D
  psubw      mm1,[edi+eax*2]       ; EL b
   pmaddwd   mm4,mm4               ; 8L c
  paddusw    mm3,PartSWDForLLBlk   ; LL +
   pmaddwd   mm1,mm1               ; EL c
  paddusw    mm3,mm0               ; LL +
   psrlq     mm5,48                ;      mm5 is SWD for upper right block.
  paddusw    mm3,mm2               ; LL +
   psubusw   mm7,mm5               ;      Diminish prev best SWD by cand UR blk.
  paddusw    mm3,mm4               ; LL +
   movq      mm0,mm7
  paddusw    mm3,mm1               ; LL +
   psrlq     mm7,32	           ; Get original Best SWD
  punpckldq  mm1,mm3
   pxor      mm2,mm2
  paddusw    mm1,mm3
  psrlq      mm1,48
  punpckldq  mm5,mm1           ; mm5[32:63] SWD for LL.  mm5[0:31] SWD for UR.
   psubusw   mm0,mm1
  psubusw    mm7,mm0           ; BestSWD dim (BestSWD dim CandSWD) --> new best.
   pcmpeqd   mm2,mm0           ; [0:31] == 0 iff cand better, else -1.

;  Registers at this point:
;  ebp -- PITCH
;  edi -- Target MacroBlock Base Address.
;  esi -- Address of upper left block of candidate ref area.
;  edx -- MBlockActionStream
;  ebx -- CurrSWDState
;  mm7 -- New best SWD for macroblock.
;  mm6 -- [0:31] SWD for upper left;   [32:63] SWD for lower right.
;  mm5 -- [0:31] SWD for upper right;  [32:63] SWD for lower left.
;  mm2 -- [0:31] 0 if cand better, else -1.

  cmp        ebx,LASTINITIALMESTATE  ; Did we just do zero motion vector?
   jg        MEForNonZeroMVDone

  movdf      eax,mm7                 ; SWD for this candidate.
   punpckldq mm7,mm7                 ; Put new best in mm7[0:31] and mm7[32:63].
  test       ebx,ebx
   jns       ZeroMVDoneForNonHeuristicME

HeuristicME_EarlyOut:

  movq       mm0,EMVLimitsForThisMB  ; Speculate no extended motion vectors.
   pcmpeqb   mm1,mm1                 ; <FFFF FFFF FFFF FFFF>
  xor        ecx,ecx
   cmp       bl,-3
  mov        cl,[edx].MBEdgeType     ; 1 left | 2 right | 4 top | 8 bottom
   jle       HeuristicME_CaseSigMVDone_or_CaseAboveMVDone

  sub        eax,NONZEROMVDIFFERENTIAL
   inc       bl
  mov        ebx,DoExtendedMotionVectors  ; 7 iff doing extende MVs, else 0.
   jne       HeuristicME_CaseLeftMVDone

HeuristicME_Case0MVDone:

  movq       SWDULandLR,mm6
   pcmpeqb   mm4,mm4                 ; <FFFF FFFF FFFF FFFF>
  movq       SWDURandLL,mm5
   psllw     mm4,15                  ; <8000 8000 8000 8000>
  cmp        eax,ZEROVECTORTHRESHOLD-NONZEROMVDIFFERENTIAL
  ;                                  ; Compare 0-MV against ZeroVectorThreshold.
   jl        BelowZeroThresh         ; Jump if 0-MV is good enough.

  mov        SWDForNon0MVToBeat,eax
   and       ebx,ecx                 ; Elim flag for bottom row. 0 iff no ExtMV.
  mov        eax,BlockAbove[4]
   je        NotExtendedMVs          ; Jump if not doing extended MVs?

                                     ; Below:  A==left;  B==above;  C==above rt.
  movdt      mm3,ValidRemoteVectors[ebx*4]              ; <mask(A) (C) (B) (A)>
   movq      mm2,mm4                 ; <8000 8000 8000 8000>

IF SIZEOF T_MacroBlockActionDescr-128
**** error:  Due to assembler weakness, can't use spaces here, so SIZEOF
**** T_MacroBlockActionDescr is replaced by constant.  If assembly error
**** occurs, the constant has been changed, and the three instructions in
**** the next 10 lines have to change.
ENDIF
IF SIZEOF T_Blk-16
**** error:  Due to assembler weakness, can't use spaces here, so SIZEOF T_Blk
**** is replaced by constant.  If assembly error occurs, the constant has been
**** changed, and the three instructions in the next 10 lines have to change.
ENDIF
  movdt      mm0,[edx-128].BestFullPelMBMVs             ; <x    x    Av,h x   >
   punpcklbw mm3,mm3                                    ; mask for both MV parts
  movdt      mm1,[edx+eax-2*16+128].BestFullPelMBMVs    ; <x    x    Cv,h x   >
   psrlw     mm2,8                                      ; <0080 0080 0080 0080>
  por        mm4,mm2                                    ; <8080 ...> bias value.
   punpcklwd mm1,mm0                                    ; <Av,h Cv,h x    x   >
  punpcklwd  mm0,[edx+eax-2*16].BestFullPelMBMVs        ; <Bv,h Av,h x x >
   ;
  punpckhdq  mm0,mm1                 ; <Av,h Cv,h Bv,h Av,h>
   ;
  pand       mm0,mm3                 ; Set to 0 any off edge.
   and       ebx,4                   ; If zero, we're on the top edge.
  paddb      mm0,mm4                 ; <Av,h Cv,h Bv,h Av,h> biased
   je        @f                      ; If on top edge, cause LEFT to be taken.
  movq       mm1,mm0                 ; <Av,h Cv,h Bv,h Av,h>
   psrlq     mm0,16                  ; <x    Av,h Cv,h Bv,h>
  psubusb    mm0,mm1                 ; <x    floor(A-C) floor(C-B) floor(B-A)>
   ;
  paddb      mm0,mm1                 ; <x    max(A,C) max(C,B) max(B,A)>
   ;
  movq       mm1,mm0                 ; <x    max(A,C) max(C,B) max(B,A)>
   psrlq     mm0,16                  ; <x    x        max(A,C) max(C,B)>
  pxor       mm1,mm0                 ; Part of median calc.
   psrlq     mm0,16                  ; <x    x        x        max(A,C)>
  pxor       mm0,mm1                 ; <x x x median(A,B,C)> biased by +128.
   ;

@@:

  punpcklbw  mm0,mm0                 ; 2 copies of median predictor MVs.
   pcmpeqb   mm1,mm1
  punpcklwd  mm0,mm0                 ; 4 copies.  Will now calc the following:
  ;                                  ; [ 0: 7] -- HMV lower limit for sig search
  ;                                  ; [ 8:15] -- HMV lower limit
  ;                                  ; [16:23] -- HMV upper limit for sig search
  ;                                  ; [24:31] -- HMV upper limit
  ;                                  ; [32:39] -- VMV lower limit for sig search
  ;                                  ; [40:47] -- VMV lower limit
  ;                                  ; [48:55] -- VMV upper limit for sig search
  ;                                  ; [56:63] -- VMV upper limit
   ;
  psubusb    mm0,EMV_ClampLowerEnd[ecx*8-40]
   psllw     mm1,3                   ; <FF F8 FF F8 FF F8 FF F8> i.e.  Mask to
   ;                                 ; set sig srch range to mult of 8.
  paddusb    mm0,EMV_ClampUpperEnd[ecx*8-40]

  psubb      mm0,EMV_RestoreRange[ecx*8-40]

NotExtendedMVs:

  movq       SWD0MVURandLL,mm5
   pand      mm0,mm1                 ; Set sig search at multiples of four.
  movq       SWD0MVULandLR,mm6
   pcmpeqb   mm2,mm2                 ; Set cand as worse than 0MV, in case skip.
  movq       EMVLimitsForThisMB,mm0
  and        cl,1
   je        HeuristicME_SkipLeftMV

  mov        BestOfFourStartingPoints,esi
   mov       ebx,-2                  ; Indicate trying MV of MB to left.
  movsx      ecx,[edx-SIZEOF T_MacroBlockActionDescr].BestFullPelMBVMV
  movsx      eax,[edx-SIZEOF T_MacroBlockActionDescr].BestFullPelMBHMV

ClampHeurMECandidateToRange:

  movsx      esi,PB EMVLimitsForThisMB+5  ; VMV lower limit.
  cmp        ecx,esi
   jl        ClampVMV_1

  movsx      esi,PB EMVLimitsForThisMB+7  ; VMV upper limit.
  cmp        ecx,esi
   jle       @f

ClampVMV_1:

  mov        ecx,esi

@@:

  movsx      esi,PB EMVLimitsForThisMB+1  ; HMV lower limit.
  cmp        eax,esi
   jl        ClampHMV_1

  movsx      esi,PB EMVLimitsForThisMB+3  ; HMV upper limit.
  cmp        eax,esi
   jle       @f

ClampHMV_1:

  mov        eax,esi

@@:

  sar        eax,1
   lea       ecx,[ecx+ecx*2]
IF PITCH-384
*** error:  The magic here assumes a pitch of 384.
ENDIF
  shl        ecx,6
   mov       esi,Addr0MVRef
  add        eax,ecx                      ; Clamped Linearized Motion Vector
   ;
  sub        eax,1
   jc        MblkEst_EarlyOut             ; Jump if Lin MV is zero.

  lea        esi,[esi+eax+1]              ; Candidate reference address.
   jmp       ComputeMBSWD

HeuristicME_SkipLeftMV:

  mov        BestOfFourStartingPoints,esi
   mov       cl,[edx].MBEdgeType   ; 1 left | 2 right | 4 top | 8 bottom

HeuristicME_CaseLeftMVDone:

  movdf      eax,mm2               ; eax == 0 iff cand better, else -1.
  mov        ebx,BlockAbove[4]
   and       cl,4
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   punpckldq mm7,mm7               ; Put new best in mm7[0:31] and mm7[32:63].
  movq       SWDURandLL[eax*8],mm5
   pcmpeqb   mm2,mm2               ; Set cand as worse than prev, in case skip.
  mov        BestOfFourStartingPoints[eax*4],esi
   je        HeuristicME_SkipAboveMV

  movsx      ecx,[edx+ebx-2*SIZEOF T_Blk].BestFullPelMBVMV
  movsx      eax,[edx+ebx-2*SIZEOF T_Blk].BestFullPelMBHMV
  mov        ebx,-3                  ; Indicate trying MV of MB above.
   jmp       ClampHeurMECandidateToRange

HeuristicME_CaseSigMVDone_or_CaseAboveMVDone:
HeuristicME_SkipAboveMV:

  movdf      eax,mm2               ; eax == 0 iff cand better, else -1.
  jne        HeuristicME_CaseSigMVDone

HeuristicME_CaseAboveMVDone:

  mov        cl,4
   lea       ebx,C0001000100010001
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   pxor      mm0,mm0
  movq       SWDURandLL[eax*8],mm5
   pxor      mm1,mm1
  mov        BestOfFourStartingPoints[eax*4],esi
   lea       esi,TargetSigContribForRowPairs
  movdf      BestMBFullPelSWD,mm7  ; Stash SWD for best full pel MB MV.
   pcmpeqb   mm7,mm7               ; W:<0xFFFF  0xFFFF  0xFFFF  0xFFFF>

; ebp -- Pitch
; edi -- Address of target macroblock.
; esi -- Address at which to store target macroblock's signature contributions.
; cl  -- Loop counter.
; mm0 -- Accumulator for target MB's sig contrib for first four even columns.
; mm1 -- Accumulator for target MB's sig contrib for last four even columns.

  movq       mm2,[edi]             ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5               ; W:<0xFFFF  0xFFFF  0xFFFF  0xFFFF>
  paddb      mm2,[edi+ebp*1]       ; B:<P07+P17 P06+P16 P05+P15 P04+P14 ...>
   psrlw     mm5,8                 ; W:<0x00FF  0x00FF  0x00FF  0x00FF>

@@:

  movq       mm3,[edi+ebp*2]       ; B:<P27 P26 P25 P24 P23 P22 P21 P20>
   movq      mm4,mm2               ; B:<P07+P17 P06+P16 P05+P15 P04+P14 ...>
  paddb      mm3,[edi+PITCH*3]     ; B:<P27+P37 P26+P36 P25+P35 P24+P34 ...>
   psrlw     mm2,8                 ; W:<P07+P17 P05+P15 P03+P13 P01+P11>
  pmaddwd    mm2,[ebx]             ; D:<P07+P17+P05+P15 P03+P13+P01+P11>
   movq      mm7,mm5               ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  pand       mm5,mm3               ; W:<P26+P36 P24+P34 P22+P32 P20+P30>
   psrlw     mm3,8                 ; W:<P27+P37 P25+P35 P23+P33 P21+P31>
  pmaddwd    mm3,[ebx]             ; D:<P27+P37+P25+P35 P23+P33+P21+P31>
   paddw     mm0,mm5               ; W:<sum(P*6) sum(P*4) sum(P*2) sum (P*0)>
  movq       mm5,[edi+ebp*2+8]     ; B:<P2F P2E P2D P2C P2B P2A P29 P28>
   pand      mm4,mm7               ; W:<P06+P16 P04+P14 P02+P12 P00+P10>
  paddb      mm5,[edi+PITCH*3+8]   ; B:<P2F+P3F P2E+P3E P2D+P3D P2C+P3C ...>
   paddw     mm0,mm4               ; W:<sum(P*6) sum(P*4) sum(P*2) sum (P*0)>
  movq       mm4,[edi+8]           ; B:<P0F P0E P0D P0C P0B P0A P09 P08>
   movq      mm6,mm7               ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  paddb      mm4,[edi+ebp*1+8]     ; B:<P0F+P1F P0E+P1E P0D+P1D P0C+P1C ...>
   pand      mm7,mm5               ; W:<P2E+P3E P2C+P3C P2A+P3A P28+P38>
  pand       mm6,mm4               ; W:<P0E+P1E P0C+P1C P0A+P1A P08+P18>
   psrlw     mm5,8                 ; W:<P2F+P3F P2D+P3D P2B+P3B P29+P39>
  pmaddwd    mm5,[ebx]             ; D:<P2F+P3F+P2D+P3D P2B+P3B+P29+P39>
   psrlw     mm4,8                 ; W:<P0F+P1F P0D+P1D P0B+P1B P09+P19>
  pmaddwd    mm4,[ebx]             ; D:<P0F+P1F+P0D+P1D P0B+P1B+P09+P19>
   paddw     mm1,mm7               ; W:<sum(P*E) sum(P*C) sum(P*A) sum (P*8)>
  paddw      mm1,mm6               ; W:<sum(P*E) sum(P*C) sum(P*A) sum (P*8)>
   lea       edi,[edi+ebp*4]       ; Advance input cursor
  paddw      mm3,mm5               ; D:<P2F+P3F+P2D+P3D+P27+P37+P25+P35
   ;                               ;    P2B+P3B+P29+P39+P23+P33+P21+P31>
   pcmpeqb   mm5,mm5               ; Next W:<0xFFFF  0xFFFF  0xFFFF  0xFFFF>
  paddw      mm4,mm2               ; D:<P0F+P1F+P0D+P1D+P07+P17+P05+P15
   ;                               ;    P0B+P1B+P09+P19+P03+P13+P01+P11>
   punpckldq mm7,mm3               ; D:<P0B+P1B+P09+P19+P03+P13+P01+P11 junk>
  paddw      mm7,mm3               ; [32:47]:<sum of odd pels of lines 0 and 1>
   punpckldq mm6,mm4               ; W:<P2B+P3B+P29+P39+P23+P33+P21+P31 junk>
  movq       mm2,[edi]             ; Next B:<P07 P06 P05 P04 P03 P02 P01 P00>
   paddw     mm6,mm4               ; [32:47]:<sum of odd pels of lines 2 and 3>
  paddb      mm2,[edi+ebp*1]       ; Next B:<P07+P17 P06+P16 P05+P15 ...>
   punpckhwd mm6,mm7               ; [0:31] W:<Line_0&1_odd  Line_2&3_odd>
  mov        MBlockActionStream,edx
   dec       cl
  movdf      [esi],mm6             ; Save W:<Line_0&1_odd  Line_2&3_odd>
   psrlw     mm5,8                 ; Next W:<0x00FF  0x00FF  0x00FF  0x00FF>
  lea        esi,[esi+4]           ; Advance output cursor
   jne       @b

; ebp -- Pitch
; edi -- Address of candidate reference MB's signature contribs.
; esi -- Address at which target MB's signature contribs were stored, plus 16.
; edx -- Scratch.
; ecx -- Count down number of lines of signatures to try.
; ebx -- Increment to get from end of one line of signatures to start of next.
; al  -- Count down number of signatures to try in a line.
; ah  -- Reinits counter of signatures to try in a line.
; mm0 -- Target MB's sig contrib for first four even columns.
; mm1 -- Target MB's sig contrib for last four even columns.
; mm2 -- Target MB's sig contrib for first four pairs of rows, odd columns.
; mm3 -- Amount and address of best signature seen so far.

IF PITCH-384
*** error:  The magic here assumes a pitch of 384.
ENDIF
  xor        eax,eax
   mov       ecx,TargetToSig_Debiased
  mov        al,EMVLimitsForThisMB+4 ; Lower vert lim for sig srch (half pels)
   xor       ebx,ebx
  add        edi,ecx
   mov       bl,EMVLimitsForThisMB+0 ; Lower horz lim for sig srch (half pels)
  shr        ebx,1
   lea       ecx,[eax+eax*2]
  shl        ecx,6
   add       edi,ebx
  add        edi,ecx
   xor       ecx,ecx
  add        ebx,ebx
   mov       cl,EMVLimitsForThisMB+6 ; Upper vert lim for sig srch (half pels)
  sub        ecx,eax
   mov       al,EMVLimitsForThisMB+2 ; Upper horz lim for sig srch (half pels)
  shr        ecx,3                   ; Number of lines of sigs to do, minus 1.
   sub       eax,ebx
  shr        eax,3                   ; Number of columns of sigs to do.
   lea       ebx,[ebp-1+080000000H]
  sub        ebx,eax                 ; 1/4th amt to add to move to next line.
   mov       ah,al
  inc        ah                      ; To reinit cntr for line.
  movq       mm2,[esi-16]
   pcmpeqd   mm3,mm3                 ; Set winning signature artificially high.
  movdt      mm4,[edi]
   psrld     mm3,2
  punpckldq  mm4,[edi+4]         ; ref sig contribs of left even cols.

TryNextSignature:

  movdt      mm5,[edi+8]
   psubw     mm4,mm0             ; diffs for sums of left even columns.
  punpckldq  mm5,[edi+12]        ; ref sig contribs of right even cols.
   pmaddwd   mm4,mm4             ; Squared differences.
  movdt      mm6,[edi+ebp*2]     ; Sums for first two pairs of rows.
   psubw     mm5,mm1             ; diffs for sums of right even columns.
  punpckldq  mm6,[edi+PITCH*6]   ; Sums for second two pairs of rows.
   pmaddwd   mm5,mm5             ; Squared differences.
  movdt      mm7,[edi+PITCH*10]  ; Sums for third two pairs of rows.
   psubw     mm6,mm2             ; Words: diffs for sums of first 4 pairs rows.
  punpckldq  mm7,[edi+PITCH*14]  ; Sums for last two pairs of rows.
   pmaddwd   mm6,mm6             ; Squared differences.
  psubw      mm7,[esi-8]         ; Words: diffs for sums of first 4 pairs rows.
   paddd     mm4,mm5             ; Accumulate squared differences.
  sub        al,1                ; Decrement line counter.
   pmaddwd   mm7,mm7             ; Squared differences.
  sbb        edx,edx             ; -1 if done with line, else 0.
   paddd     mm6,mm4             ; Accumulate squared differences.
  and        edx,ebx             ; 1/4 Amt to sub to goto next line, else 0.
   paddd     mm7,mm6             ; Accumulate squared differences.
  movdt      mm5,edi             ; Address of this signature
   punpckldq mm6,mm7             ; <low_order_accumulator junk>
  paddd      mm7,mm6             ; <full_signature_amt junk>
   psllq     mm5,32              ; <Addr_of_this_signature     0>
  lea        edi,[edi+edx*4+4]   ; advance signature position to next cand.
   punpckhdq mm5,mm7             ; <cand_signature_amt cand_signature_addr>
  sar        edx,31              ; -1 if done with line, else 0.
   pcmpgtd   mm7,mm3             ; <0xFFFFFFFF if cand not better    junk>
  movdt      mm4,[edi]
   punpckhdq mm7,mm7             ; <0xFFFFFFFFFFFFFFFF if cand not better>
  punpckldq  mm4,[edi+4]
   pand      mm3,mm7             ; 1st_best if cand not better, else 0.
  and        dl,ah               ; Num cols in a line if done with line, else 0.
   pandn     mm7,mm5             ; cand if better than 1st_best, else 0.
  add        al,dl               ; Reinit col count if finishing with line.
   por       mm3,mm7             ; Better of cand and 1st_best.
  sbb        ecx,0               ; Decrement line count if just finished line.
   jge       TryNextSignature

  movdf      ecx,mm3                ; Fetch address of best signature.
   pcmpeqb   mm2,mm2                ; Set cand as worse than prev, in case skip.
  mov        edi,TargetMacroBlockBaseAddr
   mov       ebx,-4                 ; Indicate trying MV of best signature.
  sub        ecx,edi
   mov       eax,SigToTarget
  movdt      mm7,BestMBFullPelSWD   ; Reload SWD for best full pel MB MV.
  lea        esi,[ecx+eax]          ; Linearized motion vector
   add       eax,ecx                ; Linearized motion vector
  sar        esi,8                  ; Full pel vert lin offset div 256.
   mov       edx,MBlockActionStream ; Reload pointer to MBA descriptor.
  shl        eax,25
   punpckldq mm7,mm7
  movsx      ecx,UnlinearizedVertMV[esi]  ; Get full pel vert MV component.
  sar        eax,24                 ; Full pel HMV.
   jmp       ClampHeurMECandidateToRange

HeuristicME_CaseSigMVDone:
HeuristicME_SkipSigMV:

  movdf      eax,mm2                        ; eax == 0 iff cand better, else -1.
   pcmpeqd   mm0,mm0                        ; Init previous best SWD to huge.
  mov        ecx,Addr0MVRef                 ; Start to calc linearized MV.
   mov       bh,EMVLimitsForThisMB+1        ; HMV lower limit.
  mov        BestOfFourStartingPoints[eax*4],esi
   add       bh,4
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   psrlq     mm0,2
  movq       SWDURandLL[eax*8],mm5
   psrld     mm0,14
  mov        eax,BestOfFourStartingPoints
   mov       bl,EMVLimitsForThisMB+5        ; VMV lower limit.
  mov        esi,eax
   sub       eax,ecx                        ; Linearized motion vector
  mov        ecx,eax                        ; Linearized motion vector
   add       al,al                          ; Full pel HMV.
  cmp        al,bh
   jl        ClampHMV_2

  mov        bh,EMVLimitsForThisMB+3        ; HMV upper limit
  sub        bh,4
  cmp        al,bh
   jle       NoClampHMV_2

ClampHMV_2:

  sar        ecx,8                          ; Full pel vert lin offset div 256.
   add       bl,4
  movzx      eax,bh
  movsx      ecx,PB UnlinearizedVertMV[ecx] ; Get full pel vert MV component.
  cmp        cl,bl
   jl        @f

  mov        bl,EMVLimitsForThisMB+7        ; VMV upper limit.
   movq      mm7,mm0
  sub        bl,4
  cmp        cl,bl
   jle       NoClampVMV_2

@@:

  movsx      ecx,bl
  movq       mm7,mm0

NoClampVMV_2:

  sar        eax,1
   lea       ecx,[ecx+ecx*2]
  shl        ecx,6
   mov       ebx,FIRST_HEURISTIC_EXHAUSTIVE_NEW_CTR  ; New state number.
  mov        esi,Addr0MVRef
   add       eax,ecx               ; Linearized motion vector.
  add        esi,eax
   jmp       ComputeMBSWD

NoClampHMV_2:

  sar        ecx,8                          ; Full pel vert lin offset div 256.
   add       bl,4
  mov        ah,bl
  movsx      ecx,PB UnlinearizedVertMV[ecx] ; Get full pel vert MV component.
  cmp        cl,ah
   jl        @f

  mov        ah,EMVLimitsForThisMB+7        ; VMV upper limit.
   lea       esi,[esi+ebp+1]
  sub        ah,4
   mov       ebx,FIRST_HEURISTIC_EXHAUSTIVE ; New state number.
  cmp        cl,ah
   jle       ComputeMBSWD

@@:

  movsx      ecx,ah
  movzx      eax,al
  sar        eax,1
   lea       ecx,[ecx+ecx*2]
  shl        ecx,6
   mov       ebx,FIRST_HEURISTIC_EXHAUSTIVE_NEW_CTR  ; New state number.
  mov        esi,Addr0MVRef
   add       eax,ecx               ; Linearized motion vector.
  add        esi,eax
   movq      mm7,mm0
  jmp        ComputeMBSWD


ZeroMVDoneForNonHeuristicME:

  movq       SWDULandLR,mm6
  movq       SWDURandLL,mm5
  cmp        eax,ZEROVECTORTHRESHOLD ; Compare 0-MV against ZeroVectorThreshold.
   jl        BelowZeroThresh         ; Jump if 0-MV is good enough.

  xor        ecx,ecx
   sub       eax,NONZEROMVDIFFERENTIAL
  mov        cl,StateEngineFirstRule[ebx]     ; MV adjustment.
   mov       bl,StateEngineFirstRule[ebx+10]  ; New state number.
  shl        ecx,11
   mov       SWDForNon0MVToBeat,eax
  movq       SWD0MVULandLR,mm6
  movq       SWD0MVURandLL,mm5
  lea        esi,[esi+ecx-PITCH*8]
   jmp       ComputeMBSWD

MEForNonZeroMVDone:

  movdf      eax,mm2           ; eax == 0 iff cand better, else -1.

MblkEst_EarlyOut:

  xor        ecx,ecx
   test      ebx,ebx
  movq       SWDULandLR[eax*8],mm6 ; Save blk SWDs if better (else toss).
   pcmpeqb   mm2,mm2                 ; Set cand as worse than 0MV.
  mov        cl,StateEngine[eax+ebx*4+1] ; Index of MV adjustment.
   js        HeuristicME_EarlyOut

  add        esi,ecx               ; Adjust ref addr for horz motion.
   mov       bl,StateEngine[eax+ebx*4+3] ; 0:239 -> New state number;
   ;                                     ; 240:255 -> flags which 1/2 pel to do.
  shr        ecx,4
   punpckldq mm7,mm7               ; Put new best in mm7[0:31] and mm7[32:63].
  movq       SWDURandLL[eax*8],mm5
   pxor      mm6,mm6               ; Speculatively zero to prep for half pel ME.
  add        esi,FullPelMotionVectorAdjustment[ecx*4] ; Adjust ref addr for VMV.
   cmp       bl,240                ; Terminal state?
  jb         ComputeMBSWD

  mov        eax,esi
   mov       ecx,Addr0MVRef               ; Start to calc linearized MV.
  sub        eax,ecx                      ; Linearized Motion Vector
   ;
  mov        ecx,eax
   ;
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  add        cl,cl
   ;
  mov        ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
IFDEF H261
ELSE
   mov       eax,DoHalfPelME ; 0 if not, -4 if so.
  test       eax,eax
   je        SkipHalfPelMBME

  cmp        cl,EMVLimitsForThisMB+1      ; Skip half pel ME if at edge of range
   jle       SkipHalfPelMBME

  cmp        cl,EMVLimitsForThisMB+3
   jge       SkipHalfPelMBME

  cmp        ch,EMVLimitsForThisMB+5
   jle       SkipHalfPelMBME

  cmp        ch,EMVLimitsForThisMB+7
   jge       SkipHalfPelMBME


; Registers:
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock
;  edx -- MBlockActionStream
;  ecx -- Nothing presently.
;  edi -- Address of target macroblock.
;  ebx -- 240 + Flags to indicate which half pel ME to do:
;         1 --> right;   2 --> left;   4 --> down;   8 --> up
;  eax -- Count from -4 to -1 for blocks of macroblock.
;  mm0:mm7 -- Scratch

  movdf      BestMBFullPelSWD,mm7   ; Stash SWD for best full pel MB MV.
   pxor      mm7,mm7                ; Prep accumulator for half pel ME.

  call       HalfPelMotionEstimation

  movdt      mm7,InvalidateBadHalfPelMVs[eax*4] ; Need to inflate SWDs for
  ;                                             ; MVs that go off frame edge.
  mov        eax,esi
   mov       ebx,Addr0MVRef               ; Start to calc linearized MV.
  sub        eax,ebx                      ; Linearized Motion Vector
   punpcklbw mm7,mm7                      ; Expand adjustment to words.
  mov        ecx,eax                      ; Linearized Motion Vector
   paddusw   mm7,mm3                      ; Now have SWDs for half pel MBME.
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  add        cl,cl
   movq      mm6,mm7
  mov        [edx].BestFullPelMBHMV,cl    ; Save HMV
   mov       ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
  movdf      eax,mm7                      ; eax[ 0:15] -- SWD for leftward ref.
  ;                                       ; eax[16:31] -- SWD for rightward ref.
   psrlq     mm6,32
  mov        [edx].BestFullPelMBVMV,ch    ; Save VMV
   mov       ebx,eax
  shr        eax,16                       ; eax -- SWD for leftward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for rightward ref.
  cmp        eax,ebx
   jg        MBME_RightBetterThanLeft

MBME_LeftBetterThanRight:

  cmp        eax,BestMBFullPelSWD
   jge       MBME_CtrIsBestHMV

MBME_LeftBestHMV:

  movdf      ebx,mm6                      ; ebx[ 0:15] -- SWD for downward ref.
  ;                                       ; ebx[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,eax
   mov       eax,ebx
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        MBME_LeftBestHMV_DownBetterThanUp

MBME_LeftBestHMV_UpBetterThanDown:

  cmp        eax,BestMBFullPelSWD
   jge       MBME_LeftIsBest

MBME_LeftBestHMV_UpBestVMV:

  sub        esi,PITCH+1                  ; Try ref 1/2 pel left and up
   mov       BestHalfPelVertSWD,eax
  mov        al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
   lea       esi,[esi+ebp*1+1]            ; Back to center.
  cmp        eax,ebx
   jle       MBME_UpBetterThanUpLeft

MBME_UpLeftBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_LeftIsBest

MBME_UpLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-PITCH-1]            ; Best is ref 1/2 pel left and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       MBME_HalfPelSearchDone

MBME_UpBetterThanUpLeft:

  cmp        eax,BestHalfPelHorzSWD
   jg        MBME_LeftIsBest

MBME_UpIsBest:

  mov        ebx,eax
   dec       ch                           ; Back up the vert MV one up.
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       MBME_HalfPelSearchDone

MBME_LeftBestHMV_DownBetterThanUp:

  cmp        ebx,BestMBFullPelSWD
   jge       MBME_LeftIsBest

MBME_LeftBestHMV_DownBestVMV:

  dec        esi                          ; Try ref 1/2 pel left and down
   mov       BestHalfPelVertSWD,ebx
  mov        al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
   inc       esi                          ; Back to center.
  cmp        eax,ebx
   jle       MBME_DownBetterThanDownLeft

MBME_DownLeftBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_LeftIsBest

MBME_DownLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left and down
  inc        ch                           ; Advance the vert MV one down.
   jmp       MBME_HalfPelSearchDone

MBME_DownBetterThanDownLeft:

  cmp        eax,BestHalfPelHorzSWD
   jle       MBME_DownIsBest

MBME_LeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left.
  mov        ebx,BestHalfPelHorzSWD
   jmp       MBME_HalfPelSearchDone

MBME_RightBetterThanLeft:

  cmp        ebx,BestMBFullPelSWD
   jge       MBME_CtrIsBestHMV

MBME_RightBestHMV:

  movdf      eax,mm6                      ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,ebx
   mov       ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        MBME_RightBestHMV_DownBetterThanUp

MBME_RightBestHMV_UpBetterThanDown:

  cmp        eax,BestMBFullPelSWD
   jge       MBME_RightIsBest

MBME_RightBestHMV_UpBestVMV:

  sub        esi,ebp                      ; Try ref 1/2 pel right and up
   mov       BestHalfPelVertSWD,eax
  mov        al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
   lea       esi,[esi+ebp*1]              ; Back to center.
  cmp        eax,ebx
   jle       MBME_UpBetterThanUpRight

MBME_UpRightBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_RightIsBest

MBME_UpRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   lea       eax,[esi-PITCH]              ; Best is ref 1/2 pel right and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       MBME_HalfPelSearchDone

MBME_UpBetterThanUpRight:

  cmp        eax,BestHalfPelHorzSWD
   jle       MBME_UpIsBest

MBME_RightIsBest:

  mov        ebx,BestHalfPelHorzSWD
   inc       cl                           ; Advance the horz MV one to right.
  mov        eax,esi
   jmp       MBME_HalfPelSearchDone

MBME_RightBestHMV_DownBetterThanUp:

  cmp        ebx,BestMBFullPelSWD
   jge       MBME_RightIsBest

MBME_RightBestHMV_DownBestVMV:

  mov        BestHalfPelVertSWD,ebx
   mov       al,4

  call       HalfPelMotionEstimationBothWays

  mov        eax,BestHalfPelVertSWD
  cmp        eax,ebx
   jle       MBME_DownBetterThanDownRight

MBME_DownRightBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       MBME_RightIsBest

MBME_DownRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   mov       eax,esi
  inc        ch                           ; Advance vert MV one down.
   jmp       MBME_HalfPelSearchDone

MBME_DownBetterThanDownRight:

  cmp        eax,BestHalfPelHorzSWD
   jg        MBME_RightIsBest

MBME_DownIsBest:

  mov        ebx,eax
   inc       ch                           ; Advance vert MV one down.
  mov        eax,esi
   jmp       MBME_HalfPelSearchDone

MBME_CtrIsBestHMV:

  movdf      eax,mm6                      ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jge       MBME_CtrBestHMV_DownBetterThanUp

MBME_CtrBestHMV_UpBetterThanDown:

  mov        ebx,BestMBFullPelSWD
  cmp        eax,ebx
   jge       MBME_CenterIsBest

; Up is best.

  mov        ebx,eax
   dec       ch                           ; Back up the vert MV one up.
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       MBME_HalfPelSearchDone

MBME_CtrBestHMV_DownBetterThanUp:

  mov        eax,ebx
   mov       ebx,BestMBFullPelSWD
  cmp        eax,ebx
   jge       MBME_CenterIsBest

; Down is best.

  mov        ebx,eax
   inc       ch                           ; Advande the vert MV one down.
  mov        eax,esi
   jmp       MBME_HalfPelSearchDone

ENDIF

SkipHalfPelMBME:

  mov        [edx].BestFullPelMBHMV,cl    ; Save HMV
  movdf      ebx,mm7                      ; SWD for best full pel MB MV.
  mov        [edx].BestFullPelMBVMV,ch    ; Save VMV

MBME_CenterIsBest:

  mov        eax,esi

MBME_HalfPelSearchDone:

  mov        BestMBHalfPelSWD,ebx
   mov       BestMBHalfPelMV,cl           ; Save HMV
  mov        BestMBHalfPelRefAddr,eax
   mov       BestMBHalfPelMV+1,ch         ; Save VMV

IFDEF H261
ELSE ; H263
  mov        bl,EMVLimitsForThisMB+1     ; Lower limit comparison.
   mov       al,DoBlockLevelVectors      ; Are we doing block level MVs?
  dec        al
   jne       NoBlockMotionVectors

  mov        cl,[edx].CodedBlocks        ; Fetch coded block pattern.
   add       bl,2
  and        cl,080H
   jne       NoBlockMotionVectors        ; Skip Block ME if forced intra.

  mov        al,[edx].BestFullPelMBHMV   ; Compare full pel HMV against limits.
   mov       cl,EMVLimitsForThisMB+3
  cmp        al,bl
   jl        NoBlockMotionVectors

  mov        bl,EMVLimitsForThisMB+5
   sub       cl,2
  cmp        al,cl                       ; Upper limit comparison.
   jg        NoBlockMotionVectors

  mov        al,[edx].BestFullPelMBVMV   ; Compare full pel VMV against limits.
   add       bl,2
  mov        cl,EMVLimitsForThisMB+7
   cmp       al,bl
  mov        ebx,PD [edx].BestFullPelMBVMV-3
   jl        NoBlockMotionVectors

  sar        ebx,18
   sub       cl,2
  cmp        al,cl                       ; Upper limit comparison.
   jg        NoBlockMotionVectors

  mov        ecx,BestMBHalfPelSWD        ; Jump if SWD for MB MV < thresh.
IF PITCH-384
*** error:  The magic here assumes a pitch of 384.
ENDIF
   and       ebx,0FFFFFF80H              ; VMV*128
  cmp        ecx,BLOCKMOTIONTHRESHOLD
   jle       NoBlockMotionVectors

;==========================================================================
; Starting from the best full pel macroblock motion vector calculated above, we
; search for the best block motion vectors.
;
;  ebp -- PITCH
;  esi -- Address of ref block.
;  edi -- Address of target block.
;  edx -- Induction variable over luma blocks in MBlockAction Descriptor.
;  ecx -- Scratch
;  ebx -- CurrSWDState
;  eax -- Scratch
;  mm7 -- Best SWD for current block
;  mm6 -- unused.
;  mm5 -- Best SWD for right block of pair worked on by inner loop.
;  mm0-mm4 Scratch
;

  movq       mm0,HalfPelMBMESWDAccum+8
  movq       mm1,HalfPelMBMESWDAccum+16
   psubusw   mm7,mm0
  movq       mm2,HalfPelMBMESWDAccum+0
   psubusw   mm0,mm1
  movq       [edx].BlkY4.BlkLvlSWD+16,mm7
   psubusw   mm1,mm2
  movq       [edx].BlkY2.BlkLvlSWD+16,mm0
  movq       [edx].BlkY3.BlkLvlSWD+16,mm1
  movq       [edx].BlkY1.BlkLvlSWD+16,mm2

  movsx      eax,[edx].BestFullPelMBHMV
  sar        eax,1
   lea       ebx,[ebx+ebx*2]
  mov        esi,Addr0MVRef
   add       ebx,ebp
  mov        Addr0MVRefBlk,esi
   add       esi,eax
  lea        ecx,[ecx+ecx*2]               ; Best MBMV SWD times 3.
   add       esi,ebx                       ; Try V+1 first
  shr        ecx,2                         ; Best MBMV SWD * 3/4.
   mov       eax,SWDForNon0MVToBeat
  mov        BestBlockRefAddrVP1,esi       ; Stash BestBlockRefAddr
   sub       ecx,BLOCKMVDIFFERENTIAL       ; Best MBMV SWD * 3/4 - Differential.
  lea        eax,[eax+eax*2-BLOCKMVDIFFERENTIAL*4] ; Non0MBMVSWDToBeat*3-4*Diff.
   mov       LimitForSWDForBlkMV,ecx
  shr        eax,2                         ; Non0MBMVSWDToBeat * 3/4.
   mov       ebx,FIRSTBLOCKMESTATE
  cmp        eax,ecx
   jg        @f

  mov        LimitForSWDForBlkMV,eax
   mov       ecx,eax

@@:

  movdt      mm5,SWDURandLL     ; Get SWD for best MB level full pel MVs, blk 2.
  test       ecx,ecx
   jle       NoBlockMotionVectors
  movdt      mm7,SWDULandLR     ; Get SWD for best MB level full pel MVs, blk 1.
  movdf      SWDForBlock2Or4,mm5

;============================================================================
; Compute SWD for block.

DoBlkMEForNextBlk:
ComputeBlkSWD:

  movq       mm0,[esi+ebp*1]
  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.
  movq       mm1,[esi+PITCH*3] ; Ref MB, upper left block, Line 3.
   psllw     mm0,8             ; Extract diffs for line 1 even pels.
  psubw      mm1,[edi+PITCH*3] ; Diff for line 3.
   pmaddwd   mm0,mm0           ; Square of diffs for even pels of line 1.
  movq       mm2,[esi+PITCH*5]
   psllw     mm1,8
  psubw      mm2,[edi+PITCH*5]
   pmaddwd   mm1,mm1
  movq       mm3,[esi+PITCH*7]
   psllw     mm2,8
  psubw      mm3,[edi+PITCH*7]
   pmaddwd   mm2,mm2
  movq       mm4,[esi]         ; Ref MB, upper left blk, Line 0.
   psllw     mm3,8
  psubw      mm4,[edi]         ; Diff for line 0.
   paddusw   mm0,mm1           ; Accumulate SWD (lines 0 and 2).
  movq       mm1,[esi+ebp*2]
   pmaddwd   mm3,mm3
  psubw      mm1,[edi+ebp*2]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebp*4]
   pmaddwd   mm4,mm4           ; Square of diffs for odd pels of line 0.
  psubw      mm2,[edi+ebp*4]
   paddusw   mm0,mm3
  movq       mm3,[esi+PITCH*6]
   pmaddwd   mm1,mm1
  psubw      mm3,[edi+PITCH*6]
   pmaddwd   mm2,mm2
  paddusw    mm0,mm4
   pmaddwd   mm3,mm3
  paddusw    mm0,mm1
   ;
  paddusw    mm0,mm2
   ;
  paddusw    mm0,mm3
   ;
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   movq      mm4,mm7           ; Get original Best SWD for block

  paddusw    mm1,mm0           ; mm1[48:63] is SWD for block.
   pxor      mm2,mm2
  psrlq      mm1,48            ; mm1 is SWD for block.
   ;
  psubusw    mm4,mm1
   xor       ecx,ecx
  pcmpeqd    mm2,mm4           ; mm2[0:31] == 0 iff cand better, else -1.
   psubusw   mm7,mm4           ; BestSWD dim (BestSWD dim CandSWD) --> new best.
  ;
   ;
  movdf      eax,mm2           ; edi == 0 iff cand better, else -1.
   ;

;  Registers at this point:
;  ebp -- PITCH
;  esi -- Address of block of candidate ref area.
;  edi -- 0 iff candidate SWD better, else -1.
;  edx -- Induction variable over luma blocks in MBlockAction Descriptor.
;  ecx -- Scratch
;  ebx -- CurrSWDState.
;  eax -- CurrSWDState.
;  mm7 -- New best SWD for current block
;  mm6 -- Unused.

  movq       [edx].BlkY1.BlkLvlSWD,mm7   ; Save best blk level SWD.
   pxor      mm6,mm6                     ; Spec zero to prep for half pel ME.
  mov        cl,StateEngine[eax+ebx*4+1] ; Index of MV adjustment.
   mov       bl,StateEngine[eax+ebx*4+3] ; New state number; 255 means done.
  add        esi,ecx                     ; Adjust ref addr for horz motion.
   mov       eax,DoHalfPelME             ; 0 if not, -4 if so.
  shr        ecx,4
   cmp       bl,240                      ; Terminal state?
  jae        @f

  add        esi,FullPelMotionVectorAdjustment[ecx*4] ; Adjust ref addr for VMV.
   jmp       ComputeBlkSWD

@@:
  add        esi,FullPelMotionVectorAdjustment[ecx*4] ; Adjust ref addr for VMV.
   add       eax,4
  mov        ecx,esi
   jne       SkipHalfPelBlkME

; Registers:
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock
;  edx -- Induction variable over luma blocks in MBlockAction Descriptor.
;  ecx -- Copy of esi.
;  edi -- Address of target block.
;  ebx -- Scratch
;  eax -- Set to 0 to cause HalfPelMotionEstimation to quit after one block.
;  mm0:mm7 -- Scratch

  mov        ebx,BestBlockRefAddrVP1
   add       ecx,ebp
  cmp        ebx,ecx
   jne       FullPelBlkMEMovedFromCenter

  movdf      BestBlkFullPelSWD,mm7        ; Stash SWD for best full pel MB MV.
  movq       mm3,[edx].BlkY1.BlkLvlSWD+16 ; SWDs: H+1, H-1, V+1, V-1.
  jmp        FullPelBlkMEDidNotMoveFromCenter

FullPelBlkMEMovedFromCenter:

  movdf      BestBlkFullPelSWD,mm7   ; Stash SWD for best full pel MB MV.
   pxor      mm7,mm7                 ; Prep accumulator for half pel ME.

  call       HalfPelMotionEstimation

  lea        esi,[esi+ebp*8+8]            ; Fix reference pointer.
   lea       edi,[edi+ebp*8+8]            ; Fix target pointer.

FullPelBlkMEDidNotMoveFromCenter:

  mov        eax,esi
   mov       ebx,Addr0MVRefBlk            ; Start to calc linearized MV.
  sub        ecx,ebx                      ; Linearized Motion Vector
   sub       eax,ebx                      ; Linearized Motion Vector
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  movdf      ebx,mm3                      ; ebx[ 0:15] -- SWD for leftward ref.
  ;                                       ; ebx[16:31] -- SWD for rightward ref.
   psrlq     mm3,32
  mov        ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
   mov       eax,ebx
  shr        eax,16                       ; eax -- SWD for leftward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for rightward ref.
  cmp        eax,ebx
   jg        BlkME_RightBetterThanLeft

BlkME_LeftBetterThanRight:

  add        cl,cl
   mov       ebx,BestBlkFullPelSWD
  cmp        eax,ebx
   jge       BlkME_CtrIsBestHMV

BlkME_LeftBestHMV:

  movdf      ebx,mm3                      ; ebx[ 0:15] -- SWD for downward ref.
  ;                                       ; ebx[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,eax
   mov       eax,ebx
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        BlkME_LeftBestHMV_DownBetterThanUp

BlkME_LeftBestHMV_UpBetterThanDown:

  cmp        eax,BestBlkFullPelSWD
   jge       BlkME_LeftIsBest

BlkME_LeftBestHMV_UpBestVMV:

  sub        esi,PITCH+1                  ; Try ref 1/2 pel left and up
   mov       BestHalfPelVertSWD,eax
  mov        al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+PITCH*9+9]          ; Back to center.
   cmp       eax,ebx
  jle        BlkME_UpBetterThanUpLeft

BlkME_UpLeftBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_LeftIsBest

BlkME_UpLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-PITCH-1]            ; Best is ref 1/2 pel left and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       BlkME_HalfPelSearchDone

BlkME_UpBetterThanUpLeft:

  cmp        eax,BestHalfPelHorzSWD
   jg        BlkME_LeftIsBest

BlkME_UpIsBest:

  dec        ch                           ; Back up the vert MV one up.
   mov       ebx,eax
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       BlkME_HalfPelSearchDone

BlkME_LeftBestHMV_DownBetterThanUp:

  cmp        ebx,BestBlkFullPelSWD
   jge       BlkME_LeftIsBest

BlkME_LeftBestHMV_DownBestVMV:

  dec        esi                          ; Try ref 1/2 pel left and down
   mov       BestHalfPelVertSWD,ebx
  mov        al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+ebp*8+9]            ; Back to center.
   cmp       eax,ebx
  jle        BlkME_DownBetterThanDownLeft

BlkME_DownLeftBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_LeftIsBest

BlkME_DownLeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left and down
  inc        ch                           ; Advance the vert MV one down.
   jmp       BlkME_HalfPelSearchDone

BlkME_DownBetterThanDownLeft:

  cmp        eax,BestHalfPelHorzSWD
   jle       BlkME_DownIsBest

BlkME_LeftIsBest:

  dec        cl                           ; Back up the horz MV one to the left.
   lea       eax,[esi-1]                  ; Best is ref 1/2 pel left.
  mov        ebx,BestHalfPelHorzSWD
   jmp       BlkME_HalfPelSearchDone

BlkME_RightBetterThanLeft:

  add        cl,cl
   mov       eax,BestBlkFullPelSWD
  cmp        eax,ebx
   jle       BlkME_CtrIsBestHMV

BlkME_RightBestHMV:

  movdf      eax,mm3                    ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        BestHalfPelHorzSWD,ebx
   mov       ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jg        BlkME_RightBestHMV_DownBetterThanUp

BlkME_RightBestHMV_UpBetterThanDown:

  cmp        eax,BestBlkFullPelSWD
   jge       BlkME_RightIsBest

BlkME_RightBestHMV_UpBestVMV:

  sub        esi,ebp                      ; Try ref 1/2 pel right and up
   mov       BestHalfPelVertSWD,eax
  mov        al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+PITCH*9+8]          ; Back to center.
   cmp       eax,ebx
  jle        BlkME_UpBetterThanUpRight

BlkME_UpRightBetterThanUp:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_RightIsBest

BlkME_UpRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   lea       eax,[esi-PITCH]              ; Best is ref 1/2 pel right and up
  dec        ch                           ; Back up the vert MV one up.
   jmp       BlkME_HalfPelSearchDone

BlkME_UpBetterThanUpRight:

  cmp        eax,BestHalfPelHorzSWD
   jle       BlkME_UpIsBest

BlkME_RightIsBest:

  mov        ebx,BestHalfPelHorzSWD
   inc       cl                           ; Advance the horz MV one to right.
  mov        eax,esi
   jmp       BlkME_HalfPelSearchDone

BlkME_RightBestHMV_DownBetterThanUp:

  cmp        ebx,BestBlkFullPelSWD
   jge       BlkME_RightIsBest

BlkME_RightBestHMV_DownBestVMV:

  mov        BestHalfPelVertSWD,ebx
   mov       al,1

  call       HalfPelMotionEstimationBothWays

  lea        edi,[edi+ebp*8+8]
   mov       eax,BestHalfPelVertSWD
  lea        esi,[esi+ebp*8+8]            ; Back to center.
   cmp       eax,ebx
  jle        BlkME_DownBetterThanDownRight

BlkME_DownRightBetterThanDown:

  cmp        ebx,BestHalfPelHorzSWD
   jge       BlkME_RightIsBest

BlkME_DownRightIsBest:

  inc        cl                           ; Advance the horz MV one to right.
   mov       eax,esi
  inc        ch                           ; Advance vert MV one down.
   jmp       BlkME_HalfPelSearchDone

BlkME_DownBetterThanDownRight:

  cmp        eax,BestHalfPelHorzSWD
   jg        BlkME_RightIsBest

BlkME_DownIsBest:

  inc        ch                           ; Advance vert MV one down.
   mov       ebx,eax
  mov        eax,esi
   jmp       BlkME_HalfPelSearchDone

BlkME_CtrIsBestHMV:

  movdf      eax,mm3                    ; eax[ 0:15] -- SWD for downward ref.
  ;                                       ; eax[16:31] -- SWD for upward ref.
  mov        ebx,eax
  shr        eax,16                       ; eax -- SWD for upward ref.
   and       ebx,00000FFFFH               ; ebx -- SWD for downward ref.
  cmp        eax,ebx
   jge       BlkME_CtrBestHMV_DownBetterThanUp

BlkME_CtrBestHMV_UpBetterThanDown:

  mov        ebx,BestBlkFullPelSWD
  cmp        eax,ebx
   jge       BlkME_CenterIsBest

; Up is best.

  mov        ebx,eax
   dec       ch                           ; Back up the vert MV one up.
  lea        eax,[esi-PITCH]              ; Best is ref 1/2 pel up
   jmp       BlkME_HalfPelSearchDone

BlkME_CtrBestHMV_DownBetterThanUp:

  mov        eax,ebx
   mov       ebx,BestBlkFullPelSWD
  cmp        eax,ebx
   jge       BlkME_CenterIsBest

; Down is best.

  mov        ebx,eax
   inc       ch                           ; Advande the vert MV one down.
  mov        eax,esi
   jmp       BlkME_HalfPelSearchDone

SkipHalfPelBlkME:

  mov        eax,esi
   mov       ebx,Addr0MVRefBlk            ; Start to calc linearized MV.
  sub        ecx,ebx                      ; Linearized Motion Vector
   sub       eax,ebx                      ; Linearized Motion Vector
  sar        eax,8                        ; Full pel vert lin offset div 256.
   and       cl,07FH                      ; Full pel HMV
  add        cl,cl
   ;
  mov        ch,UnlinearizedVertMV[eax]   ; Get full pel vert MV component.
   ;
  movdf      ebx,mm7                      ; SWD for best full pel block MV.

BlkME_CenterIsBest:

  mov        eax,esi

BlkME_HalfPelSearchDone:

  mov        [edx].BlkY1.BlkLvlSWD,ebx
   mov       [edx].BlkY1.PastRef,eax
  mov        [edx].BlkY1.PHMV,cl        ; Save HMV
   mov       eax,LimitForSWDForBlkMV    ; Does block's SWD put us over limit?
  mov        [edx].BlkY1.PVMV,ch        ; Save VMV
   sub       eax,ebx
  jl         BlkEst_EarlyOut

  mov        LimitForSWDForBlkMV,eax ; Remember how much is left for other blks.
   mov       esi,BestBlockRefAddrVP1
  add        edi,8                      ; Move to blk 2 or 4, V+4.
   mov       ecx,Addr0MVRefBlk          ; Calc addr of 0MV ref for this blk.
  add        esi,8                      ; Move to blk 2 or 4, V+4.
   add       ecx,8
  mov        Addr0MVRefBlk,ecx
   add       edx,SIZEOF T_Blk           ; Increment to next block.
  test       dl,SIZEOF T_Blk
  movdt      mm7,SWDForBlock2Or4
  mov        ebx,FIRSTBLOCKMESTATE
   jne       DoBlkMEForNextBlk          ; If so, go do blk 2 or 4.

  lea        esi,[esi+ebp*8-8]          ; Move to blk 3
   lea       ecx,[ecx+ebp*8-16]
  mov        BestBlockRefAddrVP1,esi
   lea       edi,[edi+ebp*8-16]
  movdt      mm5,SWDULandLR+4           ; Get SWD for best MB level MVs, blk 4.
  movdt      mm7,SWDURandLL+4           ; Get SWD for best MB level MVs, blk 3.
  movdf      SWDForBlock2Or4,mm5
  test       dl,2*SIZEOF T_Blk          ; Just finishing blk 2?
  mov        Addr0MVRefBlk,ecx
   jne       DoBlkMEForNextBlk          ; If so, go do blk 3.

;==============================================================================
; Block motion vectors are best.

  mov        esi,[edx-4*SIZEOF T_Blk].BlkY1.BlkLvlSWD
   mov       edi,[edx-4*SIZEOF T_Blk].BlkY4.BlkLvlSWD
  mov        SWDULandLR,esi
   mov       SWDULandLR+4,edi
  mov        esi,[edx-4*SIZEOF T_Blk].BlkY3.BlkLvlSWD
   mov       edi,[edx-4*SIZEOF T_Blk].BlkY2.BlkLvlSWD
  mov        eax,[edx-4*SIZEOF T_Blk].BlkY1.MVs
   mov       ebx,[edx-4*SIZEOF T_Blk].BlkY2.MVs
  mov        ecx,eax
   xor       eax,ebx
  xor        ecx,[edx-4*SIZEOF T_Blk].BlkY3.MVs
   xor       ebx,[edx-4*SIZEOF T_Blk].BlkY4.MVs
  mov        SWDURandLL,edi
   or        eax,ebx
  sub        edx,4*SIZEOF T_Blk         ; Restore MacroBlockActionStream ptr.
   or        eax,ecx
  test       eax,0FFFFH
   mov       SWDURandLL+4,esi
  je         MotionVectorSettled

  mov        al,INTER4MV               ; Set type for MB to INTER-coded, 4 MVs.
  mov        [edx].BlockType,al
   jmp       MotionVectorSettled

BlkEst_EarlyOut:

  and        edx,-1-3*SIZEOF T_Blk
   mov       ecx,BestMBHalfPelSWD       ; Get total SWD for macroblock MV.

BlockMVNotBigEnoughGain:               ; Try MB-level motion vector.

  cmp        ecx,SWDForNon0MVToBeat
   jge       NonZeroMVNotBigEnoughGain

ENDIF ; H263

  mov        ebx,BestMBHalfPelMV
   mov       esi,BestMBHalfPelRefAddr         ; Reload BestMBHalfPelRefAddr

NonZeroMBLevelMVBest:

; Non-zero macroblock level motion vector is best.

  mov        [edx].BlkY1.MVs,ebx
   mov       [edx].BlkY2.MVs,ebx
  mov        [edx].BlkY3.MVs,ebx
   mov       [edx].BlkY4.MVs,ebx
  mov        [edx].BlkY1.PastRef,esi
   lea       ecx,[esi+ebp*8]
  mov        [edx].BlkY3.PastRef,ecx
   add       esi,8
  mov        [edx].BlkY2.PastRef,esi
   add       ecx,8
  mov        [edx].BlkY4.PastRef,ecx
   jmp       MotionVectorSettled

NoBlockMotionVectors:

  mov        ecx,BestMBHalfPelSWD       ; Get total SWD for macroblock MV.
   mov       eax,SWDForNon0MVToBeat
  cmp        eax,ecx
   mov       ebx,BestMBHalfPelMV
  mov        esi,BestMBHalfPelRefAddr
   jge       NonZeroMBLevelMVBest

NonZeroMVNotBigEnoughGain:

  mov        esi,Addr0MVRef             ; 0-MV ref block.
  movq       mm6,SWD0MVULandLR
  movq       mm5,SWD0MVURandLL
  movq       SWDULandLR,mm6
  movq       SWDURandLL,mm5

BelowZeroThresh:

  mov        [edx].BlkY1.PastRef,esi   ; Save address of ref block, all blks.
   lea       eax,[esi+8]
  mov        [edx].BlkY2.PastRef,eax
   lea       eax,[esi+ebp*8]
  mov        [edx].BlkY3.PastRef,eax
   add       eax,8
  mov        [edx].BlkY4.PastRef,eax
   xor       eax,eax
  mov        [edx].BlkY1.MVs,eax       ; Set horz and vert MVs to 0 in all blks.
   mov       [edx].BlkY2.MVs,eax
  mov        [edx].BlkY3.MVs,eax
   mov       [edx].BestFullPelMBHMV,al
  mov        [edx].BlkY4.MVs,eax
   mov       [edx].BestFullPelMBVMV,al
  mov        BestMBHalfPelMV,eax


MotionVectorSettled:

IFDEF H261

;===============================================================================
; For H261, we've settled on the best motion vector.  Now we need to determine
; if spatial filtering should be done.
;
;  ebp -- PITCH
;  esi -- Address of block of ref area.
;  edi -- Address of spatially filtred block.
;  edx -- MBlockActionStream
;  ecx -- Loop counter.
;  ebx -- Address of constant 0x7F in all 8 bytes.
;  eax -- Scratch
;  mm7 -- Mask to extract bytes 0 and 7.  (High bit of bytes 1:6 must be off).
;  mm6 -- All bytes -1.
;  mm5 -- Mask to extract bytes 1:6 and clear bit 8 thereof.

  movdf      esi,mm7                 ; Restore non-SLF SWD for macroblock.
  cmp        esi,SpatialFiltThreshold
   jle       SkipSpatialFiltering

  mov        ecx,DoSpatialFiltering   ; Are we doing spatial filtering?
   mov       esi,[edx].BlkY1.PastRef
  test       cl,cl
   je        SkipSpatialFiltering

DoSpatialFilterForChroma:
DoSpatialFilterForLuma:

  movq       mm5,C7F7F7F7F7F7F7F7F   ; Mask to extract bytes 1:6.
  movdf      BestMBFullPelSWD,mm7    ; Stash SWD for best full pel MB MV.
   psllq     mm5,16
  psrlq      mm5,8
   pcmpeqb   mm7,mm7
  pxor       mm7,mm5                 ; Mask to extract bytes 0 and 7.
   mov       edi,SpatiallyFilteredMB
  lea        eax,[esi+ebp*4]
   lea       ebx,C7F7F7F7F7F7F7F7F ; Address of this useful constant.

SpatialFilterLoop:

  movq       mm0,[esi]      ; 0a: <P7 P6 P5 P4 P3 P2 P1 P0>
   pcmpeqb   mm6,mm6        ;     To add one to all bytes.
  movq       mm4,mm0        ; 0b: <P7 P6 P5 P4 P3 P2 P1 P0>
   psllq     mm0,16         ; 0c: <P5 P4 P3 P2 P1 P0  0  0>
  movq       mm3,[esi+ebp*1]; 1a
   paddb     mm0,mm4        ; 0d: <P7+P5 P6+P4 ... P3+P1 P2+P0 jnk  jnk >
  movq       mm1,mm3        ; 1b
   psrlq     mm0,9          ; 0e: <0  (P7+P5)/2 ... (P2+P0)/2 jnk>  (dirty)

SpatialFilterLoop_BlockToRight:

  pand       mm0,mm5        ; 0f: <0  (P7+P5)/2 ... (P2+P0)/2    0>  (clean)
   psllq     mm1,16         ; 1c
  paddb      mm0,mm4        ; 0g: <jnk   (P7+2P6+P5)/2 ...  (P2+2P1+P0)/2 jnk>
   paddb     mm1,mm3        ; 1d
  psubb      mm0,mm6        ; 0h: <jnk (P7+2P6+P5+2)/2 ... (P2+2P1+P0+2)/2 jnk>
   psrlq     mm1,9          ; 1e
  psrlq      mm0,1          ; 0i: <jnk (P7+2P6+P5+2)/4 ... (P2+2P1+P0+2)/2 jnk>
   pand      mm4,mm7        ; 0j: <P7  0  0  0  0  0  0 P0>
  pand       mm0,mm5        ; 0k: < 0 (P7+2P6+P5+2)/4 ... (P2+2P1+P0+2)/2  0>
   pand      mm1,mm5        ; 1f
  por        mm0,mm4        ; 0l: <P7 (P7+2P6+P5+2)/4 ... (P2+2P1+P0+2)/4 P0>
   paddb     mm1,mm3        ; 1g
  movq       mm2,[esi+ebp*2]; 2a
   psubb     mm1,mm6        ; 1h
  movq       [edi],mm0      ; 0m: Store line 0 of filtered block.  This is R0.
   movq      mm4,mm2        ; 2b
  psrlq      mm1,1          ; 1i
   pand      mm3,mm7        ; 1j
  pand       mm1,mm5        ; 1k
   psllq     mm2,16         ; 2c
  por        mm1,mm3        ; 1l: This is R1
   paddb     mm2,mm4        ; 2d
  psubb      mm1,mm6               ; 1A: R1+1
   psrlq     mm2,9                 ; 2e
  pand       mm2,mm5               ; 2f
   paddb     mm0,mm1               ; 1B: R0+R1+1
  paddb      mm2,mm4               ; 2g
   psrlq     mm0,1                 ; 1C: (R0+R1+1)/2  (dirty)
  pand       mm0,[ebx]             ; 1D: (R0+R1+1)/2  (clean)
   psubb     mm2,mm6               ; 2h
  psrlq      mm2,1                 ; 2i
   pand      mm4,mm7               ; 2j
  movq       mm3,[esi+PITCH*3]     ; 3a
   pand      mm2,mm5               ; 2k
  por        mm2,mm4               ; 2l:  This is R2.
   movq      mm4,mm3               ; 3b
  paddb      mm1,mm2               ; 1E & 2B: R1+R2+1
   psllq     mm3,16                ; 3c
  psrlq      mm1,1                 ; 1F & 2C: (R1+R2+1)/2  (dirty)
   paddb     mm3,mm4               ; 3d
  pand       mm1,[ebx]             ; 1G & 2D: (R1+R2+1)/2  (clean)
   psrlq     mm3,9                 ; 3e
  paddb      mm0,mm1               ; 1H:  (R0+2R1+R2+2)/2
   pand      mm3,mm5               ; 3f
  psrlq      mm0,1                 ; 1I:  (R0+2R1+R2+2)/4  (dirty)
   paddb     mm3,mm4               ; 3g
  pand       mm0,[ebx]             ; 1J:  (R0+2R1+R2+2)/4  (clean)
   psubb     mm3,mm6               ; 3h
  psrlq      mm3,1                 ; 3i
   pand      mm4,mm7               ; 3j
  movq       [edi+ebp*1],mm0       ; 1K: Store line 1 of filtered block.
   pand      mm3,mm5               ; 3k
  movq       mm0,[eax]             ; 4a
   por       mm3,mm4               ; 3l
  psubb      mm3,mm6               ; 3A: R3+1
   movq      mm4,mm0               ; 4b
  paddb      mm2,mm3               ; 2E & 3B: R2+R3+1
   psllq     mm0,16                ; 4c
  psrlq      mm2,1                 ; 2F & 3C: (R2+R3+1)/2  (dirty)
   paddb     mm0,mm4               ; 4d
  pand       mm2,[ebx]             ; 2G & 3D: (R2+R3+1)/2  (clean)
   psrlq     mm0,9                 ; 4e
  paddb      mm1,mm2               ; 2H:  (R1+2R2+R3+2)/2
   pand      mm0,mm5               ; 4f
  psrlq      mm1,1                 ; 2I:  (R1+2R2+R3+2)/4  (dirty)
   paddb     mm0,mm4               ; 4g
  pand       mm1,[ebx]             ; 2J:  (R1+2R2+R3+2)/4  (clean)
   psubb     mm0,mm6               ; 4h
  psrlq      mm0,1                 ; 4i
   pand      mm4,mm7               ; 4j
  movq       [edi+ebp*2],mm1       ; 2K: Store line 2 of filtered block.
   pand      mm0,mm5               ; 4k
  movq       mm1,[eax+ebp*1]       ; 5a
   por       mm0,mm4               ; 4l
  movq       mm4,mm1               ; 5b
   psllq     mm1,16                ; 5c
  paddb      mm3,mm0               ; 3E & 4B: R3+R4+1
   paddb     mm1,mm4               ; 5d
  add        esi,8
   psrlq     mm3,1                 ; 3F & 4C: (R3+R4+1)/2  (dirty)
  pand       mm3,[ebx]             ; 3G & 4D: (R3+R4+1)/2  (clean)
   psrlq     mm1,9                 ; 5e
  paddb      mm2,mm3               ; 3H:  (R2+2R3+R4+2)/2
   pand      mm1,mm5               ; 5f
  psrlq      mm2,1                 ; 3I:  (R2+2R3+R4+2)/4  (dirty)
   paddb     mm1,mm4               ; 5g
  pand       mm2,[ebx]             ; 3J:  (R2+2R3+R4+2)/4  (clean)
   psubb     mm1,mm6               ; 5h
  psrlq      mm1,1                 ; 5i
   pand      mm4,mm7               ; 5j
  movq       [edi+PITCH*3],mm2     ; 3K: Store line 3 of filtered block.
   pand      mm1,mm5               ; 5k
  movq       mm2,[eax+ebp*2]       ; 6a
   por       mm1,mm4               ; 5l
  psubb      mm1,mm6               ; 5A: R5+1
   movq      mm4,mm2               ; 6b
  paddb      mm0,mm1               ; 4E & 5B: R4+R5+1
   psllq     mm2,16                ; 6c
  psrlq      mm0,1                 ; 4F & 5C: (R4+R5+1)/2  (dirty)
   paddb     mm2,mm4               ; 6d
  pand       mm0,[ebx]             ; 4G & 5D: (R4+R5+1)/2  (clean)
   psrlq     mm2,9                 ; 6e
  paddb      mm3,mm0               ; 4H:  (R3+2R4+R5+2)/2
   pand      mm2,mm5               ; 6f
  psrlq      mm3,1                 ; 4I:  (R3+2R4+R5+2)/4  (dirty)
   paddb     mm2,mm4               ; 6g
  pand       mm3,[ebx]             ; 4J:  (R3+2R4+R5+2)/4  (clean)
   psubb     mm2,mm6               ; 6h
  psrlq      mm2,1                 ; 6i
   sub       cl,2                  ;     Loop control
  movq       [edi+ebp*4],mm3       ; 4K: Store line 4 of filtered block.
   pand      mm4,mm7               ; 6j
  movq       mm3,[eax+PITCH*3]     ; 7a
   pand      mm2,mm5               ; 6k
  por        mm2,mm4               ; 6l
   movq      mm4,mm3               ; 7b
  paddb      mm1,mm2               ; 5E & 6B: R5+R6+1
   psllq     mm3,16                ; 7c
  psrlq      mm1,1                 ; 5F & 6C: (R5+R6+1)/2  (dirty)
   paddb     mm3,mm4               ; 7d
  pand       mm1,[ebx]             ; 5G & 6D: (R5+R6+1)/2  (clean)
   psrlq     mm3,9                 ; 7e
  paddb      mm0,mm1               ; 5H:  (R4+2R5+R6+2)/2
   pand      mm3,mm5               ; 7f
  psrlq      mm0,1                 ; 5I:  (R4+2R5+R6+2)/4  (dirty)
   paddb     mm3,mm4               ; 7g
  pand       mm0,[ebx]             ; 5J:  (R4+2R5+R6+2)/4  (clean)
   psubb     mm3,mm6               ; 7h
  psrlq      mm3,1                 ; 7i
   pand      mm4,mm7               ; 7j
  movq       [edi+PITCH*5],mm0     ; 5K: Store line 5 of filtered block.
   pand      mm3,mm5               ; 7k
  psubb      mm2,mm6               ; 7A: R6+1
   por       mm3,mm4               ; 7l
  paddb      mm2,mm3               ; 6E: R6+R7+1
   lea       eax,[esi+ebp*4]
  movq       mm0,[esi]             ; 0a:  for next iteration
   psrlq     mm2,1                 ; 6F: (R6+R7+1)/2  (dirty)
  pand       mm2,[ebx]             ; 6G: (R6+R7+1)/2  (clean)
   movq      mm4,mm0               ; 0b:  for next iteration
  movq       [edi+PITCH*7],mm3     ; 7m: Store line 7 of filtered block.
   paddb     mm1,mm2               ; 6H: (R5+2R6+R7+2)/2
  lea        edi,[edi+8]           ;     Advance output cursor.
   psrlq     mm1,1                 ; 6I: (R5+2R6+R7+2)/4  (dirty)
  pand       mm1,[ebx]             ; 6J: (R5+2R6+R7+2)/4  (clean)
   psllq     mm0,16                ; 0c:  for next iteration
  movq       mm3,[esi+ebp*1]       ; 1a:  for next iteration
   paddb     mm0,mm4               ; 0d:  for next iteration
  movq       [edi+PITCH*6-8],mm1   ; 6K: Store line 6 of filtered block.
   movq      mm1,mm3               ; 1b:  for next iteration
  psrlq      mm0,9                 ; 0e:  for next iteration
   jg        SpatialFilterLoop_BlockToRight

  lea        esi,[esi+ebp*8-16]
   lea       eax,[eax+ebp*8-16]
  lea        edi,[edi+ebp*8-16]
   mov       cl,4
  jl         SpatialFilterLoop

SpatialFilterDone:

  mov        edi,TargetMacroBlockBaseAddr
   mov       esi,SpatiallyFilteredMB
  test       ch,ch
   jg        ReturnFromSpatialFilterForU

;  Registers at this point:
;  ebp -- PITCH
;  esi -- Address of upper left block of spatially filtered candidate ref area.
;  edi -- Address of upper left block of target.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- Scratch
;  eax -- Loop control
;  mm0-mm4 -- Scratch
;  mm5,mm6 -- SWD for each block
;  mm7 -- SWD for macroblock
;

  movq       mm0,[esi+ebp*1]
   pxor      mm7,mm7
  mov        al,3
   jl        ReturnFromSpatialFilterForV

ComputeSWDforSLFBlock:

  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.

ComputeSWDforSLFBlock_BlkToRight:

  movq       mm1,[esi+PITCH*3] ; Ref MB, Line 3.
   psllw     mm0,8             ; Extract diffs for line 1 even pels.
  psubw      mm1,[edi+PITCH*3] ; Diff for line 3.
   pmaddwd   mm0,mm0           ; Square of diffs for even pels of line 1.
  movq       mm2,[esi+PITCH*5]
   psllw     mm1,8
  psubw      mm2,[edi+PITCH*5]
   pmaddwd   mm1,mm1
  movq       mm3,[esi+PITCH*7]
   psllw     mm2,8
  psubw      mm3,[edi+PITCH*7]
   pmaddwd   mm2,mm2
  movq       mm4,[esi]         ; Ref MB, upper left blk, Line 0.
   psllw     mm3,8
  psubw      mm4,[edi]         ; Diff for line 0.
   paddusw   mm0,mm1           ; Accumulate SWD (lines 0 and 2).
  movq       mm1,[esi+ebp*2]
   pmaddwd   mm3,mm3
  psubw      mm1,[edi+ebp*2]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebp*4]
   pmaddwd   mm4,mm4           ; Square of diffs for odd pels of line 0.
  psubw      mm2,[edi+ebp*4]
   paddusw   mm0,mm3
  movq       mm3,[esi+PITCH*6]
   pmaddwd   mm1,mm1
  psubw      mm3,[edi+PITCH*6]
   pmaddwd   mm2,mm2
  paddusw    mm4,mm0
   pmaddwd   mm3,mm3
  paddusw    mm4,mm1
   add       esi,8
  paddusw    mm4,mm2
   add       edi,8
  movq       mm0,[esi+ebp*1]
   paddusw   mm4,mm3
  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.
   punpckldq mm1,mm4           ; Get low order SWD accum to high order of mm1.
  paddusw    mm1,mm4           ; mm1[48:63] is SWD for block.
   psllq     mm6,32            ; Shift previous block's SWD left.
  psrlq      mm1,48            ; mm1 is SWD for block.
   sub       al,2              ; Loop control.
  paddusw    mm7,mm1
   por       mm6,mm1           ; Save current block's SWD.
  movq       mm4,mm5
   jg        ComputeSWDforSLFBlock_BlkToRight

  movq       mm0,[esi+PITCH*9-16]
   movq      mm5,mm6
  lea        edi,[edi+ebp*8-16]
   lea       esi,[esi+ebp*8-16]
  mov        al,4
   jl        ComputeSWDforSLFBlock

  mov        ebx,BestMBFullPelSWD    ; Restore non-SLF SWD for macroblock.
   mov       eax,SpatialFiltDifferential
  sub        ebx,eax
   sub       edi,PITCH*16+16
  movdf      eax,mm7                 ; SLF SWD for macroblock.
  cmp        eax,ebx
   jge       SpatialFilterNotAsGood

  movdf      SWDULandLR+4,mm5
   psrlq     mm5,32
  movdf      SWDURandLL+4,mm5
  movdf      SWDURandLL,mm6
   psrlq     mm6,32
  movdf      SWDULandLR,mm6
  mov        al,INTERSLF
   mov       ebx,SpatiallyFilteredMB
  mov        [edx].BlockType,al
   sub       esi,PITCH*8-8
  mov        [edx].BlkY4.PastRef,esi
   mov       [edx].BlkY1.PastRef,ebx
  sub        esi,8
   add       ebx,8
  mov        [edx].BlkY3.PastRef,esi
   mov       [edx].BlkY2.PastRef,ebx

SkipSpatialFiltering:
SpatialFilterNotAsGood:
ENDIF ; H261

;===============================================================================
; We've settled on the motion vector that will be used if we do indeed code the
; macroblock with inter-coding.  We need to determine if some or all of the
; blocks can be forced as empty (copy).  If all the blocks can be forced
; empty, we force the whole macroblock to be empty.

  mov        esi,EMPTYTHRESHOLD         ; Get threshold for forcing block empty?
   mov       ebx,SWDULandLR             ; Get SWD for block 1.
  mov        al,[edx].CodedBlocks
   cmp       ebx,esi                    ; Is SWD > threshold?
  jg         @f

  and        al,0FEH                    ; If not, indicate block 1 is NOT coded.
   xor       ebx,ebx

@@:

  mov        ecx,SWDURandLL             ; Get SWD for block 2.
  cmp        ecx,esi
   jg        @f

  and        al,0FDH
   xor       ecx,ecx

@@:

  add        ebx,ecx
   mov       ecx,SWDURandLL+4           ; Get SWD for block 3.
  cmp        ecx,esi
   jg        @f

  and        al,0FBH
   xor       ecx,ecx

@@:

  add        ebx,ecx
   mov       ecx,SWDULandLR+4           ; Get SWD for block 4.
  cmp        ecx,esi
   jg        @f

  and        al,0F7H
   xor       ecx,ecx

@@:

  mov        [edx].CodedBlocks,al  ; Store coded block pattern.
   and       al,00FH
  add        ebx,ecx
   cmp       al,00FH               ; Are any blks marked empty?
  jne        InterBest             ; If some blks are empty, can't code as Intra

  mov        edi,TargetMacroBlockBaseAddr
   mov       [edx].SWD,ebx
  cmp        ebx,INTERCODINGTHRESHOLD  ; Is InterSWD below inter-coding thresh?
   jae       CalculateIntraSWD

InterBestX:

  mov        ebx,[edx].SWD

InterBest:

  mov        ecx,SWDTotal          ; Add to total for this macroblock class.
  add        ecx,ebx
IFDEF H261
  mov        SWDTotal,ecx
ELSE ;H263
   mov       bl,DoAdvancedPrediction
  mov        SWDTotal,ecx
   test      bl,bl
  jne        OBMCDifferencing
ENDIF

;============================================================================
; Perform differencing for the non-empty luma blocks of an Inter-coded
; macroblock.  This is the non-OBMC case;  i.e. Advanced Prediction is
; not selected.
;
;  ebp -- PITCH
;  esi -- Address of reference block.
;  edi -- Address of target block.
;  edx -- MBlockActionStream.  Used as cursor over luma blocks.
;  ecx -- Not in use.
;  ebx -- Scratch.  Used to test half pel MV resolution.
;  eax[0:3] -- Coded block pattern for luma blocks.

  mov        cl,INTER1MV
   mov       ebx,TargetMacroBlockBaseAddr
  mov        StashBlockType,cl
   test      al,1                        ; Don't diff block 1 if marked empty.
  mov        edi,ebx
   je        @f

  mov        ebx,[edx].BlkY1.MVs
   mov       esi,[edx].BlkY1.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  mov        al,[edx].CodedBlocks
  sub        al,bl
   mov       ebx,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>

@@:

  lea        edi,[ebx+8]                 ; Get address of next macroblock to do.
   test      al,2                        ; Don't diff block 2 if marked empty.
  je         @f

  mov        ebx,[edx].BlkY2.MVs
   mov       esi,[edx].BlkY2.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,1
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       ebx,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>

@@:

  lea        edi,[ebx+ebp*8]             ; Get address of next macroblock to do.
   test      al,4                        ; Don't diff block 3 if marked empty.
  je         @f

  mov        ebx,[edx].BlkY3.MVs
   mov       esi,[edx].BlkY3.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,2
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       ebx,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>

@@:

  lea        edi,[ebx+ebp*8+8]           ; Get address of next macroblock to do.
   test      al,8                        ; Don't diff block 4 if marked empty.
  je         NonOBMCDifferencingDone

  mov        ebx,[edx].BlkY4.MVs
   mov       esi,[edx].BlkY4.PastRef

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,3
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       edi                   ; Adjust stack pointer
  mov        [edx].CodedBlocks,al

StackOffset TEXTEQU <0>
NonOBMCDifferencingDone:

IFDEF H261
ELSE
   mov       al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock

  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

ENDIF
  jmp        NextMacroBlock

;============================================================================
;  Register usage in the following internal function.  This function does
;  half pel motion estimation for whole macroblocks, or individual blocks.
;
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock.  For MBME unchanged
;         at exit.  For BlkME, adjusted by -8-8*PITCH.
;  edi -- Address of target macroblock.  For MBME unchanged at exit.  For BlkME,
;         adjusted by -8-8*PITCH.
;  edx -- MBlockActionStream
;  ecx -- Reserved.
;  ebx -- For MBME:  240 + Flags to indicate which half pel ME to do:
;                    1 --> right;   2 --> left;   4 --> down;   8 --> up
;         For BlkME: Garbage
;  eax -- Count from -4 to -1 for blocks of macroblock.  0 for single block.
;  mm7 -- Initialized to zero.
;  mm6 -- Initialized to zero.
;  mm0:mm7 -- Scratch
;  mm3[ 0:15] -- SWD for ref 1/2 pel rightward
;  mm3[16:31] -- SWD for ref 1/2 pel leftward
;  mm3[32:47] -- SWD for ref 1/2 pel downward
;  mm3[48:63] -- SWD for ref 1/2 pel upward

StackOffset TEXTEQU <4>
HalfPelMotionEstimation:

  and       bl,15

HalfPelMBMEForUpperBlock:
HalfPelMEForFirst2LinesOfBlock:

  movq       mm0,[esi-PITCH]   ; <P^7 P^6 P^5 P^4 P^3 P^2 P^1 P^0>
  movq       mm1,[esi]         ; <P07 P06 P05 P04 P03 P02 P01 P00>
  movq       mm4,[edi+ebp*1]   ; <T17 T16 T15 T14 T13 T12 T11 T10>
   paddb     mm0,mm1           ; <P^7+P07 P^6+P06 P^5+P05 P^4+P04 ...>

HalfPelMEForNext2LinesOfBlock:

  movq       mm2,[esi+ebp*1]   ; <P17 P16 P15 P14 P13 P12 P11 P10>
   psrlw     mm0,1             ; <(P^7+P07)/2 junk (P^5+P05)/2 junk ...>
  movq       mm5,mm1           ; <P07 P06 P05 P04 P03 P02 P01 P00>
   psllw     mm4,8             ; <T16 0 T14 0 T12 0 T10 0>

HalfPelMBMEForLowerBlock:

  psubw      mm0,[edi]         ; <(P^7+P07)/2-T07 junk (P^5+P05)/2-T05 junk ...>
   paddb     mm5,mm2           ; <P07+P17 P06+P16 P05+P15 P04+P14 ...>
  pmullw     mm1,C0101010101010101  ; <(P07+P06)*256+P06 ...>
   psllw     mm5,8             ; <(P06+P16) 0 (P04+P14) 0 ...>
  pmaddwd    mm0,mm0           ; Square diff for line 0 odd pels, upward ref.
   psrlw     mm5,1             ; <(P06+P16)/2 0 (P04+P14)/2 0 ...>
  movq       mm3,[edi]         ; <T07 T06 T05 T04 T03 T02 T01 T00>
   psubw     mm4,mm5           ; <T16-(P06+P16)/2 junk ...>
  pmaddwd    mm4,mm4           ; Square diff for line 1 even pels, upward ref.
   psrlw     mm1,1             ; <(P07+P06)*128+P06/2 ...>
  psllw      mm3,8             ; <T06 0 T04 0 T02 0 T00 0>
   lea       edi,[edi+ebp*2]   ; Advance Target cursor
  psubw      mm3,mm1           ; <T06-(P07+P06)/2 junk T04-(P05+P03)/2 junk ...>
   lea       esi,[esi+ebp*2]   ; Advance Reference cursor
  psubw      mm1,[edi-PITCH*2] ; <(P07+P06)/2-T07 junk (P05+P04)/2-T05 junk ...>
   pmaddwd   mm3,mm3           ; Square diff for line 0 even pels, rightwrd ref.
  pmaddwd    mm1,mm1           ; Square diff for line 0 odd pels, leftward ref.
   paddusw   mm0,mm4           ; SSD for line 0 and 1, upward ref.
  pand       mm0,CFFFF0000FFFF0000 ; Extract SSD for line 0 and 1, upward ref.
   movq      mm4,mm2           ; <P17 P16 P15 P14 P13 P12 P11 P10>
  paddusw    mm6,mm0           ; Accumulate SSD for line 0 and 1, upward ref.
   psrlq     mm4,8             ; <  0 P17 P16 P15 P14 P13 P12 P11>
  pand       mm1,CFFFF0000FFFF0000 ; Extract SSD for line 0, leftward ref.
   psrld     mm3,16            ; Extract SSD for line 0, rightward ref.
  pmullw     mm4,C0200010101010101  ; <P17*256*2 (P16+P15)*256+P15 ...>
   paddw     mm3,mm1           ; SSD for line 0, leftward and rightward refs.
  movq       mm1,[esi]         ; <P27 P26 P25 P24 P23 P22 P21 P20>
   movq      mm0,mm2           ; <P17 P16 P15 P14 P13 P12 P11 P10>
  paddusw    mm7,mm3           ; Accumulate SSD for line 0, left and right refs.
   paddb     mm2,mm1           ; <P17+P27 P16+P26 P15+P25 P14+P24 ...>
  movq       mm3,mm0           ; <P17 P16 P15 P14 P13 P12 P11 P10>
   psrlw     mm4,1             ; <P17 (P16*P15)*128+P15/2 ...>
  psubw      mm4,[edi-PITCH*1] ; <P17-T17 junk (P16*P15)/2-T15 junk ...>
   psllq     mm3,8             ; <P16 P15 P14 P13 P12 P11 P10   0>
  pmullw     mm3,C0101010101010002  ; <(P16+P15)*256+P15 ... P10*256*2>
   psrlw     mm2,1             ; <(P17+P27)/2 junk (P15+P25)/2 junk ...>
  movq       StashMM6,mm6
   pmaddwd   mm4,mm4           ; Square diff for line 1 odd pels, rightward ref.
  movq       mm6,[edi-PITCH*1] ; <T17 T16 T15 T14 T13 T12 T11 T10>
   psrlw     mm3,1             ; <(P16+P15)*128+P15/2 ... P10*256>
  psubw      mm2,[edi-PITCH*1] ; <(P17+P27)/2-T17 junk (P15+P25)/2-T15 junk ...>
   psllw     mm6,8             ; <T16 0 T14 0 T12 0 T10 0>
  psubw      mm3,mm6           ; <(P16+P15)/2-T16 junk ... P10-T10>
   psrld     mm4,16            ; Extract SSD for line 1, rightward ref.
  movq       mm6,[edi-PITCH*2] ; <T07 T06 T05 T04 T03 T02 T01 T00>
   pmaddwd   mm3,mm3           ; Square diff for line 1 even pels, leftward ref.
  pmaddwd    mm2,mm2           ; Square diff for line 1 odd pels, downward ref.
   psllw     mm6,8             ; <T06 0 T04 0 T02 0 T00 0>
  paddusw    mm7,mm4           ; Accumulate SSD for line 1, rightward ref.
   psubw     mm6,mm5           ; <T06-(P06+P16)/2 junk ...>
  pand       mm3,CFFFF0000FFFF0000 ; Extract SSD for line 1, leftward ref.
   pmaddwd   mm6,mm6           ; Square diff for line 0 even pels, downward ref.
  add        bl,080H
   psrld     mm2,16            ; Extract SSD for line 1, downward ref.
  paddusw    mm2,StashMM6      ; Accumulate SSD for line 1, downward ref.
   paddusw   mm7,mm3           ; Accumulate SSD for line 1, leftward ref.
  movq       mm4,[edi+ebp*1]   ; <T17 T16 T15 T14 T13 T12 T11 T10>
   psrld     mm6,16            ; Extract SSD for line 0, downward ref.
  paddusw    mm6,mm2           ; Accumulate SSD for line 0, downward ref.
   paddb     mm0,mm1           ; <P^7+P07 P^6+P06 P^5+P05 P^4+P04 ...>
  punpckldq  mm5,mm6           ; Speculatively start to accum partial SWDs.
   jnc       HalfPelMEForNext2LinesOfBlock  ; Iterate twice, for half a block.

  punpckldq  mm3,mm7
   add       bl,040H
  paddusw    mm5,mm6
   jns       HalfPelMEForNext2LinesOfBlock  ; Iterate twice, for a whole block.

  paddusw    mm3,mm7
   psrlw     mm0,1             ; <(P^7+P07)/2 junk (P^5+P05)/2 junk ...>
  movq       mm2,[esi+ebp*1]   ; <P17 P16 P15 P14 P13 P12 P11 P10>
   punpckhdq mm3,mm5           ; mm3[ 0:15] -- SWD for ref 1/2 pel rightward
   ;                           ; mm3[16:31] -- SWD for ref 1/2 pel leftward
   ;                           ; mm3[32:47] -- SWD for ref 1/2 pel downward
   ;                           ; mm3[48:63] -- SWD for ref 1/2 pel upward
  movq       mm5,mm1           ; <P07 P06 P05 P04 P03 P02 P01 P00>
   sub       bl,080H
  movq       HalfPelMBMESWDAccum[eax*8+32],mm3
   psllw     mm4,8             ; <T16 0 T14 0 T12 0 T10 0>
  add        eax,2
   jl        HalfPelMBMEForLowerBlock       ; Iterate twice for 2 blocks.

  lea        edi,[edi-PITCH*16+8]
   lea       esi,[esi-PITCH*16+8]
  lea        eax,[eax-3]
   je        HalfPelMBMEForUpperBlock       ; Iterate twice for macroblock.

  sub        edi,16
   xor       eax,eax
  sub        esi,16
   mov       al,bl
  ret

StackOffset TEXTEQU <0>

;============================================================================
;  Register usage in the following internal function.  This function does
;  half pel motion estimation in both directions for whole macroblocks, or
;  individual blocks.
;
;  ebp -- PITCH
;  esi -- Address of best full pel reference macroblock.  For MBME unchanged
;         at exit.  For BlkME, adjusted by -8-8*PITCH.
;  edi -- Address of target macroblock.  For MBME unchanged at exit.  For BlkME,
;         adjusted by -8-8*PITCH.
;  edx -- MBlockActionStream
;  ecx -- Reserved.  Contains motion vectors.
;  ebx -- Returns SWD for this reference block or macroblock.
;  al  -- Count from 4 to 1 for blocks of macroblock.  1 for blk only.
;  mm0:mm6 -- Scratch
;  mm7 -- Reserved.  Contains SWDs for four 1/2 pel refs at main compass points.
;  mm4 -- Returns SWD for this reference block or macroblock.

StackOffset TEXTEQU <4>
HalfPelMotionEstimationBothWays:

  movq       mm3,C0101010101010101
   pxor      mm6,mm6                ; Zero out SSD accumulator.

HalfPelMBMEForUpperBlockBothWays:
HalfPelMEForFirst2LinesOfBlockBothWays:

  movq       mm0,[esi]         ; <P07 P06 P05 P04 P03 P02 P01 P00>

HalfPelMEForNext2LinesOfBlockBothWays:
HalfPelMBMEForLowerBlockBothWays:

  movq       mm1,[esi+ebp*1]   ; <P17 P16 P15 P14 P13 P12 P11 P10>
   pmullw    mm0,mm3           ; <(P07+P06)*256+P06 ...>
  movq       mm2,[esi+ebp*2]   ; <P27 P26 P25 P24 P23 P22 P21 P20>
   pmullw    mm3,mm1           ; <(P17+P16)*256+P16 ...>
  movq       mm4,mm2           ; <P27 P26 P25 P24 P23 P22 P21 P20>
   psrlq     mm2,8             ; <  0 P27 P26 P25 P24 P23 P22 P21>
  pmullw     mm2,C0200010101010101 ; <P27*256*2 (P26+P25)*256+P25 ...>
   psrlq     mm1,8             ; <  0 P17 P16 P15 P14 P13 P12 P11>
  pmullw     mm1,C0200010101010101 ; <P17*256*2 (P16+P15)*256+P15 ...>
   psrlw     mm3,2             ; <(P17+P16)/4 junk ...> (w /2 frac bits)
  movq       mm5,[edi]         ; <T07 T06 T05 T04 T03 T02 T01 T00>
   psrlw     mm0,2             ; <(P07+P06)/4 junk ...> (w/ 2 frac bits)
  paddw      mm3,mm0           ; <(P07+P06+P17+P16)/4 junk ...>
   psrlw     mm2,2             ; <P27/2 junk (P26+P25)/4 junk ...>
  psubw      mm2,[edi+ebp*1]   ; <P27/2-T17 junk (P26+P25)/4-T15 junk ...>
   psrlw     mm1,2             ; <P17/2 junk (P16+P15)/4 junk ...>
  paddw      mm2,mm1     ; <(P17+P27)/2-T17 junk (P16+P15+P26+P25)-T15 junk ...>
   psllw     mm5,8             ; <T06   0 T04   0 T02   0 T00   0>
  psubw      mm5,mm3           ; <T06-(P07+P06+P17+P16)/4 junk ...>
   pmaddwd   mm2,mm2           ; Square diffs for odd pels of line 1.
  pmaddwd    mm5,mm5           ; Square diffs for even pels of line 0.
   movq      mm0,mm4           ; <P27 P26 P25 P24 P23 P22 P21 P20>
  lea        edi,[edi+ebp*2]   ; Advance target cursor.
   lea       esi,[esi+ebp*2]   ; Advance reference cursor.
  paddusw    mm6,mm2           ; Accumulate SSD for odd pels of line 1.
   add       al,080H
  movq       mm3,C0101010101010101
   paddusw   mm6,mm5           ; Accumulate SSD for even pels of line 0.
  punpckldq  mm4,mm6           ; Speculatively start to accum partial SWDs.
   jnc       HalfPelMEForNext2LinesOfBlockBothWays  ; Twice, for half a block.

  add        al,040H
   paddusw   mm4,mm6            ; After whole block, SSD is in mm4[48:63].
  psrlq      mm4,48
   jns       HalfPelMEForNext2LinesOfBlockBothWays  ; Twice, for a whole block.

  movdf      ebx,mm4
  sub        al,082H
   jg        HalfPelMBMEForLowerBlockBothWays  ; Iterate twice for 2 blocks.

  lea        edi,[edi-PITCH*16+8]
   lea       esi,[esi-PITCH*16+8]
  mov        al,3
   je        HalfPelMBMEForUpperBlockBothWays  ; Iterate twice for macroblock.

  sub        edi,16
   sub       esi,16
  ret

StackOffset TEXTEQU <0>

;============================================================================
;  Register usage in the following internal function.  This function is also
;  called to do frame differencing for chroma blocks.
;
;  ebp -- PITCH
;  esi -- Address of reference block.
;  edi -- Address of target block.
;  edx -- Unavailable.  In use by caller.
;  ecx -- Not in use.
;  ebx -- Motion vectors for the block.  bl[0] indicates whether half-pel
;         horizontal interpolation is required;  bh[0] same for vertical.
;         This register is then used for scratch purposes.
;  eax -- Unavailable.  In use by caller.
;  mm0-mm5 -- Scratch
;  mm6 -- 8 bytes of 0xFE
;  mm7 -- 8 bytes of -1

StackOffset TEXTEQU <4>

DoNonOBMCDifferencing: ; Internal Function

  pcmpeqb    mm7,mm7
   pcmpeqb   mm6,mm6
IFDEF H261
ELSE ;H263
  shr        bl,1

   jc        NonOBMCDiff_Horz
ENDIF


  movq       mm1,[esi+ebp*1]     ; BC . . .  R0Dn
   paddb     mm6,mm6
IFDEF H261
ELSE ;H263
  shr        bh,1
   jc        NonOBMCDiff_Vert
ENDIF

  psubb      mm1,[edi+ebp*1]     ; P1 - T1
   pxor      mm4,mm4
  movq       mm0,[edi]           ; T0
   psubb     mm4,mm1             ; D1 = T1 - P1
  psubb      mm0,[esi]           ; D0 = T0 - P0
  movq       mm2,[edi+ebp*2]     ; T2
  movq       mm3,[edi+PITCH*3]   ; T3
  psubb      mm2,[esi+ebp*2]     ; D2 = T2 - P2
  psubb      mm3,[esi+PITCH*3]   ; D3 = T3 - P3
  movq       PelDiffsLine0,mm0   ; Store D0.
  movq       PelDiffsLine1,mm4   ; Store D1.
  movq       PelDiffsLine2,mm2   ; Store D2.
  movq       PelDiffsLine3,mm3   ; Store D3.
  movq       mm3,[esi+PITCH*7]   ; P7
  movq       mm2,[esi+PITCH*6]   ; P6
   paddb     mm3,mm3             ; Double so that return will fix it.
  movq       mm1,[esi+PITCH*5]   ; P5
   paddb     mm2,mm2             ; Double so that return will fix it.
  movq       mm0,[esi+ebp*4]     ; P4
   paddb     mm1,mm1             ; Double so that return will fix it.
  ret

IFDEF H261
ELSE ;H263
NonOBMCDiff_Vert:                ; 0123   Detail for 0

  movq       mm0,[esi]           ; C. .   R0Up
   psubb     mm1,mm7             ; DD .   R0Dn+1

  call       Get4LinesOfPred_InterpVert

  movq       mm5,[edi]           ; T0
   psrlq     mm1,1               ;  O .
  movq       mm7,[edi+ebp*1]
   psubb     mm5,mm0             ; D0 = T0 - P0
  movq       mm0,mm4
   psubb     mm7,mm1
  movq       mm1,[edi+ebp*2]
   pand      mm2,mm6             ;  .N.
  movq       mm4,[edi+PITCH*3]
  pand       mm3,mm6             ;  . N
   psrlq     mm2,1               ;  .O.
  movq       PelDiffsLine0,mm5   ; Store D0.
   psubb     mm1,mm2
  movq       PelDiffsLine1,mm7   ; Store D1.
   psrlq     mm3,1               ;  . O
  movq       PelDiffsLine2,mm1   ; Store D2.
   psubb     mm4,mm3
  movq       mm1,[esi+ebp*1]     ; BC . . .  R0Dn
   pcmpeqb   mm7,mm7
  movq       PelDiffsLine3,mm4   ; Store D3.
   psubb     mm1,mm7             ; DD . . .  R0Dn+1
; jmp        Get4MoreLinesOfPred_InterpVert

;===========================================================================
; Internal function to get 4 lines of prediction, interpolating in the
; vertical direction.  The first 3 lines of the function are scheduled into
; the caller's space, and so are commented out here.  For 8 lines of prediction,
; a second call, to the second entry point, is called after consuming the
; outputs of the first function call.  Certain registers must remain intact
; to convey information from the first call to the second.
;
; ebp -- PITCH
; edi -- Points to target block.
; esi -- Points to Upper left corner of 8 column, 9 row block that will be
;        interpolated vertically to generate prediction.
; edx -- Reserved (MBlockActionStream)
; ecx -- Not in use.
; ebx -- Will be used.
; eax -- Reserved.
; mm6 -- 8 bytes of 0xFE.
; mm7 -- 8 bytes of -1.
; mm0-mm5 -- Scratch.

StackOffset TEXTEQU <StackDepthVaries_DoNotUseStackVariables>
Get4LinesOfPred_InterpVert:      ; 0123   Details for line 0
; movq       mm1,[esi+ebp*1]     ; BC .   R0Dn
; movq       mm0,[esi]           ; C. .   R0Up
;  psubb     mm1,mm7             ; DD .   R0Dn+1
Get4MoreLinesOfPred_InterpVert:
  movq       mm2,[esi+ebp*2]     ;  BC.
   paddb     mm0,mm1             ; E. .   R0Up+R0Dn+1
  movq       mm3,[esi+PITCH*3]   ;  .BC
   paddb     mm1,mm2             ;  E .
  movq       mm4,[esi+ebp*4]     ;  . BC
   psubb     mm3,mm7             ;  .DD
  paddb      mm2,mm3             ;  .E.
   pand      mm0,mm6             ; F. .   Pre-clean
  paddb      mm3,mm4             ;    E
   pand      mm1,mm6             ;  F .
  lea        esi,[esi+ebp*4]     ;       Advance to next four lines.
   psrlq     mm0,1               ; G. .   P0 = (R0Up + R0Dn + 1) / 2
; pand       mm2,mm6             ;   G.
;  psrlq     mm1,1               ;  H .
; pand       mm3,mm6             ;    G
;  psrlq     mm2,1               ;   H.
; psrlq      mm3,1               ;    H
  ret
StackOffset TEXTEQU <4>

;===========================================================================

NonOBMCDiff_Horz:

  movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
   paddb     mm6,mm6             ; . .      8 bytes of 0xFE
  shr        bh,1
   jc        NonOBMCDiff_Both

  movq       mm7,[edi+PITCH*3]   ; T3

  call       Get4LinesOfPred_InterpHorz

  movq       mm4,[edi]           ; T0
   psrlq     mm1,1               ;  O .
  movq       mm5,[edi+ebp*1]
   psubb     mm4,mm0             ; D0 = T0 - P0
  movq       mm0,[edi+ebp*2]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*3]
   pand      mm2,mm6             ;  .N.
  pand       mm3,mm6             ;  . N
   psrlq     mm2,1               ;  .O.
  movq       PelDiffsLine0,mm4   ; Store D0.
   psubb     mm0,mm2
  movq       PelDiffsLine1,mm5   ; Store D1.
   psrlq     mm3,1               ;  . O
  movq       PelDiffsLine2,mm0   ; Store D2.
   psubb     mm1,mm3
  movq       mm5,[esi+1]         ; <R48 R47 R46 R45 R44 R43 R42 R41>
   ;
  movq       PelDiffsLine3,mm1   ; Store D3.
   ;

;===========================================================================
; Internal function to get 4 lines of prediction, interpolating in the
; horizontal direction.  The first line of the function are scheduled into
; the caller's space, and so are commented out here.  For 8 lines of prediction,
; a second call, to the second entry point, is called after consuming the
; outputs of the first function call.  Certain registers must remain intact
; to convey information from the first call to the second.
;
; ebp -- PITCH
; edi -- Points to target block.
; esi -- Points to Upper left corner of 9 column, 8 row block that will be
;        interpolated horizontally to generate prediction.
; edx -- Reserved (MBlockActionStream)
; ecx -- Not in use.
; ebx -- Will be used.
; eax -- Reserved.
; mm6 -- 8 bytes of 0xFE.
; mm0-mm5 -- Will be used.

StackOffset TEXTEQU <StackDepthVaries_DoNotUseStackVariables>
Get4LinesOfPred_InterpHorz:
Get4MoreLinesOfPred_InterpHorz:

; movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  xor        ebx,ebx             ;  . .
   movq      mm0,mm5             ; B. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  mov        bl,[esi]            ; C. .  R00
   psllq     mm5,8               ; D. .  <R07 R06 R05 R04 R03 R02 R01   0>
  movq       mm1,[esi+ebp*1+1]   ;  A .
   paddb     mm0,mm5             ; E. .  <R08+R07   ... R02+R01   R01      >
  paddb      mm0,Pel_Rnd[ebx*8]  ; F. .  <R08+R07+1 ... R02+R01+1 R01+R00+1>
   movq      mm4,mm1             ;  B .
  mov        bl,[esi+ebp*1]      ;  C .
   psllq     mm4,8               ;  D .
  movq       mm2,[esi+ebp*2+1]   ;   A.
   paddb     mm1,mm4             ;  E .
  paddb      mm1,Pel_Rnd[ebx*8]  ;  F .
   movq      mm5,mm2             ;   B.
  mov        bl,[esi+ebp*2]      ;   C.
   psllq     mm5,8               ;   D.
  movq       mm3,[esi+PITCH*3+1] ;    A
   paddb     mm2,mm5             ;   E.
  paddb      mm2,Pel_Rnd[ebx*8]  ;   F.
   movq      mm4,mm3             ;    B
  mov        bl,[esi+PITCH*3]    ;    C
   psllq     mm4,8               ;    D
  paddb      mm3,mm4             ;    E
   pand      mm0,mm6             ; G. .  pre-cleaned
  paddb      mm3,Pel_Rnd[ebx*8]  ;    F
   psrlq     mm0,1               ; H. .  P0=<(R08+R07+1)/2 ... (R01+R00+1)/2>
  lea        esi,[esi+ebp*4]     ;       Advance to next four lines.
   pand      mm1,mm6             ;  G .
; pand       mm2,mm6             ;   G.
;  psrlq     mm1,1               ;  H .
; pand       mm3,mm6             ;    G
;  psrlq     mm2,1               ;   H.
; psrlq      mm3,1               ;    H
  ret
StackOffset TEXTEQU <4>

; The steps commented out above are scheduled into the mem-ops the caller has
; to do at the point of return.  As though these ops were done, the registers
; look as follows:
;  mm0 -- Prediction for line 0.
;  mm1 -- Prediction for line 1.
;  mm2 -- Prediction for line 2.
;  mm3 -- Prediction for line 3.
;  mm6 -- 8 bytes of 0xFE.  Must be this when computing pred for next 4 lines.
;=============================================================================
 
NonOBMCDiff_Both:

  call       Get4LinesOfPred_InterpBoth

  movq       mm7,[edi]           ; T0
   psrlq     mm1,1               ;  O .
  psubb      mm7,mm0             ; D0 = T0 - P0
   pand      mm2,mm6             ;  .N.
  movq       mm0,[edi+ebp*1]
   psrlq     mm2,1               ;  .O.
  movq       PelDiffsLine0,mm7   ; Store D0.
   psubb     mm0,mm1
  movq       mm7,[edi+ebp*2]
   pand      mm3,mm6             ;  . N
  movq       PelDiffsLine1,mm0
   psrlq     mm3,1               ;  . O
  movq       mm1,[edi+PITCH*3]
   psubb     mm7,mm2
  psubb      mm1,mm3
   movq      mm0,mm4
  movq       PelDiffsLine2,mm7
   paddb     mm5,mm5             ;  . .  Prepare for use for next 4 lines.
  movq       PelDiffsLine3,mm1   ; Store D3.
   pcmpeqb   mm7,mm7
  jmp        Get4MoreLinesOfPred_InterpBoth

;===========================================================================
; Internal function to get 4 lines of prediction, interpolating in both
; directions.  The first line of the function are scheduled into the
; caller's space, and so are commented out here.  For 8 lines of prediction,
; a second call, to the second entry point, is called after consuming the
; outputs of the first function call.  Certain registers must remain intact
; to convey information from the first call to the second.
;
; ebp -- PITCH
; edi -- Points to target block.
; esi -- Points to Upper left corner of 9*9 block that will be interpolated
;        horizontally and vertically to generate prediction.
; edx -- Reserved (MBlockActionStream)
; ecx -- Not in use
; ebx -- Will be used.
; eax -- Reserved.
; mm6 -- 8 bytes of 0xFE.
; mm7 -- 8 bytes of -1.
; mm0-mm5 -- Scratch

StackOffset TEXTEQU <StackDepthVaries_DoNotUseStackVariables>
Get4LinesOfPred_InterpBoth:      ; 01234 Details for line 0

; movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  movq       mm1,mm5             ; B. .  <R08 R07 R06 R05 R04 R03 R02 R01>
   xor       ebx,ebx             ;  . .
  mov        bl,[esi]            ; C. .  R00
   psllq     mm5,8               ; D. .  <R07 R06 R05 R04 R03 R02 R01   0>
  paddb      mm5,mm1             ; E. .  <R08+R07 ... R02+R01 R01>
  paddb      mm5,Pel_Rnd[ebx*8]  ; F. .  <R08+R07+1 ... R02+R01+1 R01+R00+1>
   movq      mm0,mm6             ; G. .  Mask to extract each pel's frac bit.
  pandn      mm0,mm5             ; H. .  <(R08+R07+1)&1 ...>
   pand      mm5,mm6             ; I. .  Pre-clean
Get4MoreLinesOfPred_InterpBoth:  ;  . .
  movq       mm2,[esi+ebp*1+1]   ;  A .
   psrlq     mm5,1               ; J. .  <(R08+R07+1)/2 ... (R01+R00+1)/2)>
  xor        ebx,ebx             ;  . .
   movq      mm1,mm2             ;  B .
  mov        bl,[esi+ebp*1]      ;  C .
   psllq     mm2,8               ;  D .
  movq       mm3,[esi+ebp*2+1]   ;  .A.
   paddb     mm2,mm1             ;  E .
  paddb      mm2,Pel_Rnd[ebx*8]  ;  F .
   movq      mm1,mm3             ;  .B.
  mov        bl,[esi+ebp*2]      ;  .C.
   psllq     mm3,8               ;  .D.
  movq       mm4,[esi+PITCH*3+1] ;  . A
   paddb     mm3,mm1             ;  .E.
  paddb      mm3,Pel_Rnd[ebx*8]  ;  .F.
   movq      mm1,mm4             ;  . B
  mov        bl,[esi+PITCH*3]    ;  . C
   pand      mm0,mm2             ; K. .  <(R08+R07+1)&(R18+R17+1)&1 ...>
  paddb      mm0,mm5             ; L. .  <(R08+R07+1+((R18+R17+1)&1))/2 ...>
   psllq     mm4,8               ;  . D
  movq       mm5,[esi+ebp*4+1]   ;  . .A
   paddb     mm4,mm1             ;  . E
  paddb      mm4,Pel_Rnd[ebx*8]  ;  . F
   movq      mm1,mm5             ;  . .B
  mov        bl,[esi+ebp*4]      ;  . .C
   psllq     mm5,8               ;  . .D
  paddb      mm5,mm1             ;  . .E
   movq      mm1,mm6             ;  G .
  pandn      mm1,mm2             ;  H .
   pand      mm2,mm6             ;  I .
  paddb      mm5,Pel_Rnd[ebx*8]  ;  . .F
   psrlq     mm2,1               ;  J .
  paddb      mm0,mm2             ; M. .  <(R08+R07+R18+R17+2)/2 ...>
   pand      mm1,mm3             ;  K .
  paddb      mm1,mm2             ;  L .
   movq      mm2,mm6             ;  .G.
  pandn      mm2,mm3             ;  .H.
   pand      mm3,mm6             ;  .I.
  pand       mm0,mm6             ; N. .  Pre-clean
   psrlq     mm3,1               ;  .J.
  paddb      mm1,mm3             ;  M .
   pand      mm2,mm4             ;  .K.
  paddb      mm2,mm3             ;  .L.
   movq      mm3,mm6             ;  . G
  pandn      mm3,mm4             ;  . H
   pand      mm4,mm6             ;  . I
  pand       mm3,mm5             ;  . K
   psrlq     mm4,1               ;  . J
  paddb      mm2,mm4             ;  .M.
   paddb     mm3,mm4             ;  . L
  movq       mm4,mm6             ;  . .G
   psrlq     mm0,1               ; O. .  P0 = <(R08+R07+R18+R17+2)/4 ...>
  pandn      mm4,mm5             ;  . .H
   pand      mm5,mm6             ;  . .I
  pand       mm1,mm6             ;  N .
   psrlq     mm5,1               ;  . .J
  paddb      mm3,mm5             ;  . M
   lea       esi,[esi+ebp*4]     ;       Advance to next four lines.
; pand       mm2,mm6             ;  .N.
;  psrlq     mm1,1               ;  O .
; pand       mm3,mm6             ;  . N
;  psrlq     mm2,1               ;  .O.
; paddb      mm5,mm5             ;  . .  Prepare for use for next 4 lines.
;  psrlq     mm3,1               ;  . O
  ret
StackOffset TEXTEQU <4>

; The steps commented out above are scheduled into the mem-ops the caller has
; to do at the point of return.  As though these ops were done, the registers
; look as follows:
;  mm0 -- Prediction for line 0.
;  mm1 -- Prediction for line 1.
;  mm2 -- Prediction for line 2.
;  mm3 -- Prediction for line 3.
;  mm4 -- Must be moved to mm0 before computing prediction for next 4 lines.
;  mm5 -- Must be doubled before computing prediction for next 4 lines.
;  mm6 -- 8 bytes of 0x01.  Must be this when computing pred for next 4 lines.
;  mm7 -- 8 bytes of 0xFE.  Must be this when computing pred for next 4 lines.
;=============================================================================
ENDIF

StackOffset TEXTEQU <0>

IFDEF H261
ELSE ;H263
OBMCDifferencing:

  mov        al,PendingOBMC           ; Do OBMC for previous block, if needed..
   mov       bl,1
  test       al,al
   mov       PendingOBMC,bl
  mov        cl,INTER1MV
   je        NextMacroBlock

  mov        StashBlockType,cl

  call       DoPendingOBMCDiff

  mov        al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock

  add        edx,-SIZEOF T_MacroBlockActionDescr
  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

  sub        edx,-SIZEOF T_MacroBlockActionDescr
   jmp       NextMacroBlock

ENDIF

;============================================================================
; Calculate the IntraSWD
;
;  ebp -- PITCH
;  esi -- Accumulation for IntraSWD
;  edi -- Address of target macroblock.
;  edx -- MBlockActionStream
;  ecx -- Scratch
;  ebx -- Amount IntraSWD has to be less than to be the winner.
;  eax -- Reserved.  Holds coded blk pattern, (except undef when IntraByDecree).
;  mm7 -- SWD total for macroblock.
;  mm6 -- Average pel value for block 1.
;  mm5 -- Average pel value for block 2.
;  mm4 -- Average pel value for block 3.
;  mm3 -- Average pel value for block 4.
;  mm0-mm2 Scratch
;

IntraByDecree:

  mov        ebx,000080000H           ; Set Inter SWD artificially high.

CalculateIntraSWD:

  sub        ebx,INTRACODINGDIFFERENTIAL
   mov       cl,1
  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5

ComputeIntraSWDForNextBlock:

  movq       mm2,[edi+ebp*2]        ; <P27 P26 P25 P24 P23 P22 P21 P20>
   psrlw     mm5,8
  movq       mm4,[edi+ebp*4]
   paddw     mm0,mm2                ; <junk P06+P26 junk P04+P24 ...>
  movq       mm6,[edi+PITCH*6]
   pand      mm0,mm5                ; <P06+P26 P04+P24 P02+P22 P00+P20>
  movq       mm1,[edi+ebp*1]        ; <P17 P16 P15 P14 P13 P12 P11 P10>
   paddw     mm4,mm6
  movq       mm3,[edi+PITCH*3]      ; <P37 P36 P35 P34 P33 P32 P31 P30>
   pand      mm4,mm5
  movq       mm5,[edi+PITCH*5]
   paddw     mm1,mm3                ; <P17+P37 junk P15+P35 junk ...>
  movq       mm7,[edi+PITCH*7]
   psrlw     mm1,8                  ; <P17+P37 P15+P35 P13+P33 P11+P31>
  paddw      mm0,mm1
   paddw     mm5,mm7
  paddw      mm0,mm4
   psrlw     mm5,8
  paddw      mm0,mm5
   pcmpeqw   mm5,mm5                ; Get words of -1
  movq       mm4,[edi+ebp*4]
   pmaddwd   mm0,mm5                ; <SumHi = Sum3+Sum2 | SumLo = Sum1+Sum0>
  pcmpeqw    mm1,mm1
   psllw     mm3,8                  ; <P36   0 P34   0 P32  0 P30  0>
  movq       mm5,[edi+PITCH*5]
   psllw     mm1,3                  ; 4 words of 0xFFF8
  packssdw   mm0,mm0                ; <SumHi | SumLo | SumHi | SumLo>
   mov       al,[edx].CodedBlocks   ; Fetch coded block pattern.
  pmaddwd    mm0,mm1                ; <Sum = SumHi+SumLo | Sum = SumHi+SumLo>
   psllw     mm5,8
  movq       mm1,[edi+ebp*1]
   psllw     mm7,8
  ;
   psllw     mm1,8
  ;
   packssdw  mm0,mm0                ; <Sum | Sum | Sum | Sum>
  psubw      mm1,mm0                ; <P16-Avg frac P14-Avg frac ...>
   psubw     mm2,mm0                ; <P27-Avg frac P25-Avg frac ...>
  pmaddwd    mm1,mm1                ; Square of diff
   psubw     mm3,mm0
  pmaddwd    mm2,mm2
   psubw     mm4,mm0
  pmaddwd    mm3,mm3
   psubw     mm5,mm0
  pmaddwd    mm4,mm4
   psubw     mm6,mm0
  psubw      mm7,mm0
   paddusw   mm1,mm2
  psubw      mm0,[edi]
   pmaddwd   mm5,mm5
  pmaddwd    mm6,mm6
   paddusw   mm1,mm3
  pmaddwd    mm7,mm7
   paddusw   mm1,mm4
  pmaddwd    mm0,mm0
   paddusw   mm1,mm5
  paddusw    mm1,mm6
   cmp       cl,2
  paddusw    mm1,mm7
   ;
  paddusw    mm0,mm1
   ;
  punpckldq  mm1,mm0
   ;
  paddusw    mm0,mm1
   jg        LowerBlkIntraDone

  psrlq      mm0,48
   lea       edi,[edi+ebp*8+8]   ; Speculate going from blk 1 to blk 4
  mov        cl,4
   je        Blk2IntraDone

Blk1IntraDone:

  movdf      esi,mm0
  sub        ebx,esi
   jle       InterBestX

  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5
  jmp        ComputeIntraSWDForNextBlock

LowerBlkIntraDone:


  psrlq      mm0,48
   sub       edi,PITCH*8         ; Speculate going from blk 4 to blk 2
  cmp        cl,3
   je        Blk3IntraDone

Blk4IntraDone:

  movdf      ecx,mm0
  add        esi,ecx             ; Accumulate IntraSWD
   sub       ebx,ecx
  jle        InterBestX

  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5
  mov        cl,2
   jmp       ComputeIntraSWDForNextBlock

Blk2IntraDone:

  movdf      ecx,mm0
  add        esi,ecx             ; Accumulate IntraSWD
   sub       edi,16              ; Get to blk 3.
  sub        ebx,ecx
   jle       InterBestX

  movq       mm0,[edi]              ; <P07 P06 P05 P04 P03 P02 P01 P00>
   pcmpeqb   mm5,mm5
  mov        cl,3
   jmp       ComputeIntraSWDForNextBlock

Blk3IntraDone:

  movdf      ecx,mm0
  add        esi,ecx             ; Accumulate IntraSWD
   sub       ebx,ecx
  jle        InterBestX

IntraBest:

  mov        ecx,SWDTotal
   and       al,07FH                   ; Turn off FORCE-INTRA bit.
  mov        [edx].SWD,esi
   add       ecx,esi                   ; Add to total.
  mov        SWDTotal,ecx
   mov       cl,INTRA
  mov        [edx].BlockType,cl        ; Indicate macroblock handling decision.
   xor       ecx,ecx
  mov        [edx].BlkY1.MVs,ecx
   mov       [edx].BlkY2.MVs,ecx
  mov        [edx].BlkY3.MVs,ecx
   mov       [edx].BlkY4.MVs,ecx
  mov        [edx].CodedBlocks,al

IFDEF H261
ELSE ;H263
   mov       al,PendingOBMC            ; Do Prev MB if it needs to be OBMC'ed.
  mov        [edx].BestFullPelMBHMV,cl ; Kill MVs so extended EMV of other
  ;                                    ; blocks will work right.
   dec       al
  mov        [edx].BestFullPelMBVMV,cl
   jne       @f

  mov        PendingOBMC,al            ; Go on to next MB, unless the prev MB
  ;                                    ; needs to be finished (OBMC).
   mov       cl,INTER1MV
  mov        StashBlockType,cl

  call       DoPendingOBMCDiff

  mov        al,IsPlainPFrame
  test       al,al
   jne       @f

  add        edx,-SIZEOF T_MacroBlockActionDescr
  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

  sub        edx,-SIZEOF T_MacroBlockActionDescr

@@:

ENDIF

  mov        cl,INTRA
   mov       esi,TargetMacroBlockBaseAddr
  mov        StashBlockType,cl
   push      eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>
  call       MMxDoForwardDCT
  mov        al,[edx].CodedBlocks
   mov       esi,TargetMacroBlockBaseAddr
  sub        al,bl
   add       esi,8
  mov        [edx].CodedBlocks,al
  call       MMxDoForwardDCT
  shl        bl,1
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       esi,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   add       esi,PITCH*8
  call       MMxDoForwardDCT
  shl        bl,2
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       esi,TargetMacroBlockBaseAddr
  mov        [edx].CodedBlocks,al
   add       esi,PITCH*8+8
  call       MMxDoForwardDCT
  shl        bl,3
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        [edx].CodedBlocks,al
IFDEF H261
ELSE
   mov       al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock

  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks
ENDIF

  jmp        NextMacroBlock


IFDEF H261
ELSE; H263
StackOffset TEXTEQU <4>
DoPendingOBMCDiff: ; Internal function

;============================================================================
; Perform differencing for the non-empty luma blocks of an Inter-coded
; macroblock.  This is the OBMC case;  i.e. Advanced Prediction is selected.

PrevMBAD EQU [edx-SIZEOF T_MacroBlockActionDescr]

  pcmpeqb    mm6,mm6
   pcmpeqb   mm7,mm7                    ; 8 bytes of -1
  paddb      mm6,mm6                    ; 8 bytes of 0xFE
   mov       al,PrevMBAD.CodedBlocks    ; Bits  0- 3  set for non-empty Y blks.
  test       al,1                       ; Check if block 1 empty.
   je        OBMCDoneForBlock1

  xor        ebx,ebx
   mov       eax,SIZEOF T_Blk           ; Blk to right is blk 2 of this MB.
  mov        bl,PrevMBAD.MBEdgeType
   mov       ecx,1                      ; Mask to extract left edge indicator.
  and        ecx,ebx                    ; Extract left edge indicator.
   and       ebx,4                      ; Extract top edge indicator.
  mov        esi,PrevMBAD.BlkY1.MVs
   lea       edi,[eax*2]                ; Blk below is blk 3 of this MB.
  mov        DistToBADforBlockBelow,edi ; Stash BAD offset for lower remote MV.
   mov       edi,BlockAbove[ebx]        ; Blk above is blk 3 of mb above, or off
   ;                                    ; upper edge.
  mov        ecx,BlockToLeft[ecx*4]     ; Blk to left is blk 2 of mb to the
  ;                                     ; left, or off left edge.
   mov       DistToBADforBlockAbove,edi
  call       DoOBMCForBlock
  mov        al,PrevMBAD.CodedBlocks    ; Bits  0- 3  set for non-empty Y blks.
  sub        al,bl
  mov        PrevMBAD.CodedBlocks,al

OBMCDoneForBlock1:

   add       edx,SIZEOF T_Blk
  test       al,2                       ; Check if block 2 empty.
   je        OBMCDoneForBlock2

  xor        ebx,ebx
   mov       eax,2                      ; Mask to extract right edge indicator.
  mov        bl,PrevMBAD[-SIZEOF T_Blk].MBEdgeType
   mov       edi,2*SIZEOF T_Blk         ; Blk below is blk 4 of this MB.
  and        eax,ebx                    ; Extract right edge indicator.
   and       ebx,4                      ; Extract top edge indicator.
  mov        DistToBADforBlockBelow,edi ; Stash BAD offset for lower remote MV.
   lea       ecx,[edi-3*SIZEOF T_Blk]   ; Blk to left is blk 1 of this MB.
  mov        eax,BlockToRight[eax*2]    ; Blk to right is blk 1 of mb to the
  ;                                     ; right, or off right edge.
   mov       edi,BlockAbove[ebx]        ; Blk above is blk 4 of mb above, or off
   ;                                    ; upper edge.
  mov        esi,PrevMBAD.BlkY1.MVs
   mov       DistToBADforBlockAbove,edi
  call       DoOBMCForBlock
  shl        bl,1
   mov       al,PrevMBAD[-1*SIZEOF T_Blk].CodedBlocks
  sub        al,bl
  mov        PrevMBAD[-1*SIZEOF T_Blk].CodedBlocks,al

OBMCDoneForBlock2:

   add       edx,SIZEOF T_Blk
  test       al,4                       ; Check if block 3 empty.
   je        OBMCDoneForBlock3

  xor        ecx,ecx
   xor       ebx,ebx                    ; Blk below is this block.
  mov        cl,PrevMBAD[-2*SIZEOF T_Blk].MBEdgeType
   mov       eax,SIZEOF T_Blk           ; Blk to right is blk 4 of this MB.
  and        ecx,1                      ; Extract left edge indicator.
   mov       DistToBADforBlockBelow,ebx ; Stash BAD offset for lower remote MV.
  lea        edi,[eax-3*SIZEOF T_Blk]   ; Blk above is blk 1 of this MB.
   mov       esi,PrevMBAD.BlkY1.MVs
  mov        DistToBADforBlockAbove,edi
   mov       ecx,BlockToLeft[ecx*4]     ; Blk to left is blk 1 of mb to the
  ;                                     ; left, or off left edge.
  call       DoOBMCForBlock
  shl        bl,2
   mov       al,PrevMBAD[-2*SIZEOF T_Blk].CodedBlocks
  sub        al,bl
  mov        PrevMBAD[-2*SIZEOF T_Blk].CodedBlocks,al

OBMCDoneForBlock3:

   add       edx,SIZEOF T_Blk
  test       al,8                       ; Check if block 4 empty.
   je        OBMCDoneForBlock4

  xor        eax,eax
   xor       ebx,ebx                    ; Blk below is this block.
  mov        al,PrevMBAD[-3*SIZEOF T_Blk].MBEdgeType
   mov       ecx,-SIZEOF T_Blk          ; Blk to left is blk 3 of this MB.
  and        eax,2                      ; Extract right edge indicator.
   mov       DistToBADforBlockBelow,ebx ; Stash BAD offset for lower remote MV.
  lea        edi,[ecx*2]                ; Blk above is blk 2 of this MB.
   mov       esi,PrevMBAD.BlkY1.MVs
  mov        DistToBADforBlockAbove,edi
   mov       eax,BlockToRight[eax*2]    ; Blk to right is blk 1 of mb to the
  ;                                     ; right, or off right edge.
  call       DoOBMCForBlock
  shl        bl,3
   mov       al,PrevMBAD[-3*SIZEOF T_Blk].CodedBlocks
  sub        al,bl
  mov        PrevMBAD[-3*SIZEOF T_Blk].CodedBlocks,al

OBMCDoneForBlock4:

   sub       edx,3*SIZEOF T_Blk    ; Get back to MacroBlock Action Descriptor
  ret

StackOffset TEXTEQU <8>
DoOBMCForBlock: ; Internal Function

;  Present register contents.
;  ebp -- PITCH
;  esi -- Motion vectors for current block.
;  ecx -- Distance from BAD of blk we're doing to BAD for block that provides
;         remote MV from left.
;  eax -- Distance from BAD of blk we're doing to BAD for block that provides
;         remote MV from right.
;  edx -- MBlockActionStream, adjusted to reach BAD of blk we are doing OBMC to.
;         doing OBMC)
;  mm7 -- 8 bytes of -1.
;  mm6 -- 8 bytes of 0xFE.
;
; In the body of this code:
;
;  edx -- Unchanged.
;  edi -- Saved to memory.  Then used for address of destination for storing
;         remote prediction blocks.
;  ebp -- PITCH.
;  esi -- Pointer to 8*8, 8*9, 9*8, or 9*9 remote reference areas, which are
;         then interpolated and stored at edi.
;  ecx, eax -- Inputs are used, then these are scratch.
;  ebx -- Scratch
;  mm7 -- 8 bytes of -1
;  mm6 -- 8 bytes of 0xFE
;  mm0-mm5 -- Scratch

;  Compute left remote prediction block.

  lea        edi,PrevMBAD[ecx]
  and        edi,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk to left.
   lea       ebx,CentralPred
  mov        AddrOfLeftPred,ebx  ; Speculate that left remote MV == center MV.
   mov       AddrOfRightPred,ebx ; Speculate that right remote MV == center MV.
  mov        bl,[edi].BlockType
  cmp        bl,INTRA
   je        LeftEqCtr           ; Jump if INTRA.  (Use central)

  mov        ebx,PrevMBAD[ecx].BlkY1.MVs
  and        ebx,00000FFFFH     ; Blk to left may have B MVs set.  Clear them.
  cmp        esi,ebx
   je        LeftEqCtr

  mov        edi,PrevMBAD[ecx].BlkY1.BlkOffset
   mov       esi,PrevMBAD[ecx].BlkY1.PastRef   ; Get ref addr using left remote.
  sub        esi,edi
   mov       edi,PrevMBAD.BlkY1.BlkOffset
  add        esi,edi
   lea       edi,LeftPred

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  lea        ecx,PrevMBAD[eax]
  and        ecx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk to right.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7             ;  . .  Restore 8 bytes of -1

;  Compute right remote prediction block.

  mov        AddrOfLeftPred,edi
   mov       bl,[ecx].BlockType
  cmp        bl,INTRA
   je        RightEqCtrButLeftNeCtr ; Jump if INTRA.(Use central)

  mov        ebx,PrevMBAD[eax].BlkY1.MVs
  cmp        esi,ebx
   je        RightEqCtrButLeftNeCtr

  mov        esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using right remote.
   mov       edi,PrevMBAD[eax].BlkY1.BlkOffset

RightNeCtr:

  sub        esi,edi
   mov       edi,PrevMBAD.BlkY1.BlkOffset
  add        esi,edi
   lea       edi,RightPred

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  mov        AddrOfRightPred,edi
   ;
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7             ;  . .  Restore 8 bytes of -1

RightEqCtrButLeftNeCtr:

;  Compute central prediction block.

  mov        ebx,PrevMBAD.BlkY1.MVs
   mov       esi,PrevMBAD.BlkY1.PastRef
  lea        edi,CentralPred
   mov       eax,DistToBADforBlockBelow

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  lea        ecx,PrevMBAD[eax]
  and        ecx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk below.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7
  mov        bl,[ecx].BlockType
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  cmp        bl,INTRA
   je        BelowEqCtrButSidesDiffer ; Jump if INTRA.  (Use central)

; Compute bottom remote prediction block.

  mov        ebx,PrevMBAD[eax].BlkY1.MVs
   mov       edi,AddrOfLeftPred
  cmp        esi,ebx
   jne       BelowNeCtr

BelowEqCtrButSidesDiffer:

  paddb      mm1,mm1             ; Prep mm0-3, which have ctr, for reuse below.
   paddb     mm2,mm2
  paddb      mm3,mm3
   mov       edi,AddrOfLeftPred
  jmp        BelowEqCtr

BelowNeCtr:

  mov        esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
   mov       eax,PrevMBAD[eax].BlkY1.BlkOffset
  sub        esi,eax
   lea       eax,[ecx+ebp*4]

  call       GetPredForAboveOrBelow

BelowEqCtr:

; Compute difference for lines 4 thru 7.
; Lines 4 and 5: Cols 0,1,6, and 7 treated same.  Cols 2-5 treated same.

  mov        esi,AddrOfRightPred
   mov       ebx,TargetFrameBaseAddress
  movdt      mm5,[edi+48]          ; 6B: <  0   0   0   0 R63 R62 R61 R60>
   pand      mm2,mm6
  punpckldq  mm5,[esi+48+4]        ; 6C: <L67 L66 L65 L64 R63 R62 R61 R60>
   pand      mm3,mm6
  movq       mm4,CFFFF00000000FFFF ; 6D: < FF  FF  00  00  00  00  FF  FF>
   psrlq     mm2,1                 ; 6A: <B67 B66 B65 B64 B63 B62 B61 B60>
  pand       mm4,mm5               ; 6E: <L67 L66  00  00  00  00 R61 R60>
   paddb     mm5,mm2               ; 6F: <B67+L67 ... B65+L65 ...>

  pand       mm2,C0000FFFFFFFF0000 ; 6G: < 00  00 B65 B64 B63 B62  00  00>
   psrlq     mm1,1                 ; 5A: <B57 B56 B55 B54 B53 B52 B51 B50>
  paddb      mm2,mm4               ; 6H: <L67 L66 B65 B64 B63 B62 R61 R60>
   add       ecx,ebx               ;     Address of target block.
  movdt      mm4,[edi+56]          ; 7B: <  0   0   0   0 R73 R72 R71 R70>
   psubb     mm5,mm2               ; 6I: <B67 B66 L65 L64 R63 R62 B61 B60>
  paddb      mm5,CentralPred+48    ; 6J: <C67+B67 ... C65+L65 ...>
   psrlq     mm3,1                 ; 7A: <B77 B76 B75 B74 B73 B72 B71 B70>
  punpckldq  mm4,[esi+56+4]        ; 7C: <L77 L76 L75 L74 R73 R72 R71 R70>
   pand      mm5,mm6               ; 6K: <C67+B67 ... C65+L65 ...> pre-cleaned
  mov        eax,DistToBADforBlockAbove
   psrlq     mm5,1                 ; 6L: <(C67+B67)/2 ... (C65+L65)/2 ...>
  paddb      mm2,mm5               ; 6M: <(C67+B67+2L67)/2 ...
  ;                                ;      (C65+2B65+L65)/2 ...>
   lea       ebx,PelDiffs
  movq       mm5,CFF000000000000FF ; 7D: < FF  00  00  00  00  00  00  FF>
   pand      mm2,mm6               ; 6N: pre-cleaned
  pandn      mm5,CentralPred+56    ; 7E: < 00 C76 C75 C74 C73 C72 C71  00>
   psrlq     mm2,1                 ; 6O: <(C67+B67+2L67)/4 ...
   ;                               ;      (C65+2B65+L65)/4 ...>
  paddb      mm2,CentralPred+48    ; 6P: <(5C67+B67+2L67)/4 ...
  ;                                ;      (5C65+2B65+L65)/4 ...>
   paddb     mm5,mm4               ; 7F: <L77 C76+L76 ...>
  pand       mm4,CFF000000000000FF ; 7G: <L77  00  00  00  00  00  00  L70>
   psubb     mm2,mm7               ; 6Q: <(5C67+B67+2L67+4)/4 ...
   ;                               ;      (5C65+2B65+L65+4)/4 ...>
  paddb      mm4,mm5               ; 7H: <2L77 C76+L76 ...>
   pand      mm2,mm6               ; 6R: pre-cleaned
  movq       mm5,[ecx+PITCH*6]     ; 6T: T6
   psrlq     mm2,1                 ; 6S: P6 = <(5C67+B67+2L67+4)/8 ...
   ;                               ;           (5C65+2B65+L65+4)/8 ...>
  psubb      mm5,mm2               ; 6U: D6 = T6 - P6
   ;
                                   ; 4A: <B47 B46 B45 B44 B43 B42 B41 B40>: mm0
  movdt      mm2,[edi+32]          ; 4B: <  0   0   0   0 R43 R42 R41 R40>
   pand      mm4,mm6               ; 7I: <2L77 C76+L76 ...> pre-cleaned
  movq       [ebx+6*16],mm5        ; 6V: Store D6.
   psrlq     mm4,1                 ; 7J: <2L77/2 (C76+L76)/2 ...>
  punpckldq  mm2,[esi+32+4]        ; 4C: <L47 L46 L45 L44 R43 R42 R41 R40>
   paddb     mm3,mm4               ; 7K: <(2B77+2L77)/2 (C76+2B76+L76)/2 ...>
  movq       mm5,CFFFF00000000FFFF ; 4D: < FF  FF  00  00  00  00  FF  FF>
   pand      mm3,mm6               ; 7L: pre-cleaned
  movq       mm4,CentralPred+32    ; 4E: <C47 C46 C45 C44 C43 C42 C41 C40>
   psrlq     mm3,1                 ; 7M: <(2B77+2L77)/4 (C76+2B76+L76)/4 ...>
  paddb      mm3,CentralPred+56    ; 7N: <(4C77+2B77+2L77)/4
  ;                                ;      (5C76+2B76+L76)/4 ...>
   pand      mm5,mm4               ; 4F: <C47 C46  00  00  00  00 C41 C40>
  psubb      mm3,mm7               ; 7O: <(4C77+2B77+2L77+4)/4
   ;                               ;      (5C76+2B76+L76+4)/4 ...>
   paddb     mm4,mm2               ; 4G: <C47+L47 ... C45+L45 ...>
  pand       mm2,C0000FFFFFFFF0000 ; 4H: < 00  00 L45 L44 R43 R42  00  00>
   pand      mm3,mm6               ; 7P: <(4C77+2B77+2L77+4)/4
   ;                               ;      (5C76+2B76+L76+4)/4 ...> pre-cleaned
  paddb      mm2,mm5               ; 4I: <C47 C46 L45 L44 R43 R42 C41 C40>
   psrlq     mm3,1                 ; 7Q: P7 = <(4C77+2B77+2L77+4)/8
   ;                               ;           (5C76+2B76+L76+4)/8 ...>
  movdt      mm5,[edi+40]          ; 5B: <  0   0   0   0 R53 R52 R51 R50>
   psubb     mm4,mm2               ; 4J: <L47 L46 C45 C44 C43 C42 R41 R40>
  punpckldq  mm5,[esi+40+4]        ; 5C: <L57 L56 L55 L54 R53 R52 R51 R50>
   paddb     mm0,mm2               ; 4K: <C47+B47 ... B45+L45 ...>
  movq       mm2,[ecx+PITCH*7]     ; 7R: T7
   pand      mm0,mm6               ; 4L: <C47+B47 ... B45+L45 ...> pre-cleaned
  psubb      mm2,mm3               ; 7S: D7 = T7 - P7
   psrlq     mm0,1                 ; 4M: <(C47+B47)/2 ... (B45+L45)/2 ...>
  movq       mm3,CFFFF00000000FFFF ; 5D: < FF  FF  00  00  00  00  FF  FF>
   paddb     mm0,mm4               ; 4N: <(C47+B47+2L47)/2 ...
   ;                               ;      (2C45+B45+L45)/2 ...>
  movq       mm4,CentralPred+40    ; 5E: <C57 C56 C55 C54 C53 C52 C51 C50>
   pand      mm0,mm6               ; 4O: pre-cleaned
  pand       mm3,mm4               ; 5F: <C57 C56  00  00  00  00 C51 C50>
   paddb     mm4,mm5               ; 5G: <C57+L57 ... C55+L55 ...>
  pand       mm5,C0000FFFFFFFF0000 ; 5H: < 00  00 L55 L54 R53 R52  00  00>
   psrlq     mm0,1                 ; 4P: <(C47+B47+2L47)/4 ...
   ;                               ;      (2C45+B45+L45)/4 ...>
  paddb      mm0,CentralPred+32    ; 4Q: <(5C47+B47+2L47)/4 ...
  ;                                ;      (6C45+B45+L45)/4 ...>
   paddb     mm5,mm3               ; 5I: <C57 C56 L55 L54 R53 R52 C51 C50>
  psubb      mm4,mm5               ; 5J: <L57 L56 C55 C54 C53 C52 R51 R50>
   paddb     mm1,mm5               ; 5K: <C57+B57 ... B55+L55 ...>
  pand       mm1,mm6               ; 5L: <C57+B57 ... B55+L55 ...> pre-cleaned
   psubb     mm0,mm7               ; 4R: <(5C47+B47+2L47+4)/4 ...
   ;                               ;      (6C45+B45+L45+4)/4 ...>
  pand       mm0,mm6               ; 4S: pre-cleaned
   psrlq     mm1,1                 ; 5M: <(C57+B57)/2 ... (B55+L55)/2 ...>
  paddb      mm1,mm4               ; 5N: <(C57+B57+2L57)/2 ...
  ;                                ;      (2C55+B55+L55)/2 ...>
   psrlq     mm0,1                 ; 4T: P4 = <(5C47+B47+2L47+4)/8 ...
   ;                               ;           (6C45+B45+L45+4)/8 ...>
  movq       mm3,[ecx+PITCH*5]     ; 5U: T5
   pand      mm1,mm6               ; 5O: pre-cleaned
  movq       mm4,[ecx+ebp*4]       ; 4U: T4
   psrlq     mm1,1                 ; 5P: <(C57+B57+2L57)/4 ...
   ;                               ;      (2C55+B55+L55)/4 ...>
  paddb      mm1,CentralPred+40    ; 5Q: <(5C57+B57+2L57)/4 ...
  ;                                ;      (6C55+B55+L55)/4 ...>
   psubb     mm4,mm0               ; 4V: D4 = T4 - P4
  lea        esi,PrevMBAD[eax]
   psubb     mm1,mm7               ; 5R: <(5C57+B57+2L57+4)/4 ...
   ;                               ;      (6C55+B55+L55+4)/4 ...>
  and        esi,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk above.
   pand      mm1,mm6               ; 5S: pre-cleaned
  movq       [ebx+7*16],mm2        ; 7T
   psrlq     mm1,1                 ; 5T: P5 = <(5C57+B57+2L57+4)/8 ...
   ;                               ;           (6C55+B55+L55+4)/8 ...>
  movq       [ebx+4*16],mm4        ; 4W: Store D4.
   psubb     mm3,mm1               ; 5V: D5 = T5 - P5
  mov        cl,[esi].BlockType    ; Bottom bit set if above neighbor is INTRA.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [ebx+5*16],mm3        ; 5W: Store D5.
  cmp        cl,INTRA
   je        AboveEqCtrButSidesDiffer ; Jump if INTRA.  (Use central)

; Compute top remote prediction block.

  mov        ebx,PrevMBAD[eax].BlkY1.MVs
  and        ebx,00000FFFFH     ; Blk above may have B MVs set.  Clear them.
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  cmp        esi,ebx
   jne       AboveNeCtr

AboveEqCtrButSidesDiffer:

  movq       mm3,CentralPred+24   ; Prep mm0-3, which have ctr, for reuse below.
  movq       mm2,CentralPred+16
   paddb     mm3,mm3
  movq       mm1,CentralPred+8
   paddb     mm2,mm2
  movq       mm0,CentralPred
   paddb     mm1,mm1
  mov        ecx,PrevMBAD.BlkY1.BlkOffset
   jmp       AboveEqCtr

AboveNeCtr:

  mov        esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
   mov       eax,PrevMBAD[eax].BlkY1.BlkOffset
  sub        esi,eax
   mov       eax,ecx

  call       GetPredForAboveOrBelow

AboveEqCtr:

; Compute difference for lines 0 thru 3.

  mov        esi,AddrOfRightPred
   mov       ebx,TargetFrameBaseAddress
  movdt      mm5,[edi+8]           ; 1B: <  0   0   0   0 R13 R12 R11 R10>
   psrlq     mm1,1                 ; 1A: <A17 A16 A15 A14 A13 A12 A11 A10>
  punpckldq  mm5,[esi+8+4]         ; 1C: <L17 L16 L15 L14 R13 R12 R11 R10>
   pand      mm3,mm6
  movq       mm4,CFFFF00000000FFFF ; 1D: < FF  FF  00  00  00  00  FF  FF>
   psrlq     mm3,1                 ; 3A: <A37 A36 A35 A34 A33 A32 A31 A30>: mm0
  pand       mm4,mm5               ; 1E: <L17 L16  00  00  00  00 R11 R10>
   paddb     mm5,mm1               ; 1F: <A17+L17 ... A15+L15 ...>
  pand       mm1,C0000FFFFFFFF0000 ; 1G: < 00  00 A15 A14 A13 A12  00  00>
   pand      mm2,mm6
  paddb      mm5,CentralPred+8     ; 1H: <C17+A17+L17 ... C15+A15+L15 ...>
   paddb     mm1,mm4               ; 1I: <L17 L16 A15 A14 A13 A12 R11 R10>
                                   ; 0A: <A07 A06 A05 A04 A03 A02 A01 A00>:mm0
  movdt      mm4,[edi]             ; 0B: <  0   0   0   0 R03 R02 R01 R00>
   psubb     mm5,mm1               ; 1J: <C17+A17 ... C15+L15 ...>
  punpckldq  mm4,[esi+4]           ; 0C: <L07 L06 L05 L04 R03 R02 R01 R00>
   pand      mm5,mm6               ; 1K: <C17+A17 ... C15+L15 ...> pre-cleaned
  add        ecx,ebx               ;     Address of target block.
   psrlq     mm5,1                 ; 1L: <(C17+A17)/2 ... (C15+L15)/2 ...>
  paddb      mm1,mm5               ; 1M: <(C17+A17+2L17)/2 ...
   ;                               ;      (C15+2A15+L15)/2 ...>
   psrlq     mm2,1                 ; 2A: <A27 A26 A25 A24 A23 A22 A21 A20>
  movq       mm5,CFF000000000000FF ; 0D: < FF  00  00  00  00  00  00  FF>
   pand      mm1,mm6               ; 1N: pre-cleaned
  pandn      mm5,CentralPred       ; 0E: < 00 C06 C05 C04 C03 C02 C01  00>
   psrlq     mm1,1                 ; 1O: <(C17+A17+2L17)/4 ...
   ;                               ;      (C15+2A15+L15)/4 ...>
  paddb      mm1,CentralPred+8     ; 1P: <(5C17+A17+2L17)/4 ...
  ;                                ;      (5C15+2A15+L15)/4 ...>
   paddb     mm5,mm4               ; 0F: <L07 C06+L06 ...>
  pand       mm4,CFF000000000000FF ; 0G: <L07  00  00  00  00  00  00  L00>
   psubb     mm1,mm7               ; 1Q: <(5C17+A17+2L17+4)/4 ...
   ;                               ;      (5C15+2A15+L15+4)/4 ...>
  paddb      mm4,mm5               ; 0H: <2L07 C06+L06 ...>
   pand      mm1,mm6               ; 1R: pre-cleaned
  movq       mm5,[ecx+ebp*1]       ; 1T: T1
   psrlq     mm1,1                 ; 1S: P1 = <(5C17+A17+2L17+4)/8 ...
   ;                               ;           (5C15+2A15+L15+4)/8 ...>
  psubb      mm5,mm1               ; 1U: D1 = T1 - P1
   ;
  movdt      mm1,[edi+24]          ; 3B: <  0   0   0   0 R33 R32 R31 R30>
   pand      mm4,mm6               ; 0I: <2L07 C06+L06 ...> pre-cleaned
  movq       PelDiffsLine1,mm5       ; 1V: Store D1.
   psrlq     mm4,1                 ; 0J: <2L07/2 (C06+L06)/2 ...>
  punpckldq  mm1,[esi+24+4]        ; 3C: <L37 L36 L35 L34 R33 R32 R31 R30>
   paddb     mm0,mm4               ; 0K: <(2A07+2L07)/2 (C06+2A06+L06)/2 ...>
  movq       mm5,CFFFF00000000FFFF ; 3D: < FF  FF  00  00  00  00  FF  FF>
   pand      mm0,mm6               ; 0L: pre-cleaned
  movq       mm4,CentralPred+24    ; 3E: <C37 C36 C35 C34 C33 C32 C31 C30>
   psrlq     mm0,1                 ; 0M: <(2A07+2L07)/4 (C06+2A06+L06)/4 ...>
  paddb      mm0,CentralPred       ; 0N: <(4C07+2A07+2L07)/4
  ;                                ;      (5C06+2A06+L06)/4 ...>
   pand      mm5,mm4               ; 3F: <C37 C36  00  00  00  00 C31 C30>
  psubb      mm0,mm7               ; 0O: <(4C07+2A07+2L07+4)/4
  ;                                ;      (5C06+2A06+L06+4)/4 ...>
   paddb     mm4,mm1               ; 3G: <C37+L37 ... C35+L35 ...>
  pand       mm1,C0000FFFFFFFF0000 ; 3H: < 00  00 L35 L34 R33 R32  00  00>
   pand      mm0,mm6               ; 0P: <(4C07+2A07+2L07+4)/4
   ;                               ;      (5C06+2A06+L06+4)/4 ...> pre-cleaned
  paddb      mm1,mm5               ; 3I: <C37 C36 L35 L34 R33 R32 C31 C30>
   psrlq     mm0,1                 ; 0Q: P0 = <(4C07+2A07+2L07+4)/8
   ;                               ;           (5C06+2A06+L06+4)/8 ...>
  movdt      mm5,[edi+16]          ; 2B: <  0   0   0   0 R23 R22 R21 R20>
   psubb     mm4,mm1               ; 3J: <L37 L36 C35 C34 C33 C32 R31 R30>
  punpckldq  mm5,[esi+16+4]        ; 2C: <L27 L26 L25 L24 R23 R22 R21 R20>
   paddb     mm3,mm1               ; 3K: <C37+A37 ... A35+L35 ...>
  movq       mm1,[ecx]             ; 0R: T0
   pand      mm3,mm6               ; 3L: <C37+A37 ... A35+L35 ...> pre-cleaned
  psubb      mm1,mm0               ; 0S: D0 = T0 - P0
   psrlq     mm3,1                 ; 3M: <(C37+A37)/2 ... (A35+L35)/2 ...>
  movq       mm0,CFFFF00000000FFFF ; 2D: < FF  FF  00  00  00  00  FF  FF>
   paddb     mm3,mm4               ; 3N: <(C37+A37+2L37)/2 ...
   ;                               ;      (2C35+A35+L35)/2 ...>
  movq       mm4,CentralPred+16    ; 2E: <C27 C26 C25 C24 C23 C22 C21 C20>
   pand      mm3,mm6               ; 3O: pre-cleaned
  pand       mm0,mm4               ; 2F: <C27 C26  00  00  00  00 C21 C20>
   paddb     mm4,mm5               ; 2G: <C27+L27 ... C25+L25 ...>
  pand       mm5,C0000FFFFFFFF0000 ; 2H: < 00  00 L25 L24 R23 R22  00  00>
   psrlq     mm3,1                 ; 3P: <(C37+A37+2L37)/4 ...
   ;                               ;      (2C35+A35+L35)/4 ...>
  paddb      mm3,CentralPred+24    ; 3Q: <(5C37+A37+2L37)/4 ...
  ;                                ;      (6C35+A35+L35)/4 ...>
   paddb     mm5,mm0               ; 2I: <C27 C26 L25 L24 R23 R22 C21 C20>
  psubb      mm4,mm5               ; 2J: <L27 L26 C25 C24 C23 C22 R21 R20>
   paddb     mm2,mm5               ; 2K: <C27+A27 ... A25+L25 ...>
  pand       mm2,mm6               ; 2L: <C27+A27 ... A25+L25 ...> pre-cleaned
   psubb     mm3,mm7               ; 3R: <(5C37+A37+2L37+4)/4 ...
   ;                               ;      (6C35+A35+L35+4)/4 ...>
  pand       mm3,mm6               ; 3S: pre-cleaned
   psrlq     mm2,1                 ; 2M: <(C27+A27)/2 ... (A25+L25)/2 ...>
  paddb      mm2,mm4               ; 2N: <(C27+A27+2L27)/2 ...
  ;                                ;      (2C25+A25+L25)/2 ...>
   psrlq     mm3,1                 ; 3T: P3 = <(5C37+A37+2L37+4)/8 ...
   ;                               ;           (6C35+A35+L35+4)/8 ...>
  movq       mm0,[ecx+ebp*2]       ; 2U: T2
   pand      mm2,mm6               ; 2O: pre-cleaned
  movq       mm4,[ecx+PITCH*3]     ; 3U: T3
   psrlq     mm2,1                 ; 2P: <(C27+A27+2L27)/4 ...
   ;                               ;      (2C25+A25+L25)/4 ...>
  paddb      mm2,CentralPred+16    ; 2Q: <(5C27+A27+2L27)/4 ...
  ;                                ;      (6C25+A25+L25)/4 ...>
   psubb     mm4,mm3               ; 3V: D3 = T3 - P3
  movq       PelDiffsLine0,mm1     ; 0T
   psubb     mm2,mm7               ; 2R: <(5C27+A27+2L27+4)/4 ...
   ;                               ;      (6C25+A25+L25+4)/4 ...>
  movq       PelDiffsLine3,mm4     ; 3W: Store D3.
   pand      mm2,mm6               ; 2S: pre-cleaned
  psrlq      mm2,1                 ; 2T: P2 = <(5C27+A27+2L27+4)/8 ...
  ;                                ;           (6C25+A25+L25+4)/8 ...>
   ;
  psubb      mm0,mm2               ; 2V: D2 = T2 - P2
   ;
  ;
   ;
  movq       PelDiffsLine2,mm0     ; 2W: Store D2.
   ;
  jmp        MMxDoForwardDCTy      ; Block is in PelDiffs block;  Pitch is 16

LeftEqCtr:

;  Left remote motion vector was same as center.
;  Compute right remote prediction block.

  lea        edi,PrevMBAD[eax]
  and        edi,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk to right.
   mov       esi,PrevMBAD.BlkY1.MVs
  ;
   ;
  mov        cl,[edi].BlockType
   mov       ebx,PrevMBAD[eax].BlkY1.MVs
  cmp        cl,INTRA
   je        LeftEqCtrAndRightEqCtr ; Jump if INTRA.  (Use central)

  cmp        esi,ebx
   mov       esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using right remote.
  mov        edi,PrevMBAD[eax].BlkY1.BlkOffset
   jne       RightNeCtr

;  Left and right remote motion vectors were same as center.
;  Compute central prediction block.

LeftEqCtrAndRightEqCtr:

  mov        ebx,PrevMBAD.BlkY1.MVs
   mov       esi,PrevMBAD.BlkY1.PastRef
  lea        edi,CentralPred
   mov       eax,DistToBADforBlockBelow

  call       GetPredForCenterLeftOrRight

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+32],mm0
   psrlq     mm2,1
  movq       [edi+40],mm1
   pand      mm3,mm6
  movq       [edi+48],mm2
   psrlq     mm3,1
  lea        ecx,PrevMBAD[eax]
  and        ecx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk below.
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       [edi+56],mm3
   pcmpeqb   mm7,mm7             ;  . .  Restore 8 bytes of -1
  mov        bl,[ecx].BlockType
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  cmp        bl,INTRA
   mov       edi,AddrOfLeftPred
  mov        ebx,PrevMBAD[eax].BlkY1.MVs
   je        BottomHalfAllSame   ; Jump if INTRA.  (Use central)

; Compute bottom remote prediction block.

  cmp        esi,ebx
   mov       esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
  mov        eax,PrevMBAD[eax].BlkY1.BlkOffset
   je        BottomHalfAllSame

  sub        esi,eax
   lea       eax,[ecx+ebp*4]

  call       GetPredForAboveOrBelow

; Compute difference for lines 4 thru 7.  Only the remote motion vector below
; was different than the central motion vector.

                                   ; 4A: <B47 B46 B45 B44 B43 B42 B41 B40>: mm0
  movq       mm5,CentralPred+48    ; 6b: <C67 C66 C65 C64 C63 C62 C61 C60>
   pand      mm2,mm6
  movq       mm4,CentralPred+32    ; 4B: <C47 C46 C45 C44 C43 C42 C41 C40>
   psrlq     mm2,1                 ; 6a: <B67 B66 B65 B64 B63 B62 B61 B60>
  paddb      mm2,mm5               ; 6c: <C67+B67 ... C65+B65 ...>
   paddb     mm0,mm4               ; 4C: <C47+B47>
  pand       mm0,mm6               ; 4D: <C47+B47> pre-cleaned
   psrlq     mm1,1                 ; 5A: <B57 B56 B55 B54 B53 B52 B51 B50>
  pand       mm2,mm6               ; 6d: <C67+B67 ... C65+B65 ...> pre-cleaned 
   psrlq     mm0,1                 ; 4E: <(C47+B47)/2 ...>
  paddb      mm0,mm4               ; 4F: <(3C47+B47)/2 ...>
   psrlq     mm2,1                 ; 6e: <(C67+B67)/2 ... (C65+B65)/2 ...>
  pmullw     mm2,C0001000200020001 ; 6f: <(C67+B67)/2 ... (2C65+2B65)/2 ...>
   pand      mm0,mm6               ; 4G: <(3C47+B47)/2 ...> pre-cleaned
  pand       mm3,mm6
   psrlq     mm0,1                 ; 4H: <(3C47+B47)/4 ...>
  paddb      mm0,mm4               ; 4I: <(7C47+B47)/4 ...>
   psrlq     mm3,1                 ; 7A: <B77 B76 B75 B74 B73 B72 B71 B70>
  movq       mm4,C0000FFFFFFFF0000 ; 6g: < 00  00  FF  FF  FF  FF  00  00>
   psubb     mm0,mm7               ; 4J: <(7C47+B47+4)/4 ...>
  pandn      mm4,mm5               ; 6h: <C67 C66  00  00  00  00 C61 C60>
   psubb     mm5,mm7               ; 6i: <C67+1 ... C65+1 ...>
  paddb      mm2,mm4               ; 6j: <(3C67+B67)/2 ... (2C65+2B65)/2 ...>
   pand      mm0,mm6               ; 4K: <(7C47+B47+4)/4 ...> pre-cleaned
  movq       mm4,CentralPred+40    ; 5B
   pand      mm2,mm6               ; 6k: pre-cleaned
  paddb      mm1,mm4               ; 5C
   psrlq     mm0,1                 ; 4L: <(7C47+B47+4)/8 ...>
  pand       mm1,mm6               ; 5D
   psrlq     mm2,1                 ; 6l: <(3C67+B67)/4 ... (2C65+2B65)/4 ...>
  paddb      mm2,mm5               ; 6m: <(7C67+B67+4)/4 ... (6C65+2B65+4)/4...>
   psrlq     mm1,1                 ; 5E
  movq       mm5,CentralPred+56    ; 7B: <C77 C76 C75 C74 C73 C72 C71 C70>
   paddb     mm1,mm4               ; 5F
  paddb      mm3,mm5               ; 7C: <C77+B47>
   pand      mm1,mm6               ; 5G
  pand       mm3,mm6               ; 7D: <C77+B47> pre-cleaned
   psrlq     mm1,1                 ; 5H
  paddb      mm1,mm4               ; 5I
   psrlq     mm3,1                 ; 7E: <(C77+B47)/2 ...>
  psubb      mm1,mm7               ; 5J
   paddb     mm3,mm5               ; 7F: <(3C77+B47)/2 ...>
  pand       mm1,mm6               ; 5K
   psubb     mm3,mm7               ; 7G: <(3C77+B47+2)/2 ...>
  pand       mm2,mm6               ; 6n: pre-cleaned
   psrlq     mm1,1                 ; 5L
  pand       mm3,mm6               ; 7H: <(3C77+B47+2)/2 ...> pre-cleaned
   psrlq     mm2,1                 ; 6o: <(7C67+B67+4)/8 ... (6C65+2B65+4)/8...>
  psrlq      mm3,1                 ; 7I: <(3C77+B47+2)/4 ...>

BottomHalfAllSame:

   mov       ebx,TargetFrameBaseAddress
  mov        eax,DistToBADforBlockAbove
   mov       esi,PrevMBAD.BlkY1.MVs
  movq       mm5,[ecx+ebx+PITCH*5] ; 5M
  add        ecx,ebx               ;     Address of target block.
   lea       ebx,PrevMBAD[eax]

  and        ebx,-SIZEOF T_MacroBlockActionDescr ; Addr of MBD for blk above.
   psubb     mm5,mm1               ; 5N
  movq       mm4,[ecx+ebp*4]       ; 4M: T4
  movq       mm1,[ecx+PITCH*7]     ; 7J: T7
   psubb     mm4,mm0               ; 4N: D4 = T4 - P4
  movq       mm0,[ecx+PITCH*6]     ; 6p: T6
   psubb     mm1,mm3               ; 7K: D7 = T7 - P7
  movq       PelDiffsLine4,mm4     ; 4O: Store D4.
   psubb     mm0,mm2               ; 6q: D6 = T6 - P6
  movq       PelDiffsLine5,mm5     ; 5O
  movq       PelDiffsLine6,mm0     ; 6r
  movq       PelDiffsLine7,mm1     ; 7L
  mov        cl,[ebx].BlockType
  cmp        cl,INTRA
   mov       ecx,PrevMBAD.BlkY1.BlkOffset
  mov        ebx,PrevMBAD[eax].BlkY1.MVs
   je        SidesEqCtrAndAboveEqCtr  ; Jump if INTRA.  (Use central)

; Compute top remote prediction block.

  and        ebx,00000FFFFH     ; Blk above may have B MVs set.  Clear them.
  cmp        esi,ebx
   mov       esi,PrevMBAD[eax].BlkY1.PastRef  ; Get ref addr using above remote.
  mov        eax,PrevMBAD[eax].BlkY1.BlkOffset
   jne       SidesEqCtrButAboveNeCtr

SidesEqCtrAndAboveEqCtr:

  movq       mm0,CentralPred
  movq       mm1,CentralPred+8
   paddb     mm0,mm0
  movq       mm2,CentralPred+16
   paddb     mm1,mm1
  movq       mm3,CentralPred+24
   paddb     mm2,mm2
  jmp        TopHalfAllSame

SidesEqCtrButAboveNeCtr:

  sub        esi,eax
   mov       eax,ecx

  call       GetPredForAboveOrBelow

; Compute difference for lines 0 thru 3.  Only the remote motion vector above
; was different than the central motion vector.

  movq       mm5,CentralPred+8     ; 1b
   pand      mm3,mm6
  movq       mm4,CentralPred+24    ; 3B
   psrlq     mm3,1                 ; 3A
  paddb      mm3,mm4               ; 3C
   psrlq     mm1,1                 ; 1A
  paddb      mm1,mm5               ; 1c
   pand      mm3,mm6               ; 3D
  pand       mm1,mm6               ; 1d
   psrlq     mm3,1                 ; 3E
  paddb      mm3,mm4               ; 3F
   psrlq     mm1,1                 ; 1e
  pmullw     mm1,C0001000200020001 ; 1f
   pand      mm3,mm6               ; 3G
  pand       mm2,mm6
   psrlq     mm3,1                 ; 3H
  paddb      mm3,mm4               ; 3I
   psrlq     mm2,1                 ; 2a
  movq       mm4,C0000FFFFFFFF0000 ; 1g
   psubb     mm3,mm7               ; 3J
  pandn      mm4,mm5               ; 1h
   psubb     mm5,mm7               ; 1i
  paddb      mm1,mm4               ; 1j
   pand      mm3,mm6               ; 3K
  movq       mm4,CentralPred+16    ; 2B
   pand      mm1,mm6               ; 1k
  paddb      mm2,mm4               ; 2C
   psrlq     mm3,1                 ; 3L
  pand       mm2,mm6               ; 2D
   psrlq     mm1,1                 ; 1l
  paddb      mm1,mm5               ; 1m
   psrlq     mm2,1                 ; 2E
  movq       mm5,CentralPred       ; 0B
   paddb     mm2,mm4               ; 2F
  paddb      mm0,mm5               ; 0C
   pand      mm2,mm6               ; 2G
  pand       mm0,mm6               ; 0D
   psrlq     mm2,1                 ; 2H
  paddb      mm2,mm4               ; 2I
   psrlq     mm0,1                 ; 0E
  psubb      mm2,mm7               ; 2J
   paddb     mm0,mm5               ; 0F
  pand       mm2,mm6               ; 2K
   psubb     mm0,mm7               ; 0G

TopHalfAllSame:

  mov        ebx,TargetFrameBaseAddress
  lea        edi,[ecx+ebx]
   pand      mm1,mm6               ; 1n
  movq       mm7,[ecx+ebx]         ; 0J
   pand      mm0,mm6               ; 0H
  movq       mm5,[edi+PITCH*3]     ; 3M
   psrlq     mm2,1                 ; 2L
  movq       mm4,[edi+ebp*2]       ; 2M
   psubb     mm5,mm3               ; 3N
  psubb      mm4,mm2               ; 2N
   psrlq     mm1,1                 ; 1o
  movq       mm3,[edi+ebp*1]       ; 1p
   psubb     mm3,mm1               ; 1q
  movq       PelDiffsLine3,mm5     ; 3O
   psrlq     mm0,1                 ; 0I
  movq       PelDiffsLine2,mm4     ; 2O
   psubb     mm7,mm0               ; 0K
  movq       PelDiffsLine1,mm3     ; 1r
  movq       PelDiffsLine0,mm7     ; 0L
  jmp        MMxDoForwardDCTy      ; Block is in PelDiffs block;  Pitch is 16

;=============================================================================
; This internal function computes the OBMC contribution for the reference
; block that uses the left, central, or right remote motion vector.
;
;  ebp -- PITCH
;  edi -- Address of where to put the contribution.
;  esi -- Address of reference block.
;  edx -- Reserved.  MBlockActionStream
;  ecx -- Unavailable.
;  ebx -- Scratch.  Initially the horizontal and vertical motion vectors.
;  eax -- Unavailable.
;  mm7 -- 8 bytes of -1
;  mm6 -- 8 bytes of 0xFE
;  mm0-mm5 -- Scratch

StackOffset TEXTEQU <12_ButAccessToLocalVariablesShouldNotBeNeeded>

GetPredForCenterLeftOrRight:

  shr        ebx,1
   jc        HorzInterpInCLRPred
  
  movq       mm1,[esi+ebp*1]
  and        bl,080H
   je        NoInterpInCLRPred

VertInterpInCLRPred:

  movq       mm0,[esi]
   psubb     mm1,mm7

  call       Get4LinesOfPred_InterpVert

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+0],mm0
   pand      mm3,mm6
  movq       [edi+8],mm1
   psrlq     mm2,1
  movq       mm1,[esi+ebp*1]
   psrlq     mm3,1
  movq       [edi+16],mm2
   movq      mm0,mm4
  movq       [edi+24],mm3
   psubb     mm1,mm7
  jmp        Get4MoreLinesOfPred_InterpVert

HorzInterpInCLRPred:
  
  movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  and        bl,080H
   jne       BothInterpInCLRPred

  call       Get4LinesOfPred_InterpHorz

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+0],mm0
   pand      mm3,mm6
  movq       [edi+8],mm1
   psrlq     mm2,1
  movq       mm5,[esi+1]         ; <R48 R47 R46 R45 R44 R43 R42 R41>
   psrlq     mm3,1
  movq       [edi+16],mm2
   ;
  movq       [edi+24],mm3
   ;
  jmp        Get4MoreLinesOfPred_InterpHorz

BothInterpInCLRPred:

  call       Get4LinesOfPred_InterpBoth

  pand       mm2,mm6
   psrlq     mm1,1
  movq       [edi+0],mm0
   pand      mm3,mm6
  movq       [edi+8],mm1
   psrlq     mm2,1
  movq       mm1,[esi+ebp*1]
   psrlq     mm3,1
  movq       [edi+16],mm2
   movq      mm0,mm4
  movq       [edi+24],mm3
   psubb     mm1,mm7
  paddb      mm5,mm5
   jmp       Get4MoreLinesOfPred_InterpBoth

NoInterpInCLRPred:

  movq       mm0,[esi]
  movq       mm2,[esi+ebp*2]
  movq       mm3,[esi+PITCH*3]
  movq       [edi+0],mm0
  movq       [edi+8],mm1
  movq       [edi+16],mm2
  movq       [edi+24],mm3
  movq       mm3,[esi+PITCH*7]
  movq       mm2,[esi+PITCH*6]
   paddb     mm3,mm3
  movq       mm1,[esi+PITCH*5]
   paddb     mm2,mm2
  movq       mm0,[esi+ebp*4]
   paddb     mm1,mm1
  ret

;=============================================================================
; This internal function computes the OBMC contribution for the reference
; block that uses the remote motion vector from block above or below.
;
;  ebp -- PITCH
;  edi -- Not used.
;  esi -- Address of reference block (after ecx is added in).
;  edx -- Reserved.  MBlockActionStream
;  ecx -- Unavailable.  Must not be changed.
;  ebx -- Scratch.  Initially the horizontal and vertical motion vectors.
;  eax -- Offset within frame for block being worked on.
;  mm7 -- 8 bytes of -1
;  mm6 -- 8 bytes of 0xFE
;  mm0-mm5 -- Scratch

GetPredForAboveOrBelow:

  shr        ebx,1
   lea       esi,[esi+eax]
  jc         HorzInterpInABPred
  
  movq       mm1,[esi+ebp*1]
  movq       mm0,[esi]
   psubb     mm1,mm7
  and        bl,080H
   jne       Get4LinesOfPred_InterpVert

  movq       mm2,[esi+ebp*2]
   paddb     mm1,mm7
  movq       mm3,[esi+PITCH*3]
   paddb     mm1,mm1
  paddb      mm2,mm2
   paddb     mm3,mm3
  ret

HorzInterpInABPred:
  
  movq       mm5,[esi+1]         ; A. .  <R08 R07 R06 R05 R04 R03 R02 R01>
  and        bl,080H
   jne       Get4LinesOfPred_InterpBoth

  jmp        Get4LinesOfPred_InterpHorz

StackOffset TEXTEQU <0>
;=============================================================================
ENDIF

Done:

IFDEF H261
ELSE; H263
  mov        bl,PendingOBMC
   mov       cl,INTER1MV
  test       bl,bl
   je        TrulyDone

  mov        StashBlockType,cl

  call       DoPendingOBMCDiff

  mov        al,IsPlainPFrame
   add       edx,-SIZEOF T_MacroBlockActionDescr
  test       al,al
   jne       TrulyDone

  movq       mm6,C0101010101010101
   pxor      mm7,mm7                      ; Initialize SWD accumulator

  call       MMxDoBFrameLumaBlocks

ENDIF
TrulyDone:

  emms
IFDEF H261
  mov        eax,SWDTotal
  mov        esp,StashESP
  mov        edi,[esp+PSWDTotal]
  mov        [edi],eax
ELSE
  mov        eax,SWDTotal
   mov       ebx,BSWDTotal
  mov        esp,StashESP
  mov        edi,[esp+PSWDTotal]
   mov       esi,[esp+PBSWDTotal]
  mov        [edi],eax
   mov       [esi],ebx
ENDIF
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  rturn

MMxEDTQ endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\memmodel.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\memmodel.inv   1.1   27 Dec 1995 14:36:24   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\memmodel.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:24   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF memmodel_inc
ELSE

IFDEF WIN32
.486
.MODEL FLAT, STDCALL
Zd EQU <>
Ze EQU <>
Zf EQU <>
Zg EQU <>
Zs EQU <>
Zc EQU <>
BPTR equ ebp
SPTR equ esp
NAT_WORD TEXTEQU <DWORD>

ELSE

.MODEL MEDIUM
.486
Zd EQU <ds:>
Ze EQU <es:>
Zf EQU <fs:>
Zg EQU <gs:>
Zs EQU <ss:>
Zc EQU <cs:>
BPTR equ bp
SPTR equ sp
NAT_WORD TEXTEQU <WORD>

ENDIF

PD EQU <DWORD PTR>
PW EQU <WORD PTR>
PB EQU <BYTE PTR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; this provides a normal return when under WIN32 and
;; a 16 bit mode instruction override when under not WIN32
;;
;; This is needed as the segment this code runs in is
;; in 32 bit mode but the caller is in 16 bit mode.
;;
;; under WIN32, we must relieve the stack of passed
;; args, and with proper setup of the PROC directive,
;; the assembler will calculate the correct value
;; to relieve every time it sees the ret.
;;
;; this also sets the language to 'C' when not under WIN32 and
;; stdcall when under WIN32
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifdef WIN32
LANG    TEXTEQU <stdcall>
DIST    TEXTEQU <>
rturn   MACRO
	ret
ENDM
else
LANG    TEXTEQU <C>
DIST    TEXTEQU <FAR>
rturn   MACRO
	db      66h
	retf
ENDM
endif

memmodel_inc=1

; this is intended to emulate a disabled epilouge with the single
; exception of relieving the stack of passed parameters if
; the calling type is STDCALL.
;
; only stdcall and c calling conventions are directly supported.
; VARARGS is not supported.
; NONE of the standard prologue or epilogue switches
; are used.
; Like the standard epilogue, the use of retf, retn or ret n
; where n is the number of bytes to relieve, this macro
; is effectively disabled.
ReturnAndRelieveEpilogueMacro MACRO procname, \
                                    flag,     \
                                    parmbytes, \
                                    localbytes, \
                                    reglist, \
                                    macroargs
LOCAL RET_DIST
if (flag AND 020h)
; We are in a FAR procedure
	RET_DIST TEXTEQU <retf>
else
; We are in a local procedure
	RET_DIST TEXTEQU <ret>
endif

if (flag AND 010h)
; user restoring the stack: ret n, retf or retn was used
	RET_DIST
else
; user expects us to restore the stack: ret was used
if (flag AND 007h) EQ 3
; stdcall calling convention
if parmbytes EQ 0
	RET_DIST
else
	RET_DIST		parmbytes
endif
else
; assume 'C' calling convention
	RET_DIST
endif

endif
ENDM

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\locals.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\locals.inv   1.1   27 Dec 1995 14:36:24   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\locals.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:24   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

include memmodel.inc
IFDEF WIN32
LDal    macro   address
        mov     al,BYTE PTR address[esp]
        endm

LDbl    macro   address
        mov     bl,BYTE PTR address[esp]
        endm

LDcl    macro   address
        mov     cl,BYTE PTR address[esp]
        endm

LDdl    macro   address
        mov     dl,BYTE PTR address[esp]
        endm

LDah    macro   address
        mov     ah,BYTE PTR address[esp]
        endm

LDbh    macro   address
        mov     bh,BYTE PTR address[esp]
        endm

LDch    macro   address
        mov     ch,BYTE PTR address[esp]
        endm

LDdh    macro   address
        mov     dh,BYTE PTR address[esp]
        endm

Leax    macro   address
        mov     eax,DWORD PTR address[esp]
        endm

Lebx    macro   address
        mov     ebx,DWORD PTR address[esp]
        endm

Lecx    macro   address
        mov     ecx,DWORD PTR address[esp]
        endm

Ledx    macro   address
        mov     edx,DWORD PTR address[esp]
        endm

Lesi    macro   address
        mov     esi,DWORD PTR address[esp]
        endm

Ledi    macro   address
        mov     edi,DWORD PTR address[esp]
        endm

Lebp    macro   address
        mov     ebp,DWORD PTR address[esp]
        endm

LZeax   macro   address
        movzx   eax,BYTE PTR address[esp]
        endm

LZebx   macro   address
        movzx   ebx,BYTE PTR address[esp]
        endm

LZecx   macro   address
        movzx   ecx,BYTE PTR address[esp]
        endm

LZedx   macro   address
        movzx   edx,BYTE PTR address[esp]
        endm

LZesi   macro   address
        movzx   esi,BYTE PTR address[esp]
        endm

LZedi   macro   address
        movzx   edi,BYTE PTR address[esp]
        endm

LZebp   macro   address
        movzx   ebp,BYTE PTR address[esp]
        endm

STal    macro   address
        mov     BYTE PTR address[esp],al
        endm

STbl    macro   address
        mov     BYTE PTR address[esp],bl
        endm

STcl    macro   address
        mov     BYTE PTR address[esp],cl
        endm

STdl    macro   address
        mov     BYTE PTR address[esp],dl
        endm

STah    macro   address
        mov     BYTE PTR address[esp],ah
        endm

STbh    macro   address
        mov     BYTE PTR address[esp],bh
        endm

STch    macro   address
        mov     BYTE PTR address[esp],ch
        endm

STdh    macro   address
        mov     BYTE PTR address[esp],dh
        endm

Seax    macro   address
        mov     DWORD PTR address[esp],eax
        endm

Sebx    macro   address
        mov     DWORD PTR address[esp],ebx
        endm

Secx    macro   address
        mov     DWORD PTR address[esp],ecx
        endm

Sedx    macro   address
        mov     DWORD PTR address[esp],edx
        endm

Sesi    macro   address
        mov     DWORD PTR address[esp],esi
        endm

Sedi    macro   address
        mov     DWORD PTR address[esp],edi
        endm

Sebp    macro   address
        mov     DWORD PTR address[esp],ebp
        endm

ADDeax  macro   address
        add     eax,DWORD PTR address[esp]
        endm

ADDebx  macro   address
        add     ebx,DWORD PTR address[esp]
        endm

ADDecx  macro   address
        add     ecx,DWORD PTR address[esp]
        endm

ADDedx  macro   address
        add     edx,DWORD PTR address[esp]
        endm

ADDesi  macro   address
        add     esi,DWORD PTR address[esp]
        endm

ADDedi  macro   address
        add     edi,DWORD PTR address[esp]
        endm

ADDebp  macro   address
        add     ebp,DWORD PTR address[esp]
        endm

SUBeax  macro   address
        sub     eax,DWORD PTR address[esp]
        endm

SUBebx  macro   address
        sub     ebx,DWORD PTR address[esp]
        endm

SUBecx  macro   address
        sub     ecx,DWORD PTR address[esp]
        endm

SUBedx  macro   address
        sub     edx,DWORD PTR address[esp]
        endm

SUBesi  macro   address
        sub     esi,DWORD PTR address[esp]
        endm

SUBedi  macro   address
        sub     edi,DWORD PTR address[esp]
        endm

SUBebp  macro   address
        sub     ebp,DWORD PTR address[esp]
        endm

CMPeax  macro   address
        cmp     eax,DWORD PTR address[esp]
        endm

CMPebx  macro   address
        cmp     ebx,DWORD PTR address[esp]
        endm

CMPecx  macro   address
        cmp     ecx,DWORD PTR address[esp]
        endm

CMPedx  macro   address
        cmp     edx,DWORD PTR address[esp]
        endm

CMPesi  macro   address
        cmp     esi,DWORD PTR address[esp]
        endm

CMPedi  macro   address
        cmp     edi,DWORD PTR address[esp]
        endm

CMPebp  macro   address
        cmp     ebp,DWORD PTR address[esp]
        endm

ADDC2M  macro   address,constant
        add     DWORD PTR address[esp],constant
        endm

ELSE
LDal    macro   address
        DB      0A0H            ; opcode: move memory to accumulator (al)
        DD      address         ; source
        endm

LDbl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      01DH            ; destination: bl
        DD      address         ; source
        endm

LDcl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      00DH            ; destination: cl
        DD      address         ; source
        endm

LDdl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      015H            ; destination: dl
        DD      address         ; source
        endm

LDah    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      025H            ; destination: ah
        DD      address         ; source
        endm

LDbh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      03DH            ; destination: bh
        DD      address         ; source
        endm

LDch    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      02DH            ; destination: ch
        DD      address         ; source
        endm

LDdh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      035H            ; destination: dh
        DD      address         ; source
        endm

Leax    macro   address
        DB      0A1H            ; opcode: move memory to accumulator (eax)
        DD      address         ; source
        endm

Lebx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

Lecx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

Ledx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

Lesi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

Ledi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

Lebp    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

LZeax   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

LZebx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

LZecx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

LZedx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

LZesi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

LZedi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

LZebp   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

STal    macro   address
        DB      0A2H            ; opcode: move accumulator (al) to memory
        DD      address         ; destination
        endm

STbl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      01DH            ; source: bl
        DD      address         ; destination
        endm

STcl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      00DH            ; source: cl
        DD      address         ; destination
        endm

STdl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      015H            ; source: dl
        DD      address         ; destination
        endm

STah    macro   address
        DB      088H            ; opcode: move register to memory
        DB      025H            ; source: ah
        DD      address         ; destination
        endm

STbh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      03DH            ; source: bh
        DD      address         ; destination
        endm

STch    macro   address
        DB      088H            ; opcode: move register to memory
        DB      02DH            ; source: ch
        DD      address         ; destination
        endm

STdh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      035H            ; source: dh
        DD      address         ; destination
        endm

Seax    macro   address
        DB      0A3H            ; opcode: move accumulator (eax) to memory
        DD      address         ; destination
        endm

Sebx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      01DH            ; source: ebx
        DD      address         ; destination
        endm

Secx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      00DH            ; source: ecx
        DD      address         ; destination
        endm

Sedx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      015H            ; source: edx
        DD      address         ; destination
        endm

Sesi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      035H            ; source: esi
        DD      address         ; destination
        endm

Sedi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      03DH            ; source: edi
        DD      address         ; destination
        endm

Sebp    macro   address
        DB      089H            ; opcode: move register to memory
        DB      02DH            ; source: ebp
        DD      address         ; destination
        endm

ADDeax  macro   address
        DB      003H            ; opcode: add memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

ADDebx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

ADDecx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

ADDedx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

ADDesi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

ADDedi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

ADDebp  macro   address
        DB      003H            ; opcode: add memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

SUBeax  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      005H            ; source: eax
        DD      address         ; destination
        endm

SUBebx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

SUBecx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

SUBedx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

SUBesi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

SUBedi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

SUBebp  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

CMPeax  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      005H            ; source: eax
        DD      address         ; source
        endm

CMPebx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      01DH            ; source: ebx
        DD      address         ; source
        endm

CMPecx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      00DH            ; source: ecx
        DD      address         ; source
        endm

CMPedx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      015H            ; source: edx
        DD      address         ; source
        endm

CMPesi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      035H            ; source: esi
        DD      address         ; source
        endm

CMPedi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      03DH            ; source: edi
        DD      address         ; source
        endm

CMPebp  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      02DH            ; source: ebp
        DD      address         ; source
        endm

ADDC2M  macro   address,constant
        add     ds:DWORD PTR address,constant
        endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\yuv12enc.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;//
;////////////////////////////////////////////////////////////////////////////
; yuv12enc -- This function performs "color conversion" in the H26X decoder for
;             consumption by the H26X encoder.  This entails reformatting the decoder's
;             YVU data into the shape required by the encoder - including YUV order.  It
;			  Also includes 7-bit pels.
; $Header:   S:\h26x\src\dec\yuv12enc.asv   1.5   30 Oct 1996 14:31:00   mbodart  $
; $Log:   S:\h26x\src\dec\yuv12enc.asv  $
;// 
;//    Rev 1.5   30 Oct 1996 14:31:00   mbodart
;// Re-checking in changes originally made by Atul, but lost when the server
;// ran out of disk space during a PVCS operation.  Atul's original log msg:
;// 
;// Removed AGI in IA code.  Added MMX code but it is not ready for prime-time.
;// 
;//    Rev 1.4   08 Mar 1996 15:11:10   AGUPTA2
;// Removed segment register override when compiling for WIN32.
;// Should speed-up this routine substantially.
;// 
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include decconst.inc
include iammx.inc
IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataH26x_YUV12ForEnc>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE H26x_YUV12ForEnc (
;							U8 FAR * InstanceBase,
;                           X32 YPlane,
;                           X32 VPlane,
;                           X32 UPlane,
;                           UN  FrameWidth,
;                           UN  FrameHeight,
;                           UN  Pitch,
;                           U8 FAR * ColorConvertedFrame, // encoder's buffers.
;                           X32 YOutputPlane,
;                           X32 VOutputPlane,
;                           X32 UOutputPlane)
;
;  YPlane, VPlane, YOutputPlane, and VOutputPlane are offsets. In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;

PUBLIC  H26x_YUV12ForEnc

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        H26x_YUV12ForEnc proc DIST LANG PUBLIC, 
            							AInstanceBase:         DWORD,
							     		AYPlane:               DWORD,
							     		AVPlane:               DWORD,
							     		AUPlane:               DWORD,
							     		AFrameWidth:           DWORD,
										AFrameHeight:          DWORD,
										APitch:                DWORD,
										AColorConvertedFrame:  DWORD,
										AYOutputPlane:         DWORD,
										AVOutputPLane:         DWORD,
										AUOutputPLane:         DWORD


LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase            = LocalFrameSize + RegisterStorageSize +  4
YPlane                  = LocalFrameSize + RegisterStorageSize +  8
VPlane                  = LocalFrameSize + RegisterStorageSize + 12
UPlane                  = LocalFrameSize + RegisterStorageSize + 16
FrameWidth              = LocalFrameSize + RegisterStorageSize + 20
FrameHeight             = LocalFrameSize + RegisterStorageSize + 24
Pitch                   = LocalFrameSize + RegisterStorageSize + 28
ColorConvertedFrame     = LocalFrameSize + RegisterStorageSize + 32
YOutputPlane            = LocalFrameSize + RegisterStorageSize + 36
VOutputPlane            = LocalFrameSize + RegisterStorageSize + 40
UOutputPlane            = LocalFrameSize + RegisterStorageSize + 44
EndOfArgList            = LocalFrameSize + RegisterStorageSize + 48

LCL EQU <esp+>

  push  esi
  push  edi
  push  ebp
  push  ebx
  sub   esp,LocalFrameSize
  mov   eax,PD [esp+InstanceBase]
  add   PD [esp+YPlane],eax
  add   PD [esp+VPlane],eax
  add   PD [esp+UPlane],eax
  mov   eax,PD [esp+ColorConvertedFrame]
  add	PD [esp+YOutputPlane],eax
  add	PD [esp+VOutputPlane],eax
  add	PD [esp+UOutputPlane],eax

;   We copy 16 pels in one iteration of the inner loop
; Register usage:
;   edi -- Y plane output cursor
;   esi -- Y plane input cursor
;   ebp -- Count down Y plane height
;   ecx -- Count down Y plane width
;   ebx -- Y plane input pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  Lesi  YPlane
   Lebx Pitch
  Ledi  YOutputPlane

YLoopHeader:	
  mov   eax, PD [esi+ecx-8]        ; 
   mov  edx, PD [esi+ecx-4]
ALIGN 4
YLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
                                   ; NEXT 8 PELS
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8-8], eax
   mov  PD [edi+ecx-4-8], edx

  mov   eax, PD [esi+ecx-8-16]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-16]      ; for next iteration

  sub   ecx, 16
   jg   YLoop

  Lecx  FrameWidth
   add  esi, ebx
  add   edi, ebx
   dec  ebp
  jne   YLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- V plane output cursor
;   esi -- V plane input cursor
;   ebp -- Count down V plane height
;   ecx -- Count down V plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi VPlane
  sar   ebp,1
   Ledi VOutputPlane

ALIGN 4
VLoopHeader:
  mov   eax, PD [esi+ecx-8]
   mov  edx, PD [esi+ecx-4]
VLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  sub   ecx, 8
   jg   VLoop

  Lecx  FrameWidth
   add  esi,ebx
  shr   ecx,1
   add  edi,ebx
  dec   ebp
   jne  VLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- U plane output cursor
;   esi -- U plane input cursor
;   ebp -- Count down U plane height
;   ecx -- Count down U plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi UPlane
  sar   ebp,1
   Ledi UOutputPlane

ALIGN 4
ULoopHeader:
  mov   eax,PD [esi+ecx-8]
   mov  edx,PD [esi+ecx-4]
ULoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]
   mov  edx, PD [esi+ecx-4-8]
  sub   ecx, 8
   jg   ULoop

  Lecx  FrameWidth
   add  esi, ebx
  shr   ecx, 1
   add  edi, ebx
  dec   ebp
   jne  ULoopHeader

  add   esp,LocalFrameSize
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

H26x_YUV12ForEnc endp

IFDEF H263P
MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
CLEAR_LOW_BIT_MASK  LABEL DWORD
  DWORD 0FEFEFEFEH, 0FEFEFEFEH
CLEAR_HIGH_BIT_MASK LABEL DWORD
  DWORD 07F7F7F7FH, 07F7F7F7FH
MMXDATA1 ENDS

PUBLIC  MMX_H26x_YUV12ForEnc

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        MMX_H26x_YUV12ForEnc proc DIST LANG PUBLIC, 
            							AInstanceBase:         DWORD,
							     		AYPlane:               DWORD,
							     		AVPlane:               DWORD,
							     		AUPlane:               DWORD,
							     		AFrameWidth:           DWORD,
										AFrameHeight:          DWORD,
										APitch:                DWORD,
										AColorConvertedFrame:  DWORD,
										AYOutputPlane:         DWORD,
										AVOutputPLane:         DWORD,
										AUOutputPLane:         DWORD

LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase            = LocalFrameSize + RegisterStorageSize +  4
YPlane                  = LocalFrameSize + RegisterStorageSize +  8
VPlane                  = LocalFrameSize + RegisterStorageSize + 12
UPlane                  = LocalFrameSize + RegisterStorageSize + 16
FrameWidth              = LocalFrameSize + RegisterStorageSize + 20
FrameHeight             = LocalFrameSize + RegisterStorageSize + 24
Pitch                   = LocalFrameSize + RegisterStorageSize + 28
ColorConvertedFrame     = LocalFrameSize + RegisterStorageSize + 32
YOutputPlane            = LocalFrameSize + RegisterStorageSize + 36
VOutputPlane            = LocalFrameSize + RegisterStorageSize + 40
UOutputPlane            = LocalFrameSize + RegisterStorageSize + 44
EndOfArgList            = LocalFrameSize + RegisterStorageSize + 48

LCL EQU <esp+>

CLEAR_LOW_BIT  EQU mm6
CLEAR_HIGH_BIT EQU mm7

  push  esi
  push  edi
  push  ebp
  push  ebx
  sub   esp,LocalFrameSize
  mov   eax,PD [esp+InstanceBase]
  add   PD [esp+YPlane],eax
  add   PD [esp+VPlane],eax
  add   PD [esp+UPlane],eax
  mov   eax,PD [esp+ColorConvertedFrame]
  add	PD [esp+YOutputPlane],eax
  add	PD [esp+VOutputPlane],eax
  add	PD [esp+UOutputPlane],eax

;   We copy 16 pels of two lines in one iteration of the inner loop
; Register usage:
;   edi -- Y plane output cursor (line 0)
;   edx -- Y plane output cursor (line 1)
;   esi -- Y plane input cursor  (line 0)
;   eax -- Y plane input cursor  (line 1)
;   ebp -- Count down Y plane height / 2
;   ecx -- Count down Y plane width
;   ebx -- Y plane input pitch

  Lebp  FrameHeight
   Lebx Pitch
  Lesi  YPlane
   Lecx FrameWidth
  Ledi  YOutputPlane
   lea  eax, [esi + ebx]                  ; line 1 of input
  movq  mm6, CLEAR_LOW_BIT_MASK
   lea  edx, [edi + ebx]                  ; line 1 of output
  movq  mm7, CLEAR_HIGH_BIT_MASK
   shr  ebp, 1                            ; two lines in one iteration
  

YLoopHeader:	
  movq       mm0, [esi+ecx-16]            ;00
   ;
  movq       mm1, [esi+ecx-8]             ;01
   psrlq     mm0, 1                       ;00 Shift packed pel by 1 to convert to 7-bit
YLoop:
  movq       mm2, [eax+ecx-16]            ;10 
   pand      mm0, CLEAR_HIGH_BIT          ;00 and to get rid of high bit
  movq       mm3, [eax+ecx-8]             ;11
   psrlq     mm1, 1                       ;01
  movq       [edi+ecx-16], mm0            ;00
   pand      mm1, CLEAR_LOW_BIT           ;01 and to get rid of low bit
  movq       mm0, [esi+ecx-16-16]         ;   speculatively load next 8 pels
   psrlq     mm2, 1                       ;10 Shift packed pel by 1 to convert to 7-bit
  movq       [edi+ecx-8 ], mm1            ;01
   pand      mm2, CLEAR_HIGH_BIT          ;10 and to get rid of high bit
  movq       mm1, [esi+ecx-8 -16]         ;   for next iteration
   pand      mm3, CLEAR_LOW_BIT           ;11 and to get rid of low bit
  movq       [edx+ecx-16], mm2            ;10
   psrlq     mm3, 1                       ;11
  psrlq      mm0, 1                       ;00 Shift packed pel by 1 to convert to 7-bit
   ;
  movq       [edx+ecx-8 ], mm3            ;11
   sub       ecx, 16
  jg        YLoop

  Lecx  FrameWidth
   lea  esi, [esi + 2*ebx]
  lea   edi, [edi + 2*ebx]
   lea  eax, [eax + 2*ebx]            ; line 1 of input
  lea   edx, [edx + 2*ebx]            ; line 1 of output
   dec  ebp
  jne   YLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- V plane output cursor
;   esi -- V plane input cursor
;   ebp -- Count down V plane height
;   ecx -- Count down V plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi VPlane
  sar   ebp,1
   Ledi VOutputPlane

ALIGN 4
VLoopHeader:
  mov   eax, PD [esi+ecx-8]
   mov  edx, PD [esi+ecx-4]
VLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  sub   ecx, 8
   jg   VLoop

  Lecx  FrameWidth
   add  esi,ebx
  shr   ecx,1
   add  edi,ebx
  dec   ebp
   jne  VLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- U plane output cursor
;   esi -- U plane input cursor
;   ebp -- Count down U plane height
;   ecx -- Count down U plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi UPlane
  sar   ebp,1
   Ledi UOutputPlane

ALIGN 4
ULoopHeader:
  mov   eax,PD [esi+ecx-8]
   mov  edx,PD [esi+ecx-4]
ULoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]
   mov  edx, PD [esi+ecx-4-8]
  sub   ecx, 8
   jg   ULoop

  Lecx  FrameWidth
   add  esi, ebx
  shr   ecx, 1
   add  edi, ebx
  dec   ebp
   jne  ULoopHeader

  add   esp,LocalFrameSize
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

MMX_H26x_YUV12ForEnc endp
ENDIF ;H263P

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\fv_m8.h ===
/*
 *   Project:		LHCODING.DLL  (L&H Speech Coding SDK)  
 *   Workfile:		fv_m8.h     
 *   Author:		Alfred Wiesen 
 *   Created:		13 June 1995    
 *   Last update:	14 February 1996
 *   DLL Version:	1   
 *   Revision:		
 *   Comment:   
 *
 *	(C) Copyright 1993-94 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company cnfidential.
 */

# ifndef __FV_M8_H  /* avoid multiple include */ 

# define __FV_M8_H

/*
 *  Type definition for the L&H functions returned values
 */

typedef DWORD LH_ERRCODE;

typedef struct CodecInfo_tag {
   WORD wPCMBufferSize;
   WORD wCodedBufferSize;
   WORD wBitsPerSamplePCM;
   DWORD dwSampleRate;
   WORD wFormatSubTag;
   char wFormatSubTagName[40];
   DWORD dwDLLVersion;
} CODECINFO, near *PCODECINFO, far *LPCODECINFO;

typedef struct CodecInfoEx_tag {
   WORD		wFormatSubTag;
   char		szFormatSubTagName[80];
   BOOL 	bIsVariableBitRate;
   BOOL 	bIsRealTimeEncoding;
   BOOL 	bIsRealTimeDecoding;
   WORD		wInputDataFormat;
   DWORD 	dwInputSampleRate;
   WORD 	wInputBitsPerSample;
   DWORD 	nAvgBytesPerSec;
   WORD 	wInputBufferSize;
   WORD 	wCodedBufferSize;
   WORD 	wMinimumCodedBufferSize;
   DWORD 	dwDLLVersion;
} CODECINFOEX, near *PCODECINFOEX, far *LPCODECINFOEX;


/*
 *  Possible values for the LH_ERRCODE type
 */

# define LH_SUCCESS (0)    /* everything is OK */
# define LH_EFAILURE (-1)  /* something went wrong */
# define LH_EBADARG (-2)   /* one of the given argument is incorrect */
# define LH_BADHANDLE (-3) /* bad handle passed to function */

/*
 *  Some real types are defined here
 */

# ifdef __cplusplus
	# define LH_PREFIX extern "C"
# else
	# define LH_PREFIX
# endif

# define LH_SUFFIX FAR PASCAL

/*
 *  The function prototypes for 4800 bps, 8000 Hz, Fixed point
 */

LH_PREFIX HANDLE LH_SUFFIX
	LHCELP_FIX488K_Open_Coder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Encode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Close_Coder( HANDLE hAccess);

LH_PREFIX HANDLE LH_SUFFIX
	LHCELP_FIX488K_Open_Decoder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Decode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHCELP_FIX488K_Close_Decoder( HANDLE hAccess);

LH_PREFIX void LH_SUFFIX
	LHCELP_FIX488K_GetCodecInfo(LPCODECINFO lpCodecInfo);

LH_PREFIX void LH_SUFFIX
	LHCELP_FIX488K_GetCodecInfoEx(LPCODECINFOEX lpCodecInfoEx,DWORD cbSize);

# endif  /* avoid multiple include */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\bib_32.h ===
void PassLow8(short *vin,short *vout,short *mem,short nech);
#if 0
// PhilF: The following functions are never called!!!
void PassLow11(short *vin,short *vout,short *mem,short nech);
void PassHigh8(short *mem, short *Vin, short *Vout, short lfen);
void PassHigh11(short *mem, short *Vin, short *Vout, short lfen);
void Down11_8(short *Vin, short *Vout, short *mem);
void Up8_11(short *Vin, short *Vout, short *mem1, short *mem2);
#endif
void QMFilter(short *in,short *coef,short *out_low,short *out_high,short *mem,short lng);
void QMInverse(short *in_low,short *in_high,short *coef,short *out,short *mem,short lng);
void iConvert64To8(short *in, short *out, short N, short *mem);
void iConvert8To64(short *in, short *out, short N, short *mem);
void fenetre(short *src,short *fen,short *dest,short lng);
void autocor(short *vech,long *ri,short nech,short ordre);
short max_autoc(short *vech,short nech,short debut,short fin);
short max_vect(short *vech,short nech);
void upd_max(long *corr_ene,long *vval,short pitch);
short upd_max_d(long *corr_ene,long *vval);
void norm_corrl(long *corr,long *vval);
void norm_corrr(long *corr,long *vval);
void energy(short *vech,long *ene,short lng);
void venergy(short *vech,long *vene,short lng);
void energy2(short *vech,long *ene,short lng);
void upd_ene(long *ener,long *val);
short max_posit(long *vcorr,long *maxval,short pitch,short lvect);
void correlation(short *vech,short *vech2,long *acc,short lng);
void  schur(short *parcor,long *Ri,short netages);
void interpol(short *lsp1,short *lsp2,short *dest,short lng);
void add_sf_vect(short *y1,short *y2,short deb,short lng);
void sub_sf_vect(short *y1,short *y2,short deb,short lng);
void short_to_short(short *src,short *dest,short lng);
void inver_v_int(short *src,short *dest,short lng);
void long_to_long(long *src,long *dest,short lng);
void init_zero(short *src,short lng);
#if 0
// PhilF: The following function is never called!!!
void update_dic(short *y1,short *y2,short hy[],short lng,short i0,short fact);
#endif
void update_ltp(short *y1,short *y2,short hy[],short lng,short gdgrd,short fact);
void proc_gain2(long *corr_ene,long *gain,short bit_garde);
void proc_gain(long *corr_ene,long *gain);
void decode_dic(short *code,short dic,short npuls);
void dsynthesis(long *z,short *coef,short *input,short *output,
						short lng,short netages);
void synthesis(short *z,short *coef,short *input,short *output,
				short lng,short netages,short bdgrd );
void synthese(short *z,short *coef,short *input,short *output,
						short lng,short netages);
void f_inverse(short *z,short *coef,short *input,short *output,
						short lng,short netages );
void filt_iir(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre);
#if 0
// PhilF: The following is never called!!!
void filt_iir_a(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre);
#endif
void mult_fact(short src[],short dest[],short fact,short lng);
void mult_f_acc(short src[],short dest[],short fact,short lng);
void dec_lsp(short *code,short *tablsp,short *nbit,short *bitdi,short *tabdi);
void teta_to_cos(short *tabcos,short *lsp,short netages);
void cos_to_teta(short *tabcos,short *lsp,short netages);
void lsp_to_ai(short *ai_lsp,long *tmp,short netages);
void ki_to_ai(short *ki,long *ai,short netages);
void ai_to_pq(long *aip,short netages);
void horner(long *P,long *T,long *a,short n,short s);
short calcul_s(long a,long b);
void binome(short *lsp,long *PP);
void deacc(short *src,short *dest,short fact,short lfen,short *last_out);
void filt_in(short *mem,short *Vin,short *Vout,short lfen);
short calc_gltp(short *gltp,short *bq,short *bv,long ttt);
short calc_garde(short MAX);
short calc_gopt(short *c,short *code,short *gq,short *gv,short voise,
	short npopt,short pitch,short espopt,short depl,short position,
	short soudecal,long vmax);
void decimation(short *vin,short *vout,short nech);

#ifndef _X86_
#ifdef __cplusplus
extern "C" {
#endif

unsigned int SampleRate6400To8000( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputStreamTime,
                                   int * piOutputStreamTime );

unsigned int SampleRate8000To6400( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputStreamTime,
                                   int * piOutputStreamTime );

int FirFilter( int * piFilterCoefficients,
               int * piFilterDelay,
               unsigned int uiDelayPosition,
               unsigned int uiFilterLength );

_int64 DotProduct( int * piVector_0,
                   int * piVector_1,
                   unsigned int uiLength );
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\data.h ===
/*
 *   Project:		Direct Subband about 13000 bps coder and QUATERDECK 4160 bps decoder (LPC10 based)
 *   Workfile:		data.h
 *   Author:		Georges Zanellato, Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	26 October 1995
 *   DLL Version:	1.00
 *   Revision:
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Constant definitions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
#define Fil_Lenght   8			// QMF filter lenght
#define L_RES       128			// Subband frame lenght
#define N_SB          3			// power(2,N_SB) = Number subband
#define NETAGES      10		// Filter order
#define NECHFEN      220	// Total window length
#define FACTRECO     60		// Overlap length
#define RECS2        30		// Half overlap length
#define NECHDECAL    160	// Input frame size
#define DECAL        160	// Input frame size
#define SOUDECAL1    54 	// First subframe size
#define SOUDECAL     53		// Second and third subframe size
#define LIM_P1       20		// Lowest possible value for PITCH
#define LIM_P2      110		// Highest possible value for PITCH
#define lngEE       148		// Excitation vector length

#include "variable.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Data types definitions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
typedef short VAUTOC [NETAGES+1];
typedef short VEE  [lngEE];
typedef short VSOU  [SOUDECAL1];

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Instance data for coder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
typedef struct C16008Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PC16008DATA or PC4808DATA
    DWORD dwMaxBitRate;
   // Long term
   short zx0_i[2];
   // Long term
   short QMF_MEM_ANAL_I[112];		// Memory of QMF filter during analysis
   short memBP[9];
//   float Zb[5],Za[5];			// long term decimator
//   float mem1[2];
#ifdef _X86_
   short imem1[2];
#else
   int imem1[23];
   unsigned int uiDelayPosition;
   int iInputStreamTime;
   int iOutputStreamTime;
#endif
   long memory[20];

   long nbbit[NBFAC];
   short nbsb_sp;

   short DIV_MAX;     // div. factor for the greatest max of a the sb of a sp frame
   short MAX_LEVEL;   // threshold below which a sb is replaced by white noise
   short NBSB_SP_MAX; // max nbr of sb treated as speech
   short nbbit_cf;    // nber of bits required by the current frame of speech

// PhilF: Since these depend on the bit rate, moved them from global to here...
short quantif[2*NBSB_SP_MAX1_8000_12000]; //={QUANT_LEVELS};
short bits[NBSB_SP_MAX1_8000_12000]; //={CODING_BITS};

short codes_max[8];	// Quantized max. of each subband
long codes_sb[16];	// Two codes for each of the quantified subbands
short indic_sp[8];	// type of subband (0=noise; 1=speech)
short DATA_I[512];                  	// Intermediate vector = input and output of QMF
char stream[MAX_OUTPUT_BYTES_16000];

} C16008DATA, *PC16008DATA;

#ifdef CELP4800
typedef struct C4808Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PC16008DATA or PC4808DATA
    DWORD dwMaxBitRate;
   long DMSY[13];				// Synthesis memory filter
   short   MINV[13];				// Filter memory
   short  SIG[NECHFEN+SOUDECAL],M_PIT[160];	// Computation signal vectors
   VSOU	E,E_PE;					// Excitation vectors
   VEE 	EE;					// Excitation vector
   short mem2[2];					// Input filter memory
   short mem_pit[2];				// Pitch memory
   short LSP0[10];				// LSP memory

short 	SIG_CALP[380];	// RAM
short 	UNVOIS,PITCH,SOULONG;	// RAM
long  	a,b;	// RAM
short 	ialf;
long  	TLSP[24],VMAX[9];	// RAM
long  	veci1[10],veci2[10],veci3[10];	// RAM
long  	ttt[11];				// RAM
short 	SIGPI[2*NECHDECAL+FACTRECO];	// RAM
short 	zz[12];
VAUTOC  A1,A2,A3,Aw,LSP;	// RAM
VSOU	H;			// RAM
short  	GLTP;		// RAM
short 	code[22];		// RAM
short 	output_frame[6];
short 	depl;
short 	*ptr1;		// RAM

} C4808DATA, *PC4808DATA, *LPC4808DATA;
#endif

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Instance data for decoder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
typedef struct D16008Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PD16008DATA or PD4808DATA
    DWORD dwMaxBitRate;
   long memfil[20];
   short QMF_MEM_SYNT_I[112];          // Memory of QMF filter during synthesis
//   float mem2[2];
#ifdef _X86_
   short imem2[2];
#else
   int imem2[56];
   unsigned int uiDelayPosition;
   int iInputStreamTime;
   int iOutputStreamTime;
#endif

   short out_mem[4];
   short out_mem2[20];
   long memory[20];
   short mem1,mem2;

// PhilF: Since these depend on the bit rate, moved them from global to here...
short quantif[2*NBSB_SP_MAX1_8000_12000]; //={QUANT_LEVELS};
short bits[NBSB_SP_MAX1_8000_12000]; //={CODING_BITS}; 
long lRand;

short synth_speech[224];
short d_codes_max[8];	// Quantified max. of each subband
long d_codes_sb[16];	// Two codes for each of the quantified subbands
short d_indic_sp[8];	// type of subband (0=noise; 1=speech)
short d_DATA_I[512];                  	// Intermediate vector = input and output of QMF
char d_stream[MAX_OUTPUT_BYTES_16000];
short d_num_bandes;

} D16008DATA, *PD16008DATA;

#ifdef CELP4800
typedef struct D4808Data_Tag
{
    // PhilF: This field needs to be at the top so that it can be accessed
    // by casting to PD16008DATA or PD4808DATA
    DWORD dwMaxBitRate;
   long memfil[32]; 	// Synthesis filter memory
   short  MSYNTH[13];	// Filter memory
   VSOU E;		// Excitation vector
   VEE	EE,EEE;		// Excitation vectors
   short LSP0[10];	// LSP memory

short PITCH,SOULONG;	// RAM
long  TLSP[24];		// RAM
VAUTOC  A1,A2,A3,LSP;	// RAM
short  GLTP;
short ss[DECAL];	// RAM
short code[22];		// RAM
short frame[6];		// RAM
short depl;		// RAM

} D4808DATA, *PD4808DATA, *LPD4808DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\decoder.c ===
/*#define __TEST
#ifdef __TEST
#include <stdio.h>
FILE *d_codage;
FILE *d_test;
#endif*/

/*
 *   Project:		Direct Subband 16000 bps coder
 *   Workfile:		sb_encod.c
 *   Author:		Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	4 September 1995
 *   DLL Version:	1.00
 *   Revision:          Single DLL for coder and decoder.
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Included files
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
#include <math.h>
#include <windows.h>
#include <windowsx.h>

//#define USE_CRT_RAND 1

#ifdef USE_CRT_RAND
#include <stdlib.h>	// for rand() function
#endif

#include "fv_x8.h"
#include "data.h"
#include "bib_32.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function prototypes
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
//------------------------------------------------------------------------
void InitializeDecoderInstanceData(PVOID p, DWORD dwMaxBitRate);
void interpolation_I(short low_input[],short coef[],short low_part_mem[],short order);
void bruit_I(PD16008DATA p, short vec[],short max, short deb ,short fin);
#if 0
// PhilF: The following is never called!!!
void dec_0a16_I2(short z1, short z2, short vec[], short maxv, short V1[], short V2[],long *code);
#endif
void dec_sous_bandes(PD16008DATA p,short *out,short *codes_max, long *codes_sb, short *indic_br/*, short *code_max_br*/);
#if 0
// PhilF: The following is not defined anywhere!!!
void decodeframe(short codes_max[],long codes_sb[],short d_indic_sp[],char stream[]);
#endif

#ifdef CELP4800
void demux(PD4808DATA p);
void decode_ai(PD4808DATA p);
void dec_ltp(PD4808DATA p,short no),dec_dic(PD4808DATA p);
void post_synt(PD4808DATA p),post_filt(PD4808DATA p,short no);
#endif

/*void iConvert64To8(short *in, short *out, short N, short *mem);
void iConvert8To64(short *in, short *out, short N, short *mem);
void filt_in(short *mem, short *Vin, short *Vout, short lfen);
//void PassHigh(short *vin,short *vout,short *mem,short nech);
void BandPass(short *,short *,short *,short);*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Global variables for decoder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

/*#define MAXDECODINGHANDLES 10

// Instance data structure
PD16008DATA pDecoderData;
D16008DATA DecoderData[MAXDECODINGHANDLES];
short brol[300];
short DecodingHandles[MAXDECODINGHANDLES];*/

// ROM tables :
//extern long coef_outfil[];
extern short coef_I[];	// QMF filter coefficients
extern short V3_I[];
extern short V4_I[];
extern short V5_I[];
extern short V6_I[];
extern short V7_I[];
extern short V8_I[];
extern short V9_I[];
extern short d_max_level[];  // Quantified maximum sample level
extern long coeffs[];
extern short quantif[];
extern long Mask[];
extern short tabcos[];
extern short LSP_Q[];
extern short TAB_DI[];
extern short GV[];
extern short BV[];
extern long coef_i[];
extern short NBB[],BITDD[];
extern short LSP0ROM[];
//extern short bytes[];
//extern short bits[];

// RAM variables
/*extern char d_stream[];
extern short synth_speech[];
extern short d_DATA_I[];                  // Intermediate vector = input and output of QMF
extern short d_codes_max[];
extern long d_codes_sb[];
extern short d_indic_sp[];
extern short d_num_bandes;
//extern float d_vect6[256], d_vect8[256];*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function implementation
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
void InitializeDecoderInstanceData(PVOID p, DWORD dwMaxBitRate)
// Instance data initializations
{
  short i;

#ifdef CELP4800
  if (dwMaxBitRate == 4800)
    {
    ((PD4808DATA)p)->dwMaxBitRate = dwMaxBitRate;

    for (i=0;i<10;i++)
      ((PD4808DATA)p)->LSP0[i]=LSP0ROM[i];
    }
  else
#endif
    {
    ((PD16008DATA)p)->dwMaxBitRate = dwMaxBitRate;
    ((PD16008DATA)p)->lRand = 1L;

    ((PD16008DATA)p)->quantif[0] = 9;
    ((PD16008DATA)p)->quantif[1] = 9;
    ((PD16008DATA)p)->quantif[4] = 5;
    ((PD16008DATA)p)->quantif[5] = 5;
    ((PD16008DATA)p)->quantif[6] = 5;
    ((PD16008DATA)p)->quantif[7] = 5;
    ((PD16008DATA)p)->quantif[8] = 5;
    ((PD16008DATA)p)->quantif[9] = 5;
    ((PD16008DATA)p)->bits[0] = 52;
    ((PD16008DATA)p)->bits[2] = 38;
    ((PD16008DATA)p)->bits[3] = 38;
    ((PD16008DATA)p)->bits[4] = 38;
    if (dwMaxBitRate == 16000)
      {
      ((PD16008DATA)p)->quantif[2] = 7;
      ((PD16008DATA)p)->quantif[3] = 7;
      ((PD16008DATA)p)->bits[1] = 46;
      }
    else
      {
      ((PD16008DATA)p)->quantif[2] = 9;
      ((PD16008DATA)p)->quantif[3] = 9;
      ((PD16008DATA)p)->quantif[10] = 5;
      ((PD16008DATA)p)->quantif[11] = 5;
      ((PD16008DATA)p)->bits[1] = 52;
      ((PD16008DATA)p)->bits[5] = 38;
      }
    }
   return;
}

//------------------------------------------------------------------------
void interpolation_I(short low_input[],short coef[],short low_part_mem[],short order)
// Purpose : from subbands stored in low_input[], create the corresponding signal
// Remark  : The reconstruct signal is stored at *(input+N_SB*L_RES)
{
   short *output;
   short *high_input;
   short *buffer,*sa_vec;
   short lng,j,i;

   buffer = low_part_mem;
   for (i = 7-N_SB; i<7; i++)
	{
	lng = 1<<i;
	high_input=low_input+lng;
	output=low_input+L_RES;
	sa_vec=output;
	for (j = L_RES >> (i+1); j>0; j--)
		{
		low_part_mem=buffer;

		QMInverse(low_input,high_input,coef,output,low_part_mem,lng);

		output += 2*lng; low_input += lng; high_input += lng;

		if (j&1) high_input += 2*lng;
		else low_input += 2*lng;

		buffer += 2*order;
		}
	low_input=sa_vec;
	}
}

//------------------------------------------------------------------------
void bruit_I(PD16008DATA p, short vec[],short max, short deb ,short fin)
// rand() generates integers from 1 to RAND_MAX (32767)
{
   short i;

   for (i=deb;i<fin;i++)
     {
#ifdef USE_CRT_RAND
     *vec++ =  (short)(((long)max*(long)(rand()-16384))>>15);
#else
    // We provide our own rand() function in order
    // to go away from libcmt, msvcrt...
    p->lRand = p->lRand * 214013L + 2531011L;
     *vec++ =  (short)(((long)max*(long)((long)((p->lRand >> 16) & 0x7fff)-16384))>>15);
#endif
}    }

/*void bruit_I(int vec[],int max, int deb ,int fin)
{
   int i;
   for (i=deb;i<fin;i++) *vec++ = (int)(((long)max*(long)(rand()-16384))>>15);
}*/

//------------------------------------------------------------------------
// PhilF: The following is never called!!!
#if 0
void dec_0a16_I2(short z1, short z2, short vec[], short maxv, short V1[], short V2[],long *code)

// Decodes two long codes to retreive the z level quantified subband

{
//   short vect1[16];
   short i,x;
   long result;
//   long lp1,lp2;

   result=*(code+1);
   for (i=15;i>=8;i--)	// Decodes the 8 last samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }

   result=*(code);
   for (i=7;i>=0;i--)	// Decodes the 8 first samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }
}
#endif

void dec_0a16_I3(short z1, short z2, short vec[], short maxv, long *code)

// Decodes two long codes to retreive the z level quantified subband

{
//   short vect1[16];
   short i,x;
   long result;
   short *V1,*V2;
//   long lp1,lp2;

   switch (z1)
   {
      case 3: V1=V3_I; break;
      case 4: V1=V4_I; break;
      case 5: V1=V5_I; break;
      case 6: V1=V6_I; break;
      case 7: V1=V7_I; break;
      case 8: V1=V8_I; break;
      case 9: V1=V9_I; break;
   }
   switch (z2)
   {
      case 3: V2=V3_I; break;
      case 4: V2=V4_I; break;
      case 5: V2=V5_I; break;
      case 6: V2=V6_I; break;
      case 7: V2=V7_I; break;
      case 8: V2=V8_I; break;
      case 9: V2=V9_I; break;
   }

  result=*(code+1);
  if (z1 && z2)
  {
   for (i=15;i>=8;i--)	// Decodes the 8 last samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }

   result=*(code);
   for (i=7;i>=0;i--)	// Decodes the 8 first samples of the subband
     {
     if (i==2*(short)(i/2))
       {
       x=result%z1;
       result-=x;
       result/=z1;
       *(vec+i)=(short)(((long)V1[x]*(long)maxv)>>13);
       }
     else
       {
       x=result%z2;
       result-=x;
       result/=z2;
       *(vec+i)=(short)(((long)V2[x]*(long)maxv)>>13);
       }
     }
  }
}

//------------------------------------------------------------------------

void dec_sous_bandes(PD16008DATA p,short *out,short *codes_max, long *codes_sb, short *d_indic_sp)

// Decodes the 8 subbands

{
   short max[8]={0,0,0,0,0,0,0,0};
   short max_loc[8]={0,0,0,0,0,0,0,0};
   short order[8]={0,0,0,0,0,0,0,0};
   short maximum,max_num;
   short i,j,nbsb_sp,ord;

  #ifdef MAX_SB_ABSOLU
   short sb_count;
  #endif


   for (i=0;i<8;i++)	// Decodes the maximums
     {
     max_loc[i]=2*d_max_level[codes_max[i]];
     }
   nbsb_sp=0;
   j=0;
   for (i=0;i<8;i++)
     {
     if (d_indic_sp[i]==1)
       {
       max[i]=max_loc[j];
       nbsb_sp++;
       j++;
       }
     }

  if (p->dwMaxBitRate == 16000)
    {
   j=0;

  #ifdef MAX_SB_ABSOLU
   sb_count=nbsb_sp;
   if (sb_count>=MAX_SB_ABSOLU) return;
  #endif

   for (i=0;i<8;i++)
   {
     if (d_indic_sp[i]==0)
     {
       max[i]=max_loc[nbsb_sp+j];
       j++;
      #ifdef MAX_SB_ABSOLU
       sb_count++;
       quant_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,in+i*16,max[i],codes_sb+2*sb_count);
       if (sb_count>=MAX_SB_ABSOLU) break;
      #endif
     }
   }
    }

   ord=8;
   for (i=0;i<8;i++)	// Calculates the order of the subbands
     {                  // 1 is higher energy than 2 than 3,..
     maximum=32767;
     for (j=7;j>=0;j--)
       {
       if ((order[j]==0)&&(max[j]<maximum))
	 {
	 max_num=j; maximum=max[j];
	 }
       }
     order[max_num]=ord;
     ord--;
     }


  if (p->dwMaxBitRate == 16000)
    {
   // On gnre les sous-bandes
   for (i=7;i>=nbsb_sp;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     dec_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,out+j*16,max[j],codes_sb+2*i);
     }
    }
   else
    {
   // On gnre du bruit
   if (nbsb_sp==0) maximum=20; // qd on ne doit generer que du bruit
   else
     {
     maximum=32767;
     for (i=0;i<nbsb_sp;i++) if (max_loc[i]<maximum) maximum=max_loc[i];
     maximum>>=2;   // le 64eme du plus petit max transmis
     }

   //en fait il faudrait diminuer le bruit avec l'ordre

   for (i=0;i<8;i++)              // Replaces the less energetic subbands
     {			          // with white noise
     if (d_indic_sp[i]==0)
       {
       maximum/=order[i];
       bruit_I(p,out+i*16,maximum,0,16);
       }
     }
   }

   for (i=nbsb_sp-1;i>=0;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     dec_0a16_I3(p->quantif[2*i],p->quantif[2*i+1],out+j*16,max[j],codes_sb+2*i);
     }

}

//------------------------------------------------------------------------
short Demultiplexing(
	char *Stream,
	long *Codes,
	short *CodeSizes,
	short NumCodes,
	short StreamSize)
{
   short B,P;	// B=bits  coder, P=bits disponibles
   short i,j;

   #ifdef __CHECK_FORMAT
   long TotalBytes=0;

   for (i=0;i<NumCodes;i++) TotalBytes+=CodeSizes[i];
   if (TotalBytes>StreamSize*8) return 1;
   #endif

   i=0;
   j=0;
   B=CodeSizes[i];	// bits  coder
   P=8;			// 1 octet libre au dpart
   Codes[i]=0;
   while (i<NumCodes)
   {
      if (P>B)
      {
	 Codes[i]|=(Stream[j]>>(P-B))&Mask[B];
	 P-=B;
	 i++;
	 if (i<NumCodes)
	 {
	    B=CodeSizes[i];
	    Codes[i]=0;
	 }
      }
      else if (P<B)
      {
	 Codes[i]|=(Stream[j]&Mask[P])<<(B-P);
	 B-=P;
	 P=8;
	 j++;
      }
      else
      {
	 Codes[i]|=Stream[j]&Mask[P];
	 i++;
	 j++;
	 P=8;
	 if (i<NumCodes)
	 {
	    B=CodeSizes[i];
	    Codes[i]=0;
	 }
      }
   }
   return 0;
}

// ------------------------------------------------------------------------
#ifdef CELP4800
void decode_ai(PD4808DATA p)
{
   short_to_short(p->code,p->LSP,10);
   p->LSP[10]=32767;
   dec_lsp(p->LSP,LSP_Q,NBB,BITDD,TAB_DI);

   short_to_short(p->LSP,p->A3,10);
   teta_to_cos(tabcos,p->A3,10);
   lsp_to_ai(p->A3,p->TLSP,10);

   interpol(p->LSP0,p->LSP,p->A1,NETAGES);
   teta_to_cos(tabcos,p->A1,10);
   lsp_to_ai(p->A1,p->TLSP,10);

   interpol(p->LSP,p->LSP0,p->A2,NETAGES);
   teta_to_cos(tabcos,p->A2,10);
   lsp_to_ai(p->A2,p->TLSP,10);

   short_to_short(p->LSP,p->LSP0,NETAGES);
}

// ------------------------------------------------------------------------
void dec_ltp(PD4808DATA p,short no)
{
   short k;

   switch (no)
   {
   case 0:
      break;
   case 1:
      short_to_short(p->A2,p->A1,11);
      break;
   case 2:
      short_to_short(p->A3,p->A1,11);
      break;
   }


   p->PITCH=p->code[10+p->depl];
   k=p->code[11+p->depl];
   if (k<10) p->GLTP = BV[k+1]; /* les BV sont multiplies par 16384 */
   else p->GLTP = -BV[k-9];

   if (p->PITCH<p->SOULONG)
   {
      short_to_short(p->EE+lngEE-p->PITCH,p->E,p->PITCH);
      short_to_short(p->E,p->E+p->PITCH,(short)(p->SOULONG-p->PITCH));
      mult_fact(p->E,p->E,p->GLTP,p->SOULONG);
   }
   else
   {
      mult_fact(p->EE+lngEE-p->PITCH,p->E,p->GLTP,p->SOULONG);
   }
}

// ------------------------------------------------------------------------
void dec_dic(PD4808DATA p)
{
   short i,esp_opt,j,position,npopt,phas_opt,cod;
   short c[10];
   short Gopt;

   cod=p->code[13+p->depl];
   if (cod<16) Gopt=GV[cod+1];
   else Gopt=-GV[cod-15];

   cod=p->code[12+p->depl];

   if (cod<54) { position=cod; esp_opt=p->PITCH; }
   else
   {
      if (cod<64)
      {
	 position=cod-54;
	 if (p->PITCH<p->SOULONG) esp_opt=p->SOULONG+5;
	 else if (p->PITCH/2<p->SOULONG) esp_opt=p->PITCH/2;
	    else esp_opt=p->PITCH/3;
      }
      else
      {
	 if (cod<128)
	 {
	    npopt=7;
	    phas_opt=3;
	    esp_opt=8;
	    i=cod-64;
	    c[0]=1;
	    decode_dic(c,i,npopt);
	 }
	 else
	 {
	    npopt=8;
	    phas_opt=0;
	    esp_opt=7;
	    i=cod-128;
	    c[0]=1;
	    decode_dic(c,i,npopt);
	 }
      }
   }

   if (cod<64)
   {
      i=0;
      do
      {
	 p->E[position+i] += Gopt;
	 i += esp_opt;
      }
      while ((position+i)<p->SOULONG);
   }
   else
      for (j=0;j<npopt;j++)
	 p->E[esp_opt*j+phas_opt] += c[j]*Gopt;

   short_to_short(p->EE+p->SOULONG,p->EE,(short)(lngEE - p->SOULONG));
   short_to_short(p->E,p->EE+lngEE-p->SOULONG,p->SOULONG);
}

// ------------------------------------------------------------------------
void post_synt(PD4808DATA p)
{
   short GPREF;

   if (abs(p->GLTP)<8192) GPREF = (long)p->GLTP*(long)35/100;
   if (p->GLTP>=8192)  GPREF=2867;
   if (p->GLTP<=-8192) GPREF=-2867;

   if (p->PITCH>=p->SOULONG) mult_f_acc(p->EEE+lngEE-p->PITCH,p->E,GPREF,p->SOULONG);
   else
   {
      mult_f_acc(p->EEE+lngEE-p->PITCH,p->E,GPREF,p->PITCH);
      mult_f_acc(p->E,p->E+p->PITCH,GPREF,(short)(p->SOULONG-p->PITCH));
   }

   short_to_short(p->EEE+p->SOULONG,p->EEE,(short)(lngEE-p->SOULONG));
   short_to_short(p->E,p->EEE+lngEE-p->SOULONG,p->SOULONG);

   synthese(p->MSYNTH,p->A1,p->E,p->E,p->SOULONG,NETAGES);
}

// ------------------------------------------------------------------------
void post_filt(PD4808DATA p,short no)
{
   short i0;

   switch (no)
   {
   case 0: i0=0;
	   break;
   case 1: i0=SOUDECAL1;
	   break;
   case 2: i0=SOUDECAL1+SOUDECAL;
	   break;
   }
   filt_iir(p->memfil,coef_i,p->E,p->ss+i0,p->SOULONG,4);
}

// ------------------------------------------------------------------------
void demux(PD4808DATA p)
// Purpose : deconcatenate the input stream
// Input parameter  :
//          input_stream[]  :  input stream
//  Output parameter :
//          code[]   :  separate parameter code
//
//  Comments: The LTP or Adaptive codebook is also called PITCH.
//
//  Stream format :
//  input_stream[0] = LSP[0] | LSP[1] | LSP[2] | (Binary gain 2)
//  input_stream[1] = LSP[3] | (Binary gain 3) | (Binary codebook 1)
//  input_stream[2] = LSP[4] | LSP[5] | LSP[6] | LSP[7] | LSP[8] | LSP[9]
//  input_stream[3] = (LTP codebook 1) | (LTP gain 1) | (Binary gain 1)
//  input_stream[4] = (LTP codebook 2) | (LTP gain 2) | (Binary codebook 2)
//  input_stream[5] = (LTP codebook 3) | (LTP gain 3) | (Binary codebook 3)
//
//  Bit allocation : Codebook or gain "i" is the codebook for subframe "i".
//  code[0] = LSP(0) : 3bits     code[10] = LTP codebook 1    : 7bits
//  code[1] = LSP(1) : 4bits     code[11] = LTP gain 1        : 4bits
//  code[2] = LSP(2) : 4bits     code[12] = Binary codebook 1 : 8bits
//  code[3] = LSP(3) : 3bits     code[13] = Binary gain 1     : 5bits
//  code[4] = LSP(4) : 4bits     code[14] = LTP codebook 2    : 4bits
//  code[5] = LSP(5) : 3bits     code[15] = LTP gain 2        : 4bits
//  code[6] = LSP(6) : 3bits     code[16] = Binary codebook 2 : 8bits
//  code[7] = LSP(7) : 2bits     code[17] = Binary gain 2     : 5bits
//  code[8] = LSP(8) : 3bits     code[18] = LTP codebook 3    : 4bits
//  code[9] = LSP(9) : 1bits     code[19] = LTP gain 3        : 4bits
//                               code[20] = Binary codebook 3 : 8bits
//                               code[21] = Binary gain 3     : 5bits
//
{
   p->code[0] = (p->frame[0]>>13) & 0x0007;
   p->code[1] = (p->frame[0]>>9) & 0x000f;
   p->code[2] = (p->frame[0]>>5) & 0x000f;
   p->code[17] = p->frame[0] & 0x001f;

   p->code[3] = (p->frame[1]>>13) & 0x0007;
   p->code[21] = (p->frame[1]>>8) & 0x001f;
   p->code[12] = p->frame[1] & 0x00ff;

   p->code[4] = (p->frame[2]>>12) & 0x000f;
   p->code[5] = (p->frame[2]>>9) & 0x0007;
   p->code[6] = (p->frame[2]>>6) & 0x0007;
   p->code[7] = (p->frame[2]>>4) & 0x0003;
   p->code[8] = (p->frame[2]>>1) & 0x0007;
   p->code[9] = p->frame[2] & 0x0001;

   p->code[10] = (p->frame[3]>>9) & 0x007f;
   p->code[11] = (p->frame[3]>>5) & 0x000f;
   p->code[13] = p->frame[3] & 0x001f;

   p->code[14] = (p->frame[4]>>12) & 0x000f;
   p->code[15] = (p->frame[4]>>8) & 0x000f;
   p->code[16] = p->frame[4] & 0x00ff;

   p->code[18] = (p->frame[5]>>12) & 0x000f;
   p->code[19] = (p->frame[5]>>8) & 0x000f;
   p->code[20] = p->frame[5] & 0x00ff;

   p->code[10] += LIM_P1;
   p->code[14] = p->code[14]+p->code[10]-7;
   p->code[18] = p->code[18]+p->code[14]-7;

}
#endif

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// DLL entry points
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Decoder(DWORD dwMaxBitRate)
{
   PVOID pDecoderData;
   /*short i,flag=0;

   // Test if there are free handles
   for (i=0;i<MAXDECODINGHANDLES;i++)
      if (DecodingHandles[i]==0) {DecodingHandles[i]=1; flag=1; break;}
   if (flag==0) return 0;
   pDecoderData=&DecoderData[i];*/

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (dwMaxBitRate != 4800) && 
#endif
	  (dwMaxBitRate != 8000) && 
	  (dwMaxBitRate != 12000) && 
	  (dwMaxBitRate != 16000))
      return (HANDLE)0;

   // pDecoderData=(PVOID)GlobalAllocPtr(GMEM_MOVEABLE, dwMaxBitRate == 4800 ? sizeof(D4808DATA) : sizeof(D16008DATA));
#ifdef CELP4800
   pDecoderData=(PVOID)GlobalAllocPtr(GHND, dwMaxBitRate == 4800 ? sizeof(D4808DATA) : sizeof(D16008DATA));
#else
   pDecoderData=(PVOID)GlobalAllocPtr(GHND, sizeof(D16008DATA));
#endif
   if (pDecoderData==NULL)
      return (HANDLE)0;

   InitializeDecoderInstanceData(pDecoderData, dwMaxBitRate);

   #ifdef __TEST
   d_codage=(FILE*)fopen("codage.dat","rb");
   d_test=(FILE*)fopen("codes_dec.dat","wt");
   #endif

   return((HANDLE)pDecoderData);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Decode(
   HANDLE hAccess,
   LPBYTE lpSrcBuf,
   LPWORD lpSrcBufSize,
   LPBYTE lpDstBuf,
   LPWORD lpDstBufSize)
{
    short i,iOutputSize,flag=0;
    char  *input;
    char  *int_ptr;
    unsigned short  *ptr1;
    unsigned short  *ptr3;
    long interm;

    short codesizes[24];
    long codes[24];
    short numcodes,temp;
    short bits_count;

	PVOID pDecoderData;

    if ((!hAccess) || (!lpSrcBuf) || (!lpDstBuf))
      return LH_EBADARG;

    /*// First check that the handle provided as argument is correct
    for (i=0;i<MAXDECODINGHANDLES;i++)
       if ((DecodingHandles[i]==1)&&(hAccess==(HANDLE)&DecoderData[i])) {flag=1; break;}
    if (flag==0) return LH_BADHANDLE;*/

    pDecoderData=(PVOID)hAccess;

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (((PD4808DATA)pDecoderData)->dwMaxBitRate != 4800) && 
#endif
	  (((PD16008DATA)pDecoderData)->dwMaxBitRate != 8000) && 
	  (((PD16008DATA)pDecoderData)->dwMaxBitRate != 12000) && 
	  (((PD16008DATA)pDecoderData)->dwMaxBitRate != 16000))
    return (LH_ERRCODE)LH_EBADARG;

#ifdef CELP4800
  if ((((PD4808DATA)pDecoderData)->dwMaxBitRate == 4800))
    {
    // then check the buffer sizes passed as argument.
    if ((*lpDstBufSize<2*NECHDECAL)||(*lpSrcBufSize<12))
      return (LH_ERRCODE)LH_EBADARG;
    *lpDstBufSize=2*NECHDECAL;
    *lpSrcBufSize=12;

    ptr1 = (unsigned short *)lpSrcBuf;
    ptr3 = (unsigned short *)&(((PD4808DATA)pDecoderData)->frame);

    for (i=6 ; i>0 ; i--) *ptr3++ = *ptr1++;

    demux(((PD4808DATA)pDecoderData));

    decode_ai(((PD4808DATA)pDecoderData));

    for (i=0;i<3;i++)
	     {
	     if (i==0) ((PD4808DATA)pDecoderData)->SOULONG=SOUDECAL1;
	     else ((PD4808DATA)pDecoderData)->SOULONG=SOUDECAL;
	     ((PD4808DATA)pDecoderData)->depl=4*i;
	     dec_ltp((PD4808DATA)pDecoderData,i);
	     dec_dic((PD4808DATA)pDecoderData);
	     post_synt((PD4808DATA)pDecoderData);
	     post_filt((PD4808DATA)pDecoderData,i);
	     }

    ptr3 = (unsigned short *)&(((PD4808DATA)pDecoderData)->ss);
    ptr1 = (unsigned short *)lpDstBuf;

    for (i =160; i>0;i--) *ptr1++ = *ptr3++;
    }
  else
#endif
    {
    // then check the buffer sizes passed as argument.
    switch (((PD16008DATA)pDecoderData)->dwMaxBitRate)
      {
      case 8000:
        if ((*lpSrcBufSize<1)||(*lpDstBufSize<2*160))
           return (LH_ERRCODE)LH_EBADARG;
        *lpDstBufSize=2*160;
        break;
      case 12000:
      case 16000:
        if ((*lpSrcBufSize<1)||(*lpDstBufSize<2*128))
           return (LH_ERRCODE)LH_EBADARG;
        *lpDstBufSize=2*128;
        break;
      }
    input = (char  *)lpSrcBuf;
    int_ptr=(char  *)(((PD16008DATA)pDecoderData)->d_stream);

    /*for (i=0;i<26;i++)
       *int_ptr++=*input++;*/

    *int_ptr++=*input++;	// read d_stream[0]

    for (i=0;i<8;i++)
       ((PD16008DATA)pDecoderData)->d_indic_sp[i]=(short)((((PD16008DATA)pDecoderData)->d_stream[0]>>i)&0x01);

    ((PD16008DATA)pDecoderData)->d_num_bandes=0;
    for (i=0;i<8;i++)
      if (((PD16008DATA)pDecoderData)->d_indic_sp[i]==1)
	     ((PD16008DATA)pDecoderData)->d_num_bandes++;


    bits_count=8;
    for (i=0;i<((PD16008DATA)pDecoderData)->d_num_bandes;i++)
       bits_count+=5+((PD16008DATA)pDecoderData)->bits[i];

  if (((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000)
    {
    #ifdef MAX_SB_ABSOLU
    for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<MAX_SB_ABSOLU;i++)
    #else
    for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<8;i++)
    #endif
       bits_count+=5+SILENCE_CODING_BIT_16000;
    }         

    //temp=bytes[d_num_bandes]; //9
#if 0
    temp=(short)((float)bits_count/8.0+0.99);
#else
    // We want to go away of libcmt, msvcrt... and
    // floating point is not really essential here...
    if (bits_count)
      temp=(short)((bits_count-1)/8+1);
    else
      temp=0;
#endif

    if (*lpSrcBufSize<temp)
       return (LH_ERRCODE)LH_EBADARG;

    if ((((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000) || ((((PD16008DATA)pDecoderData)->dwMaxBitRate == 8000) && (((PD16008DATA)pDecoderData)->d_num_bandes)) || ((((PD16008DATA)pDecoderData)->dwMaxBitRate == 12000) && (((PD16008DATA)pDecoderData)->d_num_bandes)))
    {
       for (i=0;i<temp-1;i++)		// read 8 last bytes
	  *int_ptr++=*input++;

       numcodes=0;
       for (i=0;i<24;i++) codesizes[i]=0;
       for (i=0;i<((PD16008DATA)pDecoderData)->d_num_bandes;i++)
       {
	  codesizes[i]=5;
	  codesizes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i]=((PD16008DATA)pDecoderData)->bits[i]/2;
	  codesizes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i+1]=((PD16008DATA)pDecoderData)->bits[i]/2;
	  numcodes+=3;
       }
  if (((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000)
    {
       for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<8;i++)
       {
	  codesizes[2*((PD16008DATA)pDecoderData)->d_num_bandes+i]=5;
	  codesizes[8+2*i]=SILENCE_CODING_BIT_16000/2;
	  codesizes[8+2*i+1]=SILENCE_CODING_BIT_16000/2;
	  numcodes+=3;
       }
    }

       if (Demultiplexing(((PD16008DATA)pDecoderData)->d_stream+1,codes,codesizes,numcodes,(short)(temp-1)))
	  return (LH_ERRCODE)LH_BADHANDLE;

       for (i=0;i<((PD16008DATA)pDecoderData)->d_num_bandes;i++)
       {
	  ((PD16008DATA)pDecoderData)->d_codes_max[i]=(short)codes[i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i]=codes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i+1]=codes[((PD16008DATA)pDecoderData)->d_num_bandes+2*i+1];
       }
    if (((PD16008DATA)pDecoderData)->dwMaxBitRate == 16000)
      {
      #ifdef MAX_SB_ABSOLU
       for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<MAX_SB_ABSOLU;i++)
      #else
       for (i=((PD16008DATA)pDecoderData)->d_num_bandes;i<8;i++)
      #endif
       {
	  ((PD16008DATA)pDecoderData)->d_codes_max[i]=(short)codes[2*((PD16008DATA)pDecoderData)->d_num_bandes+i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i]=codes[8+2*i];
	  ((PD16008DATA)pDecoderData)->d_codes_sb[2*i+1]=codes[8+2*i+1];
       }
       }
    }
    *lpSrcBufSize=temp;

    dec_sous_bandes(((PD16008DATA)pDecoderData),((PD16008DATA)pDecoderData)->d_DATA_I,((PD16008DATA)pDecoderData)->d_codes_max,((PD16008DATA)pDecoderData)->d_codes_sb,((PD16008DATA)pDecoderData)->d_indic_sp);
    interpolation_I(((PD16008DATA)pDecoderData)->d_DATA_I,coef_I,((PD16008DATA)pDecoderData)->QMF_MEM_SYNT_I,Fil_Lenght);

    for (i=0;i<128;i++) ((PD16008DATA)pDecoderData)->d_DATA_I[3*L_RES+i]*=8; //TEST 16; // Because input divided before coding

    switch (((PD16008DATA)pDecoderData)->dwMaxBitRate)
      {
      case 8000:
        iOutputSize = 160;
#ifdef _X86_
        iConvert64To8(((PD16008DATA)pDecoderData)->d_DATA_I+3*L_RES, ((PD16008DATA)pDecoderData)->synth_speech, 128, ((PD16008DATA)pDecoderData)->imem2);
        PassLow8(((PD16008DATA)pDecoderData)->synth_speech, ((PD16008DATA)pDecoderData)->synth_speech,((PD16008DATA)pDecoderData)->out_mem2,160);
#else
        SampleRate6400To8000(((PD16008DATA)pDecoderData)->d_DATA_I+3*L_RES,
                             ((PD16008DATA)pDecoderData)->synth_speech,
                             128,
                             ((PD16008DATA)pDecoderData)->imem2,
                             &((PD16008DATA)pDecoderData)->uiDelayPosition,
                             &((PD16008DATA)pDecoderData)->iInputStreamTime,
                             &((PD16008DATA)pDecoderData)->iOutputStreamTime );
#endif
        break;
      case 12000:
      case 16000:
        iOutputSize = 128;
        for (i=0;i<128;i++)
          ((PD16008DATA)pDecoderData)->synth_speech[i]=((PD16008DATA)pDecoderData)->d_DATA_I[3*L_RES+i];
        break;
      }

    for (i=0;i<iOutputSize;i++)
    {
       interm=((long)((PD16008DATA)pDecoderData)->synth_speech[i] * 2L);//VERS 4 + ( ((long)(rand()-16384))>>8 ) ;
       if (interm>32700L) interm=32700L;
       if (interm<-32700L) interm=-32700L;
       ((PD16008DATA)pDecoderData)->synth_speech[i] = (short)interm ;
    }

    ptr3 = (unsigned short  *)&(((PD16008DATA)pDecoderData)->synth_speech);
    ptr1 = (unsigned short  *)lpDstBuf;

    for (i =0;i<iOutputSize;i++) ptr1[i] = ptr3[i];
    }
    return (LH_SUCCESS);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Decoder(HANDLE hAccess)
{
   PVOID pDecoderData;

   /*short i,flag=0;

   // Check if right handle
   for (i=0;i<MAXDECODINGHANDLES;i++)
      if ((DecodingHandles[i]==1)&&(hAccess==(HANDLE)&DecoderData[i])) {flag=1; break;}
   if (flag==0) return LH_BADHANDLE;
   // Free handle
   DecodingHandles[i]=0;*/

  if (!hAccess)
    return LH_EBADARG;

   pDecoderData=(PVOID)hAccess;

   GlobalFreePtr(pDecoderData);

   #ifdef __TEST
   fclose(d_codage);
   fclose(d_test);
   #endif

   return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\bib_32.c ===
#ifdef _X86_
void PassLow8(short *vin,short *vout,short *mem,short nech)
{
	short low_a;

	_asm
	{
		MOV	ESI,[vin]       		; SI  adress input samples
		MOV	CX,[nech]

	BP_LOOP:
		MOV	EBX,0
		MOV	WORD PTR [low_a],0
		MOV	EDI,[mem]      		; DI  adress mem vect.
		ADD	EDI,14			; point on mem(7)

		MOV	AX,-3126		; AX=c(8)
		IMUL	WORD PTR [EDI]		; *=mem(7)
		SUB	WORD PTR [low_a],AX	; accumulate in EBX:LOW_A
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2			; mem--

		MOV	AX,-22721		; AX=c(7)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,-12233		; AX=c(6)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,11718		; AX=c(5)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,-13738		; AX=c(4)
		IMUL    WORD PTR [EDI]
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,-26425		; AX=c(3)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	DX,WORD PTR [EDI]	; c(2)=0 !
		MOV	WORD PTR [EDI+2],DX
		SUB	EDI,2

		MOV	AX,26425		; AX=c(1)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		MOV	AX,13738		; AX=c(0)
		MOV	DX,WORD PTR [ESI]	; *=input !!!
		ADD	ESI,2
		MOV	WORD PTR [EDI],DX	; DI=mem(0)
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		SAL	EBX,1
		MOV	[EDI+8],BX

		MOV	EDI,[vout]
		MOV	[EDI],BX

		ADD	DWORD PTR [vout],2		; vout++

		DEC	CX
		JNE     BP_LOOP
	}
}
#else
void PassLow8(short *vin,short *vout,short *mem,int nech)
{
	int j,k;
	long X;

	for (j=nech;j>0;j--)
	{
		X = 0;
		X -=   (((long)-3126*(long)mem[7])+
			((long)-22721*(long)mem[6])+
			((long)-12233*(long)mem[5])+
			((long)11718*(long)mem[4]))>>1;

		X +=   (((long)-13738*(long)mem[3])+
			((long)-26425*(long)mem[2])+
			((long)26425*(long)mem[0])+
			((long)13738*(long)(*vin)))>>1;

		mem[7]=mem[6];
		mem[6]=mem[5];
		mem[5]=mem[4];
		mem[4]=(int)(X>>14);
		mem[3]=mem[2];
		mem[2]=mem[1];
		mem[1]=mem[0];
		mem[0]=*vin++;
		*vout++=mem[4];
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void PassLow11(short *vin,short *vout,short *mem,short nech)
{
	short low_a;

	_asm
	{
		MOV	ESI,[vin]       		; ESI  adress input samples
		MOV	CX,[nech]

	BP11_LOOP:
		MOV	EBX,0
		MOV	WORD PTR [low_a],0
		MOV	EDI,[mem]      		; EDI  adress mem vect.
		ADD	EDI,14			; point on mem(7)

		MOV	AX,3782			; AX=c(8)
		IMUL	WORD PTR [EDI]		; *=mem(7)
		SUB	WORD PTR [low_a],AX	; accumulate in EBX:low_a
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2			; mem--

		MOV	AX,-8436		; AX=c(7)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,17092		; AX=c(6)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,-10681		; AX=c(5)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		SUB	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		SBB	EBX,EAX
		SUB	EDI,2

		MOV	AX,1179			; AX=c(4)
		IMUL    WORD PTR [EDI]
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,4280			; AX=c(3)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,6208			; AX=c(3)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SUB	EDI,2

		MOV	AX,4280			; AX=c(1)
		MOV	DX,WORD PTR [EDI]
		MOV	WORD PTR [EDI+2],DX
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		MOV	AX,1179			; AX=c(0)
		MOV	DX,WORD PTR [ESI]	; *=input !!!
		ADD	ESI,2
		MOV	WORD PTR [EDI],DX	; EDI=mem(0)
		IMUL    DX
		ADD	WORD PTR [low_a],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX

		SAL	EBX,2
		MOV	[EDI+8],BX

		MOV	EDI,[vout]
		MOV	[EDI],BX

		ADD	WORD PTR [vout],2		; vout++

		DEC	CX
		JNE     BP11_LOOP
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void PassHigh8(short *mem, short *Vin, short *Vout, short lfen)
{

	_asm
	{
		MOV	CX,[lfen]		;CX=cpteur

		MOV	EDI,[mem]

	PH8_LOOP:
		MOV	ESI,[Vin]
		MOV	BX,WORD PTR [ESI]        ;BX=Xin
		MOV	AX,WORD PTR [EDI]	;AX=z(1)
		MOV	WORD PTR [EDI],BX        ;mise a jour memoire
		SUB	BX,AX                   ;BX=Xin-z(1)
		ADD	WORD PTR [Vin],2     ;pointer echant svt
		MOV	AX,WORD PTR [EDI+2]	;AX=z(2)
		MOV	DX,30483		;DX=0.9608
		IMUL	DX
		ADD	AX,16384
		ADC	DX,0                    ;arrondi et dble signe
		SHLD	DX,AX,1
		ADD	DX,BX			;reponse=DX=tmp
		MOV	WORD PTR [EDI+2],DX      ;mise a jour memoire
		MOV	ESI,[Vout]
		MOV	WORD PTR [ESI],DX     	;output=tmp
		ADD	WORD PTR [Vout],2  	;pointer echant svt
		DEC	CX
		JNE	PH8_LOOP
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void PassHigh11(short *mem, short *Vin, short *Vout, short lfen)
{
	_asm
	{
		MOV	CX,[lfen]		;CX=cpteur

		MOV	EDI,[mem]

	PH11_LOOP:
		MOV	ESI,[Vin]
		MOV	BX,WORD PTR [ESI]        ;BX=Xin
		MOV	AX,WORD PTR [EDI]	;AX=z(1)
		MOV	WORD PTR [EDI],BX        ;mise a jour memoire
		SUB	BX,AX                   ;BX=Xin-z(1)
		ADD	WORD PTR [Vin],2  	;pointer echant svt
		MOV	AX,WORD PTR [EDI+2]	;AX=z(2)
		MOV	DX,30830		;DX=0.9714
		IMUL	DX
		ADD	AX,16384
		ADC	DX,0                    ;arrondi et dble signe
		SHLD	DX,AX,1
		ADD	DX,BX			;reponse=DX=tmp
		MOV	WORD PTR [EDI+2],DX      ;mise a jour memoire
		MOV	ESI,[Vout]
		MOV	WORD PTR [ESI],DX     	;output=tmp
		ADD	WORD PTR [Vout],2  	;pointer echant svt
		DEC	CX
		JNE	PH11_LOOP
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void Down11_8(short *Vin, short *Vout, short *mem)
{
	short low_a, count;

	_asm
	{
		MOV	WORD PTR [count],176
		MOV	ESI,[Vin]
		MOV	EDI,[Vout]

		MOV	CX,[ESI]			; *mem=*in

	DOWN_LOOP:
		MOV	[EDI],CX
		ADD	EDI,2
		ADD	ESI,2

		MOV	AX,7040
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,2112
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-960
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,3584
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,5376
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-768
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	ESI,2
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,8064
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,576
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-448
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,6144
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,3072
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-1024
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,1920
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,6720
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-448
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	ESI,2
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,7680
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,1280
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-768
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,4992
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,4160
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-960
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	ESI,4
		MOV	CX,[ESI]
		ADD	EDI,2

		SUB	WORD PTR [count],11
		JNE	DOWN_LOOP

		SUB	ESI,2
		MOV	EBX,[mem]
		MOV	CX,[ESI]
		MOV	[EBX],CX			; *memory=*(++ptr_in)
	}
}
#endif

#if 0
// PhilF: The following is never called!!!
void Up8_11(short *Vin, short *Vout, short *mem1, short *mem2)
{
	short low_a, count;

	_asm
	{
		MOV	WORD PTR [count],128
		MOV	ESI,[Vin]

		MOV	EBX,[mem1]
		MOV	CX,[EBX]		;CX=memo
		MOV	EDI,[mem2]

		MOV	AX,7582
		IMUL	CX
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,1421
		IMUL	WORD PTR [ESI]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-812
		IMUL	WORD PTR [EDI]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	EDI,[Vout]
		MOV	[EDI],AX
		ADD	EDI,2

	UP_LOOP:
		MOV	AX,[ESI]
		MOV	[EDI],AX
		ADD	EDI,2

		MOV	AX,3859
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,5145
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-812
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,6499
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,2708
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-1015
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,7921
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,880
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-609
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	EDI,2

		MOV	AX,1421
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,7108
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-338
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,4874
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,4265
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-947
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,7108
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,2031
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-947
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,8124
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,406
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-338
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		ADD	EDI,2

		MOV	AX,2708
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,6093
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-609
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		MOV	AX,5754
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,3452
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-1015
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2

		CMP	WORD PTR [count],8
		JE	END_OF_LOOP

		MOV	AX,7582
		IMUL	WORD PTR [ESI]
		MOV	[low_a],AX
		MOV	BX,DX
		MOV	AX,1421
		IMUL	WORD PTR [ESI+2]
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,-812
		IMUL	CX
		ADD	[low_a],AX
		ADC	BX,DX
		MOV	AX,[low_a]
		SHRD    AX,BX,13
		MOV	[EDI],AX
		MOV	CX,[ESI]
		ADD	ESI,2
		ADD	EDI,2



	END_OF_LOOP:
		SUB	WORD PTR [count],8
		JNE	UP_LOOP

		MOV	EBX,[mem2]
		MOV	CX,[ESI-2]
		MOV	[EBX],CX			; *memory2=*(ptr_in-1)
		MOV	EBX,[mem1]
		MOV	CX,[ESI]
		MOV	[EBX],CX			; *memory=*(ptr_in)
	}
}
#endif

#ifdef _X86_
void QMFilter(short *input,short *coef,short *out_low,short *out_high,
		     short *mem,short lng)
{
	long R1,R0;
	
	_asm
	{

	QMF_LOOP:
		MOV	ESI,[input]		; ES:SI for input
		MOV	EBX,[mem]		; DS:BX for memory
		MOV	AX,WORD PTR [ESI]		; AX=*input
		MOV	WORD PTR [EBX+16],AX		; *high_mem=*input
		ADD	ESI,2			; input++
		MOV	AX,WORD PTR [ESI]		; AX=*input
		MOV	WORD PTR [EBX],AX		; *low_mem=*input
		ADD	DWORD PTR [input],4		; input++
		MOV	DWORD PTR [R1],0	; initialize accumulation in R1
		MOV	DWORD PTR [R0],0	; initialize accumulation in R0
		MOV	ESI,[coef]	; ES:SI for ptr1
		MOV	EDI,ESI
		ADD	EDI,14			; ES:DI for ptr2
		ADD	EBX,14			; DS:BX for end of mem vector

		MOV	CX,8			; CX=count

	QMF_LOOP2:
		MOV	AX,WORD PTR [ESI]	; AX=*ptr1
		ADD	ESI,2			; ptr1++
		IMUL	WORD PTR [EBX+16]	; DX:AX *=(*high_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R1],EDX
		
		MOV	AX,WORD PTR [EDI]	; AX=*ptr0
		SUB	EDI,2			; ptr1--
		IMUL	WORD PTR [EBX]		; DX:AX *=(*low_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R0],EDX

		MOV	AX,WORD PTR [EBX-2]
		MOV	WORD PTR [EBX],AX		; *low_mem=*(low_mem-1)
		MOV	AX,WORD PTR [EBX+14]
		MOV	WORD PTR [EBX+16],AX		; *high_mem=*(high_mem-1)
		SUB	EBX,2			; *low_mem-- , *high_mem--
		DEC	CX
		JNE	QMF_LOOP2

		MOV	EAX,DWORD PTR [R0]
		SUB	EAX,DWORD PTR [R1]
		SAR	EAX,15
		MOV	EDI,[out_high]
		MOV	WORD PTR [EDI],AX	; *high_out=R0-R1
		ADD	DWORD PTR [out_high],2	; high_low++

		MOV	EAX,DWORD PTR [R0]
		ADD	EAX,DWORD PTR [R1]
		SAR	EAX,15
		MOV	EDI,[out_low]
		MOV	WORD PTR [EDI],AX	; *low_out=R0+R1
		ADD	DWORD PTR [out_low],2	; low_out++

		DEC	WORD PTR [lng]
		JNE     QMF_LOOP
	}
}
#else
void QMFilter(short *in,short *coef,short *out_low,short *out_high,
		     short *mem,short lng)
{
   int i,j;
   long R1,R0;
   short *ptr0,*ptr1,*high_p,*low_p;

   for (j=lng; j>0; j--)
   {
      high_p = mem+8;
      low_p = mem;

      *high_p =  *in++;
      *low_p =  *in++;

      R1=R0=0;

      ptr0 = coef; ptr1 = coef+8-1;

      for (i=8; i>0; i--)
      {
	 R1 += (long)(*ptr1--) * (long)(*high_p++);
	 R0 += (long)(*ptr0++) * (long)(*low_p++);
      }
      *out_low++ = (short)((R0+R1)>>15);
      *out_high++ = (short)((R0-R1)>>15);

      for (i=8; i>0; i--)
      {
	 high_p--; low_p--;
	 *high_p = *(high_p-1); *low_p = *(low_p-1);
      }
   }
}

#endif

#ifdef _X86_
void QMInverse(short *in_low,short *in_high,short *coef,
			short *output,short *mem,short lng)
{
	long R0,R1;

	_asm
	{
	QMI_LOOP:
		MOV	ESI,[in_low]		; ES:SI for input low
		MOV	EDI,[in_high]		; ES:DI for input high
		MOV	EBX,[mem]		; DS:BX for memory
		MOV	AX,WORD PTR [ESI]
		SUB	AX,WORD PTR [EDI]	; AX=*in_low-*in_high
		MOV     WORD PTR [EBX],AX	; *low_mem=*in_low-*in_high
		MOV	AX,WORD PTR [ESI]
		ADD	AX,WORD PTR [EDI]	; AX=*in_low+*in_high
		MOV     WORD PTR [EBX+16],AX	; *high_mem=*in_low+*in_high

		ADD	DWORD PTR [in_low],2	; in_low++
		ADD	DWORD PTR [in_high],2	; in_high++
		MOV	DWORD PTR [R0],0
		MOV	DWORD PTR [R1],0
		MOV	ESI,[coef]	; ES:SI for ptr1
		MOV	EDI,ESI
		ADD	EDI,14			; ES:DI for ptr2
		ADD	EBX,14			; DS:BX for end of mem vector

		MOV	CX,8			; DX=count
	QMI_LOOP2:
		MOV	AX,WORD PTR [ESI]	; AX=*ptr1
		ADD	ESI,2			; ptr1++

		IMUL	WORD PTR [EBX+16]	; DX:AX*=(*high_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R1],EDX	; Accumulate in R1

		MOV	AX,WORD PTR [EDI]	; AX=*ptr0
		SUB	EDI,2			; ptr1--
		IMUL	WORD PTR [EBX]		; DX:AX*=(*low_mem)
		AND	EAX,0000ffffH
		SAL	EDX,16
		ADD	EDX,EAX
		ADD	DWORD PTR [R0],EDX 		; Accumulate in R0

		MOV	AX,WORD PTR [EBX-2]
		MOV	WORD PTR [EBX],AX	; *low_mem=*(low_mem-1)
		MOV	AX,WORD PTR [EBX+14]
		MOV	WORD PTR [EBX+16],AX	; *high_mem=*(high_mem-1)
		SUB	EBX,2			; *low_mem-- , *high_mem--
		DEC	CX
		JNE	QMI_LOOP2

		MOV	EDI,[output]
		MOV	EAX,DWORD PTR [R1]
		SAR	EAX,15
		MOV	WORD PTR [EDI+2],AX	; *(out+1)=R1
		MOV	EAX,DWORD PTR [R0]
		SAR	EAX,15
		MOV	WORD PTR [EDI],AX	; *out=R0
		ADD	DWORD PTR [output],4	; out++,out++

		DEC	WORD PTR [lng]
		JNE     QMI_LOOP
	}
}
#else
void QMInverse(short *in_low,short *in_high,short *coef,
		short *out,short *mem,short lng)
{
   int i,j;
   long R1,R0;
   short *ptr0,*ptr1,*high_p,*low_p;

   for (j=0; j<lng; j++)
   {
       high_p = mem+8;
       low_p = mem;

       *high_p =  *in_low + *in_high;
       *low_p =  *in_low++ - *in_high++;

       R1 = R0 = 0;
       ptr0 = coef; ptr1 = coef+8-1;

       for (i=8; i>0; i--)
       {
	  R1 += (long)(*ptr1--) * (long)(*high_p++);
	  R0 += (long)(*ptr0++) * (long)(*low_p++);
       }

       *out++ = (short)(R0>>15);
       *out++ = (short)(R1>>15);

       for (i=8; i>0; i--)
       {
	  high_p--; low_p--;
	  *high_p = *(high_p-1); *low_p = *(low_p-1);
       }
   }
}
#endif

#ifdef _X86_
void iConvert64To8(short *input, short *output, short N, short *mem)
{
	short LOW_A;

	_asm
	{
		MOV	ESI,[input]
		MOV	EDI,[output]

		MOV	AX,[ESI]
		MOV	[EDI],AX		; out[0]=in[0]

		MOV	WORD PTR [LOW_A],0
		MOV	AX,-3072
		MOV	EBX,[mem]		; BX for memory
		IMUL	word ptr [EBX]
		MOV	EBX,0
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,14336
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,21504
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+2],BX			; out[1]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-4096
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,24576
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,12288
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+4],BX			; out[2]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3072
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,30720
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,5120
		IMUL	word ptr [ESI+6]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+6],BX			; out[3]

		MOV	AX,[ESI+6]
		MOV	[EDI+8],AX		; out[4]

		MOV	CX,0
	iUPSAMP:
		ADD	CX,4
		CMP	CX,WORD PTR [N]
		JGE	iEND_UPSAMP
		ADD	ESI,8
		ADD	EDI,10

		MOV	AX,[ESI]
		MOV	[EDI],AX			; out[0]=in[0]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3072
		IMUL	word ptr [ESI-2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,14336
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,21504
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+2],BX			; out[1]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-4096
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,24576
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,12288
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+4],BX			; out[2]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3072
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,30720
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,5120
		IMUL	word ptr [ESI+6]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+6],BX			; out[3]

		MOV	AX,[ESI+6]
		MOV	[EDI+8],AX		; out[4]

		JMP	iUPSAMP

	iEND_UPSAMP:
		MOV	EBX,[mem]
		MOV	AX,[ESI+6]
		MOV	[EBX],AX		; mem[0]=in[N-1]
	}
}
#else
void iConvert64To8(short *input, /* Pointer to input buffer */
				   short *output, /* Pointer to output buffer */
				   short N,		/* Number of input samples */
				   short *mem)	/* Pointer to two word temporary storage */
{
	int i;

	/* This copies samples and replicates every 4th */
	/* (and leaves garbage at the end if not a multiple of 4 */
	for(i=0; i<N/4; i++) {
		short temp;

		*output++ = *input++;
		*output++ = *input++;
		*output++ = *input++;
		*output++ = temp = *input++;
		*output++ = temp;
	}

}
#endif

#ifdef _X86_
void iConvert8To64(short *input, short *output, short N, short *mem)
{
	short LOW_A;

	_asm
	{

		MOV	ESI,[input]
		MOV	EDI,[output]

		MOV	CX,0

	iDOWNSAMP:
		CMP	CX,WORD PTR [N]
		JGE	iEND_DOWNSAMP

		MOV	AX,[ESI]
		MOV	[EDI],AX			; out[0]=in[0]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3623
		IMUL	word ptr [ESI]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,29200
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,7191
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+2],BX			; out[1]

		MOV	WORD PTR [LOW_A],0
		MOV	EBX,0
		MOV	AX,-3677
		IMUL	word ptr [ESI+2]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,18494
		IMUL	word ptr [ESI+4]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		MOV	AX,17950
		IMUL	word ptr [ESI+6]
		ADD	[LOW_A],AX
		MOVSX	EAX,DX
		ADC	EBX,EAX
		SAL	EBX,1
		MOV	word ptr [EDI+4],BX			; out[2]

		MOV	AX,[ESI+8]
		MOV	[EDI+6],AX		; out[3]=in[4]

		ADD	CX,5
		ADD	SI,10
		ADD	EDI,8

		JMP	iDOWNSAMP

	iEND_DOWNSAMP:

	}
}
#else
/* Resample 8 KHz to 6.4 KHz */
void iConvert8To64(short *input,	/* Pointer to input sample buffer */
				   short *output,	/* Pointer to output sample buffer */
				   short N,			/* Count of input samples */
				   short *mem)		/* Pointer to two word temporary storage */
{
	int i;

	/* This copies 4 of every 5 samples */
	/* (and leaves garbage at the end if not a multiple of 5 */
	for(i=0; i<N/5; i++) {
		*output++ = *input++ >> 1;
		*output++ = *input++ >> 1;
		*output++ = *input++ >> 1;
		*output++ = *input++ >> 1;
		input++;
	}

}
#endif

#ifdef _X86_
void fenetre(short *src,short *fen,short *dest,short lng)
{
	_asm
	{

		MOV	ESI,[src]
		MOV     EDI,[fen]
		MOV     EBX,[dest]

		MOV	CX,[lng]     ; CX : compteur

	fen_loop:
		MOV	AX,WORD PTR [ESI]     ; AX = src
		IMUL    WORD PTR [EDI]        ; DX:AX = src*fen
		ADD     AX,16384
		ADC     DX,0                    ; arrondi
		SHLD    DX,AX,1
		MOV     WORD PTR [EBX],DX
		ADD     ESI,2
		ADD     EDI,2
		ADD     EBX,2
		DEC	CX
		JNE	fen_loop
	}
}
#else
/* Window the data in buffer */
/* not tested - tfm */
void fenetre(short *src,short *fen,short *dest,short lng)
{
	int i;

	for(i=0; i<lng; i++) {
		*dest++ = *src++ * *fen++;
	}
}

#endif


#ifdef _X86_
void autocor(short *vech,long *ri,short nech,short ordre)
{
	short low_a,compta;

	_asm
	{
		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons
		MOV     BX,[nech]
		MOV     WORD PTR [low_a],0
		MOV     ECX,0

	DYNAMIC:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    AX             ; DX:AX = xi*xi
		ADD     [low_a],AX
		MOVSX   EAX,DX
		ADC     ECX,EAX         ;accumuler sur 48 bits
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB	BX,1
		JG      DYNAMIC

		MOV     EDI,[ri]         ;ES:DI  adresse vect. autocorr.

		MOV     EAX,ECX
		SAR     EAX,15
		ADD     AX,0
		JZ      FORMAT_OK

	;RISK_OV:
		MOV     AX,[low_a]
		ADD     AX,8
		ADC     ECX,0
		SAR     AX,4
		AND     AX,0FFFH

		SAL     ECX,12
		OR      CX,AX
		MOV     DWORD PTR [EDI],ECX     ;Sauvegarder R(0)

		MOVSX   EAX,[ordre]
		SAL	EAX,2
		ADD     EDI,EAX           ;Pointer dernier lment du vect. autoc.

	ATCROV1:
		MOV     CX,[nech]       ;Charger nombre de points vect. source
		SUB     CX,[ordre]    ;Dcrmenter de l'ordre de corrlation
		MOV     [compta],CX

		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons
		MOVSX   EBX,[ordre]
		ADD     EBX,EBX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     ECX,0
		MOV     WORD PTR [low_a],0	; //SS:

	ATCROV2:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    WORD PTR [ESI+EBX] ;Multiplier par l'lment dcal
		ADD     [low_a],AX
		MOVSX   EAX,DX
		ADC     ECX,EAX
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB     WORD PTR [compta],1		; //SS:
		JG      ATCROV2

		MOV     AX,[low_a]
		ADD     AX,8
		ADC     ECX,0
		SAR     AX,4
		AND     AX,0FFFH

		SAL     ECX,12
		OR      CX,AX
		MOV     DWORD PTR [EDI],ECX     ;Sauvegarder rsultat
		SUB     EDI,4            ;Pointer autocor. prcdant
		SUB     WORD PTR [ordre],1   ;Test de fin de boucle //SS:
		JG      ATCROV1

		JMP     FIN_ATCR

	FORMAT_OK:
		SAL     ECX,16
		MOV     CX,[low_a]
		MOV     DWORD PTR [EDI],ECX     ;Sauvegarder R(0)
		MOVSX   EAX,WORD PTR [ordre]
		SAL     EAX,2
		ADD     EDI,EAX           ;Pointer dernier lment du vect. autoc.

	ATCR10:
		MOV     CX,[nech]       ;Charger nombre de points vect. source
		SUB     CX,[ordre]    ;Dcrmenter de l'ordre de corrlation
		MOV     [compta],CX

		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons
		MOVSX	EBX,[ordre]
		ADD     EBX,EBX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     CX,0
		MOV     WORD PTR [low_a],0		;//SS:

	ATCR20:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    WORD PTR [ESI+EBX] ;Multiplier par l'lment dcal
		ADD     [low_a],AX
		ADC     CX,DX
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB     WORD PTR [compta],1		;//SS:
		JG      ATCR20

		MOV     AX,[low_a]
		MOV     WORD PTR [EDI],AX      ;Sauvegarder rsultat
		MOV     WORD PTR [EDI+2],CX

		SUB     EDI,4            ;Pointer autocor. prcdant
		SUB     WORD PTR [ordre],1   ;Test de fin de boucle
		JG      ATCR10

	FIN_ATCR:

	}	// _asm
}
#else
void autocor(short *vech,long *ri,short nech,short ordre)
{
	// TODO: Fill this in
}
#endif

#ifdef _X86_
short max_autoc(short *vech,short nech,short debut,short fin)
{
	short max_pos,max_l,compta;
	long lmax_h;

	_asm
	{
		MOV     WORD PTR [max_pos],69
		MOV     DWORD PTR [lmax_h],-6969
		MOV     WORD PTR [max_l],69

	M_ATCR1:
		MOV     CX,[nech]      ;Charger nombre de points vect. source
		MOVSX   EBX,WORD PTR [fin]
		SUB     CX,BX           ;Dcrmenter de l'ordre de corrlation
		MOV     [compta],CX

		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons

		ADD     EBX,EBX           ;Dfinir un Deplacement d'adresse vect. source

		MOV     ECX,0
		MOV     DI,0;

	M_ATCR2:
		MOV     AX,WORD PTR [ESI]     ;Charger lment vect. source
		IMUL    WORD PTR [ESI+EBX] ;Multiplier par l'lment dcal
		ADD     DI,AX
		MOVSX   EAX,DX
		ADC     ECX,EAX
		ADD     ESI,2            ;Pointer lmen suiv.
		SUB     WORD PTR [compta],1
		JG      M_ATCR2

		MOV     BX,[max_l]
		SUB     BX,DI

		MOV     EDX,[lmax_h]
		SBB     EDX,ECX

		JGE     NEXT_ITR

		MOV     [max_l],DI                 ;save max
		MOV     [lmax_h],ECX
		MOV     AX,[fin]
		MOV     [max_pos],AX

	NEXT_ITR:
		MOV     CX,[fin]                 ;Test de fin de boucle
		SUB     CX,1
		MOV     [fin],CX
		SUB     CX,[debut]
		JGE     M_ATCR1

	}

	// MOV     AX,[max_pos]
	return max_pos;
}
#else
short max_autoc(short *vech,short nech,short debut,short fin)
{
		// TODO need 64-bit
	return 0;
}
#endif


#ifdef _X86_
#pragma warning(disable : 4035)
short max_vect(short *vech,short nech)
{

	_asm
	{
		MOV     CX,[nech]      ;Charger nombre de points vect. source
		MOV     ESI,[vech]       ;DS:SI  adresse vect. echantillons

		MOV     AX,-32767       ; AX = maximum

	L_M_VECT:
		MOV     BX,WORD PTR [ESI]     ;Charger elem. vect.
		ADD     BX,0
		JGE     BX_POSIT
		NEG     BX

	BX_POSIT:
		CMP     BX,AX
		JLE     NEXT_VALUE
		MOV     AX,BX

	NEXT_VALUE:
		ADD     ESI,2
		DEC	CX
		JNE	L_M_VECT
	}

}
#pragma warning(default : 4035)

void upd_max(long *corr_ene,long *vval,short pitch)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EDI,[vval]        ; ES:DI  maximum.


		MOV     EAX,DWORD PTR [ESI+8]    ; AX = partie haute de ener
		SAR     EAX,15
		ADD     AX,0
		JE      FORMA32

		MOV     EAX,DWORD PTR [ESI]            ;EAX = corr. high
		MOV     BX,WORD PTR [ESI+4]
		ADD     BX,8
		ADC     EAX,0
		SAR     BX,4
		AND     BX,0FFFH
		SAL     EAX,12
		OR      AX,BX
		ADD     EAX,0
		JGE     CORR_POSIT
		NEG     EAX

	CORR_POSIT:
		MOV     DWORD PTR [ESI+16],EAX

		MOV     EBX,DWORD PTR [ESI+8]
		MOV     DX,WORD PTR [ESI+12]
		ADD     DX,8
		ADC     EBX,0
		SAR     DX,4
		AND     DX,0FFFH
		SAL     EBX,12
		OR      BX,DX
		MOV     DWORD PTR [ESI+20],EBX
		MOV     ECX,4
		JMP     DEB_COMP

	FORMA32:
		MOV     ECX,0            ; init normalisat.
		MOV     AX,WORD PTR [ESI]
		SAL     EAX,16
		MOV     AX,WORD PTR [ESI+4]
		ADD     EAX,0
		JGE     CORR_POSIT2
		NEG     EAX

	CORR_POSIT2:
		MOV     DWORD PTR [ESI+16],EAX
		MOV     BX,WORD PTR [ESI+8]
		SAL     EBX,16
		MOV     BX,WORD PTR [ESI+12]
		MOV     DWORD PTR [ESI+20],EBX

	DEB_COMP:
					; EAX = correl.
					; EBX = ener
		ADD     EBX,0
		JE      ENER_NULL

		MOV     DX,WORD PTR [ESI+22]
		ADD     DX,WORD PTR [ESI+18]
		JG      GT16BIT

	;FORM_16:
		SAL     EBX,15
		SAL     EAX,15
		SUB     ECX,15
	GT16BIT:
		ADD     EAX,0
		JE      ENER_NULL
		CMP     EBX,40000000H
		JGE     NO_E_NORMU
	NORM_ENEU:
		ADD     EBX,EBX
		INC     ECX
		CMP     EBX,40000000H
		JL      NORM_ENEU

	NO_E_NORMU:
		CMP     EAX,40000000H      ; normaliser acc
		JGE     PAS_D_N_C

	NORM_CORL:
		ADD     EAX,EAX
		SUB     ECX,2
		CMP     EAX,40000000H
		JL      NORM_CORL
	PAS_D_N_C:
		IMUL    EAX             ;EDX:EAX = produit
		CMP     EDX,20000000H
		JLE     MAKE_DIVU

		SHRD    EAX,EDX,1
		SAR     EDX,1
		INC     ECX

	MAKE_DIVU:
		IDIV    EBX
		CMP     EAX,40000000H
		JGE     SAVE_RAPP

	NORM_RAPP:
		ADD     EAX,EAX
		DEC     ECX
		CMP     EAX,40000000H
		JLE     NORM_RAPP

	SAVE_RAPP:
		MOV     EBX,DWORD PTR [EDI+4]
		CMP     ECX,EBX
		JG      UPDATE_M
		JL      ENER_NULL

	;EBX_EQU_ECX:
		MOV     EBX,DWORD PTR [EDI]
		CMP     EAX,EBX
		JLE     ENER_NULL

	UPDATE_M:
		MOV     DWORD PTR [EDI],EAX          ; sauver mant. et exp. max
		MOV     DWORD PTR [EDI+4],ECX

		MOV     EAX,DWORD PTR [ESI+16]
		MOV     EDX,DWORD PTR [ESI]
		ADD     EDX,0
		JGE     SIGNE_OK
		NEG     EAX
	SIGNE_OK:
		MOV     DWORD PTR [EDI+8],EAX
		MOV     EAX,DWORD PTR [ESI+20]
		MOV     DWORD PTR [EDI+12],EAX

		MOVSX   EAX,WORD PTR [pitch]
		MOV     DWORD PTR [EDI+16],EAX

	ENER_NULL:

	}
}


#pragma warning(disable : 4035)

short upd_max_d(long *corr_ene,long *vval)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EDI,[vval]        ; ES:DI  maximum.

		MOV     AX,0
		MOV     EBX,DWORD PTR [ESI+4]    ;EBX = ener
		ADD     EBX,0
		JE      ENER_ZRO

		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr.
		SAL     EAX,10           ; 12 initialement
		IMUL    EAX              ; EDX:EAX = corr*corr

		IDIV    EBX              ; EAX = corr*corr/ener

		MOV     ECX,EAX
		MOV     AX,0
		MOV     EDX,DWORD PTR [EDI]      ; EDX = GGmax
		CMP     ECX,EDX
		JLE     ENER_ZRO
		MOV     DWORD PTR [EDI],ECX       ; save max
		MOV     DWORD PTR [EDI+8],EBX
		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr.
		MOV     DWORD PTR [EDI+4],EAX
		MOV     AX,7FFFH
	ENER_ZRO:
	}
}
#pragma warning(default : 4035)

void norm_corrl(long *corr,long *vval)
{
	_asm
	{
		MOV     ESI,[corr]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[vval]        ; ES:DI  adresse acc et ener.

		MOV     EAX,DWORD PTR [EDI+8]    ; AX = partie haute de ener
		SAR     EAX,15
		ADD     AX,0
		JE      FORM_32

		MOV     EAX,DWORD PTR [EDI]
		MOV     BX,WORD PTR [EDI+4]
		ADD     BX,32
		ADC     EAX,0
		SAR     BX,5
		AND     BX,07FFH
		SAL     EAX,11            ;
		OR      AX,BX
		MOV     DWORD PTR [EDI+16],EAX

		MOV     EBX,DWORD PTR [EDI+8]
		MOV     DX,WORD PTR [EDI+12]
		ADD     DX,32
		ADC     EBX,0
		SAR     DX,5
		AND     DX,07FFH
		SAL     EBX,11           ;
		OR      BX,DX
		MOV     DWORD PTR [EDI+20],EBX
		MOV     ECX,5
		JMP     DEB_PROC

	FORM_32:
		MOV     ECX,0            ; init normalisation
		MOV     AX,WORD PTR [EDI]
		SAL     EAX,16
		MOV     AX,WORD PTR [EDI+4]
		MOV     DWORD PTR [EDI+16],EAX

		MOV     BX,WORD PTR [EDI+8]
		SAL     EBX,16
		MOV     BX,WORD PTR [EDI+12]
		MOV     DWORD PTR [EDI+20],EBX

	DEB_PROC:
		ADD     EAX,0			;EAX = acc
		JLE     CORR_LE_0

		CMP     EBX,40000000H
		JGE     NO_E_NORM

	NORM_ENE:
		ADD     EBX,EBX
		INC     ECX
		CMP     EBX,40000000H
		JL      NORM_ENE

	NO_E_NORM:
		CMP     EAX,40000000H      ; normaliser acc
		JGE     PAS_D_NORM

	NORM_ACC:
		ADD     EAX,EAX
		SUB     ECX,2
		CMP     EAX,40000000H
		JL      NORM_ACC

	PAS_D_NORM:
		IMUL    EAX             ;EDX:EAX = produit
		CMP     EDX,20000000H
		JLE     MAKE_DIV
		SHRD    EAX,EDX,1
		SAR     EDX,1
		INC     ECX

	MAKE_DIV:
		IDIV    EBX
		CMP     EAX,40000000H
		JL      SAVE_CRR

		SAR     EAX,1
		INC     ECX
		JMP     SAVE_CRR

	CORR_LE_0:
		MOV     EAX,0
		MOV     ECX,-69

	SAVE_CRR:
		MOV     DWORD PTR [ESI],EAX
		MOV     DWORD PTR [ESI+4],ECX
	}
}

void norm_corrr(long *corr,long *vval)
{
	_asm
	{
		MOV     ESI,[corr]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[vval]        ; ES:DI  adresse acc et ener.

		MOV     EAX,DWORD PTR [EDI+8]    ; AX = partie haute de ener
		SAR     EAX,15
		ADD     AX,0
		JE      FORM_32R

		MOV     EAX,DWORD PTR [EDI]
		MOV     BX,WORD PTR [EDI+4]
		ADD     BX,32
		ADC     EAX,0
		SAR     BX,5
		AND     BX,07FFH
		SAL     EAX,11            ;
		OR      AX,BX
		MOV     DWORD PTR [EDI+16],EAX

		MOV     EBX,DWORD PTR [EDI+8]
		MOV     DX,WORD PTR [EDI+12]
		ADD     DX,32
		ADC     EBX,0
		SAR     DX,5
		AND     DX,07FFH
		SAL     EBX,11           ;
		OR      BX,DX
		MOV     DWORD PTR [EDI+20],EBX
		MOV     ECX,5
		JMP     DEB_PROCR

	FORM_32R:
		MOV     ECX,0            ; init normalisat.
		MOV     AX,WORD PTR [EDI]
		SAL     EAX,16
		MOV     AX,WORD PTR [EDI+4]
		MOV     DWORD PTR [EDI+16],EAX

		MOV     BX,WORD PTR [EDI+8]
		SAL     EBX,16
		MOV     BX,WORD PTR [EDI+12]
		MOV     DWORD PTR [EDI+20],EBX

	DEB_PROCR:
					;EAX = acc
		ADD     EAX,0
		JLE     CORRR_LE_0
					;EBX = ener
		CMP     EBX,40000000H
		JGE     NO_E_NORMR

	NORM_ENER:
		ADD     EBX,EBX
		INC     ECX
		CMP     EBX,40000000H
		JL      NORM_ENER

	NO_E_NORMR:
		CMP     EAX,40000000H      ; normaliser acc
		JGE     PAS_D_NORMR

	NORM_ACCR:
		ADD     EAX,EAX
		SUB     ECX,2
		CMP     EAX,40000000H
		JL      NORM_ACCR

	PAS_D_NORMR:
		IMUL    EAX             ;EDX:EAX = produit
		CMP     EDX,20000000H
		JLE     MAKE_DIVR

		SHRD    EAX,EDX,1
		SAR     EDX,1
		INC     ECX

	MAKE_DIVR:
		IDIV    EBX
		CMP     EAX,40000000H
		JL      SAVE_CRRR

		SAR     EAX,1
		INC     ECX

	SAVE_CRRR:
		MOV     EBX,DWORD PTR [ESI+4]
		CMP     EBX,ECX
		JL      BX_LT_CX
		JG      BX_GT_CX

	;BX_EQU_CX:
		ADD     DWORD PTR [ESI],EAX
		JMP     CORRR_LE_0

	BX_LT_CX:
		MOV     DWORD PTR [ESI+4],ECX          ; sauver exp.
		SUB     CX,BX                  ;
		MOV     EDX,DWORD PTR [ESI]
		SAR     EDX,CL
		ADD     EAX,EDX
		MOV     DWORD PTR [ESI],EAX
		JMP     CORRR_LE_0

	BX_GT_CX:
		SUB     BX,CX                  ;
		MOV     CL,BL
		SAR     EAX,CL
		ADD     DWORD PTR [ESI],EAX
	CORRR_LE_0:
		MOV     EAX,DWORD PTR [ESI]
		MOV     ECX,DWORD PTR [ESI+4]
		ADD     EAX,0
		JZ      END_CRRR

		CMP     EAX,40000000H
		JGE     END_CRRR

	NRM_RR:
		ADD     EAX,EAX
		DEC     ECX
		CMP     EAX,40000000H
		JL      NRM_RR

		MOV     DWORD PTR [ESI],EAX
		MOV     DWORD PTR [ESI+4],ECX

	END_CRRR:
	}
}

void energy(short *vech,long *ene,short lng)
{
	_asm
	{
		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons

		MOV     CX,[lng]      ;Initialiser le compteur

		MOV     EBX,0
		MOV     DI,0

	L_ENERGY:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    AX                 ;Multiplier
		ADD     DI,AX
		MOVSX   EAX,DX
		ADC     EBX,EAX
		ADD     ESI,2               ;Pointer lmen suiv.
		DEC	CX
		JNE     L_ENERGY

		MOV     ESI,[ene]          ;  adresse result.
		MOV     DWORD PTR [ESI],EBX
		MOV     WORD PTR [ESI+4],DI
	}
}

void venergy(short *vech,long *vene,short lng)
{
	_asm
	{

		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons
		MOV     EDI,[vene]          ;  adresse result.

		MOV     EBX,0
		MOV     CX,0
	L_VENERGY:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    AX                 ;Multiplier
		ADD     CX,AX
		MOVSX   EAX,DX
		ADC     EBX,EAX            ; acc. en EBX:CX
		ADD     ESI,2               ;Pointer lmen suiv.

		MOV     EDX,EBX            ; sauver EBX:CX>>5
		MOV     AX,CX              ; mettre dans EDX:AX
		ADD     AX,16              ; arrondi
		ADC     EDX,0
		SAL     EDX,11             ; EDX<<11
		SAR     AX,5               ;
		AND     AX,07FFH
		OR      DX,AX              ; EDX = (EBX:CX + 16) >> 5
		MOV     DWORD PTR [EDI],EDX
		ADD     EDI,4
		SUB     WORD PTR [lng],1
		JG      L_VENERGY
	}
}

void energy2(short *vech,long *ene,short lng)
{
	_asm
	{
		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons

		MOV     CX,[lng]      ;Initialiser le compteur
		MOV     EBX,0
		MOV     DI,0
	L_ENERGY2:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    AX                 ;Multiplier
		ADD     DI,AX
		MOVSX   EAX,DX
		ADC     EBX,EAX
		ADD     ESI,2               ;Pointer lmen suiv.
		DEC	    CX
		JNE     L_ENERGY2

		MOV     ESI,[ene]         ;  adresse result.
				       ; sauver EBX:[LOW_A]>>5
		ADD     DI,16              ; arrondi
		ADC     EBX,0
		SAL     EBX,11             ; EBX<<11
		SAR     DI,5               ;
		AND     DI,07FFH
		OR      BX,DI              ; EBX = (EBX:AX + 16) >> 5
		MOV     DWORD PTR [ESI],EBX
	}
}

void upd_ene(long *ener,long *val)
{
	_asm
	{
		MOV     ESI,[ener]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[val]        ; ES:DI  adresse acc et ener.

		MOV     EBX,DWORD PTR [ESI]      ; EBX partie H ene
		MOV     AX,WORD PTR [ESI+4]    ; AX = partie low

		MOV     CX,WORD PTR [EDI]
		MOVSX   EDX,WORD PTR [EDI+2]    ; EDX:CX  ajouter

		ADD     AX,CX
		ADC     EBX,EDX

		MOV     CX,WORD PTR [EDI+4]
		MOVSX   EDX,WORD PTR [EDI+6]    ; EDX:CX  retirer

		SUB     AX,CX
		SBB     EBX,EDX

		MOV     DWORD PTR [ESI],EBX
		MOV     WORD PTR [ESI+4],AX
	}
}


#pragma warning(disable : 4035)

short max_posit(long *vcorr,long *maxval,short pitch,short lvect)
{

	_asm
	{
		MOV     ESI,[vcorr]       ; DS:SI  adresse vect. corr.
		MOV     EDI,[maxval]        ; ES:DI  adresse val max

		MOV     CX,[lvect]       ; init compt

		MOV     EAX,DWORD PTR [ESI]      ; init max
		MOV     EBX,DWORD PTR [ESI+4]
		ADD     ESI,8
		MOV     WORD PTR [EDI],CX
		DEC     CX

	L_MAX_POS:
		MOV     EDX,DWORD PTR [ESI+4]    ; EDX = exp. du candidat
		CMP     EDX,EBX
		JG      UPDT_MAX
		JL      NEXT_IND

		MOV     EDX,DWORD PTR [ESI]      ; EDX = mantisse
		CMP     EDX,EAX
		JLE     NEXT_IND

	UPDT_MAX:
		MOV     EAX,DWORD PTR [ESI]
		MOV     EBX,DWORD PTR [ESI+4]
		MOV     WORD PTR [EDI],CX

	NEXT_IND:
		ADD     ESI,8
		DEC	CX
		JNE	L_MAX_POS

		MOV     CX,WORD PTR [EDI]
		NEG     CX
		ADD     CX,[lvect]

		MOV     DX,[lvect]
		SAR     DX,1
		SUB     CX,DX
		ADD     CX,[pitch]

		MOV     DWORD PTR [EDI],EAX
		MOV     DWORD PTR [EDI+4],EBX

		MOV     AX,CX
	}
}
#pragma warning(default : 4035)

void correlation(short *vech,short *vech2,long *acc,short lng)
{
	short low_a;

	_asm
	{
		MOV     ESI,[vech]       ; DS:SI  adresse vect. echantillons
		MOV     EDI,[vech2]      ; ES:DI  adresse 2d vect.
		MOV     CX,[lng]      ;Initialiser le compteur

		MOV     EBX,0
		MOV     WORD PTR [low_a],0

	L_CORREL:
		MOV     AX,WORD PTR [ESI]         ;Charger lment vect. source
		IMUL    WORD PTR [EDI]   ;Multiplier par l'lment dcal
		ADD     [low_a],AX
		MOVSX   EAX,DX
		ADC     EBX,EAX
		ADD     ESI,2            ;Pointer lmen suiv.
		ADD     EDI,2
		DEC	CX
		JNE     L_CORREL

		MOV     ESI,[acc]           ;  adresse result.
		MOV     DWORD PTR [ESI],EBX
		MOV     AX,[low_a]
		MOV     WORD PTR [ESI+4],AX
	}
}

void  schur(short *parcor,long *Ri,short netages)
{
	short cmpt2;

	_asm
	{
		MOV     ESI,[Ri]
		MOV     EDI,ESI
		ADD     EDI,44             ; DS:DI for V

		MOV     EBX,DWORD PTR [ESI]       ; EBX = R(0)
		MOV     CL,0
		CMP     EBX,40000000H     ;normaliser R(0)
		JGE     OUT_N_R0
	NORM_R0:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H
		JL      NORM_R0
	OUT_N_R0:
		MOV     DWORD PTR [ESI],EBX
				      ;Initialisation de  V = R1..Rp
		MOV     DX,[netages]       ;Charger ordre p du LPC
		ADD     ESI,4              ;Pointer R1
	INIT_V:
		MOV     EAX,DWORD PTR [ESI]       ;EAX = Ri
		SAL     EAX,CL
		MOV     DWORD PTR [ESI],EAX       ;Sauver dans U[i]
		MOV     DWORD PTR [EDI],EAX       ;Sauver dans V[i]
		ADD     ESI,4              ;passer au suivant
		ADD     EDI,4
		DEC     DX
		JG      INIT_V

		MOV     WORD PTR [cmpt2],1    ;I=1

	HANITRA:
		MOV     CX,[netages]            ;CX = NETAGES
		SUB     CX,[cmpt2]             ;CX = NETAGES-I
		ADD     WORD PTR [cmpt2],1
		MOV     ESI,[Ri]               ;Charger vecteur U
		MOV     EDI,ESI
		ADD     EDI,44                  ;Charger vect. V

		MOV     EDX,DWORD PTR [EDI]            ; EDX = V(0)
		MOV     EAX,0
		SHRD    EAX,EDX,1
		SAR     EDX,1
		MOV     EBX,DWORD PTR [ESI]            ; EBX = S(0)
		NEG     EBX
		IDIV    EBX

		MOV     EBX,EAX                ; EBX = KI

		MOV     EAX,DWORD PTR [EDI]            ; EAX =V(0)
		IMUL    EBX                    ; EDX:EAX = PARCOR*V[0]
		SHLD    EDX,EAX,1
		ADD     EDX,DWORD PTR [ESI]            ; EDX = U[0]+V[0]*PARCOR
		CMP     CX,0
		JE      FINATCR
		MOV     DWORD PTR [ESI],EDX            ;Sauver U[0]; EBX = KI

	LALA:
		ADD     EDI,4                     ;Incrementer les pointeurs
		ADD     ESI,4                     ;
		MOV     EAX,DWORD PTR [ESI]
		IMUL    EBX                      ;EDX:EAX = PARCOR*U[I]
		SHLD    EDX,EAX,1
		ADD     EDX,DWORD PTR [EDI]              ;EDX = V[I]+U[I]*PARCOR
		MOV     DWORD PTR [EDI-4],EDX            ;Sauver V[I-1];

		MOV     EAX,DWORD PTR [EDI]
		IMUL    EBX                      ;EDX:EAX = PARCOR*V[I]
		SHLD    EDX,EAX,1
		ADD     EDX,DWORD PTR [ESI]              ;EDX = U[I]+V[I]*PARCOR
		MOV     DWORD PTR [ESI],EDX              ;Sauver U[I]; ST = KI
		DEC     CX
		JNE     LALA

		MOV     EDI,[parcor]
		ADD     EBX,32768
		SAR     EBX,16
		MOV     WORD PTR [EDI],BX        ; sauver KI
		ADD     DWORD PTR [parcor],2   ;Next KI

		JMP     HANITRA

	FINATCR:
		ADD     EBX,32768
		SAR     EBX,16
		MOV     EDI,[parcor]
		MOV     WORD PTR [EDI],BX               ; sauver KI

	}
}

void interpol(short *lsp1,short *lsp2,short *dest,short lng)
{
	_asm
	{
		MOV	ESI,[lsp1]
		MOV     EDI,[lsp2]
		MOV     EBX,[dest]

		MOV	CX,[lng]     ; CX : compteur

	interp_loop:
		MOVSX	EAX,WORD PTR [ESI]     ; AX = lsp1
		ADD     ESI,2

		ADD     EAX,EAX        		; EAX = 2*lsp1
		MOVSX   EDX,WORD PTR [EDI]
		ADD     EAX,EDX        		; EAX = 2*lsp1+lsp2
		ADD     EDI,2

		MOV     EDX,21845       ; 21845 = 1/3
		IMUL    EDX             ; EDX:EAX = AX/3

		ADD     EAX,32768
		SAR     EAX,16

		MOV     WORD PTR [EBX],AX
		ADD     EBX,2

		DEC	CX
		JNE	interp_loop
	}
}

void add_sf_vect(short *y1,short *y2,short deb,short lng)
{
	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]
		MOV     CX,[lng]
		MOVSX	EBX,WORD PTR [deb]
		SUB     CX,BX            ; CX : compteur
		ADD     BX,BX
		ADD     ESI,EBX

	ADD_SHFT:
		MOV	AX,WORD PTR [EDI]
		ADD	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	ADD_SHFT
	}
}

void sub_sf_vect(short *y1,short *y2,short deb,short lng)
{
	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]
		MOV     CX,[lng]
		MOVSX	EBX,[deb]
		SUB     CX,BX            ; CX : compteur
		ADD     BX,BX
		ADD     ESI,EBX

	SUB_SHFT:
		MOV	AX,WORD PTR [EDI]
		SUB	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	SUB_SHFT
	}
}

void short_to_short(short *src,short *dest,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV     EDI,[dest]
		MOV	CX,[lng]     ; CX : compteur

	COPY_LOOP:
		MOV	AX,WORD PTR [ESI]
		MOV	WORD PTR [EDI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	COPY_LOOP
	}
}

void inver_v_int(short *src,short *dest,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV     EDI,[dest]
		MOV	CX,[lng]     ; CX : compteur
		MOVSX   EBX,CX
		DEC     EBX
		ADD     EBX,EBX
		ADD     EDI,EBX

	INVERS_LOOP:
		MOV	AX,WORD PTR [ESI]
		MOV	WORD PTR [EDI],AX
		ADD	ESI,2
		SUB     EDI,2
		DEC	CX
		JNE	INVERS_LOOP
	}
}

void long_to_long(long *src,long *dest,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV     EDI,[dest]
		MOV	CX,[lng]     ; CX : compteur

	COPY_LOOP2:
		MOV	EAX,DWORD PTR [ESI]
		MOV	DWORD PTR [EDI],EAX
		ADD	ESI,4
		ADD     EDI,4
		DEC	CX
		JNE	COPY_LOOP2
	}
}

void init_zero(short *src,short lng)
{
	_asm
	{
		MOV	ESI,[src]
		MOV	CX,[lng]     ; CX : compteur
		MOV     AX,0

	COPY_LOOP3:
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		DEC	CX
		JNE	COPY_LOOP3
	}
}



#if 0
// PhilF: The following is never called!!!
void update_dic(short *y1,short *y2,short hy[],short lng,short i0,short fact)
{
	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]
		MOV	CX,[i0]       ; CX : compteur
		MOV     DX,CX

	UPDAT_LOOP1:
		MOV	AX,WORD PTR [EDI]     ; y1 = y2 for (i=0..i0-1)
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		DEC	CX
		JNE	UPDAT_LOOP1

		MOV     EBX,[hy]
		MOV     CX,[lng]
		SUB     CX,DX          ; CX = lng-i0 = compteur

		MOV     AX,[fact]
		ADD     AX,0
		JL      FACT_NEG

	UPDAT_LOOP2:
		MOV	AX,WORD PTR [EDI]     ; AX = y2[i]
		MOV     DX,WORD PTR [EBX]
		ADD     AX,DX
		ADD     AX,DX          ; AX = y2[i] + 2*hy[i]
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		ADD     EBX,2
		DEC	CX
		JNE	UPDAT_LOOP2

		JMP     FIN_UPDT
	FACT_NEG:
		MOV     AX,WORD PTR [EDI]     ; AX = y2[i]
		MOV     DX,WORD PTR [EBX]
		SUB     AX,DX
		SUB     AX,DX	       ; AX = y2[i] - 2*hy[i]
		MOV	WORD PTR [ESI],AX
		ADD	ESI,2
		ADD     EDI,2
		ADD     EBX,2
		DEC	CX
		JNE	FACT_NEG

	FIN_UPDT:
	}
}
#endif

void update_ltp(short *y1,short *y2,short hy[],short lng,short gdgrd,short fact)
{
	short arrondi;

	_asm
	{
		MOV	ESI,[y1]
		MOV     EDI,[y2]

		MOV     BX,[fact]
		MOV     CX,[gdgrd]       ; CX = bit de garde
		ADD     CX,0
		JE      BDG_NUL
		DEC     CL
		SAR     BX,CL
		ADD     BX,1
		SAR     BX,1
		INC     CL
	BDG_NUL:
		MOV     WORD PTR [ESI],BX
		ADD     ESI,2
		ADD     CL,11

		MOV     AX,1
		SAL     AX,CL
		MOV     [arrondi],AX            ; [BP-2] = arrondi
		INC     CL

		SUB     WORD PTR [lng],1

		MOV     BX,[fact]

	UPDAT_LTP:
		XCHG    ESI,[hy]
		MOV	AX,WORD PTR [ESI]     ; AX = hy[i]
		IMUL    BX             ; DX:AX = fact*hy
		ADD     AX,[arrondi]      ;arrondi
		ADC     DX,0
		SHRD    AX,DX,CL
		ADD     AX,WORD PTR [EDI]
		ADD     ESI,2           ; increm.
		ADD     EDI,2
		XCHG    ESI,[hy]
		MOV     WORD PTR [ESI],AX
		ADD     ESI,2
		SUB     WORD PTR [lng],1
		JG      UPDAT_LTP
	}
}

void proc_gain2(long *corr_ene,long *gain,short bit_garde)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EAX,0
		MOV     EBX,DWORD PTR [ESI+4]    ;EBX = ener
		ADD     EBX,0
		JE      G_ENER_NULL2

		MOV     CX,[bit_garde]
		ADD     CL,19
		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr
		CDQ
		SHLD    EDX,EAX,CL       ;
		SAL     EAX,CL
		IDIV    EBX
	G_ENER_NULL2:

		MOV     ESI,[gain]       ; DS:SI  adresse resultat
		MOV     DWORD PTR [ESI],EAX
	}
}


#if 0
void proc_gain(long *corr_ene,long *gain)
{
	_asm
	{
		MOV     ESI,[corr_ene]       ; DS:SI  adresse correlation et energie
		MOV     EAX,0
		MOV     EBX,DWORD PTR [ESI+4]    ;EBX = ener
		ADD     EBX,0
		JE      G_ENER_NULL

		MOV     EAX,DWORD PTR [ESI]      ; EAX = corr
		CDQ
		SHLD    EDX,EAX,13
		SAL     EAX,13
		IDIV    EBX
	G_ENER_NULL:
		MOV     ESI,[gain]       ; DS:SI  adresse resultat
		MOV     DWORD PTR [ESI],EAX
	}
}
#else
void proc_gain(long *corr_ene,long gain)
{
	_asm
	{
		MOV		ESI,[corr_ene]
		MOV		EAX,0
		MOV		EBX,DWORD PTR [ESI+4]	;EBX = energy
		ADD		EBX,0
		JLE		G_ENER_NULL				; REPLACED JE BY JLE: ENERGY MUST BE POSITIVE

		MOV		EAX,DWORD PTR [ESI]		; EAX = correlation
		CDQ
		SHLD	EDX,EAX,13
		SAL		EAX,13

		; ----------------------------------------------
		; AT THIS POINT, EDX:EAX contains the dividend, EBX the divisor. HERE IS THE ADDED CHECK

		MOV		ECX,EDX					; COPY EDX IN ECX
		CMP		ECX,0					; CHECK SIGN OF ECX
		JGE		G_CORR_POS
		NEG		ECX						; IF ECX IS NEGATIVE, TAKE ABS(ECX)
		SAL		ECX,2					; AND COMPARE ECX<<2 WITH EBX
		CMP		ECX,EBX					; IF (ECX<<2) >= EBX, THERE IS A RISK OF OVERFLOW,
		JL		G_NO_OVERFLOW			; IN THAT CASE WE SAVE A BIG VALUE IN EAX
		MOV		EAX,-2147483647			; (NEGATIVE BECAUSE EDX<0)
		JMP		G_ENER_NULL				; AND WE EXIT

	G_CORR_POS:
		SAL		ECX,2
		CMP		ECX,EBX					; THE SAME CHECKING FOR THE CASE EDX>0
		JL		G_NO_OVERFLOW			; BUT HERE WE SAVE A BIG POSITIVE VALUE
		MOV		EAX,2147483647			; IN CASE OF OVERFLOW
		JMP		G_ENER_NULL

	G_NO_OVERFLOW:
		; END OF ADDED CODE
		;-------------------------------------------------

		IDIV	EBX						; IF THERE IS NO RISK OF OVERFLOW, WE MAKE THE DIV
	G_ENER_NULL:
		MOV		ESI,[gain]
		MOV		DWORD PTR [ESI],EAX
	}
}
#endif

void decode_dic(short *code,short dic,short npuls)
{
	_asm
	{
		MOV	ESI,[code]
		MOVSX	ECX,[npuls]
		DEC     ECX
		ADD	ECX,ECX          ; CX = deplacement
		ADD     ESI,ECX
		MOV     BX,[dic]     ; BX = Dictionnaire
		MOV     AX,1           ; AX = Mask
		MOV	CX,[npuls]     ; CX : compteur
		DEC     CX
	dic_loop:
		MOV     DX,BX          ; DX = dec
		AND     DX,AX          ; Masquer
		JNZ     NO_NUL         ; Saut si non null
		MOV	WORD PTR [ESI],-1
		JMP     NDAO
	NO_NUL:
		MOV     WORD PTR [ESI],1
	NDAO:
		SUB     ESI,2
		ADD	AX,AX
		DEC	CX
		JNE	dic_loop
	}
}

void dsynthesis(long *z,short *coef,short *input,short *output,
						short lng,short netages)
{
	short depl,count;

	_asm
	{
		MOV     CX,[netages]   ; CX = filter order
		ADD	CX,CX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       ; [BP-2] = deplacement

	DSYNTH_GEN:
		MOV	EDI,[z]

		MOV     ESI,[input]           		; FS:[SI] input
		MOVSX   EBX,WORD PTR [ESI]	 	; EBX = entre
		NEG     EBX
		SAL     EBX,16
		ADD     DWORD PTR [input],2	  	; increm.
		MOV     DWORD PTR [EDI],EBX            	; mise  jour mmoire

		MOV     ESI,[coef]

		MOVSX   ECX,[depl]
		ADD     ESI,ECX
		ADD     EDI,ECX
		ADD     EDI,ECX

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX
		MOV     EBX,0
		MOV     ECX,0
	DSYNTHL:
		MOV     EAX,DWORD PTR [EDI]            ;EAX = Zi
		MOV     DWORD PTR [EDI+4],EAX           ;update memory
		MOVSX   EDX,WORD PTR [ESI]		   ;EDX = Ai
		IMUL    EDX                    ;EDX:EAX = Zi*Ai
		SUB     ECX,EAX
		SBB     EBX,EDX                ;Acc en EBX:ECX
		SUB     EDI,4                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1
		JGE     DSYNTHL

		ADD     ECX,512
		ADC     EBX,0
		SHLD    EBX,ECX,22

		ADD     EDI,8
		MOV     DWORD PTR [EDI],EBX             ; mise  jour mmoire

		MOV     ESI,[output]
		ADD     EBX,32768
		SAR     EBX,16
		MOV     WORD PTR [ESI],BX              ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1  ;decrem compt
		JG      DSYNTH_GEN
	}
}

void synthesis(short *z,short *coef,short *input,short *output,
				short lng,short netages,short bdgrd )
{
	short depl,count,coeff;

	_asm
	{
		MOV     CX,[netages]   ; CX = filter order
		ADD     CX,CX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       ; [BP-2] = deplacement

		MOV     ESI,[coef]
		MOV     AX,WORD PTR [ESI]
		MOV     [coeff],AX
		MOV     CX,[bdgrd]
		SAR     AX,CL
		MOV     WORD PTR [ESI],AX

	SYNTH_GEN:
		MOV	EDI,[z]

		MOV     ESI,[input]           ; FS:[SI] input
		MOV     BX,WORD PTR [ESI]           ; BX = entre
		NEG     BX
		ADD     DWORD PTR [input],2  ; increm.
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[coef]

		ADD     SI,[depl]
		ADD     DI,[depl]

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX

		MOV     CX,0
		MOV     BX,0
	SYNTHL:
		MOV     AX,WORD PTR [EDI]             ;AX = Zi
		MOV     WORD PTR [EDI+2],AX           ;update memory
		MOV     DX,WORD PTR [ESI]             ;DX = Ai
		IMUL    DX                     ;DX:AX = Zi*Ai
		SUB     BX,AX
		SBB     CX,DX                  ;acc. en CX:BX

		SUB     EDI,2                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1   ;Decrem. compt.
		JGE     SYNTHL

		ADD	BX,512                 ;arrondi
		ADC     CX,0
		SHRD    BX,CX,10

		ADD     EDI,4
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[output]
		MOV     WORD PTR [ESI],BX       ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1    ;Decrem. compt.
		JG      SYNTH_GEN

		MOV     ESI,[coef]
		MOV     AX,[coeff]
		MOV     WORD PTR [ESI],AX
	}
}

void synthese(short *z,short *coef,short *input,short *output,
						short lng,short netages)
{
	short depl,count;

	_asm
	{
		MOV     CX,[netages]   ; CX = filter order
		ADD	CX,CX           ;Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       ; [BP-2] = deplacement

	SYNTH_GEN2:
		MOV	EDI,[z]
		MOV     ESI,[input]           ; FS:[SI] input
		MOV     BX,WORD PTR [ESI]           ; BX = entre
		NEG     BX
		ADD     DWORD PTR [input],2  ; increm.
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[coef]

		ADD     SI,[depl]
		ADD     DI,[depl]

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX

		MOV     CX,0
		MOV     BX,0
	SYNTHL2:
		MOV     AX,WORD PTR [EDI]             ;AX = Zi
		MOV     WORD PTR [EDI+2],AX           ;update memory
		MOV     DX,WORD PTR [ESI]             ;DX = Ai
		IMUL    DX                     ;DX:AX = Zi*Ai
		SUB     BX,AX
		SBB     CX,DX                  ;acc. en CX:BX

		SUB     EDI,2                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1   ;Decrem. compt.
		JGE     SYNTHL2

		ADD	BX,512                 ;arrondi
		ADC     CX,0
		SHRD    BX,CX,10

		ADD     EDI,4
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[output]
		MOV     WORD PTR [ESI],BX       ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1    ;Decrem. compt.
		JG      SYNTH_GEN2
	}
}

void f_inverse(short *z,short *coef,short *input,short *output,
						short lng,short netages )
{
	short depl,count;

	_asm
	{
		MOV     CX,[netages]   		; CX = filter order
		ADD		CX,CX                   ; Dfinir un Deplacement d'adresse vect. source
		MOV     [depl],CX       	; [BP-2] = deplacement

	INVER_GEN:
		MOV		EDI,[z]

		MOV     ESI,[input]             ; FS:[SI] input
		MOV     BX,WORD PTR [ESI]             ; BX = entre
		ADD     DWORD PTR [input],2 	 ; increm.
		MOV     WORD PTR [EDI],BX             ; mise  jour mmoire

		MOV     ESI,[coef]

		ADD     SI,[depl]
		ADD     DI,[depl]

		MOV     CX,[netages]         ;Charger ordre du filtre
		MOV     [count],CX            ;BP-4 : compteur
		MOV     CX,0
		MOV     BX,0
	INVERL:
		MOV     AX,WORD PTR [EDI]             ;AX = Zi
		MOV     WORD PTR [EDI+2],AX           ;update memory
		MOV     DX,WORD PTR [ESI]             ;DX = Ai
		IMUL    DX                     ;DX:AX = Zi*Ai

		ADD     CX,AX
		ADC     BX,DX                  ; acc. en BX:CX

		SUB     EDI,2                   ;Incrementer
		SUB     ESI,2                   ;
		SUB     WORD PTR [count],1
		JGE     INVERL

		MOV     ESI,[output]
		ADD	CX,512                ;arrondi
		ADC     BX,0
		SHRD    CX,BX,10

		MOV     WORD PTR [ESI],CX                 ; sauver output
		ADD     DWORD PTR [output],2

		SUB     WORD PTR [lng],1      ;decrem.
		JG      INVER_GEN
	}
}

void filt_iir(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre)
{
	long off_coef,off_mem,delta;
	long acc_low;

	_asm
	{
		MOVSX   ECX,[ordre]      ;ordre du filtre
		SAL		ECX,3            ;Dfinir un Deplacement d'adresse
		MOV     [off_coef],ECX   ; [OFF_COEF] = deplacement pour coeff
		ADD     ECX,4
		MOV     [off_mem],ECX    ; [OFF_MEM] = depl. pour mem.

		ADD     ECX,20
		SAR     ECX,1
		MOV     [delta],ECX


	IIR_FIL:
		MOV     CX,[ordre]            ;init compteur
		MOV     EBX,[Vin] 	      ; BX = offset input
		MOVSX   EDX,WORD PTR [EBX]  ; EDX = input avec extension de signe
		ADD     DWORD PTR [Vin],2   ; incrmenter l'offset de input

		MOV     ESI,[zx]    	      ; DS:SI pointe zx

		MOV     DWORD PTR [ESI],EDX           ; mettre  jour zx

		MOV     EDI,[ai]    	      ; ES:DI pointe coeff

		ADD     EDI,[off_coef]
		ADD     ESI,[off_mem]

		MOV     DWORD PTR [acc_low],0   ; initialiser ACC_LOW  0
		SUB     EBX,EBX               ; init EBX = 0

	F_IIR_Y:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zx
		MOV     DWORD PTR [ESI+4],EAX         ;mettre  jour zx
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff

		IMUL    EDX                   ;EDX:EAX = zx*coeff
		SUB     [acc_low],EAX         ; accumuler les LSB
		SBB     EBX,EDX               ; acc avec borrow les MSB
		SUB     EDI,4                  ;Incrementer
		SUB     ESI,4                  ;
		DEC		CX
		JNE		F_IIR_Y


		SUB     ESI,4
		MOV     CX,[ordre]            ;Charger ordre du filtre
		INC     CX

	F_IIR_X:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zy
		MOV     DWORD PTR [ESI+4],EAX         ;update zy
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff
		IMUL    EDX                   ;EDS:EAX = zy*coeff
		ADD     [acc_low],EAX         ;acc LSB
		ADC     EBX,EDX               ;acc avec carry MSB
		SUB     EDI,4                  ;Decrementer
		SUB     ESI,4                  ;
		DEC		CX
		JNE		F_IIR_X

		MOV		EAX,[delta]
		ADD     ESI,EAX
		MOV     EAX,[acc_low]         ; EAX = LSB de l'acc.
		ADD     EAX,8192              ; arrondi
		ADC     EBX,0
		SHRD    EAX,EBX,14            ; cadrer
		MOV     DWORD PTR [ESI],EAX           ; mettre  jour zy

		SAR     EAX,14	              ; cadrer en x4.0
					; logique saturante
		CMP     EAX,32767
		JG      SATUR_POS             ; jump if ov
		CMP     EAX,-32767
		JL      SATUR_NEG
		JMP		NEXT

	SATUR_POS:
		MOV      AX,32767
		JMP      NEXT
	SATUR_NEG:
		MOV      AX,-32767
		JMP      NEXT

	NEXT:
		MOV     ESI,[Vout]             ;di offset output
		MOV     WORD PTR [ESI],AX	      ;sauver output
		ADD     DWORD PTR [Vout],2      ;incrmenter offset
		SUB     WORD PTR [lfen],1
		JNZ	IIR_FIL
	}
}


#if 0
// PhilF: The following is never called!!!
void filt_iir_a(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre)
{
	short off_coef,off_mem,delta;
	long acc_low;

	_asm
	{

		MOV     CX,[ordre]      ;ordre du filtre
		SAL	CX,3            ;Dfinir un Deplacement d'adresse
		MOV     [off_coef],CX   ; [OFF_COEF] = deplacement pour coeff
		ADD     CX,4
		MOV     [off_mem],CX    ; [OFF_MEM] = depl. pour mem.

		ADD     CX,20
		SAR     CX,1
		MOV     [delta],CX


	A_IIR_FIL:
		MOV     CX,[ordre]            ;init compteur
		MOV     EBX,[Vin] 	      ; BX = offset input
		MOVSX   EDX,WORD PTR [EBX]  ; EDX = input avec extension de signe
		ADD     WORD PTR [Vin],2   ; incrmenter l'offset de input

		MOV     ESI,[zx]    	      ; DS:SI pointe zx

		MOV     DWORD PTR [ESI],EDX           ; mettre  jour zx

		MOV     EDI,[ai]    	      ; ES:DI pointe coeff

		ADD     DI,[off_coef]
		ADD     SI,[off_mem]

		MOV     DWORD PTR [acc_low],0   ; initialiser ACC_LOW  0
		SUB     EBX,EBX               ; init EBX = 0

	F_IIR_Y_A:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zx
		MOV     DWORD PTR [ESI+4],EAX         ;mettre  jour zx
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff

		IMUL    EDX                   ;EDX:EAX = zx*coeff
		SUB     [acc_low],EAX         ; accumuler les LSB
		SBB     EBX,EDX               ; acc avec borrow les MSB
		SUB     EDI,4                  ;Incrementer
		SUB     ESI,4                  ;
		DEC	CX
		JNE	F_IIR_Y_A


		SUB     ESI,4
		MOV     CX,[ordre]            ;Charger ordre du filtre
		INC     CX

	F_IIR_X_A:
		MOV     EAX,DWORD PTR [ESI]           ;EAX = *zy
		MOV     DWORD PTR [ESI+4],EAX         ;update zy
		MOV     EDX,DWORD PTR [EDI]           ;EDX = coeff
		IMUL    EDX                   ;EDS:EAX = zy*coeff
		ADD     [acc_low],EAX         ;acc LSB
		ADC     EBX,EDX               ;acc avec carry MSB
		SUB     EDI,4                  ;Decrementer
		SUB     ESI,4                  ;
		DEC	CX
		JNE	F_IIR_X_A


		MOVSX	EAX,[delta]
		ADD     ESI,EAX
		MOV     EAX,[acc_low]         ; EAX = LSB de l'acc.
		ADD     EAX,8192              ; arrondi
		ADC     EBX,0
		SHRD    EAX,EBX,14            ; cadrer
		MOV     DWORD PTR [ESI],EAX           ; mettre  jour zy

		ADD     EAX,32768
		SAR     EAX,16	              ; cadrer en x4.0
		MOV     ESI,[Vout]             ;di offset output
		MOV     WORD PTR [ESI],AX	      ;sauver output
		ADD     WORD PTR [Vout],2      ;incrmenter offset
		SUB     WORD PTR [lfen],1
		JNZ     A_IIR_FIL
	}
}
#endif

void mult_fact(short src[],short dest[],short fact,short lng)
{
	_asm
	{
		MOV     ESI,[src]
		MOV     EDI,[dest]
		MOV     BX,[fact]         ; BX = Factor

		MOV     CX,[lng]          ; init compteur

	MULT_F:
		MOV     AX,WORD PTR [ESI]        ; AX = src
		IMUL	BX                ; DX:AX = src*fact
		ADD     AX,4096
		ADC     DX,0
		SHRD    AX,DX,13          ; cadrer
		MOV	WORD PTR [EDI],AX        ;save
		ADD     ESI,2              ;incrmenter
		ADD     EDI,2
		DEC	CX
		JNE	MULT_F
	}
}

void mult_f_acc(short src[],short dest[],short fact,short lng)
{
	_asm
	{
		MOV     EDI,[src]
		MOV     ESI,[dest]
		MOV     BX,[fact]         ; BX = Factor

		MOV     CX,[lng]          ; init compteur

	MULT_F_A:
		MOV     AX,WORD PTR [EDI]        ; AX = src
		IMUL	BX                ; DX:AX = src*fact
		ADD     AX,4096
		ADC     DX,0
		SHRD    AX,DX,13          ; cadrer
		ADD     WORD PTR [ESI],AX        ; Accumuler   dest = dest + src*fact
		ADD     ESI,2              ;incrmenter
		ADD     EDI,2
		DEC	CX
		JNE	MULT_F_A
	}
}

void dec_lsp(short *code,short *tablsp,short *nbit,short *bitdi,short *tabdi)
{
	short compt;
	long pointer;

	_asm
	{
		MOV     EDI,[tablsp]
		MOV     ESI,[code]

		MOVSX   EBX,WORD PTR [ESI]        ; BX = depl.
		ADD	EBX,EBX
		MOV     AX,WORD PTR [EDI+EBX]     ; AX = code[0];
		MOV     WORD PTR [ESI],AX        ;
		ADD     ESI,4              ;

		MOV     CX,4              ; init compteur


	LSP_PAIR:
		MOV     EBX,[nbit]         ; lsptab += nbit[i]
		MOVSX   EAX,WORD PTR [EBX]        ; AX = nbit[i]
		ADD     EAX,EAX
		ADD     EDI,EAX             ;
		ADD     EBX,2              ; increm
		MOV     [nbit],EBX

		MOVSX   EBX,WORD PTR [ESI]        ; BX = depl.
		ADD     EBX,EBX
		MOV     AX,WORD PTR [EDI+EBX]     ; AX = code[i];
		MOV     WORD PTR [ESI],AX       ;
		ADD     ESI,4
		DEC	CX
		JNE	LSP_PAIR

		ADD     DWORD PTR [nbit],2

		MOV     EDI,[tabdi]
		SUB     ESI,20            ; pointer code[0]

		MOV     WORD PTR [compt],5

	REPEAT_DEC:
		MOV     EBX,[bitdi]
		MOV     CX,WORD PTR [EBX]       ;
		MOV     BX,WORD PTR [ESI+4]     ; BX = lsp[2*k+2]
		SUB     BX,WORD PTR [ESI]       ;    = lsp[2*k+2]-lsp[2*k] = delta
					 ; ne pas faire /2 --> pas de corr. signe *
		MOV     EAX,[nbit]
		MOV     [pointer],EAX

	LOOP_DI1:
		MOV     AX,WORD PTR [EDI]       ; AX = TABDI
		ADD     EDI,2
		IMUL    BX               ; DX:AX = tabdi * delta
		ADD     AX,32768
		ADC     DX,0             ;arrondi
		ADD     DX,WORD PTR [ESI]
		XCHG    ESI,[pointer]
		MOV     WORD PTR [ESI],DX       ; sauver
		ADD     ESI,2
		XCHG    ESI,[pointer]
		DEC	CX
		JNE	LOOP_DI1


		MOV     DX,BX
		MOV     EBX,[bitdi]
		MOV     CX,WORD PTR [EBX]       ;
		ADD     ESI,4
		SUB     CX,2
		JLE     IALAO
		MOV     BX,DX
		NEG     BX
	LOOP_DI2:
		MOV     AX,WORD PTR [EDI]       ; AX = TABDI
		ADD     EDI,2
		IMUL    BX               ; DX:AX = tabdi * delta
		ADD     DX,WORD PTR [ESI]
		XCHG    ESI,[pointer]
		MOV     WORD PTR [ESI],DX       ; sauver
		ADD     ESI,2
		XCHG    ESI,[pointer]
		DEC	CX
		JNE	LOOP_DI2

	IALAO:
		ADD     DWORD PTR [bitdi],2        ;

		MOV     EBX,[nbit]        ; BX = adresse de veclsp

		SUB     ESI,2             ; pointer code[2*k+1]
		MOVSX   EAX,WORD PTR [ESI]
		ADD	EAX,EAX            ; AX = depl.

		ADD     EBX,EAX

		MOV     AX,WORD PTR [EBX]       ; AX = veclsp[code[2*k+1]
		MOV     WORD PTR [ESI],AX
		ADD     ESI,2
		SUB     WORD PTR [compt],1
		JNZ     REPEAT_DEC
	}
}

void teta_to_cos(short *tabcos,short *lsp,short netages)
{
	short norm,arrondi,ptm1,lts2;

	_asm
	{
		MOV     EDI,[lsp]

		MOV     CX,[netages]        ;init compteur

	TETA_LOOP:
		MOV     AX,WORD PTR [EDI]        ; AX = lsp[i]
		CMP     AX,04000H         ; comparer  4000h

		JLE     INIT_VAL          ;
		NEG     AX
		ADD     AX,32767          ; prendre le complment
	INIT_VAL:
		MOV     ESI,[tabcos]
		CMP     AX,0738H          ; comparer 
		JG      BIGTABLE

	;SMALLTAB:
		ADD     ESI,550            ; pointer tabteta2
		MOV     WORD PTR [ptm1],3
		MOV     WORD PTR [lts2],16
		MOV     WORD PTR [arrondi],512
		MOV     WORD PTR [norm],10
		JMP     DEBUT_LP

	BIGTABLE:
		ADD     ESI,258             ; pointer tabteta1
		MOV     WORD PTR [ptm1],6
		MOV     WORD PTR [lts2],128
		MOV     WORD PTR [arrondi],64
		MOV     WORD PTR [norm],7

	DEBUT_LP:
		MOVSX   EDX,[lts2]          ; init incrment
		ADD     ESI,EDX              ; SI = index

		MOV     CX,[ptm1]
	LOCAL_L:
		SAR     EDX,1               ; increm >> 1
		CMP     AX,WORD PTR [ESI]
		JG      ADD_INCRM
		SUB     ESI,EDX
		JMP     AURORA
	ADD_INCRM:
		ADD     ESI,EDX
	AURORA:
		DEC	CX
		JNE	LOCAL_L


		CMP     AX,WORD PTR [ESI]
		JG      INTERP_V
		SUB     ESI,2
	INTERP_V:
		SUB     AX,WORD PTR [ESI]         ; AX = teta - tabteta[index]
		MOV	DX,AX
		MOV	AX,0
		MOV     CX,WORD PTR [ESI+2]
		SUB     CX,WORD PTR [ESI]         ; CX = tabteta[index+1]-tabteta[index]
		ADD	CX,CX              ; multiplier par 2 pour ne pas SHRD de DX:AX
		DIV     CX
		ADD     AX,[arrondi]       ;
		MOV     CX,[norm]          ; CX = normalisation
		SAR     AX,CL
		NEG     AX

		CMP     CX,7
		JE      GRAN_TAB
		SUB     ESI,34
		ADD     AX,WORD PTR [ESI]         ;AX = tabcos[index]+delta
		JMP     ADD_SIGN

	GRAN_TAB:
		SUB     ESI,258
		ADD     AX,WORD PTR [ESI]         ;AX = tabcos[index]+delta
	ADD_SIGN:
		CMP     WORD PTR [EDI],04000H
		JLE     END_LOOP
		NEG     AX
	END_LOOP:
		MOV     WORD PTR [EDI],AX          ; save cos
		ADD     EDI,2
		SUB     WORD PTR [netages],1
		JG      TETA_LOOP
	}
}


void cos_to_teta(short *tabcos,short *lsp,short netages)
{
	_asm
	{
		MOV     EDI,[lsp]

		MOV     CX,[netages]        ;init compteur

	COS_LOOP:
		MOV     ESI,[tabcos]
		ADD     ESI,258
		MOV     AX,WORD PTR [EDI]        ; AX = lsp[i]
		ADD     AX,0

		JGE     DEBUT_CS          ; prendre ABS
		NEG     AX
	DEBUT_CS:
		CMP     AX,07DFFH         ; comparer  7DFFh
		JGE     TABLE2
	;TABLE1:
		MOV     BX,AX
		AND     BX,0FFH           ; BX = cos & mask

		MOV     CL,8
		SAR     AX,CL
		ADD	AX,AX
		MOV     EDX,256            ; BX index
		SUB     DX,AX
		ADD     ESI,EDX

		MOV     AX,WORD PTR [ESI]        ; AX=teta[index]
		SUB     AX,WORD PTR [ESI-2]      ;
		IMUL    BX
		ADD     AX,128
		ADC     DX,0
		SHRD    AX,DX,8              ; cadrer
		NEG     AX

		MOV     BX,WORD PTR [ESI]
		ADD     AX,BX

		MOV     BX,WORD PTR [EDI]        ; tester signe de lsp
		ADD     BX,0
		JGE     END_COS
		NEG     AX
		ADD     AX,07FFFH         ; AX = 7fff-AX
		JMP     END_COS

	TABLE2:
		ADD     ESI,292            ; pointer tabteta2
		MOV     BX,AX             ; BX = AX

		SUB     AX,07DFFH         ; retirer delta
		MOV     CL,5
		SAR     AX,CL
		ADD	AX,AX
		MOV     EDX,32             ; DX index
		SUB     DX,AX
		ADD     ESI,EDX

		MOV     AX,WORD PTR [ESI]        ; AX=teta2[index]

		CMP     BX,AX
		JGE     NO_INCRM
		ADD     ESI,2
	NO_INCRM:
		MOV     AX,WORD PTR [ESI]        ; AX=teta2[index]
		MOV     CX,AX             ; pour plus tard
		SUB     AX,WORD PTR [ESI-2]      ;

		SUB     ESI,34             ; pointer tabcos2
		SUB     BX,WORD PTR [ESI]        ;

		IMUL    BX

		ADD     AX,16
		ADC     DX,0
		SHRD    AX,DX,5            ; cadrer
		NEG     AX

		ADD     AX,CX             ; AX = cos + delta

		MOV     BX,WORD PTR [EDI]        ; tester signe de lsp
		ADD     BX,0
		JGE     END_COS
		NEG     AX
		ADD     AX,07FFFH         ; AX = 7fff-AX

	END_COS:
		MOV     WORD PTR [EDI],AX        ;
		ADD     EDI,2
		SUB     WORD PTR [netages],1
		JG      COS_LOOP
	}
}

void lsp_to_ai(short *ai_lsp,long *tmp,short netages)
{
	short cmptr;
	long index;

	_asm
	{
		MOV     ESI,[tmp]
		MOV     EBX,ESI
		ADD     EBX,4*11           ;DS:BX vect. Q

		MOV     EDI,[ai_lsp]
	;LSP_AI:
		MOV     DWORD PTR [ESI],0400000H     ; P(0) = 1
		MOV     DWORD PTR [ESI+8],0400000H   ; P(2) = 1
		MOV     DWORD PTR [EBX],0400000H     ; Q(0) = 1
		MOV     DWORD PTR [EBX+8],0400000H   ; Q(2) = 1

		MOVSX   EAX,WORD PTR [EDI] ; EAX = lsp(0)
		SAL     EAX,8
		NEG     EAX                  ; EAX = -lsp(0)>>8
		MOV     DWORD PTR [ESI+4],EAX        ;P(1) = EAX

		MOVSX   EAX,WORD PTR [EDI+2] ; EAX = lsp(1)
		SAL     EAX,8
		NEG     EAX                  ; EAX = -lsp(1)>>8
		MOV     DWORD PTR [EBX+4],EAX        ; Q(1) = EAX
		MOV     WORD PTR [cmptr],1    ;init compteur
		SUB     WORD PTR [netages],2
		ADD     EBX,8
		MOV     [index],EBX           ; sauver BX = i

		ADD     ESI,8                 ; DS:SI  P(2)
		ADD     EDI,4                 ; ES:DI  lsp(2)
		MOV     CX,[netages]

	GL_LOOP:
		MOV     [netages],CX
		MOV     DWORD PTR [ESI+8],0400000H     ; P(i+2) = 1

		MOVSX   EAX,WORD PTR [EDI] ; EAX = lsp(i)
		MOV     EBX,EAX              ; memoriser lsp(i)
		SAL     EAX,8
		MOV     ECX,DWORD PTR [ESI-4]        ; ECX = P(i-1)
		SUB     ECX,EAX              ; ECX = P(i-1) - lsp(i)<<8
		MOV     DWORD PTR [ESI+4],ECX        ; P(i+1)=ECX


		MOV     CX,[cmptr]           ;
	LOCAL_P:
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = P(j-1)
		IMUL    EBX                  ; EDX:EAX = P(j-1)*lsp(i)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*P(j-1)*lsp(i)
		SUB     DWORD PTR [ESI],EAX          ; P(j)=P(j)-EAX
		MOV     EAX,DWORD PTR [ESI-8]        ; EAX = P(j-2)
		ADD     DWORD PTR [ESI],EAX          ; P(j) += P(j-2)
		SUB     ESI,4
		DEC	CX
		JNE	LOCAL_P

					     ; DS:SI pointe P(1)
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = P(0)
		IMUL    EBX                  ; EDX:EAX = P(0)*lsp(i)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*P(0)*lsp(i)
		SUB     DWORD PTR [ESI],EAX          ; P(1) = P(1)-2*P(0)*lsp(i)

		XCHG    ESI,[index]           ; DS:SI pointe Q(j)

		MOV     DWORD PTR [ESI+8],0400000H   ; Q(i+2) = 1
		MOVSX   EAX,WORD PTR [EDI+2] ; EAX = lsp(i+1)
		MOV     EBX,EAX              ; memoriser lsp(i+1)
		SAL     EAX,8
		MOV     ECX,DWORD PTR [ESI-4]        ; ECX = Q(i-1)
		SUB     ECX,EAX              ; ECX = Q(i-1) - lsp(i+1)<<8
		MOV     DWORD PTR [ESI+4],ECX        ; Q(i+1)=ECX

		MOV     CX,[cmptr]           ;
	LOCAL_Q:
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = Q(j-1)
		IMUL    EBX                  ; EDX:EAX = Q(j-1)*lsp(i+1)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*Q(j-1)*lsp(i+1)
		SUB     DWORD PTR [ESI],EAX          ; Q(j)=Q(j)-EAX
		MOV     EAX,DWORD PTR [ESI-8]        ; EAX = Q(j-2)
		ADD     DWORD PTR [ESI],EAX          ; Q(j) += Q(j-2)
		SUB     ESI,4
		DEC	CX
		JNE	LOCAL_Q

					     ; DS:SI pointe Q(1)
		MOV     EAX,DWORD PTR [ESI-4]        ; EAX = Q(0)
		IMUL    EBX                  ; EDX:EAX = Q(0)*lsp(i+1)
		ADD     EAX,8192
		ADC     EDX,0
		SHRD    EAX,EDX,14           ; EAX = 2*Q(0)*lsp(i+1)
		SUB     DWORD PTR [ESI],EAX          ; Q(1) = Q(1)-2*Q(0)*lsp(i+1)

		MOVSX   ECX,[cmptr]
		ADD     CX,2
		MOV     [cmptr],CX

		SAL     ECX,2
		ADD     ESI,ECX                 ; increm. offset de Q
		XCHG    ESI,[index]            ;
		ADD     ESI,ECX                 ; increm. offset de P
		ADD     EDI,4
		MOV     CX,[netages]
		SUB     CX,2
		JG      GL_LOOP

		MOV     ESI,[tmp]         ;DS:SI vect  P
		MOV     EBX,ESI
		ADD     EBX,4*11           ;DS:BX vect. Q

		MOV     EDI,[ai_lsp]       ;ES:DI lsp et ai
		MOV     WORD PTR [EDI],0400H  ; ai(0) = 1
		ADD     EDI,2

		MOV     CX,10             ; init compteur
		ADD     EBX,4              ;
		ADD     ESI,4
	CALC_AI:
		MOV     EAX,DWORD PTR [ESI]         ; EAX = P(i)
		ADD     EAX,DWORD PTR [ESI-4]       ;       +P(i-1)
		ADD     EAX,DWORD PTR [EBX]         ;       +Q(i)
		SUB     EAX,DWORD PTR [EBX-4]       ;       -Q(i-1)
		ADD     EAX,01000H          ; arrondi
		SAR     EAX,13
		MOV     WORD PTR [EDI],AX          ; save ai
		ADD     EDI,2
		ADD     ESI,4
		ADD     EBX,4
		DEC	CX
		JNE	CALC_AI
	}
}


void ki_to_ai(short *ki,long *ai,short netages)
{
	short cmptk;
	long indam1,indexk,kiim1;

	_asm
	{
		MOV     ESI,[ai]
		MOV     EBX,ESI
		ADD     EBX,44             ; DS:BX vect. interm.

		MOV     EDI,[ki]

		MOV     DWORD PTR [ESI],0400000H     ; ai(0) = 1
		MOVSX   EAX,WORD PTR [EDI] ; EAX = ki(0)
		SAL     EAX,7
		MOV     DWORD PTR [ESI+4],EAX        ; ai(1) = EAX

		ADD     ESI,4                 ; DS:SI  ai(1)
		ADD     EBX,8
		ADD     EDI,2                 ; ES:DI  ki(1)

		MOV     WORD PTR [cmptk],1
		MOV     CX,[netages]

	KI_AI_LP:
		MOV     [netages],CX

		MOVSX   EAX,WORD PTR [EDI] ; EAX = ki(i-1)
		MOV     [kiim1],EAX          ; memoriser ki(i-1)

		SAL     EAX,7
		MOV     DWORD PTR [EBX],EAX          ; tmp(i)=EAX

		SUB     EBX,4

		MOV     [indexk],EBX

		MOVSX   ECX,[cmptk]           ;
		MOV     EBX,ECX
		DEC     EBX
		SAL     EBX,2                 ; DI : deplacement
		MOV     [indam1],ESI
		SUB     ESI,EBX
		MOV     EBX,[indexk]
	LOCAL_AI:
		MOV     EAX,DWORD PTR [ESI]          ; EAX = ai(i-j)
		IMUL    DWORD PTR [kiim1] ; EDX:EAX = ai(i-j)*ki(i-1)
		ADD     EAX,16384
		ADC     EDX,0
		SHRD    EAX,EDX,15           ; EAX = ai(i-j)*ki(i-1)
		ADD     ESI,4
		XCHG    ESI,[indam1]
		ADD     EAX,DWORD PTR [ESI]          ;       + ai(j)
		SUB     ESI,4
		XCHG    ESI,[indam1]

		MOV     DWORD PTR [EBX],EAX          ; tmp(j) = EAX
		SUB     EBX,4

		DEC	CX
		JNE	LOCAL_AI


		XCHG    ESI,[indam1]
		MOV     CX,[cmptk]
		INC     CX
		MOV     [cmptk],CX
		ADD     ESI,4
		ADD     EBX,4
	L_COPY:
		MOV     EAX,DWORD PTR [EBX]              ; EAX = tmp(i)
		MOV     DWORD PTR [ESI],EAX              ; ai(i) = EAX
		ADD     EBX,4
		ADD     ESI,4
		DEC	CX
		JNE	L_COPY


		ADD     EDI,2                     ; increm. i

		SUB     ESI,4

		MOV     CX,[netages]
		DEC	CX
		JNE	KI_AI_LP
	}
}

void ai_to_pq(long *aip,short netages)
{
	_asm
	{
		MOV     ESI,[aip]
		MOV     EDI,ESI
		ADD     EDI,4*11          ;DS:DI vect. Q

		MOV     EDX,DWORD PTR [ESI]       ; EAX = ai(0) = P(0)
		MOV     DWORD PTR [EDI],EDX       ; Q(0) = ai(0)
		MOV     CX,[netages]
		MOVSX   EBX,CX
		DEC     EBX
		SAL     EBX,2              ; BX deplacement
		ADD     ESI,4
		ADD     EDI,4
		SAR     CX,1

	AI_LSP1:
		MOV     EAX,DWORD PTR [ESI]       ; EAX = ai(i) = P(i)
		MOV     EDX,EAX           ; memoriser
		ADD     EAX,DWORD PTR [ESI+EBX]       ; + ai(j)
		SUB     EAX,DWORD PTR [ESI-4]     ; - P(i-1)
		MOV     DWORD PTR [ESI],EAX       ; P(i)=EAX
		SUB     EDX,DWORD PTR [ESI+EBX]    ; EDX = ai(i) - ai(j)
		ADD     EDX,DWORD PTR [EDI-4]     ;        - Q(i-1)
		MOV     DWORD PTR [EDI],EDX       ; Q(i)=EDX

		SUB     EBX,8
		ADD     ESI,4
		ADD     EDI,4
		DEC	CX
		JNE	AI_LSP1

		MOV     ESI,[aip]         ;DS:SI vect. PP = P

		MOV     EAX,DWORD PTR [ESI+20]   ;EAX = P(5)
		ADD     EAX,1
		SAR     EAX,1
		SUB     EAX,DWORD PTR [ESI+12]   ;EAX = P(5)/2 - P(3)
		ADD     EAX,DWORD PTR [ESI+4]    ;      + P(1)
		XCHG    DWORD PTR [ESI],EAX      ; PP(0) = EAX et EAX = P(0)
		MOV     EBX,EAX          	 ; save EBX = P(0)
		SAL     EAX,2            	 ; EAX = 2*P(0)
		ADD     EAX,EBX          	 ; EAX = 5*P(0)
		ADD     EAX,DWORD PTR [ESI+16]   ;       + P(4)
		MOV     EDX,DWORD PTR [ESI+8]    ; EDX = P(2)
		ADD     EDX,EDX          	 ;   *2
		ADD     EDX,DWORD PTR [ESI+8]    ; EDX = 3*P(2)
		SUB     EAX,EDX          	 ; EAX = P(4) - 3*P(2) + 5*P(0)
		XCHG    EAX,DWORD PTR [ESI+4]    ; PP(1)=EAX et EAX = P(1)
		MOV     ECX,EAX          ; ECX = P(1)
		SAL     EAX,3            ; *8
		MOV     DWORD PTR [ESI+16],EAX   ; PP(4) = 8*P(1)
		NEG     EAX
		MOV     EDX,DWORD PTR [ESI+12]   ; EDX = P(3)
		ADD     EDX,EDX          ; * 2
		ADD     EAX,EDX          ; EAX = 2*P(3) - 8*P(1)
		XCHG    EAX,DWORD PTR [ESI+8]    ; PP(2) = EAX et EAX = P(2)
		SAL     EAX,2            ; EAX *= 4*P(2)
		SAL     EBX,2            ; EBX = 4*P0
		MOV     EDX,EBX          ; EDX = 4*P(0)
		SAL     EDX,2            ; EDX = 16*P(0)
		MOV     DWORD PTR [ESI+20],EDX   ; PP(5) = 16*P(0)
		ADD     EBX,EDX          ; EDX = 20*P(0)
		NEG     EBX
		ADD     EAX,EBX
		MOV     DWORD PTR [ESI+12],EAX   ; PP(3) = 4*P(2)-20*P(0)

		MOV     EDI,ESI
		ADD     ESI,4*11          ;DS:SI vect. Q
		ADD     EDI,4*6           ;DS:DI vect  QQ

		MOV     EAX,DWORD PTR [ESI+20]   ;EAX = Q(5)
		ADD     EAX,1
		SAR     EAX,1
		SUB     EAX,DWORD PTR [ESI+12]   ;EAX = Q(5)/2 - Q(3)
		ADD     EAX,DWORD PTR [ESI+4]    ;      + Q(1)
		MOV     DWORD PTR [EDI],EAX      ; QQ(0) = EAX
		MOV     EAX,DWORD PTR [ESI]      ; EAX = Q(0)
		MOV     EBX,EAX
		SAL     EAX,2            ; EAX = 2*Q(0)
		ADD     EAX,DWORD PTR [ESI]      ; EAX = 5*Q(0)
		ADD     EAX,DWORD PTR [ESI+16]   ;       + Q(4)
		MOV     EDX,DWORD PTR [ESI+8]    ; EDX = Q(2)
		ADD     EDX,EDX          ;   *2
		ADD     EDX,DWORD PTR [ESI+8]    ; EDX = 3*Q(2)
		SUB     EAX,EDX          ; EAX = Q(4) - 3*Q(2) + 5*Q(0)
		MOV     DWORD PTR [EDI+4],EAX    ; QQ(1)=EAX
		MOV     EAX,DWORD PTR [ESI+4]    ; EAX = Q(1)
		MOV     ECX,EAX          ; ECX = Q(1)
		SAL     EAX,3            ; *8
		MOV     DWORD PTR [EDI+16],EAX   ; QQ(4) = 8*Q(1)
		NEG     EAX
		MOV     EDX,DWORD PTR [ESI+12]   ; EDX = Q(3)
		ADD     EDX,EDX          ; * 2
		ADD     EAX,EDX          ; EAX = 2*Q(3) - 8*Q(1)
		MOV     DWORD PTR [EDI+8],EAX    ; QQ(2) = EAX
		MOV     EAX,DWORD PTR [ESI+8]    ; EAX = Q(2)
		SAL     EAX,2            ; EAX *= 4*Q(2)
		SAL     EBX,2            ; EBX = 4*Q0
		MOV     EDX,EBX          ; EDX = 4*Q(0)
		SAL     EDX,2            ; EDX = 16*Q(0)
		MOV     DWORD PTR [EDI+20],EDX   ; QQ(5) = 16*Q(0)
		ADD     EBX,EDX          ; EDX = 20*Q(0)
		NEG     EBX
		ADD     EAX,EBX
		MOV     DWORD PTR [EDI+12],EAX   ; QQ(3) = 4*Q(2)-20*Q(0)
	}
}

void horner(long *P,long *T,long *a,short n,short s)
{
	_asm
	{
		MOV     ESI,[P]
		MOV     EDI,[T]

		MOV     CX,[n]
		MOVSX   EBX,CX
		SAL     EBX,2
		ADD     ESI,EBX            ; SI : P(n)
		SUB     EBX,4
		ADD     EDI,EBX            ; DI : Q(n-1)

		MOV     EAX,DWORD PTR [ESI]      ; EAX = P(n)
		MOV     DWORD PTR [EDI],EAX        ; Q(n-1) = P(n)

		SUB     ESI,4

		DEC     CX
		MOVSX   EBX,WORD PTR [s]
	LOOP_HNR:
		MOV     EAX,DWORD PTR [EDI]      ; EAX = Q(i)
		IMUL    EBX              ; EDX:EAX = s*Q(i)
		ADD     EAX,16384        ;
		ADC     EDX,0
		SHRD    EAX,EDX,15       ; cadrer
		SUB     EDI,4
		ADD     EAX,DWORD PTR [ESI]      ; EAX = Q(i) = P(i) + s*Q(i)
		MOV     DWORD PTR [EDI],EAX      ;
		SUB     ESI,4
		DEC	CX
		JNE	LOOP_HNR


		MOV     EAX,DWORD PTR [EDI]      ; EAX = Q(0)
		IMUL    EBX              ; EDX:EAX = s*Q(0)
		ADD     EAX,16384        ;
		ADC     EDX,0
		SHRD    EAX,EDX,15       ; cadrer
		ADD     EAX,DWORD PTR [ESI]      ; EAX = P(0) + s*Q(0)

		MOV     ESI,[a]
		MOV     DWORD PTR [ESI],EAX
	}
}

#pragma warning(disable : 4035)
short calcul_s(long a,long b)
{
	_asm
	{
		MOV     EBX,[b]
		ADD     EBX,0
		JGE     B_POSIT
		NEG     EBX
	B_POSIT:
		MOV     CL,0
		CMP     EBX,40000000H   ;normaliser b
		JGE     OUT_NORM
	NORM_B:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H   ;
		JGE     OUT_NORM
		JMP     NORM_B
	OUT_NORM:
		ADD     EBX,16384
		SAR     EBX,15
		MOV     EDX,[b]
		ADD     EDX,0
		JGE     PUT_SIGN
		NEG     EBX
	PUT_SIGN:
		MOV     EAX,[a]
		SAL     EAX,CL           ; shifter a de CL
		CDQ
		IDIV    EBX              ; AX = a/b

		MOV     BX,AX

		IMUL    BX               ; DX:AX = sqr(a/b)
		ADD     AX,8192
		ADC     DX,0
		SHRD    AX,DX,14         ; AX = 2*sqr(a/b)
		MOV     DX,AX
		ADD     DX,1
		SAR     DX,1
		ADD     AX,DX            ; AX = 3*sqr(a/b)
		NEG     AX
		SUB     AX,BX            ; AX = -a/b - 3*sqr(a/b)
	}
}

#pragma warning(default : 4035)

void binome(short *lsp,long *PP)
{
	short inc_sq;
	long sqr;

	_asm
	{
		MOV     EDI,[lsp]
		MOV     ESI,[PP]

		MOV     EBX,DWORD PTR [ESI+8]    ;EBX = PP(2)
		ADD     EBX,0
		JGE     B_POSIT_P
		NEG     EBX
	B_POSIT_P:
		MOV     CL,0
		CMP     EBX,40000000H   ;normaliser PP(2)
		JGE     OUT_NORM_P
	NORM_B_P:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H   ;
		JGE     OUT_NORM_P
		JMP     NORM_B_P
	OUT_NORM_P:
		ADD     EBX,16384
		SAR     EBX,15

		MOV     EDX,DWORD PTR [ESI+8]
		ADD     EDX,0
		JGE     PUT_SIGN_P
		NEG     EBX
	PUT_SIGN_P:                              ; BX = PP(2)

		MOV     EAX,DWORD PTR [ESI]      ; EAX = PP(0)
		SAL     EAX,CL           ; shifter a de CL
		CDQ
		IDIV    EBX              ; AX = PP(0)/PP(2)
		NEG     AX
		MOV     WORD PTR [EDI],AX       ; ES:[DI] = -PP(0)/PP(2)

		MOV     EAX,DWORD PTR [ESI+4]    ; EAX = PP(1)
		SAL     EAX,CL           ; shifter a de CL
		SAR     EAX,1
		CDQ
		IDIV    EBX
		NEG     EAX               ; va = AX = -PP(1)/2*PP(2)
		MOV     DWORD PTR [ESI],EAX
		MOV     CX,WORD PTR [EDI]        ; vb = CX = -PP(0)/PP(2)

		IMUL    EAX               ; EAX = va*va

		MOVSX   EBX,CX           ; EAX = vb
		SAL     EBX,15           ; EAX = vb*32768

		ADD     EAX,EBX          ; EBX = va*va + vb*32768

		MOV     [sqr],EAX

		MOV     CX,14            ; CX = compteur
		MOV     BX,0             ; BX = racine
		MOV     WORD PTR [inc_sq],4000H ;

	SQRT_L:
		ADD     BX,[inc_sq]      ; rac += incrm
		MOVSX   EAX,BX
		IMUL    EAX              ; EAX = rac*rac
		SUB     EAX,[sqr]        ; EAX = rac*rac - SQR

		JZ      VITA_SQ
		JLE     NEXTIT

		SUB     BX,[inc_sq]       ; rac = rac - incrm
	NEXTIT:
		SAR     WORD PTR [inc_sq],1  ; incrm >> 1
		DEC	CX
		JNE	SQRT_L

	VITA_SQ:

		MOV     EAX,DWORD PTR [ESI]         ; AX = b
		MOV     DX,AX
		SUB     AX,BX               ; AX = b-sqrt()
		MOV     WORD PTR [EDI+4],AX        ; sauver

		ADD     DX,BX               ; DX = b+sqrt()
		MOV     WORD PTR [EDI],DX          ; sauver

						; idem with QQ

		ADD     ESI,24            ;DS:SI  QQ
		MOV     EBX,DWORD PTR [ESI+8]    ;EBX = QQ(2)
		ADD     EBX,0
		JGE     B_POSIT_Q
		NEG     EBX
	B_POSIT_Q:
		MOV     CL,0
		CMP     EBX,40000000H   ;normaliser QQ(2)
		JGE     OUT_NORM_Q
	NORM_B_Q:
		ADD     EBX,EBX
		INC     CL
		CMP     EBX,40000000H   ;
		JGE     OUT_NORM_Q
		JMP     NORM_B_Q
	OUT_NORM_Q:
		ADD     EBX,16384
		SAR     EBX,15

		MOV     EDX,DWORD PTR [ESI+8]
		ADD     EDX,0
		JGE     PUT_SIGN_Q
		NEG     EBX
	PUT_SIGN_Q:                               ; BX = QQ(2)

		MOV     EAX,DWORD PTR [ESI]      ; EAX = QQ(0)
		SAL     EAX,CL           ; shifter a de CL
		CDQ
		IDIV    EBX              ; AX = QQ(0)/QQ(2)
		NEG     AX
		MOV     WORD PTR [EDI+2],AX       ; ES:[DI+2] = -QQ(0)/QQ(2)

		MOV     EAX,DWORD PTR [ESI+4]    ; EAX = QQ(1)
		SAL     EAX,CL           ; shifter a de CL
		SAR     EAX,1
		CDQ
		IDIV    EBX
		NEG     EAX               ; va = AX = -QQ(1)/2*QQ(2)
		MOV     DWORD PTR [ESI],EAX
		MOV     CX,WORD PTR [EDI+2]        ; vb = CX = -QQ(0)/QQ(2)

		IMUL    EAX               ; EAX = va*va

		MOVSX   EBX,CX           ; EAX = vb
		SAL     EBX,15           ; EAX = vb*32768

		ADD     EAX,EBX          ; EBX = va*va + vb*32768

		MOV     [sqr],EAX

		MOV     CX,14            ; CX = compteur
		MOV     BX,0             ; BX = racine
		MOV     WORD PTR [inc_sq],4000H ;

	SQRT_LQ:
		ADD     BX,[inc_sq]      ; rac += incrm
		MOVSX   EAX,BX
		IMUL    EAX              ; EAX = rac*rac
		SUB     EAX,[sqr]        ; EAX = rac*rac - SQR

		JZ      VITA_SQ2
		JLE     NEXTITQ

		SUB     BX,[inc_sq]       ; rac = rac - incrm
	NEXTITQ:
		SAR     WORD PTR [inc_sq],1  ; incrm >> 1
		DEC	CX
		JNE	SQRT_LQ

	VITA_SQ2:
		MOV     EAX,DWORD PTR [ESI]         ; AX = b
		MOV     DX,AX
		SUB     AX,BX               ; AX = b-sqrt()
		MOV     WORD PTR [EDI+6],AX        ; sauver

		ADD     DX,BX               ; DX = b+sqrt()
		MOV     WORD PTR [EDI+2],DX          ; sauver
	}
}

void deacc(short *src,short *dest,short fact,short lfen,short *last_out)
{
	_asm
	{
		MOV     ESI,[src]
		MOV     EDI,[dest]

		MOV     EBX,[last_out]        ; FS:BX = last_out
		MOV     AX,WORD PTR [EBX]        ; AX = last_out
		MOV     BX,[fact]         ; BX = Fact
		MOV     CX,[lfen]          ; init compteur

	LOOP_DEAC:
		IMUL    BX                ; DX:AX = fact * y(i-1)
		ADD     AX,16384
		ADC     DX,0              ; arrondi
		SHLD    DX,AX,1           ; DX = fact * x(i-1;
		MOV     AX,WORD PTR [ESI]        ; AX = x(i)
		ADD     AX,DX             ; DX = x(i) + fact*x(i-1)
		MOV     WORD PTR [EDI],AX        ;Sauver Xout
		ADD     ESI,2              ;
		ADD     EDI,2              ;Pointer composantes suivantes
		DEC	CX
		JNE	LOOP_DEAC


		MOV     EBX,[last_out]
		MOV     WORD PTR [EBX],AX        ;Sauver dernier chantillon
	}
}

void filt_in(short *mem,short *Vin,short *Vout,short lfen)
{
	_asm
	{
		MOV	CX,[lfen]		;CX=cpteur

		MOV	EDI,[mem]
	FIL_IN_LOOP:
		MOV	ESI,[Vin]
		MOV	BX,WORD PTR [ESI]              ;BX=Xin
		SAR	BX,2			;div par 4
		MOV	AX,WORD PTR [EDI]		;AX=z(1)
		MOV	WORD PTR [EDI],BX              ;mise a jour memoire
		SUB	BX,AX                   ;BX=(Xin-z(1))/4
		ADD	DWORD PTR [Vin],2	  ;pointer echant svt
		MOV	AX,WORD PTR [EDI+2]		;AX=z(2)
		MOV	DX,29491		;DX=0.9
		IMUL	DX  			;DX=0.9*z(2)
		ADD	AX,16384
		ADC	DX,0                    ;arrondi et dble signe
		SHLD	DX,AX,1
		ADD	DX,BX			;reponse=DX=tmp
		MOV	WORD PTR [EDI+2],DX            ;mise a jour memoire
		MOV	ESI,[Vout]
		MOV	WORD PTR [ESI],DX     ;output=tmp/4
		ADD	DWORD PTR [Vout],2  ;pointer echant svt
		DEC	CX
		JNE	FIL_IN_LOOP
	}
}

/*
void cal_dic1(short *y,short *sr,short *espopt,short *posit,short dec,
	short esp,short SIGPI[],short SOULONG,long TLSP[],long VMAX[])
{
	short ss,vene;

	_asm
	{
		PUSH	WORD PTR [INT_SOUL]
		MOV	SI,WORD PTR [INT_SIG]
		ADD	SI,300
		PUSH	SI
		PUSH	WORD PTR [INT_Y]
		CALL	near ptr venergy
		ADD	SP,6
		MOV	BX,WORD PTR [INT_SOUL]
		SAL	BX,2
		ADD	SI,BX
		SUB	SI,4
		MOV	WORD PTR [VENE],SI

		MOV	AX,WORD PTR [INT_SOUL]
		MOV	WORD PTR [INT_SS],AX
		ADD	AX,WORD PTR [INT_SR]
		ADD     WORD PTR [INT_SS],AX

		MOV	DI,0
		MOV	SI,WORD PTR [LG_TLSP]

		PUSH	WORD PTR [LG_VMAX]
		PUSH	SI

DEC1_LOOP:	MOV	BX,WORD PTR [INT_SR]
		MOV	EAX,0
		MOV	DWORD PTR [SI],EAX
		ADD	BX,DI
		ADD	BX,DI
DEC1_BCLE:	MOVSX	EAX,WORD PTR [BX]
		ADD	DWORD PTR [SI],EAX
		MOV	AX,WORD	PTR [INT_ESP]
		ADD	BX,AX
		ADD	BX,AX
		CMP	BX,WORD PTR [INT_SS]
		JL	DEC1_BCLE
		MOV	BX,WORD PTR [VENE]
		SAL	DI,2
		SUB	BX,DI
		SAR	DI,2
		MOV	EAX,DWORD PTR [BX]
		MOV	DWORD PTR [SI+4],EAX

		CALL	upd_max_d

		ADD	AX,0
		JE	NO_LIMIT
		MOV	BX,WORD PTR [INT_POS]
		MOV	WORD PTR [BX],DI
		MOV	BX,WORD PTR [INT_EO]
		MOV	AX,WORD PTR [INT_ESP]
		MOV	WORD PTR [BX],AX

NO_LIMIT:	INC	DI
		CMP	DI,WORD PTR [INT_DEC]
		JL      DEC1_LOOP

		ADD	SP,4

		POP	DI
		POP	SI
		MOV	SP,BP
		POP	BP

		RET

cal_dic1	ENDP



COMMENT #
COMMENT &
___ void cal_dic2(int q,int espace,int phase,int *s_r,int *hy,int *b,
___ int *vois,int *esp,int *qq,int *phas,int SIGPI[],
___ int SOULONG,long TLSP[],long VMAX[],(int PITCH))
___                                       |--->en option...
&

R11		EQU  BP-4
Y1		EQU  BP-6
Y2		EQU  BP-8
IO		EQU  BP-10
ST_CC		EQU  BP-30
ST_SRC		EQU  BP-50

INT_Q		EQU  BP+6
ESPACE		EQU  BP+8
PHASE		EQU  BP+10
INT_SR		EQU  BP+12
S_INT_SR	EQU  BP+14
HY 		EQU  BP+16
S_HY		EQU  BP+18
INT_B		EQU  BP+20
S_INT_B		EQU  BP+22
VOIS		EQU  BP+24
S_VOIS		EQU  BP+26
INT_ESP		EQU  BP+28
S_ESP		EQU  BP+30
QQ	        EQU  BP+32
S_QQ		EQU  BP+34
PHAS		EQU  BP+36
S_PHAS		EQU  BP+38
SIGPI		EQU  BP+40
S_SIGPI		EQU  BP+42
SOULONG		EQU  BP+44
TLSP		EQU  BP+46
S_TLSP		EQU  BP+48
VMAX		EQU  BP+50
S_VMAX		EQU  BP+52
;PITCH		EQU  BP+54

cal_dic2	PROC	FAR

		PUSH	BP
		MOV	BP,SP
		SUB	SP,50
		PUSH	SI
		PUSH	DI
		PUSH	DS
;		PUSH	ES

		MOV	DWORD PTR [R11],0
		PUSH	WORD PTR [SOULONG]
		PUSH	WORD PTR [S_SIGPI]
		MOV	SI,WORD PTR [SIGPI]
		ADD	SI,300
		MOV	WORD PTR [Y1],SI
		SUB	SI,150
		MOV	WORD PTR [Y2],SI
		PUSH	SI
		CALL	init_zero
		ADD	SP,6

		MOV	AX,WORD PTR [PHASE]
		SUB	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX
		PUSH	WORD PTR [SOULONG]
		SUB	SP,2
		PUSH	WORD PTR [S_HY]
		PUSH	WORD PTR [HY]
		PUSH	WORD PTR [S_SIGPI]
		PUSH	SI
		ADD	SP,10

		MOV	SI,0
		MOV	DS,WORD PTR [S_INT_SR]
CAL2_LOOP:	MOV	DI,WORD PTR [INT_SR]
		MOV	AX,WORD PTR [IO]
		ADD	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX
		ADD	DI,AX
		ADD	DI,AX
		MOVSX	EBX,WORD PTR DS:[DI]
		ADD	SI,SI
		MOV	WORD PTR SS:[ST_SRC+SI],BX
		ADD	EBX,0
		JL	SRC_NEG
		MOV	WORD PTR SS:[ST_CC+SI],1
		ADD	DWORD PTR [R11],EBX
		PUSH	AX
		SUB	SP,8
		CALL	add_sf_vect
		ADD	SP,10
		JMP	CAL2_SUITE
SRC_NEG:  	MOV	WORD PTR SS:[ST_CC+SI],-1
		SUB	DWORD PTR [R11],EBX
		PUSH	AX
		SUB	SP,8
		CALL	sub_sf_vect
		ADD	SP,10
CAL2_SUITE:	SAR	SI,1
		ADD	SI,1
		CMP	SI,WORD PTR [INT_Q]
		JL	CAL2_LOOP
		ADD	SP,2


		PUSH	WORD PTR [SOULONG]
		PUSH	WORD PTR [S_TLSP]
		MOV	SI,WORD PTR [TLSP]
		ADD	SI,4
		PUSH	SI
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y2]
		CALL	energy2
		ADD	SP,10


		MOV	DS,WORD PTR [S_TLSP]
		MOV	SI,WORD PTR [TLSP]
		MOV	EAX,DWORD PTR [R11]
		MOV	DS:[SI],EAX

		PUSH	WORD PTR [S_VMAX]
		PUSH	WORD PTR [VMAX]
		PUSH	DS
		PUSH	SI
		CALL	upd_max_d
		ADD	SP,8
		ADD	AX,0
		JE	UPD_NULL
		PUSH	WORD PTR [INT_Q]
		PUSH	WORD PTR [S_INT_B]
		PUSH	WORD PTR [INT_B]
		PUSH	SS
		MOV	AX,BP
		SUB	AX,30
		PUSH	AX
		CALL	int_to_int
		ADD	SP,10
		MOV	SI,WORD PTR [VOIS]
		MOV	DS,WORD PTR [S_VOIS]
		MOV	DS:[SI],WORD PTR 0
		MOV	DS,WORD PTR [S_ESP]
		MOV	SI,WORD PTR [INT_ESP]
		MOV	AX,WORD PTR [ESPACE]
		MOV	DS:[SI],AX
		MOV	DS,WORD PTR [S_QQ]
		MOV	SI,WORD PTR [QQ]
		MOV	AX,WORD PTR [INT_Q]
		MOV	DS:[SI],AX
		MOV	DS,WORD PTR [S_PHAS]
		MOV	SI,WORD PTR [PHAS]
		MOV	AX,WORD PTR [PHASE]
		MOV	DS:[SI],AX

UPD_NULL:     ;	CMP	WORD PTR [PITCH],80
	      ;	JG	FINI
COMMENT &
		MOV	AX,WORD PTR [PHASE]
		SUB	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX

		MOV	SI,0

CAL2_LOOP2:     ADD	SI,SI
		MOV	AX,WORD PTR SS:[ST_CC+SI]
		NEG	AX
		MOV	WORD PTR SS:[ST_CC+SI],AX
		MOV	EDX,DWORD PTR [R11]
		MOVSX	EBX,WORD PTR SS:[ST_SRC+SI]
		ADD	AX,0
		JL	CC_NEG
		ADD	EDX,EBX
		ADD	EDX,EBX
		JMP     CC_NEXT
CC_NEG:         SUB	EDX,EBX
		SUB	EDX,EBX

CC_NEXT:
		MOV	DI,WORD PTR [TLSP]
		MOV	DS,WORD PTR [S_TLSP]
		MOV	DS:[DI],EDX
		MOV	AX,WORD PTR [IO]
		ADD	AX,WORD PTR [ESPACE]
		MOV	WORD PTR [IO],AX
		MOV	BX,WORD PTR SS:[ST_CC+SI]
		ADD	BX,BX
		PUSH	BX
		PUSH	AX
		PUSH	WORD PTR [SOULONG]
		PUSH	WORD PTR [S_HY]
		PUSH	WORD PTR [HY]
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y2]
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y1]
		CALL	update_dic
		ADD	SP,18
		PUSH	WORD PTR [SOULONG]
		PUSH	DS
		MOV	BX,WORD PTR [TLSP]
		ADD	BX,4
		PUSH	BX
		PUSH	WORD PTR [S_SIGPI]
		PUSH	WORD PTR [Y1]
		CALL	energy2
		ADD	SP,10

		PUSH	WORD PTR [S_VMAX]
		PUSH	WORD PTR [VMAX]
		PUSH	DS
		PUSH	WORD PTR [TLSP]
		CALL	upd_max_d
		ADD	SP,8
		ADD	AX,0
		JE	CAL2_END
		PUSH	WORD PTR [INT_Q]
		PUSH	WORD PTR [S_INT_B]
		PUSH	WORD PTR [INT_B]
		PUSH	SS
		MOV	AX,BP
		SUB	AX,30
		PUSH	AX
		CALL	int_to_int
		ADD	SP,10
		MOV	DI,WORD PTR [TLSP]
		MOV	EAX,DS:[DI]
		MOV	DWORD PTR [R11],EAX
		MOV	AX,WORD PTR [Y1]
		XCHG	AX,WORD PTR [Y2]
		MOV 	WORD PTR [Y1],AX

		MOV	DI,WORD PTR [VOIS]
		MOV	DS,WORD PTR [S_VOIS]
		MOV	DS:[DI],WORD PTR 0
		MOV	DS,WORD PTR [S_ESP]
		MOV	DI,WORD PTR [INT_ESP]
		MOV	AX,WORD PTR [ESPACE]
		MOV	DS:[DI],AX
		MOV	DS,WORD PTR [S_QQ]
		MOV	DI,WORD PTR [QQ]
		MOV	AX,WORD PTR [INT_Q]
		MOV	DS:[DI],AX
		MOV	DS,WORD PTR [S_PHAS]
		MOV	DI,WORD PTR [PHAS]
		MOV	AX,WORD PTR [PHASE]
		MOV	DS:[DI],AX
		JMP	CAL2_OUT
CAL2_END:	NEG	WORD PTR SS:[ST_CC+SI]
CAL2_OUT:       SAR	SI,1
		ADD	SI,1
		CMP	SI,WORD PTR [INT_Q]
		JL	CAL2_LOOP2

FINI:
&
;		POP	ES
		POP	DS
		POP	DI
		POP	SI
		MOV	SP,BP
		POP	BP

		RET

cal_dic2	ENDP
#

COMMENT &
___ void calc_p(int *p1,int *p2,int pitch,int lim_p1,int lim_p2,int no);
&


P1	EQU	BP+4
P2	EQU	BP+6
PITCH	EQU	BP+8
LIM_P1	EQU	BP+10
LIM_P2	EQU	BP+12
INT_NO	EQU	BP+14

calc_p		PROC    near

		PUSH 	BP             ; save contexte
		MOV	BP,SP          ;
		PUSH	SI             ; save C register
		PUSH	DI

		MOV	BX,WORD PTR [PITCH]
		MOV	SI,WORD PTR [P1]
		MOV	CX,WORD PTR [LIM_P1]
		MOV	AX,WORD PTR [INT_NO]
		ADD	AX,0
		JE	NUM_NULL
		SUB	BX,3
		CMP	BX,CX
		JL	P1_NEG1
		MOV	WORD PTR [SI],BX
		JMP	P1_SUITE1
P1_NEG1:        MOV	WORD PTR [SI],CX
P1_SUITE1:	ADD	BX,7
		MOV	CX,WORD PTR [LIM_P2]
		MOV	SI,WORD PTR [P2]
		CMP	BX,CX
		JG	P2_POS1
		MOV	WORD PTR [SI],BX
		JMP	P_FIN
P2_POS1:	MOV	WORD PTR [SI],CX
		JMP	P_FIN

NUM_NULL:       SUB	BX,5
		CMP	BX,CX
		JL	P1_NEG2
		MOV	WORD PTR [SI],BX
		JMP	P1_SUITE2
P1_NEG2:        MOV	WORD PTR [SI],CX
P1_SUITE2:	ADD	BX,10
		MOV	CX,WORD PTR [LIM_P2]
		MOV	SI,WORD PTR [P2]
		CMP	BX,CX
		JG	P2_POS2
		MOV	WORD PTR [SI],BX
		JMP	P_FIN
P2_POS2:	MOV	WORD PTR [SI],CX

P_FIN:
		POP     DI
		POP     SI
		MOV 	SP,BP
		POP	BP

		RET

calc_p		ENDP
*/

#pragma warning(disable : 4035)
short calc_gltp(short *gltp,short *bq,short *bv,long ttt)
{
	_asm
	{
		MOV	EBX,DWORD PTR [ttt]
		CMP	EBX,32767
		JLE	TEST2
		MOV	AX,32767
		JMP	OUT_TEST
	TEST2:
		CMP	EBX,-32767
		JGE	TEST3
		MOV	AX,-32767
		JMP	OUT_TEST
	TEST3:
		MOV	AX,BX
	OUT_TEST:
		MOV	BX,AX		; BX=GLTP
		ADD	AX,0
		JGE	GLTP_POS
		NEG	AX		; AX=abs(GLTP)

	GLTP_POS:
		MOV	CX,0
		MOV	ESI,[bq]
		MOV	EDI,[bv]
	BOUCLER:
		ADD	CX,1
		CMP	CX,11
		JE	FIN_BOUCLER
		ADD	EDI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JL	BOUCLER
		ADD	ESI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JGE	BOUCLER
		ADD	BX,0
		JLE	GLTP_NEG
		DEC	CX		;CX=k
		MOV	BX,WORD PTR [EDI]
		JMP	FIN_BOUCLER
	GLTP_NEG:
		ADD	CX,9
		MOV	BX,WORD PTR [EDI]
		NEG	BX
	FIN_BOUCLER:
		MOV	ESI,[bq]
		ADD	ESI,20
		MOV	DX,WORD PTR [ESI]
		CMP	BX,DX
		JL 	GLTP_P
		MOV	EDI,[bv]
		ADD	EDI,20
		MOV	BX,WORD PTR [EDI]
		MOV	CX,9
	GLTP_P:
		SUB	ESI,8
		MOV	DX,WORD PTR [ESI]
		NEG	DX
		CMP	BX,DX
		JGE	GLTP_G
		MOV	EDI,[bv]
		ADD	EDI,12
		MOV	BX,WORD PTR [EDI]
		NEG	BX
		MOV	CX,15
	GLTP_G:
		MOV	ESI,[gltp]
		MOV	WORD PTR [ESI],BX

		MOV	AX,CX
	}
}
#pragma warning(default : 4035)


#pragma warning(disable : 4035)

short calc_garde(short MAX)
{
	_asm
	{
		MOV	AX,0
		MOV	BX,WORD PTR [MAX]
		AND	BX,0FE00H
		JE	STORE
		SAR	BX,9

	BCLE_SAR:
		INC	AX
		SAR	BX,1
		JE	STORE
		CMP	AX,5
		JNE	BCLE_SAR
	STORE:
	}
}
#pragma warning(default : 4035)

#pragma warning(disable : 4035)
short calc_gopt(short *c,short *code,short *gq,short *gv,short voise,
	short npopt,short pitch,short espopt,short depl,short position,
	short soudecal,long vmax)
{
	_asm
	{
		MOV	EBX,DWORD PTR [vmax]
		CMP	EBX,32767
		JLE	COMP2
		MOV	AX,32767
		JMP	OUT_COMP
	COMP2:
		CMP	EBX,-32767
		JGE	COMP3
		MOV	AX,-32767
		JMP	OUT_COMP
	COMP3:
		MOV	AX,BX              	;AX=Gopt
	OUT_COMP:
		MOV	BX,WORD PTR [voise]
		ADD	BX,0
		JNE	VOIS_1

		MOV	ESI,[c]
		MOV	BX,WORD PTR [ESI]
		CMP	BX,-1
		JNE	CO_1
		NEG	AX
		MOVSX	ECX,WORD PTR [npopt]
		ADD	ESI,ECX
		ADD	ESI,ECX
	CX_BCLE:
		SUB	ESI,2
		NEG	WORD PTR [ESI]
		DEC	CX
		JNE	CX_BCLE
	CO_1:
		MOV	CX,WORD PTR [npopt]
		CMP	CX,8
		JNE	NPOPT_9
		MOV	DX,128
		JMP	NP_NEXT
	NPOPT_9:
		MOV	DX,256			;DX=cod
	NP_NEXT:
		MOV	DI,1
		MOV	ESI,[c]
		DEC	CX
	CJ_BCLE:
		ADD	ESI,2
		DEC	CX
		MOV	BX,WORD PTR [ESI]
		SUB	BX,1
		JNE	CJ_1
		MOV	BX,1
		SAL	BX,CL
		ADD	DX,BX
	CJ_1:
		INC	DI
		CMP	DI,WORD PTR [npopt]
		JL	CJ_BCLE
		JMP	VOIS_0
	VOIS_1:
		MOV	BX,WORD PTR [espopt]
		MOV	DX,WORD PTR [position]
		CMP	BX,WORD PTR [pitch]
		JE	VOIS_0
		ADD	DX,WORD PTR [soudecal]

	VOIS_0:
		MOVSX	ESI,[depl]			
		ADD	ESI,ESI
		ADD	ESI,24
		ADD	ESI,[c]
		MOV	WORD PTR [ESI],DX		; code[12+depl]=cod

		ADD	AX,0
		JGE	SIGN_0
		NEG	AX
		MOV	BX,1
		JMP	SIGN_1
	SIGN_0:
		MOV	BX,0

	SIGN_1:
		MOV	CX,0
		MOV	ESI,[gq]
		MOV	EDI,[gv]

	BOUCLER2:
		ADD	CX,1
		CMP	CX,17
		JE	FIN_BOUCLER2
		ADD	EDI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JL	BOUCLER2
		ADD	ESI,2
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JGE	BOUCLER2
		DEC	CX			;CX=cod
		MOV	AX,WORD PTR [EDI]		;AX=Gopt

	FIN_BOUCLER2:
		MOV	ESI,[gq]
		ADD	ESI,32
		MOV	DX,WORD PTR [ESI]
		CMP	AX,DX
		JL 	G_GQ
		MOV	EDI,[gv]
		ADD	EDI,32
		MOV	AX,WORD PTR [EDI]
		MOV	CX,15

	G_GQ:
		ADD	BX,0
		JE	SIGN_NULL
		NEG	AX
		ADD	CX,16

	SIGN_NULL:
		MOVSX	ESI,WORD PTR [depl]
		ADD	ESI,ESI
		ADD	ESI,26
		ADD	ESI,[c]
		MOV	WORD PTR [ESI],CX
	}
}
#pragma warning(default : 4035)

void decimation(short *vin,short *vout,short nech)
{
	_asm
	{
		MOV	EDI,[vin]
		MOV	ESI,[vout]

	DECIMATE:
		MOV	AX,WORD PTR [EDI]
		MOV	WORD PTR [ESI],AX
		ADD	EDI,8
		ADD	ESI,2
		DEC	WORD PTR [nech]
		JNE	DECIMATE
	}
}
#else

void proc_gain(long *corr_ene,long gain)
{
	// TODO need 64-bit
}

void inver_v_int(short *src,short *dest,short lng)
{
	// TODO need 64-bit
}

short max_vect(short *vech,short nech)
{
	// TODO need 64-bit
	return 0;
}

void upd_max(long *corr_ene,long *vval,short pitch)
{
	// TODO need 64-bit
}

short upd_max_d(long *corr_ene,long *vval)
{
	// TODO need 64-bit
	return 0;
}

void norm_corrl(long *corr,long *vval)
{
	// TODO need 64-bit
}

void norm_corrr(long *corr,long *vval)
{
	// TODO need 64-bit
}

void energy(short *vech,long *ene,short lng)
{
	// TODO need 64-bit
}

void venergy(short *vech,long *vene,short lng)
{
	// TODO need 64-bit
}

void energy2(short *vech,long *ene,short lng)
{
	// TODO need 64-bit
}

void upd_ene(long *ener,long *val)
{
	// TODO need 64-bit
}

short max_posit(long *vcorr,long *maxval,short pitch,short lvect)
{
	// TODO need 64-bit
	return 0;
}

void correlation(short *vech,short *vech2,long *acc,short lng)
{
	// TODO need 64-bit
}

void  schur(short *parcor,long *Ri,short netages)
{
	// TODO need 64-bit
}

void interpol(short *lsp1,short *lsp2,short *dest,short lng)
{
	// TODO need 64-bit
}

void add_sf_vect(short *y1,short *y2,short deb,short lng)
{
	// TODO need 64-bit
}

void sub_sf_vect(short *y1,short *y2,short deb,short lng)
{
	// TODO need 64-bit
}

void short_to_short(short *src,short *dest,short lng)
{
	int i;

	for(i=0; i<lng; i++)
		*dest++ = *src++;
}


void long_to_long(long *src,long *dest,short lng)
{
	// TODO need 64-bit
}

void init_zero(short *src,short lng)
{
	// TODO need 64-bit
}

void update_ltp(short *y1,short *y2,short hy[],short lng,short gdgrd,short fact)
{
	// TODO need 64-bit
}

void proc_gain2(long *corr_ene,long *gain,short bit_garde)
{
	// TODO need 64-bit
}

void decode_dic(short *code,short dic,short npuls)
{
	// TODO need 64-bit
}

void dsynthesis(long *z,short *coef,short *input,short *output,
										short lng,short netages)
{
	// TODO need 64-bit
}

void synthesis(short *z,short *coef,short *input,short *output,
				short lng,short netages,short bdgrd )
{
	// TODO need 64-bit
}

void synthese(short *z,short *coef,short *input,short *output,
						short lng,short netages)
{
	// TODO need 64-bit
}

void f_inverse(short *z,short *coef,short *input,short *output,
						short lng,short netages )
{
	// TODO need 64-bit
}

void filt_iir(long *zx,long *ai,short *Vin,short *Vout,short lfen,short ordre)
{
	// TODO need 64-bit
}

void mult_fact(short src[],short dest[],short fact,short lng)
{
	// TODO need 64-bit
}

void mult_f_acc(short src[],short dest[],short fact,short lng)
{
	// TODO need 64-bit
}

void dec_lsp(short *code,short *tablsp,short *nbit,short *bitdi,short *tabdi)
{
	// TODO need 64-bit
}

void teta_to_cos(short *tabcos,short *lsp,short netages)
{
	// TODO need 64-bit
}

void cos_to_teta(short *tabcos,short *lsp,short netages)
{
	// TODO need 64-bit
}

void lsp_to_ai(short *ai_lsp,long *tmp,short netages)
{
	// TODO need 64-bit
}

void ki_to_ai(short *ki,long *ai,short netages)
{
	// TODO need 64-bit
}

void ai_to_pq(long *aip,short netages)
{
	// TODO need 64-bit
}

void horner(long *P,long *T,long *a,short n,short s)
{
	// TODO need 64-bit
}

short calcul_s(long a,long b)
{
	// TODO need 64-bit
	return 0;
}

void binome(short *lsp,long *PP)
{
	// TODO need 64-bit
}

void deacc(short *src,short *dest,short fact,short lfen,short *last_out)
{
	// TODO need 64-bit
}

void filt_in(short *mem,short *Vin,short *Vout,short lfen)
{
	// TODO need 64-bit
}

short calc_gltp(short *gltp,short *bq,short *bv,long ttt)
{
	// TODO need 64-bit
	return 0;
}

short calc_garde(short MAX)
{
	// TODO need 64-bit
	return 0;
}

short calc_gopt(short *c,short *code,short *gq,short *gv,short voise,
	short npopt,short pitch,short espopt,short depl,short position,
	short soudecal,long vmax)
{
	// TODO need 64-bit
	return 0;
}

void decimation(short *vin,short *vout,short nech)
{
	// TODO need 64-bit
}
#endif

#ifndef _X86_
/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: DotProduct                                              */
/*  Author: Bill Hallahan                                             */
/*  Date: March 10, 1997                                              */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function returns the dot product of a set of two      */
/*    vectors.                                                        */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    pVector_0    A pointer of type T that points to the first       */
/*                 input vector.                                      */
/*                                                                    */
/*    pVector_1    A pointer of type T that points to the second      */
/*                 input vector.                                      */
/*                                                                    */
/*    uiLength     The length of the input vectors.                   */
/*                                                                    */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*    The dot product of the two input vectors is calculated. The     */
/*    return value is a 64 bit Q30 number.                            */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Start of routine DotProduct().                                    */
/**********************************************************************/

_int64 DotProduct( int * piVector_0,
                   int * piVector_1,
                   unsigned int uiLength )
{
  /********************************************************************/
  /*  Do the multiply-accumulates in groups of 8 values.              */
  /********************************************************************/

  _int64 qSum = 0;

  while ( uiLength >= 8 )
  {
    qSum += *piVector_0 * *piVector_1;
    qSum += *(piVector_0+1) * *(piVector_1+1);
    qSum += *(piVector_0+2) * *(piVector_1+2);
    qSum += *(piVector_0+3) * *(piVector_1+3);
    qSum += *(piVector_0+4) * *(piVector_1+4);
    qSum += *(piVector_0+5) * *(piVector_1+5);
    qSum += *(piVector_0+6) * *(piVector_1+6);
    qSum += *(piVector_0+7) * *(piVector_1+7);
    piVector_0 += 8;
    piVector_1 += 8;
    uiLength -= 8;
  }

  /********************************************************************/
  /*  Conditionally do a group of 4 multiply-accumulates.             */
  /********************************************************************/

  if ( uiLength >= 4 )
  {
    qSum += *piVector_0 * *piVector_1;
    qSum += *(piVector_0+1) * *(piVector_1+1);
    qSum += *(piVector_0+2) * *(piVector_1+2);
    qSum += *(piVector_0+3) * *(piVector_1+3);
    piVector_0 += 4;
    piVector_1 += 4;
    uiLength -= 4;
  }

  /********************************************************************/
  /*  Conditionally do a group of 2 multiply-accumulates.             */
  /********************************************************************/

  if ( uiLength >= 2 )
  {
    qSum += *piVector_0 * *piVector_1;
    qSum += *(piVector_0+1) * *(piVector_1+1);
    piVector_0 += 2;
    piVector_1 += 2;
    uiLength -= 2;
  }

  /********************************************************************/
  /*  Conditionally do a single multiply-accumulate.                  */
  /********************************************************************/

  if ( uiLength >= 1 )
  {
    qSum += *piVector_0 * *piVector_1;
  }

  return qSum;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: FirFilter                                               */
/*  Author: Bill Hallahan                                             */
/*  Date: March 10, 1997                                              */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function returns the dot product of a set of FIR      */
/*    filter coefficients and the data in a circular delay line.      */
/*    All of the input and output data has Q15 scaling.               */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    piFilterCoefficients  A pointer to the FIR filter               */
/*                          coefficients which are in reverse time    */
/*                          order.                                    */
/*                                                                    */
/*    piFilterDelay      A pointer to a delay line that contains the  */
/*                       input samples.                               */
/*                                                                    */
/*    iDelayPosition     An index into the filter delay line.         */
/*                                                                    */
/*    iFilterLength      The length of the filter impulse response.   */
/*                       (Also the number of filter coefficients.     */
/*                                                                    */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*         The dot product of the fir filter coefficients and the     */
/*    data in the circular delay line is returned.                    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Start of routine FirFilter().                                     */
/**********************************************************************/

int FirFilter( int * piFilterCoefficients,
               int * piFilterDelay,
               unsigned int uiDelayPosition,
               unsigned int uiFilterLength )
{
  int iSum;
  _int64 qSum;
  unsigned int uiRemaining;

  uiRemaining = uiFilterLength - uiDelayPosition;

  qSum = DotProduct( piFilterCoefficients,
                     &piFilterDelay[uiDelayPosition],
                     uiRemaining );

  qSum += DotProduct( piFilterCoefficients + uiRemaining,
                      &piFilterDelay[0],
                      uiDelayPosition );

  /********************************************************************/
  /*  Scale the Q30 number to be a Q15 number.                        */
  /********************************************************************/

  iSum = (int)( qSum >> 15 );

  return iSum;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: SampleRate6400To8000                                    */
/*  Author: Bill Hallahan                                             */
/*  Date: March 8, 1997                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*       This function converts a block of audio samples from an      */
/*  6400 Hz. sample rate to an 8000 Hz. sample rate. This is done     */
/*  using a set of polyphase filters that can interpolate up to a     */
/*  32000 Hz. rate ( 32000 is the LCM of 8000 and 6400.)              */
/*                                                                    */
/*       Only the 32000 Hz. samples that correspond to an 8000 Hz.    */
/*  sample rate are calculated. The input 6400 Hz. rate corresponds   */
/*  to every 5th (32000/6400) sample at the 32000 Hz. rate. The       */
/*  output 8000 Hz. rate corresponds to every 4th (32000/8000)        */
/*  sample at the 32000 Hz. rate. Since the LCM of 4 and 5 is 20,     */
/*  then the pattern of sample insertion and polyphase filter         */
/*  selection will repeat every 20 output samples.                    */
/*                                                                    */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    pwInputBuffer       A pointer to an input buffer of samples     */
/*                        that are sampled at an 6400 Hz. rate. The   */
/*                        samples are in Q15 format and must be       */
/*                        in the range of ( 1 - 2^-15) to -1.         */
/*                                                                    */
/*    pwOutputBuffer      A buffer that returns the output data       */
/*                        which is the input buffer data resampled    */
/*                        at 8000 Hz.                                 */
/*                                                                    */
/*                        The output bufer length MUST be large       */
/*                        enough to accept all of the output data.    */
/*                        The minimum length of the output buffer     */
/*                        is 5/4 times the number of samples in the   */
/*                        input buffer. ( 8000/6400 = 5/4 )           */
/*                                                                    */
/*    uiInputLength       The number of samples in the input buffer.  */
/*                                                                    */
/*                                                                    */
/*                       THE FOLLOWING INPUT VARIABLES ARE USED       */
/*                       TO MAINTAIN STATE INFORMATION BETWEEN        */
/*                       CALLS TO THIS ROUTINE.                       */
/*                                                                    */
/*                                                                    */
/*    piFilterDelay       A pointer to a delay line that is used      */
/*                        for FIR filtering. This  must be the        */
/*                        length of the polyphase filter's impulse    */
/*                        response. For this routine this is 56.      */
/*                        This buffer should be initialized to zero   */
/*                        once at system initialization.              */
/*                                                                    */
/*    puiDelayPosition    A pointer to an index into the filter       */
/*                        delay line. This index value should be      */
/*                        initialized to zero at system startup       */
/*                                                                    */
/*    piInputSampleTime   A pointer to the input sample time.         */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to track the input        */
/*                        stream time relative to the output stream   */
/*                        time. This time difference is used to       */
/*                        determine whether a new input sample        */
/*                        should be put into the filter delay line.   */
/*                        This should be initialized to zero once     */
/*                        at system initialization.                   */
/*                                                                    */
/*    piOutputSampleTime  A pointer to the output sample time.        */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to determine if a new     */
/*                        polyphase filter should be applied to the   */
/*                        input sample stream. This is also used to   */
/*                        select the particular polyphase filter      */
/*                        that is applied.                            */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*    This function returns an unsigned integer that is the number    */
/*    of samples in the output buffer. If the number of input samples */
/*    is exactly a multiple of RU_INPUT_SAMPLE_STEP ( 4 ) then this      */
/*    routine will always return the same value. This value will      */
/*    then be 5/4 times the number of input samples.                  */
/*                                                                    */
/*    When this function returns the output buffer contains an array  */
/*    of integers at the new sample rate.                             */
/*                                                                    */
/*                                                                    */
/*  Filter Information:                                               */
/*                                                                    */
/*    The 6400 Hz. -> 32000 Hz. interpolation filter design           */
/*    is shown here.                                                  */
/*                                                                    */
/*             H(  1) = -0.38306729E-03 = H(280)                      */
/*             H(  2) =  0.49756566E-03 = H(279)                      */
/*             H(  3) =  0.13501500E-02 = H(278)                      */
/*             H(  4) =  0.27531907E-02 = H(277)                      */
/*             H(  5) =  0.46118572E-02 = H(276)                      */
/*             H(  6) =  0.67112772E-02 = H(275)                      */
/*             H(  7) =  0.87157665E-02 = H(274)                      */
/*             H(  8) =  0.10221261E-01 = H(273)                      */
/*             H(  9) =  0.10843582E-01 = H(272)                      */
/*             H( 10) =  0.10320566E-01 = H(271)                      */
/*             H( 11) =  0.85992115E-02 = H(270)                      */
/*             H( 12) =  0.58815549E-02 = H(269)                      */
/*             H( 13) =  0.26067111E-02 = H(268)                      */
/*             H( 14) = -0.63367974E-03 = H(267)                      */
/*             H( 15) = -0.32284572E-02 = H(266)                      */
/*             H( 16) = -0.46942858E-02 = H(265)                      */
/*             H( 17) = -0.48050000E-02 = H(264)                      */
/*             H( 18) = -0.36581988E-02 = H(263)                      */
/*             H( 19) = -0.16504158E-02 = H(262)                      */
/*             H( 20) =  0.61691226E-03 = H(261)                      */
/*             H( 21) =  0.25050722E-02 = H(260)                      */
/*             H( 22) =  0.35073524E-02 = H(259)                      */
/*             H( 23) =  0.33904186E-02 = H(258)                      */
/*             H( 24) =  0.22536262E-02 = H(257)                      */
/*             H( 25) =  0.49328664E-03 = H(256)                      */
/*             H( 26) = -0.13216439E-02 = H(255)                      */
/*             H( 27) = -0.26241955E-02 = H(254)                      */
/*             H( 28) = -0.30239364E-02 = H(253)                      */
/*             H( 29) = -0.24250194E-02 = H(252)                      */
/*             H( 30) = -0.10513559E-02 = H(251)                      */
/*             H( 31) =  0.62918884E-03 = H(250)                      */
/*             H( 32) =  0.20572424E-02 = H(249)                      */
/*             H( 33) =  0.27652446E-02 = H(248)                      */
/*             H( 34) =  0.25287948E-02 = H(247)                      */
/*             H( 35) =  0.14388775E-02 = H(246)                      */
/*             H( 36) = -0.12839703E-03 = H(245)                      */
/*             H( 37) = -0.16392219E-02 = H(244)                      */
/*             H( 38) = -0.25793985E-02 = H(243)                      */
/*             H( 39) = -0.26292247E-02 = H(242)                      */
/*             H( 40) = -0.17717101E-02 = H(241)                      */
/*             H( 41) = -0.30041003E-03 = H(240)                      */
/*             H( 42) =  0.12788962E-02 = H(239)                      */
/*             H( 43) =  0.24192522E-02 = H(238)                      */
/*             H( 44) =  0.27206307E-02 = H(237)                      */
/*             H( 45) =  0.20694542E-02 = H(236)                      */
/*             H( 46) =  0.68163598E-03 = H(235)                      */
/*             H( 47) = -0.96732663E-03 = H(234)                      */
/*             H( 48) = -0.23031780E-02 = H(233)                      */
/*             H( 49) = -0.28516089E-02 = H(232)                      */
/*             H( 50) = -0.24051941E-02 = H(231)                      */
/*             H( 51) = -0.11016324E-02 = H(230)                      */
/*             H( 52) =  0.61728584E-03 = H(229)                      */
/*             H( 53) =  0.21542138E-02 = H(228)                      */
/*             H( 54) =  0.29617085E-02 = H(227)                      */
/*             H( 55) =  0.27367356E-02 = H(226)                      */
/*             H( 56) =  0.15328785E-02 = H(225)                      */
/*             H( 57) = -0.24891639E-03 = H(224)                      */
/*             H( 58) = -0.19927153E-02 = H(223)                      */
/*             H( 59) = -0.30787138E-02 = H(222)                      */
/*             H( 60) = -0.31024679E-02 = H(221)                      */
/*             H( 61) = -0.20239211E-02 = H(220)                      */
/*             H( 62) = -0.19259547E-03 = H(219)                      */
/*             H( 63) =  0.17642577E-02 = H(218)                      */
/*             H( 64) =  0.31550473E-02 = H(217)                      */
/*             H( 65) =  0.34669666E-02 = H(216)                      */
/*             H( 66) =  0.25533440E-02 = H(215)                      */
/*             H( 67) =  0.69819519E-03 = H(214)                      */
/*             H( 68) = -0.14703817E-02 = H(213)                      */
/*             H( 69) = -0.31912178E-02 = H(212)                      */
/*             H( 70) = -0.38355463E-02 = H(211)                      */
/*             H( 71) = -0.31353715E-02 = H(210)                      */
/*             H( 72) = -0.12912996E-02 = H(209)                      */
/*             H( 73) =  0.10815051E-02 = H(208)                      */
/*             H( 74) =  0.31569856E-02 = H(207)                      */
/*             H( 75) =  0.41838423E-02 = H(206)                      */
/*             H( 76) =  0.37558281E-02 = H(205)                      */
/*             H( 77) =  0.19692746E-02 = H(204)                      */
/*             H( 78) = -0.59148070E-03 = H(203)                      */
/*             H( 79) = -0.30430311E-02 = H(202)                      */
/*             H( 80) = -0.45054569E-02 = H(201)                      */
/*             H( 81) = -0.44158362E-02 = H(200)                      */
/*             H( 82) = -0.27416693E-02 = H(199)                      */
/*             H( 83) = -0.14716905E-04 = H(198)                      */
/*             H( 84) =  0.28351138E-02 = H(197)                      */
/*             H( 85) =  0.47940183E-02 = H(196)                      */
/*             H( 86) =  0.51221889E-02 = H(195)                      */
/*             H( 87) =  0.36296796E-02 = H(194)                      */
/*             H( 88) =  0.76842826E-03 = H(193)                      */
/*             H( 89) = -0.24999138E-02 = H(192)                      */
/*             H( 90) = -0.50239447E-02 = H(191)                      */
/*             H( 91) = -0.58644302E-02 = H(190)                      */
/*             H( 92) = -0.46395971E-02 = H(189)                      */
/*             H( 93) = -0.16878319E-02 = H(188)                      */
/*             H( 94) =  0.20179905E-02 = H(187)                      */
/*             H( 95) =  0.51868116E-02 = H(186)                      */
/*             H( 96) =  0.66543561E-02 = H(185)                      */
/*             H( 97) =  0.58053876E-02 = H(184)                      */
/*             H( 98) =  0.28218545E-02 = H(183)                      */
/*             H( 99) = -0.13399328E-02 = H(182)                      */
/*             H(100) = -0.52496092E-02 = H(181)                      */
/*             H(101) = -0.74876603E-02 = H(180)                      */
/*             H(102) = -0.71534920E-02 = H(179)                      */
/*             H(103) = -0.42167297E-02 = H(178)                      */
/*             H(104) =  0.42133522E-03 = H(177)                      */
/*             H(105) =  0.51945718E-02 = H(176)                      */
/*             H(106) =  0.83916243E-02 = H(175)                      */
/*             H(107) =  0.87586977E-02 = H(174)                      */
/*             H(108) =  0.59769331E-02 = H(173)                      */
/*             H(109) =  0.83726482E-03 = H(172)                      */
/*             H(110) = -0.49680225E-02 = H(171)                      */
/*             H(111) = -0.93886480E-02 = H(170)                      */
/*             H(112) = -0.10723907E-01 = H(169)                      */
/*             H(113) = -0.82560331E-02 = H(168)                      */
/*             H(114) = -0.25802210E-02 = H(167)                      */
/*             H(115) =  0.45066439E-02 = H(166)                      */
/*             H(116) =  0.10552152E-01 = H(165)                      */
/*             H(117) =  0.13269756E-01 = H(164)                      */
/*             H(118) =  0.11369097E-01 = H(163)                      */
/*             H(119) =  0.51042791E-02 = H(162)                      */
/*             H(120) = -0.36742561E-02 = H(161)                      */
/*             H(121) = -0.12025163E-01 = H(160)                      */
/*             H(122) = -0.16852396E-01 = H(159)                      */
/*             H(123) = -0.15987474E-01 = H(158)                      */
/*             H(124) = -0.90587810E-02 = H(157)                      */
/*             H(125) =  0.21703094E-02 = H(156)                      */
/*             H(126) =  0.14162681E-01 = H(155)                      */
/*             H(127) =  0.22618638E-01 = H(154)                      */
/*             H(128) =  0.23867993E-01 = H(153)                      */
/*             H(129) =  0.16226372E-01 = H(152)                      */
/*             H(130) =  0.87251863E-03 = H(151)                      */
/*             H(131) = -0.18082183E-01 = H(150)                      */
/*             H(132) = -0.34435309E-01 = H(149)                      */
/*             H(133) = -0.41475002E-01 = H(148)                      */
/*             H(134) = -0.33891901E-01 = H(147)                      */
/*             H(135) = -0.94815092E-02 = H(146)                      */
/*             H(136) =  0.29874707E-01 = H(145)                      */
/*             H(137) =  0.78281499E-01 = H(144)                      */
/*             H(138) =  0.12699878E+00 = H(143)                      */
/*             H(139) =  0.16643921E+00 = H(142)                      */
/*             H(140) =  0.18848117E+00 = H(141)                      */
/*                                                                    */
/*                        BAND  1       BAND  2                       */
/*  LOWER BAND EDGE     0.0000000     0.1000000                       */
/*  UPPER BAND EDGE     0.0937500     0.5000000                       */
/*  DESIRED VALUE       1.0000000     0.0000000                       */
/*  WEIGHTING           0.0080000     1.0000000                       */
/*  DEVIATION           0.1223457     0.0009788                       */
/*  DEVIATION IN DB     1.0025328   -60.1864281                       */
/*                                                                    */
/*  EXTREMAL FREQUENCIES--MAXIMA OF THE ERROR CURVE                   */
/*     0.0000000   0.0037946   0.0075893   0.0113839   0.0149554      */
/*     0.0187500   0.0225446   0.0263393   0.0301339   0.0339286      */
/*     0.0377232   0.0415179   0.0450894   0.0488840   0.0526787      */
/*     0.0566966   0.0604912   0.0642859   0.0680805   0.0718751      */
/*     0.0758929   0.0796875   0.0837053   0.0877231   0.0915177      */
/*     0.0937500   0.1000000   0.1006696   0.1024553   0.1049107      */
/*     0.1075892   0.1107142   0.1138391   0.1169641   0.1203123      */
/*     0.1236605   0.1270087   0.1305802   0.1339285   0.1372768      */
/*     0.1408483   0.1444198   0.1477681   0.1513396   0.1549111      */
/*     0.1584826   0.1618309   0.1654024   0.1689740   0.1725455      */
/*     0.1761170   0.1796885   0.1832600   0.1868315   0.1901798      */
/*     0.1937513   0.1973228   0.2008943   0.2044658   0.2080373      */
/*     0.2116089   0.2151804   0.2187519   0.2223234   0.2258949      */
/*     0.2294664   0.2330379   0.2366094   0.2401809   0.2437524      */
/*     0.2473240   0.2508955   0.2544670   0.2580385   0.2616100      */
/*     0.2651815   0.2687530   0.2723245   0.2761193   0.2796908      */
/*     0.2832623   0.2868338   0.2904053   0.2939768   0.2975483      */
/*     0.3011198   0.3046913   0.3082629   0.3118344   0.3154059      */
/*     0.3189774   0.3225489   0.3261204   0.3296919   0.3332634      */
/*     0.3368349   0.3404064   0.3439780   0.3475495   0.3511210      */
/*     0.3549157   0.3584872   0.3620587   0.3656302   0.3692017      */
/*     0.3727733   0.3763448   0.3799163   0.3834878   0.3870593      */
/*     0.3906308   0.3942023   0.3977738   0.4013453   0.4049169      */
/*     0.4084884   0.4120599   0.4158546   0.4194261   0.4229976      */
/*     0.4265691   0.4301406   0.4337122   0.4372837   0.4408552      */
/*     0.4444267   0.4479982   0.4515697   0.4551412   0.4587127      */
/*     0.4622842   0.4658557   0.4694273   0.4732220   0.4767935      */
/*     0.4803650   0.4839365   0.4875080   0.4910795   0.4946510      */
/*     0.4982226                                                      */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Symbol Definitions.                                               */
/**********************************************************************/

#define  RU_INPUT_SAMPLE_STEP        5
#define  RU_OUTPUT_SAMPLE_STEP       4
#define  RU_STEP_PRODUCT             ( RU_INPUT_SAMPLE_STEP * RU_OUTPUT_SAMPLE_STEP )
#define  RU_POLYPHASE_FILTER_LENGTH  56

/**********************************************************************/
/*  Start of SampleRate6400To8000 routine                             */
/**********************************************************************/

unsigned int SampleRate6400To8000( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputSampleTime,
                                   int * piOutputSampleTime )
{
  static int iPolyphaseFilter_0[56] =
  {
    755,
    1690,
    -528,
    101,
    80,
    -172,
    235,
    -290,
    339,
    -394,
    448,
    -508,
    568,
    -628,
    685,
    -738,
    785,
    -823,
    849,
    -860,
    851,
    -813,
    738,
    -601,
    355,
    142,
    -1553,
    30880,
    4894,
    -2962,
    2320,
    -1970,
    1728,
    -1538,
    1374,
    -1226,
    1090,
    -960,
    839,
    -723,
    615,
    -513,
    418,
    -331,
    251,
    -180,
    111,
    -49,
    -21,
    103,
    -216,
    410,
    -769,
    1408,
    1099,
    -62
  };

  static int iPolyphaseFilter_1[56] =
  {
    451,
    1776,
    -103,
    -270,
    369,
    -397,
    414,
    -430,
    445,
    -467,
    485,
    -504,
    516,
    -522,
    517,
    -498,
    464,
    -409,
    330,
    -219,
    69,
    137,
    -422,
    836,
    -1484,
    2658,
    -5552,
    27269,
    12825,
    -5641,
    3705,
    -2761,
    2174,
    -1757,
    1435,
    -1172,
    951,
    -760,
    594,
    -449,
    322,
    -211,
    114,
    -31,
    -40,
    101,
    -158,
    209,
    -268,
    337,
    -429,
    574,
    -787,
    963,
    1427,
    81
  };

  static int iPolyphaseFilter_2[56] =
  {
    221,
    1674,
    427,
    -599,
    555,
    -495,
    453,
    -422,
    396,
    -377,
    352,
    -326,
    289,
    -240,
    177,
    -96,
    -2,
    125,
    -276,
    462,
    -690,
    979,
    -1352,
    1862,
    -2619,
    3910,
    -6795,
    20807,
    20807,
    -6795,
    3910,
    -2619,
    1862,
    -1352,
    979,
    -690,
    462,
    -276,
    125,
    -2,
    -96,
    177,
    -240,
    289,
    -326,
    352,
    -377,
    396,
    -422,
    453,
    -495,
    555,
    -599,
    427,
    1674,
    221
  };

  static int iPolyphaseFilter_3[56] =
  {
    81,
    1427,
    963,
    -787,
    574,
    -429,
    337,
    -268,
    209,
    -158,
    101,
    -40,
    -31,
    114,
    -211,
    322,
    -449,
    594,
    -760,
    951,
    -1172,
    1435,
    -1757,
    2174,
    -2761,
    3705,
    -5641,
    12825,
    27269,
    -5552,
    2658,
    -1484,
    836,
    -422,
    137,
    69,
    -219,
    330,
    -409,
    464,
    -498,
    517,
    -522,
    516,
    -504,
    485,
    -467,
    445,
    -430,
    414,
    -397,
    369,
    -270,
    -103,
    1776,
    451
  };

  static int iPolyphaseFilter_4[56] =
  {
    -62,
    1099,
    1408,
    -769,
    410,
    -216,
    103,
    -21,
    -49,
    111,
    -180,
    251,
    -331,
    418,
    -513,
    615,
    -723,
    839,
    -960,
    1090,
    -1226,
    1374,
    -1538,
    1728,
    -1970,
    2320,
    -2962,
    4894,
    30880,
    -1553,
    142,
    355,
    -601,
    738,
    -813,
    851,
    -860,
    849,
    -823,
    785,
    -738,
    685,
    -628,
    568,
    -508,
    448,
    -394,
    339,
    -290,
    235,
    -172,
    80,
    101,
    -528,
    1690,
    755
  };

  static int * ppiPolyphaseFilter[5] =
  {
    &iPolyphaseFilter_0[0],
    &iPolyphaseFilter_1[0],
    &iPolyphaseFilter_2[0],
    &iPolyphaseFilter_3[0],
    &iPolyphaseFilter_4[0]
  };

  register int * piFilterCoefficients;
  register int iFilterIndex;
  register unsigned int uiDelayPosition;
  register int iInputSampleTime;
  register int iOutputSampleTime;
  register unsigned int uiInputIndex = 0;
  register unsigned int uiOutputIndex = 0;

  /********************************************************************/
  /*  Get the input filter state parameters.                          */
  /********************************************************************/

  uiDelayPosition = *puiDelayPosition;
  iInputSampleTime = *piInputSampleTime;
  iOutputSampleTime = *piOutputSampleTime;

  /********************************************************************/
  /*  Loop and process all of the input samples.                      */
  /********************************************************************/

  while ( uiInputIndex < uiInputBufferLength )
  {
    /******************************************************************/
    /*  Put input samples in interpolator delay buffer until we       */
    /*  catch up to the next output sample time index.                */
    /******************************************************************/

    while (( iInputSampleTime <= iOutputSampleTime )
      && ( uiInputIndex < uiInputBufferLength ))
    {
      /****************************************************************/
      /*  Put a new imput sample in the polyphase filter delay line.  */
      /****************************************************************/

      piFilterDelay[uiDelayPosition++] = (int)pwInputBuffer[uiInputIndex++];

      if ( uiDelayPosition >= RU_POLYPHASE_FILTER_LENGTH )
      {
        uiDelayPosition = 0;
      }

      /****************************************************************/
      /*  Increment the input sample time index.                      */
      /****************************************************************/

      iInputSampleTime += RU_INPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Calculate output samples using the interpolator until we      */
    /*  reach the next input sample time.                             */
    /******************************************************************/

    while ( iOutputSampleTime < iInputSampleTime )
    {
      /****************************************************************/
      /*  Calculate the polyphase filter index that corresponds to    */
      /*  the next output sample.                                     */
      /****************************************************************/

      iFilterIndex = iOutputSampleTime;

      while ( iFilterIndex >= RU_INPUT_SAMPLE_STEP )
      {
        iFilterIndex = iFilterIndex - RU_INPUT_SAMPLE_STEP;
      }

      /****************************************************************/
      /*  Get the polyphase filter coefficients.                      */
      /****************************************************************/

      piFilterCoefficients = ppiPolyphaseFilter[iFilterIndex];

      /****************************************************************/
      /*  Apply the polyphase filter.                                 */
      /****************************************************************/

      pwOutputBuffer[uiOutputIndex++] =
        (short)FirFilter( piFilterCoefficients,
                          piFilterDelay,
                          uiDelayPosition,
                          RU_POLYPHASE_FILTER_LENGTH );

      /****************************************************************/
      /*  Increment the output sample time index.                     */
      /****************************************************************/

      iOutputSampleTime += RU_OUTPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Wrap the input and output times indices so they don't         */
    /*  overflow and go back to process more of the input block.      */
    /******************************************************************/

    if ( iInputSampleTime >= RU_STEP_PRODUCT )
    {
      iInputSampleTime -= RU_STEP_PRODUCT;
      iOutputSampleTime -= RU_STEP_PRODUCT;
    }
  }

  /********************************************************************/
  /*  Save the input filter state parameters.                         */
  /********************************************************************/

  *puiDelayPosition = uiDelayPosition;
  *piInputSampleTime = iInputSampleTime;
  *piOutputSampleTime = iOutputSampleTime;

  /********************************************************************/
  /*  Return the number of samples in the output buffer.              */
  /********************************************************************/

  return uiOutputIndex;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: SampleRate8000To6400                                    */
/*  Author: Bill Hallahan                                             */
/*  Date: March 8, 1997                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*       This function converts a block of audio samples from an      */
/*  8000 Hz. sample rate to a 6400 Hz. sample rate. This is done      */
/*  using a set of polyphase filters that can interpolate up to a     */
/*  32000 Hz. rate ( 32000 is the LCM of 8000 and 6400.)              */
/*                                                                    */
/*       Only the 32000 Hz. samples that correspond to a 6400 Hz.     */
/*  sample rate are calculated. The input 8000 Hz. rate corresponds   */
/*  to every 4th (32000/8000) sample at the 32000 Hz. rate. The       */
/*  output 6400 Hz. rate corresponds to every 5th (32000/6400)        */
/*  sample at the 32000 Hz. rate. Since the LCM of 4 and 5 is 20,     */
/*  then the pattern of sample insertion and polyphase filter         */
/*  selection will repeat every 20 output samples.                    */
/*                                                                    */
/*                                                                    */
/*  Inputs:                                                           */
/*                                                                    */
/*    pwInputBuffer       A pointer to an input buffer of samples     */
/*                        that are sampled at an 8000 Hz. rate. The   */
/*                        samples are in Q15 format and must be       */
/*                        in the range of ( 1 - 2^-15) to -1.         */
/*                                                                    */
/*    pwOutputBuffer      A buffer that returns the output data       */
/*                        which is the input buffer data resampled    */
/*                        at 6400 Hz. Since this is a lower sample    */
/*                        rate than the input rate the data is also   */
/*                        low pass filtered during the conversion     */
/*                        process. The low pass filter cutoff         */
/*                        frequency is at 3000 Hz. All alias          */
/*                        products are down at least 60 dB. past      */
/*                        3100 Hz.                                    */
/*                                                                    */
/*                        The output bufer length MUST be large       */
/*                        enough to accept all of the output data.    */
/*                        The minimum length of the output buffer     */
/*                        is 4/5 times the number of samples in the   */
/*                        input buffer. ( 6400/8000 = 4/5 )           */
/*                                                                    */
/*    uiInputLength       The number of samples in the input buffer.  */
/*                                                                    */
/*                                                                    */
/*                       THE FOLLOWING INPUT VARIABLES ARE USED       */
/*                       TO MAINTAIN STATE INFORMATION BETWEEN        */
/*                       CALLS TO THIS ROUTINE.                       */
/*                                                                    */
/*                                                                    */
/*    piFilterDelay       A pointer to a delay line that is used      */
/*                        for FIR filtering. This  must be the        */
/*                        length of the polyphase filter's impulse    */
/*                        response. For this routine this is 23.      */
/*                        This buffer should be initialized to zero   */
/*                        once at system initialization.              */
/*                                                                    */
/*    puiDelayPosition    A pointer to an index into the filter       */
/*                        delay line. This index value should be      */
/*                        initialized to zero at system startup       */
/*                                                                    */
/*    piInputSampleTime   A pointer to the input sample time.         */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to track the input        */
/*                        stream time relative to the output stream   */
/*                        time. This time difference is used to       */
/*                        determine whether a new input sample        */
/*                        should be put into the filter delay line.   */
/*                        This should be initialized to zero once     */
/*                        at system initialization.                   */
/*                                                                    */
/*    piOutputSampleTime  A pointer to the output sample time.        */
/*                        This time is reset to zero by this routine  */
/*                        when is reaches the value STEP_PRODUCT.     */
/*                        This time is used to determine if a new     */
/*                        polyphase filter should be applied to the   */
/*                        input sample stream. This is also used to   */
/*                        select the particular polyphase filter      */
/*                        that is applied.                            */
/*                                                                    */
/*  Outputs:                                                          */
/*                                                                    */
/*    This function returns an unsigned integer that is the number    */
/*    of samples in the output buffer. If the number of input samples */
/*    is exactly a multiple of RD_INPUT_SAMPLE_STEP ( 5 ) then this      */
/*    routine will always return the same value. This value will      */
/*    then be 4/5 times the number of input samples.                  */
/*                                                                    */
/*    When this function returns the output buffer contains an array  */
/*    of integers at the new sample rate.                             */
/*                                                                    */
/*                                                                    */
/*  Filter Information:                                               */
/*                                                                    */
/*    The 8000 Hz. -> 32000 Hz. interpolation filter design           */
/*    is shown here.                                                  */
/*                                                                    */
/*               FINITE IMPULSE RESPONSE (FIR)                        */
/*             LINEAR PHASE DIGITAL FILTER DESIGN                     */
/*                 REMEZ EXCHANGE ALGORITHM                           */
/*                                                                    */
/*                      BANDPASS FILTER                               */
/*                                                                    */
/*                    FILTER LENGTH =  92                             */
/*                                                                    */
/*               ***** IMPULSE RESPONSE *****                         */
/*             H(  1) = -0.77523338E-03 = H( 92)                      */
/*             H(  2) = -0.56140189E-03 = H( 91)                      */
/*             H(  3) = -0.26485065E-03 = H( 90)                      */
/*             H(  4) =  0.48529240E-03 = H( 89)                      */
/*             H(  5) =  0.15506579E-02 = H( 88)                      */
/*             H(  6) =  0.25692214E-02 = H( 87)                      */
/*             H(  7) =  0.30662031E-02 = H( 86)                      */
/*             H(  8) =  0.26577783E-02 = H( 85)                      */
/*             H(  9) =  0.12834022E-02 = H( 84)                      */
/*             H( 10) = -0.67870057E-03 = H( 83)                      */
/*             H( 11) = -0.24781306E-02 = H( 82)                      */
/*             H( 12) = -0.32756536E-02 = H( 81)                      */
/*             H( 13) = -0.25334368E-02 = H( 80)                      */
/*             H( 14) = -0.34487492E-03 = H( 79)                      */
/*             H( 15) =  0.24779409E-02 = H( 78)                      */
/*             H( 16) =  0.46604010E-02 = H( 77)                      */
/*             H( 17) =  0.50008399E-02 = H( 76)                      */
/*             H( 18) =  0.29790259E-02 = H( 75)                      */
/*             H( 19) = -0.85979374E-03 = H( 74)                      */
/*             H( 20) = -0.49750470E-02 = H( 73)                      */
/*             H( 21) = -0.74064843E-02 = H( 72)                      */
/*             H( 22) = -0.66624931E-02 = H( 71)                      */
/*             H( 23) = -0.25365327E-02 = H( 70)                      */
/*             H( 24) =  0.35602755E-02 = H( 69)                      */
/*             H( 25) =  0.90023531E-02 = H( 68)                      */
/*             H( 26) =  0.11015911E-01 = H( 67)                      */
/*             H( 27) =  0.80042975E-02 = H( 66)                      */
/*             H( 28) =  0.53222617E-03 = H( 65)                      */
/*             H( 29) = -0.85644918E-02 = H( 64)                      */
/*             H( 30) = -0.15142974E-01 = H( 63)                      */
/*             H( 31) = -0.15514131E-01 = H( 62)                      */
/*             H( 32) = -0.82975281E-02 = H( 61)                      */
/*             H( 33) =  0.44855666E-02 = H( 60)                      */
/*             H( 34) =  0.17722420E-01 = H( 59)                      */
/*             H( 35) =  0.25017589E-01 = H( 58)                      */
/*             H( 36) =  0.21431517E-01 = H( 57)                      */
/*             H( 37) =  0.60814521E-02 = H( 56)                      */
/*             H( 38) = -0.16557660E-01 = H( 55)                      */
/*             H( 39) = -0.37409518E-01 = H( 54)                      */
/*             H( 40) = -0.45595154E-01 = H( 53)                      */
/*             H( 41) = -0.32403238E-01 = H( 52)                      */
/*             H( 42) =  0.50128344E-02 = H( 51)                      */
/*             H( 43) =  0.61689958E-01 = H( 50)                      */
/*             H( 44) =  0.12557802E+00 = H( 49)                      */
/*             H( 45) =  0.18087465E+00 = H( 48)                      */
/*             H( 46) =  0.21291447E+00 = H( 47)                      */
/*                                                                    */
/*                        BAND  1       BAND  2                       */
/*  LOWER BAND EDGE     0.0000000     0.1250000                       */
/*  UPPER BAND EDGE     0.0968750     0.5000000                       */
/*  DESIRED VALUE       1.0000000     0.0000000                       */
/*  WEIGHTING           0.0700000     1.0000000                       */
/*  DEVIATION           0.0136339     0.0009544                       */
/*  DEVIATION IN DB     0.1176231   -60.4056206                       */
/*                                                                    */
/*  EXTREMAL FREQUENCIES--MAXIMA OF THE ERROR CURVE                   */
/*     0.0000000   0.0129076   0.0251359   0.0380435   0.0495924      */
/*     0.0618206   0.0733696   0.0842392   0.0930708   0.0968750      */
/*     0.1250000   0.1270380   0.1331521   0.1413043   0.1501357      */
/*     0.1596465   0.1698367   0.1800269   0.1908964   0.2010865      */
/*     0.2119560   0.2228255   0.2330157   0.2438852   0.2547547      */
/*     0.2656242   0.2764937   0.2873632   0.2982327   0.3091022      */
/*     0.3199717   0.3308412   0.3417107   0.3525802   0.3634497      */
/*     0.3743192   0.3851887   0.3960582   0.4069277   0.4177972      */
/*     0.4293461   0.4402156   0.4510851   0.4619546   0.4728241      */
/*     0.4836936   0.4945631                                          */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Symbol Definitions.                                               */
/**********************************************************************/

#define  RD_INPUT_SAMPLE_STEP        4
#define  RD_OUTPUT_SAMPLE_STEP       5
#define  RD_STEP_PRODUCT             ( RD_INPUT_SAMPLE_STEP * RD_OUTPUT_SAMPLE_STEP )
#define  RD_POLYPHASE_FILTER_LENGTH  23

/**********************************************************************/
/*  Start of SampleRate8000To6400 routine                             */
/**********************************************************************/

unsigned int SampleRate8000To6400( short * pwInputBuffer,
                                   short * pwOutputBuffer,
                                   unsigned int uiInputBufferLength,
                                   int * piFilterDelay,
                                   unsigned int * puiDelayPosition,
                                   int * piInputSampleTime,
                                   int * piOutputSampleTime )
{
  static int iPolyphaseFilter_0[23] =
  {
    62,
    344,
    -424,
    604,
    -644,
    461,
    68,
    -1075,
    2778,
    -5910,
    16277,
    23445,
    -4200,
    788,
    581,
    -1110,
    1166,
    -960,
    648,
    -328,
    166,
    201,
    -100
  };

  static int iPolyphaseFilter_1[23] =
  {
    -34,
    397,
    -321,
    321,
    -111,
    -328,
    1037,
    -2011,
    3242,
    -4849,
    7996,
    27598,
    649,
    -2146,
    2297,
    -1962,
    1427,
    -863,
    386,
    -44,
    -87,
    333,
    -72
  };

  static int iPolyphaseFilter_2[23] =
  {
    -72,
    333,
    -87,
    -44,
    386,
    -863,
    1427,
    -1962,
    2297,
    -2146,
    649,
    27598,
    7996,
    -4849,
    3242,
    -2011,
    1037,
    -328,
    -111,
    321,
    -321,
    397,
    -34
  };

  static int iPolyphaseFilter_3[23] =
  {
    -100,
    201,
    166,
    -328,
    648,
    -960,
    1166,
    -1110,
    581,
    788,
    -4200,
    23445,
    16277,
    -5910,
    2778,
    -1075,
    68,
    461,
    -644,
    604,
    -424,
    344,
    62
  };

  static int * ppiPolyphaseFilter[4] =
  {
    &iPolyphaseFilter_0[0],
    &iPolyphaseFilter_1[0],
    &iPolyphaseFilter_2[0],
    &iPolyphaseFilter_3[0]
  };

  register int * piFilterCoefficients;
  register int iFilterIndex;
  register unsigned int uiDelayPosition;
  register int iInputSampleTime;
  register int iOutputSampleTime;
  register unsigned int uiInputIndex = 0;
  register unsigned int uiOutputIndex = 0;

  /********************************************************************/
  /*  Get the input filter state parameters.                          */
  /********************************************************************/

  uiDelayPosition = *puiDelayPosition;
  iInputSampleTime = *piInputSampleTime;
  iOutputSampleTime = *piOutputSampleTime;

  /********************************************************************/
  /*  Loop and process all of the input samples.                      */
  /********************************************************************/

  while ( uiInputIndex < uiInputBufferLength )
  {
    /******************************************************************/
    /*  Put input samples in interpolator delay buffer until we       */
    /*  catch up to the next output sample time index.                */
    /******************************************************************/

    while (( iInputSampleTime <= iOutputSampleTime )
      && ( uiInputIndex < uiInputBufferLength ))
    {
      /****************************************************************/
      /*  Put a new imput sample in the polyphase filter delay line.  */
      /****************************************************************/

      piFilterDelay[uiDelayPosition++] = (int)pwInputBuffer[uiInputIndex++];

      if ( uiDelayPosition >= RD_POLYPHASE_FILTER_LENGTH )
      {
        uiDelayPosition = 0;
      }

      /****************************************************************/
      /*  Increment the input sample time index.                      */
      /****************************************************************/

      iInputSampleTime += RD_INPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Calculate output samples using the interpolator until we      */
    /*  reach the next input sample time.                             */
    /******************************************************************/

    while ( iOutputSampleTime < iInputSampleTime )
    {
      /****************************************************************/
      /*  Calculate the polyphase filter index that corresponds to    */
      /*  the next output sample.                                     */
      /****************************************************************/

      iFilterIndex = iOutputSampleTime;

      while ( iFilterIndex >= RD_INPUT_SAMPLE_STEP )
      {
        iFilterIndex = iFilterIndex - RD_INPUT_SAMPLE_STEP;
      }

      /****************************************************************/
      /*  Get the polyphase filter coefficients.                      */
      /****************************************************************/

      piFilterCoefficients = ppiPolyphaseFilter[iFilterIndex];

      /****************************************************************/
      /*  Apply the polyphase filter.                                 */
      /****************************************************************/

      pwOutputBuffer[uiOutputIndex++] =
        (short)FirFilter( piFilterCoefficients,
                          piFilterDelay,
                          uiDelayPosition,
                          RD_POLYPHASE_FILTER_LENGTH );

      /****************************************************************/
      /*  Increment the output sample time index.                     */
      /****************************************************************/

      iOutputSampleTime += RD_OUTPUT_SAMPLE_STEP;
    }

    /******************************************************************/
    /*  Wrap the input and output times indices so they don't         */
    /*  overflow and go back to process more of the input block.      */
    /******************************************************************/

    if ( iInputSampleTime >= RD_STEP_PRODUCT )
    {
      iInputSampleTime -= RD_STEP_PRODUCT;
      iOutputSampleTime -= RD_STEP_PRODUCT;
    }
  }

  /********************************************************************/
  /*  Save the input filter state parameters.                         */
  /********************************************************************/

  *puiDelayPosition = uiDelayPosition;
  *piInputSampleTime = iInputSampleTime;
  *piOutputSampleTime = iOutputSampleTime;

  /********************************************************************/
  /*  Return the number of samples in the output buffer.              */
  /********************************************************************/

  return uiOutputIndex;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\data.c ===
/*
 *   Project:		Direct Subband about 13000 bps coder and SBCELP 4800 bps coder
 *   Workfile:		data.c
 *   Author:		Georges Zanellato, Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	26 October 1995
 *   DLL Version:	1.00
 *   Revision:          Single DLL for coder and decoder.
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */


//#include <math.h>
#include <windows.h>
#include "data.h"

// ------------------------------------------------------------------------
// ROM tables :
// ------------------------------------------------------------------------

short coef_I[Fil_Lenght] = // QMF filter coefficients
			 {    94,   -62,  -528,  3499,
			   15641, -3122,  1178,  -326 };
/****/

short B3_I[2]={-3072, 3072};
short B4_I[3]={-4233,    0, 4233};

short B5_I[4]={-4915,-1638, 1638, 4915};
short B6_I[5]={-5406,-2703,    0, 2703, 5406};

short B7_I[6]={-5802,-3481,-1160, 1160, 3481, 5802};
short B8_I[7]={-6144,-4096,-2048,    0, 2048, 4096, 6144};

short B9_I[8]={-6451,-4607,-2764, -921,  921, 2764, 4607, 6451};



short V3_I[3]={-6144,    0, 6144};                                    // 75   %
short V4_I[4]={-6349,-2116, 2116, 6349};                              // 77.5 %

short V5_I[5]={-6554,-3277,    0, 3277, 6554};                        // 80   %
short V6_I[6]={-6758,-4055,-1352, 1352, 4055, 6758};                  // 82.5 %

short V7_I[7]={-6963,-4642,-2321,    0, 2321, 4642, 6963};            // 85   %
short V8_I[8]={-7168,-5120,-3072,-1024, 1024, 3072, 5120, 7168};      // 87.5 %

short V9_I[9]={-7373,-5529,-3686,-1843,    0, 1843, 3686, 5529, 7373};// 90   %



/**** Nouvelles tables ****/

//short B9_I[8]={-6707,-4791,-2874, -958,  958, 2874, 4791, 6707};      //lineaires
//short V9_I[9]={-7666,-5749,-3833,-1916,    0, 1916, 3833, 5749, 7666};

//short B9_I[8]={-5702,-3154,-1745, -965,  965, 1745, 3154, 5702};      //log
//short V9_I[9]={-7666,-4241,-2346,-1298,    0, 1298, 2346, 4241, 7666};

/****/



/**** Quantif du maximum des ss bandes avec calcul des distances; ****/
/**** les ech. des ss bandes peuvent etre superieurs a 1          ****/
/****/
short max_level[32] = {
	 10,   30,   60,  100,  117,  138,  162,  190,
	223,  262,  308,  361,  425,  499,  586,  688,
	808,  949, 1114, 1308, 1536, 1804, 2119, 2488,
       2922, 3431, 4030, 4732, 5557, 6526, 7664, 9000
	 };

short d_max_level[32] = {		// Division des petites valeurs pour rduire le bruit
	  2,   10,   30,   60,  100,  138,  162,  190,
	223,  262,  308,  361,  425,  499,  586,  688,
	808,  949, 1114, 1308, 1536, 1804, 2119, 2488,
       2922, 3431, 4030, 4732, 5557, 6526, 7664, 9000
	 };
/****/

/**** Cette table est la meme que la precedente mais avec comparaison ****/
/**** simple (les ech des ss bandes seront alors tjs inferieurs a 1)  ****/
/****
short max_level[32] = {  // Quantified maximum sample level
		    20,   45,   80,  109,  128,  150,  176,  207,
		   243,  285,  335,  393,  462,  543,  637,  748,
		   879, 1032, 1211, 1422, 1670, 1962, 2304, 2705,
		  3177, 3731, 4381, 5145, 6042, 7095, 8332,16000
	 };
/****/

/***   New table with new structure (variable threshold)  ***
short max_level[32] = {
		   100,  125,  150,  200,  250,  285,  326,  372,
		   425,  485,  554,  633,  723,  825,  943, 1076,
		  1229, 1404, 1603, 1830, 2090, 2387, 2726, 3113,
		  3554, 4059, 4635, 5293, 6044, 6902, 7881, 9000,
		};
/****/
// Masques utiliss pour le multiplexage et dmultiplexage des trames codes
// Mask[i] donne accs aux i bits de poids faible d'un long
long Mask[9]={0,1,3,7,15,31,63,127,255};

// PhilF: Since these depend on the bit rate, moved them from global to instance data...
//short quantif[2*NBSB_SP_MAX1]={QUANT_LEVELS};
//short bits[NBSB_SP_MAX1]={CODING_BITS};
//short bytes[NBSB_SP_MAX1+1]={OUTPUT_BYTES};

/*short quantif[16]={9,9,7,7,7,6,5,5,5,5,0,0,0,0,0,0};
short bits[8]={52,46,44,38,38,0,0,0};
short bytes[9]={1,9,15,21,26,32,0,0,0};*/

// Hamming window
short hamming[220] =
{   2621,  2628,  2646,  2677,  2721,  2776,  2844,  2924,  3017,  3121,
    3237,  3366,  3506,  3658,  3821,  3996,  4182,  4379,  4587,  4806,
    5035,  5275,  5525,  5786,  6056,  6335,  6624,  6922,  7229,  7544,
    7868,  8200,  8540,  8887,  9242,  9603,  9971, 10346, 10726, 11113,
   11504, 11901, 12303, 12709, 13119, 13533, 13950, 14370, 14793, 15219,
   15646, 16076, 16506, 16938, 17370, 17802, 18235, 18667, 19098, 19528,
   19956, 20382, 20807, 21229, 21648, 22063, 22475, 22883, 23287, 23686,
   24081, 24470, 24853, 25231, 25602, 25967, 26325, 26676, 27019, 27355,
   27683, 28003, 28314, 28616, 28910, 29194, 29469, 29734, 29989, 30234,
   30469, 30693, 30907, 31109, 31301, 31481, 31650, 31808, 31954, 32088,
   32211, 32321, 32419, 32506, 32580, 32642, 32691, 32728, 32753, 32765,
   32765, 32753, 32728, 32691, 32642, 32580, 32506, 32419, 32321, 32211,
   32088, 31954, 31808, 31650, 31481, 31301, 31109, 30907, 30693, 30469,
   30234, 29989, 29734, 29469, 29194, 28910, 28616, 28314, 28003, 27683,
   27355, 27019, 26676, 26325, 25967, 25602, 25231, 24853, 24470, 24081,
   23686, 23287, 22883, 22475, 22063, 21648, 21229, 20807, 20382, 19956,
   19528, 19098, 18667, 18235, 17802, 17370, 16938, 16506, 16076, 15646,
   15219, 14793, 14370, 13950, 13533, 13119, 12709, 12303, 11901, 11504,
   11113, 10726, 10346,  9971,  9603,  9242,  8887,  8540,  8200,  7868,
    7544,  7229,  6922,  6624,  6335,  6056,  5786,  5525,  5275,  5035,
    4806,  4587,  4379,  4182,  3996,  3821,  3658,  3506,  3366,  3237,
    3121,  3017,  2924,  2844,  2776,  2721,  2677,  2646,  2628,  2621
};

short A0[11] = { 32767, 29491, 26542, 23887, 21499, 19349, 17414, 15672, 14105, 12694, 11425};

short LSP0ROM[10] = {1638,  4915,  8192, 11468, 14745, 18022, 21299, 24576, 27852, 31129};

short tabcos[292] =
{  32767, 32512, 32256, 32000, 31744, 31488, 31232, 30976, 30720, 30464,
   30208, 29952, 29696, 29440, 29184, 28928, 28672, 28416, 28160, 27904,
   27648, 27392, 27136, 26880, 26624, 26368, 26112, 25856, 25600, 25344,
   25088, 24832, 24576, 24320, 24064, 23808, 23552, 23296, 23040, 22784,
   22528, 22272, 22016, 21760, 21504, 21248, 20992, 20736, 20480, 20224,
   19968, 19712, 19456, 19200, 18944, 18688, 18432, 18176, 17920, 17664,
   17408, 17152, 16896, 16640, 16384, 16128, 15872, 15616, 15360, 15104,
   14848, 14592, 14336, 14080, 13824, 13568, 13312, 13056, 12800, 12544,
   12288, 12032, 11776, 11520, 11264, 11008, 10752, 10496, 10240,  9984,
    9728,  9472,  9216,  8960,  8704,  8448,  8192,  7936,  7680,  7424,
    7168,  6912,  6656,  6400,  6144,  5888,  5632,  5376,  5120,  4864,
    4608,  4352,  4096,  3840,  3584,  3328,  3072,  2816,  2560,  2304,
    2048,  1792,  1536,  1280,  1024,   768,   512,   256,     0,     0,
    1304,  1846,  2262,  2614,  2924,  3206,  3465,  3707,  3934,  4150,
    4355,  4552,  4741,  4923,  5100,  5271,  5437,  5598,  5755,  5909,
    6059,  6206,  6350,  6491,  6630,  6766,  6899,  7031,  7160,  7288,
    7414,  7538,  7660,  7781,  7900,  8018,  8135,  8250,  8364,  8477,
    8589,  8699,  8809,  8917,  9025,  9131,  9237,  9342,  9446,  9549,
    9651,  9753,  9854,  9954, 10053, 10152, 10251, 10348, 10445, 10542,
   10638, 10733, 10828, 10922, 11016, 11109, 11202, 11295, 11387, 11478,
   11570, 11660, 11751, 11841, 11931, 12020, 12109, 12198, 12286, 12374,
   12462, 12549, 12637, 12723, 12810, 12896, 12983, 13068, 13154, 13240,
   13325, 13410, 13495, 13579, 13664, 13748, 13832, 13916, 14000, 14083,
   14167, 14250, 14333, 14416, 14499, 14582, 14665, 14747, 14830, 14912,
   14994, 15076, 15158, 15240, 15322, 15404, 15486, 15568, 15650, 15731,
   15813, 15894, 15976, 16058, 16139, 16221, 16302, 16384, 32767, 32735,
   32703, 32671, 32639, 32607, 32575, 32543, 32511, 32479, 32447, 32415,
   32383, 32351, 32319, 32287, 32255,     8,   461,   652,   798,   922,
   1031,  1129,  1220,  1304,  1383,  1458,  1530,  1598,  1663,  1726,
   1787,  1846  };

// First table for LSP quantification
short LSP_Q[56]  =
{   819,  1392,  1843,  2048,  2293,  2785,  3440,  4096,  3440,  3768,
   4096,  4423,  4792,  5242,  5775,  6348,  6963,  7782,  8601,  9420,
  10240, 11059, 11878, 12697,  8192,  8601,  9256,  9912, 10526, 11059,
  11714, 12369, 13025, 13680, 14336, 15155, 15974, 16793, 17612, 18432,
  14745, 15400, 16056, 17203, 18841, 20316, 22118, 23756, 22609, 23592,
  24576, 25395, 26214, 27115, 28098, 29081
};

short TAB_DI[38] =
{ 1604,  3522,  5816,  8559, 11839, 15761, 20451, 26060, 32767,
  1825,  4057,  6787, 10125, 14207, 19199, 25303,
  3110,  7402, 13324, 21494, 32767,
  4057, 10125, 19199,
  3110,  7402, 13324, 21494, 32767,
  4057, 10125, 19199,  5816, 15761, 32767,
  10125, 10125, 32767
};

short GQ[17] =  {     0,    37,    81,   132,   194,   266,   352,   454,   575,
		  717,   887,  1087,  1324,  1606,  1939,  2333,  2800 };
short GV[17] =  {     0,     9,    58,   105,   162,   228,   307,   401,   512,
		  643,   798,   983,  1201,  1459,  1765,  2127,  2557 };
short BQ[11] =  {     0,   328,   757,  1320,  2058,  3026,  4295,  5958,
		 8139, 10998, 14746                                    };
short BV[11] =  {     0,   153,   528,  1020,  1664,  2509,  3617,  5070,
		 6975,  9471, 12745                                    };

short NBB[25] = {8,16,16,8,8,
	       0,0,0,0,0,0,0,0,0,0,
	       0,0,0,0,0,0,0,0,0,0};
short BITDD[5] = {9,5,5,3,2};

long coef_i[9] = { -626684736, 7274874, 1238819712, 7274874, -626684736,
	-4058, -23341, 1585, 10127 };

// } ROM TABLES

// -------------------------------------------------------------------------
// RAM variables :
// -------------------------------------------------------------------------
// All in data structures.

// ------------------------------------------------------------------------
void InitializeROM(void)
// Global initializations of ROM tables : should only be called once
{
   // All data hardcoded. no initialization needed.
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\fv_h8.h ===
/*
 *   Project:		LHCODING.DLL  (L&H Speech Coding SDK)  
 *   Workfile:		fv_m8.h     
 *   Author:		Alfred Wiesen 
 *   Created:		13 June 1995    
 *   Last update:	13 June 1995
 *   DLL Version:	1   
 *   Revision:		Version 1.0 of FASTVOX_XXX splitted versions
 *   Comment:   
 *
 *	(C) Copyright 1993-94 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company cnfidential.
 */

# ifndef __FV_H8_H  /* avoid multiple include */

# define __FV_H8_H

/*
 *  Type definition for the L&H functions returned values
 */

typedef DWORD LH_ERRCODE;

typedef struct CodecInfo_tag {
   WORD wPCMBufferSize;
   WORD wCodedBufferSize;
   WORD wBitsPerSamplePCM;
   DWORD dwSampleRate;
   WORD wFormatSubTag;
   char wFormatSubTagName[40];
   DWORD dwDLLVersion;
} CODECINFO, near *PCODECINFO, far *LPCODECINFO;


/*
 *  Possible values for the LH_ERRCODE type
 */

# define LH_SUCCESS 0    /* everything is OK */
# define LH_EFAILURE -1  /* something went wrong */
# define LH_EBADARG -2   /* one of the given argument is incorrect */
# define LH_BADHANDLE -3 /* bad handle passed to function */

/*
 *  Some real types are defined here
 */

# ifdef __cplusplus
	# define LH_PREFIX extern "C"
# else
	# define LH_PREFIX
# endif

# define LH_SUFFIX FAR PASCAL

/*
 *  The function prototypes for 16000 bps, 8000 Hz, Fixed point
 */

LH_PREFIX HANDLE LH_SUFFIX
	LHSB_FIXv0808K_Open_Coder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Encode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Close_Coder( HANDLE hAccess);

LH_PREFIX HANDLE LH_SUFFIX
	LHSB_FIXv0808K_Open_Decoder( void );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Decode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX
	LHSB_FIXv0808K_Close_Decoder( HANDLE hAccess);

LH_PREFIX void LH_SUFFIX
	LHSB_FIXv0808K_GetCodecInfo(LPCODECINFO lpCodecInfo);


# endif  /* avoid multiple include */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\encoder.c ===
/*#define __TEST

#ifdef __TEST
#include <stdio.h>
FILE *test;
FILE *codage;
#endif*/

/*
 *   Project:		Direct Subband 16000 bps coder and SBCELP 4800 bps coder
 *   Workfile:		encoder.c
 *   Author:		Alfred Wiesen
 *   Created:		30 August 1995
 *   Last update:	4 September 1995
 *   DLL Version:	1.00
 *   Revision:          Single DLL for coder and decoder.
 *   Comment:
 *
 *	(C) Copyright 1993-95 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */


// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Included files
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
#include <math.h>
#include <windows.h>
#include <windowsx.h>

#include "fv_x8.h"
#include "data.h"
#include "bib_32.h"

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function prototypes
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
void InitializeCoderInstanceData(PVOID p, DWORD dwMaxBitRate);
void decimation_I(short input_I[],short coef_I[],short low_part_mem_I[],short order);
#if 0
// PhilF: The following is never called!!!
void quant_0a16_I2(short z1, short z2 ,short vec[], short maxv, short B1[], short B2[], long *code);
#endif
void quant_sous_bandes(PC16008DATA p,short *in,short *codes_max, long *codes_sb, short *indic_br/*, short *code_max_br*/);
void code_res_I(PC16008DATA p,short input[],short coef[],short qmf_mem[],short v_code[],long cod_long[], short ind_br[]/*, short c_max_br*/);
#ifdef CELP4800
void COEFF_A(PC4808DATA p),CALPITCH(PC4808DATA p),CHERCHE(PC4808DATA p);
void PERIODE(PC4808DATA p,short no),FRAME(PC4808DATA p);
void lsp_quant(PC4808DATA p,short lsp[],short nbit[],short bitdi[],short vcode[]);
void cal_dic1(PC4808DATA p,short *y,short *sr,short *espopt,short *posit,short dec,short esp,short sigpit[],short soulong,long tlsp[],long vmax[]);
//void cal_dic2(short q,short espace,short phase,short *s_r,short *hy,short *b,short *vois,short *esp,short *qq,short *phas,short sigpit[],short soulong,long tlsp[],long vmax[]);
void cal_dic2(PC4808DATA p,short q,short espace,short phase,short *s_r,short *hy,short *b,short *vois,short *esp,short *qq,short *phas);
#endif
void decimation(short *vin,short *vout,short nech);

/*void iConvert64To8(int *in, int *out, int N, int *mem);
void iConvert8To64(int *in, int *out, int N, int *mem);
void BandPass(int *,int *,int *,int);*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Global variables for coder
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

/*#define MAXCODINGHANDLES 10

// Instance data structure
PC16008DATA pCoderData;
C16008DATA CoderData[MAXCODINGHANDLES];
int CodingHandles[MAXCODINGHANDLES];*/

// ROM tables :
extern short coef_I[];		// QMF filter coeffs
extern short B3_I[];		// Five levels quantification table
extern short B4_I[];		// Four  levels quantification table
extern short B5_I[];		// Five levels quantification table
extern short B6_I[];		// Nine levels quantification table
extern short B7_I[];		// Nine levels quantification table
extern short B8_I[];		// Nine levels quantification table
extern short B9_I[];		// Nine levels quantification table
extern short max_level[];			// Quantified maximum sample level
extern long coeffs[];
extern long Mask[];
extern short hamming[];
extern short A0[];
extern short tabcos[];
extern short LSP_Q[];
extern short TAB_DI[];
extern short GQ[];
extern short GV[];
extern short BQ[];
extern short BV[];
extern short NBB[];
extern short BITDD[];
extern short LSP0ROM[];
//extern short quantif[];
//extern short bits[];
//extern short bytes[];

// RAM variables :
/*extern short codes_max[];		// Quantized max. of each subband
extern long codes_sb[];		// Two codes for each of the quantized subband
extern short indic_sp[];		// type of subband (1=noise; 0=to be decoded)
extern short code_max_br;		// 1 bit for coding the noise
extern short DATA_I[];            // Intermediate vector = input and output of QMF
extern char stream[];				// Coded data buffer*/

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// Function implementation
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
void InitializeCoderInstanceData(PVOID p, DWORD dwMaxBitRate)
// Instance data initializations
{
  short i;

#ifdef CELP4800
  if (dwMaxBitRate == 4800)
    {
    ((PC4808DATA)p)->dwMaxBitRate = dwMaxBitRate;

    ((PC4808DATA)p)->mem_pit[0]=((PC4808DATA)p)->mem_pit[1]=69;
    for (i=0;i<10;i++)
      ((PC4808DATA)p)->LSP0[i]=LSP0ROM[i];
    }
  else
#endif
    {
    ((PC16008DATA)p)->dwMaxBitRate = dwMaxBitRate;

    for (i=0;i<NBFAC;i++) ((PC16008DATA)p)->nbbit[i]=8; // On met les compteurs a "zero";
    // on suppose demarrer par du bruit

    ((PC16008DATA)p)->MAX_LEVEL   = MAX_LEVEL1; // valeur par defaut si le debit n'augmente pas trop
    ((PC16008DATA)p)->DIV_MAX     = DIV_MAX1; // cad on ne traite pas les sb < 5% du max[i]

    ((PC16008DATA)p)->quantif[0] = 9;
    ((PC16008DATA)p)->quantif[1] = 9;
    ((PC16008DATA)p)->quantif[4] = 5;
    ((PC16008DATA)p)->quantif[5] = 5;
    ((PC16008DATA)p)->quantif[6] = 5;
    ((PC16008DATA)p)->quantif[7] = 5;
    ((PC16008DATA)p)->quantif[8] = 5;
    ((PC16008DATA)p)->quantif[9] = 5;
    ((PC16008DATA)p)->bits[0] = 52;
    ((PC16008DATA)p)->bits[2] = 38;
    ((PC16008DATA)p)->bits[3] = 38;
    ((PC16008DATA)p)->bits[4] = 38;
	// Bug 3214: Just in case we get carried away, init the end of the arrays in both configurations
	((PC16008DATA)p)->quantif[10] = 5;
	((PC16008DATA)p)->quantif[11] = 5;
	((PC16008DATA)p)->bits[5] = 38;
    if (dwMaxBitRate == 16000)
      {
      ((PC16008DATA)p)->NBSB_SP_MAX = NBSB_SP_MAX1_16000; // nbre max de sb pouvant etre du signal
      ((PC16008DATA)p)->quantif[2] = 7;
      ((PC16008DATA)p)->quantif[3] = 7;
      ((PC16008DATA)p)->bits[1] = 46;
      }
    else
      {
      ((PC16008DATA)p)->NBSB_SP_MAX = NBSB_SP_MAX1_8000_12000; // nbre max de sb pouvant etre du signal
      ((PC16008DATA)p)->quantif[2] = 9;
      ((PC16008DATA)p)->quantif[3] = 9;
      ((PC16008DATA)p)->bits[1] = 52;
      }
    }
   return;
}

//------------------------------------------------------------------------
void decimation_I(short input_I[],short coef_I[],short low_part_mem_I[],short order)
//
// Purpose : from data stored in DATA[], create the N_SB subbands
// Remark  : output subband is stored at (input[]+N_SB*L_RES)
//
{
   short i,j,lng;

   short *low_out_part_I;
   short *high_out_part_I;
   short *buffer_I,*sa_vec_I;

   buffer_I = low_part_mem_I;

   for (i=0;i<N_SB;i++)
   {
      low_out_part_I=input_I+L_RES;
      lng = L_RES >> (i+1);
      high_out_part_I=low_out_part_I+lng;
      sa_vec_I=low_out_part_I;
      for (j=0;j<(1<<i);j++)
      {
	 low_part_mem_I=buffer_I;

	 QMFilter(input_I,coef_I,low_out_part_I,high_out_part_I,low_part_mem_I,lng);

	 input_I += 2*lng;  low_out_part_I += lng; high_out_part_I += lng;

	 if (j&1) high_out_part_I += 2*lng;
	 else low_out_part_I += 2*lng;

	 buffer_I += 2*order;
      }
      input_I=sa_vec_I;
   }
}

#if 0
// PhilF: The following is never called!!!
//------------------------------------------------------------------------
void quant_0a16_I2(short z1, short z2, short vec[], short maxv, short B1[], short B2[], long *code)

// Quantifies the 16 samples of a subband on z levels using the table B[]
// Result stored in code[] (two long codes pro subband).
{
   short i,x;
   short ftmp;
   long result;

   result=0;
   for (i=0;i<8;i++)	// Quantify the first eight samples of the subband
      {
      ftmp=(((long)vec[i])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *code=result;	// Store code

   result=0;
   for (i=0;i<8;i++)	// Quantify the last eight samples of the subband
      {
      ftmp=(((long)vec[i+8])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *(code+1)=result;	// Store code

}
#endif

void quant_0a16_I3(short z1, short z2, short vec[], short maxv, long *code)

// Quantifies the 16 samples of a subband on z levels using the table B[]
// Result stored in code[] (two long codes pro subband).
{
   short i,x;
   short ftmp;
   long result;
   short *B1,*B2;

   switch (z1)
   {
      case 3: B1=B3_I; break;
      case 4: B1=B4_I; break;
      case 5: B1=B5_I; break;
      case 6: B1=B6_I; break;
      case 7: B1=B7_I; break;
      case 8: B1=B8_I; break;
      case 9: B1=B9_I; break;
	// Bug 3214: Just in case we're passed a bogus value, set a default quantizer
	default: B1=B5_I; break;
   }
   switch (z2)
   {
      case 3: B2=B3_I; break;
      case 4: B2=B4_I; break;
      case 5: B2=B5_I; break;
      case 6: B2=B6_I; break;
      case 7: B2=B7_I; break;
      case 8: B2=B8_I; break;
      case 9: B2=B9_I; break;
	// Bug 3214: Just in case we're passed a bogus value, set a default quantizer
	default: B2=B5_I; break;
   }

   result=0;
   for (i=0;i<8;i++)	// Quantify the first eight samples of the subband
      {
      ftmp=(((long)vec[i])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *code=result;	// Store code

   result=0;
   for (i=0;i<8;i++)	// Quantify the last eight samples of the subband
      {
      ftmp=(((long)vec[i+8])<<13)/maxv;
      x=0;
      if (i==2*(short)(i/2))
	{
	while((ftmp>B1[x])&&(x<z1-1)) x++; result*=z1;
	}
      else
	{
	while((ftmp>B2[x])&&(x<z2-1)) x++; result*=z2;
	}
      result+=x;	// Construct long code
      }
   *(code+1)=result;	// Store code

}

//------------------------------------------------------------------------
void quant_sous_bandes(PC16008DATA p,short *in,short *codes_max, long *codes_sb, short *indic_sp)

// Quantifies the eight subbands

{
   short max[8];
   short order[8]={0,0,0,0,0,0,0,0};
   short codes_max_loc[8]={0,0,0,0,0,0,0,0};
   short maximum,max_num,ord,maxmax;
   short i,j;
  #ifdef MAX_SB_ABSOLU
   short sb_count;
  #endif

   for (i=0;i<8;i++)	// Quantify the maximums of the subbands
      {
      max[i]=0;
      for (j=0;j<16;j++)
	if (abs(*(in+16*i+j))>max[i]) max[i]=abs(*(in+16*i+j));
      }

   for (i=0;i<8;i++)
     {
     if (max[i]>2*max_level[31]) j = 31;
     else                      for (j=0; max[i]>2*max_level[j]; j++);
     codes_max_loc[i]=j;
     max[i]=2*max_level[j];
     }  // fin quantifiation

   p->nbbit_cf+=8; // 8 bits for the indic_sp

   maxmax=0;
   for (i=0;i<8;i++) // On cherche le plus grand maximum
     {
     if (max[i]>maxmax) maxmax=max[i];
     }
   maxmax/=p->DIV_MAX;  // On le divise par 10 a 20 (cad a peu pres 10 a 5 %)

   ord=8;
   p->nbsb_sp=0;
   for (i=0;i<8;i++)	// Calculates the order of the subbands
     {                  // 1 is higher energy than 2 than 3,..
     maximum=32767;
     for (j=7;j>=0;j--)
       {
       if ((order[j]==0)&&(max[j]<maximum))
	 {
	 max_num=j; maximum=max[j];
	 }
       }
     order[max_num]=ord;
     if ( (ord>p->NBSB_SP_MAX)||(maximum<=p->MAX_LEVEL)||(maximum<=maxmax) )
       {
       indic_sp[max_num]=0; // c'est 1 bande qui sera du bruit
       }
     else
       {
       indic_sp[max_num]=1;
       p->nbsb_sp++;
       }
     ord--;
     }

   j=0;
   for (i=0;i<8;i++)
   {
     if (indic_sp[i]==1)
     {
       codes_max[j]=codes_max_loc[i];  //5* 4 ou 5 bits suffisent
       j++;
       p->nbbit_cf+=5; // 5 bits per coded max
     }
   }

   for (i=p->nbsb_sp-1;i>=0;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     quant_0a16_I3(p->quantif[2*i],p->quantif[2*i+1],in+j*16,max[j],codes_sb+2*i);
     p->nbbit_cf+=p->bits[i];
     }

  if (p->dwMaxBitRate == 16000)
    {
   j=0;
  #ifdef MAX_SB_ABSOLU
   sb_count=p->nbsb_sp;
   if (sb_count>=MAX_SB_ABSOLU) return;
  #endif

   for (i=0;i<8;i++)
   {
     if (indic_sp[i]==0)
     {
       codes_max[p->nbsb_sp+j]=codes_max_loc[i];  //5* 4 ou 5 bits suffisent
       j++;
       p->nbbit_cf+=5; // 5 bits per coded max
      #ifdef MAX_SB_ABSOLU
       sb_count++;
       quant_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,in+i*16,max[i],codes_sb+2*sb_count);
       p->nbbit_cf+=SILENCE_CODING_BIT_16000;
       if (sb_count>=MAX_SB_ABSOLU) break;
      #endif
     }
   }

  #ifndef MAX_SB_ABSOLU
   for (i=7;i>=p->nbsb_sp;i--)
     {
     j=0;
     while (order[j]!=i+1) j++;
     quant_0a16_I3(SILENCE_QUANT_LEVEL_16000,SILENCE_QUANT_LEVEL_16000,in+j*16,max[j],codes_sb+2*i);
     p->nbbit_cf+=SILENCE_CODING_BIT_16000;
     }
  #endif

  }
}

//------------------------------------------------------------------------

void code_res_I(PC16008DATA p,short input[],short coef[],short qmf_mem[],short v_code[],long cod_long[], short ind_br[]/*, short c_max_br*/)

{
   decimation_I(input,coef,qmf_mem,Fil_Lenght);
   quant_sous_bandes(p,input+3*L_RES,v_code,cod_long,ind_br/*AW,&c_max_br*/);
}

//------------------------------------------------------------------------
short Multiplexing(
	char *Stream,
	long *Codes,
	short *CodeSizes,
	short NumCodes,
	short StreamSize)
{
   short B,P;	// B=bits  coder, P=bits libres
   short i,j;

   #ifdef __CHECK_FORMAT
   long TotalBytes=0;

   for (i=0;i<NumCodes;i++) TotalBytes+=CodeSizes[i];
   if (TotalBytes>StreamSize*8) return 1;
   #endif

   i=0;
   j=0;
   B=CodeSizes[i];	// bits  coder
   P=8;			// 1 octet libre au dpart
   Stream[j]=0;
   while (i<NumCodes)
   {
      if (P>B)
      {
	 Stream[j]|=(Codes[i]&Mask[B])<<(P-B);
	 P-=B;
	 i++;
	 B=CodeSizes[i];
      }
      else if (P<B)
      {
	 Stream[j]|=(Codes[i]>>(B-P))&Mask[P];
	 B-=P;
	 P=8;
	 j++;
	 Stream[j]=0;
      }
      else
      {
	 Stream[j]|=Codes[i]&Mask[P];
	 i++;
	 j++;
	 P=8;
	 B=CodeSizes[i];
	 Stream[j]=0;
      }
   }
   return 0;
}

// ------------------------------------------------------------------------
#ifdef CELP4800
void iteration(PC4808DATA p,long *P,short n,short *s)
{
   short i;

   p->a=0x7fffffffL;
   for(i=0;i<7 ;i++)
   {
      horner(P,p->ttt,&p->a,n,*s);
      horner(p->ttt,p->TLSP+12,&p->b,(short)(n-1),*s);

      *s += calcul_s(p->a,p->b);
   }
   horner(P,p->ttt,&p->a,n,*s);
   *(P+n) = 0;
   long_to_long(p->ttt,P,n);
}

// ------------------------------------------------------------------------
void ai_to_lsp(PC4808DATA p,long *ai_pq,short *lsp)
{
   short s;  short n;

   ai_to_pq(ai_pq,10);

   s=0x7fff;
   p->ptr1 = lsp;
   for(n=5; n>2; n--)
   {
      iteration(p,ai_pq,n,&s);
      *p->ptr1++ = s;
      if (lsp[0]<0) lsp[0]=s=32765;
      iteration(p,ai_pq+6,n,&s);
      *p->ptr1++ = s;
   }
   binome(lsp+6,ai_pq);
}

// ------------------------------------------------------------------------
void cal_dic1(PC4808DATA p,short *y,short *sr,short *espopt,short *posit,short dec,short esp,
		short *sigpi,short soulong,long *tlsp,long *vmax)
{
   short i,k,limite;
   long  *vene;

   vene = (long *)(sigpi+150);
   venergy(y,vene,soulong);

   k=soulong-1;

   for (i=0;i<dec;i++)
   {
      p->ptr1 = sr;limite=i;
      *tlsp = *(p->ptr1+limite); limite += esp;
      while (limite<soulong) { *tlsp += *(p->ptr1+limite); limite += esp;}
      *(tlsp+1) = *(vene+k-i);
      limite=upd_max_d(tlsp,vmax);
      if (limite) {*posit=i; *espopt=esp; *posit=i; *espopt=esp;}
   }
}

// ------------------------------------------------------------------------
void cal_dic2(PC4808DATA p,short q,short espace,short phase,short *s_r,short *hy,
	     short *b,short *vois,short *esp,short *qq,short *phas)
{
   short i,j,i0,k;
   short src[10],*y2; short cc[10];
   long R11;

   y2 = p->SIGPI+75;
   R11 = 0;
   init_zero(y2,p->SOULONG);

   for (j=0;j<q;j++)
   {
      i0=espace*j+phase;
      src[j]=s_r[i0];
   }

   for (j=0;j<q;j++) if (src[j]>0) cc[j]=1;
			     else  cc[j]=-1;


   for (i=0;i<q;i++) R11 += abs(src[i]);

   for (j=0;j<q;j++)
   {
      i0=espace*j+phase;
      k=cc[j];
      if (k>0)
      {
	 add_sf_vect(y2,hy,i0,p->SOULONG);
      }
      else
      {
	 sub_sf_vect(y2,hy,i0,p->SOULONG);
      }
   }

   energy2(y2,p->TLSP+1,p->SOULONG);

   *p->TLSP=R11;
   i = upd_max_d(p->TLSP,p->VMAX);
   if (i)   { short_to_short(cc,b,q); *vois=0; *esp=espace; *qq=q; *phas=phase; }

   /* for (i=0;i<q;i++)
   {
      cc[i]=-cc[i];
      *TLSP = R11 + 2*src[i]*cc[i];
      k=2*cc[i];
      i0=espace*i+phase;
      update_dic(y1,y2,hy,SOULONG,i0,k);
      energy2(y1,TLSP+1,SOULONG);
      k = upd_max_d(TLSP,VMAX);
      if (k)
      {
	 short_to_short(cc,b,q);
	 R11 = *TLSP;
	 my2=y1; y1=y2; y2=my2;
	 *vois=0; *esp=espace; *qq=q; *phas=phase;
      }
      else cc[i]=-cc[i];
   }*/
}

/*-------------------------------------------------------------------------
Review version of CAL_DIC2
{
   R11 = 0;
   init_zero(y2,SOULONG);
   i0=phase-espace;
   for (j=0;j<q;j++)
   {
      i0+=espace;
      src[j]=s_r[i0];
      if (src[j]>0)
      {
	 cc[j]=1;
	 R11 += (long)(src[j]);
	 add_sf_vect(y2,hy,i0,SOULONG);
      }
      else
      {
	 cc[j]=-1;
	 R11 -= (long)(src[j]);
	 sub_sf_vect(y2,hy,i0,SOULONG);
      }
   }
   energy2(y2,TLSP+1,SOULONG);
   *TLSP=R11;
   i = upd_max_d(TLSP,VMAX);
   if (i)   { short_to_short(cc,b,q); *vois=0; *esp=espace; *qq=q; *phas=phase; }

   i0=phase-espace;
   for (i=0;i<q;i++)
   {
      cc[i]=-cc[i];
      *TLSP = R11 + 2*src[i]*cc[i];
      k=2*cc[i];
      i0+=espace;
      update_dic(y1,y2,hy,SOULONG,i0,k);
      energy2(y1,TLSP+1,SOULONG);
      k = upd_max_d(TLSP,VMAX);
      if (k)
      {
	 short_to_short(cc,b,q);
	 R11 = *TLSP;
	 my2=y1; y1=y2; y2=my2;
	 *vois=0; *esp=espace; *qq=q; *phas=phase;
      }
      else cc[i]=-cc[i];
   }
}
-----------------------------------------------------------------------*/

// ------------------------------------------------------------------------
void left_correl(PC4808DATA p,short vech[],short debut,short fin,short pitch,short delta,long *vv)
{
   short i,k,lng;

   lng=fin-debut+1;
   i=pitch-delta;

   energy(vech+debut-i,p->TLSP+2,lng);
   correlation(vech+debut-i,vech+debut,p->TLSP,lng);
   norm_corrl(vv,p->TLSP);

   for (i=pitch-delta+1;i<=pitch+delta;i++)
   {
      correlation(vech+debut-i,vech+debut,p->TLSP,lng);
      p->TLSP[10] = (long)vech[debut-i]*(long)vech[debut-i];
      p->TLSP[11] = (long)vech[fin-i+1]*(long)vech[fin-i+1];
      upd_ene(p->TLSP+2,p->TLSP+10);
      k=i-pitch+delta;
      norm_corrl(vv+2*k,p->TLSP);
   }
}

// ------------------------------------------------------------------------
void right_correl(PC4808DATA p,short vech[],short debut,short fin,short pitch,short delta,long *vv)
{
   short i,k,lng;

   lng=fin-debut+1;
   i=pitch-delta;
   energy(vech+debut+i,p->TLSP+2,lng);
   correlation(vech+debut+i,vech+debut,p->TLSP,lng);

   norm_corrr(vv,p->TLSP);

   for (i=pitch-delta+1;i<=pitch+delta;i++)
   {
      correlation(vech+debut+i,vech+debut,p->TLSP,lng);
      p->TLSP[11]=(long)vech[debut+i-1]*(long)vech[debut+i-1];
      p->TLSP[10]=(long)vech[fin+i]*(long)vech[fin+i];
      upd_ene(p->TLSP+2,p->TLSP+10);
      k=i-pitch+delta;
      norm_corrr(vv+2*k,p->TLSP);
   }
}

// ------------------------------------------------------------------------
void COEFF_A(PC4808DATA p)
{
   fenetre(p->SIG+SOUDECAL1-RECS2,hamming,p->SIGPI,NECHFEN);
   autocor(p->SIGPI,p->TLSP,NECHFEN,NETAGES);

   // TLSP[0]=ldiv(TLSP[0]*1001L,1000L);
   if (*p->TLSP)
     {
     schur(p->LSP,p->TLSP,NETAGES);

     ki_to_ai(p->LSP,p->TLSP,NETAGES);
     ai_to_lsp(p,p->TLSP,p->LSP);
     cos_to_teta(tabcos,p->LSP,10);
     }
   else short_to_short(p->LSP0,p->LSP,10);

   lsp_quant(p,p->LSP,NBB,BITDD,p->code);

   short_to_short(p->LSP,p->A3,10);
   teta_to_cos(tabcos,p->A3,10);
   lsp_to_ai(p->A3,p->TLSP,10);

   interpol(p->LSP0,p->LSP,p->A1,NETAGES);
   teta_to_cos(tabcos,p->A1,10);
   lsp_to_ai(p->A1,p->TLSP,10);

   interpol(p->LSP,p->LSP0,p->A2,NETAGES);
   teta_to_cos(tabcos,p->A2,10);
   lsp_to_ai(p->A2,p->TLSP,10);

   short_to_short(p->LSP,p->LSP0,NETAGES);
}

// ------------------------------------------------------------------------
void lsp_quant(PC4808DATA p,short lsp[],short nbit[],short bitdi[],short vcode[])
{
   short i,iopt,k,nombi,m,m1,k2;
   short *delta,*lsptab,dmin,tmp,demi;

   delta = p->E;
   lsptab = LSP_Q;

   m1 = NETAGES/2;
   for (i=0;i<nbit[0];i++) delta[i]=abs(lsp[0] - *(lsptab+i) );
   dmin=delta[0];
   iopt=0;
   for (i=1;i<nbit[0];i++)
      if (delta[i]<dmin)
      {
	 dmin=delta[i];
	 iopt=i;
      }
   lsp[0] = *(lsptab+iopt);
   vcode[0]=iopt;

   for (k=1;k<m1;k++)
   {
      k2=2*k;
      lsptab += nbit[k-1];
      for (i=0;i<nbit[k];i++) delta[i]=abs(lsp[k2] - *(lsptab+i));
      dmin=32767;
      tmp=lsp[k2-1];
      if (tmp<lsp[k2-2]) tmp=lsp[k2-2];
      for (i=0;i<nbit[k];i++)
	 if (*(lsptab+i)>tmp)
	    if (delta[i]<dmin)
	    {
	       dmin=delta[i];
	       iopt=i;
	    }
      lsp[k2] = *(lsptab+iopt);
      vcode[k2] = iopt;
   }

   lsptab = TAB_DI;
   for (k=0; k<m1-1; k++)
   {
      k2 = k<<1;
      m=bitdi[k];
      nombi = (m-1)<<1;
      demi=(lsp[k2+2]-lsp[k2]+1)>>1;
      for (i=0;i<m;i++)
	 delta[i]=lsp[k2] + (short)(((long)*(lsptab++)* (long)demi+(long)16384<<1)>>16);
      for (i=0;i<m-2;i++) delta[m+i]=lsp[k2+2] - (short)(((long)*(lsptab++) * (long)demi+(long)16384<<1)>>16);
	 dmin=32767;
      for (i=0;i<nombi;i++)
      {
	 tmp = abs(lsp[k2+1]-delta[i]);
	 if (tmp<dmin)
	 {
	    iopt=i;
	    dmin=tmp;
	 }
      }
      lsp[k2+1]=delta[iopt];
      vcode[k2+1]=iopt;
   }
   m=bitdi[k];
   nombi=(m-1)<<1;
   demi=(32767-lsp[8]+1)>>1;
   for (i=0;i<m;i++) delta[i] = lsp[8] + (short)(((long)*(lsptab++) * (long)demi+(long)16384<<1)>>16);
   dmin=32767;
   for (i=0;i<nombi;i++)
   {
      tmp = abs(lsp[9]-delta[i]);
      if (tmp<dmin)
      {
	 iopt=i;
	 dmin=tmp;
      }
   }
   lsp[9]=delta[iopt];
   vcode[9]=iopt;
}

// ------------------------------------------------------------------------
void RESIDU(PC4808DATA p,short no)
{
   short i0;

   switch (no)
   {
   case 0:
	   i0=0;
	   break;
   case 1: short_to_short(p->A2,p->A1,11);
	   i0=SOUDECAL1;
	   break;
   case 2: short_to_short(p->A3,p->A1,11);
	   i0=SOUDECAL1+SOUDECAL;
	   break;
   }
   f_inverse(p->MINV,p->A1,p->SIG+i0,p->E,p->SOULONG,NETAGES);
}

// ------------------------------------------------------------------------
void PERIODE(PC4808DATA p,short no)
{
   short i,P1,P2;
   short *y0,*y1,*y2;
   short MAX,MAX2,j,bit_garde;

   y0=p->SIGPI; y2=y0+75; y1=p->E_PE;

   fenetre(p->A1,A0,p->Aw,11);

   init_zero(p->zz,12);
   p->H[0]=4096;
   init_zero(p->H+1,(short)(p->SOULONG-1));
   synthesis(p->zz,p->Aw,p->H,p->H,35,NETAGES,0);


   if (no)
   {
      P1=p->PITCH-3;
      if (P1<LIM_P1) P1=LIM_P1;
      P2=p->PITCH+4;
      if (P2>LIM_P2) P2=LIM_P2;
   }
   else
   {
      P1=p->PITCH-5;
      if (P1<LIM_P1) P1=LIM_P1;
      P2=p->PITCH+5;
      if (P2>LIM_P2) P2=LIM_P2;
   }

   // calc_p(&P1,&P2,PITCH,LIM_P1,LIM_P2,no);

   MAX = max_vect(p->E,p->SOULONG);

   if (P2<p->SOULONG) MAX2 = max_vect(p->EE+lngEE-P2,P2);
   else
   {
      if (P1<p->SOULONG) j=P1+16;
      else            j=p->SOULONG+16;
      MAX2 = max_vect(p->EE+lngEE-P2,j);
   }

   if (MAX2>MAX) MAX=MAX2;

   if (MAX & 0xe000)
   {
      i=MAX >> 13;
      if (!(i>>1)) bit_garde=1;
      else   bit_garde=2;
   }
   else bit_garde=0;

   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,p->E,y1,p->SOULONG,NETAGES,bit_garde);

   if (P1<p->SOULONG)
   {
      short_to_short(p->EE+lngEE-P1,y0,P1);
      for (i=P1;i<p->SOULONG;i++) y0[i]=0;
   }
   else short_to_short(p->EE+lngEE-P1,y0,p->SOULONG);

   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,y0,y0,p->SOULONG,NETAGES,bit_garde);
   short_to_short(y0,y2,p->SOULONG);

   if (P1<p->SOULONG) add_sf_vect(y2,y0,P1,p->SOULONG);

   if (2*P1<p->SOULONG) add_sf_vect(y2,y0,(short)(P1<<1),p->SOULONG);

   energy(y2,p->TLSP+2,p->SOULONG);
   correlation(y1,y2,p->TLSP,p->SOULONG);

   p->VMAX[1]=-6969;
   p->VMAX[4]=P1;

   upd_max(p->TLSP,p->VMAX,P1);

   for (i=P1+1;i<=P2;i++)
   {
      p->ptr1=y0; y0=y2; y2=p->ptr1;
      update_ltp(y0,y2,p->H+1,p->SOULONG,bit_garde,p->EE[lngEE-i]);
      if (i<p->SOULONG)
      {
	 short_to_short(y0,y2,p->SOULONG);
	 add_sf_vect(y2,y0,i,p->SOULONG);
	 if (2*i<p->SOULONG) add_sf_vect(y2,y0,(short)(i<<1),p->SOULONG);
	 energy(y2,p->TLSP+2,p->SOULONG);
	 correlation(y1,y2,p->TLSP,p->SOULONG);
      }
      else
      {
	 energy(y0,p->TLSP+2,p->SOULONG);
	 correlation(y1,y0,p->TLSP,p->SOULONG);
      }
      upd_max(p->TLSP,p->VMAX,i);
   }

#if 0
  //*(p->VMAX+2) = 28265821L;
  //*(p->VMAX+3) = 61L;
  //*(p->VMAX+2) = 881427L;
  //*(p->VMAX+3) = 1L;
  //*(p->VMAX+2) = 9851363L;
  //*(p->VMAX+3) = 6L;
  //*(p->VMAX+2) = 812881L;
  //*(p->VMAX+3) = 2L;
#if 1
  // Save jmp
   if ((*(p->VMAX+2) < 0L) || (*(p->VMAX+3) == 0L) || (((long)((long)(*(p->VMAX+2))/(long)(*(p->VMAX+3))) & 0xFFFC0000) == 0L))
     proc_gain(p->VMAX+2,p->ttt);
   else
     *(p->ttt) = 0L;  // *(p->VMAX+3) = 0L;
#else
   if ((*(p->VMAX+2) > 0L) && (*(p->VMAX+3)) && ((long)((long)(*(p->VMAX+2))/(long)(*(p->VMAX+3))) & 0x0FFC0000))
   {
     *(p->ttt) = 0L;  // *(p->VMAX+3) = 0L;
   }
   else
     proc_gain(p->VMAX+2,p->ttt);
#endif
#else
  //*(p->VMAX+2) = 28265821L;
  //*(p->VMAX+3) = 61L;
  //*(p->VMAX+2) = 881427L;
  //*(p->VMAX+3) = 1L;
  //*(p->VMAX+2) = 9851363L;
  //*(p->VMAX+3) = 6L;
  //*(p->VMAX+2) = 812881L;
  //*(p->VMAX+3) = 2L;
  proc_gain(p->VMAX+2,p->ttt);
#endif
   p->PITCH=(short)p->VMAX[4];
   /*
   if (ttt[0]>32767) GLTP=32767;
   else
      if (ttt[0]<-32767) GLTP=-32767;
      else GLTP=ttt[0];
   m = abs(GLTP);
   for (i=1;i<=10;i++) if ((m>=BQ[i-1])&&(m<BQ[i]))
   {
      if (GLTP>0) { GLTP=BV[i] ; k=i-1; }
      else        { GLTP=-BV[i]; k=i+10-1; }
      break;
   }
   if (GLTP>=BQ[10])  { GLTP=BV[10]; k=9; }
   if (GLTP<-BQ[6])   { GLTP=-BV[6]; k=15 ; }
   */
   p->code[11+p->depl]=calc_gltp(&p->GLTP,BQ,BV,p->ttt[0]);;
   p->code[10+p->depl]=p->PITCH;

   if (p->PITCH<p->SOULONG)
   {
      short_to_short(p->EE+lngEE-p->PITCH,p->E_PE,p->PITCH);
      short_to_short(p->E_PE,p->E_PE+p->PITCH,(short)(p->SOULONG-p->PITCH));
      mult_fact(p->E_PE,p->E_PE,p->GLTP,p->SOULONG);
   }
   else
   {
      mult_fact(p->EE+lngEE-p->PITCH,p->E_PE,p->GLTP,p->SOULONG);
   }
}

// ------------------------------------------------------------------------
void CHERCHE(PC4808DATA p)
{
   short i;
   short position,esp_opt;
   short k,j;
   short c[10],VOISE,npopt,phas_opt,cod,sign;
   short  Gopt;
   short *sr,*y0;
   short MAX,bit_garde;

   sr=p->SIGPI; y0=sr+75;
   for (i=0;i<p->SOULONG;i++) p->E[i] -= p->E_PE[i];
   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,p->E,sr,p->SOULONG,NETAGES,0);
   MAX = max_vect(sr,p->SOULONG);

   /* if (MAX & 0xfe00)
   {
      i=MAX >> 9;
      if (!(i>>1)) bit_garde=1;
      else if (!(i>>2)) bit_garde=2;
      else if (!(i>>3)) bit_garde=3;
      else if (!(i>>4)) bit_garde=4;
      else if (!(i>>5)) bit_garde=5;
      else   bit_garde=6;
   }
   else bit_garde=0;
   */
   bit_garde=calc_garde(MAX);

   inver_v_int(sr,y0,p->SOULONG);
   init_zero(p->zz,12);
   synthesis(p->zz,p->Aw,y0,y0,p->SOULONG,NETAGES,bit_garde);
   inver_v_int(y0,sr,p->SOULONG);

   p->VMAX[0]=-6969;
   Gopt=position=0;

   VOISE=1;
   if ( !p->UNVOIS )
   {
      esp_opt=p->PITCH;
      short_to_short(p->H,y0,p->SOULONG);
      if (p->PITCH<p->SOULONG) add_sf_vect(y0,p->H,p->PITCH,p->SOULONG);
      // cal_dic1(y0,sr,&esp_opt,&position,SOULONG,PITCH);
      cal_dic1(p,y0,sr,&esp_opt,&position,p->SOULONG,p->PITCH,p->SIGPI,p->SOULONG,p->TLSP,p->VMAX);
      /* if (PITCH>=SOULONG)
      {
	 if (PITCH/2<SOULONG) sign = PITCH/2;
	 else sign=PITCH/3;
	 short_to_short(H,y0,SOULONG);
	 add_sf_vect(y0,H,sign,SOULONG);
	 // cal_dic1(y0,sr,&esp_opt,&position,54,sign);
	 cal_dic1(y0,sr,&esp_opt,&position,54,sign,SIGPI,SOULONG,TLSP,VMAX);
      }
      // else  cal_dic1(H,sr,&esp_opt,&position,54,SOULONG+5);
      else  cal_dic1(H,sr,&esp_opt,&position,54,SOULONG+5,SIGPI,SOULONG,TLSP,VMAX);
      */
   }

   cal_dic2(p,8,7,0,sr,p->H,c,&VOISE,&esp_opt,&npopt,&phas_opt);
   cal_dic2(p,7,8,3,sr,p->H,c,&VOISE,&esp_opt,&npopt,&phas_opt);
   /*
   cal_dic2(8,7,0,sr,H,c,&VOISE,&esp_opt,&npopt,&phas_opt,SIGPI,SOULONG,TLSP,VMAX);
   cal_dic2(7,8,3,sr,H,c,&VOISE,&esp_opt,&npopt,&phas_opt,SIGPI,SOULONG,TLSP,VMAX);
   */
   proc_gain2(p->VMAX+1,p->VMAX,bit_garde);

   if (p->VMAX[0]>32767) Gopt=32767;
   else if (p->VMAX[0]<-32767) Gopt=-32767;
   else  Gopt=(short)p->VMAX[0];

   if (VOISE==0)
   {
      if (c[0]==-1)
      {
	 Gopt=-Gopt;
	 for (k=0;k<npopt;k++) c[k]=-c[k];
      }
      if (npopt==7) cod = 64;
      else  cod = 128;
      for (j=1;j<npopt;j++)
	 if (c[j]==1) cod += 1 << (npopt-j-1);
   }
   else
   {
      if (esp_opt == p->PITCH) cod=position;
      else  cod = position+SOUDECAL1;
   }
   p->code[12+p->depl]=cod;

   if (Gopt<0) { Gopt=-Gopt;  sign=1; }
   else  sign=0;

   for (i=1;i<=16;i++) if ((Gopt>=GQ[i-1])&&(Gopt<GQ[i]))
   {
      Gopt=GV[i];
      cod=i-1;
      break;
   }
   if (Gopt>=GQ[16]) { Gopt=GV[16]; cod=15; }

   if (sign) { Gopt = -Gopt; cod += 16; }

   p->code[13+p->depl]=cod;
   // Gopt=calc_gopt(c,code,GQ,GV,VOISE,npopt,PITCH,esp_opt,depl,position,SOUDECAL1,VMAX[0]);
   short_to_short(p->E_PE,p->E,p->SOULONG);

   if (VOISE==1)
   {
      i=0;
      do
      {
	 p->E[position+i] += Gopt;
	 i += esp_opt;
      }
      while ((position+i)<p->SOULONG);
   }
   else
      for (j=0;j<npopt;j++)
	 p->E[esp_opt*j+phas_opt] += c[j]*Gopt;

   short_to_short(p->EE+p->SOULONG,p->EE,(short)(lngEE-p->SOULONG));
   short_to_short(p->E,p->EE+lngEE-p->SOULONG,p->SOULONG);
}

// ------------------------------------------------------------------------
void FRAME(PC4808DATA p)
// Purpose : concatenate all parameters
// Input parameter  :
//          code[]  :  parameters code
//  Output parameter  :
//          output_stream[] :  multiplexed code
//
//  Comments: The LTP or Adaptive codebook is also called PITCH.
//
//  Bit allocation : Codebook or gain "i" is the codebook for suboutput_stream "i".
//  code[0] = LSP(0) : 3bits     code[10] = LTP codebook 1    : 7bits
//  code[1] = LSP(1) : 4bits     code[11] = LTP gain 1        : 4bits
//  code[2] = LSP(2) : 4bits     code[12] = Binary codebook 1 : 8bits
//  code[3] = LSP(3) : 3bits     code[13] = Binary gain 1     : 5bits
//  code[4] = LSP(4) : 4bits     code[14] = LTP codebook 2    : 4bits
//  code[5] = LSP(5) : 3bits     code[15] = LTP gain 2        : 4bits
//  code[6] = LSP(6) : 3bits     code[16] = Binary codebook 2 : 8bits
//  code[7] = LSP(7) : 2bits     code[17] = Binary gain 2     : 5bits
//  code[8] = LSP(8) : 3bits     code[18] = LTP codebook 3    : 4bits
//  code[9] = LSP(9) : 1bits     code[19] = LTP gain 3        : 4bits
//                               code[20] = Binary codebook 3 : 8bits
//                               code[21] = Binary gain 3     : 5bits
//
//  output_stream[0] = LSP[0] | LSP[1] | LSP[2] | (Binary gain 2)
//  output_stream[1] = LSP[3] | (Binary gain 3) | (Binary codebook 1)
//  output_stream[2] = LSP[4] | LSP[5] | LSP[6] | LSP[7] | LSP[8] | LSP[9]
//  output_stream[3] = (LTP codebook 1) | (LTP gain 1) | (Binary gain 1)
//  output_stream[4] = (LTP codebook 2) | (LTP gain 2) | (Binary codebook 2)
//  output_stream[5] = (LTP codebook 3) | (LTP gain 3) | (Binary codebook 3)
{
   p->code[18] = p->code[18]-p->code[14]+7;
   p->code[14] = p->code[14]-p->code[10]+7;
   p->code[10] -= LIM_P1;

   p->output_frame[0] = (p->code[0]<<13) | (p->code[1]<<9) | (p->code[2]<<5) | p->code[17];
   p->output_frame[1] = (p->code[3]<<13) | (p->code[21]<<8) | p->code[12];
   p->output_frame[2] = (p->code[4]<<12) | (p->code[5]<<9) | (p->code[6]<<6) | (p->code[7]<<4) | (p->code[8]<<1) | p->code[9];
   p->output_frame[3] = (p->code[10]<<9) | (p->code[11]<<5) | p->code[13];
   p->output_frame[4] = (p->code[14]<<12) | (p->code[15]<<8) | p->code[16];
   p->output_frame[5] = (p->code[18]<<12) | (p->code[19]<<8) | p->code[20];
   /*
   code[18] = code[18]-code[14]+3;
   code[14] = code[14]-code[10]+3;
   code[10] -= LIM_P1;

   output_frame[0] = (code[0]<<13) | (code[1]<<9) | code[12];
   output_frame[1] = (code[3]<<13) | (code[2]<<9) | code[16];
   output_frame[2] = (code[5]<<13) | (code[4]<<9) | code[20];

   output_frame[3] = (code[10]<<9) | (code[6]<<6) | (code[14]<<3) | code[18];
   output_frame[4] = (code[11]<<12) | (code[15]<<8) | (code[19]<<4) | (code[7]<<2) | code[8];
   output_frame[5] = (code[13]<<11) | (code[17]<<6) | (code[21]<<1) | code[9];
   */
}

// ------------------------------------------------------------------------
void CALPITCH(PC4808DATA p)
{
   short P1,P2,P3,j0,j1,L;
   /* long GG;

   GG=0;
   for (j=0;j<NECHFEN;j++) GG += (long)abs(SIG[SOUDECAL1-RECS2+j]);
   GG /= NECHFEN;
   if (GG<69) UNVOIS=1;
   else UNVOIS=0;*/

   L=NECHFEN+DECAL;

   p->ialf=0;
   deacc(p->M_PIT,p->SIGPI+10,29491,150,&p->ialf);
   deacc(p->SIG+SOUDECAL1-RECS2,p->SIGPI+160,29491,211,&p->ialf);

   j0=(L-80)/2;
   j1=j0+80;
   /*
   filt_iir(memfil_calp,coef_calp,SIGPI+10,SIG_CALP,361,3); // filtrage
   for (j=0;j<90;j++) SIG_CALP[j]=SIG_CALP[4*j];		//dcimation par 4
   */
   //// decime(SIGPI+10,SIG_CALP,coef_calp,Zai,Zbi,361);
   decimation(p->SIGPI+10,p->SIG_CALP,90);

   P1=max_autoc(p->SIG_CALP+40,28,5,14)*4;
   P2=max_autoc(p->SIG_CALP+20,56,13,28)*4;

   /* P1=max_autoc(SIGPI+160,130,LIM_P1,LIM_P1+35);
   P2=max_autoc(SIGPI+160-80,280,LIM_P1+30,LIM_P2);
   */
   P3=P2/2; p->ialf=P2/3;
   if ( (p->ialf>p->mem_pit[0]-17)&&(p->ialf<p->mem_pit[0]+17) && (abs(p->mem_pit[0]-p->ialf)<abs(p->mem_pit[0]-P3))) P3=p->ialf;

   left_correl(p,p->SIGPI,j0,j1,P1,2,p->veci1);
   left_correl(p,p->SIGPI,j0,j1,P2,2,p->veci2);
   left_correl(p,p->SIGPI,j0,j1,P3,2,p->veci3);

   right_correl(p,p->SIGPI,j0,j1,P1,2,p->veci1);
   right_correl(p,p->SIGPI,j0,j1,P2,2,p->veci2);
   right_correl(p,p->SIGPI,j0,j1,P3,2,p->veci3);

   P1=max_posit(p->veci1,p->TLSP,P1,5);
   P2=max_posit(p->veci2,p->TLSP+2,P2,5);
   P3=max_posit(p->veci3,p->TLSP+4,P3,5);

   if (p->TLSP[1]>p->TLSP[3]) p->PITCH =P1;
   else if ((p->TLSP[1]==p->TLSP[3]) && (p->TLSP[0]>p->TLSP[2])) p->PITCH=P1;
   else  { p->PITCH=P2;  p->TLSP[0]=p->TLSP[2]; p->TLSP[1]=p->TLSP[3];}

   if ( (P3>p->mem_pit[0]-17) && (P3<p->mem_pit[0]+17))
   {
      if (abs(p->mem_pit[1]-p->mem_pit[0])<15)  p->TLSP[0] = p->TLSP[0]>>1 + p->TLSP[0]>>2;
      if (abs(P3-P1)>6) p->TLSP[0] = p->TLSP[0]>>1 + p->TLSP[0]>>2;
      if (p->TLSP[0]<0x40000000L) { p->TLSP[0]<<=1; p->TLSP[1]--;}
      // if (TLSP[0]<0x40000000) { TLSP[0]<<=1; TLSP[1]--;}
      if (p->TLSP[1]<p->TLSP[5]) p->PITCH =P3;
	       else if ((p->TLSP[1]==p->TLSP[5]) && (p->TLSP[0]<p->TLSP[4])) p->PITCH=P3;
   }
   p->mem_pit[1]=p->mem_pit[0];
   p->mem_pit[0]=p->PITCH;
}
#endif

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// DLL entry points
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Coder(DWORD dwMaxBitRate)
{
   PVOID pCoderData;
   /*short i,flag=0;

   // Test if there are free handles
   for (i=0;i<MAXCODINGHANDLES;i++)
      if (CodingHandles[i]==0) {CodingHandles[i]=1; flag=1; break;}
   if (flag==0) return 0;
   pCoderData=&CoderData[i];*/

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (dwMaxBitRate != 4800) && 
#endif
	  (dwMaxBitRate != 8000) && (dwMaxBitRate != 12000) && (dwMaxBitRate != 16000))
      return (HANDLE)0;

   // pCoderData=(PVOID)GlobalAllocPtr(GMEM_MOVEABLE, dwMaxBitRate == 4800 ? sizeof(C4808DATA) : sizeof(C16008DATA));
#ifdef CELP4800
   pCoderData=(PVOID)GlobalAllocPtr(GHND, dwMaxBitRate == 4800 ? sizeof(C4808DATA) : sizeof(C16008DATA));
#else
   pCoderData=(PVOID)GlobalAllocPtr(GHND, sizeof(C16008DATA));
#endif
   if (pCoderData==NULL)
      return (HANDLE)0;

   InitializeCoderInstanceData(pCoderData, dwMaxBitRate);

   #ifdef __TEST
   codage=(FILE*)fopen("codage.dat","wb");
   test=(FILE*)fopen("codes_c2.dat","wt");
   #endif

   return((HANDLE)pCoderData);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Encode(
   HANDLE hAccess,
   LPBYTE lpSrcBuf,
   LPWORD lpSrcBufSize,
   LPBYTE lpDstBuf,
   LPWORD lpDstBufSize)
{
    short i,iNBSPF,iMOD_TH1,iMOD_TH2,iMOD_TH3,k,flag=0;
    short iNBSB_SP_MAX1,iNBSB_SP_MAX2,iNBSB_SP_MAX3,iNBSB_SP_MAX4;
    short  *input;
    short *in;
    unsigned short  *ptr2,*ptr4;
    unsigned char  *ptr1,*ptr3;
    long nbb_ave; // Average bit rate on the previous NBFAC frames of speech

    short codesizes[24];
    long codes[24];
    short numcodes,temp;
    short ivect8[160];

	PVOID pCoderData;

    if ((!hAccess) || (!lpSrcBuf) || (!lpDstBuf))
      return LH_EBADARG;

    // First check that the handle provided as argument is correct
    /*for (i=0;i<MAXCODINGHANDLES;i++)
       if ((CodingHandles[i]==1)&&(hAccess==(HANDLE)&CoderData[i])) {flag=1; break;}
    if (flag==0) return LH_BADHANDLE;*/

    pCoderData=(PVOID)hAccess;

  // Check the input bit rate param.
  if (
#ifdef CELP4800
	  (((PC4808DATA)pCoderData)->dwMaxBitRate != 4800) && 
#endif
	  (((PC16008DATA)pCoderData)->dwMaxBitRate != 8000) && 
	  (((PC16008DATA)pCoderData)->dwMaxBitRate != 12000) &&
	  (((PC16008DATA)pCoderData)->dwMaxBitRate != 16000))
    return (LH_ERRCODE)LH_EBADARG;

#ifdef CELP4800
  if ((((PC4808DATA)pCoderData)->dwMaxBitRate == 4800))
    {
     // then check the buffer sizes passed as argument.
     if ((*lpSrcBufSize<2*NECHDECAL)||(*lpDstBufSize<12))
        return (LH_ERRCODE)LH_EBADARG;

     *lpSrcBufSize=2*NECHDECAL;
     *lpDstBufSize=12;

     input = (short  *)lpSrcBuf;
     in=((PC4808DATA)pCoderData)->SIG+SOUDECAL1+RECS2;
     for (i=0;i<DECAL;i++) *in++=*input++;

     filt_in(((PC4808DATA)pCoderData)->mem2,((PC4808DATA)pCoderData)->SIG+SOUDECAL1+RECS2,((PC4808DATA)pCoderData)->SIG+SOUDECAL1+RECS2,DECAL);

     CALPITCH(((PC4808DATA)pCoderData));

     COEFF_A(((PC4808DATA)pCoderData));

     for (i=0;i<3;i++)
     {
        if (i==0) ((PC4808DATA)pCoderData)->SOULONG=SOUDECAL1;
        else ((PC4808DATA)pCoderData)->SOULONG=SOUDECAL;
        ((PC4808DATA)pCoderData)->depl=i*4;
        RESIDU(((PC4808DATA)pCoderData),i);
        PERIODE(((PC4808DATA)pCoderData),i);
        CHERCHE(((PC4808DATA)pCoderData));
        dsynthesis(((PC4808DATA)pCoderData)->DMSY,((PC4808DATA)pCoderData)->A1,((PC4808DATA)pCoderData)->E,((PC4808DATA)pCoderData)->E_PE,((PC4808DATA)pCoderData)->SOULONG,NETAGES);
        for (k=0;k<=11;k++) ((PC4808DATA)pCoderData)->MINV[12-k] = ((PC4808DATA)pCoderData)->E_PE[((PC4808DATA)pCoderData)->SOULONG-12+k];
        ((PC4808DATA)pCoderData)->MINV[0]=(short)(((PC4808DATA)pCoderData)->DMSY[0] >> 16);
     }
     FRAME(((PC4808DATA)pCoderData));
     short_to_short(((PC4808DATA)pCoderData)->SIG+SOUDECAL1-RECS2,((PC4808DATA)pCoderData)->M_PIT,160);
     short_to_short(((PC4808DATA)pCoderData)->SIG+NECHDECAL,((PC4808DATA)pCoderData)->SIG,SOUDECAL1+RECS2);

     ptr4 = (unsigned short  *)&((PC4808DATA)pCoderData)->output_frame;
     ptr2 = (unsigned short  *)lpDstBuf;

     for (i =0;i<6;i++) ptr2[i] = ptr4[i];
    }
  else
#endif
    {
    input = (short  *)lpSrcBuf;

    ((PC16008DATA)pCoderData)->nbbit_cf=0;

    // then check the buffer sizes passed as argument.
    switch (((PC16008DATA)pCoderData)->dwMaxBitRate)
      {
      case 8000:
        if ((*lpSrcBufSize<2*160)||(*lpDstBufSize<MAX_OUTPUT_BYTES_8000_12000))
          return (LH_ERRCODE)LH_EBADARG;
        *lpSrcBufSize=2*160;
        for (i=0;i<160;i++) ((PC16008DATA)pCoderData)->DATA_I[i]=(*input++)>>1;	// TEST >>2
#ifdef _X86_
        PassLow8(((PC16008DATA)pCoderData)->DATA_I,ivect8,((PC16008DATA)pCoderData)->memBP,160);
        iConvert8To64(ivect8,((PC16008DATA)pCoderData)->DATA_I,160,((PC16008DATA)pCoderData)->imem1);
#else
        SampleRate8000To6400(((PC16008DATA)pCoderData)->DATA_I,
                             ((PC16008DATA)pCoderData)->DATA_I,
                             160,
                             ((PC16008DATA)pCoderData)->imem1,
                             &((PC16008DATA)pCoderData)->uiDelayPosition,
                             &((PC16008DATA)pCoderData)->iInputStreamTime,
                             &((PC16008DATA)pCoderData)->iOutputStreamTime );
#endif

        break;
      case 12000:
        if ((*lpSrcBufSize<2*128)||(*lpDstBufSize<MAX_OUTPUT_BYTES_8000_12000))
          return (LH_ERRCODE)LH_EBADARG;
        *lpSrcBufSize=2*128;
        for (i=0;i<128;i++) ((PC16008DATA)pCoderData)->DATA_I[i]=(*input++)>>1;	// TEST >>2
        break;
      case 16000:
        if ((*lpSrcBufSize<2*128)||(*lpDstBufSize<MAX_OUTPUT_BYTES_16000))
          return (LH_ERRCODE)LH_EBADARG;
        *lpSrcBufSize=2*128;
        for (i=0;i<128;i++) ((PC16008DATA)pCoderData)->DATA_I[i]=(*input++)>>1;	// TEST >>2
        break;
      }

    code_res_I(((PC16008DATA)pCoderData),((PC16008DATA)pCoderData)->DATA_I,coef_I,((PC16008DATA)pCoderData)->QMF_MEM_ANAL_I,((PC16008DATA)pCoderData)->codes_max,
    		((PC16008DATA)pCoderData)->codes_sb,((PC16008DATA)pCoderData)->indic_sp);

     //*#ifdef __VARIABLE__
     for (i=NBFAC-1;i>0;i--)
       {
       ((PC16008DATA)pCoderData)->nbbit[i]=((PC16008DATA)pCoderData)->nbbit[i-1]; // on re-adapte les tranches precedentes
       }
     ((PC16008DATA)pCoderData)->nbbit[0]=((PC16008DATA)pCoderData)->nbbit_cf;     // valeur pour la tranche actuelle

     nbb_ave=0L;
     for (i=0;i<NBFAC;i++) nbb_ave+=(long)((PC16008DATA)pCoderData)->nbbit[i];
    if (((PC16008DATA)pCoderData)->dwMaxBitRate == 8000)
      {
      iNBSPF = NBSPF_4800_8000;
      iMOD_TH1 = MOD_TH1_8000;
      iMOD_TH2 = MOD_TH2_8000;
      iMOD_TH3 = MOD_TH3_8000;
      iNBSB_SP_MAX1 = NBSB_SP_MAX1_8000_12000;
      iNBSB_SP_MAX2 = NBSB_SP_MAX2_8000_12000;
      iNBSB_SP_MAX3 = NBSB_SP_MAX3_8000_12000;
      iNBSB_SP_MAX4 = NBSB_SP_MAX4_8000_12000;
      }
    else
      {
      iNBSPF = NBSPF_12000_16000;
      iMOD_TH1 = MOD_TH1_12000_16000;
      if (((PC16008DATA)pCoderData)->dwMaxBitRate == 12000)
        {
        iMOD_TH2 = MOD_TH2_12000;
        iMOD_TH3 = MOD_TH3_12000;
        iNBSB_SP_MAX1 = NBSB_SP_MAX1_8000_12000;
        iNBSB_SP_MAX2 = NBSB_SP_MAX2_8000_12000;
        iNBSB_SP_MAX3 = NBSB_SP_MAX3_8000_12000;
        iNBSB_SP_MAX4 = NBSB_SP_MAX4_8000_12000;
        }
      else
        {
        iMOD_TH2 = MOD_TH2_16000;
        iMOD_TH3 = MOD_TH3_16000;
        iNBSB_SP_MAX1 = NBSB_SP_MAX1_16000;
        iNBSB_SP_MAX2 = NBSB_SP_MAX2_16000;
        iNBSB_SP_MAX3 = NBSB_SP_MAX3_16000;
        iNBSB_SP_MAX4 = NBSB_SP_MAX4_16000;
        }
      }
    nbb_ave=(short)((nbb_ave*F_ECH)/(NBFAC*iNBSPF));
// On retablit les seuils en fonction de la moyenne calculee
     if (nbb_ave<=iMOD_TH1)
       {
       ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL1; // valeur par defaut si le debit n'augmente pas trop
       ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX1; // cad on ne traite pas les sb < 5% du max[i]
       ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX1; // nbre max de sb pouvant etre du signal
       }
     else
       {
       if (nbb_ave<=iMOD_TH2) // on a depasse le 1er seuils mais pas le 2eme
	 {
	 ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL2; // on rejette plus de tranches
	 ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX2; // cad on ne traite pas les sb < 7% du max[i]
	 ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX2; // nbre max de sb pouvant etre du signal
	 }
       else
	 {
	 if (nbb_ave<=iMOD_TH3) // on a depasse le 1er seuils mais pas le 2eme
	   {
	   ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL3; // on rejette un max
	   ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX3; // cad on ne traite pas les sb < 5% du max[i]
	   ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX3; // nbre max de sb pouvant etre du signal
	   }
	 else                 // on a depasse le troisieme seuil; il faut descendre!
	   {
	   ((PC16008DATA)pCoderData)->MAX_LEVEL   = MAX_LEVEL4; // meme seuil de rejet
	   ((PC16008DATA)pCoderData)->DIV_MAX     = DIV_MAX4; // cad on ne traite pas les sb <10% du max[i]
	   ((PC16008DATA)pCoderData)->NBSB_SP_MAX = iNBSB_SP_MAX4; // nbre max de sb pouvant etre du signal
	   }
	 }
       }/**/
    ((PC16008DATA)pCoderData)->stream[0]=0;
    for (i=0;i<8;i++)
       ((PC16008DATA)pCoderData)->stream[0]|=(((PC16008DATA)pCoderData)->indic_sp[i]&0x01)<<i;

    numcodes=0;
    //temp=bytes[((PC16008DATA)pCoderData)->nbsb_sp];
#if 0
    temp=(short)((float)((PC16008DATA)pCoderData)->nbbit_cf/8.0+0.99);
#else
    // We want to go away of libcmt, msvcrt... and
    // floating point is not really essential here...
    if (((PC16008DATA)pCoderData)->nbbit_cf)
      temp=(short)((((PC16008DATA)pCoderData)->nbbit_cf-1)/8+1);
    else
      temp=0;
#endif

    for (i=0;i<24;i++) codesizes[i]=0;
    for (i=0;i<((PC16008DATA)pCoderData)->nbsb_sp;i++)
    {
       codes[i]=(long)((PC16008DATA)pCoderData)->codes_max[i];
       codes[((PC16008DATA)pCoderData)->nbsb_sp+2*i]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i];
       codes[((PC16008DATA)pCoderData)->nbsb_sp+2*i+1]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i+1];
       codesizes[i]=5;
       codesizes[((PC16008DATA)pCoderData)->nbsb_sp+2*i]=((PC16008DATA)pCoderData)->bits[i]/2;
       codesizes[((PC16008DATA)pCoderData)->nbsb_sp+2*i+1]=((PC16008DATA)pCoderData)->bits[i]/2;
       numcodes+=3;
    }

  if (((PC16008DATA)pCoderData)->dwMaxBitRate == 16000)
    {
    for (i=((PC16008DATA)pCoderData)->nbsb_sp;i<8;i++)
    {
       codes[2*((PC16008DATA)pCoderData)->nbsb_sp+i]=(long)((PC16008DATA)pCoderData)->codes_max[i];
       codes[8+2*i]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i];
       codes[8+2*i+1]=(long)((PC16008DATA)pCoderData)->codes_sb[2*i+1];
       codesizes[2*((PC16008DATA)pCoderData)->nbsb_sp+i]=5;
       codesizes[8+2*i]=SILENCE_CODING_BIT_16000/2;
       codesizes[8+2*i+1]=SILENCE_CODING_BIT_16000/2;
       numcodes+=3;
    }
    Multiplexing(((PC16008DATA)pCoderData)->stream+1,codes,codesizes,numcodes,(short)(temp-1));
    }
  else
    if (((PC16008DATA)pCoderData)->nbsb_sp)
       Multiplexing(((PC16008DATA)pCoderData)->stream+1,codes,codesizes,numcodes,(short)(temp-1));

    *lpDstBufSize=temp;


    ptr3 = (unsigned char  *)&((PC16008DATA)pCoderData)->stream;
    ptr1 = (unsigned char  *)lpDstBuf;
    for (i =0;i<*lpDstBufSize;i++) ptr1[i] = ptr3[i];
    }
    return (LH_SUCCESS);
}

// ------------------------------------------------------------------------
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Coder(HANDLE hAccess)
{
   PVOID pCoderData;
   /*short i,flag=0;

   // Check if right handle
   for (i=0;i<MAXCODINGHANDLES;i++)
      if ((CodingHandles[i]==1)&&(hAccess==(HANDLE)&CoderData[i])) {flag=1; break;}
   if (flag==0) return LH_BADHANDLE;
   // Free handle
   CodingHandles[i]=0;*/

  if (!hAccess)
    return LH_EBADARG;

   pCoderData=(PVOID)hAccess;

   GlobalFreePtr(pCoderData);

   #ifdef __TEST
   fclose(codage);
   fclose(test);
   #endif

   return LH_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\variable.h ===
//Use CELP on _x86_ but not Alpha
#ifndef _ALPHA_
#define CELP4800
#endif

#define   F_ECH    8000  // Sampling frequency
#define   NBSPF_4800_8000     160  // !!! Nbr of sample per recorded speech frame
#define   NBSPF_12000_16000     128  // !!! Nbr of sample per recorded speech frame
#define   NBFAC      25  // Nbr of speech frame for computing the average br

#define DEGRADE_8000 1

#ifdef DEGRADE_8000
#define   MOD_TH1_8000  50  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_8000  100  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_8000  150  // the overhead is about 60%, hence max=12000
//#define   MOD_TH1_8000  500  // 1st, 2nd and 3rd thresholds for a 14.4 modem
//#define   MOD_TH2_8000  1000  // (assumed with compression, hence max 19.2)
//#define   MOD_TH3_8000  1500  // the overhead is about 60%, hence max=12000
#else
#define   MOD_TH1_8000  5000  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_8000  6500  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_8000  8000  // the overhead is about 60%, hence max=12000
#endif

#ifdef DEGRADE_12000_16000
#define   MOD_TH1_12000_16000  3000  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_12000  4000  // (assumed with compression, hence max 19.2)
#define   MOD_TH2_16000  5000  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_12000  5000  // the overhead is about 60%, hence max=12000
#define   MOD_TH3_16000  7000  // the overhead is about 60%, hence max=12000
#else
#define   MOD_TH1_12000_16000  8000  // 1st, 2nd and 3rd thresholds for a 14.4 modem
#define   MOD_TH2_12000  10000  // (assumed with compression, hence max 19.2)
#define   MOD_TH2_16000  12000  // (assumed with compression, hence max 19.2)
#define   MOD_TH3_12000  12000  // the overhead is about 60%, hence max=12000
#define   MOD_TH3_16000  16000  // the overhead is about 60%, hence max=12000
#endif

#define   MAX_LEVEL1	40	// input /2 instead of /4 20
#define	  DIV_MAX1	60
#define   NBSB_SP_MAX1_8000_12000	6
#define   NBSB_SP_MAX1_16000	5

#define   MAX_LEVEL2	80	// input /2 instead of /4 40
#define	  DIV_MAX2	40
#define   NBSB_SP_MAX2_8000_12000  5
#define   NBSB_SP_MAX2_16000  4

#define   MAX_LEVEL3	120	// input /2 instead of /4 60
#define	  DIV_MAX3	30
#define   NBSB_SP_MAX3_8000_12000	5
#define   NBSB_SP_MAX3_16000	4

#define   MAX_LEVEL4    150	// input /2 instead of /4 75
#define	  DIV_MAX4	20
#ifdef DEGRADE_8000
#define   NBSB_SP_MAX4_8000_12000	3
#else
#define   NBSB_SP_MAX4_8000_12000	4
#endif
#define   NBSB_SP_MAX4_16000	3

//#define	  QUANT_LEVELS_8000_12000  9,9,9,9,5,5,5,5,5,5,5,5
//#define	  QUANT_LEVELS_16000  9,9,7,7,5,5,5,5,5,5

#define   SILENCE_QUANT_LEVEL_16000	3

//#define   CODING_BITS_8000_12000   52,52,38,38,38,38
//#define   CODING_BITS_16000   52,46,38,38,38

#define   SILENCE_CODING_BIT_16000	26

#define   MAX_OUTPUT_BYTES_4800 12
#define   MAX_OUTPUT_BYTES_8000_12000 37
#define   MAX_OUTPUT_BYTES_16000 43
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32 - the only initialization
//      required is to set ghinst, which is done in the DRV_LOAD message
//      of DriverProc (in codec.c).
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "msacmdrv.h"


BOOL APIENTRY DllEntryPoint ( HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpReserved )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\fv_x8.h ===
/*
 *   Project:		LHCODING.DLL  (L&H Speech Coding SDK)  
 *   Workfile:		fv_m8.h + fv_h8.h + private     
 *   Author:		Alfred Wiesen
 *   Created:		13 June 1995    
 *   Last update:	14 February 1996
 *   DLL Version:	1   
 *   Revision:		
 *   Comment:   
 *
 *	(C) Copyright 1993-94 Lernout & Hauspie Speech Products N.V. (TM)
 *	All rights reserved. Company confidential.
 */

# ifndef __FV_X8_H  /* avoid multiple include */ 

# define __FV_X8_H


#pragma pack(push,8)

/*
 *  Type definition for the L&H functions returned values
 */

typedef long LH_ERRCODE;

typedef struct CodecInfo_tag {
   WORD wPCMBufferSize;
   WORD wCodedBufferSize;
   WORD wBitsPerSamplePCM;
   DWORD dwSampleRate;
   WORD wFormatSubTag;
   char wFormatSubTagName[40];
   DWORD dwDLLVersion;
} CODECINFO, near *PCODECINFO, far *LPCODECINFO;

/*
 *  Possible values for the LH_ERRCODE type
 */

# define LH_SUCCESS (0)    /* everything is OK */
# define LH_EFAILURE (-1)  /* something went wrong */
# define LH_EBADARG (-2)   /* one of the given argument is incorrect */
# define LH_BADHANDLE (-3) /* bad handle passed to function */

/*
 *  Some real types are defined here
 */

# ifdef __cplusplus
	# define LH_PREFIX extern "C"
# else
	# define LH_PREFIX
# endif

#if 0
# define LH_SUFFIX FAR PASCAL
#else
# define LH_SUFFIX
#endif

/*
 *  The function prototypes for 4800 bps, 8000 bps, 12000 bps, 16000 bps, 8000 Hz, Fixed point
 */

LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Coder(DWORD dwMaxBitRate);

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Encode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Coder(HANDLE hAccess);

LH_PREFIX HANDLE LH_SUFFIX MSLHSB_Open_Decoder(DWORD dwMaxBitRate);

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Decode(
  HANDLE hAccess,
  LPBYTE inputBufferPtr,
  LPWORD inputBufferLength,
  LPBYTE outputBufferPtr,
  LPWORD outputBufferLength
  );

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_Close_Decoder(HANDLE hAccess);

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_GetCodecInfo(LPCODECINFO lpCodecInfo, DWORD dwMaxBitRate);

#pragma pack(pop)

# endif  /* avoid multiple include */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\lhacm.h ===
//==========================================================================
//
//  lhacm.h
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================


#ifndef _LHACM_H_
#define _LHACM_H_

#define _T(s)       __TEXT (s)
#define TRACE_FUN

#ifdef DEBUG
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#ifdef _DEBUG
    #include <assert.h>
    #ifdef TRACE_FUN
    #define FUNCTION_ENTRY(s)   \
                static TCHAR _szFunName_[] = _T ("LH::") _T (s); \
                MyDbgPrintf (_T ("%s\r\n"), (LPTSTR) _szFunName_);
    #else
    #define FUNCTION_ENTRY(s)   \
                static TCHAR _szFunName_[] = _T (s);
    #endif
    #define SZFN        ((LPTSTR) _szFunName_)
    #define DBGMSG(z,s) ((z) ? (MyDbgPrintf s) : 0);
#else
    #define FUNCTION_ENTRY(s)
    #define SZFN
    #define DBGMSG(z,s)
#endif

#define SIZEOFACMSTR(x)  (sizeof(x)/sizeof(WCHAR))

void FAR CDECL MyDbgPrintf ( LPTSTR lpszFormat, ... );

//==========================================================================;
//
//  Version info
//
//==========================================================================;

// !!! Need to assign a WAVE_FORMAT tag to the codec

#include "temp.h"  // from common\h\temp.h

//Use CELP on _x86_ but not Alpha
#ifndef _ALPHA_
#define CELP4800
#endif

#define VERSION_ACM_DRIVER              MAKE_ACM_VERSION(1, 0, 1)
#define VERSION_MSACM                   MAKE_ACM_VERSION(2, 1, 0)

// !!! Need to assign valid MID and PID

#define MM_ACM_MID_LH                   MM_MICROSOFT
#define MM_ACM_PID_LH                   90

// !!! need to assign IDs

#define MM_LERNOUTHAUSPIE_ACM_CELP      0x70
#define MM_LERNOUTHAUSPIE_ACM_SB8       0x71
#define MM_LERNOUTHAUSPIE_ACM_SB12      0x72
#define MM_LERNOUTHAUSPIE_ACM_SB16      0x73


//==========================================================================;
//
//  Helper routines
//
//==========================================================================;

#define SIZEOF_ARRAY(ar)                (sizeof(ar)/sizeof((ar)[0]))

#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))


// !!! need defines for all four l&h codecs

#define LH_BITSPERSAMPLE                16
#define LH_SAMPLESPERSEC                8000

#define LH_PCM_SAMPLESPERSEC            LH_SAMPLESPERSEC
#define LH_PCM_BITSPERSAMPLE            LH_BITSPERSAMPLE

#ifdef CELP4800
#define LH_CELP_SAMPLESPERSEC           LH_SAMPLESPERSEC
#define LH_CELP_BITSPERSAMPLE           LH_BITSPERSAMPLE
#define LH_CELP_BLOCKALIGNMENT          2
#endif

#define LH_SB8_SAMPLESPERSEC            LH_SAMPLESPERSEC
#define LH_SB8_BITSPERSAMPLE            LH_BITSPERSAMPLE
#define LH_SB8_BLOCKALIGNMENT           2

#define LH_SB12_SAMPLESPERSEC           LH_SAMPLESPERSEC
#define LH_SB12_BITSPERSAMPLE           LH_BITSPERSAMPLE
#define LH_SB12_BLOCKALIGNMENT          2

#define LH_SB16_SAMPLESPERSEC           LH_SAMPLESPERSEC
#define LH_SB16_BITSPERSAMPLE           LH_BITSPERSAMPLE
#define LH_SB16_BLOCKALIGNMENT          2

// !!! l&h probably does not need an extended header...tbd
// lonchanc: we don't need an extended header
//           because we will use separate wave format tags for
//           different coding techniques.

//==========================================================================;
//
//  Supported configurations
//
//==========================================================================;

#define LH_MAX_CHANNELS       1


//==========================================================================;
//
//  Global storage and defs
//
//==========================================================================;

typedef HANDLE (LH_SUFFIX * PFN_OPEN) ( void );
typedef LH_ERRCODE (LH_SUFFIX * PFN_CONVERT) ( HANDLE, LPBYTE, LPWORD, LPBYTE, LPWORD );
typedef LH_ERRCODE (LH_SUFFIX * PFN_CLOSE) ( HANDLE );


typedef struct tagCODECDATA
{
    DWORD       wFormatTag;
    CODECINFO   CodecInfo;
}
    CODECDATA, *PCODECDATA;


typedef struct tagSTREAMINSTANCEDATA
{
    BOOL            fInit;      // TRUE if this stream has been initialized
    BOOL            fCompress;  // TRUE if we're compressing
    HANDLE          hAccess;
    PCODECDATA      pCodecData; // shortcut to instance data's celp, sb8, sb12, or sb16.
    PFN_CONVERT     pfnConvert; // pointer to the encoder/decoder function
    PFN_CLOSE       pfnClose;   // pointer to the close function
    DWORD           dwMaxBitRate;     // bit rate of the codec
    WORD            cbData;     // valid data
    BYTE            Data[2];    // max size is wCodedBufferSize
}
    STREAMINSTANCEDATA, FAR *PSTREAMINSTANCEDATA;


typedef struct tagINSTANCEDATA
{
    WORD        cbStruct;
    BOOL        fInit;
    HINSTANCE   hInst;
    CODECDATA   CELP;
    CODECDATA   SB8;
    CODECDATA   SB12;
    CODECDATA   SB16;
    WORD        wPacketData;// packet by packet audio data (decoding only)
}
    INSTANCEDATA, *PINSTANCEDATA;



//==========================================================================;
//
//  Function prototypes
//
//==========================================================================;

BOOL  pcmIsValidFormat( LPWAVEFORMATEX pwfx );
BOOL  lhacmIsValidFormat( LPWAVEFORMATEX pwfx, PINSTANCEDATA pid );
BOOL CALLBACK DlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL acmdDriverOpen( HDRVR hdrvr, LPACMDRVOPENDESC paod );
LRESULT FAR PASCAL acmdDriverClose( PINSTANCEDATA  pid );
LRESULT FAR PASCAL acmdDriverConfigure( PINSTANCEDATA pid, HWND hwnd, LPDRVCONFIGINFO pdci );
LRESULT FAR PASCAL acmdDriverDetails( PINSTANCEDATA pid, LPACMDRIVERDETAILS padd );
LRESULT FAR PASCAL acmdDriverAbout( PINSTANCEDATA pid, HWND hwnd );
LRESULT FAR PASCAL acmdFormatSuggest( PINSTANCEDATA pid, LPACMDRVFORMATSUGGEST padfs );
LRESULT FAR PASCAL acmdFormatTagDetails( PINSTANCEDATA pid, LPACMFORMATTAGDETAILS padft, DWORD fdwDetails );
LRESULT FAR PASCAL acmdFormatDetails( PINSTANCEDATA pid, LPACMFORMATDETAILS padf, DWORD fdwDetails );
LRESULT FAR PASCAL acmdStreamOpen( PINSTANCEDATA pid, LPACMDRVSTREAMINSTANCE padsi );
LRESULT FAR PASCAL acmdStreamClose( PINSTANCEDATA pid, LPACMDRVSTREAMINSTANCE padsi );
LRESULT FAR PASCAL acmdStreamSize( LPACMDRVSTREAMINSTANCE padsi, LPACMDRVSTREAMSIZE padss );
LRESULT FAR PASCAL acmdStreamConvert( PINSTANCEDATA pid, LPACMDRVSTREAMINSTANCE padsi, LPACMDRVSTREAMHEADER padsh );
LRESULT CALLBACK DriverProc(DWORD_PTR dwId, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2 );


#endif // _LHACM_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\lhacm.c ===
//==========================================================================
//
//  lhacm.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "mmddk.h"
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include "msacmdrv.h"

#include "fv_x8.h"
#include "lhacm.h"

#define NEW_ANSWER 1

#include "resource.h"

enum
{
#ifdef CELP4800
    IDX_LH_CELP,
#endif
    IDX_LH_SB8,
    IDX_LH_SB12,
    IDX_LH_SB16,
    IDX_PCM,
    NumOfTagIndices
};

const UINT gauFormatTagIndexToTag[NumOfTagIndices] =
{
#ifdef CELP4800
    WAVE_FORMAT_LH_CELP,
#endif
    WAVE_FORMAT_LH_SB8,
    WAVE_FORMAT_LH_SB12,
    WAVE_FORMAT_LH_SB16,
    WAVE_FORMAT_PCM
};

const UINT gauTagNameIds[NumOfTagIndices] =
{
#ifdef CELP4800
    IDS_CODEC_NAME_CELP,
#endif
		IDS_CODEC_NAME_SB8,
    IDS_CODEC_NAME_SB12,
    IDS_CODEC_NAME_SB16,
    0
};

#define ACM_DRIVER_MAX_FORMAT_TAGS      SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS      0

//  arrays of sample rates supported.

//  L&H codecs don't do sample rate conversion.

UINT gauPCMFormatIndexToSampleRate[] =
{
    LH_PCM_SAMPLESPERSEC
};

#ifdef CELP4800
UINT gauLHCELPFormatIndexToSampleRate[] =
{
    LH_CELP_SAMPLESPERSEC
};
#endif

UINT gauLHSB8FormatIndexToSampleRate[] =
{
    LH_SB8_SAMPLESPERSEC
};

UINT gauLHSB12FormatIndexToSampleRate[] =
{
    LH_SB12_SAMPLESPERSEC
};

UINT gauLHSB16FormatIndexToSampleRate[] =
{
    LH_SB16_SAMPLESPERSEC
};

#define ACM_DRIVER_MAX_PCM_SAMPLE_RATES     SIZEOF_ARRAY(gauPCMFormatIndexToSampleRate)
#ifdef CELP4800
#define ACM_DRIVER_MAX_LH_CELP_SAMPLE_RATES SIZEOF_ARRAY(gauLHCELPFormatIndexToSampleRate)
#endif
#define ACM_DRIVER_MAX_LH_SB8_SAMPLE_RATES  SIZEOF_ARRAY(gauLHSB8FormatIndexToSampleRate)
#define ACM_DRIVER_MAX_LH_SB12_SAMPLE_RATES SIZEOF_ARRAY(gauLHSB12FormatIndexToSampleRate)
#define ACM_DRIVER_MAX_LH_SB16_SAMPLE_RATES SIZEOF_ARRAY(gauLHSB16FormatIndexToSampleRate)

#define ACM_DRIVER_MAX_CHANNELS             1

//  array of bits per sample supported.

//  the current version of the LH codecs require 16 bit

UINT gauPCMFormatIndexToBitsPerSample[] =
{
    LH_PCM_BITSPERSAMPLE
};

#ifdef CELP4800
UINT gauLHCELPFormatIndexToBitsPerSample[] =
{
    LH_CELP_BITSPERSAMPLE
};
#endif

UINT gauLHSB8FormatIndexToBitsPerSample[] =
{
    LH_SB8_BITSPERSAMPLE
};

UINT gauLHSB12FormatIndexToBitsPerSample[] =
{
    LH_SB12_BITSPERSAMPLE
};

UINT gauLHSB16FormatIndexToBitsPerSample[] =
{
    LH_SB16_BITSPERSAMPLE
};


#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM     SIZEOF_ARRAY(gauPCMFormatIndexToBitsPerSample)
#ifdef CELP4800
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_CELP SIZEOF_ARRAY(gauLHCELPFormatIndexToBitsPerSample)
#endif
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB8  SIZEOF_ARRAY(gauLHSB8FormatIndexToBitsPerSample)
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB12 SIZEOF_ARRAY(gauLHSB12FormatIndexToBitsPerSample)
#define ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB16 SIZEOF_ARRAY(gauLHSB16FormatIndexToBitsPerSample)

//  number of formats we enumerate per format tag is number of sample rates
//  times number of channels times number of types (bits per sample).

#define ACM_DRIVER_MAX_FORMATS_PCM  \
                (ACM_DRIVER_MAX_PCM_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#ifdef CELP4800
#define ACM_DRIVER_MAX_FORMATS_LH_CELP  \
                (ACM_DRIVER_MAX_LH_CELP_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_CELP)
#endif

#define ACM_DRIVER_MAX_FORMATS_LH_SB8  \
                (ACM_DRIVER_MAX_LH_SB8_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB8)

#define ACM_DRIVER_MAX_FORMATS_LH_SB12  \
                (ACM_DRIVER_MAX_LH_SB12_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB12)

#define ACM_DRIVER_MAX_FORMATS_LH_SB16  \
                (ACM_DRIVER_MAX_LH_SB16_SAMPLE_RATES *  \
                 ACM_DRIVER_MAX_CHANNELS *          \
                 ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB16)


//////////////////////////////////////////////////////////
//
// lonchanc: special shorthand for L&H codecs
//

static DWORD _GetAvgBytesPerSec ( PCODECINFO pCodecInfo )
{
    return ((pCodecInfo->dwSampleRate * (DWORD) pCodecInfo->wCodedBufferSize)
            /
            ((DWORD) pCodecInfo->wPCMBufferSize / (DWORD) (pCodecInfo->wBitsPerSamplePCM >> 3)));
}

static PCODECINFO _GetCodecInfoFromFormatIdx ( PINSTANCEDATA pid, int idx )
{
    PCODECINFO pCodecInfo = NULL;

    switch (gauFormatTagIndexToTag[idx])
    {
#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP: pCodecInfo = &(pid->CELP.CodecInfo); break;
#endif
    case WAVE_FORMAT_LH_SB8:  pCodecInfo = &(pid->SB8.CodecInfo);  break;
    case WAVE_FORMAT_LH_SB12: pCodecInfo = &(pid->SB12.CodecInfo); break;
    case WAVE_FORMAT_LH_SB16: pCodecInfo = &(pid->SB16.CodecInfo); break;
    default: break;
    }

    return pCodecInfo;
}

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.
//
//      The 32-bit ACM always expects Unicode strings.  Therefore,
//      when UNICODE is defined, this function is compiled to
//      LoadStringW to load a Unicode string.  When UNICODE is
//      not defined, this function loads an ANSI string, converts
//      it to Unicode, and returns the Unicode string to the
//      codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else
int LoadStringCodec ( HINSTANCE hInst, UINT uID, LPWSTR	lpwstr, int cch )
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR) LocalAlloc (LPTR, cch);
    if (NULL == lpstr)
    {
        return 0;
    }

    iReturn = LoadStringA (hInst, uID, lpstr, cch);
    if (0 == iReturn)
    {
        if (0 != cch)
        {
            lpwstr[0] = '\0';
        }
    }
    else
    {
        MultiByteToWideChar (GetACP(), 0, lpstr, cch, lpwstr, cch);
    }

    LocalFree ((HLOCAL) lpstr);

    return iReturn;
}
#endif  // UNICODE


//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL  pcmIsValidFormat( LPWAVEFORMATEX pwfx )
{
    BOOL fReturn = FALSE;

    FUNCTION_ENTRY ("pcmIsValidFormat")

    if (NULL == pwfx)
    {
        DBGMSG (1, (_T ("%s: pwfx is null\r\n"), SZFN));
        goto MyExit;
    }

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        DBGMSG (1, (_T ("%s: bad wFormatTag=%d\r\n"), SZFN, (UINT) pwfx->wFormatTag));
        goto MyExit;
    }

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
    {
        DBGMSG (1, (_T ("%s: bad nChannels=%d\r\n"), SZFN, (UINT) pwfx->nChannels));
        goto MyExit;
    }

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if (pwfx->wBitsPerSample != LH_PCM_BITSPERSAMPLE)
    {
        DBGMSG (1, (_T ("%s: bad wBitsPerSample=%d\r\n"), SZFN, (UINT) pwfx->wBitsPerSample));
        goto MyExit;
    }

// lonchanc: BUG BUG do we really care about the alignment???
    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT (pwfx) != pwfx->nBlockAlign)
    {
        DBGMSG (1, (_T ("%s: bad nBlockAlign=%d\r\n"), SZFN, (UINT) pwfx->nBlockAlign));
        goto MyExit;
    }

// lonchanc: BUG BUG this only check the integrity of the wave format struct
// but does not ensure that this is a good PCM for us.

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC (pwfx) != pwfx->nAvgBytesPerSec)
    {
        DBGMSG (1, (_T ("%s: bad nAvgBytesPerSec=%d\r\n"), SZFN, (UINT) pwfx->nAvgBytesPerSec));
        goto MyExit;
    }

    fReturn = TRUE;

MyExit:

    DBGMSG (1, (_T ("%s: fReturn=%d\r\n"), SZFN, (UINT) fReturn));

    return fReturn;

} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL lhacmIsValidFormat
//
//  Description:
//		This function ensures that the header is a valid LH header
//
//--------------------------------------------------------------------------;

BOOL lhacmIsValidFormat ( LPWAVEFORMATEX pwfx, PINSTANCEDATA pid )
{
    BOOL fReturn = FALSE;
    PCODECINFO pCodecInfo;
    WORD cbSize;

    FUNCTION_ENTRY ("lhacmIsValidFormat()");

    if (NULL == pwfx)
    {
        DBGMSG (1, (_T ("%s: pwfx is null\r\n"), SZFN));
        goto MyExit;
    }

    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
    {
        DBGMSG (1, (_T ("%s: bad nChannels=%d\r\n"), SZFN, (UINT) pwfx->nChannels));
        goto MyExit;
    }

    switch (pwfx->wFormatTag)
    {
#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
        pCodecInfo = &(pid->CELP.CodecInfo);
        break;
#endif
    case WAVE_FORMAT_LH_SB8:
        pCodecInfo = &(pid->SB8.CodecInfo);
        break;
    case WAVE_FORMAT_LH_SB12:
        pCodecInfo = &(pid->SB12.CodecInfo);
        break;
    case WAVE_FORMAT_LH_SB16:
        pCodecInfo = &(pid->SB16.CodecInfo);
        break;
    default:
        DBGMSG (1, (_T ("%s: bad wFormatTag=%d\r\n"), SZFN, (UINT) pwfx->wFormatTag));
        goto MyExit;
    }
    cbSize = 0;

    if (pwfx->wBitsPerSample != pCodecInfo->wBitsPerSamplePCM)
    {
        DBGMSG (1, (_T ("%s: bad wBitsPerSample=%d\r\n"), SZFN, (UINT) pwfx->wBitsPerSample));
        goto MyExit;
    }

    if (pwfx->nBlockAlign != pCodecInfo->wCodedBufferSize)
    {
        DBGMSG (1, (_T ("%s: bad nBlockAlign=%d\r\n"), SZFN, (UINT) pwfx->nBlockAlign));
        goto MyExit;
    }

    if (pwfx->nSamplesPerSec != pCodecInfo->dwSampleRate)
    {
        DBGMSG (1, (_T ("%s: bad nSamplesPerSec=%d\r\n"), SZFN, (UINT) pwfx->nSamplesPerSec));
        goto MyExit;
    }

	if (pwfx->cbSize != cbSize)
	{
        DBGMSG (1, (_T ("%s: bad cbSize=%d\r\n"), SZFN, (UINT) pwfx->cbSize));
        goto MyExit;
    }

    fReturn = TRUE;

MyExit:

    DBGMSG (1, (_T ("%s: fReturn=%d\r\n"), SZFN, (UINT) fReturn));

    return fReturn;

} // lhacmIsValidFormat()


//==========================================================================;
//
//  The followings are message handlers...
//
//
//==========================================================================;

//==========================================================================;
//
//  on DRV_OPEN
//
//==========================================================================;


LRESULT FAR PASCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PINSTANCEDATA pdata = NULL;

    FUNCTION_ENTRY ("acmdDriverOpen")

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (paod->fccType != ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC)
        {
            return 0;
        }
    }

    // !!! add check for LH DLL version here

    // we're not using the instance data for much right
    // now. when we add a configuration dialog it will
    // be more useful

    pdata= LocalAlloc (LPTR, sizeof (INSTANCEDATA));
    if (pdata == NULL)
    {
        if (paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        return 0;
    }

    pdata->cbStruct = sizeof (INSTANCEDATA);
    pdata->hInst = GetDriverModuleHandle (hdrvr);

#ifdef CELP4800
    pdata->CELP.wFormatTag = WAVE_FORMAT_LH_CELP;
    MSLHSB_GetCodecInfo (&(pdata->CELP.CodecInfo), 4800);

    DBGMSG (1, (_T ("%s: CELP's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->CELP.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->CELP.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->CELP.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->CELP.CodecInfo.dwDLLVersion));
#endif

    pdata->SB8.wFormatTag = WAVE_FORMAT_LH_SB8;
    MSLHSB_GetCodecInfo (&(pdata->SB8.CodecInfo), 8000);

    DBGMSG (1, (_T ("%s: SB8's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->SB8.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->SB8.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->SB8.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->SB8.CodecInfo.dwDLLVersion));

    pdata->SB12.wFormatTag = WAVE_FORMAT_LH_SB12;
    MSLHSB_GetCodecInfo (&(pdata->SB12.CodecInfo), 12000);

    DBGMSG (1, (_T ("%s: SB12's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->SB12.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->SB12.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->SB12.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->SB12.CodecInfo.dwDLLVersion));

    pdata->SB16.wFormatTag = WAVE_FORMAT_LH_SB16;
    MSLHSB_GetCodecInfo (&(pdata->SB16.CodecInfo), 16000);

    DBGMSG (1, (_T ("%s: SB16's codec info\r\n"), SZFN));
    DBGMSG (1, (_T ("%s: wPCMBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wPCMBufferSize));
    DBGMSG (1, (_T ("%s: wCodedBufferSize=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wCodedBufferSize));
    DBGMSG (1, (_T ("%s: wBitsPerSamplePCM=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wBitsPerSamplePCM));
    DBGMSG (1, (_T ("%s: dwSampleRate=0x%lX\r\n"), SZFN, pdata->SB16.CodecInfo.dwSampleRate));
    DBGMSG (1, (_T ("%s: wFormatSubTag=0x%X\r\n"), SZFN, (UINT) pdata->SB16.CodecInfo.wFormatSubTag));
    DBGMSG (1, (_T ("%s: wFormatSubTagName=[%s]\r\n"), SZFN, pdata->SB16.CodecInfo.wFormatSubTagName));
    DBGMSG (1, (_T ("%s: dwDLLVersion=0x%lX\r\n"), SZFN, pdata->SB16.CodecInfo.dwDLLVersion));

    pdata->fInit = TRUE;

    // let's update some global data
    gauPCMFormatIndexToSampleRate[0]    = pdata->CELP.CodecInfo.dwSampleRate;
#ifdef CELP4800
    gauLHCELPFormatIndexToSampleRate[0] = pdata->CELP.CodecInfo.dwSampleRate;
#endif
    gauLHSB8FormatIndexToSampleRate[0]  = pdata->SB8.CodecInfo.dwSampleRate;
    gauLHSB12FormatIndexToSampleRate[0] = pdata->SB12.CodecInfo.dwSampleRate;
    gauLHSB16FormatIndexToSampleRate[0] = pdata->SB16.CodecInfo.dwSampleRate;

    gauPCMFormatIndexToBitsPerSample[0]    = pdata->CELP.CodecInfo.wBitsPerSamplePCM;
#ifdef CELP4800
    gauLHCELPFormatIndexToBitsPerSample[0] = pdata->CELP.CodecInfo.wBitsPerSamplePCM;
#endif
    gauLHSB8FormatIndexToBitsPerSample[0]  = pdata->SB8.CodecInfo.wBitsPerSamplePCM;
    gauLHSB12FormatIndexToBitsPerSample[0] = pdata->SB12.CodecInfo.wBitsPerSamplePCM;
    gauLHSB16FormatIndexToBitsPerSample[0] = pdata->SB16.CodecInfo.wBitsPerSamplePCM;

    // report success
    if (paod)
    {
        paod->dwError = MMSYSERR_NOERROR;
    }

    return (LRESULT) pdata;

} // acmdDriverOpen()


//==========================================================================;
//
//  on DRV_CLOSE
//
//==========================================================================;

LRESULT FAR PASCAL acmdDriverClose
(
    PINSTANCEDATA   pid
)
{
    FUNCTION_ENTRY ("acmdDriverClose")

    if (pid)
    {
        LocalFree ((HLOCAL) pid);
    }

    return 1;
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  on DRV_CONFIGURE
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdDriverConfigure
(
    PINSTANCEDATA           pid,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{

    //
    //  first check to see if we are only being queried for hardware
    //  configuration support. if hwnd == (HWND)-1 then we are being
    //  queried and should return zero for 'not supported' and non-zero
    //  for 'supported'.
    //
    if (hwnd == (HWND) -1)
    {
        //
        //  this codec does not support hardware configuration so return
        //  zero...
        //
        return 0;
    }

    //
    //  we are being asked to bring up our hardware configuration dialog.
    //  if this codec can bring up a dialog box, then after the dialog
    //  is dismissed we return non-zero. if we are not able to display a
    //  dialog, then return zero.
    //
    return 0;

} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  on ACMDM_DRIVER_DETAILS
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdDriverDetails
(
    PINSTANCEDATA           pid,
    LPACMDRIVERDETAILS      padd
)
{

    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    FUNCTION_ENTRY ("acmdDriverDetails")

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    ZeroMemory (&add, sizeof (add));
    cbStruct            = min (padd->cbStruct, sizeof (ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;

    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;

    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_ACM_MID_LH;
    add.wPid            = MM_ACM_PID_LH;

    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;

    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.

    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.

    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;

    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.

    if (FIELD_OFFSET (ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.

        add.hicon = NULL;

        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.


        LoadStringCodec (pid->hInst, IDS_CODEC_SHORTNAME,
                            add.szShortName, SIZEOFACMSTR (add.szShortName));
        LoadStringCodec (pid->hInst, IDS_CODEC_LONGNAME,
                            add.szLongName,  SIZEOFACMSTR (add.szLongName));

        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.

        if (FIELD_OFFSET (ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec (pid->hInst, IDS_CODEC_COPYRIGHT,
                                add.szCopyright, SIZEOFACMSTR (add.szCopyright));
            LoadStringCodec (pid->hInst, IDS_CODEC_LICENSING,
                                add.szLicensing, SIZEOFACMSTR (add.szLicensing));
            LoadStringCodec (pid->hInst, IDS_CODEC_FEATURES,
                                add.szFeatures,  SIZEOFACMSTR (add.szFeatures));
        }
    }

    //  now copy the correct number of bytes to the caller's buffer

    CopyMemory (padd, &add, (UINT) add.cbStruct);

    //  success!

    return MMSYSERR_NOERROR;

} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  on ACMDM_DRIVER_ABOUT
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdDriverAbout
(
    PINSTANCEDATA           pid,
    HWND                    hwnd
)
{
    FUNCTION_ENTRY ("acmdDriverAbout")

    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //

    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?

    return MMSYSERR_NOTSUPPORTED;

} // acmdDriverAbout()


//--------------------------------------------------------------------------;
//
//  on ACMDM_FORMAT_SUGGEST
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdFormatSuggest
(
    PINSTANCEDATA           pid,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;

    DWORD   nSamplesPerSec;
    WORD    wBitsPerSample;

    FUNCTION_ENTRY ("acmdFormatSuggest")

    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.

    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return MMSYSERR_NOTSUPPORTED;

    //  get the source and destination formats in more convenient variables

    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;

    switch (pwfxSrc->wFormatTag)
    {
    case WAVE_FORMAT_PCM:
        DBGMSG (1, (_T ("%s: src wFormatTag=WAVE_FORMAT_PCM\r\n"), SZFN));
        //  strictly verify that the source format is acceptable for
        //  this driver
        //
        if (! pcmIsValidFormat (pwfxSrc))
        {
            DBGMSG (1, (_T ("%s: src format not valid\r\n"), SZFN));
            return ACMERR_NOTPOSSIBLE;
        }

        //  if the destination format tag is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver can encode to one of four L&H codecs

        if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
        {
            switch (pwfxDst->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
#endif
            case WAVE_FORMAT_LH_SB8:
            case WAVE_FORMAT_LH_SB12:
            case WAVE_FORMAT_LH_SB16:
                break;
            default:
                DBGMSG (1, (_T ("%s: not supported dest wFormatTag=%d\r\n"),
                SZFN, (UINT) pwfxDst->wFormatTag));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
#ifdef CELP4800
            pwfxDst->wFormatTag = WAVE_FORMAT_LH_CELP;
#else
			pwfxDst->wFormatTag = WAVE_FORMAT_LH_SB12;
#endif
        }

        //  if the destination channel count is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver is not able to change the number of channels

        if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
        {
            if ((pwfxSrc->nChannels != pwfxDst->nChannels) ||
                ((pwfxDst->nChannels < 1) &&
                 (pwfxDst->nChannels > ACM_DRIVER_MAX_CHANNELS)))
            {
                DBGMSG (1, (_T ("%s: ERROR src'nChannels=%ld and dest'nChannels=%ld are different\r\n"),
                SZFN, (DWORD) pwfxSrc->nChannels, (DWORD) pwfxDst->nChannels));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nChannels = pwfxSrc->nChannels;
        }

        switch (pwfxDst->wFormatTag)
        {
#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
            nSamplesPerSec = pid->CELP.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->CELP.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->CELP.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
#endif
        case WAVE_FORMAT_LH_SB8:
            nSamplesPerSec = pid->SB8.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->SB8.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->SB8.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
        case WAVE_FORMAT_LH_SB12:
            nSamplesPerSec = pid->SB12.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->SB12.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->SB12.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
        case WAVE_FORMAT_LH_SB16:
            nSamplesPerSec = pid->SB16.CodecInfo.dwSampleRate;
            wBitsPerSample = pid->CELP.CodecInfo.wBitsPerSamplePCM;
            pwfxDst->nBlockAlign     = pid->SB16.CodecInfo.wCodedBufferSize;
            pwfxDst->nAvgBytesPerSec = _GetAvgBytesPerSec (&(pid->SB16.CodecInfo));
            pwfxDst->cbSize		     = 0;
            break;
        default:
            DBGMSG (1, (_T ("%s: not supported dest wFormatTag=%d\r\n"),
            SZFN, (UINT) pwfxDst->wFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }

        //  if the destination samples per second is restricted, verify
        //  that it is within our capabilities...

        if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
        {
            if (pwfxDst->nSamplesPerSec != nSamplesPerSec)
            {
                DBGMSG (1, (_T ("%s: ERROR dest'nSamplesPerSec=%ld must be 8000\r\n"),
                SZFN, (DWORD) pwfxDst->nSamplesPerSec));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nSamplesPerSec = nSamplesPerSec;
        }

        //  if the destination bits per sample is restricted, verify
        //  that it is within our capabilities...

        if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
        {
            if (pwfxDst->wBitsPerSample != wBitsPerSample)
            {
                DBGMSG (1, (_T ("%s: dest wBitsPerSample is not valid\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->wBitsPerSample = wBitsPerSample;
        }

        DBGMSG (1, (_T ("%s: returns no error\r\n"), SZFN));
        return MMSYSERR_NOERROR;


#ifdef CELP4800
	case WAVE_FORMAT_LH_CELP:
#endif
    case WAVE_FORMAT_LH_SB8:
    case WAVE_FORMAT_LH_SB12:
    case WAVE_FORMAT_LH_SB16:
        DBGMSG (1, (_T ("%s: src wFormatTag=0x%X\r\n"), SZFN, (UINT) pwfxSrc->wFormatTag));

        //  strictly verify that the source format is acceptable for
        //  this driver
        //
        if (! lhacmIsValidFormat (pwfxSrc, pid))
        {
            DBGMSG (1, (_T ("%s: src format not valid\r\n"), SZFN));
            return ACMERR_NOTPOSSIBLE;
        }

        //  if the destination format tag is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver is only able to decode to PCM

        if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
        {
            if (pwfxDst->wFormatTag != WAVE_FORMAT_PCM)
            {
                DBGMSG (1, (_T ("%s: not supported dest wFormatTag=%d\r\n"),
                SZFN, (UINT) pwfxDst->wFormatTag));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
        }

        //  if the destination channel count is restricted, verify that
        //  it is within our capabilities...
        //
        //  this driver is not able to change the number of channels

        if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
        {
            if ((pwfxSrc->nChannels != pwfxDst->nChannels) ||
                ((pwfxDst->nChannels < 1) &&
                 (pwfxDst->nChannels > ACM_DRIVER_MAX_CHANNELS)))
            {
                DBGMSG (1, (_T ("%s: ERROR src'nChannels=%ld and dest'nChannels=%ld are different\r\n"),
                SZFN, (DWORD) pwfxSrc->nChannels, (DWORD) pwfxDst->nChannels));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nChannels = pwfxSrc->nChannels;
        }

        //  if the destination samples per second is restricted, verify
        //  that it is within our capabilities...
        //
        //  this driver is not able to change the sample rate

        if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
        {
            if (pwfxDst->nSamplesPerSec != pwfxSrc->nSamplesPerSec)
            {
                DBGMSG (1, (_T ("%s: ERROR invalid dest'nSamplesPerSec=%ld\r\n"),
                SZFN, (DWORD) pwfxDst->nSamplesPerSec));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
        }

        //  if the destination bits per sample is restricted, verify
        //  that it is within our capabilities...

        if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
        {
            if (pwfxDst->wBitsPerSample != LH_PCM_BITSPERSAMPLE)
            {
                DBGMSG (1, (_T ("%s: dest wBitsPerSample is not 16\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
            pwfxDst->wBitsPerSample = pwfxSrc->wBitsPerSample;
        }

        //  at this point, we have filled in all fields except the
        //  following for our 'suggested' destination format:
        //
        //      nAvgBytesPerSec
        //      nBlockAlign
        //      cbSize

        pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT (pwfxDst);
        pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                   pwfxDst->nBlockAlign;

        // pwfxDst->cbSize       = not used;

        DBGMSG (1, (_T ("%s: returns no error\r\n"), SZFN));
        return MMSYSERR_NOERROR;
    }

    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.

    DBGMSG (1, (_T ("%s: bad wFormatTag=%d\r\n"), SZFN, (UINT) pwfxSrc->wFormatTag));

    return ACMERR_NOTPOSSIBLE;

} // acmdFormatSuggest()


//--------------------------------------------------------------------------;
//
//  on ACMDM_FORMATTAG_DETAILS
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdFormatTagDetails
(
    PINSTANCEDATA           pid,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT    uFormatTag;

    FUNCTION_ENTRY ("acmdFormatTagDetails")

    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
    case ACM_FORMATTAGDETAILSF_INDEX:
        DBGMSG (1, (_T ("%s: ACM_FORMATTAGDETAILSF_INDEX\r\n"), SZFN));

        //  if the index is too large, then they are asking for a
        //  non-existant format.  return error.

        if (padft->dwFormatTagIndex >= ACM_DRIVER_MAX_FORMAT_TAGS)
        {
            DBGMSG (1, (_T ("%s: ERROR too big dwFormatTagIndex=%ld\r\n"), SZFN, padft->dwFormatTagIndex));
            return ACMERR_NOTPOSSIBLE;
        }

        uFormatTag = gauFormatTagIndexToTag[padft->dwFormatTagIndex];
        break;


    case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
        DBGMSG (1, (_T ("%s: ACM_FORMATTAGDETAILSF_LARGESTSIZE\r\n"), SZFN));
        switch (padft->dwFormatTag)
        {
        case WAVE_FORMAT_UNKNOWN:
#ifdef CELP4800
            padft->dwFormatTag = WAVE_FORMAT_LH_CELP;
#else
            padft->dwFormatTag = WAVE_FORMAT_LH_SB12;
#endif

#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
#endif
        case WAVE_FORMAT_LH_SB8:
        case WAVE_FORMAT_LH_SB12:
        case WAVE_FORMAT_LH_SB16:
            uFormatTag = padft->dwFormatTag;
            DBGMSG (1, (_T ("%s: dwFormatTag=0x%x\r\n"), SZFN, uFormatTag));
            break;

        case WAVE_FORMAT_PCM:
            DBGMSG (1, (_T ("%s: dwFormatTag=WAVE_FORMAT_PCM\r\n"), SZFN));
            uFormatTag = WAVE_FORMAT_PCM;
            break;

        default:
            DBGMSG (1, (_T ("%s: dwFormatTag=%ld not valid\r\n"), SZFN, padft->dwFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }
        break;


    case ACM_FORMATTAGDETAILSF_FORMATTAG:
        DBGMSG (1, (_T ("%s: ACM_FORMATTAGDETAILSF_FORMATTAG\r\n"), SZFN));
        switch (padft->dwFormatTag)
        {
#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
#endif
        case WAVE_FORMAT_LH_SB8:
        case WAVE_FORMAT_LH_SB12:
        case WAVE_FORMAT_LH_SB16:
        case WAVE_FORMAT_PCM:
            uFormatTag = padft->dwFormatTag;
            DBGMSG (1, (_T ("%s: dwFormatTag=0x%x\r\n"), SZFN, uFormatTag));
            break;
        default:
            DBGMSG (1, (_T ("%s: dwFormatTag=%ld not valid\r\n"), SZFN, padft->dwFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }
        break;

    //  if this ACM driver does not understand a query type, then
    //  return 'not supported'

    default:
        DBGMSG (1, (_T ("%s: this detail option is not supported, fdwDetails=0x%lX\r\n"), SZFN, fdwDetails));
        return MMSYSERR_NOTSUPPORTED;
    }

    // ok, let's fill in the structure based on uFormatTag!

    switch (uFormatTag)
    {
    case WAVE_FORMAT_PCM:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_PCM\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_PCM;
        padft->dwFormatTag      = WAVE_FORMAT_PCM;
        padft->cbFormatSize     = sizeof (PCMWAVEFORMAT);
        padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
        padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;
        //
        //  the ACM is responsible for the PCM format tag name
        //
        padft->szFormatTag[0]   =  0;
        break;


#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_CELP\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_CELP;
#endif

        /* GOTOs - ugh! */
    Label_LH_common:

        padft->dwFormatTag      = uFormatTag;
        padft->cbFormatSize     = sizeof (WAVEFORMATEX);
        padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
#ifdef CELP4800
        padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_LH_CELP;
#else
        padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_LH_SB16;
#endif
        LoadStringCodec (pid->hInst, gauTagNameIds[padft->dwFormatTagIndex],
                            padft->szFormatTag, SIZEOFACMSTR (padft->szFormatTag));
        break;
    case WAVE_FORMAT_LH_SB8:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_SB8\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_SB8;
        goto Label_LH_common;

    case WAVE_FORMAT_LH_SB12:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_SB12\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_SB12;
        goto Label_LH_common;

    case WAVE_FORMAT_LH_SB16:
        DBGMSG (1, (_T ("%s: uFormatTag=WAVE_FORMAT_LH_SB16\r\n"), SZFN));
        padft->dwFormatTagIndex = IDX_LH_SB16;
        goto Label_LH_common;

    default:
        DBGMSG (1, (_T ("%s: uFormatTag=%d not valid\r\n"), SZFN, uFormatTag));
        return ACMERR_NOTPOSSIBLE;
    }

    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure

    padft->cbStruct = min (padft->cbStruct, sizeof (*padft));

    return MMSYSERR_NOERROR;

} // acmdFormatTagDetails()

//--------------------------------------------------------------------------;
//
//  on ACMDM_FORMAT_DETAILS
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdFormatDetails
(
    PINSTANCEDATA           pid,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX          pwfx;
    UINT                    uFormatIndex;
    UINT                    u;
    DWORD                   dwFormatTag;

    FUNCTION_ENTRY ("acmdFormatDetails")

    pwfx = padf->pwfx;

    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
    //  enumerate by index
    //
    //  verify that the format tag is something we know about and
    //  return the details on the 'standard format' supported by
    //  this driver at the specified index...

    case ACM_FORMATDETAILSF_INDEX:
        DBGMSG (1, (_T ("%s: ACM_FORMATDETAILSF_INDEX\r\n"), SZFN));
        //
        //  put some stuff in more accessible variables--note that we
        //  bring variable sizes down to a reasonable size for 16 bit
        //  code...
        //

        dwFormatTag = padf->dwFormatTag;
        uFormatIndex = padf->dwFormatIndex;

        switch (dwFormatTag)
        {
        case WAVE_FORMAT_PCM:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_PCM\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_PCM)
            {
                DBGMSG (1, (_T ("%s: ERROR too big dwFormatIndex=%ld\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            //
            //  now fill in the format structure
            //
            pwfx->wFormatTag      = WAVE_FORMAT_PCM;

            u = uFormatIndex % ACM_DRIVER_MAX_PCM_SAMPLE_RATES;
            pwfx->nSamplesPerSec  = gauPCMFormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
            pwfx->nChannels       = u + 1;

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_PCM;
            pwfx->wBitsPerSample  = gauPCMFormatIndexToBitsPerSample[u];

            pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
            pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

            //
            //  note that the cbSize field is NOT valid for PCM
            //  formats
            //
            //  pwfx->cbSize      = 0;
            break;

#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_CELP\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_CELP)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_CELP;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_CELP_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHCELPFormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_CELP;
            pwfx->wBitsPerSample    = gauLHCELPFormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->CELP.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->CELP.CodecInfo));
            pwfx->cbSize            = 0;
            break;
#endif

        case WAVE_FORMAT_LH_SB8:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_SB8\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_SB8)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_SB8;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_SB8_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHSB8FormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB8;
            pwfx->wBitsPerSample    = gauLHSB8FormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->SB8.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->SB8.CodecInfo));
            pwfx->cbSize            = 0;
            break;

        case WAVE_FORMAT_LH_SB12:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_SB12\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_SB12)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_SB12;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_SB12_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHSB12FormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB12;
            pwfx->wBitsPerSample    = gauLHSB12FormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->SB12.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->SB12.CodecInfo));
            pwfx->cbSize            = 0;
            break;

        case WAVE_FORMAT_LH_SB16:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH_SB16\r\n"), SZFN));
            if (uFormatIndex >= ACM_DRIVER_MAX_FORMATS_LH_SB16)
            {
                DBGMSG (1, (_T ("%s: too big dwFormatIndex=%ld\r\n"), SZFN, padf->dwFormatIndex));
                return ACMERR_NOTPOSSIBLE;
            }

            pwfx->wFormatTag        = WAVE_FORMAT_LH_SB16;

            u = uFormatIndex % ACM_DRIVER_MAX_LH_SB16_SAMPLE_RATES;
            pwfx->nSamplesPerSec    = gauLHSB16FormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_BITSPERSAMPLE_LH_SB16;
            pwfx->wBitsPerSample    = gauLHSB16FormatIndexToBitsPerSample[u];

            pwfx->nChannels         = ACM_DRIVER_MAX_CHANNELS;
            pwfx->nBlockAlign       = pid->SB16.CodecInfo.wCodedBufferSize;
            pwfx->nAvgBytesPerSec   = _GetAvgBytesPerSec (&(pid->SB16.CodecInfo));
            pwfx->cbSize            = 0;
            break;

        default:
            DBGMSG (1, (_T ("%s: unknown dwFormatTag=%ld\r\n"), SZFN, dwFormatTag));
            return ACMERR_NOTPOSSIBLE;
        }
        break;


    case ACM_FORMATDETAILSF_FORMAT:
        DBGMSG (1, (_T ("%s: ACM_FORMATDETAILSF_FORMAT\r\n"), SZFN));
        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        dwFormatTag = (DWORD) pwfx->wFormatTag;
        switch (dwFormatTag)
        {
        case WAVE_FORMAT_PCM:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_PCM\r\n"), SZFN));
            if (! pcmIsValidFormat (pwfx))
            {
                DBGMSG (1, (_T ("%s: format not valid\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
            break;

#ifdef CELP4800
        case WAVE_FORMAT_LH_CELP:
#endif
        case WAVE_FORMAT_LH_SB8:
        case WAVE_FORMAT_LH_SB12:
        case WAVE_FORMAT_LH_SB16:
            DBGMSG (1, (_T ("%s: WAVE_FORMAT_LH\r\n"), SZFN));
            if (! lhacmIsValidFormat (pwfx, pid))
            {
                DBGMSG (1, (_T ("%s: format not valid\r\n"), SZFN));
                return ACMERR_NOTPOSSIBLE;
            }
            break;

        default:
            DBGMSG (1, (_T ("%s: bad dwFormatTag=%ld\r\n"), SZFN, dwFormatTag));
            return (ACMERR_NOTPOSSIBLE);
        }
        break;


    default:
        //
        //  don't know how to do the query type passed--return 'not
        //  supported'.
        //
        DBGMSG (1, (_T ("%s: not support this detail option=%ld\r\n"), SZFN, fdwDetails));
        return MMSYSERR_NOTSUPPORTED;
    }

    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.

    padf->cbStruct    = min (padf->cbStruct, sizeof (*padf));
    if (padf->cbStruct == 0)
        padf->cbStruct = sizeof (*padf);
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';

#ifdef _DEBUG
    DBGMSG (1, (_T ("%s: %s, %ld Samp/Sec, %u Channels, %u-bit, Align=%u, %ld Bytes/Sec, cbSize=%u\n"),
        SZFN, (WAVE_FORMAT_PCM == pwfx->wFormatTag ? (LPCTSTR) _T ("PCM") : (LPCTSTR) _T ("LH")),
        pwfx->nSamplesPerSec, pwfx->nChannels,
        pwfx->wBitsPerSample, pwfx->nBlockAlign,
        pwfx->nAvgBytesPerSec, pwfx->cbSize));
#endif

    return MMSYSERR_NOERROR;

} // acmdFormatDetails()


//--------------------------------------------------------------------------;
//
//  on ACMDM_STREAM_OPEN
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      HLOCAL pid: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdStreamOpen
(
    PINSTANCEDATA           pid,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX pwfxSrc = padsi->pwfxSrc;
    LPWAVEFORMATEX pwfxDst = padsi->pwfxDst;
    PSTREAMINSTANCEDATA psi;
    BOOL fCompress;
    UINT uEncodedFormatTag;
    UINT cbMaxData;
    DWORD dwMaxBitRate;
    PFN_CONVERT pfnConvert = NULL;
    PFN_CLOSE pfnClose = NULL;
    HANDLE hAccess = NULL;
    PCODECDATA pCodecData = NULL;

    FUNCTION_ENTRY ("acmdStreamOpen")

    // Validate that the input and output formats are compatible
    DBGMSG (1, (_T ("%s: wFormatTag: Src=%d, Dst=%d\r\n"), SZFN, (UINT) pwfxSrc->wFormatTag, (UINT) pwfxDst->wFormatTag));

    switch (pwfxSrc->wFormatTag)
    {
    case WAVE_FORMAT_PCM:
        // Source is PCM (we'll be compressing): check it and
        // make sure destination type is LH
        if (! pcmIsValidFormat (pwfxSrc))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        if (! lhacmIsValidFormat (pwfxDst, pid))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        uEncodedFormatTag = pwfxDst->wFormatTag;
        fCompress = TRUE;
        break;

#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
#endif
    case WAVE_FORMAT_LH_SB8:
    case WAVE_FORMAT_LH_SB12:
    case WAVE_FORMAT_LH_SB16:
        // Source is LH (we'll be decompressing): check it and
        // make sure destination type is PCM
        if (! lhacmIsValidFormat (pwfxSrc, pid))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        if (! pcmIsValidFormat (pwfxDst))
        {
            return ACMERR_NOTPOSSIBLE;
        }
        uEncodedFormatTag = pwfxSrc->wFormatTag;
        fCompress = FALSE;
        break;

    default:
        return ACMERR_NOTPOSSIBLE;
    }

    //  For this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.

    if (pwfxSrc->nChannels != pwfxDst->nChannels)
    {
        DBGMSG (1, (_T ("%s: bad nChannels: Src=%d, Dst=%d\r\n"), SZFN, (UINT) pwfxSrc->nChannels, (UINT) pwfxDst->nChannels));
        return MMSYSERR_NOTSUPPORTED;
    }

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
    {
        DBGMSG (1, (_T ("%s: bad nSamplesPerSec: Src=%d, Dst=%d\r\n"), SZFN, (UINT) pwfxSrc->nSamplesPerSec, (UINT) pwfxDst->nSamplesPerSec));
        return MMSYSERR_NOTSUPPORTED;
    }

    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.

    if (ACM_STREAMOPENF_QUERY & padsi->fdwOpen)
    {
        DBGMSG (1, (_T ("%s: Query ok\r\n"), SZFN));
        return MMSYSERR_NOERROR;
    }

    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.

    cbMaxData = 0;
    dwMaxBitRate = 0;

    switch (uEncodedFormatTag)
    {
#ifdef CELP4800
    case WAVE_FORMAT_LH_CELP:
#endif
    case WAVE_FORMAT_LH_SB8:
    case WAVE_FORMAT_LH_SB12:
    case WAVE_FORMAT_LH_SB16:
#ifdef CELP4800
        if (uEncodedFormatTag == WAVE_FORMAT_LH_CELP)
          {
          dwMaxBitRate = 4800;
          pCodecData = &(pid->CELP);
          }
        else
#endif
			if (uEncodedFormatTag == WAVE_FORMAT_LH_SB8)
          {
          dwMaxBitRate = 8000;
          pCodecData = &(pid->SB8);
          }
        else if (uEncodedFormatTag == WAVE_FORMAT_LH_SB12)
          {
          dwMaxBitRate = 12000;
          pCodecData = &(pid->SB12);
          }
        else if (uEncodedFormatTag == WAVE_FORMAT_LH_SB16)
          {
          dwMaxBitRate = 16000;
          pCodecData = &(pid->SB16);
          }
        if (fCompress)
        {
            hAccess = MSLHSB_Open_Coder (dwMaxBitRate);
            pfnConvert = MSLHSB_Encode;
            pfnClose = MSLHSB_Close_Coder;
        }
        else
        {
            hAccess = MSLHSB_Open_Decoder (dwMaxBitRate);
            pfnConvert = MSLHSB_Decode;
            pfnClose = MSLHSB_Close_Decoder;
            cbMaxData = pCodecData->CodecInfo.wCodedBufferSize;
        }
        break;

    }

    if (hAccess == NULL)
    {
        if (pfnClose) (*pfnClose) (hAccess);
        DBGMSG (1, (_T ("%s: open failed, hAccess=0\r\n"), SZFN));
        return ACMERR_NOTPOSSIBLE;
    }

    psi = (PSTREAMINSTANCEDATA) LocalAlloc (LPTR, sizeof (STREAMINSTANCEDATA) + cbMaxData);
    if (psi == NULL)
    {
        DBGMSG (1, (_T ("%s: LocalAlloc failed\r\n"), SZFN));
        if (pfnClose) (*pfnClose) (hAccess);
        return MMSYSERR_NOMEM;
    }

    //  fill out our instance structure
    psi->pfnConvert = pfnConvert;
    psi->pfnClose = pfnClose;
    psi->hAccess = hAccess;
    psi->pCodecData = pCodecData;
    psi->fCompress = fCompress;
    psi->dwMaxBitRate = dwMaxBitRate;
    psi->fInit = TRUE;

    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0;
    padsi->dwDriver  = (DWORD_PTR) psi;

    return MMSYSERR_NOERROR;

} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  on ACMDM_STREAM_CLOSE
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL acmdStreamClose
(
    PINSTANCEDATA           pid,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCEDATA     psi;

    FUNCTION_ENTRY ("acmdStreamClose")
    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCEDATA) padsi->dwDriver;
    if (psi)
    {
        if (psi->fInit && psi->hAccess && psi->pfnClose)
        {
            (*(psi->pfnClose)) (psi->hAccess);
            LocalFree ((HLOCAL) psi);
        }
    }    // if (psi)

    return MMSYSERR_NOERROR;

} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT FAR PASCAL acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;


// #define GetBytesPerBlock(nSamplesPerSec, wBitsPerSample) (RT24_SAMPLESPERBLOCK8 * (wBitsPerSample) >> 3)

LRESULT FAR PASCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{

    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cBlocks;
    DWORD   cbSrcLength;
    DWORD   cbDstLength;
    WORD    wPCMBufferSize;
    WORD    wCodedBufferSize;

    PSTREAMINSTANCEDATA     psi;

	FUNCTION_ENTRY ("acmdStreamSize")

    psi = (PSTREAMINSTANCEDATA) padsi->dwDriver;
    if (psi == NULL) return ACMERR_NOTPOSSIBLE;

    wPCMBufferSize = psi->pCodecData->CodecInfo.wPCMBufferSize;
    wCodedBufferSize = psi->pCodecData->CodecInfo.wCodedBufferSize;

    cbSrcLength = padss->cbSrcLength;
    cbDstLength = padss->cbDstLength;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
    case ACM_STREAMSIZEF_SOURCE:

        if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM)
        {
            switch (pwfxDst->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src pcm -> dst lh celp
#endif
            case WAVE_FORMAT_LH_SB8:
                // src pcm -> dst lh sb8
            case WAVE_FORMAT_LH_SB12:
                // src pcm -> dst lh sb12
            case WAVE_FORMAT_LH_SB16:
                // src pcm -> dst lh sb16

                cBlocks = cbSrcLength / wPCMBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                if (cBlocks * wPCMBufferSize < cbSrcLength) cBlocks++;
                padss->cbDstLength = cBlocks * wCodedBufferSize;
                break;
             }
        }
        else
        {
            switch (pwfxSrc->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src lh celp -> dst pcm
                cBlocks = cbSrcLength / wCodedBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                if (cBlocks * wCodedBufferSize < cbSrcLength) cBlocks++;
                padss->cbDstLength = cBlocks * wPCMBufferSize;
                break;
#endif
            case WAVE_FORMAT_LH_SB8:
                // src lh sb8 -> dst pcm
            case WAVE_FORMAT_LH_SB12:
                // src lh sb12 -> dst pcm
            case WAVE_FORMAT_LH_SB16:
                // src lh sb16 -> dst pcm

                padss->cbDstLength = cbSrcLength * wPCMBufferSize;
                break;
              }
        }
        return MMSYSERR_NOERROR;


    case ACM_STREAMSIZEF_DESTINATION:

        if (pwfxDst->wFormatTag == WAVE_FORMAT_PCM)
        {
            switch (pwfxSrc->wFormatTag)
            {
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src lh celp <- dst pcm
#endif
            case WAVE_FORMAT_LH_SB8:
                // src lh sb8 <- dst pcm
            case WAVE_FORMAT_LH_SB12:
                // src lh sb12 <- dst pcm
            case WAVE_FORMAT_LH_SB16:
                // src lh sb16 <- dst pcm

                cBlocks = cbDstLength / wPCMBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                padss->cbSrcLength = cBlocks * wCodedBufferSize;
                break;
             }
        }
        else
        {
            switch (pwfxDst->wFormatTag)
            {
#ifdef NEW_ANSWER
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src pcm <- dst lh celp
#endif
            case WAVE_FORMAT_LH_SB8:
                // src pcm <- dst lh sb8
            case WAVE_FORMAT_LH_SB12:
                // src pcm <- dst lh sb12
            case WAVE_FORMAT_LH_SB16:
                // src pcm <- dst lh sb16
                cBlocks = cbDstLength / wCodedBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                padss->cbSrcLength = cBlocks * wPCMBufferSize;
                break;
#else
#ifdef CELP4800
            case WAVE_FORMAT_LH_CELP:
                // src pcm <- dst lh celp
                cBlocks = cbDstLength / wCodedBufferSize;
                if (cBlocks == 0) return ACMERR_NOTPOSSIBLE;
                padss->cbSrcLength = cBlocks * wPCMBufferSize;
                break;
#endif
            case WAVE_FORMAT_LH_SB8:
                // src pcm <- dst lh sb8
            case WAVE_FORMAT_LH_SB12:
                // src pcm <- dst lh sb12
            case WAVE_FORMAT_LH_SB16:
                // src pcm <- dst lh sb16

                padss->cbSrcLength = cbDstLength * wPCMBufferSize;
                break;
#endif
              }
        }
        return MMSYSERR_NOERROR;

    }    // switch()

    return MMSYSERR_NOTSUPPORTED;

} // acmdStreamSize()



//--------------------------------------------------------------------------;
//
//  LRESULT FAR PASCAL acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      HLOCAL pid: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

// We want to use as little stack as possible,
// So let's make all our local variables statics


LRESULT FAR PASCAL acmdStreamConvert
(
    PINSTANCEDATA           pid,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    LH_ERRCODE lherr = LH_SUCCESS;
    DWORD    dwInBufSize, dwOutBufSize;
    PBYTE   pbSrc, pbDst, pData;
    DWORD   dwPCMBufferSize, dwCodedBufferSize;

    PSTREAMINSTANCEDATA psi;

    FUNCTION_ENTRY ("acmdStreamConvert")

    // this is a must
    pbDst = padsh->pbDst;
    pbSrc = padsh->pbSrc;

    // zero is a *must*
    padsh->cbSrcLengthUsed = 0;
    padsh->cbDstLengthUsed = 0;

    psi = (PSTREAMINSTANCEDATA) padsi->dwDriver;
    if (psi == NULL) return ACMERR_NOTPOSSIBLE;

    dwPCMBufferSize = (DWORD) psi->pCodecData->CodecInfo.wPCMBufferSize;
    dwCodedBufferSize = (DWORD) psi->pCodecData->CodecInfo.wCodedBufferSize;

    dwInBufSize = (DWORD) padsh->cbSrcLength;
    dwOutBufSize = (DWORD) padsh->cbDstLength;
    DBGMSG (1, (_T ("%s: prior: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
    SZFN, dwInBufSize, dwOutBufSize));

    /////////////////////////////////////////////
    //
    //      ENCODING
    //

    if (psi->fCompress)
    {
        while (dwOutBufSize >= dwCodedBufferSize
                  &&
               dwInBufSize >= dwPCMBufferSize)
        {
            // ignore the data the codec cannot handle
            // if (dwInBufSize > dwPCMBufferSize) dwInBufSize = dwPCMBufferSize;
            dwInBufSize = dwPCMBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            // encode it
            lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                               pbSrc, (PWORD) &dwInBufSize,
                                            pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Encode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // return the info about the amount of data used and created
            padsh->cbSrcLengthUsed += dwInBufSize;
            padsh->cbDstLengthUsed += dwOutBufSize;

            // re-compute the buffer sizes
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);
            dwInBufSize = (DWORD) (padsh->cbSrcLength - padsh->cbSrcLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

        goto MyExit; // spit out debug message
    }


    /////////////////////////////////////////////
    //
    //      DECODING celp
    //

#ifdef CELP4800
    if (psi->pCodecData->wFormatTag == WAVE_FORMAT_LH_CELP)
    {
        while (dwOutBufSize >= dwPCMBufferSize
                  &&
               dwInBufSize >= dwCodedBufferSize)
        {
            // ignore the data that the codec cannot handle
            // if (dwInBufSize > dwCodedBufferSize) dwInBufSize = dwCodedBufferSize;
            dwInBufSize = dwCodedBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            // decode it
            lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                pbSrc, (PWORD) &dwInBufSize,
                                pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Decode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // return the info about the amount of data used and created
            padsh->cbSrcLengthUsed += dwInBufSize;
            padsh->cbDstLengthUsed += dwOutBufSize;

            // re-compute the buffer sizes
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);
            dwInBufSize = (DWORD) (padsh->cbSrcLength - padsh->cbSrcLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

        goto MyExit; // spit out debug message
    }
#endif

    /////////////////////////////////////////////
    //
    //      DECODING subbands
    //

    if (pid->wPacketData != LH_PACKET_DATA_FRAMED)
    {

        //
        // general application, such as sndrec32.exe and audcmp.exe
        //

        pData = &(psi->Data[0]); // use local constant

        while (dwOutBufSize >= dwPCMBufferSize
                  &&
               dwInBufSize + psi->cbData >= dwCodedBufferSize)
       {
            DBGMSG (1, (_T ("%s: cbData=0x%X\r\n"), SZFN, psi->cbData));
            // fill in the internal buffer as possible
            if (psi->cbData < dwCodedBufferSize)
            {
                // buffer the coded data
                dwInBufSize = dwCodedBufferSize - (DWORD) psi->cbData;
                CopyMemory (&(psi->Data[psi->cbData]), pbSrc, dwInBufSize);
                psi->cbData = (WORD) dwCodedBufferSize;
                padsh->cbSrcLengthUsed += dwInBufSize;
            }

            // reset input buffer size
            dwInBufSize = dwCodedBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            // decode it
            lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                pData, (PWORD) &dwInBufSize,
                                pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Decode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // update the amount of the remaining data
            psi->cbData -= (WORD) dwInBufSize;

            // move the remaining data to the beginning of the internal buffer
            // I should have used MoveMemory, but it is an MSVC runtime call.
            // Use CopyMemory instead, which should be ok because the overlapping
            // portion is copied before being overwritten.
            if (psi->cbData)
            {
                CopyMemory (pData, &(psi->Data[dwInBufSize]), psi->cbData);
            }

            // return the info about the amount of data used and created
            padsh->cbDstLengthUsed += dwOutBufSize;
            // note that cbSrcLengthUsed has been updated already!!!

            // re-compute the buffer sizes
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);
            dwInBufSize = (DWORD) (padsh->cbSrcLength - padsh->cbSrcLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

        // accomodate the final left-over bytes
        if (dwInBufSize + psi->cbData < dwCodedBufferSize)
        {
            CopyMemory (&(psi->Data[psi->cbData]), pbSrc, dwInBufSize);
            psi->cbData += (WORD) dwInBufSize;
            padsh->cbSrcLengthUsed += dwInBufSize;
        }

    }
    else
    {

        //
        // special case: datapump's subband packets
        //

        while (dwOutBufSize >= dwPCMBufferSize)
        {
            // hack the input size to be dwCodedBufferSize as required by L&H API
            dwInBufSize = dwCodedBufferSize;

            // L&H codecs can only accept word
            if (dwOutBufSize > 0x0FFF0UL) dwOutBufSize = 0x0FFF0UL;

            DBGMSG (1, (_T ("%s: calling: dwInBufSize=0x%lX, dwOutBufSize=0x%lX\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));

            // decode it
               lherr = (*(psi->pfnConvert)) (psi->hAccess,
                                    pbSrc, (PWORD) &dwInBufSize,
                                    pbDst, (PWORD) &dwOutBufSize);
            DBGMSG (1, (_T ("%s: post: dwInBufSize=0x%X, dwOutBufSize=0x%X\r\n"),
            SZFN, dwInBufSize, dwOutBufSize));
            if (lherr != LH_SUCCESS)
            {
                DBGMSG (1, (_T ("%s: LH*_**_Decode failed lherr=%ld\r\n"), SZFN, (long) lherr));
                return MMSYSERR_NOTSUPPORTED;
            }

            // return the info about the amount of data used and created
            padsh->cbSrcLengthUsed += dwInBufSize;
            padsh->cbDstLengthUsed += dwOutBufSize;

            // re-compute the buffer size
            dwOutBufSize = (DWORD) (padsh->cbDstLength - padsh->cbDstLengthUsed);

            // re-compute the buffer pointers
            pbSrc = padsh->pbSrc + padsh->cbSrcLengthUsed;
            pbDst = padsh->pbDst + padsh->cbDstLengthUsed;
        }

    }


MyExit:

    DBGMSG (1, (_T ("%s: exit: cbSrcLengthUsed=0x%lX, cbDstLengthUsed=0x%lX\r\n"),
    SZFN, (DWORD) padsh->cbSrcLengthUsed, (DWORD) padsh->cbDstLengthUsed));

    return MMSYSERR_NOERROR;
}


//--------------------------------------------------------------------------;
//
//  LRESULT FAR PASCAL DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

LRESULT CALLBACK DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{

    PINSTANCEDATA   pid;
    LRESULT dplr;


    FUNCTION_ENTRY ("DriverProc")

	pid = (PINSTANCEDATA)dwId;

    switch (uMsg)
    {
        case DRV_LOAD:
            DBGMSG (1, (_T ("%s: DRV_LOAD\r\n"), SZFN));
            return 1L;

        case DRV_FREE:
            DBGMSG (1, (_T ("%s: DRV_FREE\r\n"), SZFN));
            return 1L;          // not that it matters since ACM does not check this return value

        case DRV_OPEN:
            DBGMSG (1, (_T ("%s: DRV_OPEN\r\n"), SZFN));
            return acmdDriverOpen (hdrvr, (LPACMDRVOPENDESC)lParam2);

        case DRV_CLOSE:
            DBGMSG (1, (_T ("%s: DRV_CLOSE\r\n"), SZFN));
            dplr = acmdDriverClose (pid);
            return dplr;

        case DRV_INSTALL:
            DBGMSG (1, (_T ("%s: DRV_INSTALL\r\n"), SZFN));
            return ((LRESULT)DRVCNF_RESTART);

        case DRV_REMOVE:
            DBGMSG (1, (_T ("%s: DRV_REMOVE\r\n"), SZFN));
            return ((LRESULT)DRVCNF_RESTART);

        case DRV_ENABLE:
            DBGMSG (1, (_T ("%s: DRV_ENABLE\r\n"), SZFN));
            return 1L;

        case DRV_DISABLE:
            DBGMSG (1, (_T ("%s: DRV_DISABLE\r\n"), SZFN));
            return 1L;

        case DRV_QUERYCONFIGURE:            // Does this driver support configuration?
            DBGMSG (1, (_T ("%s: DRV_QUERYCONFIGURE\r\n"), SZFN));
            lParam1 = -1L;
            lParam2 = 0L;

        // fall through

        case DRV_CONFIGURE:
            DBGMSG (1, (_T ("%s: DRV_CONFIGURE\r\n"), SZFN));
            dplr = acmdDriverConfigure(pid, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return dplr;

        case ACMDM_DRIVER_DETAILS:
            DBGMSG (1, (_T ("%s: ACMDM_DRIVER_DETAILS\r\n"), SZFN));
            dplr = acmdDriverDetails(pid, (LPACMDRIVERDETAILS)lParam1);
            return dplr;

        case ACMDM_DRIVER_ABOUT:
            DBGMSG (1, (_T ("%s: ACMDM_DRIVER_ABOUT\r\n"), SZFN));
            dplr = acmdDriverAbout(pid, (HWND)lParam1);
            return dplr;

        case ACMDM_FORMAT_SUGGEST:
            DBGMSG (1, (_T ("%s: ACMDM_FORMAT_SUGGEST\r\n"), SZFN));
            dplr = acmdFormatSuggest(pid, (LPACMDRVFORMATSUGGEST)lParam1);
            return dplr;

        case ACMDM_FORMATTAG_DETAILS:
            DBGMSG (1, (_T ("%s: ACMDM_FORMATTAG_DETAILS\r\n"), SZFN));
            dplr = acmdFormatTagDetails(pid, (LPACMFORMATTAGDETAILS)lParam1, lParam2);
            return dplr;

        case ACMDM_FORMAT_DETAILS:
            DBGMSG (1, (_T ("%s: ACMDM_FORMAT_DETAILS\r\n"), SZFN));
            dplr = acmdFormatDetails(pid, (LPACMFORMATDETAILS)lParam1, lParam2);
            return dplr;

        case ACMDM_STREAM_OPEN:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_OPEN\r\n"), SZFN));
            dplr = acmdStreamOpen(pid, (LPACMDRVSTREAMINSTANCE)lParam1);
            return dplr;

        case ACMDM_STREAM_CLOSE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_CLOSE\r\n"), SZFN));
            return acmdStreamClose(pid, (LPACMDRVSTREAMINSTANCE)lParam1);

        case ACMDM_STREAM_SIZE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_SIZE\r\n"), SZFN));
            return acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);

        case ACMDM_STREAM_CONVERT:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_CONVERT\r\n"), SZFN));
            dplr = acmdStreamConvert(pid, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return dplr;

        case ACMDM_STREAM_PREPARE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_PREPARE\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case ACMDM_STREAM_UNPREPARE:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_UNPREPARE\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

#if defined (_DEBUG) && 0
        // Trap some extra known messages so our debug output can show them

        case ACMDM_STREAM_RESET:
            DBGMSG (1, (_T ("%s: ACMDM_STREAM_RESET\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case ACMDM_DRIVER_NOTIFY:
            DBGMSG (1, (_T ("%s: ACMDM_DRIVER_NOTIFY\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case DRV_EXITSESSION:
            DBGMSG (1, (_T ("%s: DRV_EXITSESSION\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case DRV_EXITAPPLICATION:
            DBGMSG (1, (_T ("%s: DRV_EXITAPPLICATION\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

        case DRV_POWER:
            DBGMSG (1, (_T ("%s: DRV_POWER\r\n"), SZFN));
            return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

#endif

    }

    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.


    if (uMsg == ACMDM_LH_DATA_PACKAGING)
    {
        if (pid)
        {
            pid->wPacketData = (WORD) lParam1;
        }
    }
    else
    {
        //DBGMSG (1, (_T ("%s: bad uMsg=%d\r\n"), uMsg));
        return MMSYSERR_NOTSUPPORTED;
    }

    return DefDriverProc (dwId, hdrvr, uMsg, lParam1, lParam2);

} // DriverProc()





#ifdef _DEBUG

// CurtSm hack ... don't spew all the time
UINT DebugLH = 0;


void FAR CDECL MyDbgPrintf ( LPTSTR lpszFormat, ... )
{
    static TCHAR buf[1024];
	va_list arglist;

    if (!DebugLH)
        return;

	va_start(arglist, lpszFormat);
    wvsprintf ((LPTSTR) buf, (LPCSTR)lpszFormat,
#if 0
                    (LPSTR) (((LPBYTE) &lpszFormat) + sizeof (lpszFormat)));
#else
					arglist);
#endif
    OutputDebugString ((LPTSTR) buf);
}


#endif    //...def _DEBUG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LHACM.RC
//
#define IDS_CODEC_SHORTNAME             1
#define IDS_CODEC_LONGNAME              2
#define IDS_CODEC_COPYRIGHT             3
#define IDS_CODEC_LICENSING             4
#define IDS_CODEC_FEATURES              5
#define IDS_CODEC_NAME_CELP             6
#define IDS_CODEC_NAME_SB8              7
#define IDS_CODEC_NAME_SB12             8
#define IDS_CODEC_NAME_SB16             9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         103
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\getsize.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include "fv_x8.h"	// for DLL entry points
#include "variable.h"

# define SAMPLING_FREQUENCY F_ECH
# define DLL_MAJOR 1
# define DLL_MINOR 0
# define PCM_BUFFER_SIZE_4800_8000 2*NBSPF_4800_8000
# define PCM_BUFFER_SIZE_12000_16000 2*NBSPF_12000_16000
# define CODED_BUFFER_SIZE_4800 MAX_OUTPUT_BYTES_4800
# define CODED_BUFFER_SIZE_8000_12000 MAX_OUTPUT_BYTES_8000_12000
# define CODED_BUFFER_SIZE_16000 MAX_OUTPUT_BYTES_16000
# define PCM_BITS_PER_SAMPLE 16

# define CODEC_SUB_TAG_4800       800
# define CODEC_SUB_TAG_8000       801
# define CODEC_SUB_TAG_12000      802
# define CODEC_SUB_TAG_16000      803
# define CODEC_SUB_TAG_NAME_4800  "L&H SBCELP Codec 4.8 kbps"
# define CODEC_SUB_TAG_NAME_8000  "L&H SBC var.bitrate, 8 kbps 8 kHz"	// !!! lenght<40
# define CODEC_SUB_TAG_NAME_12000 "L&H SBC var.bitrate, 12 kbps 8 kHz"	// !!! lenght<40
# define CODEC_SUB_TAG_NAME_16000 "L&H SBC var.bitrate, 16 kbps 8 kHz"	// !!! lenght<40

# define MakeVersion(a,b) ((DWORD)a<<16)|(DWORD)b

# define LONG_CODEC_SUB_TAG_NAME_4800   "L&H SBCELP Codec, 4.8 kbps 8 kHz"
# define LONG_CODEC_SUB_TAG_NAME_8000   "L&H SBC var.bitrate, 8 kbps 8 kHz"
# define LONG_CODEC_SUB_TAG_NAME_12000  "L&H SBC var.bitrate, 12 kbps 8 kHz"
# define LONG_CODEC_SUB_TAG_NAME_16000  "L&H SBC var.bitrate, 16 kbps 8 kHz"

# define IS_VAR_BIT_RATE_4800 	0
# define IS_VAR_BIT_RATE_8000_12000_16000 	1
# define MIN_CODED_BUFFER_SIZE_4800 	12
# define MIN_CODED_BUFFER_SIZE_8000_12000_16000 	1
# define MEAN_BIT_RATE_4800 		4800
# define MEAN_BIT_RATE_8000 		8000
# define MEAN_BIT_RATE_12000 		12000
# define MEAN_BIT_RATE_16000 		16000
# define IS_RT_CODING_4800 		FALSE
# define IS_RT_CODING_8000_12000_16000 		TRUE
# define IS_RT_DECODING 	TRUE
# define IS_FLOATING_POINT	FALSE
# define INPUT_PCM_ONLY 	0x0001
# define EXTRA_CODEC_INFO_SIZE 0

LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_GetCodecInfo(LPCODECINFO CodecInfo, DWORD dwMaxBitRate)
// Returns the input and output buffer sizes.
{

  if ((!CodecInfo) || ((dwMaxBitRate != 4800) && (dwMaxBitRate != 8000) && (dwMaxBitRate != 12000) && (dwMaxBitRate != 16000)))
    return LH_EBADARG;

  CodecInfo->wBitsPerSamplePCM=PCM_BITS_PER_SAMPLE;
  CodecInfo->dwSampleRate=SAMPLING_FREQUENCY;
  CodecInfo->dwDLLVersion=MakeVersion(DLL_MAJOR,DLL_MINOR);

  switch (dwMaxBitRate)
    {
    case 4800:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_4800_8000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_4800;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_4800;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_4800);
      break;
    case 8000:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_4800_8000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_8000;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_8000);
      break;
    case 12000:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_12000_16000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_12000;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_12000);
      break;
    case 16000:
      CodecInfo->wPCMBufferSize=PCM_BUFFER_SIZE_12000_16000;
      CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_16000;
      CodecInfo->wFormatSubTag=CODEC_SUB_TAG_16000;
      strcpy(CodecInfo->wFormatSubTagName,CODEC_SUB_TAG_NAME_16000);
      break;
    }

	return LH_SUCCESS;
}

// PhilF: We don't call this guy from the wrapper, so no need to implement it
#if 0
LH_PREFIX LH_ERRCODE LH_SUFFIX MSLHSB_GetCodecInfoEx(LPCODECINFOEX CodecInfo,DWORD cbSize, DWORD dwMaxBitRate)
{

  if ((!CodecInfo) || (cbSize!=(DWORD)sizeof(CODECINFOEX)) || ((dwMaxBitRate != 8000) && (dwMaxBitRate != 12000) && (dwMaxBitRate != 16000)))
    return LH_EBADARG;

  if (cbSize==(DWORD)sizeof(CODECINFOEX))
    {
    // Information on implemented codec
    switch (dwMaxBitRate)
      {
      case 8000:
        CodecInfo->wInputBufferSize=PCM_BUFFER_SIZE_8000;
        CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
        CodecInfo->wFormatSubTag=CODEC_SUB_TAG_8000;
        strcpy(CodecInfo->szFormatSubTagName,LONG_CODEC_SUB_TAG_NAME_8000);
        CodecInfo->nAvgBytesPerSec=MEAN_BIT_RATE_8000/8;
        break;
      case 12000:
        CodecInfo->wInputBufferSize=PCM_BUFFER_SIZE_12000_16000;
        CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_8000_12000;
        CodecInfo->wFormatSubTag=CODEC_SUB_TAG_12000;
        strcpy(CodecInfo->szFormatSubTagName,LONG_CODEC_SUB_TAG_NAME_12000);
        CodecInfo->nAvgBytesPerSec=MEAN_BIT_RATE_12000/8;
        break;
      case 16000:
        CodecInfo->wInputBufferSize=PCM_BUFFER_SIZE_12000_16000;
        CodecInfo->wCodedBufferSize=CODED_BUFFER_SIZE_16000;
        CodecInfo->wFormatSubTag=CODEC_SUB_TAG_16000;
        strcpy(CodecInfo->szFormatSubTagName,LONG_CODEC_SUB_TAG_NAME_16000);
        CodecInfo->nAvgBytesPerSec=MEAN_BIT_RATE_16000/8;
        break;
      }
    CodecInfo->bIsVariableBitRate=IS_VAR_BIT_RATE;
    CodecInfo->bIsRealTimeEncoding=IS_RT_CODING;
    CodecInfo->bIsRealTimeDecoding=IS_RT_DECODING;
    CodecInfo->bIsFloatingPoint=IS_FLOATING_POINT;
    // Information on supported input format
    CodecInfo->wInputDataFormat=INPUT_PCM_ONLY;
    CodecInfo->dwInputSampleRate=SAMPLING_FREQUENCY;
    CodecInfo->wInputBitsPerSample=PCM_BITS_PER_SAMPLE;
    // Information on buffer sizes
    CodecInfo->wMinimumCodedBufferSize=MIN_CODED_BUFFER_SIZE;
    CodecInfo->dwDLLVersion=MakeVersion(DLL_MAJOR,DLL_MINOR);
    CodecInfo->cbSize=EXTRA_CODEC_INFO_SIZE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\dcthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:55 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk 

	TITLE	$dcthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk_ThunkData32	;This symbol must be exported.
thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk - offset thk_ThunkData32
	dd	offset FT_Prolog_thk - offset thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk_ThunkConnect32@16
thk_ThunkConnect32@16:
	pop	edx
	push	offset thk_ThkData16
	push	offset thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk_ThkData16 label byte
	db	"thk_ThunkData16",0


		


pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public _OpenDriver@12
_OpenDriver@12:
	mov	cl,14
; _OpenDriver(16) = _OpenDriver(32) {}
;
; dword ptr [ebp+8]:  lpDriverName
; dword ptr [ebp+12]:  dwReserved
; dword ptr [ebp+16]:  lpvop
;
public II_OpenDriver@12
II_OpenDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	dword ptr [ebp+12]	;dwReserved: dword->dword
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _CloseDriver@12
_CloseDriver@12:
	mov	cl,13
; _CloseDriver(16) = _CloseDriver(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  lpReserved1
; dword ptr [ebp+16]:  lpReserved2
;
public II_CloseDriver@12
II_CloseDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;lpReserved1: dword->dword
	push	dword ptr [ebp+16]	;lpReserved2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	12





;
public _SendDriverMessage@16
_SendDriverMessage@16:
	mov	cl,12
; _SendDriverMessage(16) = _SendDriverMessage(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  msg
; dword ptr [ebp+16]:  param1
; dword ptr [ebp+20]:  param2
;
public II_SendDriverMessage@16
II_SendDriverMessage@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;msg: dword->dword
	push	dword ptr [ebp+16]	;param1: dword->dword
	push	dword ptr [ebp+20]	;param2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	16





;
public _GetVideoPalette@12
_GetVideoPalette@12:
	mov	cl,11
; _GetVideoPalette(16) = _GetVideoPalette(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpcp
; dword ptr [ebp+16]:  dwcbSize
;
public II_GetVideoPalette@12
II_GetVideoPalette@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;dwcbSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public _InitializeVideoStream@12
_InitializeVideoStream@12:
	mov	cl,9
; _InitializeVideoStream(16) = _InitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  dwMicroSecPerFrame
; dword ptr [ebp+16]:  dwEvent
;
public II_InitializeVideoStream@12
II_InitializeVideoStream@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	push	dword ptr [ebp+12]	;dwMicroSecPerFrame: dword->dword
	push	dword ptr [ebp+16]	;dwEvent: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	12





;
public _UninitializeVideoStream@4
_UninitializeVideoStream@4:
	mov	cl,8
	jmp	II_UninitializeVideoStream@4
public _InitializeExternalVideoStream@4
_InitializeExternalVideoStream@4:
	mov	cl,10
; _UninitializeVideoStream(16) = _UninitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_UninitializeVideoStream@4
II_UninitializeVideoStream@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _GetVideoFormatSize@4
_GetVideoFormatSize@4:
	mov	cl,7
; _GetVideoFormatSize(16) = _GetVideoFormatSize(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_GetVideoFormatSize@4
II_GetVideoFormatSize@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public _GetVideoFormat@8
_GetVideoFormat@8:
	mov	cl,6
; _GetVideoFormat(16) = _GetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpbmih
;
public II_GetVideoFormat@8
II_GetVideoFormat@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public _SetVideoFormat@12
_SetVideoFormat@12:
	mov	cl,5
; _SetVideoFormat(16) = _SetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideoExtIn
; dword ptr [ebp+12]:  hvideoIn
; dword ptr [ebp+16]:  lpbmih
;
public II_SetVideoFormat@12
II_SetVideoFormat@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideoExtIn: dword->word
	push	word ptr [ebp+12]	;hvideoIn: dword->word
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _AllocateLockableBuffer@4
_AllocateLockableBuffer@4:
	mov	cl,4
; _AllocateLockableBuffer(16) = _AllocateLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  dwSize
;
public II_AllocateLockableBuffer@4
II_AllocateLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _LockBuffer@4
_LockBuffer@4:
	mov	cl,3
; _LockBuffer(16) = _LockBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_LockBuffer@4
II_LockBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _FreeLockableBuffer@4
_FreeLockableBuffer@4:
	mov	cl,1
	jmp	II_FreeLockableBuffer@4
public _UnlockBuffer@4
_UnlockBuffer@4:
	mov	cl,2
; _FreeLockableBuffer(16) = _FreeLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_FreeLockableBuffer@4
II_FreeLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _CloseVxDHandle@4
_CloseVxDHandle@4:
	mov	cl,0
; _CloseVxDHandle(16) = _CloseVxDHandle(32) {}
;
; dword ptr [ebp+8]:  pev
;
public II_CloseVxDHandle@4
II_CloseVxDHandle@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;pev: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef _CloseVxDHandle:far16
externDef _FreeLockableBuffer:far16
externDef _UnlockBuffer:far16
externDef _LockBuffer:far16
externDef _AllocateLockableBuffer:far16
externDef _SetVideoFormat:far16
externDef _GetVideoFormat:far16
externDef _GetVideoFormatSize:far16
externDef _UninitializeVideoStream:far16
externDef _InitializeVideoStream:far16
externDef _InitializeExternalVideoStream:far16
externDef _GetVideoPalette:far16
externDef _SendDriverMessage:far16
externDef _CloseDriver:far16
externDef _OpenDriver:far16


FT_thkTargetTable label word
	dw	offset _CloseVxDHandle
	dw	   seg _CloseVxDHandle
	dw	offset _FreeLockableBuffer
	dw	   seg _FreeLockableBuffer
	dw	offset _UnlockBuffer
	dw	   seg _UnlockBuffer
	dw	offset _LockBuffer
	dw	   seg _LockBuffer
	dw	offset _AllocateLockableBuffer
	dw	   seg _AllocateLockableBuffer
	dw	offset _SetVideoFormat
	dw	   seg _SetVideoFormat
	dw	offset _GetVideoFormat
	dw	   seg _GetVideoFormat
	dw	offset _GetVideoFormatSize
	dw	   seg _GetVideoFormatSize
	dw	offset _UninitializeVideoStream
	dw	   seg _UninitializeVideoStream
	dw	offset _InitializeVideoStream
	dw	   seg _InitializeVideoStream
	dw	offset _InitializeExternalVideoStream
	dw	   seg _InitializeExternalVideoStream
	dw	offset _GetVideoPalette
	dw	   seg _GetVideoPalette
	dw	offset _SendDriverMessage
	dw	   seg _SendDriverMessage
	dw	offset _CloseDriver
	dw	   seg _CloseDriver
	dw	offset _OpenDriver
	dw	   seg _OpenDriver




	.data

public thk_ThunkData16	;This symbol must be exported.
thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable
	dd	0	;First-time flag.



	.code 


externDef ThunkConnect16:far16

public thk_ThunkConnect16
thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk_ThunkData16
	push	offset thk_ThunkData16
	push	seg    thk_ThkData32
	push	offset thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk_ThkData32 label byte
	db	"thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\debug.cpp ===
#include "Precomp.h"

#ifdef _DEBUG

HDBGZONE  ghDbgZoneCap = NULL;

int WINAPI CapDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("DCAP", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\16\makefile.inc ===
C16_NAME = $(DEVROOT)\bin\c816\i386\cl -nologo
C16_FLAGS = $(C16_FLAGS) -I$(DEVROOT)\inc16 -I$(DEVROOT)\inc -Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 $(ASM_FLAGS)

!IF "$(BUILD_ALT_DIR)" == "d"
C16_FLAGS = $(C16_FLAGS) -Zi -DDEBUG
ASM_FLAGS = $(ASM_FLAGS) -Zi -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(ASM_FLAGS)
<<NOKEEP

{}.c{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(C16_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(C16_FLAGS)
<<NOKEEP
    @$(C16_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C16_FLAGS: =
)
<<NOKEEP


dcthk.asm: ..\thunks\dcthk.thk
     $(DEVROOT)\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk

$(O)\dcap16.res: dcap16.rc
    $(DEVROOT)\bin\c816\i386\rc -r -I $(DEVROOT)\inc16 -I $(ROOT)\h -fo $@ dcap16.rc

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib:	$(TARGETNAME).def
	@echo Undesirable - DCAP16.DLL is a 16-bit DLL always loaded dynamically

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp:	$(TARGETNAME).def
	@echo Undesirable - DCAP16.DLL is a 16-bit DLL always loaded dynamically

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).dll: $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(O)\$(TARGETNAME).res
	$(DEVROOT)\bin\c816\i386\link @<<
	$(OBJECTS) /align:0x1000 /nodefaultlib /NOE/MAP/NOD/AL:16/NOPACKC/ONERROR:NOEXE $(LINK16_FLAGS),
	$(TARGET),
	$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
	$(TARGETLIBS),
	$(TARGETNAME).def
<<
    $(DEVROOT)\bin\c816\i386\rc $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(PDBCOPY_CMD)
    $(DBGCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\lh\verinfo.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VERINFO.H - header file to define the build version
 *
 **************************************************************************/

#define MMVERSION		1
#define MMREVISION		00
#define MMRELEASE		2

#if defined(DEBUG)
#define VERSIONSTR	"Debug Version 1.00.002\0"
#else
#define VERSIONSTR	"1.00\0"
#endif

#ifdef RC_INVOKED

#define VERSIONCOMPANYNAME	"Microsoft Corp\0"
#define VERSIONPRODUCTNAME	"ACM Wrapper for Lernout and Hauspie codec\0"
#define VERSIONCOPYRIGHT	"Copyright \251 1995-1999 Microsoft Corporation\0"

/*
 *  Version flags 
 */

#if defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG    
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VS_FF_PRIVATEBUILD|VS_FF_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\16\dcthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:55 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk 

	TITLE	$dcthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk_ThunkData32	;This symbol must be exported.
thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk - offset thk_ThunkData32
	dd	offset FT_Prolog_thk - offset thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk_ThunkConnect32@16
thk_ThunkConnect32@16:
	pop	edx
	push	offset thk_ThkData16
	push	offset thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk_ThkData16 label byte
	db	"thk_ThunkData16",0


		


pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public _OpenDriver@12
_OpenDriver@12:
	mov	cl,14
; _OpenDriver(16) = _OpenDriver(32) {}
;
; dword ptr [ebp+8]:  lpDriverName
; dword ptr [ebp+12]:  dwReserved
; dword ptr [ebp+16]:  lpvop
;
public II_OpenDriver@12
II_OpenDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	dword ptr [ebp+12]	;dwReserved: dword->dword
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _CloseDriver@12
_CloseDriver@12:
	mov	cl,13
; _CloseDriver(16) = _CloseDriver(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  lpReserved1
; dword ptr [ebp+16]:  lpReserved2
;
public II_CloseDriver@12
II_CloseDriver@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;lpReserved1: dword->dword
	push	dword ptr [ebp+16]	;lpReserved2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	12





;
public _SendDriverMessage@16
_SendDriverMessage@16:
	mov	cl,12
; _SendDriverMessage(16) = _SendDriverMessage(32) {}
;
; dword ptr [ebp+8]:  h
; dword ptr [ebp+12]:  msg
; dword ptr [ebp+16]:  param1
; dword ptr [ebp+20]:  param2
;
public II_SendDriverMessage@16
II_SendDriverMessage@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;h: dword->word
	push	dword ptr [ebp+12]	;msg: dword->dword
	push	dword ptr [ebp+16]	;param1: dword->dword
	push	dword ptr [ebp+20]	;param2: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	16





;
public _GetVideoPalette@12
_GetVideoPalette@12:
	mov	cl,11
; _GetVideoPalette(16) = _GetVideoPalette(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpcp
; dword ptr [ebp+16]:  dwcbSize
;
public II_GetVideoPalette@12
II_GetVideoPalette@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;dwcbSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public _InitializeVideoStream@12
_InitializeVideoStream@12:
	mov	cl,9
; _InitializeVideoStream(16) = _InitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  dwMicroSecPerFrame
; dword ptr [ebp+16]:  dwEvent
;
public II_InitializeVideoStream@12
II_InitializeVideoStream@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	push	dword ptr [ebp+12]	;dwMicroSecPerFrame: dword->dword
	push	dword ptr [ebp+16]	;dwEvent: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	12





;
public _UninitializeVideoStream@4
_UninitializeVideoStream@4:
	mov	cl,8
	jmp	II_UninitializeVideoStream@4
public _InitializeExternalVideoStream@4
_InitializeExternalVideoStream@4:
	mov	cl,10
; _UninitializeVideoStream(16) = _UninitializeVideoStream(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_UninitializeVideoStream@4
II_UninitializeVideoStream@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _GetVideoFormatSize@4
_GetVideoFormatSize@4:
	mov	cl,7
; _GetVideoFormatSize(16) = _GetVideoFormatSize(32) {}
;
; dword ptr [ebp+8]:  hvideo
;
public II_GetVideoFormatSize@4
II_GetVideoFormatSize@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public _GetVideoFormat@8
_GetVideoFormat@8:
	mov	cl,6
; _GetVideoFormat(16) = _GetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideo
; dword ptr [ebp+12]:  lpbmih
;
public II_GetVideoFormat@8
II_GetVideoFormat@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideo: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public _SetVideoFormat@12
_SetVideoFormat@12:
	mov	cl,5
; _SetVideoFormat(16) = _SetVideoFormat(32) {}
;
; dword ptr [ebp+8]:  hvideoExtIn
; dword ptr [ebp+12]:  hvideoIn
; dword ptr [ebp+16]:  lpbmih
;
public II_SetVideoFormat@12
II_SetVideoFormat@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hvideoExtIn: dword->word
	push	word ptr [ebp+12]	;hvideoIn: dword->word
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public _AllocateLockableBuffer@4
_AllocateLockableBuffer@4:
	mov	cl,4
; _AllocateLockableBuffer(16) = _AllocateLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  dwSize
;
public II_AllocateLockableBuffer@4
II_AllocateLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwSize: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _LockBuffer@4
_LockBuffer@4:
	mov	cl,3
; _LockBuffer(16) = _LockBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_LockBuffer@4
II_LockBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public _FreeLockableBuffer@4
_FreeLockableBuffer@4:
	mov	cl,1
	jmp	II_FreeLockableBuffer@4
public _UnlockBuffer@4
_UnlockBuffer@4:
	mov	cl,2
; _FreeLockableBuffer(16) = _FreeLockableBuffer(32) {}
;
; dword ptr [ebp+8]:  wBuffer
;
public II_FreeLockableBuffer@4
II_FreeLockableBuffer@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBuffer: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public _CloseVxDHandle@4
_CloseVxDHandle@4:
	mov	cl,0
; _CloseVxDHandle(16) = _CloseVxDHandle(32) {}
;
; dword ptr [ebp+8]:  pev
;
public II_CloseVxDHandle@4
II_CloseVxDHandle@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;pev: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef _CloseVxDHandle:far16
externDef _FreeLockableBuffer:far16
externDef _UnlockBuffer:far16
externDef _LockBuffer:far16
externDef _AllocateLockableBuffer:far16
externDef _SetVideoFormat:far16
externDef _GetVideoFormat:far16
externDef _GetVideoFormatSize:far16
externDef _UninitializeVideoStream:far16
externDef _InitializeVideoStream:far16
externDef _InitializeExternalVideoStream:far16
externDef _GetVideoPalette:far16
externDef _SendDriverMessage:far16
externDef _CloseDriver:far16
externDef _OpenDriver:far16


FT_thkTargetTable label word
	dw	offset _CloseVxDHandle
	dw	   seg _CloseVxDHandle
	dw	offset _FreeLockableBuffer
	dw	   seg _FreeLockableBuffer
	dw	offset _UnlockBuffer
	dw	   seg _UnlockBuffer
	dw	offset _LockBuffer
	dw	   seg _LockBuffer
	dw	offset _AllocateLockableBuffer
	dw	   seg _AllocateLockableBuffer
	dw	offset _SetVideoFormat
	dw	   seg _SetVideoFormat
	dw	offset _GetVideoFormat
	dw	   seg _GetVideoFormat
	dw	offset _GetVideoFormatSize
	dw	   seg _GetVideoFormatSize
	dw	offset _UninitializeVideoStream
	dw	   seg _UninitializeVideoStream
	dw	offset _InitializeVideoStream
	dw	   seg _InitializeVideoStream
	dw	offset _InitializeExternalVideoStream
	dw	   seg _InitializeExternalVideoStream
	dw	offset _GetVideoPalette
	dw	   seg _GetVideoPalette
	dw	offset _SendDriverMessage
	dw	   seg _SendDriverMessage
	dw	offset _CloseDriver
	dw	   seg _CloseDriver
	dw	offset _OpenDriver
	dw	   seg _OpenDriver




	.data

public thk_ThunkData16	;This symbol must be exported.
thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	027b0fh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable
	dd	0	;First-time flag.



	.code 


externDef ThunkConnect16:far16

public thk_ThunkConnect16
thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk_ThunkData16
	push	offset thk_ThunkData16
	push	seg    thk_ThkData32
	push	offset thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk_ThkData32 label byte
	db	"thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\16\dcasm.asm ===
;  DCASM.ASM
;
;  Created 31-Jul-96 [JonT]

	PAGE 60, 255
	.MODEL small, pascal
	TITLE DCASM.ASM
	
	.386
	.DATA
	extrn g_dwEntrypoint:DWORD
szName	DB	'DCAPVXD ', 0

	.CODE

	extrn OpenDriver:FAR
	extrn CloseDriver:FAR

	PUBLIC _OpenDriver
_OpenDriver::
	jmp	OpenDriver

	PUBLIC _CloseDriver
_CloseDriver::
	jmp	CloseDriver
	
;  ReturnSel
;	Returns either CS or DS to the C caller

ReturnSel PROC NEAR PASCAL, fCS:WORD
	mov	ax, ds
	cmp	fCS, 0
	jz	RS_Done
	mov	ax, cs
RS_Done:
	ret
ReturnSel ENDP


;  GetVxDEntrypoint
;	Returns device entrypoint in DX:AX or zero on error

GetVxDEntrypoint PROC NEAR PASCAL uses si di

	; Get the entrypoint from the VMM
	xor	bx, bx
	mov     ax, 1684h
	push	ds
	pop	es
	mov	di, OFFSET szName
	int     2Fh
	
	; Return entrypoint in EAX
	mov	dx, es
	mov	ax, di
	ret

GetVxDEntrypoint ENDP


;  SetWin32Event
;	Sets a Win32 event using the VxD

SetWin32Event PROC NEAR PASCAL, pev:DWORD

	; Call the VxD. Note that pev is already a flat pointer
	mov	ah, 1
	mov	ecx, pev
	call	[g_dwEntrypoint]
	ret

SetWin32Event ENDP 


;  _CloseVxDHandle
;	Calls the VxD to close a VxD handle. This is really torturous
;	since it's just going to call into KERNEL32, but there's no
;	export to do this from ring 3. Go figure.

_CloseVxDHandle PROC FAR PASCAL USES ds, pev:DWORD

	mov	ax, DGROUP
	mov	ds, ax
	mov	ah, 2
	mov	ecx, pev
	call	[g_dwEntrypoint]

	ret
	
_CloseVxDHandle ENDP


;  ZeroMemory
;
;	Since we can't call CRT, does a memset(lp, 0, len)

ZeroMemory PROC NEAR PASCAL USES di, lp:DWORD, len:WORD

	les	di, lp
	xor	eax, eax
	mov	cx, len
	shr	cx, 2
	rep	stosd
	mov	cx, len
	and	cx, 3
	rep	stosb
	ret

ZeroMemory ENDP
	
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\16\dcap16.c ===
//  DCAP16.C
//
//  Created 31-Jul-96 [JonT]

#include <windows.h>
#define NODRAWDIB
#define NOCOMPMAN
#define NOAVIFILE
#define NOMSACM
#define NOAVIFMT
#define NOMCIWND
#define NOAVICAP
#include <vfw.h>
#include "..\inc\idcap.h"
#include "..\inc\msviddrv.h"

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))

// Equates
#define DCAP16API   __far __pascal __loadds
#define DCAP16LOCAL __near __pascal
#define DLL_PROCESS_ATTACH  1       // Not in 16-bit windows.h



#ifdef DEBUG_SPEW_VERBOSE
#define DEBUGSPEW(str)	DebugSpew((str))
#else
#define DEBUGSPEW(str)
#endif


// Structures thunked down
typedef struct _CAPTUREPALETTE
{
    WORD wVersion;
    WORD wcEntries;
    PALETTEENTRY pe[256];
} CAPTUREPALETTE, FAR* LPCAPTUREPALETTE;

// Special thunking prototypes
BOOL DCAP16API __export DllEntryPoint(DWORD dwReason,
         WORD  hInst, WORD  wDS, WORD  wHeapSize, DWORD dwReserved1,
         WORD  wReserved2);
BOOL __far __pascal thk_ThunkConnect16(LPSTR pszDll16, LPSTR pszDll32,
    WORD  hInst, DWORD dwReason);

// Helper functions
WORD DCAP16LOCAL    ReturnSel(BOOL fCS);
DWORD DCAP16LOCAL   GetVxDEntrypoint(void);
int DCAP16LOCAL     SetWin32Event(DWORD dwEvent);
void DCAP16API      FrameCallback(HVIDEO hvideo, WORD wMsg, LPLOCKEDINFO lpli,
                        LPVIDEOHDR lpvh, DWORD dwParam2);
void DCAP16LOCAL    ZeroMemory(LPSTR lp, WORD wSize);

// Globals
    HANDLE g_hInst;
    DWORD g_dwEntrypoint;

    LPLOCKEDINFO g_lpli;

//  LibMain

int
CALLBACK
LibMain(
    HINSTANCE hinst,
    WORD wDataSeg,
    WORD cbHeapSize,
    LPSTR lpszCmdLine
    )
{
    // Save global hinst
    g_hInst = hinst;
	
    // Still necessary?
    if (cbHeapSize)
        UnlockData(wDataSeg);

    return TRUE;
}


//  DllEntryPoint

BOOL
__far __pascal __export __loadds
DllEntryPoint(
    DWORD dwReason,
    WORD  hInst,
    WORD  wDS,
    WORD  wHeapSize,
    DWORD dwReserved1,
    WORD  wReserved2
    )
{
    if (!thk_ThunkConnect16("DCAP16.DLL", "DCAP32.DLL", hInst, dwReason))
    {
        DebugSpew("DllEntrypoint: thk_ThunkConnect16 failed!");
        return FALSE;
    }

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_dwEntrypoint = GetVxDEntrypoint();
        break;
    }

    return TRUE;
}


// APIs


//  _InitializeExternalVideoStream
//      Initializes a video stream for the external channel. We don't
//      have to deal with locking or ever set a callback on this channel.

BOOL
DCAP16API
_InitializeExternalVideoStream(
    HANDLE hvideo
	)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    vsip.dwMicroSecPerFrame = 0;    // Ignored by driver for this channel
    vsip.dwCallback = NULL;         // No callback for now
    vsip.dwCallbackInst = NULL;
    vsip.dwFlags = 0;
    vsip.hVideo = (DWORD)hvideo;

    return !SendDriverMessage(hvideo, DVM_STREAM_INIT,
        (DWORD) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
        (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}


void
DCAP16API
FrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    LPLOCKEDINFO lpli,      // Note that this is our instance data
    LPVIDEOHDR lpvh,
    DWORD dwParam2
    )
{
    LPCAPBUFFER lpcbuf;
    
    if (!lpli) {
        // Connectix hack: driver doesn't pass our instance data, so we keep it global        
        lpli = g_lpli;
    }
    
    // The client can put us in shutdown mode. This means that we will not queue
    // any more buffers onto the ready queue, even if they were ready.
    // This keeps the buffers from being given back to the driver, so it will eventually
    // stop streaming. Of course, it will spew errors, but we just ignore these.
    // Shutdown mode is defined when there is no event ready to signal.
    if (!lpli->pevWait)
        return;

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGSPEW("Setting hcd->hevWait - no data\r\n");
        SetWin32Event(lpli->pevWait);
        return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (lpli->lp1616Tail != lpli->lp1616Current)
        lpli->lp1616Tail = lpli->lp1616Tail->lp1616Prev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!lpli->lp1616Tail)
        lpli->lp1616Head = NULL;

    // Add the new buffer to the ready queue
    lpcbuf = (LPCAPBUFFER)((LPBYTE)lpvh - ((LPBYTE)&lpcbuf->vh - (LPBYTE)lpcbuf));

    lpcbuf->lp1616Next = lpli->lp1616Head;
    lpcbuf->lp1616Prev = NULL;
    if (lpli->lp1616Head)
        lpli->lp1616Head->lp1616Prev = lpcbuf;
    else
        lpli->lp1616Tail = lpcbuf;
    lpli->lp1616Head = lpcbuf;

#if 1
    if (lpli->lp1616Current) {
    	if (!(lpli->dwFlags & LIF_STOPSTREAM)) {
    	    // if client hasn't consumed last frame, then release it
    	    lpvh = &lpli->lp1616Current->vh;
    	    lpli->lp1616Current = lpli->lp1616Current->lp1616Prev;
    		DEBUGSPEW("Sending DVM_STREAM_ADDBUFFER");
			// Signal that the application is done with the buffer
			lpvh->dwFlags &= ~VHDR_DONE;
    	    if (SendDriverMessage(hvideo, DVM_STREAM_ADDBUFFER, *((DWORD*)&lpvh), sizeof(VIDEOHDR)) != 0)
    		DebugSpew("attempt to reuse unconsumed buffer failed");
    	}
    }
    else {
#else
    if (!lpli->lp1616Current) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
        lpli->lp1616Current = lpli->lp1616Tail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGSPEW("Setting hcd->hevWait - some data\r\n");
    SetWin32Event(lpli->pevWait);
}


//  _InitializeVideoStream
//      Initializes a driver's video stream for the video in channel.
//      This requires us to pagelock the memory for everything that will
//      be touched at interrupt time.

BOOL
DCAP16API
_InitializeVideoStream(
	HANDLE hvideo,
    DWORD dwMicroSecPerFrame,
    LPLOCKEDINFO lpli
	)
{
    DWORD dwRet;
    WORD wsel;
    VIDEO_STREAM_INIT_PARMS vsip;

    ZeroMemory((LPSTR)&vsip, sizeof (VIDEO_STREAM_INIT_PARMS));
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD)FrameCallback;
    vsip.dwCallbackInst = (DWORD)lpli;      // LOCKEDINFO* is instance data for callback
    vsip.dwFlags = CALLBACK_FUNCTION;
    vsip.hVideo = (DWORD)hvideo;

    g_lpli = lpli;
    
    dwRet = SendDriverMessage(hvideo, DVM_STREAM_INIT,
        (DWORD) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
        (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));

    // If we succeeded, we now lock down our code and data
    if (dwRet == 0)
    {
        // Lock CS
        wsel = ReturnSel(TRUE);
        GlobalSmartPageLock(wsel);

        // Lock DS
        wsel = ReturnSel(FALSE);
        GlobalSmartPageLock(wsel);

        return TRUE;
    }

    return FALSE;
}


//  _UninitializeVideoStream
//      Tells the driver we are done streaming. It also unlocks the memory
//      we locked for interrupt time access.

BOOL
DCAP16API
_UninitializeVideoStream(
	HANDLE hvideo
	)
{
    DWORD dwRet;
    WORD wsel;

    dwRet = SendDriverMessage(hvideo, DVM_STREAM_FINI, 0L, 0L);

    // Unlock our code and data
    if (dwRet == 0)
    {
        // Unlock CS
        wsel = ReturnSel(TRUE);
        GlobalSmartPageUnlock(wsel);

        // Unlock DS
        wsel = ReturnSel(FALSE);
        GlobalSmartPageUnlock(wsel);

        return TRUE;
    }

    return FALSE;
}


//  _GetVideoPalette
//      Get the current palette from the driver

HPALETTE
DCAP16API
_GetVideoPalette(
    HANDLE hvideo,
    LPCAPTUREPALETTE lpcp,
    DWORD dwcbSize
    )
{
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = (LPVOID)lpcp;
    vcp.dwSize1 = dwcbSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0;

    return !SendDriverMessage(hvideo, DVM_PALETTE,
        (DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
        (DWORD)(LPVIDEOCONFIGPARMS)&vcp);
}


//  _GetVideoFormatSize
//        Gets the current format header size required by driver

DWORD
DCAP16API
_GetVideoFormatSize(
    HANDLE hvideo
    )
{
	DWORD bufsize;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = &bufsize;
    vcp.lpData1 = NULL;
    vcp.dwSize1 = 0L;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

#if 0
    // it makes sense to query if DVM_FORMAT is available, but not all drivers support it!
	if (SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERY),
							(LPARAM)(LPVOID)&vcp) == DV_ERR_OK) {
#endif
		SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE),
							(LPARAM)(LPVOID)&vcp);
        if (!bufsize)
            bufsize = sizeof(BITMAPINFOHEADER);
		return bufsize;
#if 0
    } else
        return sizeof(BITMAPINFOHEADER);
#endif
}
        
//  _GetVideoFormat
//      Gets the current format (dib header) the capture device is blting to

BOOL
DCAP16API
_GetVideoFormat(
    HANDLE hvideo,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL res;
    VIDEOCONFIGPARMS vcp;

    if (!lpbmih->biSize)
        lpbmih->biSize = sizeof (BITMAPINFOHEADER);
        
    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    res = !SendDriverMessage(hvideo, DVM_FORMAT,
			(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
			(LPARAM)(LPVOID)&vcp);
	if (res) {
	    // hack for Connectix QuickCam - set format needs to be called
		//   to set internal globals so that streaming can be enabled
		SendDriverMessage(hvideo, DVM_FORMAT, (LPARAM)(DWORD)VIDEO_CONFIGURE_SET,
		        	        (LPARAM)(LPVOID)&vcp);
	}
	return res;
}


//  _SetVideoFormat
//      Sets the format (dib header) the capture device is blting to.

BOOL
DCAP16API
_SetVideoFormat(
    HANDLE hvideoExtIn,
    HANDLE hvideoIn,
    LPBITMAPINFOHEADER lpbmih
    )
{
    RECT rect;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    // See if the driver likes the format
    if (SendDriverMessage(hvideoIn, DVM_FORMAT, (LPARAM)(DWORD)VIDEO_CONFIGURE_SET,
        (LPARAM)(LPVOID)&vcp))
        return FALSE;

    // Set the rectangles
    rect.left = rect.top = 0;
    rect.right = (WORD)lpbmih->biWidth;
    rect.bottom = (WORD)lpbmih->biHeight;
    SendDriverMessage(hvideoExtIn, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
    SendDriverMessage(hvideoIn, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);

    return TRUE;
}


//  _AllocateLockableBuffer
//      Allocates memory that can be page locked. Just returns the selector.

WORD
DCAP16API
_AllocateLockableBuffer(
    DWORD dwSize
    )
{
    return GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwSize);
}


//  _LockBuffer
//      Page locks (if necessary) a buffer allocated with _AllocateLockableBuffer.

BOOL
DCAP16API
_LockBuffer(
    WORD wBuffer
    )
{
    return GlobalSmartPageLock(wBuffer);
}

//  _UnlockBuffer
//      Unlocks a buffer locked with _LockBuffer.

void
DCAP16API
_UnlockBuffer(
    WORD wBuffer
    )
{
    GlobalSmartPageUnlock(wBuffer);
}


//  _FreeLockableBuffer
//      Frees a buffer allocated with _AllocateLockableBuffer.

void
DCAP16API
_FreeLockableBuffer(
    WORD wBuffer
    )
{
    GlobalFree(wBuffer);
}


//  _SendDriverMessage
//      Sends a generic, dword only parameters, message to the driver channel of choice

DWORD
DCAP16API
_SendDriverMessage(
    HVIDEO hvideo,
    DWORD wMessage,
    DWORD param1,
    DWORD param2
    )
{
    return SendDriverMessage(hvideo, (WORD)wMessage, param1, param2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\dcap32.cpp ===
//
//  Created 31-Jul-96 [JonT]

// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

#ifndef WIDTHBYTES
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)
#endif

#ifdef _DEBUG
static PTCHAR _rgZonesCap[] = {
	TEXT("dcap"),
	TEXT("Init"),
	TEXT("Streaming"),
	TEXT("Callback"),
	TEXT("Dialogs"),
	TEXT("Trace")
};
#endif

#ifndef __NT_BUILD__
extern "C" {
// Special thunk prototype
BOOL    thk_ThunkConnect32(LPSTR pszDll16, LPSTR pszDll32,
        HINSTANCE hInst, DWORD dwReason);

//; Magic Function code values for DeviceIOControl code.
//DCAPVXD_THREADTIMESERVICE equ	101h
//DCAPVXD_R0THREADIDSERVICE equ 102h
#define DCAPVXD_THREADTIMESERVICE 0x101
#define DCAPVXD_R0THREADIDSERVICE 0x102


// KERNEL32 prototypes (not in headers but are exported by name on Win95)
void* WINAPI    MapSL(DWORD dw1616Ptr);
HANDLE WINAPI   OpenVxDHandle(HANDLE h);
}
#endif

// Helper function prototypes
BOOL    initializeCaptureDeviceList(void);
HVIDEO  openVideoChannel(DWORD dwDeviceID, DWORD dwFlags);
BOOL    allocateBuffers(HCAPDEV hcd, int nBuffers);
void    freeBuffers(HCAPDEV hcd);

// Globals
	HINSTANCE g_hInst;
    int g_cDevices;
    LPINTERNALCAPDEV g_aCapDevices[DCAP_MAX_DEVICES];

	BOOL g_fInitCapDevList;
#define INIT_CAP_DEV_LIST() if (g_fInitCapDevList) { initializeCaptureDeviceList(); }

#ifndef __NT_BUILD__
    HANDLE s_hVxD = NULL;
#endif //__NT_BUILD__

// Strings
#ifdef __NT_BUILD__
    char g_szVFWRegKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32";
    char g_szVFWRegDescKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc";
    char g_szDriverName[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "WDM Video For Windows Capture Driver (Win32)";
    char g_szVfWToWDMMapperName[] = "VfWWDM32.dll";
#endif
#else
    char g_szVFWRegKey[] = "SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo";
    char g_szRegDescription[] = "Description";
    char g_szRegName[] = "Driver";
    char g_szRegDisabled[] = "Disabled";
    char g_szDevNode[] = "DevNode";
    char g_szSystemIni[] = "system.ini";
    char g_szDriverSection[] = "drivers";
    char g_szDriverKey[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "VfW MM 16bit Driver for WDM V. Cap. Devices";
    char g_szVfWToWDMMapperName[] = "vfwwdm.drv";
#endif
#endif
    char g_szMSOfficeCamcorderDescription[] = "Screen Capture Device Driver for AVI";
    char g_szMSOfficeCamcorderName[] = "Gdicap97.drv";

    char g_szVerQueryForDesc[] = "\\StringFileInfo\\040904E4\\FileDescription";


void DoClose(HCAPDEV hcd);

#define ENTER_DCAP(hcd) InterlockedIncrement(&(hcd)->busyCount);
#define LEAVE_DCAP(hcd) if (InterlockedDecrement(&(hcd)->busyCount) == 0) DoClose((hcd));

//  DllEntryPoint

extern "C" BOOL
DllEntryPoint(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    static int s_nProcesses = 0;

	FX_ENTRY("DllEntryPoint");

#ifndef __NT_BUILD__

    // We want to load the VxD even before initializing the thunks
    // because the 16-bit half initializes the VxD during the thk_ThunkConnect32 call
    if (!s_hVxD)
    {
        s_hVxD = CreateFile("\\\\.\\DCAPVXD.VXD", 0,0,0,0, FILE_FLAG_DELETE_ON_CLOSE, 0);
        if (s_hVxD == INVALID_HANDLE_VALUE)
        {
			ERRORMESSAGE(("%s: Failure loading VxD - Fatal\r\n", _fx_));
            return FALSE;
        }
    }

    // Initialize the thunks
    if (!(thk_ThunkConnect32("DCAP16.DLL", "DCAP32.DLL", hInst, dwReason)))
    {
		ERRORMESSAGE(("%s: thk_ThunkConnect32 failed!\r\n", _fx_));
        return FALSE;
    }
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

		// Save global hinst
		g_hInst = hInst;

        // Only initialize on the first DLL load
        if (s_nProcesses++ == 0)
        {
			DBGINIT(&ghDbgZoneCap, _rgZonesCap);

            DBG_INIT_MEMORY_TRACKING(hInst);

			g_fInitCapDevList = TRUE;
        }
        else
            return FALSE;   // fail to load multiple instances
        break;

    case DLL_PROCESS_DETACH:
        if (--s_nProcesses == 0)    // Are we going away?
        {
#ifndef __NT_BUILD__
            CloseHandle(s_hVxD);
            s_hVxD = NULL;
#endif
            DBG_CHECK_MEMORY_TRACKING(hInst);

			DBGDEINIT(&ghDbgZoneCap);
        }
        break;
    }

    return TRUE;
}


void GetVersionData (LPINTERNALCAPDEV lpcd)
{
    int j;
    DWORD dwVerInfoSize;
    LPSTR lpstrInfo;
    LPSTR lpDesc;

    // Version number
    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(lpcd->szDeviceName, NULL);
    if (dwVerInfoSize && (lpstrInfo  = (LPSTR)LocalAlloc(LPTR, dwVerInfoSize))) {
        // Read from the file into our block
        if (GetFileVersionInfo(lpcd->szDeviceName, 0L, dwVerInfoSize, lpstrInfo)) {
            lpDesc = NULL;
            if (VerQueryValue(lpstrInfo, g_szVerQueryForDesc, (LPVOID *)&lpDesc, (PUINT)&j) && lpDesc) {
                lstrcpyn(lpcd->szDeviceDescription, lpDesc, j);
                    wsprintf(lpcd->szDeviceVersion, TEXT("Version:  %d.%d.%d.%d"),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS));
            }
        }
        LocalFree(lpstrInfo);
    }
}


#ifdef __NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry
//      Returns FALSE iff there are no video devices.
BOOL
initializeCaptureDeviceList(void)
{
	HKEY hkeyVFW, hkeyVFWdesc;
	DWORD dwType;
	DWORD dwSize;
	int i;
	LPINTERNALCAPDEV lpcd;
	HCAPDEV hCapDev;

	FX_ENTRY("initializeCaptureDeviceList");

	// Clear the entire array and start with zero devices
	g_cDevices = 0;
	ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// Open the reg key in question
	if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
	{
		if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegDescKey, &hkeyVFWdesc) != ERROR_SUCCESS)
			hkeyVFWdesc = 0;

		lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));

		if (lpcd)
		{
			// Loop through all possible VFW drivers in registry
			for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
			{
				// Create the key name
				if (i == 0)
					g_szDriverName[sizeof (g_szDriverName) - 2] = 0;
				else
					g_szDriverName[sizeof (g_szDriverName) - 2] = (BYTE)i + '0';

				// Name
				dwSize = sizeof(lpcd->szDeviceName);
				if (RegQueryValueEx(hkeyVFW, g_szDriverName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize) == ERROR_SUCCESS)
				{
					// Description
					if (hkeyVFWdesc)
					{
						dwSize = sizeof(lpcd->szDeviceDescription);
						RegQueryValueEx(hkeyVFWdesc, lpcd->szDeviceName, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);
					}
					else
						lstrcpy (lpcd->szDeviceDescription, lpcd->szDeviceName);

					// Devnode
					lpcd->dwDevNode = 0;
					lpcd->nDeviceIndex = g_cDevices;

					GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
					// Remove bogus Camcorder capture device from list of devices shown to the user
					// The Camcorder driver is a fake capture device used by the MS Office Camcorder
					// to capture screen activity to an AVI file. This not a legit capture device driver
					// and is extremely buggy.
					// We also remove the VfW to WDM mapper if we are on NT5.
					if (lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName) && lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName))
					{
#endif
						g_aCapDevices[g_cDevices] = lpcd;
						g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
						g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
					}
					else
						LocalFree(lpcd);
#endif

					lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
					if (!lpcd)
					{
						ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
						break;  // break out of the FOR loop
					}
				}
			}
		}
		else
		{
			ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
		}

		if (lpcd)
			LocalFree (lpcd);   // free the extra buffer

		RegCloseKey(hkeyVFW);
		if (hkeyVFWdesc)
			RegCloseKey(hkeyVFWdesc);
	}

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

	return TRUE;
}

#else //__NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry and
//      from SYSTEM.INI.
//      Returns FALSE iff there are no video devices.

BOOL
initializeCaptureDeviceList(void)
{
    int i, j, index;
    HKEY hkeyVFW;
    HKEY hkeyEnum;
    DWORD dwType;
    DWORD dwSize;
    LPINTERNALCAPDEV lpcd;
    char szEnumName[MAX_PATH];
    char szDisabled[3];
    HCAPDEV hCapDev;
	OSVERSIONINFO osvInfo = {0};

	FX_ENTRY("initializeCaptureDeviceList");

    // Clear the entire array and start with zero devices
    g_cDevices = 0;
    ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// If we are on a version on Win95 (OSRx) use the mapper to talk to WDM devices.
	// The WDM drivers used on OSR2 are not stream class minidrivers so we fail
	// to handle them properly. Let the mapper do this for us.
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvInfo);

    // Open the reg key in question
    if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
    {
        // Loop through all possible VFW drivers in registry
        for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
        {
            // See if the key is there and if not, we're done. Note that registry
            // keys have to be sequential, no holes allowed since the only way
            // to query is sequential...
            if (RegEnumKey(hkeyVFW, i, szEnumName, MAX_PATH) != ERROR_SUCCESS ||
                RegOpenKey(hkeyVFW, szEnumName, &hkeyEnum) != ERROR_SUCCESS)
                break;

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }

            // Description
            dwSize = sizeof (lpcd->szDeviceDescription);
            RegQueryValueEx(hkeyEnum, g_szRegDescription, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);

            // Name
            dwSize = sizeof (lpcd->szDeviceName);
            RegQueryValueEx(hkeyEnum, g_szRegName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize);

            // Disabled
            dwSize = sizeof (szDisabled);
            if (RegQueryValueEx(hkeyEnum, g_szRegDisabled, NULL, &dwType, (LPBYTE)szDisabled, &dwSize) == ERROR_SUCCESS &&
                szDisabled[0] == '1')
                lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

            // Devnode
            dwSize = sizeof (DWORD);
            RegQueryValueEx(hkeyEnum, g_szDevNode, NULL, &dwType, (BYTE*)&lpcd->dwDevNode, &dwSize);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

            RegCloseKey(hkeyEnum);
        }

        RegCloseKey(hkeyVFW);
    }

    // Now get the rest from system.ini, if any
    for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
    {
        // Create the key name
        if (i == 0)
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = 0;
        else
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = (BYTE)i + '0';

        // See if there's a profile string
        if (GetPrivateProfileString(g_szDriverSection, g_szDriverKey, "",
            szEnumName, MAX_PATH, g_szSystemIni))
        {
            // First check to see if this is a dupe. If it is, go no further.
            if (g_cDevices)
            {
                for (j = 0 ; j < g_cDevices ; j++)
                    if (!lstrcmpi(g_aCapDevices[j]->szDeviceName, szEnumName))
                        goto NextDriver;
            }

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }
            // We have a unique name, copy in the driver name and find the description
            // by reading the driver's versioninfo resource.
            lstrcpy(lpcd->szDeviceName, szEnumName);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

        }
NextDriver: ;
    }

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

    return TRUE;
}
#endif //__NT_BUILD__


//  GetNumCaptureDevice
//      Returns the number of *ENABLED* capture devices

/****************************************************************************
 *  @doc EXTERNAL DCAP32
 *
 *  @func int DCAPI | GetNumCaptureDevices | This function returns the number
 *    of *ENABLED* capture devices.
 *
 *  @rdesc Returns the number of *ENABLE* capture devices.
 ***************************************************************************/
int
DCAPI
GetNumCaptureDevices()
{
	int nNumCapDevices = 0;
	int nDeviceIndex = 0;

	INIT_CAP_DEV_LIST();

	while (nDeviceIndex < g_cDevices)
		if (!(g_aCapDevices[nDeviceIndex++]->dwFlags & CAPTURE_DEVICE_DISABLED))
			nNumCapDevices++;

    return nNumCapDevices;
}


//  FindFirstCaptureDevice
//      Returns the first capture device available that matches the string
//      or the first one registered if szDeviceDescription is NULL

BOOL
DCAPI
FindFirstCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    char* szDeviceDescription
    )
{
    int i;
    static HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Validate size
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

// hack to avoid quickcam driver problem when hardware not installed
    if (g_cDevices && !hcap) {
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);
        if ((i < g_cDevices) && (hcap = OpenCaptureDevice(i))) {
            CloseCaptureDevice (hcap);
        }
        else {
			if (i < g_cDevices) {
				g_aCapDevices[i]->dwFlags |= CAPTURE_DEVICE_DISABLED;
#ifdef _DEBUG
				OutputDebugString((i == 0) ? "DCAP32: 1st capture device fails to open!\r\n" : (i == 1) ? "DCAP32: 2nd capture device fails to open!\r\n" : (i == 2) ? "DCAP32: 3rd capture device fails to open!\r\n" : "DCAP32: 4th capture device fails to open!\r\n");
#endif
			}
        }
    }

    // Search if necessary
    if (szDeviceDescription)
    {
        for (i = 0 ; i < g_cDevices ; i++)
            if (!lstrcmpi(g_aCapDevices[i]->szDeviceDescription, szDeviceDescription) &&
                !(g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED))
                break;
    }
    else
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);

    // Return the info
    if (i == g_cDevices)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }
    else {
        lpfcd->nDeviceIndex = i;
        lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
        lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[i]->szDeviceDescription);
        lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[i]->szDeviceVersion);
        return TRUE;
    }
}


//  FindFirstCaptureDeviceByIndex
//      Returns the device with the specified index.

BOOL
DCAPI
FindFirstCaptureDeviceByIndex(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    int nDeviceIndex
    )
{
	INIT_CAP_DEV_LIST();

    // Validate size and index
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE) ||
        nDeviceIndex >= g_cDevices || (nDeviceIndex < 0) ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Return the info
    lpfcd->nDeviceIndex = nDeviceIndex;
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  FindNextCaptureDevice
//      Returns the next capture device in list.

BOOL
DCAPI
FindNextCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd
    )
{
    HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Parameter validate the passed in structure
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    while (++lpfcd->nDeviceIndex < g_cDevices)
	{
		if ((!(g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED)))
		{
			if (g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_OPEN)
				break;
			else
			{
				if (hcap = OpenCaptureDevice(lpfcd->nDeviceIndex))
				{
					CloseCaptureDevice (hcap);
					break;
				}
				else
					g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags |= CAPTURE_DEVICE_DISABLED;
			}
		}
	}

    // See if we're at the end
    if (lpfcd->nDeviceIndex >= g_cDevices)
    {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    // Otherwise, fill in the info for the next one
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  OpenCaptureDevice

HCAPDEV
DCAPI
OpenCaptureDevice(
    int nDeviceIndex
    )
{
    LPINTERNALCAPDEV hcd;
    LPBITMAPINFOHEADER lpbmih = NULL;
    DWORD err, dwLen;
    BOOL fl;

	FX_ENTRY("OpenCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    // Validate the device index
    if ((unsigned)nDeviceIndex >= (unsigned)g_cDevices ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & (CAPTURE_DEVICE_DISABLED | CAPTURE_DEVICE_OPEN))) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    hcd = g_aCapDevices[nDeviceIndex];
    hcd->busyCount = 1;                 // we start at 1 to say that we're open
                                        // DoClose happens when count goes to 0

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifndef __NT_BUILD__
		// Allocate some memory we can lock for the LOCKEDINFO structure
		hcd->wselLockedInfo = _AllocateLockableBuffer(sizeof (LOCKEDINFO));
		if (!hcd->wselLockedInfo) {
			err = ERROR_OUTOFMEMORY;
			goto Error;
		}

		// Do our own thunking so we can track the selector for this buffer
		hcd->lpli = (LPLOCKEDINFO)MapSL(((DWORD)hcd->wselLockedInfo) << 16);
#endif

		// Open the necessary video channels
		if (!(hcd->hvideoIn = openVideoChannel(nDeviceIndex, VIDEO_IN)) ||
			!(hcd->hvideoCapture = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALIN)))
		{
			ERRORMESSAGE(("%s: Couldn't open video channel(s)\r\n", _fx_));
			if (hcd->hvideoIn)
				_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALOUT))
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device supports overlay!\r\n", _fx_));
		}
		else
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device does not support overlay\r\n", _fx_));
		}
#endif
	}
	else
	{
		if (!WDMOpenDevice(nDeviceIndex))
		{
			ERRORMESSAGE(("%s: Couldn't open WDM device\r\n", _fx_));
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}
	}

    hcd->dwFlags |= CAPTURE_DEVICE_OPEN;

    // Get the initial format and set the values
    dwLen = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen)) {
        lpbmih->biSize = dwLen;
        fl = GetCaptureDeviceFormat(hcd, lpbmih);
        //If we can't get a format, or height and/or width are 0, don't use this device
        if (!fl || lpbmih->biWidth == 0 || lpbmih->biHeight == 0) {
			ERRORMESSAGE(("%s: GetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
        fl = SetCaptureDeviceFormat(hcd, lpbmih, 0, 0);
        if (!fl) {
			ERRORMESSAGE(("%s: SetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
#if 0
        _SetCaptureRect(hcd->hvideoIn, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_SRC_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
#endif
        LocalFree((HANDLE)lpbmih);
    } else {
        err = ERROR_OUTOFMEMORY;
        goto Error;
    }

	// Keep a stream running all the time on EXTERNALIN (capture->frame buffer).
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay)
			_InitializeExternalVideoStream(hcd->hvideoOverlay);
#else
		_InitializeExternalVideoStream(hcd->hvideoCapture);
#endif

#ifndef __NT_BUILD__
		// Lock our structure so it can be touched at interrupt time
		_LockBuffer(hcd->wselLockedInfo);
#endif
	}

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hcd;

Error:
    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;
    if (lpbmih) {
        LocalFree((HANDLE)lpbmih);
        lpbmih = NULL;
    }
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		if (hcd->hvideoIn) {
			_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			hcd->hvideoIn = NULL;
		}
		if (hcd->hvideoCapture) {
			_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0);
			hcd->hvideoCapture = NULL;
		}
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif
	}
	else
	{
		WDMCloseDevice(nDeviceIndex);
	}
    SetLastError(err);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return NULL;
}


void
DoClose(
    HCAPDEV hcd
    )
{
	FX_ENTRY("DoClose");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	// Clean up streaming on main channel, including freeing all buffers
	if (hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
		UninitializeStreaming(hcd);

	// Stop streaming on the capture channel
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_STREAM_FINI, 0L, 0L);
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#else
		_SendDriverMessage((HDRVR)hcd->hvideoCapture, DVM_STREAM_FINI, 0L, 0L);
#endif

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif

		// Close the driver channels
		if (!_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0) ||
			!_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0))
		{
			SetLastError(ERROR_DCAP_NONSPECIFIC);
			ERRORMESSAGE(("%s: Couldn't close channel, error unknown\r\n", _fx_));
			// with delayed close this is catastrophic, we can't just return that the device is still
			// open, but we can't get the device to close either, so we'll have to just leave it in this
			// hung open state - hopefully this never happens...
		}
		hcd->hvideoCapture = NULL;
		hcd->hvideoIn = NULL;
#ifndef __NT_BUILD__
		// Free the LOCKEDINFO structure
		_FreeLockableBuffer(hcd->wselLockedInfo);
		hcd->wselLockedInfo = 0;
#endif
	}
	else
	{
		WDMCloseDevice(hcd->nDeviceIndex);
	}

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}

BOOL
DCAPI
CloseCaptureDevice(
    HCAPDEV hcd
    )
{
	FX_ENTRY("CloseCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;   // clear flag to disable other API's
    LEAVE_DCAP(hcd);                        // dec our enter count, if no other thread is in a DCAP
                                            // service, then this dec will go to 0 and we'll call
                                            // DoClose; else we won't call DoClose until the other
                                            // active service dec's the count to 0
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


DWORD
DCAPI
GetCaptureDeviceFormatHeaderSize(
    HCAPDEV hcd
    )
{
    DWORD res;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		res = _GetVideoFormatSize(reinterpret_cast<HDRVR>(hcd->hvideoIn));
	else
		res = WDMGetVideoFormatSize(hcd->nDeviceIndex);

    LEAVE_DCAP(hcd);

    return res;
}


BOOL
DCAPI
GetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDeviceFormat");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // Call the driver to get the bitmap information
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoFormat(hcd->hvideoIn, lpbmih);
	else
		fRes = WDMGetVideoFormat(hcd->nDeviceIndex, lpbmih);
	
    if (!fRes)
    {
        // This is DOOM if the driver doesn't support this.
        // It might be useful have some sort of fallback code here,
        // or else we should try this when the connection is made and
        // fail it unless this call works.
		ERRORMESSAGE(("%s: Failed to get video format\r\n", _fx_));
        SetLastError(ERROR_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

	if (lpbmih->biCompression == BI_RGB)
		lpbmih->biSizeImage = WIDTHBYTES(lpbmih->biWidth * lpbmih->biBitCount) * lpbmih->biHeight;

	// Keep track of current buffer size needed
	hcd->dwcbBuffers = sizeof(CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


BOOL
DCAPI
SetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih,
    LONG srcwidth,
    LONG srcheight
    )
{
	BOOL fRes;
#ifdef USE_VIDEO_OVERLAY
    RECT rect;
#endif

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // Don't allow this if streaming
    if (hcd->dwFlags & HCAPDEV_STREAMING)
    {
        SetLastError(ERROR_DCAP_NOT_WHILE_STREAMING);
        return FALSE;
    }
    ENTER_DCAP(hcd);

    // Call the driver to set the format
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		fRes = _SetVideoFormat(hcd->hvideoCapture, hcd->hvideoIn, lpbmih);
#ifdef USE_VIDEO_OVERLAY
		if (fRes && hcd->hvideoOverlay)
		{
			// Get the current rectangles
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay dst rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay src rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));

			// Set the rectangles
			rect.left = rect.top = 0;
			rect.right = (WORD)lpbmih->biWidth;
			rect.bottom = (WORD)lpbmih->biHeight;
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			if (hcd->hvideoOverlay)
				_InitializeExternalVideoStream(hcd->hvideoOverlay);
		}
#endif
	}
	else
		fRes = WDMSetVideoFormat(hcd->nDeviceIndex, lpbmih);

    if (!fRes)
    {
        SetLastError(ERROR_DCAP_FORMAT_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

    // Cache the bitmap size we're dealing with now
	if (lpbmih->biCompression == BI_RGB)
		hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biWidth * lpbmih->biHeight * lpbmih->biBitCount / 8;
	else
	    hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


//  GetCaptureDevicePalette
//      Gets the current palette from the capture device. The entries are returned to
//      the caller who normally calls CreatePalette on the structure. It may, however,
//      want to translate the palette entries into some preexisting palette or identity
//      palette before calling CreatePalette, hence the need for passing back the entries.

BOOL
DCAPI
GetCaptureDevicePalette(
    HCAPDEV hcd,
    CAPTUREPALETTE* lpcp
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDevicePalette");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // The caller doesn't have to initialize the structure.
    // The driver should fill it in, but it may want it preininitialized so we do that here.
    lpcp->wVersion = 0x0300;
    lpcp->wcEntries = 256;

    // Get the palette entries from the driver and return to the user
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoPalette(hcd->hvideoIn, lpcp, sizeof (CAPTUREPALETTE));
	else
		fRes = WDMGetVideoPalette(hcd->nDeviceIndex, lpcp, sizeof (CAPTUREPALETTE));

    if (!fRes)
	{
		ERRORMESSAGE(("%s: No palette returned from driver\r\n", _fx_));
		SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
		LEAVE_DCAP(hcd);
		return FALSE;
	}

    LEAVE_DCAP(hcd);
    return TRUE;
}


void
TerminateStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
	BOOL fRes;

	FX_ENTRY("TerminateStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    StopStreaming(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        hcd->dwFlags |= HCAPDEV_STREAMING_PAUSED;

        // Make sure we aren't streaming
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
#ifndef __NT_BUILD__
			hcd->lpli->dwFlags |= LIF_STOPSTREAM;
#endif
			_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_RESET, 0, 0);
		}
		else
			WDMVideoStreamReset(hcd->nDeviceIndex);

        dwTicks = GetTickCount();
        lpcbuf = hcd->lpcbufList;
        while (lpcbuf && GetTickCount() < dwTicks + 1000) {
            dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                if (WaitForSingleObject(hcd->hevWait, 500) == WAIT_TIMEOUT) {
					ERRORMESSAGE(("%s: Timeout waiting for all buffers done after DVM_STREAM_RESET\r\n", _fx_));
                    break;  // looks like it isn't going to happen, so quit waiting
                }
				//else recheck done bit on current buffer
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_DONE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
            }
            else
			{
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
                lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser;    // next buffer
			}
        }

		DEBUGMSG(ZONE_STREAMING, ("%s: Done trying to clear buffers\r\n", _fx_));

		// Clean up flags in order to reuse buffers - drivers do not like to be
		// given buffers with a dirty dwFlags at the start of streaming...
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser)
			lpcbuf->vh.dwFlags = 0;

        // Terminate streaming with the driver
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRes = _UninitializeVideoStream(hcd->hvideoIn);
		else
			fRes = WDMUnInitializeVideoStream(hcd->nDeviceIndex);

        if (!fRes)
		{
			ERRORMESSAGE(("%s: Error returned from XXXUninitializeVideoStream\r\n", _fx_));
		}
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}


BOOL
ReinitStreaming(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
	BOOL fRes;

	FX_ENTRY("ReinitStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        // Tell the driver to prepare for streaming. This sets up the callback

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
#ifdef __NT_BUILD__
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD)hcd);
#else
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD)hcd->wselLockedInfo << 16);
#endif
		else
			fRes = WDMInitializeVideoStream(hcd, hcd->nDeviceIndex, hcd->dw_usecperframe);

        if (!fRes)
        {
			ERRORMESSAGE(("%s: Error returned from XXXInitializeVideoStream\r\n", _fx_));
            SetLastError(ERROR_DCAP_BAD_FRAMERATE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
            return FALSE;
        }
//        Sleep (10);

        hcd->dwFlags &= ~HCAPDEV_STREAMING_PAUSED;

        // If any buffers are not marked DONE, then give them back to the driver; let all
        // DONE buffers get processed by the app first
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				{
					// AVICap32 sets the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_PREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags |= VHDR_PREPARED;
					fRes = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
				}
				else
					fRes = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

                if (!fRes)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Failed with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
					DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
                    return FALSE;
                }
				else
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Succeeded with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
                }
            }
        }
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return TRUE;
}


//  CaptureDeviceDialog
//      Puts up one of the driver's dialogs for the user to twiddle.
//      If I can figure out ANY way to avoid this, I will.

BOOL DCAPI
CaptureDeviceDialog(
    HCAPDEV hcd,
    HWND hwndParent,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbmih   //OPTIONAL
    )
{
    DWORD dwDriverFlags = 0;
    HVIDEO hvid;
    DWORD dwSize;
    LPBITMAPINFOHEADER lpbmihCur;
#ifdef _DEBUG
    LPBITMAPINFOHEADER lpbmihPre = NULL;
#endif
    BOOL res = TRUE;

	FX_ENTRY("CaptureDeviceDialog");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (hcd->dwFlags & HCAPDEV_IN_DRIVER_DIALOG)
        return FALSE;   // don't allow re-entering

    ENTER_DCAP(hcd);

    if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
			dwDriverFlags |= VIDEO_DLG_QUERY;

		// Select the correct channel to query
		if (dwFlags & CAPDEV_DIALOG_SOURCE) {
			hvid = hcd->hvideoCapture;
			if (!(dwFlags & CAPDEV_DIALOG_QUERY)) {
				dwDriverFlags |= VIDEO_DLG_QUERY;
				if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD)hwndParent, dwDriverFlags) == DV_ERR_NOTSUPPORTED) {
					hvid = hcd->hvideoIn;
				}
				dwDriverFlags &= ~VIDEO_DLG_QUERY;
			}
		}
		else
			hvid = hcd->hvideoIn;

		// Don't stop streaming. This make the source dialog totally useless
		// if the user can't see what is going on.

#ifdef _DEBUG
		if (!lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihPre = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihPre->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihPre);
			}
			lpbmih = lpbmihPre;
		}
#endif

		// Call the driver
		hcd->dwFlags |= HCAPDEV_IN_DRIVER_DIALOG;
		if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD)hwndParent, dwDriverFlags)) {
			SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
			res = FALSE;    // restart still ok
		}
		else if (lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihCur = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihCur->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihCur);
				if (lpbmih->biSize != lpbmihCur->biSize ||
					lpbmih->biWidth != lpbmihCur->biWidth ||
					lpbmih->biHeight != lpbmihCur->biHeight ||
					lpbmih->biBitCount != lpbmihCur->biBitCount ||
					lpbmih->biCompression != lpbmihCur->biCompression)
				{
					ERRORMESSAGE(("%s: Format changed in dialog!!\r\n", _fx_));
#ifdef _DEBUG
					DebugBreak();
#endif
					// dialog changed format, so try to set it back
					if (!SetCaptureDeviceFormat(hcd, lpbmih, 0, 0)) {
						SetLastError (ERROR_DCAP_DIALOG_FORMAT);
						res = FALSE;
					}
				}
				LocalFree ((HANDLE)lpbmihCur);
			}
#ifdef _DEBUG
			if (lpbmih == lpbmihPre) {
				LocalFree ((HANDLE)lpbmihPre);
				lpbmih = NULL;
				lpbmihPre = NULL;
			}
#endif
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		if (hcd->dwFlags & HCAPDEV_STREAMING) {
    		// The Intel Smart Video Recorder Pro stops streaming
			// on exit from the source dialog (!?!?). Make sure
    		// we reset the streaming on any kind of device right
			// after we exit the source dialog. I verified this on
    		// the CQC, ISVR Pro, Video Stinger and Video Blaster SE100.
			// They all seem to take this pretty well...
    		TerminateStreaming(hcd);
			if (ReinitStreaming(hcd))
				StartStreaming(hcd);
			else {
				SetLastError(ERROR_DCAP_DIALOG_STREAM);
				res = FALSE;
				ERRORMESSAGE(("%s: Couldn't reinit streaming after dialog!\r\n", _fx_));
			}
		}
	}
	else
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
		{
			// We only expose a settings dialog
			if (dwFlags & CAPDEV_DIALOG_IMAGE)
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}
		else
		{
			if (!WDMShowSettingsDialog(hcd->nDeviceIndex, hwndParent))
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		// No need to restart streaming on WDM devices tested so far
		// Will add this feature if problems come up
	}

    LEAVE_DCAP(hcd);
    return res;
}


//  InitializeStreaming
//      Allocates all memory and other objects necessary for streaming.

BOOL
DCAPI
InitializeStreaming(
    HCAPDEV hcd,
    CAPSTREAM* lpcs,
    DWORD flags
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwRound;
    LPBITMAPINFOHEADER lpbmih;
    BOOL bHaveBuffers = FALSE;

	FX_ENTRY("InitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // It doesn't make sense to stream with less than 2 buffers
    if (lpcs->ncCapBuffers < MIN_STREAMING_CAPTURE_BUFFERS ||
            flags & 0xfffffffe ||
            hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }
    ENTER_DCAP(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING | HCAPDEV_STREAMING_INITIALIZED |
                      HCAPDEV_STREAMING_FRAME_GRAB | HCAPDEV_STREAMING_FRAME_TIME | HCAPDEV_STREAMING_PAUSED);

    // Before allocating, make sure we have the current format.
    // This sets our idea of the current size we need for the buffer by
    // setting hcd->dwcbBuffers as a side effect
    dwRound = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwRound)) {
        lpbmih->biSize = dwRound;
        GetCaptureDeviceFormat(hcd, lpbmih);
        LocalFree ((HANDLE)lpbmih);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

// BUGBUG - add logic to determine if we should automatically use FRAME_GRAB mode

    // Try allocating the number asked for
    if (flags & STREAMING_PREFER_FRAME_GRAB) {
        hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_GRAB;
    }

    if (!allocateBuffers(hcd, lpcs->ncCapBuffers))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Create the event we need so we can signal at interrupt time
    if (!(hcd->hevWait = CreateEvent(NULL, FALSE, FALSE, NULL))) {
		ERRORMESSAGE(("%s: CreateEvent failed!\r\n", _fx_));
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Init CS used to serialize buffer list management
    InitializeCriticalSection(&hcd->bufferlistCS);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    hcd->dw_usecperframe = (unsigned)1000000000 / (unsigned)lpcs->nFPSx100;
    dwRound = hcd->dw_usecperframe % 10;  // Could have done with one less divide,
    hcd->dw_usecperframe /= 10;           // but this is clearer, and this is just
                                          // an init call...
    if (dwRound >= 5)
        hcd->dw_usecperframe++;

    hcd->lpCurrent = NULL;
    hcd->lpHead = NULL;
    hcd->lpTail = NULL;

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->pevWait = 0;
#endif

        // link the buffers into the available list
        // start with empty list
        hcd->lpHead = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR
        hcd->lpTail = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR

        // now insert the buffers
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
	        lpcbuf->lpPrev = hcd->lpTail;
	        hcd->lpTail = lpcbuf;
            lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	        lpcbuf->lpPrev->lpNext = lpcbuf;
	        lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    }
    }
	else
	{
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			hcd->lpli->pevWait = (DWORD)OpenVxDHandle(hcd->hevWait);

			// Lock down the LOCKEDINFO structure
			if (!_LockBuffer(hcd->wselLockedInfo))
			{
				SetLastError(ERROR_OUTOFMEMORY);
				goto Error;
			}
			hcd->lpli->lp1616Head = 0;
			hcd->lpli->lp1616Tail = 0;
			hcd->lpli->lp1616Current = 0;
		}
#endif

        if (!ReinitStreaming(hcd))
            goto Error;
    }
    lpcs->hevWait = hcd->hevWait;

    // Flag that streaming is initialized
    hcd->dwFlags |= HCAPDEV_STREAMING_INITIALIZED;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

Error:
    freeBuffers(hcd);
    if (hcd->hevWait)
    {
        CloseHandle(hcd->hevWait);
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && hcd->lpli->pevWait)
            _CloseVxDHandle(hcd->lpli->pevWait);
#endif
    }
    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return FALSE;
}


//  SetStreamFrameRate
//      Changes the frame rate of a stream initialized channel.
// PhilF-: This call is not used by NMCAP and NAC. So remove it or
// start using it.
BOOL
DCAPI
SetStreamFrameRate(
    HCAPDEV hcd,
    int nFPSx100
    )
{
    DWORD dwNew, dwRound;
    BOOL restart;
    BOOL res = TRUE;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED))
    {
        // must already have the channel initialized for streaming
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ENTER_DCAP(hcd);
    restart = (hcd->dwFlags & HCAPDEV_STREAMING);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    dwNew = (unsigned)1000000000 / (unsigned)nFPSx100;
    dwRound = dwNew % 10;           // Could have done with one less divide,
    dwNew /= 10;                    // but this is clearer, and this is just an init call...
    if (dwRound >= 5)
        dwNew++;

    if (dwNew != hcd->dw_usecperframe) {

        TerminateStreaming(hcd);

        hcd->dw_usecperframe = dwNew;

        res = ReinitStreaming(hcd);

        if (restart && res)
            StartStreaming(hcd);
    }
    LEAVE_DCAP(hcd);
    return res;
}


//  UninitializeStreaming
//      Frees all memory and objects associated with streaming.

BOOL
DCAPI
UninitializeStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("UninitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }

    ENTER_DCAP(hcd);

    TerminateStreaming(hcd);

#ifndef __NT_BUILD__
    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) && !(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
        // Unlock our locked structure
        _UnlockBuffer(hcd->wselLockedInfo);

        // Free the event
        _CloseVxDHandle(hcd->lpli->pevWait);
    }
#endif

    DeleteCriticalSection(&hcd->bufferlistCS);
    CloseHandle(hcd->hevWait);

    // BUGBUG - what about app still owning buffers
    // Loop through freeing all the buffers
    freeBuffers(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING_INITIALIZED + HCAPDEV_STREAMING_PAUSED);

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


void
CALLBACK
TimeCallback(
    UINT uID,	
    UINT uMsg,	
    HCAPDEV hcd,	
    DWORD dw1,	
    DWORD dw2	
    )
{
    hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_TIME;  // flag time for a new frame
    SetEvent (hcd->hevWait);    // signal client to initiate frame grab
}

//  StartStreaming
//      Begins streaming.

BOOL
DCAPI
StartStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;
	DWORD dwRet;

	FX_ENTRY("StartStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        fRet = ((hcd->timerID = timeSetEvent(hcd->dw_usecperframe/1000, 5,
                                    (LPTIMECALLBACK)&TimeCallback,
                                    (DWORD)hcd, TIME_PERIODIC)) != 0);
    } else {
        int i;

        fRet = FALSE;

#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->dwFlags &= ~LIF_STOPSTREAM;
#endif

        for (i = 0; i < 5; i++) {

			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			{
				dwRet = _SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_START, 0, 0);
				fRet = (dwRet == DV_ERR_OK);
				if (dwRet)
				{
					ERRORMESSAGE(("%s: DVM_STREAM_START failed, return code was %ld\r\n", _fx_, dwRet));
				}
			}
			else
				fRet = WDMVideoStreamStart(hcd->nDeviceIndex);

            if (fRet)
                break;
            else if (i > 1)
                Sleep(10);
        }
    }

    if (fRet)
        hcd->dwFlags |= HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  StopStreaming
//      Stops streaming but doesn't free any memory associated with streaming
//      so that it can be restarted with StartStreaming.

BOOL
DCAPI
StopStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;

	FX_ENTRY("StopStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        timeKillEvent(hcd->timerID);
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

        // grab CS to ensure that no frame grab is in progress
        EnterCriticalSection(&hcd->bufferlistCS);
        LeaveCriticalSection(&hcd->bufferlistCS);
        fRet = TRUE;
    }
	else
	{
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_STOP, 0, 0) == DV_ERR_OK);
		else
			fRet = WDMVideoStreamStop(hcd->nDeviceIndex);
	}

    if (fRet)
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  GetNextReadyBuffer
//      Called by the app to find the next buffer that has been marked as
//      done by the driver and has data to be displayed.

LPSTR
DCAPI
GetNextReadyBuffer(
    HCAPDEV hcd,
    CAPFRAMEINFO* lpcfi
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
	BOOL fRet;

	FX_ENTRY("GetNextReadyBuffer");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        lpcbuf = (LPCAPBUFFER)hcd->lpHead;
        if ((hcd->dwFlags & HCAPDEV_STREAMING_FRAME_TIME) &&
            (lpcbuf != (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR))))  /* fake CAPBUFFERHDR */
        {
            // remove buffer from list
            EnterCriticalSection(&hcd->bufferlistCS);
            hcd->dwFlags &= ~HCAPDEV_STREAMING_FRAME_TIME;
            lpcbuf->lpPrev->lpNext = lpcbuf->lpNext;
            lpcbuf->lpNext->lpPrev = lpcbuf->lpPrev;
            lpcbuf->vh.dwFlags &= ~VHDR_INQUEUE;
            lpcbuf->vh.dwFlags |= VHDR_DONE;
            LeaveCriticalSection(&hcd->bufferlistCS);
            dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				fRet = (SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
			else
				fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

            if (!fRet)
			{
                // put buffer back into list
                EnterCriticalSection(&hcd->bufferlistCS);
        	    lpcbuf->lpPrev = hcd->lpTail;
        	    hcd->lpTail = lpcbuf;
                lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
        	    lpcbuf->lpPrev->lpNext = lpcbuf;
           	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
                LeaveCriticalSection(&hcd->bufferlistCS);
                lpcbuf = NULL;
            }
        } else
            lpcbuf = NULL;

    } else {

#ifdef __NT_BUILD__
        // If the current pointer is NULL, there is no frame ready so bail
        if (!hcd->lpCurrent)
	        lpcbuf = NULL;
        else {
            // Get the linear address of the buffer
            lpcbuf = hcd->lpCurrent;

            // Move to the next ready buffer
            hcd->lpCurrent = lpcbuf->lpPrev;
        }
#else
        //--------------------
        // Buffer ready queue:
        // We maintain a doubly-linked list of our buffers so that we can buffer up
        // multiple ready frames when the app isn't ready to handle them. Two things
        // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
        // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
        // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
        // buffers get added to the list asynchronously.
        //
        // To handle this, the scheme implemented here is to have a double-linked list
        // of buffers with all insertions and deletions happening in FrameCallback
        // (interrupt time). This allows the GetNextReadyBuffer routine to simply
        // find the previous block on the list any time it needs a new buffer without
        // fear of getting tromped (as would be the case if it had to dequeue buffers).
        // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
        // is done with. Dequeueing is simple since we don't need to unlink the blocks:
        // no code ever walks the list! All we have to do is move the tail pointer back up
        // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
        // since all the list manipulation is on the 16-bit side AND because MapSL is
        // much more efficient and safer than MapLS since MapLS has to allocate selectors.
        //--------------------

        // If the current pointer is NULL, there is no frame ready so bail
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!hcd->lpli->lp1616Current)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = (LPCAPBUFFER)MapSL(hcd->lpli->lp1616Current);

				// Move to the next ready buffer
				hcd->lpli->lp1616Current = lpcbuf->lp1616Prev;
			}
		}
		else
		{
			// If the current pointer is NULL, there is no frame ready so bail
			if (!hcd->lpCurrent)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = hcd->lpCurrent;

				// Move to the next ready buffer
				hcd->lpCurrent = lpcbuf->lpPrev;
			}
		}
#endif

    }

    if (!lpcbuf) {
        lpcfi->lpData = NULL;
		DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Fails with lpcbuf=NULL\r\n", _fx_));
        LEAVE_DCAP(hcd);
        return NULL;
    }

    // Build the CAPFRAMEINFO from the VIDEOHDR information
    lpcfi->lpData = ((LPSTR)lpcbuf) + sizeof(CAPBUFFERHDR);
    lpcfi->dwcbData = lpcbuf->vh.dwBytesUsed;
    lpcfi->dwTimestamp = lpcbuf->vh.dwTimeCaptured;
    lpcfi->dwFlags = 0;
    lpcbuf->lpNext = NULL;

	DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  lpcbuf->vh.dwBufferLength=%ld\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, lpcbuf->vh.dwBufferLength));
	DEBUGMSG(ZONE_STREAMING, ("  lpcbuf->vh.dwBytesUsed=%ld\r\n  lpcbuf->vh.dwTimeCaptured=%ld\r\n  lpcbuf->vh.dwFlags=0x%08lX\r\n", lpcbuf->vh.dwBytesUsed, lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwFlags));

    LEAVE_DCAP(hcd);
    return lpcfi->lpData;
}


//  PutBufferIntoStream
//      When the app is finished using a buffer, it must allow it to be requeued
//      by calling this API.

BOOL
DCAPI
PutBufferIntoStream(
    HCAPDEV hcd,
    BYTE* lpBits
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwlpvh;
    BOOL res;

	FX_ENTRY("PutBufferIntoStream");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);
    // From the CAPFRAMEINFO, find the appropriate CAPBUFFER pointer
    lpcbuf = (LPCAPBUFFER)(lpBits - sizeof(CAPBUFFERHDR));

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Returning buffer lpcbuf=0x%08lX\r\n", _fx_, lpcbuf));

    lpcbuf->vh.dwFlags &= ~VHDR_DONE;   // mark that app no longer owns buffer
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        EnterCriticalSection(&hcd->bufferlistCS);
	    lpcbuf->lpPrev = hcd->lpTail;
	    hcd->lpTail = lpcbuf;
        lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	    lpcbuf->lpPrev->lpNext = lpcbuf;
	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    res = TRUE;
        LeaveCriticalSection(&hcd->bufferlistCS);
    }
    else if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
        // if streaming is paused, then just return with the busy bit cleared, we'll add the
        // buffer into the stream in ReinitStreaming
        //
        // if streaming isn't paused, then call the driver to add the buffer
        dwlpvh = (DWORD)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			res = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
		else
			res = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

		if (res)
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Failed with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}

    }

    LEAVE_DCAP(hcd);
    return res;
}


//  CaptureFrame
LPBYTE
DCAPI
CaptureFrame(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
    DWORD dwlpvh;
    LPBYTE lpbuf;
    BOOL fRet;

	FX_ENTRY("CaptureFrame");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    dwlpvh = (DWORD)hbuf->vh.lpData - sizeof(CAPBUFFERHDR);
	// 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
	// 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
	else
		fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

    if (!fRet)
	{
		ERRORMESSAGE(("%s: DVM_FRAME failed!\r\n", _fx_));
        lpbuf =  NULL;
    }
    else
        lpbuf = ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr

    LEAVE_DCAP(hcd);
    return lpbuf;
}


LPBYTE
DCAPI
GetFrameBufferPtr(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
        return ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr
    else
        return NULL;
}

HFRAMEBUF
DCAPI
AllocFrameBuffer(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER hbuf = NULL;
    DWORD dpBuf;

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
    if (dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)) {
        hbuf = (LPCAPBUFFER)dpBuf;
#else
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16;
        hbuf = (LPCAPBUFFER)MapSL(dpBuf);
	}
	else
	{
		dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers);
        hbuf = (LPCAPBUFFER)dpBuf;
	}

    if (dpBuf) {
#endif
        // Initialize the VIDEOHDR structure
        hbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        hbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        hbuf->vh.dwFlags = 0UL;
    }

    LEAVE_DCAP(hcd);
    return (HFRAMEBUF)hbuf;
}


VOID
DCAPI
FreeFrameBuffer(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
	{
        ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
		LocalFree((HANDLE)hbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			_FreeLockableBuffer(HIWORD((DWORD)hbuf->vh.lpData));
		else
			LocalFree((HANDLE)hbuf);
#endif

        LEAVE_DCAP(hcd);
    }
}

//=====================================================================
//  Helper functions

HVIDEO
openVideoChannel(
    DWORD dwDeviceID,
    DWORD dwFlags
    )
{
    HVIDEO hvidRet = NULL;
    VIDEO_OPEN_PARMS vop;
#ifdef __NT_BUILD__
    WCHAR devName[MAX_PATH];
#else
#define LPWSTR      LPSTR
#define devName     g_aCapDevices[dwDeviceID]->szDeviceName
#endif

	FX_ENTRY("openVideoChannel");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Validate parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }
    if (dwDeviceID > (DWORD)g_cDevices)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    // Prepare to call the driver
    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = 0;
    vop.dnDevNode = g_aCapDevices[dwDeviceID]->dwDevNode;

#ifdef __NT_BUILD__
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR)&(g_aCapDevices[dwDeviceID]->szDeviceName),
	-1, (LPWSTR)&devName, MAX_PATH);
#endif

    hvidRet = (HVIDEO)_OpenDriver((LPWSTR)&devName, NULL, (LONG)&vop);

#ifndef NO_DRIVER_HACKS
    if (!hvidRet) {
        // backward compatibility hack
        // Some drivers fail to open because of the extra fields that were added to
        // VIDEO_OPEN_PARAMS struct for Win95.  Therefore, if the open fails, try
        // decrementing the dwSize field back to VFW1.1 size and try again.  Also try
        // decrementing the API version field.

        vop.dwSize -= sizeof(DWORD) + sizeof(LPVOID)*2;
#if 0
        while (--vop.dwVersion > 2 && !hvidRet)
#endif
        while (--vop.dwVersion > 0 && !hvidRet)
            hvidRet = (HVIDEO)_OpenDriver((LPWSTR)&devName, NULL, (LONG)&vop);
    }
#endif //NO_DRIVER_HACKS

// BUGBUG [JonT] 31-Jul-96
// Translate error values from DV_ERR_* values
    if (!hvidRet)
        SetLastError(vop.dwError);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hvidRet;
}


//  allocateBuffers

BOOL
allocateBuffers(
    HCAPDEV hcd,
    int nBuffers
    )
{
    int i;
    LPCAPBUFFER lpcbuf;
    DWORD dpBuf;

	FX_ENTRY("allocateBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Try to allocate all they ask for
    for (i = 0 ; i < nBuffers ; i++)
    {

#ifdef __NT_BUILD__
        if (!(dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)))
            goto Error;
        else
			lpcbuf = (LPCAPBUFFER)dpBuf;
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!(dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16) || !_LockBuffer((WORD)(dpBuf >> 16)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)MapSL(dpBuf);
		}
		else
		{
			if (!(dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)dpBuf;
		}
#endif

        // Initialize the VIDEOHDR structure
        lpcbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        lpcbuf->vh.dwUser = (DWORD)hcd->lpcbufList;
        hcd->lpcbufList = lpcbuf;
        lpcbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        lpcbuf->vh.dwFlags = 0UL;
    }

#ifdef _DEBUG
	// Show buffer map
	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming Buffer map:\r\n", _fx_));
	DEBUGMSG(ZONE_STREAMING, ("Root: hcd->lpcbufList=0x%08lX\r\n", hcd->lpcbufList));
    for (i = 0, lpcbuf=hcd->lpcbufList ; i < nBuffers ; i++, lpcbuf=(LPCAPBUFFER)lpcbuf->vh.dwUser)
    {
		DEBUGMSG(ZONE_STREAMING, ("Buffer[%ld]: lpcbuf=0x%08lX\r\n             lpcbuf->vh.lpData=0x%08lX\r\n", i, lpcbuf, lpcbuf->vh.lpData));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwBufferLength=%ld\r\n             lpcbuf->vh.dwBytesUsed=%ld\r\n", lpcbuf->vh.dwBufferLength, lpcbuf->vh.dwBytesUsed));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwTimeCaptured=%ld\r\n             lpcbuf->vh.dwUser=0x%08lX\r\n", lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwUser));
	}	
#endif

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

    // In the error case, we have to get rid of this page locked memory
Error:
    freeBuffers(hcd);
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return FALSE;
}


//  freeBuffers

void
freeBuffers(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("freeBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    while (hcd->lpcbufList)
    {
        lpcbuf = hcd->lpcbufList;
        hcd->lpcbufList = (LPCAPBUFFER)lpcbuf->vh.dwUser;

#ifdef __NT_BUILD__
		LocalFree((HANDLE)lpcbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			_UnlockBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
			_FreeLockableBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
		}
		else
			LocalFree((HANDLE)lpcbuf);
#endif
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\precomp.h ===
// Precompiled header for DCAP32.DLL

// the build environment only defines _DEBUG when
// ALT_PROJECT_TARGET = NT is specified. Bug the debug zones only
// test for DEBUG...

#ifdef _DEBUG
#	ifndef DEBUG
#		define DEBUG
#	endif // !DEBUG
#endif // _DEBUG

#include <windows.h>
#include <confdbg.h>
#include <avutil.h>
#include <memtrack.h>
#include <winioctl.h>	// CTL_CODE, FILE_READ_ACCESS..etc
#include <commctrl.h>	// Page.cpp (UDM_GETRANGE, TBM_GETPOS) and Sheet.cpp (InitCommonControls)
#include <mmsystem.h>	// must go before mmddk.h
#include <mmddk.h>		// for DriverCallback()
#include <vfw.h>
#include <msviddrv.h>	// VIDEO_STREAM_INIT_PARMS
#include <strmif.h>
#include <uuids.h>
#include <ks.h>
#include <ksmedia.h>
#include <help_ids.h>
#include "..\inc\idcap.h"
#include "..\inc\WDMDrivr.h"
#include "..\inc\WDMPin.h"
#include "..\inc\WDMStrmr.h"
#include "..\inc\debug.h"
#include "..\inc\wdmcap.h"
#include "..\inc\resource.h"
#include "..\inc\WDMDialg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\makefile.inc ===
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 -Zi -coff $(ASM_FLAGS)

!IF "$(BUILD_ALT_DIR)" == "d"
C16_FLAGS = $(C16_FLAGS) -Zi -DDEBUG
ASM_FLAGS = $(ASM_FLAGS) -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(ASM_FLAGS)
<<NOKEEP

dcthk.asm: ..\thunks\dcthk.thk
     $(DEVROOT)\bin\misc\i386\thunk -t thk -o dcthk.asm ..\thunks\dcthk.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\wdmdialg.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.cpp | Source file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"

// Globals
extern HINSTANCE g_hInst;

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CWDMDialog | Create | This function creates a new
 *    page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CWDMDialog::Create()
{
    PROPSHEETPAGE psp;
    
    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = g_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(m_DlgID);
    psp.pfnDlgProc    = (DLGPROC)BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc BOOL | CWDMDialog | BaseDlgProc | This function implements
 *    the dialog box procedure for the page of a property sheet.
 *
 *  @parm HWND | hDlg | Handle to dialog box.
 *
 *  @parm UINT | uMessage | Message sent to the dialog box.
 *
 *  @parm WPARAM | wParam | First message parameter.
 *
 *  @parm LPARAM | lParam | Second message parameter.
 *
 *  @rdesc Except in response to the WM_INITDIALOG message, the dialog box
 *    procedure returns nonzero if it processes the message, and zero if it
 *    does not.
 ***************************************************************************/
BOOL CALLBACK CWDMDialog::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CWDMDialog * pSV = (CWDMDialog*)GetWindowLong(hDlg,DWL_USER);

	FX_ENTRY("CWDMDialog::BaseDlgProc");

    switch (uMessage)
    {
        case WM_HELP:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("conf.hlp"), HELP_WM_HELP, (DWORD)pSV->m_pdwHelp);
			break;

        case WM_CONTEXTMENU:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)wParam, TEXT("conf.hlp"), HELP_CONTEXTMENU, (DWORD)pSV->m_pdwHelp);
			break;

        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
				pSV=(CWDMDialog*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg,DWL_USER,(LPARAM)pSV);
				pSV->m_bInit = FALSE;
				pSV->m_bChanged = FALSE;
				return TRUE;
			}
			break;

        case WM_COMMAND:
            if (pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam), HIWORD(wParam));
                if (!iRet && pSV->m_bInit)
				{
					PropSheet_Changed(GetParent(pSV->m_hDlg), pSV->m_hDlg);
					pSV->m_bChanged = TRUE;
				}
                return iRet;
            }
			break;

        case WM_HSCROLL:
			if (pSV && pSV->m_pCWDMPin && pSV->m_pPC)
			{
				HWND hwndControl = (HWND) lParam;
				HWND hwndSlider;
				ULONG i;
				TCHAR szTemp[32];
    
				for (i = 0 ; i < pSV->m_dwNumControls ; i++)
				{
					hwndSlider = GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider);

					// find matching slider
					if (hwndSlider == hwndControl)
					{
						LONG lValue = (LONG)SendMessage(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider), TBM_GETPOS, 0, 0);
						pSV->m_pCWDMPin->SetPropertyValue(pSV->m_guidPropertySet, pSV->m_pPC[i].uiProperty, lValue, KSPROPERTY_FLAGS_MANUAL, pSV->m_pPC[i].ulCapabilities);
						pSV->m_pPC[i].lCurrentValue = lValue;
						wsprintf(szTemp,"%d", lValue);
						SetWindowText(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiCurrent), szTemp);
						break;
					}
				}
			}

			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->SetActive();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						// Since we apply the changes on the fly when the user moves the slide bars,
						// there isn't much left to do on PSN_APPLY...
						if (pSV->m_bChanged)
							pSV->m_bChanged = FALSE;
						return FALSE;
						break;

					case PSN_QUERYCANCEL:    
						return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc void | CWDMDialog | CWDMDialog | Property page class constructor.
 *
 *  @parm int | DlgId | Resource ID of the property page dialog.
 *
 *  @parm DWORD | dwNumControls | Number of controls to display in the page.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are showing in
 *    the property page.
 *
 *  @parm PPROPSLIDECONTROL | pPC | Pointer to the list of slider controls
 *    to be displayed in the property page.
 *
 *  @parm PDWORD | pdwHelp | Pointer to the list of help IDs to be displayed
 *    in the property page.
 *
 *  @parm CWDMPin * | pCWDMPin | Pointer to the kernel streaming object
 *    we will query the property on.
 ***************************************************************************/
CWDMDialog::CWDMDialog(int DlgId, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, PDWORD pdwHelp, CWDMPin *pCWDMPin)
{
	FX_ENTRY("CWDMDialog::CWDMDialog");

	ASSERT(dwNumControls);
	ASSERT(pPC);

	m_DlgID = DlgId;
	m_pdwHelp = pdwHelp;
	m_pCWDMPin = pCWDMPin;
	m_dwNumControls = dwNumControls;
	m_guidPropertySet = guidPropertySet;
	m_pPC = pPC;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | SetActive | This function handles
 *    PSN_SETACTIVE by intializing all the property page controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::SetActive()
{
	FX_ENTRY("CWDMDialog::SetActive");

    DEBUGMSG(ZONE_DIALOGS, ("%s()\n", _fx_));

    if (!m_pCWDMPin || !m_pPC) 
        return 0;

    // Returns zero to accept the activation or
    // -1 to activate the next or previous page 
    // (depending on whether the user chose the Next or Back button)
    LONG i;
    EnableWindow(m_hDlg, TRUE);

    if (m_bInit) 
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplay[256];

    for (i = j = 0 ; i < (LONG)m_dwNumControls; i++)
	{
        // Get the current value
        if (m_pCWDMPin->GetPropertyValue(m_guidPropertySet, m_pPC[i].uiProperty, &lValue, &ulFlags, &ulCapabilities))
		{
            LoadString(g_hInst, m_pPC[i].uiString, szDisplay, sizeof(szDisplay));
            DEBUGMSG(ZONE_DIALOGS, ("%s: szDisplay = %s\n", _fx_, szDisplay));
            SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), szDisplay);

            // Get the Range of Values possible.
            if (m_pCWDMPin->GetRangeValues(m_guidPropertySet, m_pPC[i].uiProperty, &lMin, &lMax, &lStep)) 
			{
				HWND hTB = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

				DEBUGMSG(ZONE_DIALOGS, ("(%d, %d) / %d = %d \n", lMin, lMax, lStep, (lMax-lMin)/lStep));

				SendMessage(hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0);
				SendMessage(hTB, TBM_SETRANGE, 0, MAKELONG(lMin, lMax));
			}
            else
			{
                ERRORMESSAGE(("%s:Cannot get range values for this property ID = %d\n", _fx_, m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), TRUE);

			SendMessage(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TBM_SETPOS, TRUE, lValue);
			wsprintf(szDisplay,"%d", lValue);
			SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szDisplay);

            DEBUGMSG(ZONE_DIALOGS, ("%s: Capability = 0x%08lX; Flags=0x%08lX; lValue=%d\r\n", _fx_, ulCapabilities, ulFlags, lValue));
            DEBUGMSG(ZONE_DIALOGS, ("%s: switch(%d): \n", _fx_, ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO))
			{
				case KSPROPERTY_FLAGS_MANUAL:            
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto
					break;

				case KSPROPERTY_FLAGS_AUTO:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; 
					// always auto!
					SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;

				case (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO):
					// Set flags
					if (ulFlags & KSPROPERTY_FLAGS_AUTO)
					{
						DEBUGMSG(ZONE_DIALOGS, ("%s: Auto (checked) and slider disabled\n", _fx_));
						// Set auto check box; greyed out slider
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
					}
					else
					{
						// Unchecked auto; enable slider                    
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
					}
					break;

				case 0:
				default:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;
            }

            j++;

        }
		else
		{                
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);
        }            
    }
        
    // Disable the "default" push button; 
    // or inform user that no control is enabled.
    if (j == 0)
        EnableWindow(GetDlgItem(m_hDlg, IDC_DEFAULT), FALSE);

    return 0;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | DoCommand | This function handles WM_COMMAND. This
 *    is where a click on the Default button or one of the Auto checkboxes
 *    is handled
 *
 *  @parm WORD | wCmdID | Command ID.
 *
 *  @parm WORD | hHow | Notification code.
 *
 *  @rdesc Always returns 1.
 ***************************************************************************/
int CWDMDialog::DoCommand(WORD wCmdID, WORD hHow)
{
    // If a user select default settings of the video format
    if (wCmdID == IDC_DEFAULT)
	{
        if (m_pCWDMPin && m_pPC)
		{
            HWND hwndSlider;
            LONG  lDefValue;
			TCHAR szTemp[32];

            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                hwndSlider = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider))
				{
                    if (m_pCWDMPin->GetDefaultValue(m_guidPropertySet, m_pPC[i].uiProperty, &lDefValue))
					{
                        if (lDefValue != m_pPC[i].lCurrentValue)
						{
                            m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
							SendMessage(hwndSlider, TBM_SETPOS, TRUE, lDefValue);
							wsprintf(szTemp,"%d", lDefValue);
							SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szTemp);
							m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 1;
    }
	else if (hHow == BN_CLICKED)
	{
        if (m_pCWDMPin && m_pPC)
		{
            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID)
				{
                    if (BST_CHECKED == SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_GETCHECK, 1, 0))
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                    }
					else
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                    }    
                    break;
                }
            }
        }
    }

    return 1;    
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | QueryCancel | This function handles
 *    PSN_QUERYCANCEL by resetting the values of the controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::QueryCancel()
{
    if (m_pCWDMPin && m_pPC)
	{
        for (ULONG i = 0 ; i < m_dwNumControls ; i++)
		{
            if (IsWindowEnabled(GetDlgItem(m_hDlg, m_pPC[i].uiSlider)))
			{
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue) 
                    m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\debug.cpp ===
#include "Precomp.h"

#ifdef _DEBUG

HDBGZONE  ghDbgZoneCap = NULL;

int WINAPI CapDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("DCAP", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\wdmstrmr.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMStrmr.cpp | Source file for <c CWDMStreamer> class used to get a
 *    stream of video data flowing from WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | CWDMStreamer | WDM filter class constructor.
 *
 *  @parm CWDMPin * | pWDMVideoPin | Pointer to the kernel streaming
 *    object we will get the frames from.
 ***************************************************************************/
CWDMStreamer::CWDMStreamer(CWDMPin * pWDMVideoPin)
{
	m_pWDMVideoPin = pWDMVideoPin;
	m_lpVHdrFirst = (LPVIDEOHDR)NULL;
	m_lpVHdrLast = (LPVIDEOHDR)NULL;
	m_fVideoOpen = FALSE;
	m_fStreamingStarted = FALSE;
	m_pBufTable = (PBUFSTRUCT)NULL;
	m_cntNumVidBuf = 0UL;
	m_idxNextVHdr = 0UL;
    m_hThread = NULL;
	m_bKillThread = FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | videoCallback | This function calls the
 *    callback function provided by the appplication.
 *
 *  @parm WORD | msg | Message value.
 *
 *  @parm DWORD | dwParam1 | 32-bit message-dependent parameter.
 ***************************************************************************/
void CWDMStreamer::videoCallback(WORD msg, DWORD dwParam1)
{
    if (m_CaptureStreamParms.dwCallback)
        DriverCallback (m_CaptureStreamParms.dwCallback, HIWORD(m_CaptureStreamParms.dwFlags), (HDRVR) m_CaptureStreamParms.hVideo, msg, m_CaptureStreamParms.dwCallbackInst, dwParam1, 0UL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc LPVIDEOHDR | CWDMStreamer | DeQueueHeader | This function dequeues a
 *    video buffer from the list of video buffers used for streaming.
 *
 *  @rdesc Returns a valid pointer if successful, or NULL otherwise.
 ***************************************************************************/
LPVIDEOHDR CWDMStreamer::DeQueueHeader()
{
	FX_ENTRY("CWDMStreamer::DeQueueHeader");

    LPVIDEOHDR lpVHdr;

    if (m_pBufTable)
	{
        if (m_pBufTable[m_idxNextVHdr].fReady)
		{
			DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

            lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
            lpVHdr->dwFlags &= ~VHDR_INQUEUE;
            m_pBufTable[m_idxNextVHdr].fReady = FALSE;
        }
		else
		{
            m_idxNextVHdr++;
            if (m_idxNextVHdr >= m_cntNumVidBuf)
                m_idxNextVHdr = 0;

			if (m_pBufTable[m_idxNextVHdr].fReady)
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

				lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
				lpVHdr->dwFlags &= ~VHDR_INQUEUE;
				m_pBufTable[m_idxNextVHdr].fReady = FALSE;
			}
			else
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: idxNextVHdr (idx=%d) has not been returned by client\r\n", _fx_, m_idxNextVHdr));
				lpVHdr = NULL;
			}
		}
    }
	else
	{
        lpVHdr = m_lpVHdrFirst;

        if (lpVHdr) {

            lpVHdr->dwFlags &= ~VHDR_INQUEUE;

            m_lpVHdrFirst = (LPVIDEOHDR)(lpVHdr->dwReserved[0]);
        
            if (m_lpVHdrFirst == NULL)
                m_lpVHdrLast = NULL;                            
        }
    }

    return lpVHdr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | QueueHeader | This function actually adds the
 *    video buffer to the list of video buffers used for streaming.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 ***************************************************************************/
void CWDMStreamer::QueueHeader(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::QueHeader");

	// Initialize status flags
    lpVHdr->dwFlags &= ~VHDR_DONE;
    lpVHdr->dwFlags |= VHDR_INQUEUE;
    lpVHdr->dwBytesUsed = 0;

    // Add buffer to list
    if (m_pBufTable)
	{
		if (lpVHdr->dwReserved[1] < m_cntNumVidBuf)
		{
			if (m_pBufTable[lpVHdr->dwReserved[1]].lpVHdr != lpVHdr)
			{
				DEBUGMSG(ZONE_STREAMING, ("        %s: index (%d) Match but lpVHdr does not(%x)\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
			}
			m_pBufTable[lpVHdr->dwReserved[1]].fReady = TRUE;
			DEBUGMSG(ZONE_STREAMING, ("        %s: Buffer lpVHdr=0x%08lX was succesfully queued\r\n", _fx_, lpVHdr));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("        %s: lpVHdr->dwReserved[1](%d) >= m_cntNumVidBuf (%d)\r\n", _fx_, lpVHdr->dwReserved[1], m_cntNumVidBuf));
		}
	}
	else
	{
		*(lpVHdr->dwReserved) = NULL;

		if (m_lpVHdrLast)
			*(m_lpVHdrLast->dwReserved) = (DWORD)(LPVOID)lpVHdr;
		else
			m_lpVHdrFirst = lpVHdr;

		m_lpVHdrLast = lpVHdr;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | AddBuffer | This function adds a buffer to the
 *    list of video buffers to be used when streaming video data from the WDM
 *    device.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_ADDBUFFER message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::AddBuffer(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::AddBuffer");

	ASSERT(m_fVideoOpen && lpVHdr && !(lpVHdr->dwFlags & VHDR_INQUEUE));

	// Make sure this is a valid call
    if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because m_fVideoOpen=FALSE\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!lpVHdr)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because lpVHdr=NULL\r\n", _fx_, lpVHdr));
		return FALSE;
	}

    if (lpVHdr->dwFlags & VHDR_INQUEUE)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because buffer is already queued\r\n", _fx_, lpVHdr));
		return FALSE;
	}

	// Does the size of the buffer match the size of the buffers the streaming pin will generate?
    if (lpVHdr->dwBufferLength < m_pWDMVideoPin->GetFrameSize())
	{
		ERRORMESSAGE(("%s: Buffer lpVHdr=0x%08lX can't be queued because the length of that buffer is too small\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!m_pBufTable)
	{
        lpVHdr->dwReserved[1] = m_cntNumVidBuf;
        m_cntNumVidBuf++;
		DEBUGMSG(ZONE_STREAMING, ("%s: Queue buffer (%d) lpVHdr=0x%08lX\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
    }

    QueueHeader(lpVHdr);

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stop | This function stops a stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_STOP message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Stop()
{
	FX_ENTRY("CWDMStreamer::Stop");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Reset data members - stop streaming thread
    m_fStreamingStarted = FALSE;

    if (m_hThread)
    {

		DEBUGMSG(ZONE_STREAMING, ("%s: Stopping the thread\r\n", _fx_));

        // Signal the streaming thread to stop
		m_bKillThread = TRUE;

        // wait until thread has self-terminated, and clear the event.
		DEBUGMSG(ZONE_STREAMING, ("%s: WaitingForSingleObject...\r\n", _fx_));

        WaitForSingleObject(m_hThread, INFINITE);

		DEBUGMSG(ZONE_STREAMING, ("%s: ...thread stopped\r\n", _fx_));

		// Close the thread handle
		CloseHandle(m_hThread);
		m_hThread = NULL;

		// Ask the pin to stop streaming.
		m_pWDMVideoPin->Stop();

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
			{
				SetEvent(m_pWDMVideoBuff[i].Overlap.hEvent);
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
				m_pWDMVideoBuff[i].Overlap.hEvent = NULL;
			}
		}

		if (m_pWDMVideoBuff)
		{
			delete []m_pWDMVideoBuff;
			m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;
		}

    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Reset | This function resets a stream of
 *    video data coming from the WDM device so that prepared buffer may be
 *    freed correctly.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_RESET message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Reset()
{
	LPVIDEOHDR lpVHdr;

	FX_ENTRY("CWDMStreamer::Reset");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
    Stop();

	// Return all buffers to the application one last time
	while (lpVHdr = DeQueueHeader ())
	{
		lpVHdr->dwFlags |= VHDR_DONE;
		videoCallback(MM_DRVM_DATA, (DWORD) lpVHdr);
	}

	// Reset data members
    m_lpVHdrFirst = (LPVIDEOHDR)NULL;
    m_lpVHdrLast = (LPVIDEOHDR)NULL;
    if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Open | This function opens a stream of
 *    video data coming from the WDM device.
 *
 *  @parm LPVIDEO_STREAM_INIT_PARMS | lpStreamInitParms | Pointer to
 *    initialization data.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_INIT message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Open(LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms)
{
	FX_ENTRY("CWDMStreamer::Open");

	ASSERT(!m_fVideoOpen);

	// Make sure this is a valid call
	if (m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is already opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Initialize data memmbers
	m_CaptureStreamParms	= *lpStreamInitParms;
	m_fVideoOpen			= TRUE;
	m_lpVHdrFirst			= (LPVIDEOHDR)NULL;
	m_lpVHdrLast			= (LPVIDEOHDR)NULL;
	m_cntNumVidBuf			= 0UL;

	// Set frame rate on the pin
	m_pWDMVideoPin->SetAverageTimePerFrame(lpStreamInitParms->dwMicroSecPerFrame * 10);

	// Let the app know we just opened a stream
	videoCallback(MM_DRVM_OPEN, 0L);

	if (lpStreamInitParms->dwMicroSecPerFrame != 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Capturing at %d frames/sec\r\n", _fx_, 100000 / lpStreamInitParms->dwMicroSecPerFrame));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Close | This function closes the stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_FINI message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Close()
{
	FX_ENTRY("CWDMStreamer::Close");

	ASSERT(m_fVideoOpen && !m_lpVHdrFirst);

	// Make sure this is a valid call
	if (!m_fVideoOpen || m_lpVHdrFirst)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
	Stop();

	// Reset data members
	m_fVideoOpen = FALSE;   
	m_lpVHdrFirst = m_lpVHdrLast = (LPVIDEOHDR)NULL; 
	m_idxNextVHdr = 0UL;

	// Release table of pointers to video buffers
	if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
	}

	// Let the app know that we just closed the stream
	videoCallback(MM_DRVM_CLOSE, 0L);

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | BufferDone | This function lets the application
 *    know that there is video data available coming from the WDM device.
 *
 *  @devnote This method is called by the kernel streaming object (Pin)
 ***************************************************************************/
void CWDMStreamer::BufferDone(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::BufferDone");

	// Make sure this is a valid call
	if (!m_fStreamingStarted)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Video has not been started or just been stopped\r\n", _fx_));
		return;
	}

    if (lpVHdr == NULL)
	{
		// No buffers available - the app hasn't returned the buffers to us yet
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that we don't have any buffers anymore since lpVHdr=NULL\r\n", _fx_));

		// Let the app know something wrong happened
        videoCallback(MM_DRVM_ERROR, 0UL);
        return;
    }

    lpVHdr->dwFlags |= VHDR_DONE;

	// Sanity check
    if (lpVHdr->dwBytesUsed == 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is no valid data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

		// Return frame to the pool before notifying app
		AddBuffer(lpVHdr);
        videoCallback(MM_DRVM_ERROR, 0UL);
    }
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

        lpVHdr->dwTimeCaptured = timeGetTime() - m_dwTimeStart;

		// Let the app know there's some valid video data available
        videoCallback(MM_DRVM_DATA, (DWORD)lpVHdr);
    }
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Start | This function starts streaming
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_START message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Start()
{
	FX_ENTRY("CWDMStreamer::Start");

    ULONG i;
    LPVIDEOHDR lpVHdr;
	DWORD dwThreadID;

	ASSERT(m_fVideoOpen && m_pWDMVideoPin->GetAverageTimePerFrame() && !m_hThread);

	// Make sure this is a valid call
	if (!m_fVideoOpen || !m_pWDMVideoPin->GetAverageTimePerFrame() || m_hThread)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming in %d video buffers at %d frames/sec\r\n", _fx_, m_cntNumVidBuf, 1000000 / m_pWDMVideoPin->GetAverageTimePerFrame()));

	// Allocate and initialize the video buffer structures
    m_pBufTable = (PBUFSTRUCT) new BUFSTRUCT[m_cntNumVidBuf];
    if (m_pBufTable)
	{
		lpVHdr = m_lpVHdrFirst;
		for (i = 0; i < m_cntNumVidBuf && lpVHdr; i++)
		{
			m_pBufTable[i].fReady = TRUE;
			m_pBufTable[i].lpVHdr = lpVHdr;
			lpVHdr = (LPVIDEOHDR) lpVHdr->dwReserved[0];
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_pBufTable allocation failed! AsynIO may be out of sequence\r\n", _fx_));
	}

    m_idxNextVHdr		= 0UL;  // 0..m_cntNumVidBuf-1
    m_dwTimeStart		= timeGetTime();
    m_fStreamingStarted	= TRUE;
	m_bKillThread = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("%s: Creating %d read video buffers\r\n", _fx_, m_cntNumVidBuf));

	if (!(m_pWDMVideoBuff = (WDMVIDEOBUFF *) new WDMVIDEOBUFF[m_cntNumVidBuf]))
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_Overlap allocation failed!\r\n", _fx_));
		return FALSE;
	}

	for(i=0; i<m_cntNumVidBuf; i++)
	{
		// Create the overlapped structures
		ZeroMemory( &(m_pWDMVideoBuff[i].Overlap), sizeof(OVERLAPPED) );
		m_pWDMVideoBuff[i].Overlap.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

		DEBUGMSG(ZONE_STREAMING, ("%s: Event %d is handle 0x%08lX\r\n", _fx_, i, m_pWDMVideoBuff[i].Overlap.hEvent));
	}

	m_dwNextToComplete=0;

    // Create the streaming thread
    m_hThread = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)ThreadStub,
                                this,
                                CREATE_SUSPENDED, 
                                &dwThreadID);

    if (m_hThread == NULL) 
    {
		ERRORMESSAGE(("%s: Couldn't create the thread\r\n", _fx_));

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
		}

		delete []m_pWDMVideoBuff;
		m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;

		m_lpVHdrFirst = (LPVIDEOHDR)NULL;
		m_lpVHdrLast = (LPVIDEOHDR)NULL;
		if (m_pBufTable)
		{
			delete []m_pBufTable;
			m_pBufTable = NULL;
		}

        return FALSE;
    }

    SetThreadPriority(m_hThread, THREAD_PRIORITY_ABOVE_NORMAL);

    ResumeThread(m_hThread);

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread created OK\r\n", _fx_));

    return TRUE;

}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stream | This function does the actual
 *    streaming.
 ***************************************************************************/
void CWDMStreamer::Stream()
{
	FX_ENTRY("CWDMStreamer::Stream");

	DEBUGMSG(ZONE_STREAMING, ("%s: Starting to process StreamingThread\r\n", _fx_));

	// Put the pin in streaming mode
	m_pWDMVideoPin->Start();

	// Queue all the reads
	for (UINT i = 0; i<m_cntNumVidBuf; i++)
	{
		QueueRead(i);
	}

	m_dwNextToComplete=0;
#ifdef _DEBUG
	m_dwFrameCount=0;
#endif
	BOOL  bGotAFrame=FALSE;
	DWORD dwRes;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Starting to wait on reads to complete\r\n", _fx_));

	while (!m_bKillThread)
	{
		bGotAFrame = FALSE;

		if (m_pWDMVideoBuff[m_dwNextToComplete].fBlocking)
		{
			DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Waiting on read to complete...\r\n", _fx_));

			// Waiting for the asynchronous read to complete
			dwRes = WaitForSingleObject(m_pWDMVideoBuff[m_dwNextToComplete].Overlap.hEvent, 1000*1);

			if (dwRes == WAIT_FAILED)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...we couldn't perform the wait as requested\r\n", _fx_));
			}

			if (dwRes == WAIT_OBJECT_0)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...wait is over - we now have a frame\r\n", _fx_));
				bGotAFrame = TRUE;
			}
			else
			{
				// time out waiting for frames.
				if (dwRes == WAIT_TIMEOUT)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Waiting failed with timeout, last error=%d\r\n", _fx_, GetLastError()));
				}
			}
		}
		else
		{
			// We didn't have to wait - this means the read executed synchronously
			bGotAFrame = TRUE;
		}

		if (bGotAFrame)
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Trying to give frame #%ld to the client\r\n", _fx_, m_dwFrameCount++));

			LPVIDEOHDR lpVHdr;

			lpVHdr = m_pWDMVideoBuff[m_dwNextToComplete].pVideoHdr;

			if (lpVHdr)
			{
				lpVHdr->dwBytesUsed = m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.StreamHeader.DataUsed;

				if ((m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.FrameInfo.dwFrameFlags & 0x00f0) == KS_VIDEO_FLAG_I_FRAME) 
					lpVHdr->dwFlags |= VHDR_KEYFRAME;
			}

			// Mark the buffer as done - signal the app
			BufferDone(lpVHdr);

			// Queue a new read
			QueueRead(m_dwNextToComplete);
		}

		m_dwNextToComplete++;
		m_dwNextToComplete %= m_cntNumVidBuf;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: End of the streaming thread\r\n", _fx_));

	ExitThread(0);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | QueueRead | This function queues a read
 *    operation on a video streaming pin.
 *
 *  @parm DWORD | dwIndex | Index of the video structure in read buffer.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMStreamer::QueueRead(DWORD dwIndex)
{
	FX_ENTRY("CWDMStreamer::QueueRead");

	DWORD cbReturned;
	BOOL  bShouldBlock = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Queue read buffer %d on pin handle 0x%08lX\r\n", _fx_, dwIndex, m_pWDMVideoPin->GetPinHandle()));

	// Get a buffer from the queue of video buffers
	m_pWDMVideoBuff[dwIndex].pVideoHdr = DeQueueHeader();

	if (m_pWDMVideoBuff[dwIndex].pVideoHdr)
	{
		ZeroMemory(&m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage));
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Size				= sizeof (KS_HEADER_AND_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.FrameInfo.ExtendedHeaderSize	= sizeof (KS_FRAME_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Data				= m_pWDMVideoBuff[dwIndex].pVideoHdr->lpData;
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.FrameExtent		= m_pWDMVideoPin->GetFrameSize();

		// Submit the read
		BOOL bRet = DeviceIoControl(m_pWDMVideoPin->GetPinHandle(), IOCTL_KS_READ_STREAM, &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &cbReturned, &m_pWDMVideoBuff[dwIndex].Overlap);

		if (!bRet)
		{
			DWORD dwErr = GetLastError();
			switch(dwErr)
			{
				case ERROR_IO_PENDING:
					DEBUGMSG(ZONE_STREAMING, ("%s: An overlapped IO is going to take place\r\n", _fx_));
					bShouldBlock = TRUE;
					break;

				// Something bad happened
				default:
					DEBUGMSG(ZONE_STREAMING, ("%s: DeviceIoControl() failed badly dwErr=%d\r\n", _fx_, dwErr));
					break;
			}
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Overlapped IO won't take place - no need to wait\r\n", _fx_));
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: We won't queue the read - no buffer available\r\n", _fx_));
	}

	m_pWDMVideoBuff[dwIndex].fBlocking = bShouldBlock;

	return bShouldBlock;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | ThreadStub | Thread stub.
 ***************************************************************************/
LPTHREAD_START_ROUTINE CWDMStreamer::ThreadStub(CWDMStreamer *pCWDMStreamer)
{
	FX_ENTRY("CWDMStreamer::ThreadStub");

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread stub called, starting streaming...\r\n", _fx_));

    pCWDMStreamer->Stream();

	DEBUGMSG(ZONE_STREAMING, ("%s: ...capture thread has stopped\r\n", _fx_));

    return(0);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\wdmdrivr.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMDRIVER
 *
 *  @module WDMDrivr.cpp | Include file for <c CWDMDriver> class used to
 *    access the streaming class driver using IOctls.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | CWDMDriver | Driver class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMDriver::CWDMDriver(DWORD dwDeviceID) 
{
	m_hDriver = (HANDLE)NULL;
	m_pDataRanges = (PDATA_RANGES)NULL;

	m_dwDeviceID = dwDeviceID;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | ~CWDMDriver | Driver class destructor. Closes
 *    the driver file handle and releases the video data range memory.
 ***************************************************************************/
CWDMDriver::~CWDMDriver()
{
	if (m_hDriver) 
		CloseDriver();

	if (m_pDataRanges)
	{
		delete [] m_pDataRanges;
		m_pDataRanges = (PDATA_RANGES)NULL;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CreateDriverSupportedDataRanges | This
 *    function builds the list of video data ranges supported by the capture
 *    device.
 *
 *  @rdesc Returns the number of valid data ranges in the list.
 ***************************************************************************/
DWORD CWDMDriver::CreateDriverSupportedDataRanges()
{
	FX_ENTRY("CWDMDriver::CreateDriverSupportedDataRanges");

	DWORD cbReturned;
	DWORD dwSize = 0UL;

	// Initialize property structure to get data ranges
	KSP_PIN KsProperty = {0};

	KsProperty.PinId			= 0; // m_iPinNumber;
	KsProperty.Property.Set		= KSPROPSETID_Pin;
	KsProperty.Property.Id		= KSPROPERTY_PIN_DATARANGES ;
	KsProperty.Property.Flags	= KSPROPERTY_TYPE_GET;

	// Get the size of the data range structure
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
	{
		ERRORMESSAGE(("%s: Couldn't get the size for the data ranges\r\n", _fx_));
		return 0UL;
	}

	DEBUGMSG(ZONE_INIT, ("%s: GetData ranges needs %d bytes\r\n", _fx_, dwSize));

	// Allocate memory to hold data ranges
	if (m_pDataRanges)
		delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES) new BYTE[dwSize];

	if (!m_pDataRanges)
	{
		ERRORMESSAGE(("%s: Couldn't allocate memory for the data ranges\r\n", _fx_));
		return 0UL;
	}

	// Really get the data ranges
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), m_pDataRanges, dwSize, &cbReturned) == 0)
	{
		ERRORMESSAGE(("%s: Problem getting the data ranges themselves\r\n", _fx_));
		goto MyError1;
	}

	// Sanity check
	if (cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0)
	{
		ERRORMESSAGE(("%s: cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0\r\n", _fx_));
		goto MyError1;
	}

	return m_pDataRanges->Count;

MyError1:
	delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES)NULL;
	return 0UL;

}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | OpenDriver | This function opens a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::OpenDriver()
{
	FX_ENTRY("CWDMDriver::OpenDriver");

	// Don't re-open the driver
	if (m_hDriver)
	{
		DEBUGMSG(ZONE_INIT, ("%s: Class driver already opened\r\n", _fx_));
		return TRUE;
	}

	// Validate driver path
	if (lstrlen(g_aCapDevices[m_dwDeviceID]->szDeviceName) == 0)
	{
		ERRORMESSAGE(("%s: Invalid driver path\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Opening class driver '%s'\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName));

	// All we care is to wet the hInheritHanle = TRUE;
	SECURITY_ATTRIBUTES SecurityAttributes;
	SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);  // use pointers
	SecurityAttributes.bInheritHandle = TRUE;
	SecurityAttributes.lpSecurityDescriptor = NULL; // GetInitializedSecurityDescriptor();

	// Really open the driver
	if ((m_hDriver = CreateFile(g_aCapDevices[m_dwDeviceID]->szDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &SecurityAttributes, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) == INVALID_HANDLE_VALUE)
	{
		ERRORMESSAGE(("%s: CreateFile failed with Path=%s GetLastError()=%d\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName, GetLastError()));
		m_hDriver = (HANDLE)NULL;
		return FALSE;
	}

	// If there is no valid data range, we cannot stream
	if (!CreateDriverSupportedDataRanges())
	{
		CloseDriver();
		return FALSE;
	}
	else
		return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CloseDriver | This function closes a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::CloseDriver()
{
	FX_ENTRY("CWDMDriver::CloseDriver");

	BOOL bRet = TRUE;

	if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE))
	{
		if (!(bRet = CloseHandle(m_hDriver)))
		{
			ERRORMESSAGE(("%s: CloseHandle() failed with GetLastError()=%d\r\n", _fx_, GetLastError()));
		}
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: Nothing to close\r\n", _fx_));
	}

	m_hDriver = (HANDLE)NULL;

	return bRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | DeviceIoControl | This function wraps around
 *    ::DeviceIOControl.
 *
 *  @parm HANDLE | hFile | Handle to the device that is to perform the
 *    operation.
 *
 *  @parm DWORD | dwIoControlCode | Specifies the control code for the
 *    operation.
 *
 *  @parm LPVOID | lpInBuffer | Pointer to a buffer that contains the data
 *    required to perform the operation.
 *
 *  @parm DWORD | nInBufferSize | Specifies the size, in bytes, of the buffer
 *    pointed to by <p lpInBuffer>.
 *
 *  @parm LPVOID | lpOutBuffer | Pointer to a buffer that receives the
 *    operation's output data.
 *
 *  @parm DWORD | nOutBufferSize | Specifies the size, in bytes, of the
 *    buffer pointed to by <p lpOutBuffer>.
 *
 *  @parm LPDWORD | lpBytesReturned | Pointer to a variable that receives the
 *    size, in bytes, of the data stored into the buffer pointed to by
 *    <p lpOutBuffer>.
 *
 *  @parm BOOL | bOverlapped | If TRUE, the operation is performed
 *    asynchronously, if FALSE, the operation is synchronous.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::DeviceIoControl(HANDLE hFile, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped)
{
	FX_ENTRY("CWDMDriver::DeviceIoControl");

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
	{
		LPOVERLAPPED lpOverlapped=NULL;
		BOOL bRet;
		OVERLAPPED ov;
		DWORD dwErr;

		if (bOverlapped)
		{
			ov.Offset            = 0;
			ov.OffsetHigh        = 0;
			ov.hEvent            = CreateEvent( NULL, FALSE, FALSE, NULL );
			if (ov.hEvent == (HANDLE) 0)
			{
				ERRORMESSAGE(("%s: CreateEvent has failed\r\n", _fx_));
			}
			lpOverlapped        =&ov;
		}

		bRet = ::DeviceIoControl(hFile, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);

		if (bOverlapped)
		{
			BOOL bShouldBlock=FALSE;

			if (!bRet)
			{
				dwErr=GetLastError();
				switch (dwErr)
				{
					case ERROR_IO_PENDING:    // the overlapped IO is going to take place.
						bShouldBlock=TRUE;
						break;

					default:    // some other strange error has happened.
						ERRORMESSAGE(("%s: DevIoControl failed with GetLastError=%d\r\n", _fx_, dwErr));
						break;
				}
			}

			if (bShouldBlock)
			{
#ifdef _DEBUG
				DWORD    tmStart, tmEnd, tmDelta;
				tmStart = timeGetTime();
#endif

				DWORD dwRtn = WaitForSingleObject( ov.hEvent, 1000 * 10);  // USB has a max of 5 SEC bus reset

#ifdef _DEBUG
				tmEnd = timeGetTime();
				tmDelta = tmEnd - tmStart;
				if (tmDelta >= 1000)
				{
					ERRORMESSAGE(("%s: WaitObj waited %d msec\r\n", _fx_, tmDelta));
				}
#endif

				switch (dwRtn)
				{
					case WAIT_ABANDONED:
						ERRORMESSAGE(("%s: WaitObj: non-signaled ! WAIT_ABANDONED!\r\n", _fx_));
						bRet = FALSE;
						break;

					case WAIT_OBJECT_0:                    
						bRet = TRUE;
						break;

					case WAIT_TIMEOUT:
#ifdef _DEBUG
						ERRORMESSAGE(("%s: WaitObj: TIMEOUT after %d msec! rtn FALSE\r\n", _fx_, tmDelta));
#endif
						bRet = FALSE;
						break;

					default:
						ERRORMESSAGE(("%s: WaitObj: unknown return ! rtn FALSE\r\n", _fx_));
						bRet = FALSE;
						break;
				}
			}

			CloseHandle(ov.hEvent);
		}

		return bRet;
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetPropertyValue | This function gets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plValue | Pointer to a LONG to receive the current value.
 *
 *  @parm PULONG | pulFlags | Pointer to a ULONG to receive the current
 *    flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm PULONG | pulCapabilities | Pointer to a ULONG to receive the
 *    capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities)
{
	FX_ENTRY("CWDMDriver::GetPropertyValue");

	ULONG cbReturned;        

	// Inititalize video property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;
	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S));

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
	VideoProperty.Flags          = 0;

	// Get property value from driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: This property is not supported by this minidriver/device\r\n", _fx_));
		return FALSE;
	}

	*plValue         = VideoProperty.Value;
	*pulFlags        = VideoProperty.Flags;
	*pulCapabilities = VideoProperty.Capabilities;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetDefaultValue | This function gets the
 *    default value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plDefValue | Pointer to a LONG to receive the default value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue)    
{
	FX_ENTRY("CWDMDriver::GetDefaultValue");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;

	// Get the default values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	// Sanity check
	if (proList.proDesc.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION))
		return FALSE;
	else
	{
		*plDefValue = proList.ulData;
		return TRUE;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetRangeValues | This function gets the
 *    range values of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plMin | Pointer to a LONG to receive the minimum value.
 *
 *  @parm PLONG | plMax | Pointer to a LONG to receive the maximum value.
 *
 *  @parm PLONG | plStep | Pointer to a LONG to receive the step value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep)
{
	FX_ENTRY("CWDMDriver::GetRangeValues");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;

	// Get range values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	*plMin  = proList.proData.Bounds.SignedMinimum;
	*plMax  = proList.proData.Bounds.SignedMaximum;
	*plStep = proList.proData.SteppingDelta;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | SetPropertyValue | This function sets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm LONG | lValue | New value.
 *
 *  @parm ULONG | ulFlags | New flags. We only care about KSPROPERTY_*_FLAGS_MANUAL
 *    or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm ULONG | ulCapabilities | New capabilities. We only care about 
 *    KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities)
{
	FX_ENTRY("CWDMDriver::SetPropertyValue");

	ULONG cbReturned;        

	// Initialize property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;

	VideoProperty.Flags        = ulFlags;
	VideoProperty.Value        = lValue;
	VideoProperty.Capabilities = ulCapabilities;

	// Set the property value on the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *set* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\precomp.h ===
// Precompiled header for DCAP32.DLL

// the build environment only defines _DEBUG when
// ALT_PROJECT_TARGET = NT is specified. Bug the debug zones only
// test for DEBUG...

#ifdef _DEBUG
#	ifndef DEBUG
#		define DEBUG
#	endif // !DEBUG
#endif // _DEBUG

#include <windows.h>
#include <confdbg.h>
#include <avutil.h>
#include <memtrack.h>
#include <winioctl.h>	// CTL_CODE, FILE_READ_ACCESS..etc
#include <commctrl.h>	// Page.cpp (UDM_GETRANGE, TBM_GETPOS) and Sheet.cpp (InitCommonControls)
#include <mmsystem.h>	// must go before mmddk.h
#include <mmddk.h>		// for DriverCallback()
#include <vfw.h>
#include <msviddrv.h>	// VIDEO_STREAM_INIT_PARMS
#include <strmif.h>
#include <uuids.h>
#include <ks.h>
#include <ksmedia.h>
#include <help_ids.h>
#include "..\inc\idcap.h"
#include "..\inc\WDMDrivr.h"
#include "..\inc\WDMPin.h"
#include "..\inc\WDMStrmr.h"
#include "..\inc\debug.h"
#include "..\inc\wdmcap.h"
#include "..\inc\resource.h"
#include "..\inc\WDMDialg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\wdmpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMPIN
 *
 *  @module WDMPin.cpp | Include file for <c CWDMPin> class used to access
 *    video data on a video streaming pin exposed by the WDM class driver.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | CWDMPin | Video pin class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMPin::CWDMPin(DWORD dwDeviceID) : CWDMDriver(dwDeviceID)
{
	m_hKS			= (HANDLE)NULL;
	m_fStarted		= FALSE;
	m_hKsUserDLL	= (HINSTANCE)NULL;
	m_pKsCreatePin	= (LPFNKSCREATEPIN)NULL;

	ZeroMemory(&m_biHdr, sizeof(KS_BITMAPINFOHEADER));
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | ~CWDMPin | Video pin class destructor. Closes
 *    the video pin and releases the video buffers allocated.
 ***************************************************************************/
CWDMPin::~CWDMPin()
{
	FX_ENTRY("CWDMPin::~CWDMPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroying the video pin, m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	// Nuke the video streaming pin
	DestroyPin();

	// Close the driver
	if (GetDriverHandle())
		CloseDriver();

	// Release kernel streaming DLL (KSUSER.DLL)
	if (m_hKsUserDLL)
		FreeLibrary(m_hKsUserDLL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetFrame | This function gets a frame from the
 *    video streaming pin.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to the destination buffer to receive
 *    the video frame and information.
 *
 *  @parm PDWORD | pdwBytesUsed | Pointer to the number of bytes used to
 *    read the video frame.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetFrame(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMPin::GetFrame");

	ASSERT(lpVHdr && lpVHdr->lpData && GetDriverHandle() && m_hKS && (lpVHdr->dwBufferLength >= m_biHdr.biSizeImage));

	DWORD bRtn;

	// Check input params and state
	if (!lpVHdr || !lpVHdr->lpData || !GetDriverHandle() || !m_hKS || (lpVHdr->dwBufferLength < m_biHdr.biSizeImage))
	{
		ERRORMESSAGE(("%s: No buffer, no driver, no PIN connection, or buffer too small\r\n", _fx_));
		goto MyError0;
	}

	// Put the pin in streaming mode
	if (!Start())
	{
		ERRORMESSAGE(("%s: Cannot set streaming state to KSSTATE_RUN\r\n", _fx_));
		goto MyError0;
	}

	// Initialize structure to do a read on the video pin
	DWORD cbBytesReturned;
	KS_HEADER_AND_INFO SHGetImage;

	ZeroMemory(&SHGetImage,sizeof(SHGetImage));
	SHGetImage.StreamHeader.Data = (LPDWORD)lpVHdr->lpData;
	SHGetImage.StreamHeader.Size = sizeof (KS_HEADER_AND_INFO);
	SHGetImage.StreamHeader.FrameExtent = m_biHdr.biSizeImage;
	SHGetImage.FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

	// Read a frame on the video pin
	bRtn = DeviceIoControl(m_hKS, IOCTL_KS_READ_STREAM, &SHGetImage, sizeof(SHGetImage), &SHGetImage, sizeof(SHGetImage), &cbBytesReturned);

	if (!bRtn)
	{
		ERRORMESSAGE(("%s: DevIo rtn (%d), GetLastError=%d. StreamState->STOP\r\n", _fx_, bRtn, GetLastError()));

		// Stop streaming on the video pin
		Stop();

		goto MyError0;
	}

	// Sanity check
	ASSERT(SHGetImage.StreamHeader.FrameExtent >= SHGetImage.StreamHeader.DataUsed);
	if (SHGetImage.StreamHeader.FrameExtent < SHGetImage.StreamHeader.DataUsed)
	{
		ERRORMESSAGE(("%s: We've corrupted memory!\r\n", _fx_));
		goto MyError0;
	}

	lpVHdr->dwTimeCaptured = timeGetTime();
	lpVHdr->dwBytesUsed  = SHGetImage.StreamHeader.DataUsed;
	lpVHdr->dwFlags |= VHDR_KEYFRAME;

	return TRUE;

MyError0:
	if (lpVHdr)
	{
		lpVHdr->dwBytesUsed = 0UL;
		lpVHdr->dwTimeCaptured = timeGetTime();
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Start | This function puts the video
 *    pin in streaming mode.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Start()
{
	if (m_fStarted)
		return TRUE;

	if (SetState(KSSTATE_PAUSE))
		m_fStarted = SetState(KSSTATE_RUN);

	return m_fStarted;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Stop | This function stops streaming on the
 *    video pin.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Stop()
{
	if (m_fStarted)
	{
		if (SetState(KSSTATE_PAUSE))
			if (SetState(KSSTATE_STOP))
				m_fStarted = FALSE;
	}

	return (BOOL)(m_fStarted == FALSE);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function sets the state of the
 *    video streaming pin.
 *
 *  @parm KSSTATE | ksState | New state.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetState(KSSTATE ksState)
{
	KSPROPERTY	ksProp = {0};
	DWORD		cbRet;

	ksProp.Set		= KSPROPSETID_Connection;
	ksProp.Id		= KSPROPERTY_CONNECTION_STATE;
	ksProp.Flags	= KSPROPERTY_TYPE_SET;

	return DeviceIoControl(m_hKS, IOCTL_KS_PROPERTY, &ksProp, sizeof(ksProp), &ksState, sizeof(KSSTATE), &cbRet);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function either finds a video
 *    data range compatible with the bitamp info header passed in, of the
 *    prefered video data range.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdr | Bitmap info header to match.
 *
 *  @parm BOOL | pfValidMatch | Set to TRUE if a match was found, FALSE
 *    otherwise.
 *
 *  @rdesc Returns a valid pointer to a <t KS_DATARANGE_VIDEO> structure if
 *    successful, or a NULL pointer otherwise.
 *
 *  @comm \\redrum\slmro\proj\wdm10\src\dvd\amovie\proxy\filter\ksutil.cpp(207):KsGetMediaTypes(
 ***************************************************************************/
PKS_DATARANGE_VIDEO CWDMPin::FindMatchDataRangeVideo(PKS_BITMAPINFOHEADER pbiHdr, BOOL *pfValidMatch)
{
	FX_ENTRY("CWDMPin::FindMatchDataRangeVideo");

	ASSERT(pfValidMatch && pbiHdr);

	// Check input params and state
	if (!pbiHdr || !pfValidMatch)
	{
		ERRORMESSAGE(("%s: Bad input params\r\n", _fx_));
		return (PKS_DATARANGE_VIDEO)NULL;
	}

	// Default
	*pfValidMatch = FALSE;

	PDATA_RANGES pDataRanges = GetDriverSupportedDataRanges();

	ASSERT(pDataRanges != 0);

	if (!pDataRanges) 
		return (PKS_DATARANGE_VIDEO)NULL;

	PKS_DATARANGE_VIDEO pSelDRVideo, pDRVideo = &pDataRanges->Data, pFirstDRVideo = 0;
	KS_BITMAPINFOHEADER * pbInfo;

	// PhilF-: This code assumes that all structures are KS_DATARANGE_VIDEO. This
	// may not be a valid assumption foir palettized data types. Check with JayBo
	for (ULONG i = 0; i < pDataRanges->Count; i++)
	{ 
		// Meaningless unless it is *_VIDEOINFO
		if (pDRVideo->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO)
		{
			// We don't care about TV Tuner like devices
			if (pDRVideo->ConfigCaps.VideoStandard == KS_AnalogVideo_None)
			{
				// Save first useable data range
				if (!pFirstDRVideo)
					pFirstDRVideo = pDRVideo;  

				pbInfo = &((pDRVideo->VideoInfoHeader).bmiHeader);

				if ( (pbInfo->biBitCount == pbiHdr->biBitCount) && (pbInfo->biCompression == pbiHdr->biCompression) &&
					( (((pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0))
					&& (pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth) && (pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight)) ||
					((pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth) && (pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx) &&
					(pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight) && (pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy) &&
					((pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0) && ((pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0)) ) )
				{
					*pfValidMatch = TRUE;
					pSelDRVideo = pDRVideo;
					break;
				}
			} // VideoStandard
		} // Specifier

		pDRVideo++;  // Next KS_DATARANGE_VIDEO
	}

	// If no valid match, use the first range found
	if (!*pfValidMatch)
		pSelDRVideo = pFirstDRVideo;

	return (pSelDRVideo);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | CreatePin | This function actually creates a
 *    video streaming pin on the class driver.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiNewHdr | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the frame
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::CreatePin(PKS_BITMAPINFOHEADER pbiNewHdr, DWORD dwAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::CreatePin");

	ASSERT(m_pKsCreatePin);

	PKS_BITMAPINFOHEADER pbiHdr;
	BOOL bMustMatch, bValidMatch;
#ifdef _DEBUG
	char szFourCC[5] = {0};
#endif

	if (pbiNewHdr)
	{
		// We need to find a video data range that matches the bitmap info header passed in
		bMustMatch = TRUE;
		pbiHdr = pbiNewHdr;
	}
	else
	{
		// We'll use the preferred video data range and default bitmap format
		bMustMatch = FALSE;
		pbiHdr = &m_biHdr;
	}

	PKS_DATARANGE_VIDEO pSelDRVideo = FindMatchDataRangeVideo(pbiHdr, &bValidMatch);
	if (!pSelDRVideo)         
		return FALSE;

	if (bMustMatch && !bValidMatch)
		return FALSE;

	// If we already have a pin, nuke it
	if (GetPinHandle()) 
		DestroyPin();

	// Connect to a new PIN.
	DATAPINCONNECT DataConnect;
	ZeroMemory(&DataConnect, sizeof(DATAPINCONNECT));
	DataConnect.Connect.PinId						= 0;								// CODEC0 sink
	DataConnect.Connect.PinToHandle					= NULL;								// no "connect to"
	DataConnect.Connect.Interface.Set				= KSINTERFACESETID_Standard;
	DataConnect.Connect.Interface.Id				= KSINTERFACE_STANDARD_STREAMING;	// STREAMING
	DataConnect.Connect.Medium.Set					= KSMEDIUMSETID_Standard;
	DataConnect.Connect.Medium.Id					= KSMEDIUM_STANDARD_DEVIO;
	DataConnect.Connect.Priority.PriorityClass		= KSPRIORITY_NORMAL;
	DataConnect.Connect.Priority.PrioritySubClass	= 1;
	CopyMemory(&(DataConnect.Data.DataFormat), &(pSelDRVideo->DataRange), sizeof(KSDATARANGE));
	CopyMemory(&(DataConnect.Data.VideoInfoHeader), &pSelDRVideo->VideoInfoHeader, sizeof(KS_VIDEOINFOHEADER));

	// Adjust the image sizes if necessary
	if (bValidMatch)
	{
		DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth		= pbiHdr->biWidth;
		DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight		= abs(pbiHdr->biHeight); // Support only +biHeight!
		DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage	= pbiHdr->biSizeImage;        
	}

	// Overwrite the default frame rate if non-zero
	if (dwAvgTimePerFrame > 0)
		DataConnect.Data.VideoInfoHeader.AvgTimePerFrame = (REFERENCE_TIME)dwAvgTimePerFrame;

#ifdef _DEBUG
    *((DWORD*)&szFourCC) = DataConnect.Data.VideoInfoHeader.bmiHeader.biCompression;
#endif
	DEBUGMSG(ZONE_INIT, ("%s: Request image format: FourCC(%s) %d * %d * %d bits = %d bytes\r\n", _fx_, szFourCC, DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth, DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight, DataConnect.Data.VideoInfoHeader.bmiHeader.biBitCount, DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: Request frame rate:   %d fps\r\n", _fx_, 10000000/dwAvgTimePerFrame));
	DEBUGMSG(ZONE_INIT, ("%s: m_hKS was=0x%08lX\r\n", _fx_, m_hKS));

#ifndef HIDE_WDM_DEVICES
	DWORD dwErr = (*m_pKsCreatePin)(GetDriverHandle(), (PKSPIN_CONNECT)&DataConnect, GENERIC_READ | GENERIC_WRITE, &m_hKS);
#else
	DWORD dwErr = 0UL;
	m_hKS = NULL;
#endif

	if (dwAvgTimePerFrame != 0)
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX set to stream at %d fps\r\n", _fx_, m_hKS, 10000000/dwAvgTimePerFrame));
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX\r\n", _fx_, m_hKS));
	}

	if (dwErr || (m_hKS == NULL))
	{
		ERRORMESSAGE(("%s: KsCreatePin returned 0x%08lX failure and m_hKS=0x%08lX\r\n", _fx_, dwErr, m_hKS));

		if (m_hKS == INVALID_HANDLE_VALUE)
		{  
			m_hKS = (HANDLE)NULL;
		}

		return FALSE;
	}

	// Cache the bitmap info header
	CopyMemory(&m_biHdr, &DataConnect.Data.VideoInfoHeader.bmiHeader, sizeof(KS_BITMAPINFOHEADER));
	m_dwAvgTimePerFrame = (DWORD)DataConnect.Data.VideoInfoHeader.AvgTimePerFrame;

	DEBUGMSG(ZONE_INIT, ("%s: New m_biHdr:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, m_biHdr.biSize, m_biHdr.biWidth, m_biHdr.biHeight, m_biHdr.biPlanes, m_biHdr.biBitCount, m_biHdr.biCompression, m_biHdr.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: New m_dwAvgTimePerFrame=%ld (%fd fps)\r\n", _fx_, m_dwAvgTimePerFrame, 10000000/m_dwAvgTimePerFrame));

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | DestroyPin | This function nukes a video
 *    streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::DestroyPin()
{
	BOOL fRet = TRUE;

	FX_ENTRY("CWDMPin::DestroyPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroy PIN m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	if (m_hKS)
	{
		Stop();

		if (!(fRet = CloseHandle(m_hKS)))
		{
			ERRORMESSAGE(("%s: CloseHandle(m_hKS=0x%08lX) failed with GetLastError()=0x%08lX\r\n", _fx_, m_hKS, GetLastError()));
		}

		m_hKS = NULL;
	}

	return fRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetBitmapInfo | This function sets the video
 *    format of video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdrNew | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetBitmapInfo(PKS_BITMAPINFOHEADER pbiHdrNew)
{
	FX_ENTRY("CWDMPin::SetBitmapInfo");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: New pbiHdrNew:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbiHdrNew->biSize, pbiHdrNew->biWidth, pbiHdrNew->biHeight, pbiHdrNew->biPlanes, pbiHdrNew->biBitCount, pbiHdrNew->biCompression, pbiHdrNew->biSizeImage));

	// Check if we need to change anything
	if ( GetPinHandle() && (m_biHdr.biHeight == pbiHdrNew->biHeight) && (m_biHdr.biWidth == pbiHdrNew->biWidth) &&
		(m_biHdr.biBitCount == pbiHdrNew->biBitCount) && (m_biHdr.biSizeImage == pbiHdrNew->biSizeImage) &&
		(m_biHdr.biCompression == pbiHdrNew->biCompression) )
		return TRUE;
	else 
		return CreatePin(pbiHdrNew, m_dwAvgTimePerFrame);    

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetBitmapInfo | This function gets the video
 *    format of a video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbInfo | This parameter points to a bitmap
 *    info header structure to receive the video format.
 *
 *  @parm WORD | wSize | This parameter specifies the size of the bitmap
 *    info header structure.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo, WORD wSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage)
	{
		ERRORMESSAGE(("%s: No existing PIN handle or no available format\r\n", _fx_));
		return FALSE;
	}

	CopyMemory(pbInfo, &m_biHdr, wSize);  

	// Support only positive +biHeight.  
	if (pbInfo->biHeight < 0)
	{
		pbInfo->biHeight = -pbInfo->biHeight;
		DEBUGMSG(ZONE_INIT, ("%s: Changed biHeight from -%ld to %ld\r\n", _fx_, pbInfo->biHeight, pbInfo->biHeight));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetPaletteInfo | This function gets the video
 *    palette of a video streaming pin.
 *
 *  @parm CAPTUREPALETTE * | pPal | This parameter points to a palette
 *    structure to receive the video palette.
 *
 *  @parm DWORD | dwcbSize | This parameter specifies the size of the video
 *    palette.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetPaletteInfo(CAPTUREPALETTE *pPal, DWORD dwcbSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage && (m_biHdr.biBitCount > 8))
	{
		ERRORMESSAGE(("%s: No existing PIN handle, no available format, or bad biBitCount\r\n", _fx_));
		return FALSE;
	}

	// PhilF-: Copy some real bits there
	// CopyMemory(pbInfo, &m_biHdr, wSize);  

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetAverageTimePerFrame | This function sets the
 *    video frame rate of a video streaming pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the rate
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetAverageTimePerFrame(DWORD dwNewAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::SetAverageTimePerFrame");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Current frame interval=%d; new frame intercal=%d\r\n", _fx_, m_dwAvgTimePerFrame, dwNewAvgTimePerFrame));

    if (m_dwAvgTimePerFrame != dwNewAvgTimePerFrame)
		return CreatePin(&m_biHdr, dwNewAvgTimePerFrame);    
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: No need to change frame rate\r\n", _fx_));
        return TRUE;
    }

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | OpenDriverAndPin | This function opens the class
 *    driver and creates a video streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::OpenDriverAndPin()
{
	FX_ENTRY("CWDMPin::OpenDriverAndPin");

	// Load KSUSER.DLL and get a proc address
	if (m_hKsUserDLL = LoadLibrary("KSUSER"))
	{
		if (m_pKsCreatePin = (LPFNKSCREATEPIN)GetProcAddress(m_hKsUserDLL, "KsCreatePin"))
		{
			// Open the class driver
			if (OpenDriver())
			{
				// Create a video streaming pin on the driver
				if (CreatePin((PKS_BITMAPINFOHEADER)NULL))
				{
					return TRUE;
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: Pin connection creation failed!\r\n", _fx_));

					if (GetDriverHandle()) 
						CloseDriver();
				}
			}
		}

		FreeLibrary(m_hKsUserDLL);
	}


	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\dcap32.cpp ===
//
//  Created 31-Jul-96 [JonT]

// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

#ifndef WIDTHBYTES
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)
#endif

#ifdef _DEBUG
static PTCHAR _rgZonesCap[] = {
	TEXT("dcap"),
	TEXT("Init"),
	TEXT("Streaming"),
	TEXT("Callback"),
	TEXT("Dialogs"),
	TEXT("Trace")
};
#endif

#ifndef __NT_BUILD__
extern "C" {
// Special thunk prototype
BOOL    thk_ThunkConnect32(LPSTR pszDll16, LPSTR pszDll32,
        HINSTANCE hInst, DWORD dwReason);

//; Magic Function code values for DeviceIOControl code.
//DCAPVXD_THREADTIMESERVICE equ	101h
//DCAPVXD_R0THREADIDSERVICE equ 102h
#define DCAPVXD_THREADTIMESERVICE 0x101
#define DCAPVXD_R0THREADIDSERVICE 0x102


// KERNEL32 prototypes (not in headers but are exported by name on Win95)
void* WINAPI    MapSL(DWORD dw1616Ptr);
HANDLE WINAPI   OpenVxDHandle(HANDLE h);
}
#endif

// Helper function prototypes
BOOL    initializeCaptureDeviceList(void);
HVIDEO  openVideoChannel(DWORD dwDeviceID, DWORD dwFlags);
BOOL    allocateBuffers(HCAPDEV hcd, int nBuffers);
void    freeBuffers(HCAPDEV hcd);

// Globals
	HINSTANCE g_hInst;
    int g_cDevices;
    LPINTERNALCAPDEV g_aCapDevices[DCAP_MAX_DEVICES];

	BOOL g_fInitCapDevList;
#define INIT_CAP_DEV_LIST() if (g_fInitCapDevList) { initializeCaptureDeviceList(); }

#ifndef __NT_BUILD__
    HANDLE s_hVxD = NULL;
#endif //__NT_BUILD__

// Strings
#ifdef __NT_BUILD__
    char g_szVFWRegKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32";
    char g_szVFWRegDescKey[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc";
    char g_szDriverName[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "WDM Video For Windows Capture Driver (Win32)";
    char g_szVfWToWDMMapperName[] = "VfWWDM32.dll";
#endif
#else
    char g_szVFWRegKey[] = "SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo";
    char g_szRegDescription[] = "Description";
    char g_szRegName[] = "Driver";
    char g_szRegDisabled[] = "Disabled";
    char g_szDevNode[] = "DevNode";
    char g_szSystemIni[] = "system.ini";
    char g_szDriverSection[] = "drivers";
    char g_szDriverKey[] = "MSVIDEOx";
#ifndef SHOW_VFW2WDM_MAPPER
    char g_szVfWToWDMMapperDescription[] = "VfW MM 16bit Driver for WDM V. Cap. Devices";
    char g_szVfWToWDMMapperName[] = "vfwwdm.drv";
#endif
#endif
    char g_szMSOfficeCamcorderDescription[] = "Screen Capture Device Driver for AVI";
    char g_szMSOfficeCamcorderName[] = "Gdicap97.drv";

    char g_szVerQueryForDesc[] = "\\StringFileInfo\\040904E4\\FileDescription";


void DoClose(HCAPDEV hcd);

#define ENTER_DCAP(hcd) InterlockedIncrement(&(hcd)->busyCount);
#define LEAVE_DCAP(hcd) if (InterlockedDecrement(&(hcd)->busyCount) == 0) DoClose((hcd));

//  DllEntryPoint

extern "C" BOOL
DllEntryPoint(
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    static int s_nProcesses = 0;

	FX_ENTRY("DllEntryPoint");

#ifndef __NT_BUILD__

    // We want to load the VxD even before initializing the thunks
    // because the 16-bit half initializes the VxD during the thk_ThunkConnect32 call
    if (!s_hVxD)
    {
        s_hVxD = CreateFile("\\\\.\\DCAPVXD.VXD", 0,0,0,0, FILE_FLAG_DELETE_ON_CLOSE, 0);
        if (s_hVxD == INVALID_HANDLE_VALUE)
        {
			ERRORMESSAGE(("%s: Failure loading VxD - Fatal\r\n", _fx_));
            return FALSE;
        }
    }

    // Initialize the thunks
    if (!(thk_ThunkConnect32("DCAP16.DLL", "DCAP32.DLL", hInst, dwReason)))
    {
		ERRORMESSAGE(("%s: thk_ThunkConnect32 failed!\r\n", _fx_));
        return FALSE;
    }
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

		// Save global hinst
		g_hInst = hInst;

        // Only initialize on the first DLL load
        if (s_nProcesses++ == 0)
        {
			DBGINIT(&ghDbgZoneCap, _rgZonesCap);

            DBG_INIT_MEMORY_TRACKING(hInst);

			g_fInitCapDevList = TRUE;
        }
        else
            return FALSE;   // fail to load multiple instances
        break;

    case DLL_PROCESS_DETACH:
        if (--s_nProcesses == 0)    // Are we going away?
        {
#ifndef __NT_BUILD__
            CloseHandle(s_hVxD);
            s_hVxD = NULL;
#endif
            DBG_CHECK_MEMORY_TRACKING(hInst);

			DBGDEINIT(&ghDbgZoneCap);
        }
        break;
    }

    return TRUE;
}


void GetVersionData (LPINTERNALCAPDEV lpcd)
{
    int j;
    DWORD dwVerInfoSize;
    LPSTR lpstrInfo;
    LPSTR lpDesc;

    // Version number
    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(lpcd->szDeviceName, NULL);
    if (dwVerInfoSize && (lpstrInfo  = (LPSTR)LocalAlloc(LPTR, dwVerInfoSize))) {
        // Read from the file into our block
        if (GetFileVersionInfo(lpcd->szDeviceName, 0L, dwVerInfoSize, lpstrInfo)) {
            lpDesc = NULL;
            if (VerQueryValue(lpstrInfo, g_szVerQueryForDesc, (LPVOID *)&lpDesc, (PUINT)&j) && lpDesc) {
                lstrcpyn(lpcd->szDeviceDescription, lpDesc, j);
                    wsprintf(lpcd->szDeviceVersion, TEXT("Version:  %d.%d.%d.%d"),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionMS),
							 HIWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS), LOWORD(((VS_VERSION *)lpstrInfo)->vffInfo.dwFileVersionLS));
            }
        }
        LocalFree(lpstrInfo);
    }
}


#ifdef __NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry
//      Returns FALSE iff there are no video devices.
BOOL
initializeCaptureDeviceList(void)
{
	HKEY hkeyVFW, hkeyVFWdesc;
	DWORD dwType;
	DWORD dwSize;
	int i;
	LPINTERNALCAPDEV lpcd;
	HCAPDEV hCapDev;

	FX_ENTRY("initializeCaptureDeviceList");

	// Clear the entire array and start with zero devices
	g_cDevices = 0;
	ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// Open the reg key in question
	if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
	{
		if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegDescKey, &hkeyVFWdesc) != ERROR_SUCCESS)
			hkeyVFWdesc = 0;

		lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));

		if (lpcd)
		{
			// Loop through all possible VFW drivers in registry
			for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
			{
				// Create the key name
				if (i == 0)
					g_szDriverName[sizeof (g_szDriverName) - 2] = 0;
				else
					g_szDriverName[sizeof (g_szDriverName) - 2] = (BYTE)i + '0';

				// Name
				dwSize = sizeof(lpcd->szDeviceName);
				if (RegQueryValueEx(hkeyVFW, g_szDriverName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize) == ERROR_SUCCESS)
				{
					// Description
					if (hkeyVFWdesc)
					{
						dwSize = sizeof(lpcd->szDeviceDescription);
						RegQueryValueEx(hkeyVFWdesc, lpcd->szDeviceName, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);
					}
					else
						lstrcpy (lpcd->szDeviceDescription, lpcd->szDeviceName);

					// Devnode
					lpcd->dwDevNode = 0;
					lpcd->nDeviceIndex = g_cDevices;

					GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
					// Remove bogus Camcorder capture device from list of devices shown to the user
					// The Camcorder driver is a fake capture device used by the MS Office Camcorder
					// to capture screen activity to an AVI file. This not a legit capture device driver
					// and is extremely buggy.
					// We also remove the VfW to WDM mapper if we are on NT5.
					if (lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName) && lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName))
					{
#endif
						g_aCapDevices[g_cDevices] = lpcd;
						g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
						g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
					}
					else
						LocalFree(lpcd);
#endif

					lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
					if (!lpcd)
					{
						ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
						break;  // break out of the FOR loop
					}
				}
			}
		}
		else
		{
			ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
		}

		if (lpcd)
			LocalFree (lpcd);   // free the extra buffer

		RegCloseKey(hkeyVFW);
		if (hkeyVFWdesc)
			RegCloseKey(hkeyVFWdesc);
	}

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

	return TRUE;
}

#else //__NT_BUILD__
//  initializeCaptureDeviceList
//      Sets up our static array of available capture devices from the registry and
//      from SYSTEM.INI.
//      Returns FALSE iff there are no video devices.

BOOL
initializeCaptureDeviceList(void)
{
    int i, j, index;
    HKEY hkeyVFW;
    HKEY hkeyEnum;
    DWORD dwType;
    DWORD dwSize;
    LPINTERNALCAPDEV lpcd;
    char szEnumName[MAX_PATH];
    char szDisabled[3];
    HCAPDEV hCapDev;
	OSVERSIONINFO osvInfo = {0};

	FX_ENTRY("initializeCaptureDeviceList");

    // Clear the entire array and start with zero devices
    g_cDevices = 0;
    ZeroMemory(g_aCapDevices, sizeof (g_aCapDevices));

	// If we are on a version on Win95 (OSRx) use the mapper to talk to WDM devices.
	// The WDM drivers used on OSR2 are not stream class minidrivers so we fail
	// to handle them properly. Let the mapper do this for us.
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvInfo);

    // Open the reg key in question
    if (RegOpenKey(HKEY_LOCAL_MACHINE, g_szVFWRegKey, &hkeyVFW) == ERROR_SUCCESS)
    {
        // Loop through all possible VFW drivers in registry
        for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
        {
            // See if the key is there and if not, we're done. Note that registry
            // keys have to be sequential, no holes allowed since the only way
            // to query is sequential...
            if (RegEnumKey(hkeyVFW, i, szEnumName, MAX_PATH) != ERROR_SUCCESS ||
                RegOpenKey(hkeyVFW, szEnumName, &hkeyEnum) != ERROR_SUCCESS)
                break;

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }

            // Description
            dwSize = sizeof (lpcd->szDeviceDescription);
            RegQueryValueEx(hkeyEnum, g_szRegDescription, NULL, &dwType, (LPBYTE)lpcd->szDeviceDescription, &dwSize);

            // Name
            dwSize = sizeof (lpcd->szDeviceName);
            RegQueryValueEx(hkeyEnum, g_szRegName, NULL, &dwType, (LPBYTE)lpcd->szDeviceName, &dwSize);

            // Disabled
            dwSize = sizeof (szDisabled);
            if (RegQueryValueEx(hkeyEnum, g_szRegDisabled, NULL, &dwType, (LPBYTE)szDisabled, &dwSize) == ERROR_SUCCESS &&
                szDisabled[0] == '1')
                lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

            // Devnode
            dwSize = sizeof (DWORD);
            RegQueryValueEx(hkeyEnum, g_szDevNode, NULL, &dwType, (BYTE*)&lpcd->dwDevNode, &dwSize);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

            RegCloseKey(hkeyEnum);
        }

        RegCloseKey(hkeyVFW);
    }

    // Now get the rest from system.ini, if any
    for (i = 0 ; i < DCAP_MAX_VFW_DEVICES ; i++)
    {
        // Create the key name
        if (i == 0)
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = 0;
        else
            g_szDriverKey[sizeof (g_szDriverKey) - 2] = (BYTE)i + '0';

        // See if there's a profile string
        if (GetPrivateProfileString(g_szDriverSection, g_szDriverKey, "",
            szEnumName, MAX_PATH, g_szSystemIni))
        {
            // First check to see if this is a dupe. If it is, go no further.
            if (g_cDevices)
            {
                for (j = 0 ; j < g_cDevices ; j++)
                    if (!lstrcmpi(g_aCapDevices[j]->szDeviceName, szEnumName))
                        goto NextDriver;
            }

            lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV));
            if (!lpcd)
			{
				ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
                break;  // break from the FOR loop
            }
            // We have a unique name, copy in the driver name and find the description
            // by reading the driver's versioninfo resource.
            lstrcpy(lpcd->szDeviceName, szEnumName);

            GetVersionData(lpcd);

#ifndef SHOW_VFW2WDM_MAPPER
			// Remove bogus Camcorder capture device from list of devices shown to the user
			// The Camcorder driver is a fake capture device used by the MS Office Camcorder
			// to capture screen activity to an AVI file. This not a legit capture device driver
			// and is extremely buggy.
			// We also remove the VfW to WDM mapper if we are on Win98. On Win95 we still use
			// it to get access to USB devices developed for OSR2.
			if ((lstrcmp(lpcd->szDeviceDescription, g_szMSOfficeCamcorderDescription) && lstrcmp(lpcd->szDeviceName, g_szMSOfficeCamcorderName)) && (((osvInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvInfo.dwMinorVersion == 0)) || lstrcmp(lpcd->szDeviceDescription, g_szVfWToWDMMapperDescription) && lstrcmp(lpcd->szDeviceName, g_szVfWToWDMMapperName)))
			{
#endif
				g_aCapDevices[g_cDevices] = lpcd;
				g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
				g_cDevices++;
#ifndef SHOW_VFW2WDM_MAPPER
			}
			else
				LocalFree(lpcd);
#endif

        }
NextDriver: ;
    }

#ifndef HIDE_WDM_DEVICES
	WDMGetDevices();
#endif

	g_fInitCapDevList = FALSE;

    return TRUE;
}
#endif //__NT_BUILD__


//  GetNumCaptureDevice
//      Returns the number of *ENABLED* capture devices

/****************************************************************************
 *  @doc EXTERNAL DCAP32
 *
 *  @func int DCAPI | GetNumCaptureDevices | This function returns the number
 *    of *ENABLED* capture devices.
 *
 *  @rdesc Returns the number of *ENABLE* capture devices.
 ***************************************************************************/
int
DCAPI
GetNumCaptureDevices()
{
	int nNumCapDevices = 0;
	int nDeviceIndex = 0;

	INIT_CAP_DEV_LIST();

	while (nDeviceIndex < g_cDevices)
		if (!(g_aCapDevices[nDeviceIndex++]->dwFlags & CAPTURE_DEVICE_DISABLED))
			nNumCapDevices++;

    return nNumCapDevices;
}


//  FindFirstCaptureDevice
//      Returns the first capture device available that matches the string
//      or the first one registered if szDeviceDescription is NULL

BOOL
DCAPI
FindFirstCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    char* szDeviceDescription
    )
{
    int i;
    static HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Validate size
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

// hack to avoid quickcam driver problem when hardware not installed
    if (g_cDevices && !hcap) {
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);
        if ((i < g_cDevices) && (hcap = OpenCaptureDevice(i))) {
            CloseCaptureDevice (hcap);
        }
        else {
			if (i < g_cDevices) {
				g_aCapDevices[i]->dwFlags |= CAPTURE_DEVICE_DISABLED;
#ifdef _DEBUG
				OutputDebugString((i == 0) ? "DCAP32: 1st capture device fails to open!\r\n" : (i == 1) ? "DCAP32: 2nd capture device fails to open!\r\n" : (i == 2) ? "DCAP32: 3rd capture device fails to open!\r\n" : "DCAP32: 4th capture device fails to open!\r\n");
#endif
			}
        }
    }

    // Search if necessary
    if (szDeviceDescription)
    {
        for (i = 0 ; i < g_cDevices ; i++)
            if (!lstrcmpi(g_aCapDevices[i]->szDeviceDescription, szDeviceDescription) &&
                !(g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED))
                break;
    }
    else
        for (i = 0; ((i < g_cDevices) && (g_aCapDevices[i]->dwFlags & CAPTURE_DEVICE_DISABLED)); i++);

    // Return the info
    if (i == g_cDevices)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }
    else {
        lpfcd->nDeviceIndex = i;
        lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
        lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[i]->szDeviceDescription);
        lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[i]->szDeviceVersion);
        return TRUE;
    }
}


//  FindFirstCaptureDeviceByIndex
//      Returns the device with the specified index.

BOOL
DCAPI
FindFirstCaptureDeviceByIndex(
    IN OUT FINDCAPTUREDEVICE* lpfcd,
    int nDeviceIndex
    )
{
	INIT_CAP_DEV_LIST();

    // Validate size and index
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE) ||
        nDeviceIndex >= g_cDevices || (nDeviceIndex < 0) ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Return the info
    lpfcd->nDeviceIndex = nDeviceIndex;
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  FindNextCaptureDevice
//      Returns the next capture device in list.

BOOL
DCAPI
FindNextCaptureDevice(
    IN OUT FINDCAPTUREDEVICE* lpfcd
    )
{
    HCAPDEV hcap = NULL;

	INIT_CAP_DEV_LIST();

    // Parameter validate the passed in structure
    if (lpfcd->dwSize != sizeof (FINDCAPTUREDEVICE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    while (++lpfcd->nDeviceIndex < g_cDevices)
	{
		if ((!(g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_DISABLED)))
		{
			if (g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags & CAPTURE_DEVICE_OPEN)
				break;
			else
			{
				if (hcap = OpenCaptureDevice(lpfcd->nDeviceIndex))
				{
					CloseCaptureDevice (hcap);
					break;
				}
				else
					g_aCapDevices[lpfcd->nDeviceIndex]->dwFlags |= CAPTURE_DEVICE_DISABLED;
			}
		}
	}

    // See if we're at the end
    if (lpfcd->nDeviceIndex >= g_cDevices)
    {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    // Otherwise, fill in the info for the next one
    lstrcpy(lpfcd->szDeviceName, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceName);
    lstrcpy(lpfcd->szDeviceDescription, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceDescription);
    lstrcpy(lpfcd->szDeviceVersion, g_aCapDevices[lpfcd->nDeviceIndex]->szDeviceVersion);

    return TRUE;
}


//  OpenCaptureDevice

HCAPDEV
DCAPI
OpenCaptureDevice(
    int nDeviceIndex
    )
{
    LPINTERNALCAPDEV hcd;
    LPBITMAPINFOHEADER lpbmih = NULL;
    DWORD err, dwLen;
    BOOL fl;

	FX_ENTRY("OpenCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    // Validate the device index
    if ((unsigned)nDeviceIndex >= (unsigned)g_cDevices ||
        (g_aCapDevices[nDeviceIndex]->dwFlags & (CAPTURE_DEVICE_DISABLED | CAPTURE_DEVICE_OPEN))) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    hcd = g_aCapDevices[nDeviceIndex];
    hcd->busyCount = 1;                 // we start at 1 to say that we're open
                                        // DoClose happens when count goes to 0

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifndef __NT_BUILD__
		// Allocate some memory we can lock for the LOCKEDINFO structure
		hcd->wselLockedInfo = _AllocateLockableBuffer(sizeof (LOCKEDINFO));
		if (!hcd->wselLockedInfo) {
			err = ERROR_OUTOFMEMORY;
			goto Error;
		}

		// Do our own thunking so we can track the selector for this buffer
		hcd->lpli = (LPLOCKEDINFO)MapSL(((DWORD)hcd->wselLockedInfo) << 16);
#endif

		// Open the necessary video channels
		if (!(hcd->hvideoIn = openVideoChannel(nDeviceIndex, VIDEO_IN)) ||
			!(hcd->hvideoCapture = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALIN)))
		{
			ERRORMESSAGE(("%s: Couldn't open video channel(s)\r\n", _fx_));
			if (hcd->hvideoIn)
				_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay = openVideoChannel(nDeviceIndex, VIDEO_EXTERNALOUT))
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device supports overlay!\r\n", _fx_));
		}
		else
		{
			DEBUGMSG(ZONE_INIT, ("%s: Capture device does not support overlay\r\n", _fx_));
		}
#endif
	}
	else
	{
		if (!WDMOpenDevice(nDeviceIndex))
		{
			ERRORMESSAGE(("%s: Couldn't open WDM device\r\n", _fx_));
			SetLastError(ERROR_DCAP_DEVICE_IN_USE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
			return FALSE;
		}
	}

    hcd->dwFlags |= CAPTURE_DEVICE_OPEN;

    // Get the initial format and set the values
    dwLen = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen)) {
        lpbmih->biSize = dwLen;
        fl = GetCaptureDeviceFormat(hcd, lpbmih);
        //If we can't get a format, or height and/or width are 0, don't use this device
        if (!fl || lpbmih->biWidth == 0 || lpbmih->biHeight == 0) {
			ERRORMESSAGE(("%s: GetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
        fl = SetCaptureDeviceFormat(hcd, lpbmih, 0, 0);
        if (!fl) {
			ERRORMESSAGE(("%s: SetCaptureDeviceFormat failed\r\n", _fx_));
            err = ERROR_DCAP_NO_DRIVER_SUPPORT;
            goto Error;
        }
#if 0
        _SetCaptureRect(hcd->hvideoIn, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_SRC_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
        _SetCaptureRect(hcd->hvideoCapture, DVM_DST_RECT, 0, 0, lpbmih->biWidth, lpbmih->biHeight);
#endif
        LocalFree((HANDLE)lpbmih);
    } else {
        err = ERROR_OUTOFMEMORY;
        goto Error;
    }

	// Keep a stream running all the time on EXTERNALIN (capture->frame buffer).
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay)
			_InitializeExternalVideoStream(hcd->hvideoOverlay);
#else
		_InitializeExternalVideoStream(hcd->hvideoCapture);
#endif

#ifndef __NT_BUILD__
		// Lock our structure so it can be touched at interrupt time
		_LockBuffer(hcd->wselLockedInfo);
#endif
	}

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hcd;

Error:
    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;
    if (lpbmih) {
        LocalFree((HANDLE)lpbmih);
        lpbmih = NULL;
    }
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		if (hcd->hvideoIn) {
			_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0);
			hcd->hvideoIn = NULL;
		}
		if (hcd->hvideoCapture) {
			_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0);
			hcd->hvideoCapture = NULL;
		}
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif
	}
	else
	{
		WDMCloseDevice(nDeviceIndex);
	}
    SetLastError(err);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return NULL;
}


void
DoClose(
    HCAPDEV hcd
    )
{
	FX_ENTRY("DoClose");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	// Clean up streaming on main channel, including freeing all buffers
	if (hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
		UninitializeStreaming(hcd);

	// Stop streaming on the capture channel
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_STREAM_FINI, 0L, 0L);
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#else
		_SendDriverMessage((HDRVR)hcd->hvideoCapture, DVM_STREAM_FINI, 0L, 0L);
#endif

#ifdef USE_VIDEO_OVERLAY
		if (hcd->hvideoOverlay) {
			_CloseDriver((HDRVR)hcd->hvideoOverlay, 0, 0);
			hcd->hvideoOverlay = NULL;
		}
#endif

		// Close the driver channels
		if (!_CloseDriver((HDRVR)hcd->hvideoCapture, 0, 0) ||
			!_CloseDriver((HDRVR)hcd->hvideoIn, 0, 0))
		{
			SetLastError(ERROR_DCAP_NONSPECIFIC);
			ERRORMESSAGE(("%s: Couldn't close channel, error unknown\r\n", _fx_));
			// with delayed close this is catastrophic, we can't just return that the device is still
			// open, but we can't get the device to close either, so we'll have to just leave it in this
			// hung open state - hopefully this never happens...
		}
		hcd->hvideoCapture = NULL;
		hcd->hvideoIn = NULL;
#ifndef __NT_BUILD__
		// Free the LOCKEDINFO structure
		_FreeLockableBuffer(hcd->wselLockedInfo);
		hcd->wselLockedInfo = 0;
#endif
	}
	else
	{
		WDMCloseDevice(hcd->nDeviceIndex);
	}

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}

BOOL
DCAPI
CloseCaptureDevice(
    HCAPDEV hcd
    )
{
	FX_ENTRY("CloseCaptureDevice");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    hcd->dwFlags &= ~CAPTURE_DEVICE_OPEN;   // clear flag to disable other API's
    LEAVE_DCAP(hcd);                        // dec our enter count, if no other thread is in a DCAP
                                            // service, then this dec will go to 0 and we'll call
                                            // DoClose; else we won't call DoClose until the other
                                            // active service dec's the count to 0
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


DWORD
DCAPI
GetCaptureDeviceFormatHeaderSize(
    HCAPDEV hcd
    )
{
    DWORD res;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		res = _GetVideoFormatSize(reinterpret_cast<HDRVR>(hcd->hvideoIn));
	else
		res = WDMGetVideoFormatSize(hcd->nDeviceIndex);

    LEAVE_DCAP(hcd);

    return res;
}


BOOL
DCAPI
GetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDeviceFormat");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // Call the driver to get the bitmap information
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoFormat(hcd->hvideoIn, lpbmih);
	else
		fRes = WDMGetVideoFormat(hcd->nDeviceIndex, lpbmih);
	
    if (!fRes)
    {
        // This is DOOM if the driver doesn't support this.
        // It might be useful have some sort of fallback code here,
        // or else we should try this when the connection is made and
        // fail it unless this call works.
		ERRORMESSAGE(("%s: Failed to get video format\r\n", _fx_));
        SetLastError(ERROR_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

	if (lpbmih->biCompression == BI_RGB)
		lpbmih->biSizeImage = WIDTHBYTES(lpbmih->biWidth * lpbmih->biBitCount) * lpbmih->biHeight;

	// Keep track of current buffer size needed
	hcd->dwcbBuffers = sizeof(CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


BOOL
DCAPI
SetCaptureDeviceFormat(
    HCAPDEV hcd,
    LPBITMAPINFOHEADER lpbmih,
    LONG srcwidth,
    LONG srcheight
    )
{
	BOOL fRes;
#ifdef USE_VIDEO_OVERLAY
    RECT rect;
#endif

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // Don't allow this if streaming
    if (hcd->dwFlags & HCAPDEV_STREAMING)
    {
        SetLastError(ERROR_DCAP_NOT_WHILE_STREAMING);
        return FALSE;
    }
    ENTER_DCAP(hcd);

    // Call the driver to set the format
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		fRes = _SetVideoFormat(hcd->hvideoCapture, hcd->hvideoIn, lpbmih);
#ifdef USE_VIDEO_OVERLAY
		if (fRes && hcd->hvideoOverlay)
		{
			// Get the current rectangles
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay dst rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_GET);
			DEBUGMSG(ZONE_INIT, ("%s: Current overlay src rect is rect.left=%ld, rect.top=%ld, rect.right=%ld, rect.bottom=%ld\r\n", _fx_, rect.left, rect.top, rect.right, rect.bottom));

			// Set the rectangles
			rect.left = rect.top = 0;
			rect.right = (WORD)lpbmih->biWidth;
			rect.bottom = (WORD)lpbmih->biHeight;
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			_SendDriverMessage((HDRVR)hcd->hvideoOverlay, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
			if (hcd->hvideoOverlay)
				_InitializeExternalVideoStream(hcd->hvideoOverlay);
		}
#endif
	}
	else
		fRes = WDMSetVideoFormat(hcd->nDeviceIndex, lpbmih);

    if (!fRes)
    {
        SetLastError(ERROR_DCAP_FORMAT_NOT_SUPPORTED);
        LEAVE_DCAP(hcd);
        return FALSE;
    }

    // Cache the bitmap size we're dealing with now
	if (lpbmih->biCompression == BI_RGB)
		hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biWidth * lpbmih->biHeight * lpbmih->biBitCount / 8;
	else
	    hcd->dwcbBuffers = sizeof (CAPBUFFERHDR) + lpbmih->biSizeImage;

    LEAVE_DCAP(hcd);
    return TRUE;
}


//  GetCaptureDevicePalette
//      Gets the current palette from the capture device. The entries are returned to
//      the caller who normally calls CreatePalette on the structure. It may, however,
//      want to translate the palette entries into some preexisting palette or identity
//      palette before calling CreatePalette, hence the need for passing back the entries.

BOOL
DCAPI
GetCaptureDevicePalette(
    HCAPDEV hcd,
    CAPTUREPALETTE* lpcp
    )
{
	BOOL fRes;

	FX_ENTRY("GetCaptureDevicePalette");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);

    // The caller doesn't have to initialize the structure.
    // The driver should fill it in, but it may want it preininitialized so we do that here.
    lpcp->wVersion = 0x0300;
    lpcp->wcEntries = 256;

    // Get the palette entries from the driver and return to the user
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRes = _GetVideoPalette(hcd->hvideoIn, lpcp, sizeof (CAPTUREPALETTE));
	else
		fRes = WDMGetVideoPalette(hcd->nDeviceIndex, lpcp, sizeof (CAPTUREPALETTE));

    if (!fRes)
	{
		ERRORMESSAGE(("%s: No palette returned from driver\r\n", _fx_));
		SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
		LEAVE_DCAP(hcd);
		return FALSE;
	}

    LEAVE_DCAP(hcd);
    return TRUE;
}


void
TerminateStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
	BOOL fRes;

	FX_ENTRY("TerminateStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    StopStreaming(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        hcd->dwFlags |= HCAPDEV_STREAMING_PAUSED;

        // Make sure we aren't streaming
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
#ifndef __NT_BUILD__
			hcd->lpli->dwFlags |= LIF_STOPSTREAM;
#endif
			_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_RESET, 0, 0);
		}
		else
			WDMVideoStreamReset(hcd->nDeviceIndex);

        dwTicks = GetTickCount();
        lpcbuf = hcd->lpcbufList;
        while (lpcbuf && GetTickCount() < dwTicks + 1000) {
            dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                if (WaitForSingleObject(hcd->hevWait, 500) == WAIT_TIMEOUT) {
					ERRORMESSAGE(("%s: Timeout waiting for all buffers done after DVM_STREAM_RESET\r\n", _fx_));
                    break;  // looks like it isn't going to happen, so quit waiting
                }
				//else recheck done bit on current buffer
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_DONE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
            }
            else
			{
				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && (lpcbuf->vh.dwFlags & VHDR_PREPARED))
				{
					// AVICap32 clears the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_UNPREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags &= ~VHDR_PREPARED;
				}
                lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser;    // next buffer
			}
        }

		DEBUGMSG(ZONE_STREAMING, ("%s: Done trying to clear buffers\r\n", _fx_));

		// Clean up flags in order to reuse buffers - drivers do not like to be
		// given buffers with a dirty dwFlags at the start of streaming...
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser)
			lpcbuf->vh.dwFlags = 0;

        // Terminate streaming with the driver
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRes = _UninitializeVideoStream(hcd->hvideoIn);
		else
			fRes = WDMUnInitializeVideoStream(hcd->nDeviceIndex);

        if (!fRes)
		{
			ERRORMESSAGE(("%s: Error returned from XXXUninitializeVideoStream\r\n", _fx_));
		}
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}


BOOL
ReinitStreaming(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
	BOOL fRes;

	FX_ENTRY("ReinitStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB)) {
        // Tell the driver to prepare for streaming. This sets up the callback

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
#ifdef __NT_BUILD__
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD_PTR)hcd);
#else
			fRes = _InitializeVideoStream(hcd->hvideoIn, hcd->dw_usecperframe, (DWORD)hcd->wselLockedInfo << 16);
#endif
		else
			fRes = WDMInitializeVideoStream(hcd, hcd->nDeviceIndex, hcd->dw_usecperframe);

        if (!fRes)
        {
			ERRORMESSAGE(("%s: Error returned from XXXInitializeVideoStream\r\n", _fx_));
            SetLastError(ERROR_DCAP_BAD_FRAMERATE);
			DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
            return FALSE;
        }
//        Sleep (10);

        hcd->dwFlags &= ~HCAPDEV_STREAMING_PAUSED;

        // If any buffers are not marked DONE, then give them back to the driver; let all
        // DONE buffers get processed by the app first
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
            if (!(lpcbuf->vh.dwFlags & VHDR_DONE)) {
                dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

				if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				{
					// AVICap32 sets the prepared flag even if the driver failed the operation - do the same thing
					_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_PREPAREHEADER, dwlpvh, sizeof(VIDEOHDR));
					lpcbuf->vh.dwFlags |= VHDR_PREPARED;
					fRes = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
				}
				else
					fRes = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

                if (!fRes)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Failed with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
					DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
                    return FALSE;
                }
				else
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Succeeded with lpcbuf=0x%08lX, lpcbuf->vh.lpData=0x%08lX, dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
                }
            }
        }
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return TRUE;
}


//  CaptureDeviceDialog
//      Puts up one of the driver's dialogs for the user to twiddle.
//      If I can figure out ANY way to avoid this, I will.

BOOL DCAPI
CaptureDeviceDialog(
    HCAPDEV hcd,
    HWND hwndParent,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbmih   //OPTIONAL
    )
{
    DWORD dwDriverFlags = 0;
    HVIDEO hvid;
    DWORD dwSize;
    LPBITMAPINFOHEADER lpbmihCur;
#ifdef _DEBUG
    LPBITMAPINFOHEADER lpbmihPre = NULL;
#endif
    BOOL res = TRUE;

	FX_ENTRY("CaptureDeviceDialog");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (hcd->dwFlags & HCAPDEV_IN_DRIVER_DIALOG)
        return FALSE;   // don't allow re-entering

    ENTER_DCAP(hcd);

    if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
			dwDriverFlags |= VIDEO_DLG_QUERY;

		// Select the correct channel to query
		if (dwFlags & CAPDEV_DIALOG_SOURCE) {
			hvid = hcd->hvideoCapture;
			if (!(dwFlags & CAPDEV_DIALOG_QUERY)) {
				dwDriverFlags |= VIDEO_DLG_QUERY;
				if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD_PTR)hwndParent, dwDriverFlags) == DV_ERR_NOTSUPPORTED) {
					hvid = hcd->hvideoIn;
				}
				dwDriverFlags &= ~VIDEO_DLG_QUERY;
			}
		}
		else
			hvid = hcd->hvideoIn;

		// Don't stop streaming. This make the source dialog totally useless
		// if the user can't see what is going on.

#ifdef _DEBUG
		if (!lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihPre = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihPre->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihPre);
			}
			lpbmih = lpbmihPre;
		}
#endif

		// Call the driver
		hcd->dwFlags |= HCAPDEV_IN_DRIVER_DIALOG;
		if (_SendDriverMessage((HDRVR)hvid, DVM_DIALOG, (DWORD_PTR)hwndParent, dwDriverFlags)) {
			SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
			res = FALSE;    // restart still ok
		}
		else if (lpbmih) {
			dwSize = GetCaptureDeviceFormatHeaderSize(hcd);
			if (lpbmihCur = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwSize)) {
				lpbmihCur->biSize = dwSize;
				GetCaptureDeviceFormat(hcd, lpbmihCur);
				if (lpbmih->biSize != lpbmihCur->biSize ||
					lpbmih->biWidth != lpbmihCur->biWidth ||
					lpbmih->biHeight != lpbmihCur->biHeight ||
					lpbmih->biBitCount != lpbmihCur->biBitCount ||
					lpbmih->biCompression != lpbmihCur->biCompression)
				{
					ERRORMESSAGE(("%s: Format changed in dialog!!\r\n", _fx_));
#ifdef _DEBUG
					DebugBreak();
#endif
					// dialog changed format, so try to set it back
					if (!SetCaptureDeviceFormat(hcd, lpbmih, 0, 0)) {
						SetLastError (ERROR_DCAP_DIALOG_FORMAT);
						res = FALSE;
					}
				}
				LocalFree ((HANDLE)lpbmihCur);
			}
#ifdef _DEBUG
			if (lpbmih == lpbmihPre) {
				LocalFree ((HANDLE)lpbmihPre);
				lpbmih = NULL;
				lpbmihPre = NULL;
			}
#endif
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		if (hcd->dwFlags & HCAPDEV_STREAMING) {
    		// The Intel Smart Video Recorder Pro stops streaming
			// on exit from the source dialog (!?!?). Make sure
    		// we reset the streaming on any kind of device right
			// after we exit the source dialog. I verified this on
    		// the CQC, ISVR Pro, Video Stinger and Video Blaster SE100.
			// They all seem to take this pretty well...
    		TerminateStreaming(hcd);
			if (ReinitStreaming(hcd))
				StartStreaming(hcd);
			else {
				SetLastError(ERROR_DCAP_DIALOG_STREAM);
				res = FALSE;
				ERRORMESSAGE(("%s: Couldn't reinit streaming after dialog!\r\n", _fx_));
			}
		}
	}
	else
	{
		// See if we are just querying the driver for existence
		if (dwFlags & CAPDEV_DIALOG_QUERY)
		{
			// We only expose a settings dialog
			if (dwFlags & CAPDEV_DIALOG_IMAGE)
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}
		else
		{
			if (!WDMShowSettingsDialog(hcd->nDeviceIndex, hwndParent))
			{
				SetLastError(ERROR_DCAP_NO_DRIVER_SUPPORT);
				res = FALSE;
				ERRORMESSAGE(("%s: Driver does not support this dialog!\r\n", _fx_));
			}
		}

		hcd->dwFlags &= ~HCAPDEV_IN_DRIVER_DIALOG;

		// No need to restart streaming on WDM devices tested so far
		// Will add this feature if problems come up
	}

    LEAVE_DCAP(hcd);
    return res;
}


//  InitializeStreaming
//      Allocates all memory and other objects necessary for streaming.

BOOL
DCAPI
InitializeStreaming(
    HCAPDEV hcd,
    CAPSTREAM* lpcs,
    DWORD flags
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD dwRound;
    LPBITMAPINFOHEADER lpbmih;
    BOOL bHaveBuffers = FALSE;

	FX_ENTRY("InitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    // It doesn't make sense to stream with less than 2 buffers
    if (lpcs->ncCapBuffers < MIN_STREAMING_CAPTURE_BUFFERS ||
            flags & 0xfffffffe ||
            hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }
    ENTER_DCAP(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING | HCAPDEV_STREAMING_INITIALIZED |
                      HCAPDEV_STREAMING_FRAME_GRAB | HCAPDEV_STREAMING_FRAME_TIME | HCAPDEV_STREAMING_PAUSED);

    // Before allocating, make sure we have the current format.
    // This sets our idea of the current size we need for the buffer by
    // setting hcd->dwcbBuffers as a side effect
    dwRound = GetCaptureDeviceFormatHeaderSize(hcd);
    if (lpbmih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwRound)) {
        lpbmih->biSize = dwRound;
        GetCaptureDeviceFormat(hcd, lpbmih);
        LocalFree ((HANDLE)lpbmih);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

// BUGBUG - add logic to determine if we should automatically use FRAME_GRAB mode

    // Try allocating the number asked for
    if (flags & STREAMING_PREFER_FRAME_GRAB) {
        hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_GRAB;
    }

    if (!allocateBuffers(hcd, lpcs->ncCapBuffers))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Create the event we need so we can signal at interrupt time
    if (!(hcd->hevWait = CreateEvent(NULL, FALSE, FALSE, NULL))) {
		ERRORMESSAGE(("%s: CreateEvent failed!\r\n", _fx_));
        SetLastError(ERROR_OUTOFMEMORY);
        goto Error;
    }

    // Init CS used to serialize buffer list management
    InitializeCriticalSection(&hcd->bufferlistCS);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    hcd->dw_usecperframe = (unsigned)1000000000 / (unsigned)lpcs->nFPSx100;
    dwRound = hcd->dw_usecperframe % 10;  // Could have done with one less divide,
    hcd->dw_usecperframe /= 10;           // but this is clearer, and this is just
                                          // an init call...
    if (dwRound >= 5)
        hcd->dw_usecperframe++;

    hcd->lpCurrent = NULL;
    hcd->lpHead = NULL;
    hcd->lpTail = NULL;

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->pevWait = 0;
#endif

        // link the buffers into the available list
        // start with empty list
        hcd->lpHead = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR
        hcd->lpTail = (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR)); // fake CAPBUFFERHDR

        // now insert the buffers
        for (lpcbuf = hcd->lpcbufList ; lpcbuf ; lpcbuf = (LPCAPBUFFER)lpcbuf->vh.dwUser) {
	        lpcbuf->lpPrev = hcd->lpTail;
	        hcd->lpTail = lpcbuf;
            lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	        lpcbuf->lpPrev->lpNext = lpcbuf;
	        lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    }
    }
	else
	{
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			hcd->lpli->pevWait = (DWORD)OpenVxDHandle(hcd->hevWait);

			// Lock down the LOCKEDINFO structure
			if (!_LockBuffer(hcd->wselLockedInfo))
			{
				SetLastError(ERROR_OUTOFMEMORY);
				goto Error;
			}
			hcd->lpli->lp1616Head = 0;
			hcd->lpli->lp1616Tail = 0;
			hcd->lpli->lp1616Current = 0;
		}
#endif

        if (!ReinitStreaming(hcd))
            goto Error;
    }
    lpcs->hevWait = hcd->hevWait;

    // Flag that streaming is initialized
    hcd->dwFlags |= HCAPDEV_STREAMING_INITIALIZED;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

Error:
    freeBuffers(hcd);
    if (hcd->hevWait)
    {
        CloseHandle(hcd->hevWait);
#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE) && hcd->lpli->pevWait)
            _CloseVxDHandle(hcd->lpli->pevWait);
#endif
    }
    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return FALSE;
}


//  SetStreamFrameRate
//      Changes the frame rate of a stream initialized channel.
// PhilF-: This call is not used by NMCAP and NAC. So remove it or
// start using it.
BOOL
DCAPI
SetStreamFrameRate(
    HCAPDEV hcd,
    int nFPSx100
    )
{
    DWORD dwNew, dwRound;
    BOOL restart;
    BOOL res = TRUE;

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED))
    {
        // must already have the channel initialized for streaming
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ENTER_DCAP(hcd);
    restart = (hcd->dwFlags & HCAPDEV_STREAMING);

    // We were given frames per second times 100. Converting this to
    // usec per frame is 1/fps * 1,000,000 * 100. Here, do 1/fps * 1,000,000,000
    // to give us an extra digit to do rounding on, then do a final / 10
    dwNew = (unsigned)1000000000 / (unsigned)nFPSx100;
    dwRound = dwNew % 10;           // Could have done with one less divide,
    dwNew /= 10;                    // but this is clearer, and this is just an init call...
    if (dwRound >= 5)
        dwNew++;

    if (dwNew != hcd->dw_usecperframe) {

        TerminateStreaming(hcd);

        hcd->dw_usecperframe = dwNew;

        res = ReinitStreaming(hcd);

        if (restart && res)
            StartStreaming(hcd);
    }
    LEAVE_DCAP(hcd);
    return res;
}


//  UninitializeStreaming
//      Frees all memory and objects associated with streaming.

BOOL
DCAPI
UninitializeStreaming(
    HCAPDEV hcd
    )
{
    DWORD dwTicks;
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("UninitializeStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    if (!(hcd->dwFlags & HCAPDEV_STREAMING_INITIALIZED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return FALSE;
    }

    ENTER_DCAP(hcd);

    TerminateStreaming(hcd);

#ifndef __NT_BUILD__
    if (!(hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) && !(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
        // Unlock our locked structure
        _UnlockBuffer(hcd->wselLockedInfo);

        // Free the event
        _CloseVxDHandle(hcd->lpli->pevWait);
    }
#endif

    DeleteCriticalSection(&hcd->bufferlistCS);
    CloseHandle(hcd->hevWait);

    // BUGBUG - what about app still owning buffers
    // Loop through freeing all the buffers
    freeBuffers(hcd);
    hcd->dwFlags &= ~(HCAPDEV_STREAMING_INITIALIZED + HCAPDEV_STREAMING_PAUSED);

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;
}


void
CALLBACK
TimeCallback(
    UINT uID,	
    UINT uMsg,	
    HCAPDEV hcd,	
    DWORD dw1,	
    DWORD dw2	
    )
{
    hcd->dwFlags |= HCAPDEV_STREAMING_FRAME_TIME;  // flag time for a new frame
    SetEvent (hcd->hevWait);    // signal client to initiate frame grab
}

//  StartStreaming
//      Begins streaming.

BOOL
DCAPI
StartStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;
	DWORD dwRet;

	FX_ENTRY("StartStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        fRet = ((hcd->timerID = timeSetEvent(hcd->dw_usecperframe/1000, 5,
                                    (LPTIMECALLBACK)&TimeCallback,
                                    (DWORD_PTR)hcd, TIME_PERIODIC)) != 0);
    } else {
        int i;

        fRet = FALSE;

#ifndef __NT_BUILD__
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			hcd->lpli->dwFlags &= ~LIF_STOPSTREAM;
#endif

        for (i = 0; i < 5; i++) {

			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			{
				dwRet = (DWORD)_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_START, 0, 0);
				fRet = (dwRet == DV_ERR_OK);
				if (dwRet)
				{
					ERRORMESSAGE(("%s: DVM_STREAM_START failed, return code was %ld\r\n", _fx_, dwRet));
				}
			}
			else
				fRet = WDMVideoStreamStart(hcd->nDeviceIndex);

            if (fRet)
                break;
            else if (i > 1)
                Sleep(10);
        }
    }

    if (fRet)
        hcd->dwFlags |= HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  StopStreaming
//      Stops streaming but doesn't free any memory associated with streaming
//      so that it can be restarted with StartStreaming.

BOOL
DCAPI
StopStreaming(
    HCAPDEV hcd
    )
{
    BOOL fRet;

	FX_ENTRY("StopStreaming");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        timeKillEvent(hcd->timerID);
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

        // grab CS to ensure that no frame grab is in progress
        EnterCriticalSection(&hcd->bufferlistCS);
        LeaveCriticalSection(&hcd->bufferlistCS);
        fRet = TRUE;
    }
	else
	{
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_STOP, 0, 0) == DV_ERR_OK);
		else
			fRet = WDMVideoStreamStop(hcd->nDeviceIndex);
	}

    if (fRet)
        hcd->dwFlags &= ~HCAPDEV_STREAMING;

    LEAVE_DCAP(hcd);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return fRet;
}


//  GetNextReadyBuffer
//      Called by the app to find the next buffer that has been marked as
//      done by the driver and has data to be displayed.

LPSTR
DCAPI
GetNextReadyBuffer(
    HCAPDEV hcd,
    CAPFRAMEINFO* lpcfi
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
	BOOL fRet;

	FX_ENTRY("GetNextReadyBuffer");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        lpcbuf = (LPCAPBUFFER)hcd->lpHead;
        if ((hcd->dwFlags & HCAPDEV_STREAMING_FRAME_TIME) &&
            (lpcbuf != (LPCAPBUFFER)(((LPBYTE)&hcd->lpHead) - sizeof(VIDEOHDR))))  /* fake CAPBUFFERHDR */
        {
            // remove buffer from list
            EnterCriticalSection(&hcd->bufferlistCS);
            hcd->dwFlags &= ~HCAPDEV_STREAMING_FRAME_TIME;
            lpcbuf->lpPrev->lpNext = lpcbuf->lpNext;
            lpcbuf->lpNext->lpPrev = lpcbuf->lpPrev;
            lpcbuf->vh.dwFlags &= ~VHDR_INQUEUE;
            lpcbuf->vh.dwFlags |= VHDR_DONE;
            LeaveCriticalSection(&hcd->bufferlistCS);
            dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
                // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
                // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)
			if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
				fRet = (SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
			else
				fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

            if (!fRet)
			{
                // put buffer back into list
                EnterCriticalSection(&hcd->bufferlistCS);
        	    lpcbuf->lpPrev = hcd->lpTail;
        	    hcd->lpTail = lpcbuf;
                lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
        	    lpcbuf->lpPrev->lpNext = lpcbuf;
           	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
                LeaveCriticalSection(&hcd->bufferlistCS);
                lpcbuf = NULL;
            }
        } else
            lpcbuf = NULL;

    } else {

#ifdef __NT_BUILD__
        // If the current pointer is NULL, there is no frame ready so bail
        if (!hcd->lpCurrent)
	        lpcbuf = NULL;
        else {
            // Get the linear address of the buffer
            lpcbuf = hcd->lpCurrent;

            // Move to the next ready buffer
            hcd->lpCurrent = lpcbuf->lpPrev;
        }
#else
        //--------------------
        // Buffer ready queue:
        // We maintain a doubly-linked list of our buffers so that we can buffer up
        // multiple ready frames when the app isn't ready to handle them. Two things
        // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
        // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
        // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
        // buffers get added to the list asynchronously.
        //
        // To handle this, the scheme implemented here is to have a double-linked list
        // of buffers with all insertions and deletions happening in FrameCallback
        // (interrupt time). This allows the GetNextReadyBuffer routine to simply
        // find the previous block on the list any time it needs a new buffer without
        // fear of getting tromped (as would be the case if it had to dequeue buffers).
        // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
        // is done with. Dequeueing is simple since we don't need to unlink the blocks:
        // no code ever walks the list! All we have to do is move the tail pointer back up
        // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
        // since all the list manipulation is on the 16-bit side AND because MapSL is
        // much more efficient and safer than MapLS since MapLS has to allocate selectors.
        //--------------------

        // If the current pointer is NULL, there is no frame ready so bail
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!hcd->lpli->lp1616Current)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = (LPCAPBUFFER)MapSL(hcd->lpli->lp1616Current);

				// Move to the next ready buffer
				hcd->lpli->lp1616Current = lpcbuf->lp1616Prev;
			}
		}
		else
		{
			// If the current pointer is NULL, there is no frame ready so bail
			if (!hcd->lpCurrent)
				lpcbuf = NULL;
			else {
				// Get the linear address of the buffer
				lpcbuf = hcd->lpCurrent;

				// Move to the next ready buffer
				hcd->lpCurrent = lpcbuf->lpPrev;
			}
		}
#endif

    }

    if (!lpcbuf) {
        lpcfi->lpData = NULL;
		DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Fails with lpcbuf=NULL\r\n", _fx_));
        LEAVE_DCAP(hcd);
        return NULL;
    }

    // Build the CAPFRAMEINFO from the VIDEOHDR information
    lpcfi->lpData = ((LPSTR)lpcbuf) + sizeof(CAPBUFFERHDR);
    lpcfi->dwcbData = lpcbuf->vh.dwBytesUsed;
    lpcfi->dwTimestamp = lpcbuf->vh.dwTimeCaptured;
    lpcfi->dwFlags = 0;
    lpcbuf->lpNext = NULL;

	DEBUGMSG(ZONE_STREAMING, ("\r\n { %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  lpcbuf->vh.dwBufferLength=%ld\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, lpcbuf->vh.dwBufferLength));
	DEBUGMSG(ZONE_STREAMING, ("  lpcbuf->vh.dwBytesUsed=%ld\r\n  lpcbuf->vh.dwTimeCaptured=%ld\r\n  lpcbuf->vh.dwFlags=0x%08lX\r\n", lpcbuf->vh.dwBytesUsed, lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwFlags));

    LEAVE_DCAP(hcd);
    return lpcfi->lpData;
}


//  PutBufferIntoStream
//      When the app is finished using a buffer, it must allow it to be requeued
//      by calling this API.

BOOL
DCAPI
PutBufferIntoStream(
    HCAPDEV hcd,
    BYTE* lpBits
    )
{
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dwlpvh;
    BOOL res;

	FX_ENTRY("PutBufferIntoStream");

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);
    // From the CAPFRAMEINFO, find the appropriate CAPBUFFER pointer
    lpcbuf = (LPCAPBUFFER)(lpBits - sizeof(CAPBUFFERHDR));

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Returning buffer lpcbuf=0x%08lX\r\n", _fx_, lpcbuf));

    lpcbuf->vh.dwFlags &= ~VHDR_DONE;   // mark that app no longer owns buffer
    if (hcd->dwFlags & HCAPDEV_STREAMING_FRAME_GRAB) {
        EnterCriticalSection(&hcd->bufferlistCS);
	    lpcbuf->lpPrev = hcd->lpTail;
	    hcd->lpTail = lpcbuf;
        lpcbuf->lpNext = lpcbuf->lpPrev->lpNext;
	    lpcbuf->lpPrev->lpNext = lpcbuf;
	    lpcbuf->vh.dwFlags |= VHDR_INQUEUE;
	    res = TRUE;
        LeaveCriticalSection(&hcd->bufferlistCS);
    }
    else if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
        // if streaming is paused, then just return with the busy bit cleared, we'll add the
        // buffer into the stream in ReinitStreaming
        //
        // if streaming isn't paused, then call the driver to add the buffer
        dwlpvh = (DWORD_PTR)lpcbuf->vh.lpData - sizeof(CAPBUFFERHDR);
            // 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
            // 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			res = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_STREAM_ADDBUFFER, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
		else
			res = WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)dwlpvh);

		if (res)
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Succeeded with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, (" } %s: Failed with lpcbuf=0x%08lX\r\n  lpcbuf->vh.lpData=0x%08lX\r\n  dwlpvh=0x%08lX\r\n", _fx_, lpcbuf, lpcbuf->vh.lpData, dwlpvh));
		}

    }

    LEAVE_DCAP(hcd);
    return res;
}


//  CaptureFrame
LPBYTE
DCAPI
CaptureFrame(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
    DWORD_PTR dwlpvh;
    LPBYTE lpbuf;
    BOOL fRet;

	FX_ENTRY("CaptureFrame");

	INIT_CAP_DEV_LIST();

    VALIDATE_CAPDEV(hcd);

    ENTER_DCAP(hcd);
    dwlpvh = (DWORD_PTR)hbuf->vh.lpData - sizeof(CAPBUFFERHDR);
	// 16:16 ptr to vh = 16:16 ptr to data - sizeof(CAPBUFFERHDR)
	// 32bit ptr to vh = 32bit ptr to data - sizeof(CAPBUFFERHDR)

	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		fRet = (_SendDriverMessage((HDRVR)hcd->hvideoIn, DVM_FRAME, dwlpvh, sizeof(VIDEOHDR)) == DV_ERR_OK);
	else
		fRet = WDMGetFrame(hcd->nDeviceIndex, (PVOID)dwlpvh);

    if (!fRet)
	{
		ERRORMESSAGE(("%s: DVM_FRAME failed!\r\n", _fx_));
        lpbuf =  NULL;
    }
    else
        lpbuf = ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr

    LEAVE_DCAP(hcd);
    return lpbuf;
}


LPBYTE
DCAPI
GetFrameBufferPtr(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
        return ((LPBYTE)hbuf) + sizeof(CAPBUFFERHDR);   // return ptr to buffer immediately following hdr
    else
        return NULL;
}

HFRAMEBUF
DCAPI
AllocFrameBuffer(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER hbuf = NULL;
    DWORD_PTR dpBuf;

	INIT_CAP_DEV_LIST();

    ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
    if (dpBuf = (DWORD_PTR)LocalAlloc(LPTR, hcd->dwcbBuffers)) {
        hbuf = (LPCAPBUFFER)dpBuf;
#else
	if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
	{
		dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16;
        hbuf = (LPCAPBUFFER)MapSL(dpBuf);
	}
	else
	{
		dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers);
        hbuf = (LPCAPBUFFER)dpBuf;
	}

    if (dpBuf) {
#endif
        // Initialize the VIDEOHDR structure
        hbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        hbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        hbuf->vh.dwFlags = 0UL;
    }

    LEAVE_DCAP(hcd);
    return (HFRAMEBUF)hbuf;
}


VOID
DCAPI
FreeFrameBuffer(
    HCAPDEV hcd,
    HFRAMEBUF hbuf
    )
{
	INIT_CAP_DEV_LIST();

    if (hbuf)
	{
        ENTER_DCAP(hcd);

#ifdef __NT_BUILD__
		LocalFree((HANDLE)hbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
			_FreeLockableBuffer(HIWORD((DWORD)hbuf->vh.lpData));
		else
			LocalFree((HANDLE)hbuf);
#endif

        LEAVE_DCAP(hcd);
    }
}

//=====================================================================
//  Helper functions

HVIDEO
openVideoChannel(
    DWORD dwDeviceID,
    DWORD dwFlags
    )
{
    HVIDEO hvidRet = NULL;
    VIDEO_OPEN_PARMS vop;
#ifdef __NT_BUILD__
    WCHAR devName[MAX_PATH];
#else
#define LPWSTR      LPSTR
#define devName     g_aCapDevices[dwDeviceID]->szDeviceName
#endif

	FX_ENTRY("openVideoChannel");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Validate parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }
    if (dwDeviceID > (DWORD)g_cDevices)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
		DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
        return NULL;
    }

    // Prepare to call the driver
    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = 0;
    vop.dnDevNode = g_aCapDevices[dwDeviceID]->dwDevNode;

#ifdef __NT_BUILD__
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPSTR)&(g_aCapDevices[dwDeviceID]->szDeviceName),
	-1, (LPWSTR)&devName, MAX_PATH);
#endif

    hvidRet = (HVIDEO)_OpenDriver((LPWSTR)&devName, NULL, (LONG_PTR)&vop);

#ifndef NO_DRIVER_HACKS
    if (!hvidRet) {
        // backward compatibility hack
        // Some drivers fail to open because of the extra fields that were added to
        // VIDEO_OPEN_PARAMS struct for Win95.  Therefore, if the open fails, try
        // decrementing the dwSize field back to VFW1.1 size and try again.  Also try
        // decrementing the API version field.

        vop.dwSize -= sizeof(DWORD) + sizeof(LPVOID)*2;
#if 0
        while (--vop.dwVersion > 2 && !hvidRet)
#endif
        while (--vop.dwVersion > 0 && !hvidRet)
            hvidRet = (HVIDEO)_OpenDriver((LPWSTR)&devName, NULL, (LONG_PTR)&vop);
    }
#endif //NO_DRIVER_HACKS

// BUGBUG [JonT] 31-Jul-96
// Translate error values from DV_ERR_* values
    if (!hvidRet)
        SetLastError(vop.dwError);

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return hvidRet;
}


//  allocateBuffers

BOOL
allocateBuffers(
    HCAPDEV hcd,
    int nBuffers
    )
{
    int i;
    LPCAPBUFFER lpcbuf;
    DWORD_PTR dpBuf;

	FX_ENTRY("allocateBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    // Try to allocate all they ask for
    for (i = 0 ; i < nBuffers ; i++)
    {

#ifdef __NT_BUILD__
        if (!(dpBuf = (DWORD_PTR)LocalAlloc(LPTR, hcd->dwcbBuffers)))
            goto Error;
        else
			lpcbuf = (LPCAPBUFFER)dpBuf;
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			if (!(dpBuf = (DWORD)_AllocateLockableBuffer(hcd->dwcbBuffers) << 16) || !_LockBuffer((WORD)(dpBuf >> 16)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)MapSL(dpBuf);
		}
		else
		{
			if (!(dpBuf = (DWORD)LocalAlloc(LPTR, hcd->dwcbBuffers)))
				goto Error;
			else
				lpcbuf = (LPCAPBUFFER)dpBuf;
		}
#endif

        // Initialize the VIDEOHDR structure
        lpcbuf->vh.lpData = (LPBYTE)(dpBuf + sizeof(CAPBUFFERHDR));
        lpcbuf->vh.dwUser = (DWORD_PTR)hcd->lpcbufList;
        hcd->lpcbufList = lpcbuf;
        lpcbuf->vh.dwBufferLength = hcd->dwcbBuffers - sizeof(CAPBUFFERHDR);
        lpcbuf->vh.dwFlags = 0UL;
    }

#ifdef _DEBUG
	// Show buffer map
	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming Buffer map:\r\n", _fx_));
	DEBUGMSG(ZONE_STREAMING, ("Root: hcd->lpcbufList=0x%08lX\r\n", hcd->lpcbufList));
    for (i = 0, lpcbuf=hcd->lpcbufList ; i < nBuffers ; i++, lpcbuf=(LPCAPBUFFER)lpcbuf->vh.dwUser)
    {
		DEBUGMSG(ZONE_STREAMING, ("Buffer[%ld]: lpcbuf=0x%08lX\r\n             lpcbuf->vh.lpData=0x%08lX\r\n", i, lpcbuf, lpcbuf->vh.lpData));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwBufferLength=%ld\r\n             lpcbuf->vh.dwBytesUsed=%ld\r\n", lpcbuf->vh.dwBufferLength, lpcbuf->vh.dwBytesUsed));
		DEBUGMSG(ZONE_STREAMING, ("             lpcbuf->vh.dwTimeCaptured=%ld\r\n             lpcbuf->vh.dwUser=0x%08lX\r\n", lpcbuf->vh.dwTimeCaptured, lpcbuf->vh.dwUser));
	}	
#endif

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));

    return TRUE;

    // In the error case, we have to get rid of this page locked memory
Error:
    freeBuffers(hcd);
	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
    return FALSE;
}


//  freeBuffers

void
freeBuffers(
    HCAPDEV hcd
    )
{
    LPCAPBUFFER lpcbuf;

	FX_ENTRY("freeBuffers");

	DEBUGMSG(ZONE_CALLS, ("%s() - Begin\r\n", _fx_));

    while (hcd->lpcbufList)
    {
        lpcbuf = hcd->lpcbufList;
        hcd->lpcbufList = (LPCAPBUFFER)lpcbuf->vh.dwUser;

#ifdef __NT_BUILD__
		LocalFree((HANDLE)lpcbuf);
#else
		if (!(hcd->dwFlags & WDM_CAPTURE_DEVICE))
		{
			_UnlockBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
			_FreeLockableBuffer(HIWORD((DWORD)lpcbuf->vh.lpData));
		}
		else
			LocalFree((HANDLE)lpcbuf);
#endif
    }

	DEBUGMSG(ZONE_CALLS, ("%s() - End\r\n", _fx_));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32\wdmcap.cpp ===
// This file adds native support for streaming WDM video capture
// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    );

// Globals
extern HINSTANCE g_hInst;


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetDevices | This function enumerates the installed WDM video
 *   capture devices and adds them to the list of VfW capture devices.
 *
 * @parm PDWORD | [OUT] pdwOverallCPUUsage | Specifies a pointer to a DWORD to
 *   receive the current CPU usage.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 *
 * @devnote MSDN references:
 *   DirectX 5, DirectX Media, DirectShow, Application Developer's Guide
 *   "Enumerate and Access Hardware Devices in DirectShow Applications"
 ***************************************************************************/
BOOL WDMGetDevices(void)
{
	HRESULT hr;
	ICreateDevEnum *pCreateDevEnum;
	IEnumMoniker *pEm;

	FX_ENTRY("WDMGetDevices");

	// First, create a system hardware enumerator
	// This call loads the following DLLs - total 1047 KBytes!!!:
	//   'C:\WINDOWS\SYSTEM\DEVENUM.DLL' = 60 KBytes
	//   'C:\WINDOWS\SYSTEM\RPCRT4.DLL' = 316 KBytes
	//   'C:\WINDOWS\SYSTEM\CFGMGR32.DLL' = 44 KBytes
	//   'C:\WINDOWS\SYSTEM\WINSPOOL.DRV' = 23 KBytes
	//   'C:\WINDOWS\SYSTEM\COMDLG32.DLL' = 180 KBytes
	//   'C:\WINDOWS\SYSTEM\LZ32.DLL' = 24 KBytes
	//   'C:\WINDOWS\SYSTEM\SETUPAPI.DLL' = 400 KBytes
	// According to LonnyM, there's no way to go around SETUPAPI.DLL
	// when dealing with PnP device interfaces....
	if ((CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void**)&pCreateDevEnum)) != S_OK)
	{
		return FALSE;
	}

	// Second, create an enumerator for a specific type of hardware device: video capture cards only
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEm, CDEF_BYPASS_CLASS_MANAGER);
    pCreateDevEnum->Release();

	// Third, enumerate the list itself
    if (hr == S_OK)
	{
		ULONG cFetched;
		IMoniker *pM;
		IPropertyBag *pPropBag = 0;

		hr = pEm->Reset();

        while(hr = pEm->Next(1, &pM, &cFetched), hr==S_OK)
		{

			pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);

			if (pPropBag)
			{
				VARIANT var;
				LPINTERNALCAPDEV lpcd;

				if (!(lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV))))
				{
					ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
					break;  // break from the WHILE loop
				}

				// Get friendly name of the device
				var.vt = VT_BSTR;
				if ((hr = pPropBag->Read(L"FriendlyName", &var, 0)) == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceDescription, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);
				}
				else
					LoadString(g_hInst, IDS_UNKNOWN_DEVICE_NAME, lpcd->szDeviceDescription, CCHMAX(lpcd->szDeviceDescription));

				// Get DevicePath of the device
				hr = pPropBag->Read(L"DevicePath", &var, 0);
				if (hr == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceName, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);

					// There's no reg key for version information for WDM devices

					// Those devices can't be disabled from the MM control panel
					// lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

					// Mark device as a WDM device
					lpcd->dwFlags |= WDM_CAPTURE_DEVICE;

					g_aCapDevices[g_cDevices] = lpcd;
					g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
					g_cDevices++;
				}
            }
            
            pPropBag->Release();       

            pM->Release();
        }

        pEm->Release();
    }
    
	return TRUE;

}

/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMOpenDevice | This function opens a WDM video capture
 * devices and adds them to the list of VfW capture devices.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to open.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMOpenDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMOpenDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) != 0));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) == 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Open streaming class driver
	CWDMPin *pCWDMPin;
	if (!(pCWDMPin = new CWDMPin(dwDeviceID)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMPin class\r\n", _fx_));
		return FALSE;
	}
	else
	{
		// Open the WDM driver and create a video pin
		if (!pCWDMPin->OpenDriverAndPin())
		{
			goto Error0;
		}
	}

	// Create video stream on the pin
    CWDMStreamer *pCWDMStreamer;
	if (!(pCWDMStreamer = new CWDMStreamer(pCWDMPin)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMStreamer\r\n", _fx_));
		goto Error0;
	}

	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)pCWDMStreamer;

	return TRUE;

Error0:
	delete pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;

	return FALSE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMCloseDevice | This function closes a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to close.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMCloseDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMCloseDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close video channel
	if (g_aCapDevices[dwDeviceID]->pCWDMStreamer)
	{
		delete ((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer);
		g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;
	}

	// Close driver and pin
	if (g_aCapDevices[dwDeviceID]->pCWDMPin)
	{
		delete ((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
		g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	}

	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormatSize | This function returns the size of the
 *   structure used to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @rdesc Always returns the size of a BITMAPINFOHEADER structure.
 ***************************************************************************/
DWORD WDMGetVideoFormatSize(DWORD dwDeviceID)
{
	FX_ENTRY("WDMGetVideoFormatSize");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	DEBUGMSG(ZONE_INIT, ("%s: return size=%ld\r\n", _fx_, (DWORD)sizeof(BITMAPINFOHEADER)));

	// Return size of BITMAPINFOHEADER structure
	return (DWORD)sizeof(BITMAPINFOHEADER);
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMGetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Make sure the size information is correct
	if (!pbmih->biSize)
		pbmih->biSize = WDMGetVideoFormatSize(dwDeviceID);

	// Get the BITMAPINFOHEADER structure
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih, (WORD)pbmih->biSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMSetVideoFormat | This function sets the video format on
 *   a WDM video capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure describing the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMSetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMSetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih && pbmih->biSize);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih ||!pbmih->biSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Set the BITMAPINFOHEADER on the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->SetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		// PhilF-: This sometimes fail, but we keep on streaming... fix that
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoPalette(DWORD dwDeviceID, CAPTUREPALETTE* lpcp, DWORD dwcbSize)
{
	FX_ENTRY("WDMGetVideoPalette");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, lpcp=0x%08lX\r\n", _fx_, dwDeviceID, lpcp));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && lpcp);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !lpcp)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the palette information
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetPaletteInfo(lpcp, dwcbSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeExternalVideoStream | This function initializes
 *   an input video stream on the external video channel of a WDM video
 *   capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeExternalVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMInitializeExternalVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));
	DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeVideoStream | This function initializes
 *   an input video stream on the videoin channel of a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeVideoStream(HCAPDEV hcd, DWORD dwDeviceID, DWORD dwMicroSecPerFrame)
{
	FX_ENTRY("WDMInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, FPS=%ld\r\n", _fx_, dwDeviceID, 1000000UL / dwMicroSecPerFrame));

    VIDEO_STREAM_INIT_PARMS vsip = {0};

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize channel
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD)WDMFrameCallback;
    vsip.dwCallbackInst = (DWORD)hcd;
    vsip.dwFlags = CALLBACK_FUNCTION;
    // vsip.hVideo = (DWORD)hvideo;

	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Open(&vsip)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMUnInitializeVideoStream | This function requests a WDM
 *   video capture device to close a capture stream on the videoin channel.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMUnInitializeVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMUnInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close streaming on channel
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Close()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStart | This function requests a WDM video
 *   capture device to start a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to start.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStart(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStart");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Start streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Start()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStop | This function requests a WDM video
 *   capture device to stop a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to freeze.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStop(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStop");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Stop streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Stop()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamReset | This function resets a WDM video capture
 *   devie to stop input of a capture stream and return all buffers to the
 *   client.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to reset.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamReset(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamReset");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Reset()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamAddBuffer | This function requests a WDM video
 *   capture device to add an empty input buffer to its input buffer queue.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamAddBuffer(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMVideoStreamAddBuffer");

	DEBUGMSG(ZONE_STREAMING, ("      %s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->AddBuffer((LPVIDEOHDR)pBuff)))
	{
		DEBUGMSG(ZONE_STREAMING, ("      %s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("      %s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetFrame | This function requests a WDM video
 *   capture device to transfer a single frame to or from the video device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @parm PVOID | [OUT] pBuff | Specifies a pointer to a <t VIDEOHDR> structure.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetFrame(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMGetFrame");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	LPVIDEOHDR lpVHdr = (LPVIDEOHDR)pBuff;

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the frame from the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetFrame(lpVHdr))
		return TRUE;
	else
		return FALSE;

}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMShowSettingsDialog | This function puts up a property
 *   sheet with a VideoProcAmp and CameraControl page for a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMShowSettingsDialog(DWORD dwDeviceID, HWND hWndParent)
{
	PROPSHEETHEADER Psh;
	HPROPSHEETPAGE	Pages[MAX_PAGES];

	FX_ENTRY("WDMShowSettingsDialog");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize property sheet header	and common controls
	Psh.dwSize		= sizeof(Psh);
	Psh.dwFlags		= PSH_DEFAULT;
	Psh.hInstance	= g_hInst;
	Psh.hwndParent	= hWndParent;
	Psh.pszCaption	= g_aCapDevices[dwDeviceID]->szDeviceDescription;
	Psh.nPages		= 0;
	Psh.nStartPage	= 0;
	Psh.pfnCallback	= NULL;
	Psh.phpage		= Pages;

    // Create the video settings property page and add it to the video settings sheet
    CWDMDialog VideoSettings(IDD_VIDEO_SETTINGS, NumVideoSettings, PROPSETID_VIDCAP_VIDEOPROCAMP, g_VideoSettingControls, g_VideoSettingsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = VideoSettings.Create())
		Psh.nPages++;

    // Create the camera control property page and add it to the video settings sheet
    CWDMDialog CamControl(IDD_CAMERA_CONTROL, NumCameraControls, PROPSETID_VIDCAP_CAMERACONTROL, g_CameraControls, g_CameraControlsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = CamControl.Create())
		Psh.nPages++;

	// Put up the property sheet
	if (Psh.nPages && PropertySheet(&Psh) >= 0)
		return TRUE;
	else
		return FALSE;

}


void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    )
{
	FX_ENTRY("WDMFrameCallback");

	DEBUGMSG(ZONE_CALLBACK, ("    %s: wMsg=%s, hcd=0x%08lX, lpcbuf=0x%08lX, hcd->hevWait=0x%08lX\r\n", _fx_, (wMsg == MM_DRVM_OPEN) ? "MM_DRVM_OPEN" : (wMsg == MM_DRVM_CLOSE) ? "MM_DRVM_CLOSE" : (wMsg == MM_DRVM_ERROR) ? "MM_DRVM_ERROR" : (wMsg == MM_DRVM_DATA) ? "MM_DRVM_DATA" : "MM_DRVM_?????", hcd, lpcbuf, hcd->hevWait));

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - no data\r\n", _fx_));
	    SetEvent(hcd->hevWait);
	    return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (hcd->lpTail != hcd->lpCurrent)
	    hcd->lpTail = hcd->lpTail->lpPrev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!hcd->lpTail)
	    hcd->lpHead = NULL;

    // Add the new buffer to the ready queue
    lpcbuf->lpNext = hcd->lpHead;
    lpcbuf->lpPrev = NULL;
    if (hcd->lpHead)
	    hcd->lpHead->lpPrev = lpcbuf;
    else
	    hcd->lpTail = lpcbuf;
    hcd->lpHead = lpcbuf;

#if 1
    if (hcd->lpCurrent) {
        if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
    	    // if client hasn't consumed last frame, then release it
			lpcbuf = hcd->lpCurrent;
    	    hcd->lpCurrent = hcd->lpCurrent->lpPrev;
			DEBUGMSG(ZONE_CALLBACK, ("    %s: We already have current buffer (lpcbuf=0x%08lX). Returning this buffer to driver. Set new current buffer hcd->lpCurrent=0x%08lX\r\n", _fx_, lpcbuf, hcd->lpCurrent));
    	    if (!WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)lpcbuf))
			{
				ERRORMESSAGE(("    %s: Attempt to reuse unconsumed buffer failed\r\n", _fx_));
			}
    	}
    }
    else {
#else
    if (!hcd->lpCurrent) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
	    hcd->lpCurrent = hcd->lpTail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - some data\r\n", _fx_));
    SetEvent(hcd->hevWait);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\wdmdialg.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.cpp | Source file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"

// Globals
extern HINSTANCE g_hInst;

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CWDMDialog | Create | This function creates a new
 *    page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CWDMDialog::Create()
{
    PROPSHEETPAGE psp;

    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = g_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(m_DlgID);
    psp.pfnDlgProc    = (DLGPROC)BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc BOOL | CWDMDialog | BaseDlgProc | This function implements
 *    the dialog box procedure for the page of a property sheet.
 *
 *  @parm HWND | hDlg | Handle to dialog box.
 *
 *  @parm UINT | uMessage | Message sent to the dialog box.
 *
 *  @parm WPARAM | wParam | First message parameter.
 *
 *  @parm LPARAM | lParam | Second message parameter.
 *
 *  @rdesc Except in response to the WM_INITDIALOG message, the dialog box
 *    procedure returns nonzero if it processes the message, and zero if it
 *    does not.
 ***************************************************************************/
BOOL CALLBACK CWDMDialog::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CWDMDialog * pSV = (CWDMDialog*)GetWindowLongPtr(hDlg,DWLP_USER);

	FX_ENTRY("CWDMDialog::BaseDlgProc");

    switch (uMessage)
    {
        case WM_HELP:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("conf.hlp"), HELP_WM_HELP, (DWORD_PTR)pSV->m_pdwHelp);
			break;

        case WM_CONTEXTMENU:
            if (pSV->m_pdwHelp)
                WinHelp((HWND)wParam, TEXT("conf.hlp"), HELP_CONTEXTMENU, (DWORD_PTR)pSV->m_pdwHelp);
			break;

        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
				pSV=(CWDMDialog*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)pSV);
				pSV->m_bInit = FALSE;
				pSV->m_bChanged = FALSE;
				return TRUE;
			}
			break;

        case WM_COMMAND:
            if (pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam), HIWORD(wParam));
                if (!iRet && pSV->m_bInit)
				{
					PropSheet_Changed(GetParent(pSV->m_hDlg), pSV->m_hDlg);
					pSV->m_bChanged = TRUE;
				}
                return iRet;
            }
			break;

        case WM_HSCROLL:
			if (pSV && pSV->m_pCWDMPin && pSV->m_pPC)
			{
				HWND hwndControl = (HWND) lParam;
				HWND hwndSlider;
				ULONG i;
				TCHAR szTemp[32];

				for (i = 0 ; i < pSV->m_dwNumControls ; i++)
				{
					hwndSlider = GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider);

					// find matching slider
					if (hwndSlider == hwndControl)
					{
						LONG lValue = (LONG)SendMessage(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider), TBM_GETPOS, 0, 0);
						pSV->m_pCWDMPin->SetPropertyValue(pSV->m_guidPropertySet, pSV->m_pPC[i].uiProperty, lValue, KSPROPERTY_FLAGS_MANUAL, pSV->m_pPC[i].ulCapabilities);
						pSV->m_pPC[i].lCurrentValue = lValue;
						wsprintf(szTemp,"%d", lValue);
						SetWindowText(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiCurrent), szTemp);
						break;
					}
				}
			}

			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->SetActive();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						// Since we apply the changes on the fly when the user moves the slide bars,
						// there isn't much left to do on PSN_APPLY...
						if (pSV->m_bChanged)
							pSV->m_bChanged = FALSE;
						return FALSE;
						break;

					case PSN_QUERYCANCEL:
						return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc void | CWDMDialog | CWDMDialog | Property page class constructor.
 *
 *  @parm int | DlgId | Resource ID of the property page dialog.
 *
 *  @parm DWORD | dwNumControls | Number of controls to display in the page.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are showing in
 *    the property page.
 *
 *  @parm PPROPSLIDECONTROL | pPC | Pointer to the list of slider controls
 *    to be displayed in the property page.
 *
 *  @parm PDWORD | pdwHelp | Pointer to the list of help IDs to be displayed
 *    in the property page.
 *
 *  @parm CWDMPin * | pCWDMPin | Pointer to the kernel streaming object
 *    we will query the property on.
 ***************************************************************************/
CWDMDialog::CWDMDialog(int DlgId, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, PDWORD pdwHelp, CWDMPin *pCWDMPin)
{
	FX_ENTRY("CWDMDialog::CWDMDialog");

	ASSERT(dwNumControls);
	ASSERT(pPC);

	m_DlgID = DlgId;
	m_pdwHelp = pdwHelp;
	m_pCWDMPin = pCWDMPin;
	m_dwNumControls = dwNumControls;
	m_guidPropertySet = guidPropertySet;
	m_pPC = pPC;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | SetActive | This function handles
 *    PSN_SETACTIVE by intializing all the property page controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::SetActive()
{
	FX_ENTRY("CWDMDialog::SetActive");

    DEBUGMSG(ZONE_DIALOGS, ("%s()\n", _fx_));

    if (!m_pCWDMPin || !m_pPC)
        return 0;

    // Returns zero to accept the activation or
    // -1 to activate the next or previous page
    // (depending on whether the user chose the Next or Back button)
    LONG i;
    EnableWindow(m_hDlg, TRUE);

    if (m_bInit)
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplay[256];

    for (i = j = 0 ; i < (LONG)m_dwNumControls; i++)
	{
        // Get the current value
        if (m_pCWDMPin->GetPropertyValue(m_guidPropertySet, m_pPC[i].uiProperty, &lValue, &ulFlags, &ulCapabilities))
		{
            LoadString(g_hInst, m_pPC[i].uiString, szDisplay, sizeof(szDisplay));
            DEBUGMSG(ZONE_DIALOGS, ("%s: szDisplay = %s\n", _fx_, szDisplay));
            SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), szDisplay);

            // Get the Range of Values possible.
            if (m_pCWDMPin->GetRangeValues(m_guidPropertySet, m_pPC[i].uiProperty, &lMin, &lMax, &lStep))
			{
				HWND hTB = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

				DEBUGMSG(ZONE_DIALOGS, ("(%d, %d) / %d = %d \n", lMin, lMax, lStep, (lMax-lMin)/lStep));

				SendMessage(hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0);
				SendMessage(hTB, TBM_SETRANGE, 0, MAKELONG(lMin, lMax));
			}
            else
			{
                ERRORMESSAGE(("%s:Cannot get range values for this property ID = %d\n", _fx_, m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), TRUE);

			SendMessage(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TBM_SETPOS, TRUE, lValue);
			wsprintf(szDisplay,"%d", lValue);
			SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szDisplay);

            DEBUGMSG(ZONE_DIALOGS, ("%s: Capability = 0x%08lX; Flags=0x%08lX; lValue=%d\r\n", _fx_, ulCapabilities, ulFlags, lValue));
            DEBUGMSG(ZONE_DIALOGS, ("%s: switch(%d): \n", _fx_, ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO))
			{
				case KSPROPERTY_FLAGS_MANUAL:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto
					break;

				case KSPROPERTY_FLAGS_AUTO:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider;
					// always auto!
					SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;

				case (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO):
					// Set flags
					if (ulFlags & KSPROPERTY_FLAGS_AUTO)
					{
						DEBUGMSG(ZONE_DIALOGS, ("%s: Auto (checked) and slider disabled\n", _fx_));
						// Set auto check box; greyed out slider
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
					}
					else
					{
						// Unchecked auto; enable slider
						SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
						EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
					}
					break;

				case 0:
				default:
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
					EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
					break;
            }

            j++;

        }
		else
		{
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);
        }
    }

    // Disable the "default" push button;
    // or inform user that no control is enabled.
    if (j == 0)
        EnableWindow(GetDlgItem(m_hDlg, IDC_DEFAULT), FALSE);

    return 0;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | DoCommand | This function handles WM_COMMAND. This
 *    is where a click on the Default button or one of the Auto checkboxes
 *    is handled
 *
 *  @parm WORD | wCmdID | Command ID.
 *
 *  @parm WORD | hHow | Notification code.
 *
 *  @rdesc Always returns 1.
 ***************************************************************************/
int CWDMDialog::DoCommand(WORD wCmdID, WORD hHow)
{
    // If a user select default settings of the video format
    if (wCmdID == IDC_DEFAULT)
	{
        if (m_pCWDMPin && m_pPC)
		{
            HWND hwndSlider;
            LONG  lDefValue;
			TCHAR szTemp[32];

            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                hwndSlider = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider))
				{
                    if (m_pCWDMPin->GetDefaultValue(m_guidPropertySet, m_pPC[i].uiProperty, &lDefValue))
					{
                        if (lDefValue != m_pPC[i].lCurrentValue)
						{
                            m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
							SendMessage(hwndSlider, TBM_SETPOS, TRUE, lDefValue);
							wsprintf(szTemp,"%d", lDefValue);
							SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szTemp);
							m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 1;
    }
	else if (hHow == BN_CLICKED)
	{
        if (m_pCWDMPin && m_pPC)
		{
            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
			{
                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID)
				{
                    if (BST_CHECKED == SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_GETCHECK, 1, 0))
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                    }
					else
					{
                        m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                    }
                    break;
                }
            }
        }
    }

    return 1;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | QueryCancel | This function handles
 *    PSN_QUERYCANCEL by resetting the values of the controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::QueryCancel()
{
    if (m_pCWDMPin && m_pPC)
	{
        for (ULONG i = 0 ; i < m_dwNumControls ; i++)
		{
            if (IsWindowEnabled(GetDlgItem(m_hDlg, m_pPC[i].uiSlider)))
			{
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue)
                    m_pCWDMPin->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }

    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\1632com.h ===
//  1632COM.H
//
//  Created 19-Jul-96 [JonT]

#ifndef _1632COM_H
#define _1632COM_H

// Debug stuff
#if defined (DEBUG) || defined (_DEBUG)
#define Assert(x, msg) { if (!(x)) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); DebugBreak(); } }
#define DebugSpew(msg) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); }
#else
#define Assert(x, msg)
#define DebugSpew(msg)
#endif

#endif // #ifndef _1632COM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\wdmdrivr.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMDRIVER
 *
 *  @module WDMDrivr.cpp | Include file for <c CWDMDriver> class used to
 *    access the streaming class driver using IOctls.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | CWDMDriver | Driver class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMDriver::CWDMDriver(DWORD dwDeviceID) 
{
	m_hDriver = (HANDLE)NULL;
	m_pDataRanges = (PDATA_RANGES)NULL;

	m_dwDeviceID = dwDeviceID;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc void | CWDMDriver | ~CWDMDriver | Driver class destructor. Closes
 *    the driver file handle and releases the video data range memory.
 ***************************************************************************/
CWDMDriver::~CWDMDriver()
{
	if (m_hDriver) 
		CloseDriver();

	if (m_pDataRanges)
	{
		delete [] m_pDataRanges;
		m_pDataRanges = (PDATA_RANGES)NULL;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CreateDriverSupportedDataRanges | This
 *    function builds the list of video data ranges supported by the capture
 *    device.
 *
 *  @rdesc Returns the number of valid data ranges in the list.
 ***************************************************************************/
DWORD CWDMDriver::CreateDriverSupportedDataRanges()
{
	FX_ENTRY("CWDMDriver::CreateDriverSupportedDataRanges");

	DWORD cbReturned;
	DWORD dwSize = 0UL;

	// Initialize property structure to get data ranges
	KSP_PIN KsProperty = {0};

	KsProperty.PinId			= 0; // m_iPinNumber;
	KsProperty.Property.Set		= KSPROPSETID_Pin;
	KsProperty.Property.Id		= KSPROPERTY_PIN_DATARANGES ;
	KsProperty.Property.Flags	= KSPROPERTY_TYPE_GET;

	// Get the size of the data range structure
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
	{
		ERRORMESSAGE(("%s: Couldn't get the size for the data ranges\r\n", _fx_));
		return 0UL;
	}

	DEBUGMSG(ZONE_INIT, ("%s: GetData ranges needs %d bytes\r\n", _fx_, dwSize));

	// Allocate memory to hold data ranges
	if (m_pDataRanges)
		delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES) new BYTE[dwSize];

	if (!m_pDataRanges)
	{
		ERRORMESSAGE(("%s: Couldn't allocate memory for the data ranges\r\n", _fx_));
		return 0UL;
	}

	// Really get the data ranges
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), m_pDataRanges, dwSize, &cbReturned) == 0)
	{
		ERRORMESSAGE(("%s: Problem getting the data ranges themselves\r\n", _fx_));
		goto MyError1;
	}

	// Sanity check
	if (cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0)
	{
		ERRORMESSAGE(("%s: cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0\r\n", _fx_));
		goto MyError1;
	}

	return m_pDataRanges->Count;

MyError1:
	delete [] m_pDataRanges;
	m_pDataRanges = (PDATA_RANGES)NULL;
	return 0UL;

}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | OpenDriver | This function opens a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::OpenDriver()
{
	FX_ENTRY("CWDMDriver::OpenDriver");

	// Don't re-open the driver
	if (m_hDriver)
	{
		DEBUGMSG(ZONE_INIT, ("%s: Class driver already opened\r\n", _fx_));
		return TRUE;
	}

	// Validate driver path
	if (lstrlen(g_aCapDevices[m_dwDeviceID]->szDeviceName) == 0)
	{
		ERRORMESSAGE(("%s: Invalid driver path\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Opening class driver '%s'\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName));

	// All we care is to wet the hInheritHanle = TRUE;
	SECURITY_ATTRIBUTES SecurityAttributes;
	SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);  // use pointers
	SecurityAttributes.bInheritHandle = TRUE;
	SecurityAttributes.lpSecurityDescriptor = NULL; // GetInitializedSecurityDescriptor();

	// Really open the driver
	if ((m_hDriver = CreateFile(g_aCapDevices[m_dwDeviceID]->szDeviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &SecurityAttributes, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) == INVALID_HANDLE_VALUE)
	{
		ERRORMESSAGE(("%s: CreateFile failed with Path=%s GetLastError()=%d\r\n", _fx_, g_aCapDevices[m_dwDeviceID]->szDeviceName, GetLastError()));
		m_hDriver = (HANDLE)NULL;
		return FALSE;
	}

	// If there is no valid data range, we cannot stream
	if (!CreateDriverSupportedDataRanges())
	{
		CloseDriver();
		return FALSE;
	}
	else
		return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc DWORD | CWDMDriver | CloseDriver | This function closes a driver
 *    file handle to the capture device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::CloseDriver()
{
	FX_ENTRY("CWDMDriver::CloseDriver");

	BOOL bRet = TRUE;

	if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE))
	{
		if (!(bRet = CloseHandle(m_hDriver)))
		{
			ERRORMESSAGE(("%s: CloseHandle() failed with GetLastError()=%d\r\n", _fx_, GetLastError()));
		}
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: Nothing to close\r\n", _fx_));
	}

	m_hDriver = (HANDLE)NULL;

	return bRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | DeviceIoControl | This function wraps around
 *    ::DeviceIOControl.
 *
 *  @parm HANDLE | hFile | Handle to the device that is to perform the
 *    operation.
 *
 *  @parm DWORD | dwIoControlCode | Specifies the control code for the
 *    operation.
 *
 *  @parm LPVOID | lpInBuffer | Pointer to a buffer that contains the data
 *    required to perform the operation.
 *
 *  @parm DWORD | nInBufferSize | Specifies the size, in bytes, of the buffer
 *    pointed to by <p lpInBuffer>.
 *
 *  @parm LPVOID | lpOutBuffer | Pointer to a buffer that receives the
 *    operation's output data.
 *
 *  @parm DWORD | nOutBufferSize | Specifies the size, in bytes, of the
 *    buffer pointed to by <p lpOutBuffer>.
 *
 *  @parm LPDWORD | lpBytesReturned | Pointer to a variable that receives the
 *    size, in bytes, of the data stored into the buffer pointed to by
 *    <p lpOutBuffer>.
 *
 *  @parm BOOL | bOverlapped | If TRUE, the operation is performed
 *    asynchronously, if FALSE, the operation is synchronous.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::DeviceIoControl(HANDLE hFile, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped)
{
	FX_ENTRY("CWDMDriver::DeviceIoControl");

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
	{
		LPOVERLAPPED lpOverlapped=NULL;
		BOOL bRet;
		OVERLAPPED ov;
		DWORD dwErr;

		if (bOverlapped)
		{
			ov.Offset            = 0;
			ov.OffsetHigh        = 0;
			ov.hEvent            = CreateEvent( NULL, FALSE, FALSE, NULL );
			if (ov.hEvent == (HANDLE) 0)
			{
				ERRORMESSAGE(("%s: CreateEvent has failed\r\n", _fx_));
			}
			lpOverlapped        =&ov;
		}

		bRet = ::DeviceIoControl(hFile, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);

		if (bOverlapped)
		{
			BOOL bShouldBlock=FALSE;

			if (!bRet)
			{
				dwErr=GetLastError();
				switch (dwErr)
				{
					case ERROR_IO_PENDING:    // the overlapped IO is going to take place.
						bShouldBlock=TRUE;
						break;

					default:    // some other strange error has happened.
						ERRORMESSAGE(("%s: DevIoControl failed with GetLastError=%d\r\n", _fx_, dwErr));
						break;
				}
			}

			if (bShouldBlock)
			{
#ifdef _DEBUG
				DWORD    tmStart, tmEnd, tmDelta;
				tmStart = timeGetTime();
#endif

				DWORD dwRtn = WaitForSingleObject( ov.hEvent, 1000 * 10);  // USB has a max of 5 SEC bus reset

#ifdef _DEBUG
				tmEnd = timeGetTime();
				tmDelta = tmEnd - tmStart;
				if (tmDelta >= 1000)
				{
					ERRORMESSAGE(("%s: WaitObj waited %d msec\r\n", _fx_, tmDelta));
				}
#endif

				switch (dwRtn)
				{
					case WAIT_ABANDONED:
						ERRORMESSAGE(("%s: WaitObj: non-signaled ! WAIT_ABANDONED!\r\n", _fx_));
						bRet = FALSE;
						break;

					case WAIT_OBJECT_0:                    
						bRet = TRUE;
						break;

					case WAIT_TIMEOUT:
#ifdef _DEBUG
						ERRORMESSAGE(("%s: WaitObj: TIMEOUT after %d msec! rtn FALSE\r\n", _fx_, tmDelta));
#endif
						bRet = FALSE;
						break;

					default:
						ERRORMESSAGE(("%s: WaitObj: unknown return ! rtn FALSE\r\n", _fx_));
						bRet = FALSE;
						break;
				}
			}

			CloseHandle(ov.hEvent);
		}

		return bRet;
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetPropertyValue | This function gets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plValue | Pointer to a LONG to receive the current value.
 *
 *  @parm PULONG | pulFlags | Pointer to a ULONG to receive the current
 *    flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm PULONG | pulCapabilities | Pointer to a ULONG to receive the
 *    capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities)
{
	FX_ENTRY("CWDMDriver::GetPropertyValue");

	ULONG cbReturned;        

	// Inititalize video property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;
	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S));

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
	VideoProperty.Flags          = 0;

	// Get property value from driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: This property is not supported by this minidriver/device\r\n", _fx_));
		return FALSE;
	}

	*plValue         = VideoProperty.Value;
	*pulFlags        = VideoProperty.Flags;
	*pulCapabilities = VideoProperty.Capabilities;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetDefaultValue | This function gets the
 *    default value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plDefValue | Pointer to a LONG to receive the default value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue)    
{
	FX_ENTRY("CWDMDriver::GetDefaultValue");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;

	// Get the default values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	// Sanity check
	if (proList.proDesc.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION))
		return FALSE;
	else
	{
		*plDefValue = proList.ulData;
		return TRUE;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | GetRangeValues | This function gets the
 *    range values of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plMin | Pointer to a LONG to receive the minimum value.
 *
 *  @parm PLONG | plMax | Pointer to a LONG to receive the maximum value.
 *
 *  @parm PLONG | plStep | Pointer to a LONG to receive the step value.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMDriver::GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep)
{
	FX_ENTRY("CWDMDriver::GetRangeValues");

	ULONG cbReturned;        

	KSPROPERTY          Property;
	PROCAMP_MEMBERSLIST proList;

	// Initialize property structures
	ZeroMemory(&Property, sizeof(KSPROPERTY));
	ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

	Property.Set   = guidPropertySet;
	Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;

	// Get range values from the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *get* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	*plMin  = proList.proData.Bounds.SignedMinimum;
	*plMax  = proList.proData.Bounds.SignedMaximum;
	*plStep = proList.proData.SteppingDelta;

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERMETHOD
 *
 *  @mfunc BOOL | CWDMDriver | SetPropertyValue | This function sets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm LONG | lValue | New value.
 *
 *  @parm ULONG | ulFlags | New flags. We only care about KSPROPERTY_*_FLAGS_MANUAL
 *    or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm ULONG | ulCapabilities | New capabilities. We only care about 
 *    KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
BOOL CWDMDriver::SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities)
{
	FX_ENTRY("CWDMDriver::SetPropertyValue");

	ULONG cbReturned;        

	// Initialize property structure
	KSPROPERTY_VIDEOPROCAMP_S  VideoProperty;

	ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

	VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
	VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
	VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;

	VideoProperty.Flags        = ulFlags;
	VideoProperty.Value        = lValue;
	VideoProperty.Capabilities = ulCapabilities;

	// Set the property value on the driver
	if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
	{
		ERRORMESSAGE(("%s: Couldn't *set* the current property of the control\r\n", _fx_));
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\wdmstrmr.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMStrmr.cpp | Source file for <c CWDMStreamer> class used to get a
 *    stream of video data flowing from WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | CWDMStreamer | WDM filter class constructor.
 *
 *  @parm CWDMPin * | pWDMVideoPin | Pointer to the kernel streaming
 *    object we will get the frames from.
 ***************************************************************************/
CWDMStreamer::CWDMStreamer(CWDMPin * pWDMVideoPin)
{
	m_pWDMVideoPin = pWDMVideoPin;
	m_lpVHdrFirst = (LPVIDEOHDR)NULL;
	m_lpVHdrLast = (LPVIDEOHDR)NULL;
	m_fVideoOpen = FALSE;
	m_fStreamingStarted = FALSE;
	m_pBufTable = (PBUFSTRUCT)NULL;
	m_cntNumVidBuf = 0UL;
	m_idxNextVHdr = 0UL;
    m_hThread = NULL;
	m_bKillThread = FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | videoCallback | This function calls the
 *    callback function provided by the appplication.
 *
 *  @parm WORD | msg | Message value.
 *
 *  @parm DWORD | dwParam1 | 32-bit message-dependent parameter.
 ***************************************************************************/
void CWDMStreamer::videoCallback(WORD msg, DWORD_PTR dwParam1)
{
    if (m_CaptureStreamParms.dwCallback)
        DriverCallback (m_CaptureStreamParms.dwCallback, HIWORD(m_CaptureStreamParms.dwFlags), (HDRVR) m_CaptureStreamParms.hVideo, msg, m_CaptureStreamParms.dwCallbackInst, dwParam1, 0UL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc LPVIDEOHDR | CWDMStreamer | DeQueueHeader | This function dequeues a
 *    video buffer from the list of video buffers used for streaming.
 *
 *  @rdesc Returns a valid pointer if successful, or NULL otherwise.
 ***************************************************************************/
LPVIDEOHDR CWDMStreamer::DeQueueHeader()
{
	FX_ENTRY("CWDMStreamer::DeQueueHeader");

    LPVIDEOHDR lpVHdr;

    if (m_pBufTable)
	{
        if (m_pBufTable[m_idxNextVHdr].fReady)
		{
			DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

            lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
            lpVHdr->dwFlags &= ~VHDR_INQUEUE;
            m_pBufTable[m_idxNextVHdr].fReady = FALSE;
        }
		else
		{
            m_idxNextVHdr++;
            if (m_idxNextVHdr >= m_cntNumVidBuf)
                m_idxNextVHdr = 0;

			if (m_pBufTable[m_idxNextVHdr].fReady)
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: DeQueuing idxNextVHdr (idx=%d) with data to be filled at lpVHdr=0x%08lX\r\n", _fx_, m_idxNextVHdr, m_pBufTable[m_idxNextVHdr].lpVHdr));

				lpVHdr = m_pBufTable[m_idxNextVHdr].lpVHdr;
				lpVHdr->dwFlags &= ~VHDR_INQUEUE;
				m_pBufTable[m_idxNextVHdr].fReady = FALSE;
			}
			else
			{
				DEBUGMSG(ZONE_STREAMING, ("  %s: idxNextVHdr (idx=%d) has not been returned by client\r\n", _fx_, m_idxNextVHdr));
				lpVHdr = NULL;
			}
		}
    }
	else
	{
        lpVHdr = m_lpVHdrFirst;

        if (lpVHdr) {

            lpVHdr->dwFlags &= ~VHDR_INQUEUE;

            m_lpVHdrFirst = (LPVIDEOHDR)(lpVHdr->dwReserved[0]);

            if (m_lpVHdrFirst == NULL)
                m_lpVHdrLast = NULL;
        }
    }

    return lpVHdr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | QueueHeader | This function actually adds the
 *    video buffer to the list of video buffers used for streaming.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 ***************************************************************************/
void CWDMStreamer::QueueHeader(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::QueHeader");

	// Initialize status flags
    lpVHdr->dwFlags &= ~VHDR_DONE;
    lpVHdr->dwFlags |= VHDR_INQUEUE;
    lpVHdr->dwBytesUsed = 0;

    // Add buffer to list
    if (m_pBufTable)
	{
		if (lpVHdr->dwReserved[1] < m_cntNumVidBuf)
		{
			if (m_pBufTable[lpVHdr->dwReserved[1]].lpVHdr != lpVHdr)
			{
				DEBUGMSG(ZONE_STREAMING, ("        %s: index (%d) Match but lpVHdr does not(%x)\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
			}
			m_pBufTable[lpVHdr->dwReserved[1]].fReady = TRUE;
			DEBUGMSG(ZONE_STREAMING, ("        %s: Buffer lpVHdr=0x%08lX was succesfully queued\r\n", _fx_, lpVHdr));
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("        %s: lpVHdr->dwReserved[1](%d) >= m_cntNumVidBuf (%d)\r\n", _fx_, lpVHdr->dwReserved[1], m_cntNumVidBuf));
		}
	}
	else
	{
		*(lpVHdr->dwReserved) = NULL;

		if (m_lpVHdrLast)
			*(m_lpVHdrLast->dwReserved) = (DWORD_PTR)lpVHdr;
		else
			m_lpVHdrFirst = lpVHdr;

		m_lpVHdrLast = lpVHdr;
	}
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | AddBuffer | This function adds a buffer to the
 *    list of video buffers to be used when streaming video data from the WDM
 *    device.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_ADDBUFFER message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::AddBuffer(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::AddBuffer");

	ASSERT(m_fVideoOpen && lpVHdr && !(lpVHdr->dwFlags & VHDR_INQUEUE));

	// Make sure this is a valid call
    if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because m_fVideoOpen=FALSE\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!lpVHdr)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because lpVHdr=NULL\r\n", _fx_, lpVHdr));
		return FALSE;
	}

    if (lpVHdr->dwFlags & VHDR_INQUEUE)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Buffer lpVHdr=0x%08lX can't be queued because buffer is already queued\r\n", _fx_, lpVHdr));
		return FALSE;
	}

	// Does the size of the buffer match the size of the buffers the streaming pin will generate?
    if (lpVHdr->dwBufferLength < m_pWDMVideoPin->GetFrameSize())
	{
		ERRORMESSAGE(("%s: Buffer lpVHdr=0x%08lX can't be queued because the length of that buffer is too small\r\n", _fx_, lpVHdr));
        return FALSE;
	}

    if (!m_pBufTable)
	{
        lpVHdr->dwReserved[1] = m_cntNumVidBuf;
        m_cntNumVidBuf++;
		DEBUGMSG(ZONE_STREAMING, ("%s: Queue buffer (%d) lpVHdr=0x%08lX\r\n", _fx_, lpVHdr->dwReserved[1], lpVHdr));
    }

    QueueHeader(lpVHdr);

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stop | This function stops a stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_STOP message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Stop()
{
	FX_ENTRY("CWDMStreamer::Stop");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Reset data members - stop streaming thread
    m_fStreamingStarted = FALSE;

    if (m_hThread)
    {

		DEBUGMSG(ZONE_STREAMING, ("%s: Stopping the thread\r\n", _fx_));

        // Signal the streaming thread to stop
		m_bKillThread = TRUE;

        // wait until thread has self-terminated, and clear the event.
		DEBUGMSG(ZONE_STREAMING, ("%s: WaitingForSingleObject...\r\n", _fx_));

        WaitForSingleObject(m_hThread, INFINITE);

		DEBUGMSG(ZONE_STREAMING, ("%s: ...thread stopped\r\n", _fx_));

		// Close the thread handle
		CloseHandle(m_hThread);
		m_hThread = NULL;

		// Ask the pin to stop streaming.
		m_pWDMVideoPin->Stop();

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
			{
				SetEvent(m_pWDMVideoBuff[i].Overlap.hEvent);
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
				m_pWDMVideoBuff[i].Overlap.hEvent = NULL;
			}
		}

		if (m_pWDMVideoBuff)
		{
			delete []m_pWDMVideoBuff;
			m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;
		}

    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Reset | This function resets a stream of
 *    video data coming from the WDM device so that prepared buffer may be
 *    freed correctly.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_RESET message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Reset()
{
	LPVIDEOHDR lpVHdr;

	FX_ENTRY("CWDMStreamer::Reset");

	ASSERT(m_fVideoOpen);

	// Make sure this is a valid call
	if (!m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is not even opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
    Stop();

	// Return all buffers to the application one last time
	while (lpVHdr = DeQueueHeader ())
	{
		lpVHdr->dwFlags |= VHDR_DONE;
		videoCallback(MM_DRVM_DATA, (DWORD_PTR) lpVHdr);
	}

	// Reset data members
    m_lpVHdrFirst = (LPVIDEOHDR)NULL;
    m_lpVHdrLast = (LPVIDEOHDR)NULL;
    if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Open | This function opens a stream of
 *    video data coming from the WDM device.
 *
 *  @parm LPVIDEO_STREAM_INIT_PARMS | lpStreamInitParms | Pointer to
 *    initialization data.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_INIT message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Open(LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms)
{
	FX_ENTRY("CWDMStreamer::Open");

	ASSERT(!m_fVideoOpen);

	// Make sure this is a valid call
	if (m_fVideoOpen)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Stream is already opened\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Initialize data memmbers
	m_CaptureStreamParms	= *lpStreamInitParms;
	m_fVideoOpen			= TRUE;
	m_lpVHdrFirst			= (LPVIDEOHDR)NULL;
	m_lpVHdrLast			= (LPVIDEOHDR)NULL;
	m_cntNumVidBuf			= 0UL;

	// Set frame rate on the pin
	m_pWDMVideoPin->SetAverageTimePerFrame(lpStreamInitParms->dwMicroSecPerFrame * 10);

	// Let the app know we just opened a stream
	videoCallback(MM_DRVM_OPEN, 0L);

	if (lpStreamInitParms->dwMicroSecPerFrame != 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Capturing at %d frames/sec\r\n", _fx_, 100000 / lpStreamInitParms->dwMicroSecPerFrame));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Close | This function closes the stream of
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_FINI message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Close()
{
	FX_ENTRY("CWDMStreamer::Close");

	ASSERT(m_fVideoOpen && !m_lpVHdrFirst);

	// Make sure this is a valid call
	if (!m_fVideoOpen || m_lpVHdrFirst)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s()\r\n", _fx_));

	// Terminate streaming thread
	Stop();

	// Reset data members
	m_fVideoOpen = FALSE;
	m_lpVHdrFirst = m_lpVHdrLast = (LPVIDEOHDR)NULL;
	m_idxNextVHdr = 0UL;

	// Release table of pointers to video buffers
	if (m_pBufTable)
	{
		delete []m_pBufTable;
		m_pBufTable = NULL;
	}

	// Let the app know that we just closed the stream
	videoCallback(MM_DRVM_CLOSE, 0L);

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc void | CWDMStreamer | BufferDone | This function lets the application
 *    know that there is video data available coming from the WDM device.
 *
 *  @devnote This method is called by the kernel streaming object (Pin)
 ***************************************************************************/
void CWDMStreamer::BufferDone(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMStreamer::BufferDone");

	// Make sure this is a valid call
	if (!m_fStreamingStarted)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Video has not been started or just been stopped\r\n", _fx_));
		return;
	}

    if (lpVHdr == NULL)
	{
		// No buffers available - the app hasn't returned the buffers to us yet
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that we don't have any buffers anymore since lpVHdr=NULL\r\n", _fx_));

		// Let the app know something wrong happened
        videoCallback(MM_DRVM_ERROR, 0UL);
        return;
    }

    lpVHdr->dwFlags |= VHDR_DONE;

	// Sanity check
    if (lpVHdr->dwBytesUsed == 0)
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is no valid data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

		// Return frame to the pool before notifying app
		AddBuffer(lpVHdr);
        videoCallback(MM_DRVM_ERROR, 0UL);
    }
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("  %s: Let the app know that there is data available in lpVHdr=0x%08lX\r\n", _fx_, lpVHdr));

        lpVHdr->dwTimeCaptured = timeGetTime() - m_dwTimeStart;

		// Let the app know there's some valid video data available
        videoCallback(MM_DRVM_DATA, (DWORD_PTR)lpVHdr);
    }
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Start | This function starts streaming
 *    video data coming from the WDM device.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 *
 *  @devnote This function handles what was the DVM_STREAM_START message in VfW.
 ***************************************************************************/
BOOL CWDMStreamer::Start()
{
	FX_ENTRY("CWDMStreamer::Start");

    ULONG i;
    LPVIDEOHDR lpVHdr;
	DWORD dwThreadID;

	ASSERT(m_fVideoOpen && m_pWDMVideoPin->GetAverageTimePerFrame() && !m_hThread);

	// Make sure this is a valid call
	if (!m_fVideoOpen || !m_pWDMVideoPin->GetAverageTimePerFrame() || m_hThread)
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: Invalid parameters\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: Streaming in %d video buffers at %d frames/sec\r\n", _fx_, m_cntNumVidBuf, 1000000 / m_pWDMVideoPin->GetAverageTimePerFrame()));

	// Allocate and initialize the video buffer structures
    m_pBufTable = (PBUFSTRUCT) new BUFSTRUCT[m_cntNumVidBuf];
    if (m_pBufTable)
	{
		lpVHdr = m_lpVHdrFirst;
		for (i = 0; i < m_cntNumVidBuf && lpVHdr; i++)
		{
			m_pBufTable[i].fReady = TRUE;
			m_pBufTable[i].lpVHdr = lpVHdr;
			lpVHdr = (LPVIDEOHDR) lpVHdr->dwReserved[0];
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_pBufTable allocation failed! AsynIO may be out of sequence\r\n", _fx_));
	}

    m_idxNextVHdr		= 0UL;  // 0..m_cntNumVidBuf-1
    m_dwTimeStart		= timeGetTime();
    m_fStreamingStarted	= TRUE;
	m_bKillThread = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("%s: Creating %d read video buffers\r\n", _fx_, m_cntNumVidBuf));

	if (!(m_pWDMVideoBuff = (WDMVIDEOBUFF *) new WDMVIDEOBUFF[m_cntNumVidBuf]))
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: m_Overlap allocation failed!\r\n", _fx_));
		return FALSE;
	}

	for(i=0; i<m_cntNumVidBuf; i++)
	{
		// Create the overlapped structures
		ZeroMemory( &(m_pWDMVideoBuff[i].Overlap), sizeof(OVERLAPPED) );
		m_pWDMVideoBuff[i].Overlap.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

		DEBUGMSG(ZONE_STREAMING, ("%s: Event %d is handle 0x%08lX\r\n", _fx_, i, m_pWDMVideoBuff[i].Overlap.hEvent));
	}

	m_dwNextToComplete=0;

    // Create the streaming thread
    m_hThread = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)ThreadStub,
                                this,
                                CREATE_SUSPENDED,
                                &dwThreadID);

    if (m_hThread == NULL)
    {
		ERRORMESSAGE(("%s: Couldn't create the thread\r\n", _fx_));

		for (UINT i=0; i<m_cntNumVidBuf; i++)
		{
			if (m_pWDMVideoBuff[i].Overlap.hEvent)
				CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
		}

		delete []m_pWDMVideoBuff;
		m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;

		m_lpVHdrFirst = (LPVIDEOHDR)NULL;
		m_lpVHdrLast = (LPVIDEOHDR)NULL;
		if (m_pBufTable)
		{
			delete []m_pBufTable;
			m_pBufTable = NULL;
		}

        return FALSE;
    }

    SetThreadPriority(m_hThread, THREAD_PRIORITY_ABOVE_NORMAL);

    ResumeThread(m_hThread);

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread created OK\r\n", _fx_));

    return TRUE;

}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | Stream | This function does the actual
 *    streaming.
 ***************************************************************************/
void CWDMStreamer::Stream()
{
	FX_ENTRY("CWDMStreamer::Stream");

	DEBUGMSG(ZONE_STREAMING, ("%s: Starting to process StreamingThread\r\n", _fx_));

	// Put the pin in streaming mode
	m_pWDMVideoPin->Start();

	// Queue all the reads
	for (UINT i = 0; i<m_cntNumVidBuf; i++)
	{
		QueueRead(i);
	}

	m_dwNextToComplete=0;
#ifdef _DEBUG
	m_dwFrameCount=0;
#endif
	BOOL  bGotAFrame=FALSE;
	DWORD dwRes;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Starting to wait on reads to complete\r\n", _fx_));

	while (!m_bKillThread)
	{
		bGotAFrame = FALSE;

		if (m_pWDMVideoBuff[m_dwNextToComplete].fBlocking)
		{
			DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Waiting on read to complete...\r\n", _fx_));

			// Waiting for the asynchronous read to complete
			dwRes = WaitForSingleObject(m_pWDMVideoBuff[m_dwNextToComplete].Overlap.hEvent, 1000*1);

			if (dwRes == WAIT_FAILED)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...we couldn't perform the wait as requested\r\n", _fx_));
			}

			if (dwRes == WAIT_OBJECT_0)
			{
				DEBUGMSG(ZONE_STREAMING, ("%s: ...wait is over - we now have a frame\r\n", _fx_));
				bGotAFrame = TRUE;
			}
			else
			{
				// time out waiting for frames.
				if (dwRes == WAIT_TIMEOUT)
				{
					DEBUGMSG(ZONE_STREAMING, ("%s: Waiting failed with timeout, last error=%d\r\n", _fx_, GetLastError()));
				}
			}
		}
		else
		{
			// We didn't have to wait - this means the read executed synchronously
			bGotAFrame = TRUE;
		}

		if (bGotAFrame)
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Trying to give frame #%ld to the client\r\n", _fx_, m_dwFrameCount++));

			LPVIDEOHDR lpVHdr;

			lpVHdr = m_pWDMVideoBuff[m_dwNextToComplete].pVideoHdr;

			if (lpVHdr)
			{
				lpVHdr->dwBytesUsed = m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.StreamHeader.DataUsed;

				if ((m_pWDMVideoBuff[m_dwNextToComplete].SHGetImage.FrameInfo.dwFrameFlags & 0x00f0) == KS_VIDEO_FLAG_I_FRAME)
					lpVHdr->dwFlags |= VHDR_KEYFRAME;
			}

			// Mark the buffer as done - signal the app
			BufferDone(lpVHdr);

			// Queue a new read
			QueueRead(m_dwNextToComplete);
		}

		m_dwNextToComplete++;
		m_dwNextToComplete %= m_cntNumVidBuf;
	}

	DEBUGMSG(ZONE_STREAMING, ("%s: End of the streaming thread\r\n", _fx_));

	ExitThread(0);
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | QueueRead | This function queues a read
 *    operation on a video streaming pin.
 *
 *  @parm DWORD | dwIndex | Index of the video structure in read buffer.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMStreamer::QueueRead(DWORD dwIndex)
{
	FX_ENTRY("CWDMStreamer::QueueRead");

	DWORD cbReturned;
	BOOL  bShouldBlock = FALSE;

	DEBUGMSG(ZONE_STREAMING, ("\r\n%s: Queue read buffer %d on pin handle 0x%08lX\r\n", _fx_, dwIndex, m_pWDMVideoPin->GetPinHandle()));

	// Get a buffer from the queue of video buffers
	m_pWDMVideoBuff[dwIndex].pVideoHdr = DeQueueHeader();

	if (m_pWDMVideoBuff[dwIndex].pVideoHdr)
	{
		ZeroMemory(&m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage));
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Size				= sizeof (KS_HEADER_AND_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.FrameInfo.ExtendedHeaderSize	= sizeof (KS_FRAME_INFO);
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Data				= m_pWDMVideoBuff[dwIndex].pVideoHdr->lpData;
		m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.FrameExtent		= m_pWDMVideoPin->GetFrameSize();

		// Submit the read
		BOOL bRet = DeviceIoControl(m_pWDMVideoPin->GetPinHandle(), IOCTL_KS_READ_STREAM, &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage), &cbReturned, &m_pWDMVideoBuff[dwIndex].Overlap);

		if (!bRet)
		{
			DWORD dwErr = GetLastError();
			switch(dwErr)
			{
				case ERROR_IO_PENDING:
					DEBUGMSG(ZONE_STREAMING, ("%s: An overlapped IO is going to take place\r\n", _fx_));
					bShouldBlock = TRUE;
					break;

				// Something bad happened
				default:
					DEBUGMSG(ZONE_STREAMING, ("%s: DeviceIoControl() failed badly dwErr=%d\r\n", _fx_, dwErr));
					break;
			}
		}
		else
		{
			DEBUGMSG(ZONE_STREAMING, ("%s: Overlapped IO won't take place - no need to wait\r\n", _fx_));
		}
	}
	else
	{
		DEBUGMSG(ZONE_STREAMING, ("%s: We won't queue the read - no buffer available\r\n", _fx_));
	}

	m_pWDMVideoBuff[dwIndex].fBlocking = bShouldBlock;

	return bShouldBlock;
}


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERMETHOD
 *
 *  @mfunc BOOL | CWDMStreamer | ThreadStub | Thread stub.
 ***************************************************************************/
LPTHREAD_START_ROUTINE CWDMStreamer::ThreadStub(CWDMStreamer *pCWDMStreamer)
{
	FX_ENTRY("CWDMStreamer::ThreadStub");

	DEBUGMSG(ZONE_STREAMING, ("%s: Thread stub called, starting streaming...\r\n", _fx_));

    pCWDMStreamer->Stream();

	DEBUGMSG(ZONE_STREAMING, ("%s: ...capture thread has stopped\r\n", _fx_));

    return(0);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\wdmpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL WDMPIN
 *
 *  @module WDMPin.cpp | Include file for <c CWDMPin> class used to access
 *    video data on a video streaming pin exposed by the WDM class driver.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | CWDMPin | Video pin class constructor.
 *
 *  @parm DWORD | dwDeviceID | Capture device ID.
 ***************************************************************************/
CWDMPin::CWDMPin(DWORD dwDeviceID) : CWDMDriver(dwDeviceID)
{
	m_hKS			= (HANDLE)NULL;
	m_fStarted		= FALSE;
	m_hKsUserDLL	= (HINSTANCE)NULL;
	m_pKsCreatePin	= (LPFNKSCREATEPIN)NULL;

	ZeroMemory(&m_biHdr, sizeof(KS_BITMAPINFOHEADER));
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc void | CWDMPin | ~CWDMPin | Video pin class destructor. Closes
 *    the video pin and releases the video buffers allocated.
 ***************************************************************************/
CWDMPin::~CWDMPin()
{
	FX_ENTRY("CWDMPin::~CWDMPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroying the video pin, m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	// Nuke the video streaming pin
	DestroyPin();

	// Close the driver
	if (GetDriverHandle())
		CloseDriver();

	// Release kernel streaming DLL (KSUSER.DLL)
	if (m_hKsUserDLL)
		FreeLibrary(m_hKsUserDLL);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetFrame | This function gets a frame from the
 *    video streaming pin.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to the destination buffer to receive
 *    the video frame and information.
 *
 *  @parm PDWORD | pdwBytesUsed | Pointer to the number of bytes used to
 *    read the video frame.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetFrame(LPVIDEOHDR lpVHdr)
{
	FX_ENTRY("CWDMPin::GetFrame");

	ASSERT(lpVHdr && lpVHdr->lpData && GetDriverHandle() && m_hKS && (lpVHdr->dwBufferLength >= m_biHdr.biSizeImage));

	DWORD bRtn;

	// Check input params and state
	if (!lpVHdr || !lpVHdr->lpData || !GetDriverHandle() || !m_hKS || (lpVHdr->dwBufferLength < m_biHdr.biSizeImage))
	{
		ERRORMESSAGE(("%s: No buffer, no driver, no PIN connection, or buffer too small\r\n", _fx_));
		goto MyError0;
	}

	// Put the pin in streaming mode
	if (!Start())
	{
		ERRORMESSAGE(("%s: Cannot set streaming state to KSSTATE_RUN\r\n", _fx_));
		goto MyError0;
	}

	// Initialize structure to do a read on the video pin
	DWORD cbBytesReturned;
	KS_HEADER_AND_INFO SHGetImage;

	ZeroMemory(&SHGetImage,sizeof(SHGetImage));
	SHGetImage.StreamHeader.Data = (LPDWORD)lpVHdr->lpData;
	SHGetImage.StreamHeader.Size = sizeof (KS_HEADER_AND_INFO);
	SHGetImage.StreamHeader.FrameExtent = m_biHdr.biSizeImage;
	SHGetImage.FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

	// Read a frame on the video pin
	bRtn = DeviceIoControl(m_hKS, IOCTL_KS_READ_STREAM, &SHGetImage, sizeof(SHGetImage), &SHGetImage, sizeof(SHGetImage), &cbBytesReturned);

	if (!bRtn)
	{
		ERRORMESSAGE(("%s: DevIo rtn (%d), GetLastError=%d. StreamState->STOP\r\n", _fx_, bRtn, GetLastError()));

		// Stop streaming on the video pin
		Stop();

		goto MyError0;
	}

	// Sanity check
	ASSERT(SHGetImage.StreamHeader.FrameExtent >= SHGetImage.StreamHeader.DataUsed);
	if (SHGetImage.StreamHeader.FrameExtent < SHGetImage.StreamHeader.DataUsed)
	{
		ERRORMESSAGE(("%s: We've corrupted memory!\r\n", _fx_));
		goto MyError0;
	}

	lpVHdr->dwTimeCaptured = timeGetTime();
	lpVHdr->dwBytesUsed  = SHGetImage.StreamHeader.DataUsed;
	lpVHdr->dwFlags |= VHDR_KEYFRAME;

	return TRUE;

MyError0:
	if (lpVHdr)
	{
		lpVHdr->dwBytesUsed = 0UL;
		lpVHdr->dwTimeCaptured = timeGetTime();
	}

	return FALSE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Start | This function puts the video
 *    pin in streaming mode.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Start()
{
	if (m_fStarted)
		return TRUE;

	if (SetState(KSSTATE_PAUSE))
		m_fStarted = SetState(KSSTATE_RUN);

	return m_fStarted;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | Stop | This function stops streaming on the
 *    video pin.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::Stop()
{
	if (m_fStarted)
	{
		if (SetState(KSSTATE_PAUSE))
			if (SetState(KSSTATE_STOP))
				m_fStarted = FALSE;
	}

	return (BOOL)(m_fStarted == FALSE);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function sets the state of the
 *    video streaming pin.
 *
 *  @parm KSSTATE | ksState | New state.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetState(KSSTATE ksState)
{
	KSPROPERTY	ksProp = {0};
	DWORD		cbRet;

	ksProp.Set		= KSPROPSETID_Connection;
	ksProp.Id		= KSPROPERTY_CONNECTION_STATE;
	ksProp.Flags	= KSPROPERTY_TYPE_SET;

	return DeviceIoControl(m_hKS, IOCTL_KS_PROPERTY, &ksProp, sizeof(ksProp), &ksState, sizeof(KSSTATE), &cbRet);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetState | This function either finds a video
 *    data range compatible with the bitamp info header passed in, of the
 *    prefered video data range.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdr | Bitmap info header to match.
 *
 *  @parm BOOL | pfValidMatch | Set to TRUE if a match was found, FALSE
 *    otherwise.
 *
 *  @rdesc Returns a valid pointer to a <t KS_DATARANGE_VIDEO> structure if
 *    successful, or a NULL pointer otherwise.
 *
 *  @comm \\redrum\slmro\proj\wdm10\src\dvd\amovie\proxy\filter\ksutil.cpp(207):KsGetMediaTypes(
 ***************************************************************************/
PKS_DATARANGE_VIDEO CWDMPin::FindMatchDataRangeVideo(PKS_BITMAPINFOHEADER pbiHdr, BOOL *pfValidMatch)
{
	FX_ENTRY("CWDMPin::FindMatchDataRangeVideo");

	ASSERT(pfValidMatch && pbiHdr);

	// Check input params and state
	if (!pbiHdr || !pfValidMatch)
	{
		ERRORMESSAGE(("%s: Bad input params\r\n", _fx_));
		return (PKS_DATARANGE_VIDEO)NULL;
	}

	// Default
	*pfValidMatch = FALSE;

	PDATA_RANGES pDataRanges = GetDriverSupportedDataRanges();

	ASSERT(pDataRanges != 0);

	if (!pDataRanges) 
		return (PKS_DATARANGE_VIDEO)NULL;

	PKS_DATARANGE_VIDEO pSelDRVideo, pDRVideo = &pDataRanges->Data, pFirstDRVideo = 0;
	KS_BITMAPINFOHEADER * pbInfo;

	// PhilF-: This code assumes that all structures are KS_DATARANGE_VIDEO. This
	// may not be a valid assumption foir palettized data types. Check with JayBo
	for (ULONG i = 0; i < pDataRanges->Count; i++)
	{ 
		// Meaningless unless it is *_VIDEOINFO
		if (pDRVideo->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO)
		{
			// We don't care about TV Tuner like devices
			if (pDRVideo->ConfigCaps.VideoStandard == KS_AnalogVideo_None)
			{
				// Save first useable data range
				if (!pFirstDRVideo)
					pFirstDRVideo = pDRVideo;  

				pbInfo = &((pDRVideo->VideoInfoHeader).bmiHeader);

				if ( (pbInfo->biBitCount == pbiHdr->biBitCount) && (pbInfo->biCompression == pbiHdr->biCompression) &&
					( (((pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0))
					&& (pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth) && (pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight)) ||
					((pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth) && (pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx) &&
					(pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight) && (pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy) &&
					((pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0) && ((pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0)) ) )
				{
					*pfValidMatch = TRUE;
					pSelDRVideo = pDRVideo;
					break;
				}
			} // VideoStandard
		} // Specifier

		pDRVideo++;  // Next KS_DATARANGE_VIDEO
	}

	// If no valid match, use the first range found
	if (!*pfValidMatch)
		pSelDRVideo = pFirstDRVideo;

	return (pSelDRVideo);
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | CreatePin | This function actually creates a
 *    video streaming pin on the class driver.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiNewHdr | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the frame
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::CreatePin(PKS_BITMAPINFOHEADER pbiNewHdr, DWORD dwAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::CreatePin");

	ASSERT(m_pKsCreatePin);

	PKS_BITMAPINFOHEADER pbiHdr;
	BOOL bMustMatch, bValidMatch;
#ifdef _DEBUG
	char szFourCC[5] = {0};
#endif

	if (pbiNewHdr)
	{
		// We need to find a video data range that matches the bitmap info header passed in
		bMustMatch = TRUE;
		pbiHdr = pbiNewHdr;
	}
	else
	{
		// We'll use the preferred video data range and default bitmap format
		bMustMatch = FALSE;
		pbiHdr = &m_biHdr;
	}

	PKS_DATARANGE_VIDEO pSelDRVideo = FindMatchDataRangeVideo(pbiHdr, &bValidMatch);
	if (!pSelDRVideo)         
		return FALSE;

	if (bMustMatch && !bValidMatch)
		return FALSE;

	// If we already have a pin, nuke it
	if (GetPinHandle()) 
		DestroyPin();

	// Connect to a new PIN.
	DATAPINCONNECT DataConnect;
	ZeroMemory(&DataConnect, sizeof(DATAPINCONNECT));
	DataConnect.Connect.PinId						= 0;								// CODEC0 sink
	DataConnect.Connect.PinToHandle					= NULL;								// no "connect to"
	DataConnect.Connect.Interface.Set				= KSINTERFACESETID_Standard;
	DataConnect.Connect.Interface.Id				= KSINTERFACE_STANDARD_STREAMING;	// STREAMING
	DataConnect.Connect.Medium.Set					= KSMEDIUMSETID_Standard;
	DataConnect.Connect.Medium.Id					= KSMEDIUM_STANDARD_DEVIO;
	DataConnect.Connect.Priority.PriorityClass		= KSPRIORITY_NORMAL;
	DataConnect.Connect.Priority.PrioritySubClass	= 1;
	CopyMemory(&(DataConnect.Data.DataFormat), &(pSelDRVideo->DataRange), sizeof(KSDATARANGE));
	CopyMemory(&(DataConnect.Data.VideoInfoHeader), &pSelDRVideo->VideoInfoHeader, sizeof(KS_VIDEOINFOHEADER));

	// Adjust the image sizes if necessary
	if (bValidMatch)
	{
		DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth		= pbiHdr->biWidth;
		DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight		= abs(pbiHdr->biHeight); // Support only +biHeight!
		DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage	= pbiHdr->biSizeImage;        
	}

	// Overwrite the default frame rate if non-zero
	if (dwAvgTimePerFrame > 0)
		DataConnect.Data.VideoInfoHeader.AvgTimePerFrame = (REFERENCE_TIME)dwAvgTimePerFrame;

#ifdef _DEBUG
    *((DWORD*)&szFourCC) = DataConnect.Data.VideoInfoHeader.bmiHeader.biCompression;
#endif
	DEBUGMSG(ZONE_INIT, ("%s: Request image format: FourCC(%s) %d * %d * %d bits = %d bytes\r\n", _fx_, szFourCC, DataConnect.Data.VideoInfoHeader.bmiHeader.biWidth, DataConnect.Data.VideoInfoHeader.bmiHeader.biHeight, DataConnect.Data.VideoInfoHeader.bmiHeader.biBitCount, DataConnect.Data.VideoInfoHeader.bmiHeader.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: Request frame rate:   %d fps\r\n", _fx_, 10000000/dwAvgTimePerFrame));
	DEBUGMSG(ZONE_INIT, ("%s: m_hKS was=0x%08lX\r\n", _fx_, m_hKS));

#ifndef HIDE_WDM_DEVICES
	DWORD dwErr = (*m_pKsCreatePin)(GetDriverHandle(), (PKSPIN_CONNECT)&DataConnect, GENERIC_READ | GENERIC_WRITE, &m_hKS);
#else
	DWORD dwErr = 0UL;
	m_hKS = NULL;
#endif

	if (dwAvgTimePerFrame != 0)
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX set to stream at %d fps\r\n", _fx_, m_hKS, 10000000/dwAvgTimePerFrame));
	}
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: m_hKS is now=0x%08lX\r\n", _fx_, m_hKS));
	}

	if (dwErr || (m_hKS == NULL))
	{
		ERRORMESSAGE(("%s: KsCreatePin returned 0x%08lX failure and m_hKS=0x%08lX\r\n", _fx_, dwErr, m_hKS));

		if (m_hKS == INVALID_HANDLE_VALUE)
		{  
			m_hKS = (HANDLE)NULL;
		}

		return FALSE;
	}

	// Cache the bitmap info header
	CopyMemory(&m_biHdr, &DataConnect.Data.VideoInfoHeader.bmiHeader, sizeof(KS_BITMAPINFOHEADER));
	m_dwAvgTimePerFrame = (DWORD)DataConnect.Data.VideoInfoHeader.AvgTimePerFrame;

	DEBUGMSG(ZONE_INIT, ("%s: New m_biHdr:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, m_biHdr.biSize, m_biHdr.biWidth, m_biHdr.biHeight, m_biHdr.biPlanes, m_biHdr.biBitCount, m_biHdr.biCompression, m_biHdr.biSizeImage));
	DEBUGMSG(ZONE_INIT, ("%s: New m_dwAvgTimePerFrame=%ld (%fd fps)\r\n", _fx_, m_dwAvgTimePerFrame, 10000000/m_dwAvgTimePerFrame));

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | DestroyPin | This function nukes a video
 *    streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::DestroyPin()
{
	BOOL fRet = TRUE;

	FX_ENTRY("CWDMPin::DestroyPin");

	DEBUGMSG(ZONE_INIT, ("%s: Destroy PIN m_hKS=0x%08lX\r\n", _fx_, m_hKS));

	if (m_hKS)
	{
		Stop();

		if (!(fRet = CloseHandle(m_hKS)))
		{
			ERRORMESSAGE(("%s: CloseHandle(m_hKS=0x%08lX) failed with GetLastError()=0x%08lX\r\n", _fx_, m_hKS, GetLastError()));
		}

		m_hKS = NULL;
	}

	return fRet;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetBitmapInfo | This function sets the video
 *    format of video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbiHdrNew | This pointer to a bitmap info
 *    header specifies the format of the video data we want from the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetBitmapInfo(PKS_BITMAPINFOHEADER pbiHdrNew)
{
	FX_ENTRY("CWDMPin::SetBitmapInfo");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: New pbiHdrNew:\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbiHdrNew->biSize, pbiHdrNew->biWidth, pbiHdrNew->biHeight, pbiHdrNew->biPlanes, pbiHdrNew->biBitCount, pbiHdrNew->biCompression, pbiHdrNew->biSizeImage));

	// Check if we need to change anything
	if ( GetPinHandle() && (m_biHdr.biHeight == pbiHdrNew->biHeight) && (m_biHdr.biWidth == pbiHdrNew->biWidth) &&
		(m_biHdr.biBitCount == pbiHdrNew->biBitCount) && (m_biHdr.biSizeImage == pbiHdrNew->biSizeImage) &&
		(m_biHdr.biCompression == pbiHdrNew->biCompression) )
		return TRUE;
	else 
		return CreatePin(pbiHdrNew, m_dwAvgTimePerFrame);    

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetBitmapInfo | This function gets the video
 *    format of a video streaming pin.
 *
 *  @parm PKS_BITMAPINFOHEADER | pbInfo | This parameter points to a bitmap
 *    info header structure to receive the video format.
 *
 *  @parm WORD | wSize | This parameter specifies the size of the bitmap
 *    info header structure.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo, WORD wSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage)
	{
		ERRORMESSAGE(("%s: No existing PIN handle or no available format\r\n", _fx_));
		return FALSE;
	}

	CopyMemory(pbInfo, &m_biHdr, wSize);  

	// Support only positive +biHeight.  
	if (pbInfo->biHeight < 0)
	{
		pbInfo->biHeight = -pbInfo->biHeight;
		DEBUGMSG(ZONE_INIT, ("%s: Changed biHeight from -%ld to %ld\r\n", _fx_, pbInfo->biHeight, pbInfo->biHeight));
	}

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | GetPaletteInfo | This function gets the video
 *    palette of a video streaming pin.
 *
 *  @parm CAPTUREPALETTE * | pPal | This parameter points to a palette
 *    structure to receive the video palette.
 *
 *  @parm DWORD | dwcbSize | This parameter specifies the size of the video
 *    palette.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::GetPaletteInfo(CAPTUREPALETTE *pPal, DWORD dwcbSize)
{

	FX_ENTRY("CWDMPin::GetBitmapInfo");

	// Validate call
	if (!m_hKS && !m_biHdr.biSizeImage && (m_biHdr.biBitCount > 8))
	{
		ERRORMESSAGE(("%s: No existing PIN handle, no available format, or bad biBitCount\r\n", _fx_));
		return FALSE;
	}

	// PhilF-: Copy some real bits there
	// CopyMemory(pbInfo, &m_biHdr, wSize);  

	return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | SetAverageTimePerFrame | This function sets the
 *    video frame rate of a video streaming pin.
 *
 *  @parm DWORD | dwAvgTimePerFrame | This parameter specifies the rate
 *    at which we want video frames to be produced on the pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::SetAverageTimePerFrame(DWORD dwNewAvgTimePerFrame)
{
	FX_ENTRY("CWDMPin::SetAverageTimePerFrame");

	// Validate call
	if (!GetDriverHandle())
	{
		ERRORMESSAGE(("%s: Driver hasn't been opened yet\r\n", _fx_));
		return FALSE;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Current frame interval=%d; new frame intercal=%d\r\n", _fx_, m_dwAvgTimePerFrame, dwNewAvgTimePerFrame));

    if (m_dwAvgTimePerFrame != dwNewAvgTimePerFrame)
		return CreatePin(&m_biHdr, dwNewAvgTimePerFrame);    
	else
	{
		DEBUGMSG(ZONE_INIT, ("%s: No need to change frame rate\r\n", _fx_));
        return TRUE;
    }

}


/****************************************************************************
 *  @doc INTERNAL CWDMPINMETHOD
 *
 *  @mfunc BOOL | CWDMPin | OpenDriverAndPin | This function opens the class
 *    driver and creates a video streaming pin.
 *
 *  @rdesc Returns TRUE is successful, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMPin::OpenDriverAndPin()
{
	FX_ENTRY("CWDMPin::OpenDriverAndPin");

	// Load KSUSER.DLL and get a proc address
	if (m_hKsUserDLL = LoadLibrary("KSUSER"))
	{
		if (m_pKsCreatePin = (LPFNKSCREATEPIN)GetProcAddress(m_hKsUserDLL, "KsCreatePin"))
		{
			// Open the class driver
			if (OpenDriver())
			{
				// Create a video streaming pin on the driver
				if (CreatePin((PKS_BITMAPINFOHEADER)NULL))
				{
					return TRUE;
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: Pin connection creation failed!\r\n", _fx_));

					if (GetDriverHandle()) 
						CloseDriver();
				}
			}
		}

		FreeLibrary(m_hKsUserDLL);
	}


	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef _DEBUG // { _DEBUG

extern HDBGZONE  ghDbgZoneCap;
int WINAPI CapDbgPrintf ( LPTSTR lpszFormat, ... );

#define ZONE_INIT		(GETMASK(ghDbgZoneCap) & 0x0001)
#define ZONE_STREAMING	(GETMASK(ghDbgZoneCap) & 0x0002)
#define ZONE_CALLBACK	(GETMASK(ghDbgZoneCap) & 0x0004)
#define ZONE_DIALOGS	(GETMASK(ghDbgZoneCap) & 0x0008)
#define ZONE_CALLS		(GETMASK(ghDbgZoneCap) & 0x0010)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (CapDbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (CapDbgPrintf m)

#else // }{ _DEBUG

#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)

#endif // } _DEBUG

#include <poppack.h> /* End byte packing */

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\dcapnt.cpp ===
//
//  Created 5-Nov-96 [RichP]

#include "Precomp.h"

DWORD
_GetVideoFormatSize(
    HDRVR hvideo
    )
{
	DWORD bufsize;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = &bufsize;
    vcp.lpData1 = NULL;
    vcp.dwSize1 = 0;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

#if 0
    // it makes sense to query if DVM_FORMAT is available, but not all drivers support it!
	if (SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERY),
							(LPARAM)(LPVOID)&vcp) == DV_ERR_OK) {
#endif
		SendDriverMessage(hvideo, DVM_FORMAT,
							(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE),
							(LPARAM)(LPVOID)&vcp);
        if (!bufsize)
            bufsize = sizeof(BITMAPINFOHEADER);
		return bufsize;
#if 0
    } else
        return sizeof(BITMAPINFOHEADER);
#endif
}

BOOL
_GetVideoFormat(
    HVIDEO hvideo,
    LPBITMAPINFOHEADER lpbmih
    )
{
	BOOL res;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    res = !SendDriverMessage((HDRVR)hvideo, DVM_FORMAT,
			(LPARAM)(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
			(LPARAM)(LPVOID)&vcp);
	if (res) {
		// hack for Connectix QuickCam - set format needs to be called
		//   to set internal globals so that streaming can be enabled
		SendDriverMessage((HDRVR)hvideo, DVM_FORMAT,
	        (LPARAM)(DWORD)VIDEO_CONFIGURE_SET, (LPARAM)(LPVOID)&vcp);
	}
	return res;
}

BOOL
_SetVideoFormat(
    HVIDEO hvideoExtIn,
    HVIDEO hvideoIn,
    LPBITMAPINFOHEADER lpbmih
    )
{
    RECT rect;
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = lpbmih;
    vcp.dwSize1 = lpbmih->biSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0L;

    // See if the driver likes the format
    if (SendDriverMessage((HDRVR)hvideoIn, DVM_FORMAT, (LPARAM)(DWORD)VIDEO_CONFIGURE_SET,
        (LPARAM)(LPVOID)&vcp))
        return FALSE;

    // Set the rectangles
    rect.left = rect.top = 0;
    rect.right = (WORD)lpbmih->biWidth;
    rect.bottom = (WORD)lpbmih->biHeight;
    SendDriverMessage((HDRVR)hvideoExtIn, DVM_DST_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);
    SendDriverMessage((HDRVR)hvideoIn, DVM_SRC_RECT, (LPARAM)(LPVOID)&rect, VIDEO_CONFIGURE_SET);

    return TRUE;
}

BOOL
_GetVideoPalette(
    HVIDEO hvideo,
    LPCAPTUREPALETTE lpcp,
    DWORD dwcbSize
    )
{
    VIDEOCONFIGPARMS vcp;

    vcp.lpdwReturn = NULL;
    vcp.lpData1 = (LPVOID)lpcp;
    vcp.dwSize1 = dwcbSize;
    vcp.lpData2 = NULL;
    vcp.dwSize2 = 0;

    return !SendDriverMessage((HDRVR)hvideo, DVM_PALETTE,
	(DWORD)(VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT),
	(DWORD_PTR)&vcp);


}


void
FrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    )
{
	FX_ENTRY("FrameCallback");

	DEBUGMSG(ZONE_CALLBACK, ("%s: wMsg=%s, hcd=0x%08lX, lpcbuf=0x%08lX, hcd->hevWait=0x%08lX\r\n", _fx_, (wMsg == MM_DRVM_OPEN) ? "MM_DRVM_OPEN" : (wMsg == MM_DRVM_CLOSE) ? "MM_DRVM_CLOSE" : (wMsg == MM_DRVM_ERROR) ? "MM_DRVM_ERROR" : (wMsg == MM_DRVM_DATA) ? "MM_DRVM_DATA" : "MM_DRVM_?????", hcd, lpcbuf, hcd->hevWait));

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGMSG(ZONE_CALLBACK, ("%s: Setting hcd->hevWait - no data\r\n", _fx_));
	    SetEvent(hcd->hevWait);
	    return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (hcd->lpTail != hcd->lpCurrent)
	    hcd->lpTail = hcd->lpTail->lpPrev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!hcd->lpTail)
	    hcd->lpHead = NULL;

    // Add the new buffer to the ready queue
    lpcbuf->lpNext = hcd->lpHead;
    lpcbuf->lpPrev = NULL;
    if (hcd->lpHead)
	    hcd->lpHead->lpPrev = lpcbuf;
    else
	    hcd->lpTail = lpcbuf;
    hcd->lpHead = lpcbuf;

#if 1
    if (hcd->lpCurrent) {
        if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
    	    // if client hasn't consumed last frame, then release it
			lpcbuf = hcd->lpCurrent;
    	    hcd->lpCurrent = hcd->lpCurrent->lpPrev;
			DEBUGMSG(ZONE_CALLBACK, ("%s: We already have current buffer (lpcbuf=0x%08lX). Returning this buffer to driver. Set new current buffer hcd->lpCurrent=0x%08lX\r\n", _fx_, lpcbuf, hcd->lpCurrent));
			// Signal that the application is done with the buffer
			lpcbuf->vh.dwFlags &= ~VHDR_DONE;
    	    if (SendDriverMessage(reinterpret_cast<HDRVR>(hvideo), DVM_STREAM_ADDBUFFER, (DWORD_PTR)lpcbuf, sizeof(VIDEOHDR)) != 0)
			{
				ERRORMESSAGE(("%s: Attempt to reuse unconsumed buffer failed\r\n", _fx_));
			}
    	}
    }
    else {
#else
    if (!hcd->lpCurrent) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
	    hcd->lpCurrent = hcd->lpTail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGMSG(ZONE_CALLBACK, ("%s: Setting hcd->hevWait - some data\r\n", _fx_));
    SetEvent(hcd->hevWait);
}


BOOL
_InitializeVideoStream(
	HVIDEO hvideo,
    DWORD dwMicroSecPerFrame,
    DWORD_PTR hcd
	)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    ZeroMemory((LPSTR)&vsip, sizeof (VIDEO_STREAM_INIT_PARMS));
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD_PTR)FrameCallback;
    vsip.dwCallbackInst = hcd;
    vsip.dwFlags = CALLBACK_FUNCTION;
    vsip.hVideo = (DWORD_PTR)hvideo;

    return !SendDriverMessage((HDRVR)hvideo, DVM_STREAM_INIT,
		(DWORD_PTR)&vsip,
		(DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}

BOOL
_UninitializeVideoStream(
	HVIDEO hvideo
	)
{
    return !SendDriverMessage((HDRVR)hvideo, DVM_STREAM_FINI, 0L, 0L);
}


BOOL
_InitializeExternalVideoStream(
    HVIDEO hvideo
	)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    vsip.dwMicroSecPerFrame = 0;    // Ignored by driver for this channel
    vsip.dwCallback = 0L;           // No callback for now
    vsip.dwCallbackInst = 0L;
    vsip.dwFlags = 0;
    vsip.hVideo = (DWORD_PTR)hvideo;

    return !SendDriverMessage((HDRVR)hvideo, DVM_STREAM_INIT,
	                          (DWORD_PTR)&vsip,
	                          (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}


BOOL
_PrepareHeader(
	HANDLE hvideo,
    VIDEOHDR *vh
    )
{
    return (SendDriverMessage((HDRVR)hvideo, DVM_STREAM_PREPAREHEADER,
		        (DWORD_PTR)vh, (DWORD) sizeof (VIDEOHDR)) == DV_ERR_OK);
}

LRESULT
_UnprepareHeader(
	HANDLE hvideo,
    VIDEOHDR *vh
    )
{
    return SendDriverMessage((HDRVR)hvideo, DVM_STREAM_UNPREPAREHEADER,
		        (DWORD_PTR)vh, (DWORD) sizeof (VIDEOHDR));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\32nt\wdmcap.cpp ===
// This file adds native support for streaming WDM video capture
// PhilF-: This needs to be rewritten. You should have two classes
// (CVfWCap & WDMCap) that derive from the same capture class instead
// of those C-like functions...

#include "Precomp.h"

void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    );

// Globals
extern HINSTANCE g_hInst;


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetDevices | This function enumerates the installed WDM video
 *   capture devices and adds them to the list of VfW capture devices.
 *
 * @parm PDWORD | [OUT] pdwOverallCPUUsage | Specifies a pointer to a DWORD to
 *   receive the current CPU usage.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 *
 * @devnote MSDN references:
 *   DirectX 5, DirectX Media, DirectShow, Application Developer's Guide
 *   "Enumerate and Access Hardware Devices in DirectShow Applications"
 ***************************************************************************/
BOOL WDMGetDevices(void)
{
	HRESULT hr;
	ICreateDevEnum *pCreateDevEnum;
	IEnumMoniker *pEm;

	FX_ENTRY("WDMGetDevices");

	// First, create a system hardware enumerator
	// This call loads the following DLLs - total 1047 KBytes!!!:
	//   'C:\WINDOWS\SYSTEM\DEVENUM.DLL' = 60 KBytes
	//   'C:\WINDOWS\SYSTEM\RPCRT4.DLL' = 316 KBytes
	//   'C:\WINDOWS\SYSTEM\CFGMGR32.DLL' = 44 KBytes
	//   'C:\WINDOWS\SYSTEM\WINSPOOL.DRV' = 23 KBytes
	//   'C:\WINDOWS\SYSTEM\COMDLG32.DLL' = 180 KBytes
	//   'C:\WINDOWS\SYSTEM\LZ32.DLL' = 24 KBytes
	//   'C:\WINDOWS\SYSTEM\SETUPAPI.DLL' = 400 KBytes
	// According to LonnyM, there's no way to go around SETUPAPI.DLL
	// when dealing with PnP device interfaces....
	if ((CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void**)&pCreateDevEnum)) != S_OK)
	{
		return FALSE;
	}

	// Second, create an enumerator for a specific type of hardware device: video capture cards only
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEm, CDEF_BYPASS_CLASS_MANAGER);
    pCreateDevEnum->Release();

	// Third, enumerate the list itself
    if (hr == S_OK)
	{
		ULONG cFetched;
		IMoniker *pM;
		IPropertyBag *pPropBag = 0;

		hr = pEm->Reset();

        while(hr = pEm->Next(1, &pM, &cFetched), hr==S_OK)
		{

			pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);

			if (pPropBag)
			{
				VARIANT var;
				LPINTERNALCAPDEV lpcd;

				if (!(lpcd = (LPINTERNALCAPDEV)LocalAlloc(LPTR, sizeof (INTERNALCAPDEV))))
				{
					ERRORMESSAGE(("%s: Failed to allocate an INTERNALCAPDEV buffer\r\n", _fx_));
					break;  // break from the WHILE loop
				}

				// Get friendly name of the device
				var.vt = VT_BSTR;
				if ((hr = pPropBag->Read(L"FriendlyName", &var, 0)) == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceDescription, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);
				}
				else
					LoadString(g_hInst, IDS_UNKNOWN_DEVICE_NAME, lpcd->szDeviceDescription, CCHMAX(lpcd->szDeviceDescription));

				// Get DevicePath of the device
				hr = pPropBag->Read(L"DevicePath", &var, 0);
				if (hr == S_OK)
				{
					WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, lpcd->szDeviceName, MAX_PATH, 0, 0);
					SysFreeString(var.bstrVal);

					// There's no reg key for version information for WDM devices

					// Those devices can't be disabled from the MM control panel
					// lpcd->dwFlags |= CAPTURE_DEVICE_DISABLED;

					// Mark device as a WDM device
					lpcd->dwFlags |= WDM_CAPTURE_DEVICE;

					g_aCapDevices[g_cDevices] = lpcd;
					g_aCapDevices[g_cDevices]->nDeviceIndex = g_cDevices;
					g_cDevices++;
				}
            }

            pPropBag->Release();

            pM->Release();
        }

        pEm->Release();
    }

	return TRUE;

}

/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMOpenDevice | This function opens a WDM video capture
 * devices and adds them to the list of VfW capture devices.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to open.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMOpenDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMOpenDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) != 0));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (lstrlen(g_aCapDevices[dwDeviceID]->szDeviceName) == 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Open streaming class driver
	CWDMPin *pCWDMPin;
	if (!(pCWDMPin = new CWDMPin(dwDeviceID)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMPin class\r\n", _fx_));
		return FALSE;
	}
	else
	{
		// Open the WDM driver and create a video pin
		if (!pCWDMPin->OpenDriverAndPin())
		{
			goto Error0;
		}
	}

	// Create video stream on the pin
    CWDMStreamer *pCWDMStreamer;
	if (!(pCWDMStreamer = new CWDMStreamer(pCWDMPin)))
	{
		ERRORMESSAGE(("%s: Insufficient resource or fail to create CWDMStreamer\r\n", _fx_));
		goto Error0;
	}

	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)pCWDMStreamer;

	return TRUE;

Error0:
	delete pCWDMPin;
	g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;

	return FALSE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMCloseDevice | This function closes a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to close.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMCloseDevice(DWORD dwDeviceID)
{
	FX_ENTRY("WDMCloseDevice");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices));

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close video channel
	if (g_aCapDevices[dwDeviceID]->pCWDMStreamer)
	{
		delete ((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer);
		g_aCapDevices[dwDeviceID]->pCWDMStreamer = (PVOID)NULL;
	}

	// Close driver and pin
	if (g_aCapDevices[dwDeviceID]->pCWDMPin)
	{
		delete ((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
		g_aCapDevices[dwDeviceID]->pCWDMPin = (PVOID)NULL;
	}

	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormatSize | This function returns the size of the
 *   structure used to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @rdesc Always returns the size of a BITMAPINFOHEADER structure.
 ***************************************************************************/
DWORD WDMGetVideoFormatSize(DWORD dwDeviceID)
{
	FX_ENTRY("WDMGetVideoFormatSize");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	DEBUGMSG(ZONE_INIT, ("%s: return size=%ld\r\n", _fx_, (DWORD)sizeof(BITMAPINFOHEADER)));

	// Return size of BITMAPINFOHEADER structure
	return (DWORD)sizeof(BITMAPINFOHEADER);
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMGetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Make sure the size information is correct
	if (!pbmih->biSize)
		pbmih->biSize = WDMGetVideoFormatSize(dwDeviceID);

	// Get the BITMAPINFOHEADER structure
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih, (WORD)pbmih->biSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMSetVideoFormat | This function sets the video format on
 *   a WDM video capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure describing the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMSetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih)
{
	FX_ENTRY("WDMSetVideoFormat");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, pbmih=0x%08lX\r\n", _fx_, dwDeviceID, pbmih));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && pbmih && pbmih->biSize);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !pbmih ||!pbmih->biSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Set the BITMAPINFOHEADER on the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->SetBitmapInfo((PKS_BITMAPINFOHEADER)pbmih))
	{
		DEBUGMSG(ZONE_INIT, ("%s: return\r\n    biSize=%ld\r\n    biWidth=%ld\r\n    biHeight=%ld\r\n    biPlanes=%ld\r\n    biBitCount=%ld\r\n    biCompression=%ld\r\n    biSizeImage=%ld\r\n", _fx_, pbmih->biSize, pbmih->biWidth, pbmih->biHeight, pbmih->biPlanes, pbmih->biBitCount, pbmih->biCompression, pbmih->biSizeImage));
		return TRUE;
	}
	else
	{
		// PhilF-: This sometimes fail, but we keep on streaming... fix that
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetVideoFormat | This function returns the structure used
 *   to describe the video format.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to query.
 *
 * @parm DWORD | [OUT] pbmih | Specifies a pointer to a BITMAPINFOHEADER
 *   structure to receive the video format.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetVideoPalette(DWORD dwDeviceID, CAPTUREPALETTE* lpcp, DWORD dwcbSize)
{
	FX_ENTRY("WDMGetVideoPalette");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, lpcp=0x%08lX\r\n", _fx_, dwDeviceID, lpcp));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin && lpcp);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin) || !lpcp)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the palette information
	if ((((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetPaletteInfo(lpcp, dwcbSize)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeExternalVideoStream | This function initializes
 *   an input video stream on the external video channel of a WDM video
 *   capture device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeExternalVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMInitializeExternalVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));
	DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
	return TRUE;
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMInitializeVideoStream | This function initializes
 *   an input video stream on the videoin channel of a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMInitializeVideoStream(HCAPDEV hcd, DWORD dwDeviceID, DWORD dwMicroSecPerFrame)
{
	FX_ENTRY("WDMInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld, FPS=%ld\r\n", _fx_, dwDeviceID, 1000000UL / dwMicroSecPerFrame));

    VIDEO_STREAM_INIT_PARMS vsip = {0};

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize channel
    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = (DWORD_PTR)WDMFrameCallback;
    vsip.dwCallbackInst = (DWORD_PTR)hcd;
    vsip.dwFlags = CALLBACK_FUNCTION;
    // vsip.hVideo = (DWORD)hvideo;

	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Open(&vsip)))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMUnInitializeVideoStream | This function requests a WDM
 *   video capture device to close a capture stream on the videoin channel.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMUnInitializeVideoStream(DWORD dwDeviceID)
{
	FX_ENTRY("WDMUnInitializeVideoStream");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Close streaming on channel
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Close()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStart | This function requests a WDM video
 *   capture device to start a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to start.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStart(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStart");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Start streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Start()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamStop | This function requests a WDM video
 *   capture device to stop a video stream.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to freeze.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamStop(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamStop");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Stop streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Stop()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamReset | This function resets a WDM video capture
 *   devie to stop input of a capture stream and return all buffers to the
 *   client.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to reset.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamReset(DWORD dwDeviceID)
{
	FX_ENTRY("WDMVideoStreamReset");

	DEBUGMSG(ZONE_INIT, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->Reset()))
	{
		DEBUGMSG(ZONE_INIT, ("%s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("%s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMVideoStreamAddBuffer | This function requests a WDM video
 *   capture device to add an empty input buffer to its input buffer queue.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to initialize.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMVideoStreamAddBuffer(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMVideoStreamAddBuffer");

	DEBUGMSG(ZONE_STREAMING, ("      %s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMStreamer);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMStreamer))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Reset streaming
	if ((((CWDMStreamer *)g_aCapDevices[dwDeviceID]->pCWDMStreamer)->AddBuffer((LPVIDEOHDR)pBuff)))
	{
		DEBUGMSG(ZONE_STREAMING, ("      %s: succeeded\r\n", _fx_));
		return TRUE;
	}
	else
	{
		ERRORMESSAGE(("      %s: failed!!!\r\n", _fx_));
		return FALSE;
	}
}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMGetFrame | This function requests a WDM video
 *   capture device to transfer a single frame to or from the video device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @parm PVOID | [OUT] pBuff | Specifies a pointer to a <t VIDEOHDR> structure.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMGetFrame(DWORD dwDeviceID, PVOID pBuff)
{
	FX_ENTRY("WDMGetFrame");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld, pBuff=0x%08lX\r\n", _fx_, dwDeviceID, pBuff));

	LPVIDEOHDR lpVHdr = (LPVIDEOHDR)pBuff;

	ASSERT(g_cDevices && pBuff && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if (!pBuff || (dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Get the frame from the device
	if (((CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin)->GetFrame(lpVHdr))
		return TRUE;
	else
		return FALSE;

}


/****************************************************************************
 * @doc EXTERNAL WDMFUNC
 *
 * @func BOOL | WDMShowSettingsDialog | This function puts up a property
 *   sheet with a VideoProcAmp and CameraControl page for a WDM video capture
 *   device.
 *
 * @parm DWORD | [IN] dwDeviceID | Specifies the ID of the device to request.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 ***************************************************************************/
BOOL WDMShowSettingsDialog(DWORD dwDeviceID, HWND hWndParent)
{
	PROPSHEETHEADER Psh;
	HPROPSHEETPAGE	Pages[MAX_PAGES];

	FX_ENTRY("WDMShowSettingsDialog");

	DEBUGMSG(ZONE_STREAMING, ("%s: dwDeviceID=%ld\r\n", _fx_, dwDeviceID));

	ASSERT(g_cDevices && (dwDeviceID <= (DWORD)g_cDevices) && g_aCapDevices[dwDeviceID]->pCWDMPin);

    // Validate globals and parameters
    if (!g_cDevices)
    {
        SetLastError(ERROR_DCAP_BAD_INSTALL);
        return FALSE;
    }
    if ((dwDeviceID > (DWORD)g_cDevices) || (!g_aCapDevices[dwDeviceID]->pCWDMPin))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// Initialize property sheet header	and common controls
	Psh.dwSize		= sizeof(Psh);
	Psh.dwFlags		= PSH_DEFAULT;
	Psh.hInstance	= g_hInst;
	Psh.hwndParent	= hWndParent;
	Psh.pszCaption	= g_aCapDevices[dwDeviceID]->szDeviceDescription;
	Psh.nPages		= 0;
	Psh.nStartPage	= 0;
	Psh.pfnCallback	= NULL;
	Psh.phpage		= Pages;

    // Create the video settings property page and add it to the video settings sheet
    CWDMDialog VideoSettings(IDD_VIDEO_SETTINGS, NumVideoSettings, PROPSETID_VIDCAP_VIDEOPROCAMP, g_VideoSettingControls, g_VideoSettingsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = VideoSettings.Create())
		Psh.nPages++;

    // Create the camera control property page and add it to the video settings sheet
    CWDMDialog CamControl(IDD_CAMERA_CONTROL, NumCameraControls, PROPSETID_VIDCAP_CAMERACONTROL, g_CameraControls, g_CameraControlsHelpIDs, (CWDMPin *)g_aCapDevices[dwDeviceID]->pCWDMPin);
	if (Pages[Psh.nPages] = CamControl.Create())
		Psh.nPages++;

	// Put up the property sheet
	if (Psh.nPages && PropertySheet(&Psh) >= 0)
		return TRUE;
	else
		return FALSE;

}


void
WDMFrameCallback(
    HVIDEO hvideo,
    WORD wMsg,
    HCAPDEV hcd,            // (Actually refdata)
    LPCAPBUFFER lpcbuf,     // (Actually LPVIDEOHDR) Only returned from MM_DRVM_DATA!
    DWORD dwParam2
    )
{
	FX_ENTRY("WDMFrameCallback");

	DEBUGMSG(ZONE_CALLBACK, ("    %s: wMsg=%s, hcd=0x%08lX, lpcbuf=0x%08lX, hcd->hevWait=0x%08lX\r\n", _fx_, (wMsg == MM_DRVM_OPEN) ? "MM_DRVM_OPEN" : (wMsg == MM_DRVM_CLOSE) ? "MM_DRVM_CLOSE" : (wMsg == MM_DRVM_ERROR) ? "MM_DRVM_ERROR" : (wMsg == MM_DRVM_DATA) ? "MM_DRVM_DATA" : "MM_DRVM_?????", hcd, lpcbuf, hcd->hevWait));

    // If it's not a data ready message, just set the event and get out.
    // The reason we do this is that if we get behind and start getting a stream
    // of MM_DRVM_ERROR messages (usually because we're stopped in the debugger),
    // we want to make sure we are getting events so we get restarted to handle
    // the frames that are 'stuck.'
    if (wMsg != MM_DRVM_DATA)
    {
		DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - no data\r\n", _fx_));
	    SetEvent(hcd->hevWait);
	    return;
    }

    //--------------------
    // Buffer ready queue:
    // We maintain a doubly-linked list of our buffers so that we can buffer up
    // multiple ready frames when the app isn't ready to handle them. Two things
    // complicate what ought to be a very simple thing: (1) Thunking issues: the pointers
    // used on the 16-bit side are 16:16 (2) Interrupt time issues: the FrameCallback
    // gets called at interrupt time. GetNextReadyBuffer must handle the fact that
    // buffers get added to the list asynchronously.
    //
    // To handle this, the scheme implemented here is to have a double-linked list
    // of buffers with all insertions and deletions happening in FrameCallback
    // (interrupt time). This allows the GetNextReadyBuffer routine to simply
    // find the previous block on the list any time it needs a new buffer without
    // fear of getting tromped (as would be the case if it had to dequeue buffers).
    // The FrameCallback routine is responsible to dequeue blocks that GetNextReadyBuffer
    // is done with. Dequeueing is simple since we don't need to unlink the blocks:
    // no code ever walks the list! All we have to do is move the tail pointer back up
    // the list. All the pointers, head, tail, next, prev, are all 16:16 pointers
    // since all the list manipulation is on the 16-bit side AND because MapSL is
    // much more efficient and safer than MapLS since MapLS has to allocate selectors.
    //--------------------

    // Move the tail back to skip all buffers already used.
    // Note that there is no need to actually unhook the buffer pointers since no one
    // ever walks the list!
    // This makes STRICT assumptions that the current pointer will always be earlier in
    // the list than the tail and that the tail will never be NULL unless the
    // current pointer is too.
    while (hcd->lpTail != hcd->lpCurrent)
	    hcd->lpTail = hcd->lpTail->lpPrev;

    // If all buffers have been used, then the tail pointer will fall off the list.
    // This is normal and the most common code path. In this event, just set the head
    // to NULL as the list is now empty.
    if (!hcd->lpTail)
	    hcd->lpHead = NULL;

    // Add the new buffer to the ready queue
    lpcbuf->lpNext = hcd->lpHead;
    lpcbuf->lpPrev = NULL;
    if (hcd->lpHead)
	    hcd->lpHead->lpPrev = lpcbuf;
    else
	    hcd->lpTail = lpcbuf;
    hcd->lpHead = lpcbuf;

#if 1
    if (hcd->lpCurrent) {
        if (!(hcd->dwFlags & HCAPDEV_STREAMING_PAUSED)) {
    	    // if client hasn't consumed last frame, then release it
			lpcbuf = hcd->lpCurrent;
    	    hcd->lpCurrent = hcd->lpCurrent->lpPrev;
			DEBUGMSG(ZONE_CALLBACK, ("    %s: We already have current buffer (lpcbuf=0x%08lX). Returning this buffer to driver. Set new current buffer hcd->lpCurrent=0x%08lX\r\n", _fx_, lpcbuf, hcd->lpCurrent));
    	    if (!WDMVideoStreamAddBuffer(hcd->nDeviceIndex, (PVOID)lpcbuf))
			{
				ERRORMESSAGE(("    %s: Attempt to reuse unconsumed buffer failed\r\n", _fx_));
			}
    	}
    }
    else {
#else
    if (!hcd->lpCurrent) {
        // If there was no current buffer before, we have one now, so set it to the end.
#endif
	    hcd->lpCurrent = hcd->lpTail;
    }

    // Now set the event saying it's time to process the ready frame
	DEBUGMSG(ZONE_CALLBACK, ("    %s: Setting hcd->hevWait - some data\r\n", _fx_));
    SetEvent(hcd->hevWait);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\wdmcap.h ===
// WDM video capture

// Constants
// PhilF-: Ultimately, after wdm.h has been fixed to work on both
// Win98 and NT5, get the following value from wdm.h instead.
#define FILE_DEVICE_KS                  0x0000002f

// Functions
BOOL	WDMGetDevices(void);
BOOL	WDMOpenDevice(DWORD dwDeviceID);
DWORD	WDMGetVideoFormatSize(DWORD dwDeviceID);
BOOL	WDMGetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih);
BOOL	WDMSetVideoFormat(DWORD dwDeviceID, PBITMAPINFOHEADER pbmih);
BOOL	WDMGetVideoPalette(DWORD dwDeviceID, CAPTUREPALETTE* lpcp, DWORD dwcbSize);
BOOL	WDMCloseDevice(DWORD dwDeviceID);
BOOL	WDMUnInitializeVideoStream(DWORD dwDeviceID);
BOOL	WDMInitializeVideoStream(HCAPDEV hcd, DWORD dwDeviceID, DWORD dwMicroSecPerFrame);
BOOL	WDMVideoStreamReset(DWORD dwDeviceID);
BOOL	WDMVideoStreamAddBuffer(DWORD dwDeviceID, PVOID pBuff);
BOOL	WDMVideoStreamStart(DWORD dwDeviceID);
BOOL	WDMVideoStreamStop(DWORD dwDeviceID);
BOOL	WDMGetFrame(DWORD dwDeviceID, PVOID pBuff);
BOOL	WDMShowSettingsDialog(DWORD dwDeviceID, HWND hWndParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\wdmpin.h ===
/****************************************************************************
 *  @doc INTERNAL WDMPIN
 *
 *  @module WDMPin.h | Include file for <c CWDMPin> class used to access
 *    video data on a video streaming pin exposed by the WDM class driver.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _WDMPIN_H // { _WDMPIN_H
#define _WDMPIN_H

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct DATAPINCONNECT | The <t DATAPINCONNECT> structure is used to
 *   connect to a streaming video pin.
 *
 * @field KSPIN_CONNECT | Connect | Describes how the connection is to be
 *   done.
 *
 * @field KS_DATAFORMAT_VIDEOINFOHEADER | Data | Describes the video format
 *   of the video data streaming from a video pin.
 ***************************************************************************/
// Structure used to connect to a streaming video pin
typedef struct _tagStreamConnect
{
	KSPIN_CONNECT					Connect;
	KS_DATAFORMAT_VIDEOINFOHEADER	Data; 
} DATAPINCONNECT, *PDATAPINCONNECT;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct KS_HEADER_AND_INFO | The <t KS_HEADER_AND_INFO> structure is used
 *   stream data from a video pin.
 *
 * @field KSSTREAM_HEADER | StreamHeader | Describes how the streaming is to be
 *   done.
 *
 * @field KS_FRAME_INFO | FrameInfo | Describes the video format
 *   of the video data streaming from a video pin.
 ***************************************************************************/
// Video streaming data structure
typedef struct
{
	KSSTREAM_HEADER	StreamHeader;
	KS_FRAME_INFO	FrameInfo;
} KS_HEADER_AND_INFO;

// For GetProcAddresss on KsCreatePin
typedef DWORD (WINAPI *LPFNKSCREATEPIN)(IN HANDLE FilterHandle, IN PKSPIN_CONNECT Connect, IN ACCESS_MASK DesiredAccess, OUT PHANDLE ConnectionHandle);

// Default frame rate: 30 fps
#define DEFAULT_AVG_TIME_PER_FRAME 333330UL

/****************************************************************************
 *  @doc INTERNAL CWDMPINCLASS
 *
 *  @class CWDMPin | This class provides support for streaming video
 *    data from WDM device streaming pin.
 *
 *  @mdata BOOL | CWDMPin | m_hKS | Handle to the video streaming pin.
 *
 *  @mdata KS_BITMAPINFOHEADER | CWDMPin | m_biHdr | Video format
 *    of the video data used by the streaming pin.
 *
 *  @mdata DWORD | CWDMPin | m_dwAvgTimePerFrame | Frame rate.
 *
 *  @mdata BOOL | CWDMPin | m_fStarted | Video streaming channel
  *    status.
 ***************************************************************************/
class CWDMPin : public CWDMDriver
{
public:
	CWDMPin(DWORD dwDeviceID);
	~CWDMPin();

	// Pin and class driver management functions
    BOOL   OpenDriverAndPin();
    HANDLE GetPinHandle() const { return m_hKS; }

	// Pin video format functions
    BOOL  GetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo, WORD wSize);
    BOOL  SetBitmapInfo(PKS_BITMAPINFOHEADER pbInfo);
	BOOL  GetPaletteInfo(CAPTUREPALETTE *pPal, DWORD dwcbSize);
    DWORD GetFrameSize() { return m_biHdr.biSizeImage; }
    DWORD GetAverageTimePerFrame() { return m_dwAvgTimePerFrame; }
    BOOL  SetAverageTimePerFrame(DWORD dwNewAvgTimePerFrame);

	// Data access functions
    BOOL GetFrame(LPVIDEOHDR lpVHdr);

	// Streaming state functions
    BOOL Start();
    BOOL Stop();

private:
    HANDLE				m_hKS;    
    KS_BITMAPINFOHEADER	m_biHdr;
    DWORD				m_dwAvgTimePerFrame;
    BOOL				m_fStarted;
	HINSTANCE			m_hKsUserDLL;
	LPFNKSCREATEPIN		m_pKsCreatePin;

	// Pin video format function
    PKS_DATARANGE_VIDEO FindMatchDataRangeVideo(PKS_BITMAPINFOHEADER pbiHdr, BOOL *pfValidMatch);

	// Pin and class driver management functions
    BOOL CreatePin(PKS_BITMAPINFOHEADER pbiNewHdr, DWORD dwAvgTimePerFrame = DEFAULT_AVG_TIME_PER_FRAME);
    BOOL DestroyPin();

	// Streaming state function
    BOOL SetState(KSSTATE ksState);
};

#endif  // } _WDMPIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\wdmdrivr.h ===
/****************************************************************************
 *  @doc INTERNAL WDMDRIVER
 *
 *  @module WDMDrivr.h | Include file for <c CWDMDriver> class used to
 *    access the streaming class driver using IOctls.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _WDMDRVR_H // { _WDMDRVR_H
#define _WDMDRVR_H

// Used to query and set video data ranges of a device
typedef struct _tagDataRanges {
    ULONG   Size;
    ULONG   Count;
    KS_DATARANGE_VIDEO Data;
} DATA_RANGES, * PDATA_RANGES;

// Used to query/set video property values and ranges
typedef struct {
    KSPROPERTY_DESCRIPTION      proDesc;
    KSPROPERTY_MEMBERSHEADER  proHdr;
    union {
        KSPROPERTY_STEPPING_LONG  proData;
        ULONG ulData;
    };
} PROCAMP_MEMBERSLIST;

/****************************************************************************
 *  @doc INTERNAL CWDMDRIVERCLASS
 *
 *  @class CWDMDriver | This class provides access to the streaming class
 *    driver, through which we acess the video capture mini-driver properties
 *    using IOCtls.
 *
 *  @mdata DWORD | CWDMDriver | m_dwDeviceID | Capture device ID.
 *
 *  @mdata HANDLE | CWDMDriver | m_hDriver | This member holds the driver
 *    file handle.
 *
 *  @mdata PDATA_RANGES | CWDMDriver | m_pDataRanges | This member points
 *    to the video data range structure.
 ***************************************************************************/
class CWDMDriver
{
public:
    CWDMDriver(DWORD dwDeviceID);
    ~CWDMDriver();

    // Property functions
    BOOL GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities);
    BOOL GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue);
    BOOL GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep);
    BOOL SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities);

	// Device functions
	BOOL	OpenDriver();
	BOOL	CloseDriver();
	HANDLE	GetDriverHandle() { return m_hDriver; }

    // Data range functions
    PDATA_RANGES	GetDriverSupportedDataRanges() { return m_pDataRanges; };

	// Device IO function
    BOOL DeviceIoControl(HANDLE h, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped=TRUE);

private:
	DWORD			m_dwDeviceID;	// Capture device ID
	HANDLE			m_hDriver;		// Driver file handle
	PDATA_RANGES	m_pDataRanges;	// Pin data ranges

    // Data range functions
	ULONG			CreateDriverSupportedDataRanges();
};

#endif // } _WDMDRVR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\wdmdialg.h ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.h | Include file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _DIALOGS_H // { _DIALOGS_H
#define _DIALOGS_H

// Constants used to check if the property has an automatic mode or/and a manual mode
#define KSPROPERTY_FLAGS_MANUAL KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL
#define KSPROPERTY_FLAGS_AUTO KSPROPERTY_CAMERACONTROL_FLAGS_AUTO

#if (KSPROPERTY_FLAGS_AUTO != KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) || (KSPROPERTY_FLAGS_MANUAL != KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL)
#error Why did you mess with the kernel streaming include files? - PhilF-
#endif

typedef struct _tagPROPSLIDECONTROL
{
    LONG lLastValue;
    LONG lCurrentValue;
    LONG lMin;
    LONG lMax;
    ULONG ulCapabilities;

    // Dialog item IDs
    UINT uiProperty;
    UINT uiSlider;
    UINT uiString;
    UINT uiStatic;
    UINT uiCurrent;
    UINT uiAuto;
} PROPSLIDECONTROL, * PPROPSLIDECONTROL;

// Video settings (brightness tint hue etc.)
static PROPSLIDECONTROL g_VideoSettingControls[] = 
{    
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,   IDC_SLIDER_BRIGHTNESS, IDS_BRIGHTNESS, IDC_BRIGHTNESS_STATIC, IDC_TXT_BRIGHTNESS_CURRENT, IDC_CB_AUTO_BRIGHTNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_CONTRAST,     IDC_SLIDER_CONTRAST,   IDS_CONTRAST,   IDC_CONTRAST_STATIC,   IDC_TXT_CONTRAST_CURRENT,   IDC_CB_AUTO_CONTRAST},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_HUE,          IDC_SLIDER_HUE,        IDS_HUE,        IDC_HUE_STATIC,        IDC_TXT_HUE_CURRENT,        IDC_CB_AUTO_HUE},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SATURATION,   IDC_SLIDER_SATURATION, IDS_SATURATION, IDC_SATURATION_STATIC, IDC_TXT_SATURATION_CURRENT, IDC_CB_AUTO_SATURATION},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SHARPNESS,    IDC_SLIDER_SHARPNESS,  IDS_SHARPNESS,  IDC_SHARPNESS_STATIC,  IDC_TXT_SHARPNESS_CURRENT,  IDC_CB_AUTO_SHARPNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE, IDC_SLIDER_WHITEBAL,   IDS_WHITEBAL,   IDC_WHITE_STATIC,      IDC_TXT_WHITE_CURRENT,      IDC_CB_AUTO_WHITEBAL},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_GAMMA,        IDC_SLIDER_GAMMA,      IDS_GAMMA,      IDC_GAMMA_STATIC,      IDC_TXT_GAMMA_CURRENT,      IDC_CB_AUTO_GAMMA},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,    IDC_SLIDER_BACKLIGHT,  IDS_BACKLIGHT,  IDC_BACKLIGHT_STATIC,      IDC_TXT_BACKLIGHT_CURRENT,  IDC_CB_AUTO_BACKLIGHT}
};

const ULONG NumVideoSettings = sizeof(g_VideoSettingControls) / sizeof(PROPSLIDECONTROL);

// PhilF-: Assign a bug to Debbie to get this used
static DWORD g_VideoSettingsHelpIDs[] =
{
	IDC_DEVICE_SETTINGS,					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_BRIGHTNESS,					IDH_DEVICE_SETTINGS,
	IDC_BRIGHTNESS_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_BRIGHTNESS_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_BRIGHTNESS, 				IDH_DEVICE_SETTINGS,

	IDC_SLIDER_CONTRAST,					IDH_DEVICE_SETTINGS,
	IDC_CONTRAST_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_CONTRAST_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_CONTRAST, 					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_HUE,							IDH_DEVICE_SETTINGS,
	IDC_HUE_STATIC,							IDH_DEVICE_SETTINGS,
	IDC_TXT_HUE_CURRENT,					IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_HUE, 						IDH_DEVICE_SETTINGS,

	IDC_SLIDER_SATURATION,					IDH_DEVICE_SETTINGS,
	IDC_SATURATION_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_SATURATION_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_SATURATION, 				IDH_DEVICE_SETTINGS,

	IDC_SLIDER_SHARPNESS,					IDH_DEVICE_SETTINGS,
	IDC_SHARPNESS_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_SHARPNESS_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_SHARPNESS, 					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_WHITEBAL,					IDH_DEVICE_SETTINGS,
	IDC_WHITE_STATIC,						IDH_DEVICE_SETTINGS,
	IDC_TXT_WHITE_CURRENT,					IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_WHITEBAL, 					IDH_DEVICE_SETTINGS,

	IDC_SLIDER_GAMMA,						IDH_DEVICE_SETTINGS,
	IDC_GAMMA_STATIC,						IDH_DEVICE_SETTINGS,
	IDC_TXT_GAMMA_CURRENT,					IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_GAMMA, 						IDH_DEVICE_SETTINGS,
	
	IDC_SLIDER_BACKLIGHT,					IDH_DEVICE_SETTINGS,
	IDC_BACKLIGHT_STATIC,					IDH_DEVICE_SETTINGS,
	IDC_TXT_BACKLIGHT_CURRENT,				IDH_DEVICE_SETTINGS,
	IDC_CB_AUTO_BACKLIGHT, 					IDH_DEVICE_SETTINGS,

	IDC_DEFAULT,							IDH_DEVICE_SETTINGS,

	0, 0   // terminator
};

// Camera control (focus, zoom etc.)
static PROPSLIDECONTROL g_CameraControls[] = 
{    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_FOCUS,   IDC_SLIDER_FOCUS,   IDS_FOCUS,    IDC_FOCUS_STATIC,   IDC_TXT_FOCUS_CURRENT,    IDC_CB_AUTO_FOCUS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ZOOM,    IDC_SLIDER_ZOOM,    IDS_ZOOM,     IDC_ZOOM_STATIC,    IDC_TXT_ZOOM_CURRENT,     IDC_CB_AUTO_ZOOM},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_EXPOSURE,IDC_SLIDER_EXPOSURE,IDS_EXPOSURE, IDC_EXPOSURE_STATIC,IDC_TXT_EXPOSURE_CURRENT, IDC_CB_AUTO_EXPOSURE},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_IRIS,    IDC_SLIDER_IRIS,    IDS_IRIS,     IDC_IRIS_STATIC,    IDC_TXT_IRIS_CURRENT,     IDC_CB_AUTO_IRIS},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_TILT,    IDC_SLIDER_TILT,    IDS_TILT,     IDC_TILT_STATIC,    IDC_TXT_TILT_CURRENT,     IDC_CB_AUTO_TILT},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_PAN,     IDC_SLIDER_PAN,     IDS_PAN,      IDC_PAN_STATIC,     IDC_TXT_PAN_CURRENT,      IDC_CB_AUTO_PAN},    
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ROLL,    IDC_SLIDER_ROLL,    IDS_ROLL,     IDC_ROLL_STATIC,    IDC_TXT_ROLL_CURRENT,     IDC_CB_AUTO_ROLL},    
};

const ULONG NumCameraControls = sizeof(g_CameraControls) / sizeof(PROPSLIDECONTROL);

static DWORD g_CameraControlsHelpIDs[] =
{
	IDC_CAMERA_CONTROLS,		IDH_CAMERA_CONTROLS,

	IDC_SLIDER_FOCUS,			IDH_CAMERA_CONTROLS,
	IDC_FOCUS_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_FOCUS_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_FOCUS, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_ZOOM,			IDH_CAMERA_CONTROLS,
	IDC_ZOOM_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_ZOOM_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_ZOOM, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_EXPOSURE,		IDH_CAMERA_CONTROLS,
	IDC_EXPOSURE_STATIC,		IDH_CAMERA_CONTROLS,
	IDC_TXT_EXPOSURE_CURRENT,	IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_EXPOSURE, 		IDH_CAMERA_CONTROLS,

	IDC_SLIDER_IRIS,			IDH_CAMERA_CONTROLS,
	IDC_IRIS_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_IRIS_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_IRIS, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_TILT,			IDH_CAMERA_CONTROLS,
	IDC_TILT_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_TILT_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_TILT, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_PAN,				IDH_CAMERA_CONTROLS,
	IDC_PAN_STATIC,				IDH_CAMERA_CONTROLS,
	IDC_TXT_PAN_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_PAN, 			IDH_CAMERA_CONTROLS,

	IDC_SLIDER_ROLL,			IDH_CAMERA_CONTROLS,
	IDC_ROLL_STATIC,			IDH_CAMERA_CONTROLS,
	IDC_TXT_ROLL_CURRENT,		IDH_CAMERA_CONTROLS,
	IDC_CB_AUTO_ROLL, 			IDH_CAMERA_CONTROLS,

	IDC_DEFAULT,				IDH_CAMERA_CONTROLS,

	0, 0   // terminator
};

// For now, we only expose a video settings and camera control page
#define MAX_PAGES 2

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGCLASS
 *
 *  @class CWDMDialog | This class provides support for property
 *    pages to be displayed within a property sheet.
 *
 *  @mdata BOOL | CWDMDialog | m_bInit | This member is set to TRUE after the
 *    page has been initialized.
 *
 *  @mdata BOOL | CWDMDialog | m_bChanged | This member is set to TRUE after the
 *    page has been changed.
 *
 *  @mdata int | CWDMDialog | m_DlgID | Resource ID of the property page dialog.
 *
 *  @mdata HWND | CWDMDialog | m_hDlg | Window handle of the property page.
 *
 *  @mdata PDWORD | CWDMDialog | m_pdwHelp | Pointer to the list of help IDs
 *    to be displayed in the property page.
 *
 *  @mdata CWDMPin * | CWDMDialog | m_pCWDMPin | Pointer to the kernel
 *    streaming object we will query the property on.
 *
 *  @mdata PPROPSLIDECONTROL | CWDMDialog | m_pPC | Pointer to the list of
 *    slider controls to be displayed in the property page.
 *
 *  @mdata DWORD | CWDMDialog | m_dwNumControls | Number of controls to\
 *    display in the page.
 *
 *  @mdata GUID | CWDMDialog | m_guidPropertySet | GUID of the KS property
 *    we are showing in the property page.
 ***************************************************************************/
class CWDMDialog
{
public:
    CWDMDialog(int DlgID, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, PDWORD pdwHelp, CWDMPin *pCWDMPin=0);
    ~CWDMDialog() {};

	HPROPSHEETPAGE	Create();

private:
	BOOL				m_bInit;
	BOOL				m_bChanged;
	int					m_DlgID;
	HWND				m_hDlg;
	PDWORD				m_pdwHelp;
	CWDMPin				*m_pCWDMPin;
	PPROPSLIDECONTROL	m_pPC;
	DWORD				m_dwNumControls;
	GUID				m_guidPropertySet;

	// Dialog proc helper functions
	int		SetActive();
	int		QueryCancel();
	int		DoCommand(WORD wCmdID,WORD hHow);

	// Dialog proc
	static BOOL CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#endif // } _DIALOGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\idcap.h ===
//  IDCAP.H
//
//  Created 31-Jul-96 [JonT]

#ifndef _IDCAP_H
#define _IDCAP_H

// Set a define saying we're building QKCAP so that
// we use the proper DLL import switches
#define __DCAP_BUILD__

// Debug stuff
#if defined (DEBUG) || defined (_DEBUG)
#define Assert(x, msg) { if (!(x)) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); DebugBreak(); } }
#define DebugSpew(msg) { char szBuf[256]; \
    wsprintf((LPSTR)szBuf, (LPSTR)"DCAP: %s %s(%d)\r\n", (LPSTR)(msg),\
    (LPSTR)__FILE__, __LINE__); \
    OutputDebugString((LPSTR)szBuf); }
#else
#define Assert(x, msg)
#define DebugSpew(msg)
#endif


// Equates
#define DCAP_MAX_DEVICES      10        // Arbitrary
#define DCAP_MAX_VFW_DEVICES  10        // MSVIDEO's limit

// INTERNALCAPDEV flags
#define HCAPDEV_STREAMING               0x0001
#define HCAPDEV_STREAMING_INITIALIZED   0x0002
#define HCAPDEV_STREAMING_FRAME_GRAB    0x0004
#define HCAPDEV_STREAMING_FRAME_TIME    0x0008
#define HCAPDEV_STREAMING_PAUSED        0x0010
#define HCAPDEV_IN_DRIVER_DIALOG        0x0020
#define CAPTURE_DEVICE_DISABLED         0x0040
#define CAPTURE_DEVICE_OPEN             0x0080
#define WDM_CAPTURE_DEVICE              0x0100

// LOCKEDINFO flags
#define LIF_STOPSTREAM       0x0001

// Structures

// CAPTUREDEVICE flags
#define MAX_VERSION						80

#ifdef WIN32
typedef struct tagVS_VERSION
{
	WORD wTotLen;
	WORD wValLen;
	TCHAR szSig[16];
	VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;
#endif

#ifdef __NT_BUILD__
#define LPCAPBUFFER16   DWORD
#define LPCAPBUFFER32   LPCAPBUFFER
#endif //__NT_BUILD__

typedef struct _CAPBUFFERHDR FAR* LPCAPBUFFER;

// We will deal with CAPBUFFER pointers as always 16:16 pointers. So, we
// use this #define to make sure that we don't accidentally indirect them on
// the 32-bit side. We need to always MapSL them on the 32-bit side before
// using.

#ifndef WIN32
#define LPCAPBUFFER16   LPCAPBUFFER
#define LPCAPBUFFER32   DWORD
#else
#define LPCAPBUFFER16   DWORD
#define LPCAPBUFFER32   LPCAPBUFFER
#endif


typedef struct _CAPBUFFERHDR
{
    VIDEOHDR vh;
    LPCAPBUFFER32 lpNext;     // Double linked list pointers for ready queue
    LPCAPBUFFER32 lpPrev;
#ifndef __NT_BUILD__
    LPCAPBUFFER16 lp1616Next;       // Double linked list pointers for ready queue
    LPCAPBUFFER16 lp1616Prev;
#endif
} CAPBUFFERHDR, FAR* LPCAPBUFFER;


#ifndef __NT_BUILD__
typedef struct _LOCKEDINFO
{
    LPCAPBUFFER16 lp1616Head;       // Queue of ready items
    LPCAPBUFFER16 lp1616Tail;
    LPCAPBUFFER16 lp1616Current;    // Item being used by 32-bit side
    DWORD pevWait;
    DWORD dwFlags;
} LOCKEDINFO, FAR* LPLOCKEDINFO;
#endif


#ifdef WIN32
typedef struct _INTERNALCAPDEV
{
    DWORD dwFlags;
#ifndef __NT_BUILD__
    LOCKEDINFO* lpli;
    WORD wselLockedInfo;
    WORD wPad;
#endif
    int nDeviceIndex;
    HVIDEO hvideoIn;
    HVIDEO hvideoCapture;
    HVIDEO hvideoOverlay;
    LPCAPBUFFER32 lpcbufList;  // List of all allocated buffers so we can free them
    DWORD dwcbBuffers;
    DWORD dw_usecperframe;
    UINT timerID;
    HANDLE hevWait;
    LONG busyCount;
    LPCAPBUFFER32 lpHead;
    LPCAPBUFFER32 lpTail;
    LPCAPBUFFER32 lpCurrent;
    CRITICAL_SECTION bufferlistCS;
    DWORD dwDevNode;
    char szDeviceName[MAX_PATH];
    char szDeviceDescription[MAX_PATH];
    char szDeviceVersion[MAX_VERSION];
	PVOID pCWDMPin;
	PVOID pCWDMStreamer;
} INTERNALCAPDEV, *HCAPDEV, *LPINTERNALCAPDEV;

#define HFRAMEBUF LPCAPBUFFER

#define INTERNAL_MAGIC 0x50414344

#define VALIDATE_CAPDEV(h) if (!h || !(h->dwFlags & CAPTURE_DEVICE_OPEN)) { \
    SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }

#include <dcap.h>

// Globals
    extern int g_cDevices;
    extern LPINTERNALCAPDEV g_aCapDevices[DCAP_MAX_DEVICES];

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef __NT_BUILD__
#define _OpenDriver OpenDriver
#define _CloseDriver CloseDriver
#define _SendDriverMessage SendDriverMessage
#else
HANDLE __stdcall    _OpenDriver(LPCSTR lpDriverName, LPSTR lpSectionName, LONG lpvop);
DWORD __stdcall     _CloseDriver(HANDLE h, LPVOID lpReserved1, LPVOID lpReserved2);
DWORD __stdcall     _SendDriverMessage(HANDLE h, DWORD msg, DWORD param1, DWORD param2);
void __stdcall      _CloseVxDHandle(DWORD pev);
WORD __stdcall      _AllocateLockableBuffer(DWORD dwSize);
void __stdcall      _FreeLockableBuffer(WORD wBuffer);
BOOL __stdcall      _LockBuffer(WORD wBuffer);
void __stdcall      _UnlockBuffer(WORD wBuffer);
#endif

BOOL __stdcall      _GetVideoPalette(HVIDEO hvideo, CAPTUREPALETTE* lpcp, DWORD dwcbSize);
DWORD _stdcall      _GetVideoFormatSize(HDRVR hvideo);
BOOL __stdcall      _GetVideoFormat(HVIDEO hvideo, LPBITMAPINFOHEADER lpbmih);
BOOL __stdcall      _SetVideoFormat(HVIDEO hvideoExtIn, HVIDEO hvideoIn, LPBITMAPINFOHEADER lpbmih);
BOOL __stdcall      _InitializeVideoStream(HVIDEO hvideo, DWORD dwMicroSecPerFrame, DWORD_PTR dwParam);
BOOL __stdcall      _UninitializeVideoStream(HVIDEO hvideo);
BOOL __stdcall      _InitializeExternalVideoStream(HVIDEO hvideo);
DWORD __stdcall     _GetVideoFrame(HVIDEO hvideo, DWORD lpvideohdr);
#endif //Win32

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif  // #ifndef _IDCAP_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dcap32.rc
//
#define IDD_CAMERA_CONTROL              100
#define IDD_VIDEO_SETTINGS              101
#define IDC_DEFAULT                     102
#define IDC_DEVICE_SETTINGS             103
#define IDC_CAMERA_CONTROLS             104
#define IDC_BRIGHTNESS                  110
#define IDC_CONTRAST                    111
#define IDC_HUE                         112
#define IDC_SATURATION                  113
#define IDC_SHARPNESS                   114
#define IDC_WHITE                       115
#define IDC_PAN                         116
#define IDC_TILT                        117
#define IDC_ROLL                        118
#define IDC_HUE_STATIC                  120
#define IDC_BRIGHTNESS_STATIC           121
#define IDC_CONTRAST_STATIC             122
#define IDC_SATURATION_STATIC           123
#define IDC_SHARPNESS_STATIC            124
#define IDC_WHITE_STATIC                125
#define IDC_GAMMA_STATIC                126
#define IDC_BACKLIGHT_STATIC            127
#define IDC_ZOOM_STATIC                 128
#define IDC_FOCUS_STATIC                129
#define IDC_TILT_STATIC                 130
#define IDC_EXPOSURE_STATIC             131
#define IDC_IRIS_STATIC                 132
#define IDC_PAN_STATIC                  133
#define IDC_ROLL_STATIC                 134
#define IDC_SLIDER_WHITEBAL             140
#define IDC_SLIDER_BRIGHTNESS           141
#define IDC_SLIDER_CONTRAST             142
#define IDC_SLIDER_HUE                  143
#define IDC_SLIDER_SATURATION           144
#define IDC_SLIDER_SHARPNESS            145
#define IDC_SLIDER_FOCUS                146
#define IDC_SLIDER_GAMMA                147
#define IDC_SLIDER_BACKLIGHT            148
#define IDC_SLIDER_ZOOM                 149
#define IDC_SLIDER_TILT                 150
#define IDC_SLIDER_EXPOSURE             151
#define IDC_SLIDER_IRIS                 152
#define IDC_SLIDER_PAN                  153
#define IDC_SLIDER_ROLL                 154
#define IDC_TXT_HUE_CURRENT             160
#define IDC_TXT_BRIGHTNESS_CURRENT      161
#define IDC_TXT_CONTRAST_CURRENT        162
#define IDC_TXT_SATURATION_CURRENT      163
#define IDC_TXT_SHARPNESS_CURRENT       164
#define IDC_TXT_ZOOM_CURRENT            165
#define IDC_TXT_WHITE_CURRENT           166
#define IDC_TXT_FOCUS_CURRENT           167
#define IDC_TXT_GAMMA_CURRENT           168
#define IDC_TXT_BACKLIGHT_CURRENT       169
#define IDC_TXT_TILT_CURRENT            170
#define IDC_TXT_EXPOSURE_CURRENT        171
#define IDC_TXT_IRIS_CURRENT            172
#define IDC_TXT_PAN_CURRENT             173
#define IDC_TXT_ROLL_CURRENT            174
#define IDC_CB_AUTO_BRIGHTNESS          180
#define IDC_CB_AUTO_CONTRAST            181
#define IDC_CB_AUTO_HUE                 182
#define IDC_CB_AUTO_SATURATION          183
#define IDC_CB_AUTO_SHARPNESS           184
#define IDC_CB_AUTO_WHITEBAL            185
#define IDC_CB_AUTO_GAMMA               186
#define IDC_CB_AUTO_BACKLIGHT           187
#define IDC_CB_AUTO_ZOOM                188
#define IDC_CB_AUTO_FOCUS               189
#define IDC_CB_AUTO_TILT                190
#define IDC_CB_AUTO_EXPOSURE            191
#define IDC_CB_AUTO_IRIS                192
#define IDC_CB_AUTO_PAN                 193
#define IDC_CB_AUTO_ROLL                194
#define IDS_ZOOM                        200
#define IDS_FOCUS                       201
#define IDS_TILT                        202
#define IDS_EXPOSURE                    203
#define IDS_IRIS                        204
#define IDS_PAN                         205
#define IDS_ROLL                        206
#define IDS_BRIGHTNESS                  207
#define IDS_CONTRAST                    208
#define IDS_HUE                         209
#define IDS_SATURATION                  210
#define IDS_SHARPNESS                   211
#define IDS_WHITEBAL                    212
#define IDS_GAMMA                       213
#define IDS_BACKLIGHT                   214
#define IDS_UNKNOWN_DEVICE_NAME         215
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1089
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete...
// #define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
// #define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD_PTR dwCallback;
       DWORD_PTR dwCallbackInst;
       DWORD  dwFlags;
       DWORD_PTR hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\inc\wdmstrmr.h ===
/****************************************************************************
 *  @doc INTERNAL WDMSTREAMER
 *
 *  @module WDMStrmr.h | Include file for <c CWDMStreamer> class used to get a
 *    stream of video data flowing from WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _WDMSTRMR_H // { _WDMSTRMR_H
#define _WDMSTRMR_H

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct BUFSTRUCT | The <t BUFSTRUCT> structure holds the status of each
 *   video streaming buffer.
 *
 * @field LPVIDEOHDR | lpVHdr | Specifies a pointer to the video header of a
 *   video streaming buffer.
 *
 * @field BOOL | fReady | Set to TRUE if the video buffer is available for
 *   video streaming, FALSE if is locked by the application or queued for
 *   an asynchronous read.
 ***************************************************************************/
// Holds status of each video streaming buffer
typedef struct _BUFSTRUCT {
	LPVIDEOHDR lpVHdr;	// Pointer to the video header of the buffer
	BOOL fReady;		// Set to TRUE if the buffer is available for streaming, FALSE otherwise
} BUFSTRUCT, * PBUFSTRUCT;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct WDMVIDEOBUFF | The <t WDMVIDEOBUFF> structure is used to queue
 *   asynchronous read on a video streaming pin.
 *
 * @field OVERLAPPED | Overlap | Structure used for overlapping IOs.
 *
 * @field BOOL | fBlocking | Set to TRUE if read is going to block.
 *
 * @field KS_HEADER_AND_INFO | SHGetImage | Video streaming structure used
 *   on the video pin to get video data.
 *
 * @field LPVIDEOHDR | pVideoHdr | Pointer to the video header for this WDM
 *   video buffer.
 ***************************************************************************/
// Read buffer structure
typedef struct tagWDMVIDEOBUFF {
	OVERLAPPED			Overlap;		// Structure used for overlapping IOs
	BOOL				fBlocking;		// Set to TRUE if the read operation will execute asynchronously
	KS_HEADER_AND_INFO	SHGetImage;		// Video streaming structure used on the video pin
	LPVIDEOHDR			pVideoHdr;		// Pointer to the video header for this WDM buffer
} WDMVIDEOBUFF, *PWDMVIDEOBUFF;


/****************************************************************************
 *  @doc INTERNAL CWDMSTREAMERCLASS
 *
 *  @class CWDMStreamer | This class provides support for streaming video
 *    data from WDM device streaming pin.
 *
 *  @mdata CWDMPin * | CWDMStreamer | m_pWDMVideoPin | Handle to the video
 *    streaming pin.
 *
 *  @mdata ULONG | CWDMStreamer | m_cntNumVidBuf | Number of video buffers
 *    used for streaming.
 *
 *  @mdata PBUFSTRUCT | CWDMStreamer | m_pBufTable | Pointer to a list of
 *    <t BUFSTRUCT> video buffers used for streaming and their status.
 *
 *  @mdata VIDEO_STREAM_INIT_PARMS | CWDMStreamer | m_CaptureStreamParms |
 *    Streaming initialization parameters.
 *
 *  @mdata LPVIDEOHDR | CWDMStreamer | m_lpVHdrFirst | Head pointer to the
 *    list of video buffers.
 *
 *  @mdata LPVIDEOHDR | CWDMStreamer | m_lpVHdrLast | Tail pointer to the
 *    list of video buffers.
 *
 *  @mdata BOOL | CWDMStreamer | m_fVideoOpen | Set to TRUE if the stream is
 *    open, FALSE otherwise.
 *
 *  @mdata BOOL | CWDMStreamer | m_fStreamingStarted | Set to TRUE if we
 *    are currently streaming video data, FALSE otherwise.
 *
 *  @mdata DWORD | CWDMStreamer | m_dwTimeStart | Timestamp of the first
 *    video buffer ever returned to the application.
 *
 *  @mdata DWORD | CWDMStreamer | m_dwNextToComplete | Index of the next
 *    overlapped read to complete.
 *
 *  @mdata WDMVIDEOBUFF | CWDMStreamer | m_pWDMVideoBuff | Pointer to a
 *    list of <t WDMVIDEOBUFF> used to read data from the video pin.
 *
 *  @mdata DWORD | CWDMStreamer | m_dwFrameCount | Number of frames returned
 *    so far to the application - DEBUG only.
 *
 *  @mdata HANDLE | CWDMStreamer | m_hThread | Handle to our streaming
 *    thread.
 *
 *  @mdata BOOL | CWDMStreamer | m_bKillThread | Set to TRUE to kill our
 *    streaming thread.
 ***************************************************************************/
class CWDMStreamer
{
public:
   CWDMStreamer(CWDMPin * pCWDMPin);
   ~CWDMStreamer() {};

	// Stream control functions
	BOOL Open(LPVIDEO_STREAM_INIT_PARMS lpStreamInitParms);
	BOOL Close();
	BOOL Start();
	BOOL Stop();
	BOOL Reset();
	BOOL AddBuffer(LPVIDEOHDR lpVHdr);

private:
	CWDMPin					*m_pWDMVideoPin;
	ULONG					m_cntNumVidBuf;
	ULONG					m_idxNextVHdr;  // index of expected next Hdr ID
	PBUFSTRUCT				m_pBufTable;
	VIDEO_STREAM_INIT_PARMS	m_CaptureStreamParms;
	LPVIDEOHDR				m_lpVHdrFirst;
	LPVIDEOHDR				m_lpVHdrLast;
	BOOL					m_fVideoOpen;
	BOOL					m_fStreamingStarted;
	DWORD					m_dwTimeStart;
	int						m_dwNextToComplete;
	WDMVIDEOBUFF			*m_pWDMVideoBuff;
#ifdef _DEBUG
	DWORD					m_dwFrameCount;
#endif
    HANDLE					m_hThread;
    BOOL					m_bKillThread;

	// Video buffer management functions
	void BufferDone(LPVIDEOHDR lpVHdr);
	LPVIDEOHDR DeQueueHeader();
	void QueueHeader(LPVIDEOHDR lpVHdr);
	BOOL QueueRead(DWORD dwIndex);

	// User callback function
	void videoCallback(WORD msg, DWORD_PTR dw1);

	// Thread functions
    void Stream(void);
    static LPTHREAD_START_ROUTINE ThreadStub(CWDMStreamer *object);

};

#endif  // } _WDMSTRMR_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\filter\inc\ifilter.h ===
//  IFILTER.H
//
//      Contains the interfaces IVideoFilter and IAudioFilter
//
//  Created 12-Dec-96 [JonT]

#ifndef _IFILTER_H
#define _IFILTER_H

// {2B02415C-5308-11d0-B14C-00C04FC2A118}
DEFINE_GUID(IID_IVideoFilter, 0x2b02415c, 0x5308, 0x11d0, 0xb1, 0x4c, 0x0, 0xc0, 0x4f, 0xc2, 0xa1, 0x18);

typedef struct tagSURFACEINFO
{
    long lWidth;
    long lHeight;
    GUID bfid;
} SURFACEINFO;

#undef  INTERFACE
#define INTERFACE   IVideoFilter

DECLARE_INTERFACE_(IVideoFilter, IUnknown)
{
	// IUnknown method
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IVideoFilter methods
	STDMETHOD(Start)(THIS_ DWORD dwFlags, SURFACEINFO* psiIn, SURFACEINFO* psiOut) PURE;
	STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(Transform)(THIS_ IBitmapSurface* pbsIn, IBitmapSurface* pbsOut, DWORD dwTimestamp) PURE;
};

#endif // #ifndef _IFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\filter\inc\effect.h ===
#ifndef __EFFECT_H__
#define __EFFECT_H__

//{1F9DDD20-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapEffect, 
0x1f9ddd20, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapEffectDescription TEXT("Bitmap Effect")

//#define BITMAP_EFFECT_CAN_OVERLAP   1		// Not needed, only one rect provided
#define BITMAP_EFFECT_INPLACE       1		// effect is done in-place src and dst must be the same
#define BITMAP_EFFECT_REALTIME      2		// this can change based on the BFID and size ??  How do we measure 
#define BITMAP_EFFECT_DIRECTDRAW    4       // Need a dd surface

// {ACEA25C0-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapEffect, 
0xacea25c0, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#undef  INTERFACE
#define INTERFACE   IBitmapEffect

DECLARE_INTERFACE_(IBitmapEffect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapEffect methods
    STDMETHOD(SetSite)(THIS_ IUnknown* punk) PURE;
    STDMETHOD(GetMiscStatusBits)(THIS_ DWORD* pdwFlags) PURE;
    STDMETHOD(GetSupportedFormatsCount)(THIS_ unsigned* pcFormats) PURE;
    STDMETHOD(GetSupportedFormats)(THIS_ unsigned cFormats, BFID* pBFIDs) PURE;
    STDMETHOD(Begin)(THIS_ BFID* pBFID, SIZE* psizeEffect) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(DoEffect)(THIS_ IBitmapSurface* pbsIn, IBitmapSurface* pbsOut, RECT* prectFull, RECT* prectInvalid) PURE;
};

#endif //__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\balance.cpp ===
#include "precomp.h"
#define MAGIC_CPU_DO_NOT_EXCEED_PERCENTAGE 50   //Don't use more than this % of the CPU for encoding (also in audiocpl.cpp)


/***************************************************************************

	Name	  : GetQOSCPULimit

	Purpose   : Gets the total allowed CPU percentage use from QoS

	Parameters: None

	Returns   : How much of the CPU can be used, in percents. 0 means failure

	Comment   :

***************************************************************************/
ULONG GetQOSCPULimit(void)
{
#define MSECS_PER_SEC    900
	IQoS *pQoS=NULL;
	LPRESOURCELIST pResourceList=NULL;
	ULONG ulCPUPercents=0;
	ULONG i;
	HRESULT hr=NOERROR;

	// create the QoS object and get the IQoS interface
	// CoInitialize is called in conf.cpp
	hr = CoCreateInstance(	CLSID_QoS,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IQoS,
							(void **) &pQoS);

	if (FAILED(hr) || !pQoS)
	{
		// this means that QoS was not instantiated yet. Use predefined value
		// ASSERT, because I want to know if this happens
		ASSERT(pQoS);
		ulCPUPercents = MSECS_PER_SEC;
		goto out;
	}

	// get a list of all resources from QoS
	hr = pQoS->GetResources(&pResourceList);
	if (FAILED(hr) || !pResourceList)
	{
		ERROR_OUT(("GetQoSCPULimit: GetReosurces failed"));
		goto out;
	}

	// find the CPU resource
	for (i=0; i < pResourceList->cResources; i++)
	{
		if (pResourceList->aResources[i].resourceID == RESOURCE_CPU_CYCLES)
		{
			// QoS keps the CPU units as the number of ms in a sec that the
			// CPU can be used. Need to divide by 10 to get percents
			ulCPUPercents = pResourceList->aResources[i].nUnits / 10;
			break;
		}
	}

out:
	if (pResourceList)
		pQoS->FreeBuffer(pResourceList);

	if (pQoS)
		pQoS->Release();

	return ulCPUPercents;		
}

HRESULT CapsCtl::ComputeCapabilitySets (DWORD dwBitsPerSec)
{
    HRESULT hr = hrSuccess;
    UINT nAud = 0;
    UINT nAudCaps = 0;
    UINT nVid = 0;
    UINT nVidCaps = 0;
    UINT x, y, nSets = 0;
    BASIC_AUDCAP_INFO *pac = NULL;
    BASIC_VIDCAP_INFO *pvc = NULL;
    MEDIA_FORMAT_ID *AdvList = NULL;
    int CPULimit;
    LPAPPCAPPIF  pAudIF = NULL;
    LPAPPVIDCAPPIF  pVidIF = NULL;

    if (pAudCaps)
    {
    	hr = pAudCaps->QueryInterface(IID_IAppAudioCap, (void **)&pAudIF);
	    if(!HR_SUCCEEDED(hr))
    	{
	    	goto ComputeDone;
    	}
    }

    if (pVidCaps)
    {
    	hr = pVidCaps->QueryInterface(IID_IAppVidCap, (void **)&pVidIF);
	    if(!HR_SUCCEEDED(hr))
    	{
	    	goto ComputeDone;
    	}
    }

    //Save away the Bandwidth
    dwConSpeed=dwBitsPerSec;

    // Create the default PTERMCAPDESCRIPTORS set

    // Get the number of BASIC_VIDCAP_INFO and BASIC_AUDCAP_INFO structures
    // available
    if (pVidIF)
        pVidIF->GetNumFormats(&nVidCaps);
    if (pAudIF)
        pAudIF->GetNumFormats(&nAudCaps);

    if (nAudCaps)
    {
        // Allocate some memory to hold the list in
        if (pac = (BASIC_AUDCAP_INFO*)MemAlloc(sizeof(BASIC_AUDCAP_INFO) * nAudCaps))
        {
            // Get the list
            if ((hr = pAudIF->EnumFormats(pac, nAudCaps * sizeof (BASIC_AUDCAP_INFO), (UINT*)&nAudCaps)) != hrSuccess)
                goto ComputeDone;
        }
        else
        {
            hr = CAPS_E_SYSTEM_ERROR;
            goto ComputeDone;
        }
    }

    if (nVidCaps)
    {
	    // Allocate some memory to hold the video list in
	    if (pvc = (BASIC_VIDCAP_INFO*) MemAlloc(sizeof(BASIC_VIDCAP_INFO) * nVidCaps))
        {
		    // Get the list
            if ((hr = pVidIF->EnumFormats(pvc, nVidCaps * sizeof (BASIC_VIDCAP_INFO), (UINT*)&nVidCaps)) != hrSuccess)
                goto ComputeDone;
        }
	    else
        {
            hr = CAPS_E_SYSTEM_ERROR;
            goto ComputeDone;
        }
	}

    //Allocate memory for the defined list of Codecs, so we can track them
    if (nAudCaps)
    {
        AdvList = (MEDIA_FORMAT_ID*) MemAlloc(sizeof(MEDIA_FORMAT_ID) * nAudCaps);
        if (!AdvList)
        {
            hr = CAPS_E_SYSTEM_ERROR;
            goto ComputeDone;
        }
    }

    if (pAdvertisedSets && pAdvertisedSets->wLength)
    {
        ResetCombinedEntries();
    }

    // We're about to write over pSetIDs, make sure it's freed.
    if (pSetIDs)
    {
        MemFree(pSetIDs);
        pSetIDs = NULL;
    }


    //Allocate nVidCaps+1 Set Ids
    ASSERT(!pSetIDs);
    pSetIDs = (DWORD*) MemAlloc(sizeof(DWORD) * (nVidCaps + 1));
    if (!pSetIDs)
    {
        hr = CAPS_E_SYSTEM_ERROR;
        goto ComputeDone;
    }

    //
    // If we can get a % limit from the QOS, then use that as the upper bound of
    // CPU consumption for a Codec. If it exceeds this bound, do not enable it.
    //
	CPULimit= (int) GetQOSCPULimit();
	if (CPULimit == 0)
		CPULimit = MAGIC_CPU_DO_NOT_EXCEED_PERCENTAGE;

    //
    // Now, sort that list, according to preference
    // This function adds the sets to the advertised list.  It sorts audio
    // by each video codec.
    //
	for (x=0; ((x<nVidCaps) && (nVid < H245_MAX_ALTCAPS));x++)
	{
        //Check to make sure the video codec can be advertised.
		if ((pvc[x].wCPUUtilizationDecode < CPULimit)
   	   		&& pvc[x].bRecvEnabled
   	   		&& pVidCaps->IsFormatPublic(pvc[x].Id))
   	   	{
   	   	    nVid++;
		
            // Loop through the Audio codecs, checking to see if they can
            // fit alongside the video codec
            // BUGBUG - we only check the total BW and CPU because we rely on
            // QOS to scale back the video in favor of audio. in other words,
            // video can be scaled down to zero BW and CPU.
            for (y=0;((y<nAudCaps) && (nAud < H245_MAX_ALTCAPS)) ;y++)
            {
        	    if ((pac[y].wCPUUtilizationDecode < CPULimit) &&
        	       ((pac[y].uAvgBitrate <= dwBitsPerSec && pac[y].bRecvEnabled)
        	       && pAudCaps->IsFormatPublic(pac[y].Id)))
        	    {
                    // going to advertise this ID in this
        			AdvList[nAud++]=pac[y].Id;
        	    }	
            }

            //Advertise this set, if we can do audio and video
            if (nAud)
            {
                hr = AddCombinedEntry (AdvList,nAud,&pvc[x].Id,1,&pSetIDs[nSets++]);
        	    if(!HR_SUCCEEDED(hr))
                {
                    goto ComputeDone;
        	    }
            }

            nAud = 0;
 		}
    }

//#if(0)
// Advertising only one media type in a simcaps set is redundant.
	//Now, do the no-video case. If we couldn't advertise above.-- Which implies, in this iteration
	// A problem with all the video codecs. We don't do any "combined" compares, so we know
	// it's a video problem (if it's audio, well we won't have anything to advertise anyways)
	if (!nSets)
    {
    	for (y=0;y<nAudCaps;y++)
    	{
       		if ((pac[y].wCPUUtilizationDecode < CPULimit) &&
    	   		((pac[y].uAvgBitrate <= dwBitsPerSec && pac[y].bRecvEnabled)
    	   		&& pAudCaps->IsFormatPublic(pac[y].Id)))
    		{
    	   	   //Advertise this ID
        	   AdvList[nAud++]=pac[y].Id;
        	}
    	}

        //Advertise this set, if we can do any audio codecs alone
        if (nAud)
        {
            //Since the set is 0 based the nVidCaps+1th entry is nVidcaps...
            hr=AddCombinedEntry (AdvList,nAud,NULL,0,&pSetIDs[nSets++]);
            if(!HR_SUCCEEDED(hr))
            {
                goto ComputeDone;
            }
        }
    }

//#endif // if(0)
ComputeDone:

    if (pVidIF)
    {
        pVidIF->Release();
    }

    if (pAudIF)
    {
        pAudIF->Release();
    }

    if (AdvList)
    {
        MemFree(AdvList);
    }

    if (pvc)
    {
        MemFree(pvc);
    }

    if (pac)
    {
        MemFree(pac);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\vxd\makefile.inc ===
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 $(ASM_FLAGS) -Cx -DMASM6
LINKVXD_FLAGS = -align:0x1000 -nodefaultlib -VXD

!IF "$(BUILD_ALT_DIR)" == "d"
ASM_FLAGS = $(ASM_FLAGS) -Zi -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) $(INCPATH0) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(INCPATH0) $(ASM_FLAGS)
<<NOKEEP

TARGETCOPY_CMD = $(TARGETCOPY_CMD:.exe=.vxd)
MAPCOPY_CMD = $(MAPCOPY_CMD:exe=vxd)
SYMCOPY_CMD = $(SYMCOPY_CMD:exe=vxd)
PDBCOPY_CMD = $(PDBCOPY_CMD:exe=vxd)
DBGCOPY_CMD = $(DBGCOPY_CMD:exe=vxd)

$(O)\dcapvxd.res: dcapvxd.rc
    $(DEVROOT)\bin\c816\i386\rc -r -I $(DEVROOT)\inc16 -I $(ROOT)\h -fo $@ dcapvxd.rc

!IFDEF NOLINK
$(O)\dcapvxd.vxd:
    @echo

!ELSE    
$(O)\dcapvxd.vxd: $(O)\dcapvxd.obj dcapvxd.def $(O)\dcapvxd.res
    editbin $(O)\dcapvxd.obj
    link $(O)\dcapvxd.obj $(LINKVXD_FLAGS) -def:dcapvxd.def -out:$(O)\dcapvxd.vxd -map:$(O)\dcapvxd.map
    $(DEVROOT)\bin\misc\i386\adrc2vxd.exe $(O)\dcapvxd.vxd $(O)\dcapvxd.res
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(PDBCOPY_CMD)
    $(DBGCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
    
!ENDIF

$(O)\dcapvxd.lib:
    @echo no lib
$(O)\dcapvxd.exp:
    @echo no exp
$(O)\dcapvxd.exe:
    @echo no exe
# blank target to avoid linking a useless exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\dcap\vxd\dcapvxd.asm ===
;  DCAPVxD.ASM
;
;	A VxD whose purpose is to be able to set a Win32 event at
;	interrupt time
;
;  Created 	     13-Aug-96 [JonT]
;  DeviceIO support  29-May-97 [MikeG]

PAGE 58,132
    .386p

WIN40COMPAT EQU 1

    .xlist
    include vmm.inc
    include debug.inc
    include vwin32.inc
    .list

; The following equate makes the VXD dynamically loadable.
DCAPVXD_DYNAMIC		equ	1

; Our version
DCAPVXD_MAJOR   	equ     1
DCAPVXD_MINOR   	equ     0
DCAPVXD_VERSION 	equ     ((DCAPVXD_MAJOR shl 8) + DCAPVXD_MINOR)

; Magic Function code values for DeviceIOControl code.
DCAPVXD_THREADTIMESERVICE equ	101h
DCAPVXD_R0THREADIDSERVICE equ   102h

;============================================================================
;        V I R T U A L   D E V I C E   D E C L A R A T I O N
;============================================================================

DECLARE_VIRTUAL_DEVICE DCAPVXD, 1, 0, DCAPVXD_Control, UNDEFINED_DEVICE_ID, \
                        UNDEFINED_INIT_ORDER,,DCAPVXD_PMAPI_Handler

VxD_LOCKED_CODE_SEG

;===========================================================================
;
;   PROCEDURE: DCAPVXD_Control
;
;   DESCRIPTION:
;    Device control procedure for the DCAPVXD VxD
;
;   ENTRY:
;    EAX = Control call ID
;
;   EXIT:
;    If carry clear then
;        Successful
;    else
;        Control call failed
;
;   USES:
;    EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;============================================================================

BeginProc DCAPVXD_Control

;	Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, DCAPVXD_Dynamic_Init
;	Control_Dispatch SYS_DYNAMIC_DEVICE_EXIT, DCAPVXD_Dynamic_Exit
	Control_Dispatch W32_DEVICEIOCONTROL,     DCAPVXD_DeviceIOControl
	clc
	ret

EndProc DCAPVXD_Control

VxD_LOCKED_CODE_ENDS

VxD_PAGEABLE_CODE_SEG

;===========================================================================
;
;   PROCEDURE: DCAPVXD_PMAPI_Handler
;
;   DESCRIPTION:
;	Win16 API handler
;
;   ENTRY:
;       EBX = VM handle
;       EBP = ptr to client register set
;
;   EXIT:
;       Carry set if  failed
;       else carry clear
;
;   USES:
;    EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;============================================================================

BeginProc DCAPVXD_PMAPI_Handler

	movzx   eax, [ebp.Client_AX]
	or	ah, ah			;AH = 0 is Get Version
	jz	DCAPVXD_Get_Version
	dec	ah                      ;AH = 1 is Set Event
	jz	DCAPVXD_Set_Event
	dec	ah			;AH = 2 is Close VxD Handle
	jz	DCAPVXD_Close_VxD_Handle
	
	public DCAPVXD_PMAPI_FAIL
DCAPVXD_PMAPI_FAIL:
	or      [ebp.Client_EFlags], CF_MASK
	ret
	
	public DCAPVXD_PMAPI_OK	
DCAPVXD_PMAPI_OK:
	and     [ebp.Client_EFlags], NOT CF_MASK
	ret
	
EndProc DCAPVXD_PMAPI_Handler


;  DCAPVXD_Get_Version
;	Returns the version of the device

BeginProc DCAPVXD_Get_Version

	mov	WORD PTR [ebp.Client_AX], DCAPVXD_VERSION
	jmp	DCAPVXD_PMAPI_OK

EndProc DCAPVXD_Get_Version


;  DCAPVXD_Set_Event
;	Sets a Win32 event.
;  Entry:
;	ECX points to a Win32 event (NOT a handle!)
;  Returns:
;	EAX	 0:Event pointer invalid
;		-1:Event queued to be set later
;		 1:Event set now

BeginProc DCAPVXD_Set_Event

	; Set the event
	mov	eax, [ebp.Client_ECX]
	VxDcall	_VWIN32_SetWin32Event
	
	; If the return is NC, EAX is 1, so return
	mov	[ebp.Client_EAX], eax
	jnc	DCAPVXD_PMAPI_OK
	
	; If the return is CY and EAX is 0, bad parameter, return 0
	or	eax, eax
	jc	DCAPVXD_PMAPI_Fail
	
	; If the return is CY and EAX is 1, SetEvent was queued. Return -1
	neg	eax
	mov	[ebp.Client_EAX], eax
	jmp	DCAPVXD_PMAPI_OK
	
EndProc DCAPVXD_Set_Event


;  DCAPVXD_Close_VxD_Handle
;	Frees a locked Win32 object for which we had a pointer. We can only
;	call this from a VxD, unfortunately, even though it's just going to
;	turn around and run it at ring 0.

BeginProc DCAPVXD_Close_VxD_Handle

	mov	eax, [ebp.Client_ECX]
	VxDcall	_VWIN32_CloseVxDHandle
	jmp	DCAPVXD_PMAPI_OK
	
EndProc DCAPVXD_Close_VxD_Handle


;******************************************************************************
;
; DCAPVXD_DeviceIOControl
;
; Handle the 32bit api calls from 32bit applications.  The 32 bit apps cannot
; use int 2f for api calls, so this interface has been provided.
;
; We'll just swizzle the parameters into what our int 2F interface expects and
; call its subroutines.
;
; Entry:
;	EAX = W32_DEVICEIOCONTROL
;	EBX = DDB
;	ECX = dwIoControlCode (DIOC_GETVERSION or DIOC_OPEN)
;	EDX = hDevice (Handle)
;	ESI = Pointer to DIOCParams
;
;	ECX = 	DIOC_GetVersion = 0
;		DIOC_Open	= 0
;		Define our own flags starting at 100h
;
;
;
;
; EXIT:
;	EAX = 0 = success
;	ECX = Version number if version call
;
;==============================================================================

;;If we keep adding codes, fixup the jumps below to be a table
;;If you do this be VERY careful. We are using a magic IOCtl base for
;;functions. Also, define a common header file, or come see me [mikeg] or
;;richp.

	Public DCAPVXD_DeviceIOControl
BeginProc DCAPVXD_DeviceIOControl

	push	edi
	push	esi
	mov	eax, [esi.lpvInBuffer]		;;If functions added, verify input buffer
	mov	edi, [esi.lpcbBytesReturned]	;;size
	mov	edx, [esi.lpvOutBuffer]		;;EDX is HOT! Don't smash


	cmp	ecx,DIOC_OPEN
	jne	short @F
	mov	ecx, 0400h			;;Win95 and later
	mov	dword ptr [edx],ecx
	mov	dword ptr [edi], 4
	xor	eax,eax
	jmp 	short DIOC_Exit

@@:

	cmp	ecx,DCAPVXD_THREADTIMESERVICE
	je 	short 	DIOC_ThreadTime

	cmp	ecx,DCAPVXD_R0THREADIDSERVICE
	je 	short DIOC_GetThreadID
	jmp	short DIOC_NotImp


DIOC_ThreadTime:
	mov	eax,dword ptr [eax]		;;eax points to the handle value...
	VMMCall _GetThreadExecTime, <eax>	;;C convention...
		
	mov	dword ptr [edx],eax
	mov	dword ptr [edi], 4
	xor	eax,eax				;;EAX==0 success
	jmp 	short DIOC_Exit

DIOC_GetThreadID:
	mov	ecx,edi				;;Keep the ptr to the cbBytes....
	VMMCall Get_Cur_Thread_Handle
	mov	dword ptr [edx],edi
	mov	dword ptr [ecx ], 4
	xor	eax,eax
	jmp short DIOC_Exit

DIOC_NotImp:

	mov 	eax,-1				;; Failure. No other calls supported


DIOC_Exit:
	pop	esi
	pop	edi
	clc
	ret

EndProc DCAPVXD_DeviceIOControl
VxD_PAGEABLE_CODE_ENDS

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\filter\inc\ibitmap.h ===
//  IBITMAP.H
//
//      Contains the interfaces IBitmapSurface and IBitmapSurfaceFactory
//
//      Note that this file is probably a duplicate of one in the Trident project,
//      but I haven't located it yet...
//
//  Created 12-Dec-96 [JonT]

#ifndef _IBITMAP_H
#define _IBITMAP_H

// IIDs
// {3050f2ef-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IBitmapSurface,
0x3050f2ef, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f2f2-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IBitmapSurfaceFactory,
0x3050f2f2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// BFIDs (Bitmap format IDs)
typedef GUID BFID;

// e436eb78-524f-11ce-9f53-0020af0ba770            BFID_RGB1
DEFINE_GUID(BFID_MONOCHROME,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb79-524f-11ce-9f53-0020af0ba770            BFID_RGB4
DEFINE_GUID(BFID_RGB_4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7a-524f-11ce-9f53-0020af0ba770            BFID_RGB8
DEFINE_GUID(BFID_RGB_8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7b-524f-11ce-9f53-0020af0ba770            BFID_RGB565
DEFINE_GUID(BFID_RGB_565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7c-524f-11ce-9f53-0020af0ba770            BFID_RGB555
DEFINE_GUID(BFID_RGB_555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7d-524f-11ce-9f53-0020af0ba770            BFID_RGB24
DEFINE_GUID(BFID_RGB_24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7e-524f-11ce-9f53-0020af0ba770            BFID_RGB32
DEFINE_GUID(BFID_RGB_32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// Forward definitions
#ifndef __IBitmapSurface_FWD_DEFINED__
#define __IBitmapSurface_FWD_DEFINED__
typedef interface IBitmapSurface IBitmapSurface;
#endif 	// __IBitmapSurface_FWD_DEFINED__

#ifndef __IBitmapSurfaceFactory_FWD_DEFINED__
#define __IBitmapSurfaceFactory_FWD_DEFINED__
typedef interface IBitmapSurfaceFactory IBitmapSurfaceFactory;
#endif 	// __IBitmapSurfaceFactory_FWD_DEFINED__

// Interfaces

#undef  INTERFACE
#define INTERFACE   IBitmapSurface

DECLARE_INTERFACE_(IBitmapSurface, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapSurface methods
	STDMETHOD(Clone)(THIS_ IBitmapSurface** ppBitmapSurface) PURE;
	STDMETHOD(GetFormat)(THIS_ BFID* pBFID) PURE;
	STDMETHOD(GetFactory)(THIS_ IBitmapSurfaceFactory** ppBitmapSurfaceFactory) PURE;
	STDMETHOD(GetSize)(THIS_ long* pWidth, long* pHeight) PURE;
	STDMETHOD(LockBits)(THIS_ RECT* prcBounds, DWORD dwLockFlags, void** ppBits, long* pPitch) PURE;
	STDMETHOD(UnlockBits)(THIS_ RECT* prcBounds, void* pBits) PURE;
};

#undef  INTERFACE
#define INTERFACE   IBitmapSurfaceFactory

DECLARE_INTERFACE_(IBitmapSurfaceFactory, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapSurfaceFactory methods
    STDMETHOD(CreateBitmapSurface)(THIS_ long width, long height, BFID* pBFID, DWORD dwHintFlags, IBitmapSurface** ppBitmapSurface) PURE;
	STDMETHOD(GetSupportedFormatsCount)(THIS_ long* pcFormats) PURE;
	STDMETHOD(GetSupportedFormats)(THIS_ long cFormats, BFID* pBFIDs) PURE;
};

#endif // #ifndef _IBITMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\capsctl.cpp ===
/*
 *    File: capsctl.cpp
 *
 *    capability control object implementations
 *
 *
 *    Revision History:
 *
 *    10/10/96 mikeg created
 * 	  06/24/97 mikev	- Added T.120 capability to serialized caps and simcaps (interim hack until a
 *							T120 resolver is implemented)
 *						- Retired  ResolveEncodeFormat(Audio,Video) and implemented a data-independent
 *						resolution algorithm and exposed method ResolveFormats(). Added support
 * 						routines ResolvePermutations(), TestSimultaneousCaps() and
 *						AreSimcaps().
 */

#include "precomp.h"
UINT g_AudioPacketDurationMs = AUDIO_PACKET_DURATION_LONG;	// preferred packet duration
BOOL g_fRegAudioPacketDuration = FALSE;	// AudioPacketDurationMs from registry


PCC_TERMCAPDESCRIPTORS CapsCtl::pAdvertisedSets=NULL;
DWORD CapsCtl::dwConSpeed = 0;
UINT CapsCtl::uStaticGlobalRefCount=0;
UINT CapsCtl::uAdvertizedSize=0;
extern HRESULT WINAPI CreateMediaCapability(REFGUID, LPIH323MediaCap *);

LPIH323MediaCap CapsCtl::FindHostForID(MEDIA_FORMAT_ID id)
{
	if(pAudCaps && pAudCaps->IsHostForCapID(id))
	{
		return (pAudCaps);
	}
	else if (pVidCaps  && pVidCaps->IsHostForCapID(id))
	{
  		return (pVidCaps);
	}
	return NULL;
}

LPIH323MediaCap CapsCtl::FindHostForMediaType(PCC_TERMCAP pCapability)
{
	if(pCapability->DataType == H245_DATA_AUDIO)
	{
		return (pAudCaps);
	}
	else if(pCapability->DataType == H245_DATA_VIDEO)
	{
  		return (pVidCaps);
	}
	return NULL;
}

LPIH323MediaCap CapsCtl::FindHostForMediaGuid(LPGUID pMediaGuid)
{

	if(MEDIA_TYPE_H323VIDEO == *pMediaGuid)
	{
  		return (pVidCaps);
	}
	else if(MEDIA_TYPE_H323AUDIO == *pMediaGuid)
	{
		return (pAudCaps);
	}
	else
		return NULL;
}

ULONG CapsCtl::AddRef()
{
	uRef++;
	return uRef;
}

ULONG CapsCtl::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	return uRef;
}

STDMETHODIMP CapsCtl::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IDualPubCap)// satisfy symmetric property of QI
	{
		*ppvObject = (IDualPubCap *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if(iid == IID_IAppAudioCap )
	{
		if(pAudCaps)
		{
			return pAudCaps->QueryInterface(iid, ppvObject);
		}
	}
	else if(iid == IID_IAppVidCap )
	{
		if(pVidCaps)
		{
			return pVidCaps->QueryInterface(iid, ppvObject);
		}
	}
	return hr;
}



CapsCtl::CapsCtl () :
uRef(1),
pVidCaps(NULL),
pAudCaps(NULL),
pACapsBuf(NULL),
pVCapsBuf(NULL),
dwNumInUse(0),
bAudioPublicize(TRUE),
bVideoPublicize(TRUE),
bT120Publicize(TRUE),
m_localT120cap(INVALID_MEDIA_FORMAT),
m_remoteT120cap(INVALID_MEDIA_FORMAT),
m_remoteT120bitrate(0),
m_pAudTermCaps(NULL),
m_pVidTermCaps(NULL),
pSetIDs(NULL),
pRemAdvSets(NULL)
{
   uStaticGlobalRefCount++;
}

CapsCtl::~CapsCtl ()
{

   if (pACapsBuf) {
      MemFree (pACapsBuf);
   }
   if (pVCapsBuf) {
      MemFree (pVCapsBuf);
   }

   if (pAudCaps) {
      pAudCaps->Release();
   }

   if (pVidCaps) {
      pVidCaps->Release();
   }
   uStaticGlobalRefCount--;
   if (uStaticGlobalRefCount == 0) {
       //Free up the sim. caps array
       if (pAdvertisedSets) {
          while (pAdvertisedSets->wLength) {
             //wLength is Zero based
             MemFree ((VOID *)pAdvertisedSets->pTermCapDescriptorArray[--pAdvertisedSets->wLength]);
          }
          MemFree ((VOID *)pAdvertisedSets->pTermCapDescriptorArray);
          pAdvertisedSets->pTermCapDescriptorArray = NULL;
          MemFree ((void *) pAdvertisedSets);
          pAdvertisedSets=NULL;
          dwNumInUse=0;
       }
   }

   //And the remote array
   if (pRemAdvSets) {
      while (pRemAdvSets->wLength) {
         MemFree ((VOID *)pRemAdvSets->pTermCapDescriptorArray[--pRemAdvSets->wLength]);
      }
      MemFree ((void *) pRemAdvSets->pTermCapDescriptorArray);
      pRemAdvSets->pTermCapDescriptorArray = NULL;
      MemFree ((void *) pRemAdvSets);
      pRemAdvSets=NULL;
   }
   MemFree (pSetIDs);
   pSetIDs=NULL;
}

BOOL CapsCtl::Init()
{
    HRESULT hrLast;
    int iBase = 1;

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
    	hrLast = ::CreateMediaCapability(MEDIA_TYPE_H323AUDIO, &pAudCaps);
	    if(!HR_SUCCEEDED(hrLast))
    	{
            goto InitDone;
    	}
    }

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
    	hrLast = ::CreateMediaCapability(MEDIA_TYPE_H323VIDEO, &pVidCaps);
	    if(!HR_SUCCEEDED(hrLast))
    	{
            goto InitDone;
    	}
    }

    if (pAudCaps)
    {
    	// Base the capability IDs beginning at 1  (zero is an invalid capability ID!)
	    pAudCaps->SetCapIDBase(iBase);
        iBase += pAudCaps->GetNumCaps();
    }

    if (pVidCaps)
    {
        pVidCaps->SetCapIDBase(iBase);
        iBase += pVidCaps->GetNumCaps();
    }

InitDone:
	m_localT120cap = iBase;
	return TRUE;
}
																								
HRESULT CapsCtl::ReInitialize()
{
	HRESULT hr = hrSuccess;
    int iBase = 1;

	if (pAudCaps && !pAudCaps->ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto EXIT;
	}

	if (pVidCaps && !pVidCaps->ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto EXIT;
	}

	// Base the capability IDs beginning at 1  (zero is an invalid capability ID!)
    if (pAudCaps)
    {
    	pAudCaps->SetCapIDBase(iBase);
        iBase += pAudCaps->GetNumCaps();
    }

    if (pVidCaps)
    {
        pVidCaps->SetCapIDBase(iBase);
        iBase += pVidCaps->GetNumCaps();
    }

	m_localT120cap = iBase;

EXIT:
	return hr;
}

const char szNMProdNum[] = "Microsoft\256 NetMeeting(TM)\0";
const char szNM20VerNum[] = "Version 2.0\0";

HRESULT CapsCtl::AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList,PCC_TERMCAPDESCRIPTORS pTermCapDescriptors, PCC_VENDORINFO pVendorInfo)
{
	FX_ENTRY("CapsCtl::AddRemoteDecodeCaps");
	HRESULT hr;
	void      	  *pData=NULL;
	UINT		  uSize,x,y,z;


   //WLength is # of capabilities, not structure length
	WORD wNDesc;
	LPIH323MediaCap pMediaCap;
	
	if(!pTermCapList && !pTermCapDescriptors) 	// additional capability descriptors may be added
	{											// at any time
	   return CAPS_E_INVALID_PARAM;
	}
	// Check for NM version 2.0
	m_fNM20 = FALSE;
	ASSERT(pVendorInfo);
	if (pVendorInfo->bCountryCode == USA_H221_COUNTRY_CODE
		&& pVendorInfo->wManufacturerCode == MICROSOFT_H_221_MFG_CODE
		&& pVendorInfo->pProductNumber && pVendorInfo->pVersionNumber
		&& pVendorInfo->pProductNumber->wOctetStringLength == sizeof(szNMProdNum)
		&& pVendorInfo->pVersionNumber->wOctetStringLength == sizeof(szNM20VerNum)
		&& memcmp(pVendorInfo->pProductNumber->pOctetString, szNMProdNum, sizeof(szNMProdNum)) == 0
		&& memcmp(pVendorInfo->pVersionNumber->pOctetString, szNM20VerNum, sizeof(szNM20VerNum)) == 0
		)
	{
		m_fNM20 = TRUE;
	}

	// cleanup old term caps if term caps are being added and old caps exist
    if (pAudCaps)
    	pAudCaps->FlushRemoteCaps();
    if (pVidCaps)
    	pVidCaps->FlushRemoteCaps();
	m_remoteT120cap = INVALID_MEDIA_FORMAT;	// note there is no T120 cap resolver and
												// this CapsCtl holds exactly one local and remote T120 cap
	
	// Copy pTermcapDescriptors to a local copy, (and free any old one)
	if (pRemAdvSets) {
	   while (pRemAdvSets->wLength) {
		  //0 based
		  MemFree ((VOID *)pRemAdvSets->pTermCapDescriptorArray[--pRemAdvSets->wLength]);
	   }

	   MemFree ((VOID *)pRemAdvSets->pTermCapDescriptorArray);
	   pRemAdvSets->pTermCapDescriptorArray = NULL;
	   MemFree ((VOID *)pRemAdvSets);
	   pRemAdvSets=NULL;

	}

	//Ok, walk through the PCC_TERMCAPDESCRIPTORS list, first, allocate memory for the Master PCC_TERMCAPDESCRIPTORS
	//structure, then each simcap, and the altcaps therin, then copy the data.

	if (!(pRemAdvSets=(PCC_TERMCAPDESCRIPTORS) MemAlloc (sizeof (CC_TERMCAPDESCRIPTORS) ))){
	   return CAPS_E_SYSTEM_ERROR;
	}

	//How many Descriptors?
	pRemAdvSets->wLength=pTermCapDescriptors->wLength;

	if (!(pRemAdvSets->pTermCapDescriptorArray=((H245_TOTCAPDESC_T **)MemAlloc (sizeof (H245_TOTCAPDESC_T*)*pTermCapDescriptors->wLength))) ) {
	   return CAPS_E_SYSTEM_ERROR;
	}

	//Once per descriptor...
	for (x=0;x < pTermCapDescriptors->wLength;x++) {
	   //Allocate memory for the descriptor entry
	   if (!(pRemAdvSets->pTermCapDescriptorArray[x]=(H245_TOTCAPDESC_T *)MemAlloc (sizeof (H245_TOTCAPDESC_T)))) {
		  return CAPS_E_SYSTEM_ERROR;
	   }

	   //BUGBUG for beta 2 Copy en masse.
	   memcpy (pRemAdvSets->pTermCapDescriptorArray[x],pTermCapDescriptors->pTermCapDescriptorArray[x],sizeof (H245_TOTCAPDESC_T));

/*	post beta 2?
	   //Copy the capability ID
	   pRemAdvSets->pTermCapDescriptorArray[x].CapID=pTermCapDescriptors[x].CapID
	   //Walk the simcaps, then altcaps and copy entries */
	}


	for (wNDesc=0;wNDesc <pTermCapList->wLength;wNDesc++) {
	  pData=NULL;
		pMediaCap = FindHostForMediaType(pTermCapList->pTermCapArray[wNDesc]);
		if(!pMediaCap)
		{
			// special case: there is no T120 resolver. THIS IS A TEMPORARY
			// SITUATION. We cannot track bitrate limits on multiple T120 capability
			// instances because of this.  As of now, we (NetMeeting) do not advertise
			// more than one T.120 capability.

			//This code will keep the last T.120 capability encountered.
			if(((pTermCapList->pTermCapArray[wNDesc])->DataType == H245_DATA_DATA)
			&& ((pTermCapList->pTermCapArray[wNDesc])->Cap.H245Dat_T120.application.choice
				== DACy_applctn_t120_chosen)
			&& ((pTermCapList->pTermCapArray[wNDesc])->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice
				== separateLANStack_chosen))
			{
				// it's data data
				m_remoteT120cap = (pTermCapList->pTermCapArray[wNDesc])->CapId;
				m_remoteT120bitrate =
					(pTermCapList->pTermCapArray[wNDesc])->Cap.H245Dat_T120.maxBitRate;
			}
			
			// continue;
			// handled it in-line
		}
	  	else if(pMediaCap->IsCapabilityRecognized(pTermCapList->pTermCapArray[wNDesc]))
	  	{
			hr = pMediaCap->AddRemoteDecodeFormat(pTermCapList->pTermCapArray[wNDesc]);
			#ifdef DEBUG
			if(!HR_SUCCEEDED(hr))
			{
				ERRORMESSAGE(("%s:AddRemoteDecodeFormat returned 0x%08lx\r\n",_fx_, hr));
			}
			#endif // DEBUG
	  	}
	}
	return (hrSuccess);
}


HRESULT CapsCtl::CreateCapList(PCC_TERMCAPLIST *ppCapBuf, PCC_TERMCAPDESCRIPTORS *ppCombinations)
{
   	PCC_TERMCAPLIST pTermCapList = NULL, pTermListAud=NULL, pTermListVid=NULL;
	PCC_TERMCAPDESCRIPTORS pCombinations;
	UINT uCount = 0, uSize = 0, uT120Size = 0;
	HRESULT hr;
	WORD wc;
   	UINT x=0,y=0,z=0,uNumAud=0,uNumVid=0;
	H245_TOTCAPDESC_T *pTotCaps, **ppThisDescriptor;
	PPCC_TERMCAP  ppCCThisTermCap;	
	PCC_TERMCAP  pCCT120Cap = NULL;

	uCount = GetNumCaps(TRUE);

	ASSERT((NULL == m_pAudTermCaps) && (NULL == m_pVidTermCaps));
	
	// calc size of CC_TERMCAPLIST header + CC_TERMCAPDESCRIPTORS + array of PCC_TERMCAP
	// allocate mem for the master CC_TERMCAPLIST, including the array of pointers to all CC_TERMCAPs
	uSize = sizeof(CC_TERMCAPLIST)
		+ sizeof (CC_TERMCAPDESCRIPTORS) + (uCount * sizeof(PCC_TERMCAP));
	if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
	{
		uSize += sizeof(CC_TERMCAP);
	}

	pTermCapList = (PCC_TERMCAPLIST)MemAlloc(uSize);
  	if(pTermCapList == NULL)
  	{
		hr = CAPS_E_NOMEM;
		goto ERROR_EXIT;
  	}
	
	// divide up the buffer, CC_TERMCAPLIST first, followed by array of PCC_TERMCAP.
	// The array of PCC_TERMCAP follows fixed size CC_TERMCAPLIST structure and the fixed size
	// CC_TERMCAP structure that holds the one T.120 cap.
	if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
	{
		pCCT120Cap = (PCC_TERMCAP)(((BYTE *)pTermCapList) + sizeof(CC_TERMCAPLIST));
		ppCCThisTermCap = (PPCC_TERMCAP) (((BYTE *)pTermCapList) + sizeof(CC_TERMCAPLIST) +
			sizeof(CC_TERMCAP));
	}
	else
		ppCCThisTermCap = (PPCC_TERMCAP) (((BYTE *)pTermCapList) + sizeof(CC_TERMCAPLIST));
	
	// allocate mem for the simultaneous caps
	// get size of cached advertised sets if it exists and more than one media
	// type is enabled for publication
	if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)
	{
		// use size of cached buffer
		uSize = uAdvertizedSize;
	}
	else if (pAdvertisedSets)
	{
		// This case needs to be fixed. If media types are disabled, the simultaneous capability
		// descriptors in pAdvertisedSets should be rebuilt at that time. There should be no need to test
		// if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)

   		// calculate size of capability descriptors and simultaneous capability structures.

		#pragma message ("Figure out the size this needs to be...")
		#define NUMBER_TERMCAP_DESCRIPTORS 1
		uSize = sizeof(H245_TOTCAPDESC_T) * NUMBER_TERMCAP_DESCRIPTORS+
						  sizeof (CC_TERMCAPDESCRIPTORS)+NUMBER_TERMCAP_DESCRIPTORS*
						  sizeof (H245_TOTCAPDESC_T *);
	}
    else
    {
        uSize = 0;
    }

	
    if (uSize)
    {
    	pCombinations = (PCC_TERMCAPDESCRIPTORS)MemAlloc(uSize);
	    // skip the CC_TERMCAPDESCRIPTORS, which has a variable length array of (H245_TOTCAPDESC_T *) following it
    	// the total size of that glob is uSimCapsSize
	    // The actual array of [H245_TOTCAPDESC_T *] follows the CC_TERMCAPDESCRIPTORS structure
    	// anchor the pCombinations->pTermCapDescriptorArray to this point.
	    if(pCombinations == NULL)
      	{
	    	hr = CAPS_E_NOMEM;
		    goto ERROR_EXIT;
      	}
	
	    ppThisDescriptor = pCombinations->pTermCapDescriptorArray
		    = (H245_TOTCAPDESC_T **)((BYTE *)pCombinations + sizeof(CC_TERMCAPDESCRIPTORS));
    	// the first H245_TOTCAPDESC_T follows the array of [H245_TOTCAPDESC_T *]
	    pTotCaps = (H245_TOTCAPDESC_T *)((BYTE *)ppThisDescriptor + pCombinations->wLength*sizeof(H245_TOTCAPDESC_T **));

    	if(pAudCaps && bAudioPublicize)
	    {
		    hr=pAudCaps->CreateCapList((LPVOID *)&pTermListAud);
    		if(!HR_SUCCEEDED(hr))
	    		goto ERROR_EXIT;
		    ASSERT(pTermListAud != NULL);
    	}
	    if(pVidCaps && bVideoPublicize)
    	{
	    	hr=pVidCaps->CreateCapList((LPVOID *)&pTermListVid);
		    if(!HR_SUCCEEDED(hr))
			    goto ERROR_EXIT;
    		ASSERT(pTermListVid != NULL);
	    }
    }
    else
    {
        pCombinations = NULL;
    }

	// fix pointers in the master caps list

	// Now need to fixup the CC_TERMCAPLIST to refer to the individual capabilities
	// Anchor the CC_TERMCAPLIST member pTermCapArray at the array of PCC_TERMCAP, and
	// start partying on the array.
	pTermCapList->wLength =0;
	pTermCapList->pTermCapArray = ppCCThisTermCap;

	if(pCCT120Cap)
	{
		*ppCCThisTermCap++ = pCCT120Cap;	
		// set T120 capability parameters
		pCCT120Cap->DataType = H245_DATA_DATA;
		pCCT120Cap->ClientType = H245_CLIENT_DAT_T120;
		pCCT120Cap->Dir = H245_CAPDIR_LCLRXTX;
		
		pCCT120Cap->Cap.H245Dat_T120.application.choice = DACy_applctn_t120_chosen;
		pCCT120Cap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice= separateLANStack_chosen;
		pCCT120Cap->Cap.H245Dat_T120.maxBitRate = dwConSpeed;

		pCCT120Cap->CapId = (H245_CAPID_T)m_localT120cap;	
		pTermCapList->wLength++;
	}
	if(pAudCaps && pTermListAud)
	{
		for(wc = 0; wc < pTermListAud->wLength; wc++)
		{
			// copy the array of "pointers to CC_TERMCAP"
			*ppCCThisTermCap++ = pTermListAud->pTermCapArray[wc];
			pTermCapList->wLength++;
		}
	}
	if(pVidCaps && pTermListVid)
	{
		for(wc = 0; wc <  pTermListVid->wLength; wc++)
		{
			// copy the array of "pointers to CC_TERMCAP"
			*ppCCThisTermCap++ = pTermListVid->pTermCapArray[wc];
			pTermCapList->wLength++;			
		}

	}
	// fixup the simultaneous capability descriptors
	//	Create a default set if necessary
	//

	if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)
	{
		pCombinations->wLength = pAdvertisedSets->wLength;
       	// point pCombinations->pTermCapDescriptorArray past the header (CC_TERMCAPDESCRIPTORS)
        pCombinations->pTermCapDescriptorArray
			= (H245_TOTCAPDESC_T **)((BYTE *)pCombinations + sizeof(CC_TERMCAPDESCRIPTORS));
        // the first H245_TOTCAPDESC_T follows the array of [H245_TOTCAPDESC_T *]
        pTotCaps = (H245_TOTCAPDESC_T *)((BYTE *)pCombinations->pTermCapDescriptorArray +
            pAdvertisedSets->wLength*sizeof(H245_TOTCAPDESC_T **));			
		
		for(x = 0; x < pAdvertisedSets->wLength; x++)
		{
			// write into the array of descriptor pointers. pointer[x] = this one
            pCombinations->pTermCapDescriptorArray[x] = pTotCaps;
			
            pTotCaps->CapDescId= pAdvertisedSets->pTermCapDescriptorArray[x]->CapDescId;
	   		pTotCaps->CapDesc.Length=pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.Length;
	   		
	   		for(y = 0; y < pTotCaps->CapDesc.Length;y++)
			{
			   //Copy the length field.
			   pTotCaps->CapDesc.SimCapArray[y].Length=
			   pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[y].Length;

				for(z=0;
					z < pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[y].Length;
					z++)
				{
					pTotCaps->CapDesc.SimCapArray[y].AltCaps[z] =
						pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[y].AltCaps[z];
				}
			}
            pTotCaps++;            	
		}
	}
	else if (pAdvertisedSets)
	{
		// descriptors in pAdvertisedSets should be rebuilt at that time. There should be no need to test
		// if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)

 		// HACK - put all audio or video caps in one AltCaps[], the T.120 cap in another AltCaps[]
	    // and put both of those in one single  capability descriptor (H245_TOTCAPDESC_T)
		// This hack will not extend past the assumption of one audio channel, one video channel, and
		// one T.120 channel.  If arbitrary media is supported, or multiple audio channels are supported,
		// this code will be wrong
		
		pCombinations->wLength=1;
	   	// point pCombinations->pTermCapDescriptorArray past the header (CC_TERMCAPDESCRIPTORS)
        pCombinations->pTermCapDescriptorArray
			= (H245_TOTCAPDESC_T **)((BYTE *)pCombinations + sizeof(CC_TERMCAPDESCRIPTORS));
        // the first H245_TOTCAPDESC_T follows the array of [H245_TOTCAPDESC_T *]
        pTotCaps = (H245_TOTCAPDESC_T *)((BYTE *)pCombinations->pTermCapDescriptorArray +
            pAdvertisedSets->wLength*sizeof(H245_TOTCAPDESC_T **));			
   		pTotCaps->CapDescId=(H245_CAPDESCID_T)x;
   		pTotCaps->CapDesc.Length=0;
		if(pTermListAud)
		{
			uNumAud = min(pTermListAud->wLength, H245_MAX_ALTCAPS);
			pTotCaps->CapDesc.SimCapArray[x].Length=(unsigned short)uNumAud;
			for(y = 0; y<uNumAud;y++)
			{
				pTotCaps->CapDesc.SimCapArray[x].AltCaps[y] = pTermListAud->pTermCapArray[y]->CapId;
			}
			x++;
			pTotCaps->CapDesc.Length++;
		}

		if(pTermListVid && pTermListVid->wLength)
		{
			uNumVid = min(pTermListVid->wLength,  H245_MAX_ALTCAPS);
			pTotCaps->CapDesc.SimCapArray[x].Length=(unsigned short)uNumVid;
			for(y = 0; y<uNumVid;y++)
			{
				pTotCaps->CapDesc.SimCapArray[x].AltCaps[y] = pTermListVid->pTermCapArray[y]->CapId;
			}
			x++;
			pTotCaps->CapDesc.Length++;
		}
		// the T.120 cap
		if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
		{
			pTotCaps->CapDesc.SimCapArray[x].Length=1;
			pTotCaps->CapDesc.SimCapArray[x].AltCaps[0] = (H245_CAPID_T)m_localT120cap;
			pTotCaps->CapDesc.Length++;
		}
		
		// write into the array of descriptor pointers. pointer[x] = this one
		*ppThisDescriptor = pTotCaps;
		
	}
	m_pVidTermCaps = pTermListVid;
	m_pAudTermCaps = pTermListAud;
	
	*ppCapBuf = pTermCapList;
	*ppCombinations = pCombinations;
	return hrSuccess;
	
ERROR_EXIT:
	m_pAudTermCaps = NULL;
	m_pVidTermCaps = NULL;
	if(pTermCapList)
		MemFree(pTermCapList);
	if(pCombinations)
		MemFree(pCombinations);

	if(pAudCaps && pTermListAud)
	{
		hr=pAudCaps->DeleteCapList(pTermListAud);
	}
	if(pVidCaps && pTermListVid)
	{
		hr=pVidCaps->DeleteCapList(pTermListVid);
	}
	return hr;
}

HRESULT CapsCtl::DeleteCapList(PCC_TERMCAPLIST pCapBuf, PCC_TERMCAPDESCRIPTORS pCombinations)
{
	MemFree(pCapBuf);
	MemFree(pCombinations);
	if(m_pAudTermCaps && pAudCaps)
	{
		pAudCaps->DeleteCapList(m_pAudTermCaps);
	}
	if(m_pVidTermCaps)
	{
		pVidCaps->DeleteCapList(m_pVidTermCaps);
	}
	
	m_pAudTermCaps = NULL;
	m_pVidTermCaps = NULL;
	return hrSuccess;
}

HRESULT CapsCtl::GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uLocalSize,DWORD idRemote, DWORD idLocal)
{
	LPIH323MediaCap pMediaCap = FindHostForID(idLocal);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;

	// HACK
	// Adjust audio packetization depending on call scenario
	// unless there is an overriding registry setting
	if (pMediaCap == pAudCaps)
	{
		VIDEO_FORMAT_ID vidLocal=INVALID_MEDIA_FORMAT, vidRemote=INVALID_MEDIA_FORMAT;
		VIDEO_CHANNEL_PARAMETERS vidParams;
		CC_TERMCAP vidCaps;
		UINT audioPacketLength;
		// modify the audio packetization parameters based on local bandwidth
		// and presence of video
		audioPacketLength = AUDIO_PACKET_DURATION_LONG;
		// the registry setting overrides, if it is present
		if (g_fRegAudioPacketDuration)
			audioPacketLength = g_AudioPacketDurationMs;
		else if (!m_fNM20)		// dont try smaller packets for NM20 because it cant handle them
		{
			if (pVidCaps && pVidCaps->ResolveEncodeFormat(&vidLocal,&vidRemote) == S_OK
				&& (pVidCaps->GetEncodeParams(&vidCaps,sizeof(vidCaps), &vidParams, sizeof(vidParams), vidRemote, vidLocal) == S_OK))
			{
				// we may potentially send video
				if (vidParams.ns_params.maxBitRate*100 > BW_ISDN_BITS)
					audioPacketLength = AUDIO_PACKET_DURATION_SHORT;
					
			}
			else
			{
				// no video
				// since we dont know the actual connection bandwidth we use
				// the local user setting.
				// Note: if the remote is on a slow-speed net and the local is on a LAN
				// we may end up with an inappropriate setting.
				if (dwConSpeed > BW_288KBS_BITS)
					audioPacketLength = AUDIO_PACKET_DURATION_SHORT;
				else if (dwConSpeed > BW_144KBS_BITS)
					audioPacketLength = AUDIO_PACKET_DURATION_MEDIUM;
			}
		}
		// Setting the AudioPacketDurationMs  affects the subsequent GetEncodeParams call
		pMediaCap->SetAudioPacketDuration(audioPacketLength);
	}
	
	return pMediaCap->GetEncodeParams (pBufOut,uBufSize, pLocalParams,
			uLocalSize,idRemote,idLocal);
	
}

HRESULT CapsCtl::GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id)
{
	LPIH323MediaCap pMediaCap = FindHostForID(id);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;
		
	return pMediaCap->GetPublicDecodeParams (pBufOut,uBufSize,id);
}

HRESULT CapsCtl::GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,DWORD * pFormatID, LPVOID lpvBuf, UINT uBufSize)
{
	LPIH323MediaCap pMediaCap = FindHostForMediaType(pChannelParams->pChannelCapability);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;
	return pMediaCap->GetDecodeParams (pChannelParams,pFormatID,lpvBuf,uBufSize);
}

HRESULT CapsCtl::ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote)
{
	LPIH323MediaCap pMediaCap = FindHostForID(FormatIDLocal);
	if(!pMediaCap)
		return CAPS_E_INVALID_PARAM;
	return pMediaCap->ResolveToLocalFormat (FormatIDLocal,pFormatIDRemote);

}
UINT CapsCtl::GetSimCapBufSize (BOOL bRxCaps)
{
   	UINT uSize;

	// get size of cached advertised sets if it exists and more than one media
	// type is enabled for publication
	if(bAudioPublicize && bVideoPublicize && pAdvertisedSets)
	{
		// use size of cached buffer
		uSize = uAdvertizedSize;
	}
	else
	{
   		// calculate size of capability descriptors and simultaneous capability structures.

		#pragma message ("Figure out the size this needs to be...")
		#define NUMBER_TERMCAP_DESCRIPTORS 1
		uSize = sizeof(H245_TOTCAPDESC_T) * NUMBER_TERMCAP_DESCRIPTORS+
						  sizeof (CC_TERMCAPDESCRIPTORS)+NUMBER_TERMCAP_DESCRIPTORS*
						  sizeof (H245_TOTCAPDESC_T *);
	}				
   	return uSize;
}

UINT CapsCtl::GetNumCaps(BOOL bRXCaps)
{
	UINT u=0;
	if(pAudCaps && bAudioPublicize)
	{
		u = pAudCaps->GetNumCaps(bRXCaps);
	}
	if(pVidCaps && bVideoPublicize)
	{
		u += pVidCaps->GetNumCaps(bRXCaps);
	}
	if(bT120Publicize)
		u++;
	return u;
}

UINT CapsCtl::GetLocalSendParamSize(MEDIA_FORMAT_ID dwID)
{
	LPIH323MediaCap pMediaCap = FindHostForID(dwID);
	if(!pMediaCap)
		return 0;
	return (pMediaCap->GetLocalSendParamSize(dwID));
}
UINT CapsCtl::GetLocalRecvParamSize(PCC_TERMCAP pCapability)
{
	LPIH323MediaCap pMediaCap = FindHostForMediaType(pCapability);
	if(!pMediaCap)
		return 0;
	return (pMediaCap->GetLocalRecvParamSize(pCapability));
}

STDMETHODIMP CapsCtl::GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	LPIH323MediaCap pMediaCap = FindHostForID(FormatID);
	if(!pMediaCap)
	{
		*ppFormat = NULL;
		*puSize = 0;
		return E_INVALIDARG;
	}
	return pMediaCap->GetEncodeFormatDetails (FormatID, ppFormat, puSize);
}

STDMETHODIMP CapsCtl::GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	LPIH323MediaCap pMediaCap = FindHostForID(FormatID);
	if(!pMediaCap)
	{
		*ppFormat = NULL;
		*puSize = 0;
		return E_INVALIDARG;
	}
	return pMediaCap->GetDecodeFormatDetails (FormatID, ppFormat, puSize);
}

//
//  EnableMediaType controls whether or not capabilities for that media type
//  are publicized.  In a general implementation (next version?) w/ arbitrary
//	number  of media types, each of the media capability objects would keep
//  track of their own state.   This version of Capsctl tracks h323 audio and
//  video only
//

HRESULT CapsCtl::EnableMediaType(BOOL bEnable, LPGUID pGuid)
{
	if(!pGuid)
		return CAPS_E_INVALID_PARAM;
		
	if(*pGuid == MEDIA_TYPE_H323AUDIO)
	{
		bAudioPublicize = bEnable;
	}
	else if (*pGuid == MEDIA_TYPE_H323VIDEO)
	{
		bVideoPublicize = bEnable;
	}
	else
	{
		return CAPS_E_INVALID_PARAM;
	}
	return hrSuccess;
}
//
// Build the PCC_TERMCAPDESCRIPTORS list that we will advertise.
//
// puAudioFormatList/puVideoFormatList MUST BE sorted by preference!
//
//



HRESULT CapsCtl::AddCombinedEntry (MEDIA_FORMAT_ID *puAudioFormatList,UINT uAudNumEntries,MEDIA_FORMAT_ID *puVideoFormatList, UINT uVidNumEntries,DWORD *pIDOut)
{
   static USHORT dwLastIDUsed;
   DWORD x,y;
   BOOL bAllEnabled=TRUE,bRecv,bSend;
   unsigned short Length =0;	
	
   *pIDOut= (ULONG )CCO_E_SYSTEM_ERROR;
   //Validate the Input
   if ((!puAudioFormatList && uAudNumEntries > 0 ) || (!puVideoFormatList && uVidNumEntries > 0 ) || (uVidNumEntries == 0 && uAudNumEntries == 0 )) {
      //What error code should we return here?
      return CCO_E_SYSTEM_ERROR;
   }

   for (x=0;x<uAudNumEntries;x++)
   {
      ASSERT(pAudCaps);
      pAudCaps->IsFormatEnabled (puAudioFormatList[x],&bRecv,&bSend);
      bAllEnabled &= bRecv;

   }
   for (x=0;x<uVidNumEntries;x++) {
      ASSERT(pVidCaps);
      pVidCaps->IsFormatEnabled (puAudioFormatList[x],&bRecv,&bSend);
      bAllEnabled &= bRecv;
   }

   if (!bAllEnabled) {
      return CCO_E_INVALID_PARAM;
   }

   if (uAudNumEntries > H245_MAX_ALTCAPS || uVidNumEntries > H245_MAX_ALTCAPS) {
	  DEBUGMSG (1,("WARNING: Exceeding callcontrol limits!! \r\n"));
      return CCO_E_INVALID_PARAM;
   }

   //If this is the first call, allocate space
	if (!pAdvertisedSets){
	    pAdvertisedSets=(PCC_TERMCAPDESCRIPTORS)MemAlloc (sizeof (CC_TERMCAPDESCRIPTORS));
        if (!pAdvertisedSets){
	 		//Error code?
	 		return  CCO_E_SYSTEM_ERROR;
        }
        uAdvertizedSize = sizeof (CC_TERMCAPDESCRIPTORS);

        //Allocate space of NUM_SIMCAP_SETS
        pAdvertisedSets->pTermCapDescriptorArray=(H245_TOTCAPDESC_T **)
                MemAlloc (sizeof (H245_TOTCAPDESC_T *)*NUM_SIMCAP_SETS);
        if (!pAdvertisedSets->pTermCapDescriptorArray) {
	        //Error code?
	        return CCO_E_SYSTEM_ERROR;
        }

        //Update the indicies
        uAdvertizedSize += sizeof (H245_TOTCAPDESC_T *)*NUM_SIMCAP_SETS;
        dwNumInUse=NUM_SIMCAP_SETS;
        pAdvertisedSets->wLength=0;
    }

    //Find an Index to use.
    for (x=0;x<pAdvertisedSets->wLength;x++){
        if (pAdvertisedSets->pTermCapDescriptorArray[x] == NULL){
	        break;
        }
    }

    //Did we find space, or do we need a new one?
    if (x >= dwNumInUse) {
      	//Increment the number in use
       	dwNumInUse++;

        PVOID  pTempTermCapDescriptorArray = NULL;
        pTempTermCapDescriptorArray = MemReAlloc(pAdvertisedSets->pTermCapDescriptorArray, sizeof(H245_TOTCAPDESC_T *)*(dwNumInUse));

		if(pTempTermCapDescriptorArray)
		{
            pAdvertisedSets->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)pTempTermCapDescriptorArray;
		}
		else
		{
       		 return CCO_E_SYSTEM_ERROR;
		}

       	uAdvertizedSize += (sizeof (H245_TOTCAPDESC_T *)*(dwNumInUse))+sizeof (CC_TERMCAPDESCRIPTORS);
       	//Index is 0 based, point at the new entry
       	x=dwNumInUse-1;
    }


    //x is now the element we are using. Allocate space for a TermCapDescriptorArray
    pAdvertisedSets->pTermCapDescriptorArray[x]=(H245_TOTCAPDESC_T *)MemAlloc (sizeof (H245_TOTCAPDESC_T));
    if (!pAdvertisedSets->pTermCapDescriptorArray[x]){
        return CCO_E_SYSTEM_ERROR;
    }
    uAdvertizedSize += sizeof (H245_TOTCAPDESC_T);
    //Need to update the SetID. (start at 1)...
    pAdvertisedSets->pTermCapDescriptorArray[x]->CapDescId=++dwLastIDUsed;
    //Set the # of sets

    if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
    	Length++;
   	if(uVidNumEntries)
   		Length++;
   	if(uAudNumEntries)
   		Length++;
    pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.Length= Length;

   //Copy the Audio into SimCapArray[0], Video into SimCapArray[1] (if both)

    if ((uVidNumEntries > 0 && uAudNumEntries > 0)) {
        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].Length=(unsigned short)uAudNumEntries;
        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].Length=(unsigned short)uVidNumEntries;
        if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[2].Length=1;
        //Copy the format IDs
        for (y=0;y<uAudNumEntries;y++) {
            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].AltCaps[y]=(USHORT)puAudioFormatList[y];
        }
        for (y=0;y<uVidNumEntries;y++) {
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].AltCaps[y]=(USHORT)puVideoFormatList[y];
        }
        if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[2].AltCaps[0]= (H245_CAPID_T)m_localT120cap;


   } else {
        if (uAudNumEntries > 0)  {
            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].Length=(unsigned short)uAudNumEntries;
            if((m_localT120cap != INVALID_MEDIA_FORMAT) && bT120Publicize)
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].Length=1;
	        //Copy Audio only
	        for (y=0;y<uAudNumEntries;y++) {
	            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].AltCaps[y]=(USHORT)puAudioFormatList[y];
	        }
	        if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)	
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].AltCaps[0]= (H245_CAPID_T)m_localT120cap;

        } else {
	        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].Length=(unsigned short)uVidNumEntries;
            if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].Length=1;

	        //copy video entries
	        for (y=0;y<uVidNumEntries;y++) {
	            pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[0].AltCaps[y]=(USHORT)puVideoFormatList[y];
	        }
	        if((m_localT120cap != INVALID_MEDIA_FORMAT)  && bT120Publicize)
		        pAdvertisedSets->pTermCapDescriptorArray[x]->CapDesc.SimCapArray[1].AltCaps[0]= (H245_CAPID_T)m_localT120cap;
        }
   }

   //Need to update the wLength
   pAdvertisedSets->wLength++;
   *pIDOut=dwLastIDUsed;

   return hrSuccess;
}


HRESULT CapsCtl::RemoveCombinedEntry (DWORD ID)
{

   DWORD x;

   if (!pAdvertisedSets) {
      return CAPS_E_INVALID_PARAM;
   }

   for (x=0;x<dwNumInUse;x++) {
      if (pAdvertisedSets->pTermCapDescriptorArray[x]) {

		if (pAdvertisedSets->pTermCapDescriptorArray[x]->CapDescId == ID) {
		   //Found the one to remove
		   MemFree ((VOID *)pAdvertisedSets->pTermCapDescriptorArray[x]);
		   uAdvertizedSize -= sizeof (H245_TOTCAPDESC_T *);
		   if (x != (dwNumInUse -1)) {
			  //Not the last one, swap the two pointers
			  pAdvertisedSets->pTermCapDescriptorArray[x]=pAdvertisedSets->pTermCapDescriptorArray[dwNumInUse-1];
			  pAdvertisedSets->pTermCapDescriptorArray[dwNumInUse-1]=NULL;
		   }

		   //Decrement the number in use, and set the wLengthField
		   dwNumInUse--;
		   pAdvertisedSets->wLength--;
		   return hrSuccess;
		}
	  }
   }


   //Shouldn't get here, unless it was not found.
   return CAPS_E_NOCAPS;
}


// Given a sized list of capability IDs (pointer to array of H245_CAPID_T)
// and a sized list of alternate capabilities (AltCaps) within a single simultaneous
// capability set, (pointer to an array of pointers to H245_SIMCAP_T)
// Determine if the entire list of capability IDs can simultaneously coexist
// with respect to the given set of AltCaps.

BOOL CapsCtl::AreSimCaps(
	H245_CAPID_T* pIDArray, UINT uIDArraySize,
	H245_SIMCAP_T **ppAltCapArray,UINT uAltCapArraySize)
{
	UINT i, u;
	SHORT j;
	BOOL bSim;
	
	H245_SIMCAP_T *pAltCapEntry, *pFirstAltCapEntry;

	// If there are fewer AltCaps than capabilities, doom is obvious.  Don't bother searching.
	if(uAltCapArraySize < uIDArraySize)
		return FALSE;
	
	// find an altcaps entry containing the first ID in the list
	for (i=0;i<uAltCapArraySize;i++)
	{
		pAltCapEntry = *(ppAltCapArray+i);
		// scan this altcaps entry for a matching ID
		for(j=0;j<pAltCapEntry->Length;j++)
		{
			if(*pIDArray == pAltCapEntry->AltCaps[j])
			{
				// found a spot for this capability!
				if(uIDArraySize ==1)
					return TRUE; // Done! all the capabilities have been found to coexist
		
				// Otherwise, look for the next capability in the *remaining* AltCaps
				// *This* AltCaps contains the capability we were looking for
				// So, we "used up" this AltCaps and can't select from it anymore

				// Pack the array of H245_SIMCAP_T pointers in place so that
				// "used" entries are at the beginning and "unused" at the end
				// (a la shell sort swap pointers)
				if(i != 0)	// if not already the same, swap
				{
					pFirstAltCapEntry = *ppAltCapArray;
					*ppAltCapArray = pAltCapEntry;
					*(ppAltCapArray+i) = pFirstAltCapEntry;
				}
				// continue the quest using the remaining capabilities
				// and the remaining AltCaps
				bSim = AreSimCaps(pIDArray + 1, uIDArraySize - 1,
					ppAltCapArray + 1,  uAltCapArraySize - 1);
				
				if(bSim)		
				{
					return bSim;// success
				}
				else	// why not?  Either a fit does not exist (common), or the altcaps contain
						// an odd pattern of multiple instances of some capability IDs, and another
						// search order *might* fit.  Do not blindly try all permutations of search
						// order.
				{
					// If it failed simply because the recently grabbed slot in the altcaps
					// (the one in *(ppAltCapArray+i)) could have been needed by subsequent
					// capability IDs, give this one up and look for another instance.
					// If not, we know for sure that the n! approach will not yield
					// fruit and can be avoided.
					for(u=1;(bSim == FALSE)&&(u<uAltCapArraySize);u++)
					{
						for(j=0;(bSim == FALSE)&&(j<pAltCapEntry->Length);j++)
						{	// another capability needed the altcaps we grabbed ?
							if(*(pIDArray+u) == pAltCapEntry->AltCaps[j])	
							{	
								bSim=TRUE;
								break;	// look no more here, bail to try again	because a fit *might* exist
							}
						}
					}
					if(bSim)	// going to continue searching - Swap pointers back if they were swapped above
					{
						if(i != 0)	// if not the same, swap back
						{
							*ppAltCapArray = *(ppAltCapArray+i);
							*(ppAltCapArray+i) = pAltCapEntry;
						}		
						break;	// next i
					}
					else	// don't waste CPU - a fit does not exist
					{
						return bSim;
					}
				}
			}
		}
	}
	return FALSE;
}

// Given a sized list of capability IDs (pointer to array of H245_CAPID_T)
// and a list of simultaneous capabilities, try each simultaneous capability
// and determine if the entire list of capability IDs can simultaneously coexist.
BOOL CapsCtl::TestSimultaneousCaps(H245_CAPID_T* pIDArray, UINT uIDArraySize,
	PCC_TERMCAPDESCRIPTORS pTermCaps)
{
	int iSimSet, iAltSet;
	BOOL bResolved = FALSE;
	H245_SIMCAP_T * pAltCapArray[H245_MAX_SIMCAPS];
	
    if (!pAdvertisedSets)
        return(TRUE);

	// try each independent local SimCaps set (each descriptor) until success
	for (iSimSet=0; (bResolved == FALSE) && (iSimSet < pTermCaps->wLength);iSimSet++)
	{
		// EXTRA STEP:
		// Build a sortable representation of the AltCaps set.  This step will not be necessary if
		// and when we change the native representation of a capability descriptor to a variable
		// length list of pointers to AltCaps.  In the meantime, we know that there are no more
		// than H245_MAX_SIMCAPS AltCaps in this SimCaps.  This is imposed by the 2 dimensional
		// arrays of hardcoded size forced upon us by CALLCONT.DLL.
		for (iAltSet=0;iAltSet < pTermCaps->pTermCapDescriptorArray[iSimSet]->CapDesc.Length;iAltSet++)
		{
			pAltCapArray[iAltSet] = &pTermCaps->pTermCapDescriptorArray[iSimSet]->CapDesc.SimCapArray[iAltSet];
	   	}
		// do the work		
		bResolved = AreSimCaps(pIDArray, uIDArraySize,
			(H245_SIMCAP_T **)&pAltCapArray,
			MAKELONG(pTermCaps->pTermCapDescriptorArray[iSimSet]->CapDesc.Length, 0));
	}

	return bResolved;
}

// Function: CapsCtl::ResolvePermutations(PRES_CONTEXT pResContext, UINT uNumFixedColumns)
//
// This functions as both a combination generator and a validation mechanism for the
// combinations it generates.
//
// Given a pointer to a resolution context and the number of fixed (i.e. not permutable,
// if "permutable" is even a real word) columns, generate one combination at a time.
// Try each combination until a working combination is found or until all combinations
// have been tried.
//
// The resolution context structure contains a variable number of columns of variable
// length media format ID lists. Each column tracks its current index.  When this
// function returns TRUE, the winning combination is indicated by the current column
// indices.
//
// The caller can control which combinations are tried first by arranging the columns
// in descending importance.
//
// Incremental searches can be performed without redundant comparisons by adding 1 format
// at a time to a column, arranging the column order so that the appended column is
// first, and "fixing" that one column at the newly added format. For example,
// some calling function could force evaluations on a round-robin column basis by
// calling this function inside a loop which does the following:
//		1 - adds one format at a time to the rightmost column and sets the current index
//			of that column to the new entry
// 		2 - rotates the column order so that the rightmost column is now the leftmost
//  	3 - fixing the new leftmost column before calling this function again
//	The result will be that only the permutations which contain the newly added format
// 	will be generated.


BOOL CapsCtl::ResolvePermutations(PRES_CONTEXT pResContext, UINT uNumFixedColumns)
{
	RES_PAIR *pResolvedPair;
	BOOL bResolved = FALSE;
	UINT i, uColumns;
	UINT uPairIndex;

	// converge on one combination in the permutation
	if(uNumFixedColumns != pResContext->uColumns)
	{
		RES_PAIR_LIST *pThisColumn;
		// take the first non-fixed column, make that column fixed and
		// iterate on it (loop through indices), and try each sub-permutation
		// of remaining columns.  (until success or all permutations tried)
		
		pThisColumn = *(pResContext->ppPairLists+uNumFixedColumns);
		for (i=0; (bResolved == FALSE) && (i<pThisColumn->uSize); i++)
		{
			pThisColumn->uCurrentIndex = i;
			bResolved = ResolvePermutations(pResContext, uNumFixedColumns+1);
		}
		return bResolved;
	}
	else
	{
		// Bottomed out on the final column.  Test the viability of this combination
		
		// Build array of local IDs that contians the combination and test the
		// combination against local simultaneous capabilities, then against
		// remote simultaneous capabilities
		
		// NOTE: be sure to skip empty columns (which represent unresolvable
		// or unsupported/nonexistent media types or unsupported additional
		// instances of media types)
		
		for(i=0, uColumns=0;i<pResContext->uColumns;i++)
		{
			if(((*pResContext->ppPairLists)+i)->uSize)
			{
				// get index (row #) for this column
				uPairIndex = ((*pResContext->ppPairLists)+i)->uCurrentIndex;
				// get the row
				pResolvedPair =  ((*pResContext->ppPairLists)+i)->pResolvedPairs+uPairIndex;
				// add the ID to the array
				*(pResContext->pIDScratch+uColumns) = (H245_CAPID_T)pResolvedPair->idPublicLocal;
				uColumns++;
			}
			// else empty column
		}
		// Determine if this combination can exist simultaneously
		if(TestSimultaneousCaps(pResContext->pIDScratch,
			uColumns, pResContext->pTermCapsLocal))
		{	
			// now test remote
			// build array of remote IDs and test those against remote
			// simultaneous capabilities
			for(i=0, uColumns=0;i<pResContext->uColumns;i++)
			{
				if(((*pResContext->ppPairLists)+i)->uSize)
				{
					// get index (row #) for this column
					uPairIndex = ((*pResContext->ppPairLists)+i)->uCurrentIndex;
					// get the row
					pResolvedPair =  ((*pResContext->ppPairLists)+i)->pResolvedPairs+uPairIndex;
					// add the ID to the array
					*(pResContext->pIDScratch+uColumns) =(H245_CAPID_T) pResolvedPair->idRemote;
					uColumns++;
				}
				// else empty column
			}
			bResolved = TestSimultaneousCaps(pResContext->pIDScratch,
				uColumns, pResContext->pTermCapsRemote);
		}
					
		return bResolved;		
		// if(bResolved == TRUE)
			// The resolved combination of pairs is indicated by the current indices
			// of **ppPairList;
	}
}

//
// Given a counted list of desired instances of media, produce an output array of
// resolved media format IDs which correspond to the input media type IDs.
// This function returns success if at least one media instance is resolved.
// When an instance of media is unresolveable, the output corresponding to that
// instance contains the value INVALID_MEDIA_FORMAT for local and remote media
// format IDs.
//
// The input is treated as being in preferential order: permutations of the latter
// media type instance are varied first. If all permutations do not yield success,
// then one media type instance at a time is removed from the end.
//

HRESULT CapsCtl::ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia,
	PRES_PAIR pResOutput)
{
	HRESULT hr = hrSuccess;
	PRES_PAIR_LIST pResColumnArray = NULL;
	PRES_PAIR_LIST *ppPairLists;
	RES_PAIR *pResPair;
	PRES_CONTEXT pResContext;
	LPIH323MediaCap pMediaResolver;
	UINT i;
	UINT uMaxFormats = 0;
	UINT uFixedColumns =0;
	UINT uFailedMediaCount = 0;
	BOOL bResolved = FALSE;
	
	RES_PAIR UnresolvedPair = {INVALID_MEDIA_FORMAT, INVALID_MEDIA_FORMAT, INVALID_MEDIA_FORMAT};
	// create a context structure for the resolution
	pResContext = (PRES_CONTEXT)MemAlloc(sizeof(RES_CONTEXT)+ (uNumMedia*sizeof(H245_CAPID_T)));
	if(!pResContext)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;
	}
	// initialize resolution context
	pResContext->uColumns = 0;
	pResContext->pIDScratch = (H245_CAPID_T*)(pResContext+1);
	pResContext->pTermCapsLocal = pAdvertisedSets;
	pResContext->pTermCapsRemote = pRemAdvSets;

	// allocate array of RES_PAIR_LIST (one per column/media type) and
	// array of pointers to same
	pResColumnArray = (PRES_PAIR_LIST)MemAlloc((sizeof(RES_PAIR_LIST) * uNumMedia)
		+ (sizeof(PRES_PAIR_LIST) * uNumMedia));
	if(!pResColumnArray)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;
	}
	pResContext->ppPairLists = ppPairLists = (PRES_PAIR_LIST*)(pResColumnArray+uNumMedia);
			
	// build columns of media capabilities
	for(i=0;i<uNumMedia;i++)
	{
		// build array of pointers to RES_PAIR_LIST
		*(ppPairLists+i) = pResColumnArray+i;
		// initialize RES_PAIR_LIST members
		(pResColumnArray+i)->pResolvedPairs = NULL;
		(pResColumnArray+i)->uSize =0;
		(pResColumnArray+i)->uCurrentIndex = 0;

		// Get resolver for this media. Special case: there is no T120 resolver.
		// T120 caps are handled right here in this object
		if(MEDIA_TYPE_H323_T120 == *(pMediaGuidArray+i))
		{
			pMediaResolver = NULL;
			if((m_localT120cap != INVALID_MEDIA_FORMAT) &&(m_remoteT120cap != INVALID_MEDIA_FORMAT) )
			{
				(pResColumnArray+i)->uSize =1;
				uMaxFormats = 1;	// only one T.120 cap
				
				pResPair = (pResColumnArray+i)->pResolvedPairs =
					(RES_PAIR *)MemAlloc(uMaxFormats * sizeof(RES_PAIR));
				if(!pResPair)
				{
					hr = CAPS_E_NOMEM;
					goto ERROR_OUT;
				}
				
				//
				pResPair->idLocal = m_localT120cap;
				pResPair->idRemote = m_remoteT120cap;
				pResPair->idPublicLocal = pResPair->idLocal;
			}
		}
		else
		{
			pMediaResolver = FindHostForMediaGuid(pMediaGuidArray+i);
		}
			
		pResContext->uColumns++;
		(pResColumnArray+i)->pMediaResolver = pMediaResolver;
		
		if(pMediaResolver)
		{
			uMaxFormats = pMediaResolver->GetNumCaps(FALSE);	// get transmit format count
			if(uMaxFormats)
			{
				pResPair = (pResColumnArray+i)->pResolvedPairs =
					(RES_PAIR *)MemAlloc(uMaxFormats * sizeof(RES_PAIR));
				if(!pResPair)
				{
					hr = CAPS_E_NOMEM;
					goto ERROR_OUT;
				}
				
				// resolve the best choice for each media type (gotta start somewhere)
				pResPair->idLocal = INVALID_MEDIA_FORMAT;
				pResPair->idRemote = INVALID_MEDIA_FORMAT;		
				hr=pMediaResolver->ResolveEncodeFormat (&pResPair->idLocal,&pResPair->idRemote);
				if(!HR_SUCCEEDED(hr))
				{
					if((hr == CAPS_W_NO_MORE_FORMATS)	
						|| (hr == CAPS_E_NOMATCH)
						|| (hr == CAPS_E_NOCAPS))
					{	
						// No resolved format for this media type.  Remove this "column"
						(pResColumnArray+i)->pResolvedPairs = NULL;
						MemFree(pResPair);
						(pResColumnArray+i)->uSize =0;

						hr = hrSuccess;
					}
					else
					{
						goto ERROR_OUT;
					}
				}
				else
				{
					// this column has one resolved format
					pResPair->idPublicLocal = pMediaResolver->GetPublicID(pResPair->idLocal);
					(pResColumnArray+i)->uSize =1;
				}
			}
			// else // No formats exist for this media type.  this "column" has zero size
		}
	}

	// Special case test simultaneous caps for the most preferred combination:
	uFixedColumns = pResContext->uColumns;	// << make all columns fixed
	bResolved = ResolvePermutations(pResContext, uFixedColumns);

	// if the single most preferred combination can't be used, need to handle
	// the general case and try permutations until a workable combination is found
	while(!bResolved)
	{
		// make one column at a time permutable, starting with the least-critical media
		// type.  (e.g. it would be typical for the last column to be video because
		// audio+data are more important. Then we try less and less
		// preferable video formats before doing anything that would degrade the audio)

		if(uFixedColumns > 0)	// if not already at the end of the rope...
		{
			uFixedColumns--;	// make another column permutable
		}
		else
		{
			// wow - tried all permutations and still no luck ......
			// nuke the least important remaining media type (e.g. try it w/o video)
			if(pResContext->uColumns <= 1)	// already down to one media type?
			{
				hr = CAPS_E_NOMATCH;
				goto ERROR_OUT;
			}
			// Remove the end column (representing the least important media type)
			// and try it with the remaining columns			
			uFixedColumns = --pResContext->uColumns; 	// one less column

			// set the formats of the nuked column to the unresolved state
			(pResColumnArray+uFixedColumns)->uSize =0;
			(pResColumnArray+uFixedColumns)->uCurrentIndex =0;
			pResPair = (pResColumnArray+uFixedColumns)->pResolvedPairs;
			if (NULL != pResPair)
			{
				pResPair->idLocal = INVALID_MEDIA_FORMAT;
				pResPair->idRemote = INVALID_MEDIA_FORMAT;
				pResPair->idPublicLocal = INVALID_MEDIA_FORMAT;
			}

			uFailedMediaCount++;	// track the nuking of a column to avoid
									// redundantly grabbing all the formats again
									// ... would not be here if all permutations
									// had not been tried!
			// reset the combination indices
			for(i=0;i<uFixedColumns;i++)
			{
				(pResColumnArray+i)->uCurrentIndex = 0;
			}
		}
		
		// get the rest of the formats for the last known fixed column, make that column
		// permutable, etc.
		pMediaResolver = (pResColumnArray+uFixedColumns)->pMediaResolver;
		if(!pMediaResolver || ((pResColumnArray+uFixedColumns)->uSize ==0))
		{
			continue;	// this media type has no further possibility
		}

 		if(uFailedMediaCount ==0)	// If all of the possible resolved pairs
 									// have not yet been obtained, get them!
 		{
 			// get resolved pair IDs for every mutual format of this media type
			// first: get pointer to array of pair IDs, then use ResolveEncodeFormat()
			// to fill up the array
			pResPair =  (pResColumnArray+uFixedColumns)->pResolvedPairs;
			// Get total # of formats less the one that was already obtained
			uMaxFormats = pMediaResolver->GetNumCaps(FALSE) -1;	
			
			while(uMaxFormats--)	// never exceed the # of remaining local formats...
			{
				RES_PAIR *pResPairNext;
						
				// recall that ResolveEncodeFormat parameters are I/O - the input
				// is the local ID of the last resolved mutual format.  (remote id
				// is ignored as input).  Fixup the input.
				pResPairNext = pResPair+1;
				// start where the previous resolve stopped
				pResPairNext->idLocal = pResPair->idLocal;	
				// not necessary, ignored ->>> pResPairNext->idRemote = pResPair->idRemote
				pResPair = pResPairNext;
				hr=pMediaResolver->ResolveEncodeFormat (&pResPair->idLocal,&pResPair->idRemote);
				if((hr == CAPS_W_NO_MORE_FORMATS)	
					|| (hr == CAPS_E_NOMATCH))
				// got all of the formats, but not an error
				{	// this is likely when less than 100% of local formats have a remote match
					hr = hrSuccess;
					break;
				}	
				if(!HR_SUCCEEDED(hr))
					goto ERROR_OUT;

				// get the public ID of the local format (it's *usually* the same, but not always)
				pResPair->idPublicLocal = pMediaResolver->GetPublicID(pResPair->idLocal);
				// this column has another format - count it!
				(pResColumnArray+uFixedColumns)->uSize++;
			}
		}
		// now try the new permutations
		bResolved = ResolvePermutations(pResContext, uFixedColumns);
	}
	if(bResolved)
	{
		// spew the output
		for(i=0;i<uNumMedia;i++)
		{
			if((pResColumnArray+i)->uSize)
			{
				pResPair = (pResColumnArray+i)->pResolvedPairs
					+ (pResColumnArray+i)->uCurrentIndex;
			}
			else
			{
				pResPair = &UnresolvedPair;

			}
			*(pResOutput+i) = *pResPair;
		}
	}
	else
	{
		// if there was some error, preserve that error code,
		if(HR_SUCCEEDED(hr))	
		// otherwise the error is....
			hr = CAPS_E_NOMATCH;		
	}

ERROR_OUT:	// well, the success case falls out here too
	if(pResColumnArray)
	{
		for(i=0;i<uNumMedia;i++)
		{	
			if((pResColumnArray+i)->pResolvedPairs)
				MemFree((pResColumnArray+i)->pResolvedPairs);
		}
		MemFree(pResColumnArray);
	}
	if(pResContext)
	{
		MemFree(pResContext);
	}
	return hr;
}

HRESULT CapsCtl::ResetCombinedEntries (void)
{
    DWORD x;

    if (pAdvertisedSets)
    {
        for (x = 0; x < pAdvertisedSets->wLength; x++)
        {
            if (pAdvertisedSets->pTermCapDescriptorArray[x])
            {
	    	    MemFree (pAdvertisedSets->pTermCapDescriptorArray[x]);
            }
        }
        MemFree (pAdvertisedSets->pTermCapDescriptorArray);

        pAdvertisedSets->wLength=0;
        MemFree (pAdvertisedSets);
        pAdvertisedSets = NULL;
    }

    if (pSetIDs)
    {
        MemFree(pSetIDs);
        pSetIDs = NULL;
    }

    dwNumInUse=0;
    uAdvertizedSize=0;

    return hrSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\capif.h ===
#ifndef _CAPIF_H
#define _CAPIF_H



#define AUDIO_PACKET_DURATION_SHORT 	32
#define AUDIO_PACKET_DURATION_MEDIUM 	64
#define AUDIO_PACKET_DURATION_LONG		90
extern UINT g_AudioPacketDurationMs;
extern BOOL g_fRegAudioPacketDuration;


#ifdef DEBUG
extern VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
extern VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
#else
#define DumpNonstdParameters(a, b)
#define DumpChannelParameters(a, b)
#endif

#define NUM_SIMCAP_SETS 6 //Nuber of default pTermcapDescriptorArray Elements to allocate  (AddCombinedEntry (...) )



#ifdef __cplusplus

// RES_PAIR_LIST represents viable local and remote capability IDs for one
// media channel. e.g. a list of resolved audio formats or a list of resolved
// video formats. Each RES_PAIR_LIST is one column in a permutation table. 
typedef struct res_pair_list
{
	LPIH323MediaCap pMediaResolver; // interface pointer of the resolver that handles
	                                // this media type
	UINT uSize;                     // number of RES_PAIR in pResolvedPairs
	UINT uCurrentIndex;             // index into pResolvedPairs[]
	RES_PAIR *pResolvedPairs;       // pointer to array of RES_PAIR
}RES_PAIR_LIST, *PRES_PAIR_LIST;

// RES_CONTEXT represents a permutation table (A list of RES_PAIR_LISTs) 
// This used internally by a combination generator
typedef struct res_context {
	UINT uColumns;	// number of RES_PAIR_LIST in ppPairLists 
	RES_PAIR_LIST **ppPairLists;	// ptr to array of RES_PAIR_LIST pointers
	H245_CAPID_T *pIDScratch;	    // scratch area big enough to contain uColumns * sizeof(H245_CAPID_T)
	PCC_TERMCAPDESCRIPTORS pTermCapsLocal;
	PCC_TERMCAPDESCRIPTORS pTermCapsRemote;
	
}RES_CONTEXT, *PRES_CONTEXT;

// IH323PubCap  is used by H323 call control
class IH323PubCap
{
	public:
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;
    STDMETHOD_(BOOL, Init())=0;

	STDMETHOD(AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList, PCC_TERMCAPDESCRIPTORS
		pTermCapDescriptors, PCC_VENDORINFO pVendorInfo))=0;
	// H.245 parameter grabbing functions
	// Get public version of channel parameters for a specific decode capability
	STDMETHOD(GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, MEDIA_FORMAT_ID id))=0;
	// Get local and remote channel parameters for a specific encode capability
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams,
			UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal))=0;
 	// get local version of channel parameters for a specific decode capability

	STDMETHOD(GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		MEDIA_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize))=0;
	STDMETHOD( EnableMediaType(BOOL bEnable, LPGUID pGuid))=0;

	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID))=0;
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability))=0;

	// The following is an interim solution, definitely must revisit this for the next release.
 	// The data pump requires access to local parameters that results from capability
 	// negotiation. In the absence of a separate interface that the data pump can use,
 	// the following are stuck onto this interface.
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;

	STDMETHOD ( ComputeCapabilitySets (DWORD dwBandwidth))=0;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting))PURE;
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting))PURE;
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote))PURE;
    STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput))PURE;
	STDMETHOD (ReInitialize())PURE;	    
};
typedef IH323PubCap *LPIH323PubCap;


class CapsCtl : public IH323PubCap, public IDualPubCap {
protected:
    PCC_TERMCAPLIST m_pAudTermCaps;
    PCC_TERMCAPLIST m_pVidTermCaps;
	// internal utility functions
	
	UINT GetCapDescBufSize (BOOL bRxCaps);
   	HRESULT GetCombinedBufSize(BOOL bRXCaps, UINT *puBufsize, UINT *puCapsCount);
	UINT GetSimCapBufSize (BOOL bRxCaps);
   	BOOL TestSimultaneousCaps(H245_CAPID_T* pIDArray, UINT uIDArraySize, 
	    PCC_TERMCAPDESCRIPTORS pTermCaps);
	BOOL ResolvePermutations(PRES_CONTEXT pResContext, UINT uNumFixedColumns);
   	BOOL AreSimCaps(H245_CAPID_T* pIDArray, UINT uIDArraySize, 
	        H245_SIMCAP_T **ppAltCapArray,UINT uAltCapArraySize);

public:
   	CapsCtl();
	~CapsCtl();

  	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD_(BOOL, Init());
	STDMETHOD( AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList,PCC_TERMCAPDESCRIPTORS pTermCapDescriptors,PCC_VENDORINFO pVendorInfo));
	STDMETHOD( CreateCapList(PCC_TERMCAPLIST *ppCapBuf, PCC_TERMCAPDESCRIPTORS *ppCombinations));
	STDMETHOD( DeleteCapList(PCC_TERMCAPLIST pCapBuf, PCC_TERMCAPDESCRIPTORS pCombinations));

	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams, UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal));
	STDMETHOD( GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id));
	STDMETHOD(GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,DWORD * pFormatID, LPVOID lpvBuf, UINT uBufSize));
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps));
	STDMETHOD( EnableMediaType(BOOL bEnable, LPGUID pGuid));

	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID));
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability));
	//
	// methods provided to the Data pump, common to H.323 and MSICCP
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	//
	//
	LPIH323MediaCap FindHostForID(MEDIA_FORMAT_ID id);
	LPIH323MediaCap FindHostForMediaType(PCC_TERMCAP pCapability);
    LPIH323MediaCap FindHostForMediaGuid(LPGUID pMediaGuid);

	STDMETHOD ( AddCombinedEntry (MEDIA_FORMAT_ID *puAudioFormatList,UINT uAudNumEntries,MEDIA_FORMAT_ID *puVideoFormatList, UINT uVidNumEntries,PDWORD pIDOut));
	STDMETHOD ( RemoveCombinedEntry (DWORD ID));
	STDMETHOD ( ResetCombinedEntries());
	STDMETHOD ( ComputeCapabilitySets (DWORD dwBandwidth));
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHODIMP ReInitialize();
	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting)
		{
            if (pAudCaps)
    			pAudCaps->EnableTXCaps(bSetting);
            if (pVidCaps)
    			pVidCaps->EnableTXCaps(bSetting);
		};);
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting)
		{
            if (pAudCaps)
    			pAudCaps->EnableRemoteTSTradeoff(bSetting);
            if (pVidCaps)
    			pVidCaps->EnableRemoteTSTradeoff(bSetting);
		};);

	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote));
			        
	STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput));
	
protected:
	UINT uRef;
	static UINT uAdvertizedSize;
	BOOL bAudioPublicize, bVideoPublicize, bT120Publicize;
	MEDIA_FORMAT_ID m_localT120cap;
	MEDIA_FORMAT_ID m_remoteT120cap;
	DWORD m_remoteT120bitrate;
	LPIH323MediaCap pAudCaps;
	LPIH323MediaCap pVidCaps;

	PCC_TERMCAPLIST pACapsBuf,pVCapsBuf;
	static PCC_TERMCAPDESCRIPTORS pAdvertisedSets;
	static UINT uStaticGlobalRefCount;
	PCC_TERMCAPDESCRIPTORS pRemAdvSets;
	DWORD dwNumInUse;				// # of active TERMCAPDESCRIPTORS in use
	DWORD *pSetIDs;					//Id's of the active PCC_TERMCAPDESCRIPTORS
	BOOL m_fNM20;					// set to TRUE if we're talking to NM 2.0
	static DWORD dwConSpeed;

};


LPIH323PubCap CreateCapabilityObject();


#endif	// __cplusplus
#endif	//#ifndef _CAPIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\cmember.h ===
/*
 *  	File: cmember.h
 *
 *     
 *
 *		Revision History:
 *
 *		05/29/98	mikev	created
 */


#ifndef _CMEMBER_H
#define _CMEMBER_H


/*
 *	Class definitions
 */


class CH323Member
{

private:

//	IControlChannel 	*m_pControlChannel;     //  reference to control channel 
	                                            // (needed only if this is the MC)
	
    LPWSTR m_pTerminalID;
    CC_TERMINAL_LABEL   m_TerminalLabel;
    BOOL                m_fTermLabelExists; // true if m_TerminalLabel contents
                                            // have been assigned
public:
	
	CH323Member();
	~CH323Member();

    STDMETHOD(SetMemberInfo(PCC_OCTETSTRING pTerminalID, 
        PCC_TERMINAL_LABEL pTerminalLabel));
    
	STDMETHOD_(LPWSTR, GetTerminalID());
	STDMETHOD_(PCC_TERMINAL_LABEL, GetTerminalLabel());
};


#endif // _CMEMBER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\guids.c ===
#define  INITGUIDS
#include <objbase.h>
#include <initguid.h>
#include <winsock2.h>
#include <mmsystem.h>
#include "common.h"
#include "nacguids.h"
#include <nmqos.h>
#include "codecs.h"
#include <irtp_i.c>

// {D2E97231-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_MSIA = 
//{ 0xd2e97231, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {D2E97230-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_H323 = 
//{ 0xd2e97230, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {A4209190-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_H323 = 
//{ 0xa4209190, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209191-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MSICCP = 
//{ 0xa4209191, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209192-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MNM10_DUAL = 
//{ 0xa4209192, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\debug.h ===
#ifdef DEBUG // { DEBUG
int WINAPI CCDbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneCC;

#define ZONE_INIT (GETMASK(ghDbgZoneCC) & 0x0001)
#define ZONE_CONN (GETMASK(ghDbgZoneCC) & 0x0002)
#define ZONE_COMMCHAN (GETMASK(ghDbgZoneCC) & 0x0004)

#define ZONE_CAPS (GETMASK(ghDbgZoneCC) & 0x0008)
#define ZONE_MEMBER   (GETMASK(ghDbgZoneCC) & 0x0010)
#define ZONE_U2  (GETMASK(ghDbgZoneCC) & 0x0020)
#define ZONE_U3  (GETMASK(ghDbgZoneCC) & 0x0040)
#define ZONE_REFCOUNT (GETMASK(ghDbgZoneCC) & 0x0080)
#define ZONE_U4 (GETMASK(ghDbgZoneCC) & 0x0100)
#define ZONE_PROFILE (GETMASK(ghDbgZoneCC) & 0x0200)

extern HDBGZONE  ghDbgZoneNMCap;
#define ZONE_NMCAP_CDTOR (GETMASK(ghDbgZoneNMCap) & 0x0001)
#define ZONE_NMCAP_REFCOUNT (GETMASK(ghDbgZoneNMCap) & 0x0002)
#define ZONE_NMCAP_STREAMING (GETMASK(ghDbgZoneNMCap) & 0x0004)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (CCDbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (CCDbgPrintf m)
#else // }{ DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\ctrlh323.h ===
/*
 *  	File: ctrlh323.h
 *
 *      H.323/H.245 implementation of IControlChannel.
 *
 *		Revision History:
 *
 *		05/03/96	mikev	created
 */


#ifndef _CTRLH323_H
#define _CTRLH323_H

//
//  Build with BETA_2_ASN_PRESENT defined to detect a peer that is using 
//  downlevel ASN.1.  It has been discovered that some PDUs encoded with the 
//  old encoder (OSS version 4.2.1 beta) cause the new decoder (OSS 4.2.2) to 
//  crash. The only known products to beware of are:  
//      Microsoft NetMeeting Version 2, (beta 2 and beta 3.)  These do not set
//      either version field.
//      Intel Internet Video Phone Beta 1 (expires 4/19/97)
// 
//  The only PDUs known (so far) to crash are the acks for "MiscellaneousCommand"
//  and "MiscelaneousIndication".  We avoid the acks by not sending the Command or 
//  Indication.

#define BETA_2_ASN_PRESENT
#ifdef BETA_2_ASN_PRESENT

// Intel products: (country code: 0xb5, manufacturer code: 0x8080)
// Intel Internet Video Phone Beta 1 (expires 4/19/97): product number: "Intel 
// Internet Video Phone"; version number: "1.0" 
#define INTEL_H_221_MFG_CODE 0x8080  
#endif

//
//	control channel flags
//

typedef ULONG CCHFLAGS;
						
#define CTRLF_OPEN			0x10000000	// control channel is open
#define CTRLF_ORIGINATING  0x00000001 	// call originated at this end
#define IsCtlChanOpen(f) (f & CTRLF_OPEN)
#define IsOriginating(f) (f & CTRLF_ORIGINATING)

#define CTRLF_INIT_ORIGINATING		CTRLF_ORIGINATING
#define CTRLF_INIT_NOT_ORIGINATING 	0
#define CTRLF_INIT_ACCEPT			CTRLF_OPEN
#define CTRLF_RESET					0

//
//   Extensible Nonstandard data structure
//

typedef enum
{
	NSTD_ID_ONLY = 0, 	// placeholder so that H.221 stuff like Mfr.Id
						// can be exchanged without sacrificing extensibility later
	NSTD_VENDORINFO,    // wrapped CC_VENDORINFO, redundant. 
	NSTD_APPLICATION_DATA   // array of bytes passed from application layer to 
	                        // application layer
} NSTD_DATA_TYPE;

typedef struct 
{
    #define APPLICATION_DATA_DEFAULT_SIZE 4
    DWORD dwDataSize;
    BYTE  data[APPLICATION_DATA_DEFAULT_SIZE];       // variable sized
}APPLICATION_DATA;

typedef struct {
	NSTD_DATA_TYPE data_type;
	DWORD dw_nonstd_data_size;
	union {
		CC_VENDORINFO VendorInfo;
		APPLICATION_DATA AppData; 
	}nonstd_data;
}MSFT_NONSTANDARD_DATA, *PMSFT_NONSTANDARD_DATA;

class CH323Ctrl : public IControlChannel
{

protected:
	OBJ_CPT;		// profiling timer
	
#ifdef BETA_2_ASN_PRESENT
    BOOL m_fAvoidCrashingPDUs;
#endif
//
// Handles and data specific to CALLCONT.DLL apis (H245 call control DLL)
//
	CC_HLISTEN m_hListen;
	CC_HCONFERENCE m_hConference;
	CC_CONFERENCEID m_ConferenceID;
	CC_HCALL m_hCall;
    PCC_ALIASNAMES m_pRemoteAliases;
	PCC_ALIASITEM m_pRemoteAliasItem;
	LPWSTR pwszPeerAliasName;	// unicode peer ID - this is always used for caller ID
	LPWSTR pwszPeerDisplayName;	// unicode peer display name - used for called party ID
								// in the absence of szPeerAliasName
	BOOL m_bMultipointController;

	CC_VENDORINFO m_VendorInfo;
	CC_VENDORINFO m_RemoteVendorInfo;
 	CC_NONSTANDARDDATA m_NonstandardData;
	MSFT_NONSTANDARD_DATA m_NonstdContent;	// empty for now
	CC_CONFERENCEATTRIBUTES	m_ConferenceAttributes;
	CC_PARTICIPANTLIST m_ParticipantList;
public:	
//
//	access methods specific to support of CALLCONT.DLL apis (H245 call control DLL)
//
	CC_HCONFERENCE GetConfHandle() {return(m_hConference);};
	CC_CONFERENCEID GetConfID() {return(m_ConferenceID);};
	CC_CONFERENCEID *GetConfIDptr() {return(&m_ConferenceID);};
	CC_HLISTEN GetListenHandle() {return(m_hListen);};
	CC_HCALL GetHCall() {return(m_hCall);};

//	Callbacks and event handling functions specific to support of
//  CALLCONT.DLL callbacks
//	
	HRESULT ConfCallback (BYTE bIndication,
		HRESULT	hStatus, PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams);
	VOID ListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams);
	VOID OnCallConnect(HRESULT hStatus, PCC_CONNECT_CALLBACK_PARAMS pConfParams);
	VOID OnCallRinging(HRESULT hStatus, PCC_RINGING_CALLBACK_PARAMS pRingingParams);

	VOID OnChannelRequest(HRESULT hStatus,PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS pChannelReqParams);
	VOID OnChannelAcceptComplete(HRESULT hStatus, PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams);
	VOID OnChannelOpen(HRESULT hStatus,PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS pChannelParams );
	VOID OnT120ChannelRequest(HRESULT hStatus,PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS pT120RequestParams);
    VOID OnT120ChannelOpen(HRESULT hStatus, PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS pT120OpenParams);

	BOOL OnCallAccept(PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams);
	VOID OnHangup(HRESULT hStatus);
	VOID OnRxChannelClose(HRESULT hStatus,PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS pChannelParams );
	VOID OnTxChannelClose(HRESULT hStatus,PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams );
	VOID OnMiscCommand(HRESULT hStatus, 
				PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS pParams);
	VOID OnMiscIndication(HRESULT hStatus, 
				PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS pParams);
    VOID OnMute(HRESULT hStatus, PCC_MUTE_CALLBACK_PARAMS pParams);
    VOID OnUnMute(HRESULT hStatus, PCC_UNMUTE_CALLBACK_PARAMS pParams);
// support functions
	HRESULT NewConference(VOID);
    VOID SetRemoteVendorID(PCC_VENDORINFO pVendorInfo);

//
//	End of CALLCONT.DLL specific members
//		
	BOOL IsReleasing() {return((uRef==0)?TRUE:FALSE);};	// object is being released and should not
											// be reentered
// this implementation has a coarse concept of call setup protocol phase because it's
// using apis of CALLCONT.DLL.
	CtlChanStateType	m_Phase;	// our perception of protocol phase
	BOOL m_fLocalT120Cap;
	BOOL m_fRemoteT120Cap;
	
public:
	CH323Ctrl();
	~CH323Ctrl();


protected:
	SOCKADDR_IN local_sin;
	SOCKADDR_IN remote_sin;	
	int local_sin_len;
	int remote_sin_len;
	
	LPVOID lpvRemoteCustomFormats;
	
	virtual VOID Cleanup();
	BOOL ConfigureRecvChannelCapability(ICtrlCommChan *pChannel , PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams);
	BOOL ValidateChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
	
	STDMETHOD(FindDefaultRXChannel(PCC_TERMCAP pChannelCapability, ICtrlCommChan **lplpChannel));
	GUID m_PID;
private:
	UINT 		uRef;
	HRESULT 	hrLast;
	CCHFLAGS 	m_ChanFlags;
	HRESULT 	m_hCallCompleteCode;
	COBLIST m_ChannelList;            
	IConfAdvise *m_pConfAdvise;
	ICtrlCommChan *FindChannel(CC_HCHANNEL hChannel);
	VOID DoAdvise(DWORD dwEvent, LPVOID lpvData);
	VOID CheckChannelsReady(VOID);
	VOID NewRemoteUserInfo(PCC_ALIASNAMES pRemoteAliasNames, LPWSTR szRemotePeerDisplayName);
	VOID ConnectNotify(DWORD dwEvent);
	VOID GoNextPhase(CtlChanStateType phase);
	VOID InternalDisconnect();
	HRESULT AllocConferenceAttributes();
	VOID CleanupConferenceAttributes();
    VOID ReleaseAllChannels();
    
public:

	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());

	STDMETHOD( Init(IConfAdvise *pConfAdvise));
	STDMETHOD( DeInit(IConfAdvise *pConfAdvise));
	VOID SetRemoteAddress(PSOCKADDR_IN psin) {remote_sin = *psin;};
	VOID SetLocalAddress(PSOCKADDR_IN psin) {local_sin = *psin;};
	
	// so we know what address we accepted on
	STDMETHOD( GetLocalAddress(PSOCKADDR_IN *lplpAddr));	
	// so we know the address of the caller
	STDMETHOD( GetRemoteAddress(PSOCKADDR_IN *lplpAddr));
	STDMETHOD( GetRemotePort(PORT * lpPort));
	STDMETHOD( GetLocalPort(PORT * lpPort));
    STDMETHOD(PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData));
	STDMETHOD_(VOID, Disconnect(DWORD dwReason));
	STDMETHOD( ListenOn(PORT Port));
	STDMETHOD( StopListen(VOID));
   	STDMETHOD( AsyncAcceptRejectCall(CREQ_RESPONSETYPE Response));	
   	
	// accept from the listening connection.  The ideal is that the accepting
	// object would QueryInterface for a private interface, then grab all the
	// pertinent connection info through that interface.  Temporarily expose this
	// using the IControlChannel interface.  The call control state will vary greatly
	// between implementations. For some implementations, this may perform
	// a socket accept before user information has been exchanged. User information will
	// be read into the accepting object directly.  For other implementations, the
	// socket accept is decoupled and has already been performed, and user information
	// has already been read into the listening object. In that case, this method
	// copies the user info and advises the parent "Conference" object of the
	// incoming call
	STDMETHOD( AcceptConnection(LPIControlChannel pIListenCtrlChan, LPVOID lpvListenCallbackParams));
	STDMETHOD_(BOOL, IsAcceptingConference(LPVOID lpvConfID));
	STDMETHOD( GetProtocolID(LPGUID lpPID));
	STDMETHOD_(IH323Endpoint *, GetIConnIF());
	STDMETHOD( MiscChannelCommand(ICtrlCommChan *pChannel,VOID * pCmd));
	STDMETHOD( MiscChannelIndication(ICtrlCommChan *pChannel,VOID * pCmd));
	STDMETHOD( OpenChannel(ICtrlCommChan * pCommChannel, IH323PubCap *pCapResolver,
		MEDIA_FORMAT_ID dwIDLocalSend, MEDIA_FORMAT_ID dwIDRemoteRecv));
	STDMETHOD (CloseChannel(ICtrlCommChan* pCommChannel));
    STDMETHOD (AddChannel(ICtrlCommChan * pCommChannel, LPIH323PubCap pCapabilityResolver));
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));    
	};


#endif	//#ifndef _CTRLH323_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\commchan.h ===
/*
 *  	File: commchan.h
 *
 *      Network media channel interface implementation
 *
 *		Revision History:
 *
 *		10/09/96	mikev	created
 */


#ifndef _COMMCHAN_H
#define _COMMCHAN_H


#ifdef COARSE_PROFILE
	typedef struct {
		DWORD dwStart;
		DWORD dwLast;
// 		DWORD dwElapsed;	// to take advantage of thread timers
	}CP_TIME;

#define CPT_LOCAL CP_TIME _cpt_
#define OBJ_CPT CP_TIME m_cpt_

#define OBJ_CPT_RESET	m_cpt_.dwStart = m_cpt_.dwLast = GetTickCount()
#define OBJ_ETIME		((m_cpt_.dwLast = GetTickCount()) - m_cpt_.dwStart)
#define OBJ_ETIME_RESET	m_cpt_.dwStart = m_cpt_.dwLast
	// tricky macro
#define OBJ_NEW_ETIME	((m_cpt_.dwLast = GetTickCount()) - m_cpt_.dwStart); m_cpt_.dwStart = m_cpt_.dwLast

// SHOW_OBJ_ETIME snaps elapsed time since last show or reset, then resets
	#ifdef DEBUG
		#define SHOW_OBJ_ETIME(s) DEBUGMSG(ZONE_PROFILE,("\r\n** (%s) ELAPSED TIME(ms):%d, ticks:%d **\r\n", \
			(s), OBJ_ETIME, m_cpt_.dwLast)); OBJ_ETIME_RESET

	#else
		#define SHOW_OBJ_ETIME(s) RETAILMSG(("\r\n** (%s) ELAPSED TIME(ms):%d, ticks:%d **\r\n", \
			(s), OBJ_ETIME, m_cpt_.dwLast )); OBJ_ETIME_RESET
	#endif

#else	// not COARSE_PROFILE
#define CPT_LOCAL
#define CPT_RESET
#define CPT_DELTA
#define OBJ_CPT
#define OBJ_CPT_RESET
#define OBJ_NEW_ETIME
#define SHOW_OBJ_ETIME(s)
#endif	// COARSE_PROFILE


#undef INTERFACE
#define INTERFACE ICtrlCommChan
DECLARE_INTERFACE_(ICtrlCommChan, IUnknown)
{
    STDMETHOD(StandbyInit)(LPGUID lpMID, LPIH323PubCap pCapObject,
	    IMediaChannel* pMediaStreamSend) PURE;
	STDMETHOD_(BOOL, Init)(LPGUID lpMID, IH323ConfAdvise *pH323ConfAdvise,
	    BOOL fSendDirection) PURE;

    STDMETHOD(GetMediaType)(LPGUID pGuid) PURE;
    // EnableOpen is needed temporaraily until NMCOM is master of channels
    STDMETHOD(EnableOpen)(BOOL bEnable) PURE;
    // The CtrlChanSetProperty() method is only used for 4 things:
    // 1&2 - (Boolean) local and remote Temporal/Spatial tradeoff capability,
    // 3&4 (word) local & remote Temporal/Spatial tradeoff value
	STDMETHOD(CtrlChanSetProperty)(THIS_ DWORD prop, PVOID pBuf, DWORD cbBuf)PURE;

	STDMETHOD( PauseNet)(THIS_ BOOL bPause, BOOL bRemote) PURE;
	STDMETHOD( BeginControlSession)(IControlChannel *pCtlChan, LPIH323PubCap pCapObject) PURE;
	STDMETHOD( EndControlSession)(THIS)  PURE;
   	STDMETHOD_(IControlChannel *, GetControlChannel)(THIS) PURE;

	STDMETHOD( OnChannelOpening)(THIS)  PURE;
	STDMETHOD( OnChannelOpen)(THIS_ DWORD dwStatus) PURE;
	STDMETHOD( OnChannelClose)(THIS_ DWORD dwStatus) PURE;
   	STDMETHOD_(UINT, Reset) (THIS) PURE;
   	
	STDMETHOD_(BOOL, SelectPorts) (THIS_ LPIControlChannel pCtlChannel) PURE;
	STDMETHOD_(PSOCKADDR_IN, GetLocalAddress)(THIS) PURE;
	STDMETHOD_(	PORT, GetLocalRTPPort) (THIS) PURE;
	STDMETHOD_(	PORT, GetLocalRTCPPort) (THIS) PURE;
	
	STDMETHOD( AcceptRemoteAddress) (THIS_ PSOCKADDR_IN pSinD) PURE;
	STDMETHOD( AcceptRemoteRTCPAddress) (THIS_ PSOCKADDR_IN pSinC) PURE;
	
	STDMETHOD_(BOOL, IsChannelOpen)(THIS) PURE;
	STDMETHOD_(BOOL, IsOpenPending)(THIS) PURE;
    STDMETHOD_(BOOL, IsSendChannel) (THIS) PURE;
	STDMETHOD_(BOOL, IsChannelEnabled) (THIS) PURE;
	
	STDMETHOD( ConfigureCapability)(THIS_ LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
		LPVOID lpvLocalParams, UINT uLocalParamSize) PURE;
	STDMETHOD( GetLocalParams)(THIS_ LPVOID lpvChannelParams, UINT uBufSize) PURE;
	STDMETHOD_(LPVOID, GetRemoteParams)(THIS) PURE;
 	STDMETHOD_(VOID, SetNegotiatedLocalFormat)(THIS_ DWORD dwF) PURE;
	STDMETHOD_(VOID, SetNegotiatedRemoteFormat)(THIS_ DWORD dwF) PURE;
	
	// GetHChannel, SetHChannel simply store and retrieve a handle.  This is an Intel
	// call control handle.
   	STDMETHOD_(DWORD_PTR, GetHChannel) (THIS) PURE;
    STDMETHOD_(VOID, SetHChannel) (THIS_ DWORD_PTR dwSetChannel) PURE;	
};




class ImpICommChan : public ICommChannel, public ICtrlCommChan, public IStreamSignal
{

protected:
    UINT m_uRef;
	GUID m_MediaID;
	BOOL bIsSendDirection;		// true if send, false if receive
	OBJ_CPT;		// profiling timer
	LPVOID pRemoteParams;
	LPVOID pLocalParams;
	UINT uLocalParamSize;
	// so far there is no reason to remember size of remote params.
	
protected:
	IMediaChannel *m_pMediaStream;
	IRTPSession *m_pRTPChan;
	IControlChannel *m_pCtlChan;
	LPIH323PubCap m_pCapObject;
	
	IH323ConfAdvise *m_pH323ConfAdvise;
	
	DWORD m_dwFlags;
	#define COMCH_ENABLED        0x00000010		// enabled. (ok to attempt or accept open)
 	#define COMCH_OPEN_PENDING              0x00008000 										
	#define COMCH_STRM_STANDBY	            0x00010000		// preview needs to be on always
	#define COMCH_STRM_LOCAL	            0x00020000
	#define COMCH_STRM_NETWORK	            0x00040000
	#define COMCH_OPEN			            0x00080000
	#define COMCH_RESPONSE_PENDING	        0x00100000
	#define COMCH_SUPPRESS_NOTIFICATION     0x00200000
	#define COMCH_STRM_REMOTE	            0x00400000	
	#define COMCH_PAUSE_LOCAL	            0x00800000	
	#define COMCH_STRM_CONFIGURE_STANDBY	0x01000000		// stream needs to remain configured
	
	#define IsComchOpen() (m_dwFlags & COMCH_OPEN)
	#define IsStreamingStandby() (m_dwFlags & COMCH_STRM_STANDBY)
	#define IsConfigStandby() (m_dwFlags & COMCH_STRM_CONFIGURE_STANDBY)

	#define IsStreamingLocal() (m_dwFlags & COMCH_STRM_LOCAL)
	#define IsStreamingRemote() (m_dwFlags & COMCH_STRM_REMOTE)

	#define IsStreamingNet() (m_dwFlags & COMCH_STRM_NETWORK)
	#define IsResponsePending() (m_dwFlags & COMCH_RESPONSE_PENDING)
	#define IsNotificationSupressed() (m_dwFlags & COMCH_SUPPRESS_NOTIFICATION)
		
	#define StandbyFlagOff() (m_dwFlags &= ~COMCH_STRM_STANDBY)
	#define StandbyFlagOn() (m_dwFlags |= COMCH_STRM_STANDBY)
	#define StandbyConfigFlagOff() (m_dwFlags &= ~COMCH_STRM_CONFIGURE_STANDBY)
	#define StandbyConfigFlagOn() (m_dwFlags |= COMCH_STRM_CONFIGURE_STANDBY)

	#define LocalStreamFlagOff() (m_dwFlags &= ~COMCH_STRM_LOCAL)
	#define LocalStreamFlagOn() (m_dwFlags |= COMCH_STRM_LOCAL)
	#define RemoteStreamFlagOff() (m_dwFlags &= ~COMCH_STRM_REMOTE)
	#define RemoteStreamFlagOn() (m_dwFlags |= COMCH_STRM_REMOTE)
	
	#define LocalPauseFlagOff() (m_dwFlags &= ~COMCH_PAUSE_LOCAL)
	#define LocalPauseFlagOn() (m_dwFlags |= COMCH_PAUSE_LOCAL)
	#define IsPausedLocal() (m_dwFlags & COMCH_PAUSE_LOCAL)

	#define StreamFlagsOff() (m_dwFlags &= ~(COMCH_STRM_LOCAL | COMCH_STRM_NETWORK))
	#define StreamFlagsOn() (m_dwFlags |= (COMCH_STRM_LOCAL | COMCH_STRM_NETWORK))
	#define NetworkStreamFlagOff() (m_dwFlags &= ~COMCH_STRM_NETWORK)
	#define NetworkStreamFlagOn() (m_dwFlags |= COMCH_STRM_NETWORK)
	#define ResponseFlagOn() (m_dwFlags |= COMCH_RESPONSE_PENDING)
	#define ResponseFlagOff() (m_dwFlags &= ~COMCH_RESPONSE_PENDING)
	#define SuppressNotification() (m_dwFlags |= COMCH_SUPPRESS_NOTIFICATION)
	#define AllowNotifications() (m_dwFlags &= ~COMCH_SUPPRESS_NOTIFICATION)

	
		
	MEDIA_FORMAT_ID m_LocalFmt;	// format ID of what we are sending or receiving
	MEDIA_FORMAT_ID m_RemoteFmt;// remote's format ID of the complimentary format
	DWORD m_TemporalSpatialTradeoff;	// For send channels, this is the local value.
									// For receive channels, this is the remote value.
									// A magic number between 1 and 31 that describes
									// the relative tradeoff between compression and
									// bitrate.  This is part of H.323/H.245.
									// The ITU decided on the weird range.
									
	BOOL m_bPublicizeTSTradeoff;	// For send channels, this indicates our willingness
									// to accept remote control of T/S tradeoff, and
									// also signal changes in our local TS value to
									// the remote.
									// For receive channels, it indicates the remote's
									// willingness.
    DWORD m_dwLastUpdateTick;       // tick count of last attempt to request I-Frame
    #define MIN_IFRAME_REQ_TICKS    5000    // minimum #of elapsed ticks between requests

	DWORD_PTR	dwhChannel; //General purpose handle.  Whatever
	// creates an instance of this class can use this for whatever it wants

	STDMETHODIMP StreamStandby(BOOL bStandby);
    STDMETHODIMP ConfigureStream(MEDIA_FORMAT_ID idLocalFormat);
public:	

// ICtrlCommChannel methods
   	STDMETHODIMP_(IControlChannel *) GetControlChannel(VOID) {return m_pCtlChan;};
    STDMETHODIMP StandbyInit(LPGUID lpMID, LPIH323PubCap pCapObject,
	    IMediaChannel* pMediaStreamSend);

    STDMETHODIMP_(BOOL) Init(LPGUID lpMID, IH323ConfAdvise *pH323ConfAdvise, BOOL fSendDirection)
	{
    	m_MediaID = *lpMID;
		bIsSendDirection = fSendDirection;
		m_pH323ConfAdvise = pH323ConfAdvise;
		return TRUE;
	};


    STDMETHODIMP CtrlChanSetProperty(DWORD prop, PVOID pBuf, DWORD cbBuf);
    STDMETHODIMP PauseNet(BOOL bPause, BOOL bRemote);
    STDMETHODIMP BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject);
    STDMETHODIMP EndControlSession();
    STDMETHODIMP OnChannelOpening();
    STDMETHODIMP OnChannelOpen(DWORD dwStatus);
    STDMETHODIMP OnChannelClose(DWORD dwStatus);
    STDMETHODIMP_(UINT) Reset(VOID);

    STDMETHODIMP_(BOOL) SelectPorts(LPIControlChannel pCtlChannel);
    STDMETHODIMP_(PSOCKADDR_IN) GetLocalAddress();
    STDMETHODIMP_(PORT) GetLocalRTPPort();
    STDMETHODIMP_(PORT) GetLocalRTCPPort ();
    STDMETHODIMP AcceptRemoteAddress (PSOCKADDR_IN pSinD);
    STDMETHODIMP AcceptRemoteRTCPAddress(PSOCKADDR_IN pSinC);

    STDMETHODIMP_(BOOL) IsSendChannel () {return bIsSendDirection;};
    STDMETHODIMP_(BOOL) IsChannelOpen(){return ((m_dwFlags & COMCH_OPEN) !=0);};
    STDMETHODIMP_(BOOL) IsOpenPending(){return ((m_dwFlags & COMCH_OPEN_PENDING ) !=0);};
    STDMETHODIMP_(BOOL) IsChannelEnabled(){return ((m_dwFlags & COMCH_ENABLED ) !=0);};

    STDMETHODIMP ConfigureCapability(LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
        LPVOID lpvLocalParams, UINT uLocalParamSize);
    STDMETHODIMP GetLocalParams(LPVOID lpvChannelParams, UINT uBufSize);
    STDMETHODIMP_(PVOID) GetRemoteParams(VOID) {return pRemoteParams;}
    STDMETHODIMP_(VOID) SetNegotiatedLocalFormat(DWORD dwF) {m_LocalFmt = dwF;};
    STDMETHODIMP_(VOID) SetNegotiatedRemoteFormat(DWORD dwF) {m_RemoteFmt = dwF;};
    STDMETHODIMP_(DWORD_PTR) GetHChannel(VOID) {return dwhChannel;};
    STDMETHODIMP_(VOID) SetHChannel (DWORD_PTR dwSetChannel) {dwhChannel = dwSetChannel;};	

// ICommChannel Methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef());
    STDMETHOD_(ULONG,Release());

    STDMETHOD(GetProperty(DWORD prop, PVOID pBuf, LPUINT pcbBuf));
    STDMETHOD(SetProperty(DWORD prop, PVOID pBuf, UINT cbBuf));
    STDMETHOD(IsChannelOpen(BOOL *pbOpen));
    STDMETHOD(Open(MEDIA_FORMAT_ID idLocalFormat,IH323Endpoint *pConnection));
    STDMETHOD(Close());
    STDMETHOD(SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));
    STDMETHOD(EnableOpen(BOOL bEnable));
    STDMETHODIMP GetMediaType(LPGUID pGuid);
    STDMETHODIMP_(IMediaChannel *) GetMediaChannel(VOID) {return m_pMediaStream;};
    STDMETHOD(Preview(MEDIA_FORMAT_ID idLocalFormat, IMediaChannel * pMediaChannel));
    STDMETHOD(PauseNetworkStream(BOOL fPause));
    STDMETHOD_(BOOL, IsNetworkStreamPaused(VOID));
    STDMETHOD_(BOOL, IsRemotePaused(VOID));
    STDMETHODIMP_(MEDIA_FORMAT_ID) GetConfiguredFormatID() {return m_LocalFmt;};
	STDMETHODIMP GetRemoteAddress(PSOCKADDR_IN pAddrOutput);
// IStreamSignal Methods
    STDMETHOD(PictureUpdateRequest());
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO* ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));

	ImpICommChan ();
 	~ImpICommChan ();
};

#endif	// _ICOMCHAN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\connobj.h ===
/*
 *  	File: connobj.h
 *
 *      implementation of Connection Object
 *
 *		Revision History:
 *
 *		05/08/96	mikev	created
 */


#ifndef _CONNOBJ_H
#define _CONNOBJ_H


/*
 *	Class definitions
 */

class ImpIConnection : public IH323Endpoint
{
friend class CH323CallControl;	
public:	

    STDMETHOD(QueryInterface(REFIID riid, LPVOID FAR * ppvObj));	
	STDMETHOD_(ULONG,AddRef());
	STDMETHOD_(ULONG,Release());
	STDMETHOD( SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));
	STDMETHOD( ClearAdviseInterface());
    STDMETHOD(PlaceCall(BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData));	
	STDMETHOD( Disconnect());
	STDMETHOD( GetState(ConnectStateType *pState));
    STDMETHOD( GetRemoteUserName(LPWSTR lpwszName, UINT uSize));
    STDMETHOD( GetRemoteUserAddr(PSOCKADDR_IN psinUser));
    STDMETHOD( AcceptRejectConnection(THIS_ CREQ_RESPONSETYPE RejectReason));

    STDMETHOD_(HRESULT, GetSummaryCode());
   	STDMETHOD( CreateCommChannel(THIS_ LPGUID pMediaGuid, ICommChannel **ppICommChannel,
    	BOOL fSend));
	STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput));
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));
	ImpIConnection();
 	~ImpIConnection(){};
 	void Init(class CConnection FAR * pCon) {m_pConnection = pCon;};

protected:
	CConnection *m_pConnection;
};


class CConnection :
	public IH323Endpoint,
	public IConfAdvise
{

friend class CH323CallControl;
private:
	
	ImpIConnection m_ImpConnection;
	CH323CallControl *m_pH323CallControl;

	LPIH323PubCap m_pCapObject;
	
protected:
	COBLIST m_ChannelList;  
    COBLIST m_MemberList;
   
	UINT uRef;
	HRESULT hrLast;
	CConnection *next;
    BOOL            m_fCapsReady;
	IH323ConfAdvise *m_pH323ConfAdvise;
	LPCTRL_USER_INFO 	m_pUserInfo;	
	LPIControlChannel 	m_pControlChannel;
	HRESULT     m_hSummaryCode;		// best known reason for disconnect or reject
public:
	virtual HRESULT Init(class CH323CallControl *pH323CallControl, GUID PIDofProtocolType);
    void DeInit(VOID) {m_pH323CallControl = NULL;};
	CConnection();
	~CConnection();

protected:
	
	ConnectStateType 	m_ConnectionState;
	VOID DoControlNotification(DWORD dwStatus);
public:
	BOOL ListenOn(PORT Port);
	VOID Disconnect(DWORD dwResponse);
	HRESULT CloseAllChannels();
	VOID NewUserInfo(LPCTRL_USER_INFO lpNewUserInfo);
	
public:	
	LPIControlChannel GetControlChannel( ){return m_pControlChannel;};
    VOID ReleaseAllChannels();
        
	STDMETHOD(GetLocalPort(PORT *lpPort));
	STDMETHOD (OnCallIncomplete (
	    LPIControlChannel lpControlObject, 
	    HRESULT hIncompleteCode));

	VOID SummaryCode(HRESULT hCode);

	
//	IConfAdvise interface methods
//
    STDMETHOD(OnControlEvent(DWORD dwEvent, LPVOID lpvData, LPIControlChannel lpControlObject));
    STDMETHOD(GetCapResolver(LPVOID *lplpCapObject, GUID CapType));
	STDMETHOD_(LPWSTR, GetUserDisplayName());
    STDMETHOD_(PCC_ALIASITEM, GetUserDisplayAlias());
	STDMETHOD_(PCC_ALIASNAMES, GetUserAliases());

	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(
	    LPIControlChannel lpControlChannel, P_APP_CALL_SETUP_DATA pAppData));
	STDMETHOD(GetAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPGUID pPID));
	STDMETHOD(FindAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPVOID lpvConfID));
	STDMETHOD_(IH323Endpoint *, GetIConnIF()) {return &m_ImpConnection;};
	STDMETHOD (AddCommChannel (ICtrlCommChan *pChan));



// Shared IIntConn/IConnection interface methods
	STDMETHOD( Disconnect());
	
// IConnection interface  methods
	STDMETHOD(QueryInterface(REFIID riid, LPVOID FAR * ppvObj));
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD( SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));
	STDMETHOD( ClearAdviseInterface());
    STDMETHOD(PlaceCall(BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData));	
	STDMETHOD( GetState(ConnectStateType *pState));
	STDMETHOD( GetRemoteUserName(LPWSTR lpwszName, UINT uSize));
	STDMETHOD( GetRemoteUserAddr(THIS_ PSOCKADDR_IN psinUser));
    STDMETHOD( AcceptRejectConnection(THIS_ CREQ_RESPONSETYPE RejectReason));
	STDMETHOD( GetSummaryCode());
   	STDMETHOD( CreateCommChannel(THIS_ LPGUID pMediaGuid, ICommChannel **ppICommChannel,
    	BOOL fSend));
	STDMETHOD ( ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput));	
    STDMETHOD(GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo));
};


#endif // _CONNOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\connobj.cpp ===
/*
 *  	File: connobj.cpp
 *
 *		implementation of Microsoft Network Audio connection object.
 *
 *		
 *
 *		Revision History:
 *
 *		05/05/96	mikev	created
 *	 	08/04/96	philf	added support for video
 *      09/22/96	mikev	dual call control protocols (H.323 & MSICCP)
 *      10/14/96	mikev	multiple channel support, property I/F
 */


#include "precomp.h"
#include "ctrlh323.h"
#include "strutil.h"


CREQ_RESPONSETYPE CConnection::FilterConnectionRequest(
    LPIControlChannel lpControlChannel,
     P_APP_CALL_SETUP_DATA pAppData)
{
	FX_ENTRY ("CConnection::FilterConnectionRequest");
	CREQ_RESPONSETYPE cr;
	// validate lpControlChannel - this implementation sets it inside
	// GetAcceptingObject()
	if(m_pControlChannel != lpControlChannel)
	{
		ERRORMESSAGE(("%s:bad param:my pChan:0x%08lX, param pChan:0x%08lX\r\n",
			_fx_, m_pControlChannel, lpControlChannel));
		hrLast = CADV_E_INVALID_PARAM;
		return CRR_ERROR;
	}	
	m_ConnectionState = CLS_Alerting;
	cr = m_pH323CallControl->FilterConnectionRequest(this, pAppData);
	switch (cr)
	{
		case CRR_ASYNC:
			// m_ConnectionState = CLS_Alerting; // stays in this state
		break;
		case CRR_ACCEPT:
			m_ConnectionState = CLS_Connecting;
		break;	

		// set summary codes in reject cases
		case CRR_BUSY:
			m_ConnectionState = CLS_Idle;
			SummaryCode(CCR_LOCAL_BUSY);
		break;
		case CRR_SECURITY_DENIED:
			m_ConnectionState = CLS_Idle;
			SummaryCode(CCR_LOCAL_SECURITY_DENIED);
		break;
		default:
		case CRR_REJECT:
			m_ConnectionState = CLS_Idle;
			SummaryCode(CCR_LOCAL_REJECT);
		break;
	}
	return(cr);
}


HRESULT CConnection::FindAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPVOID lpvConfID)
{
	FX_ENTRY ("CConnection::FindAcceptingObject");
	HRESULT hr = H323CC_E_CONNECTION_NOT_FOUND;
	ULONG ulCount, uNumConnections;
	CConnection **ppConnections = NULL;;
	LPIControlChannel pCtlChan;
	CConnection *pConnection;

	if(!lplpAcceptingObject)
	{
		ERRORMESSAGE(("%s:null lplpAcceptingObject\r\n",_fx_));
		return CADV_E_INVALID_PARAM;
	}
	// zero out the output param
	*lplpAcceptingObject = NULL;
	hr = m_pH323CallControl->GetNumConnections(&uNumConnections);
	if(!HR_SUCCEEDED(hr))
		goto EXIT;
	if(!uNumConnections)
	{
		// initialized value hr = H323CC_E_CONNECTION_NOT_FOUND;
		goto EXIT;
	}
	ppConnections = (CConnection **)MemAlloc(uNumConnections * (sizeof(IH323Endpoint * *)));
	if(!ppConnections)
	{
		hr = H323CC_E_INSUFFICIENT_MEMORY;	
		goto EXIT;
	}
			
	// get list of connections and query each one for matching conference ID
	hr = m_pH323CallControl->GetConnobjArray(ppConnections, uNumConnections * (sizeof(IH323Endpoint * *)));
	if(!HR_SUCCEEDED(hr))
		goto EXIT;
	
	for(ulCount=0;ulCount <uNumConnections;ulCount++)
	{
		pConnection = ppConnections[ulCount];
		if(pConnection &&  (pCtlChan = pConnection->GetControlChannel())
			&& pCtlChan->IsAcceptingConference(lpvConfID))
		{
			*lplpAcceptingObject = pCtlChan;
			hr = hrSuccess;
			break;
		}
	}

EXIT:
	if(ppConnections)
		MemFree(ppConnections);

	return hr;

}


HRESULT CConnection::GetAcceptingObject(LPIControlChannel *lplpAcceptingObject,
	LPGUID pPID)
{
	FX_ENTRY ("CConnection::GetAcceptingObject");
	HRESULT hr;
	CConnection *pNewConnection;
	if(!lplpAcceptingObject)
	{
		ERRORMESSAGE(("%s:null lplpAcceptingObject\r\n",_fx_));
		return CADV_E_INVALID_PARAM;
	}
	// zero out the output param
	*lplpAcceptingObject = NULL;
	
	// create a connection object to accept the connection
	hr = m_pH323CallControl->CreateConnection(&pNewConnection, *pPID);
	if(HR_SUCCEEDED(hr))
	{
		*lplpAcceptingObject = pNewConnection->GetControlChannel();
	}
	else
	{
		ERRORMESSAGE(("%s:CreateConnection failed, hr=0x%08lx\r\n",_fx_, hr));
	}
	return hr;
}

//  This is called by a comm channel.  It is only called by a channel that is being 
//  opened, and only if that channel is not already associated with a control channel.
HRESULT CConnection::AddCommChannel (ICtrlCommChan *pChan)
{
    GUID mid;
	if(!m_fCapsReady)
    {
    	ASSERT(0);
		hrLast = CONN_E_NOT_INITIALIZED;	// need better error to indicate why 
							// (connection is not yet in a state to take new channels)
		goto EXIT;
    }
 	
	// re-initialize channel	
    hrLast = pChan->GetMediaType(&mid);
    
	ASSERT(m_pH323ConfAdvise != NULL);
	if(!pChan->Init(&mid, m_pH323ConfAdvise, TRUE))
	{
		hrLast = CONN_E_SYSTEM_ERROR;
		goto EXIT;
	}

	// non error case continues here
	if(m_pControlChannel)
	{
		m_ChannelList.AddTail(pChan);
		pChan->AddRef();
		hrLast = m_pControlChannel->AddChannel(pChan, m_pCapObject);
		if(!HR_SUCCEEDED(hrLast))
			goto EXIT;
	}
    
  EXIT:
    return hrLast;
}


HRESULT CConnection::CreateCommChannel(LPGUID pMediaGuid, ICommChannel **ppICommChannel,
	BOOL fSend)
{
	FX_ENTRY ("CConnection::CreateCommChannel");
	ICommChannel *pICommChannel = NULL;
	ICtrlCommChan *pICtrlCommChannel = NULL;
	
	if(!pMediaGuid || !ppICommChannel)
	{
		hrLast = CONN_E_INVALID_PARAM;
		goto EXIT;
	}

    DBG_SAVE_FILE_LINE
	if(*pMediaGuid == MEDIA_TYPE_H323_T120)
	{
		if(!(pICommChannel = (ICommChannel *)new ImpT120Chan))
		{
			hrLast = CONN_E_OUT_OF_MEMORY;
			goto EXIT;
		}
	}
	else if(!(pICommChannel = (ICommChannel *)new ImpICommChan))
	{
		hrLast = CONN_E_OUT_OF_MEMORY;
		goto EXIT;
	}
	
	hrLast = pICommChannel->QueryInterface(IID_ICtrlCommChannel, (void **)&pICtrlCommChannel);
	if(!HR_SUCCEEDED(hrLast))
	{
		goto EXIT;
	}

	ASSERT(m_pH323ConfAdvise != NULL);
	if(!pICtrlCommChannel->Init(pMediaGuid, m_pH323ConfAdvise, fSend))
	{
		hrLast = CONN_E_SYSTEM_ERROR;
		goto EXIT;
	}

	// it's created via this connection, now associate it and this connection
	if(m_pControlChannel)
	{
		m_ChannelList.AddTail(pICtrlCommChannel);
		hrLast = m_pControlChannel->AddChannel(pICtrlCommChannel, m_pCapObject);
		if(!HR_SUCCEEDED(hrLast))
			goto EXIT;
	}


	// in success case, the calling function gets the ICommChannel reference, and this
	// object gets the ICtrlCommChan reference
	*ppICommChannel = pICommChannel;
	pICommChannel = NULL;
	pICtrlCommChannel = NULL;

	EXIT:
	if(pICommChannel)
		pICommChannel->Release();
	if(pICtrlCommChannel)
		pICtrlCommChannel->Release();	
	return hrLast;
}

HRESULT CConnection:: ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput)
{
	ASSERT(NULL !=m_pCapObject);
	return (m_pCapObject->ResolveFormats(pMediaGuidArray, uNumMedia, pResOutput));
}

HRESULT CConnection::GetVersionInfo(PCC_VENDORINFO *ppLocalVendorInfo,
									  PCC_VENDORINFO *ppRemoteVendorInfo)
{
	if(!m_pControlChannel)
		return CONN_E_NOT_INITIALIZED;
		
	return (m_pControlChannel->GetVersionInfo(ppLocalVendorInfo, ppRemoteVendorInfo));
}

VOID CConnection ::ReleaseAllChannels()
{
	ICtrlCommChan *pChan = NULL;
	while (!m_ChannelList.IsEmpty())
	{
		pChan = (ICtrlCommChan *) m_ChannelList.RemoveHead();
		if(pChan)
		{
			pChan->Release();
			pChan = NULL;
		}
	}
}

//
// Implementation of IConfAdvise::OnControlEvent
//
// CAUTION: because Release() can be called by the registered event handler,
// any code path that accesses class instance data after a call to m_pH323ConfAdvise->CallEvent
// must AddRef() before the call, and Release() after all class instance data access
// is done.  The DoControlNotification() helper method does this, but beware of
// cases where data is touched after a call to DoControlNotification();
//
HRESULT CConnection::OnControlEvent(DWORD dwEvent, LPVOID lpvData, 	LPIControlChannel lpControlObject)
{
	FX_ENTRY ("CConnection::OnControlEvent");
	DWORD dwStatus;
	BOOL fPost = FALSE;
	HRESULT hr=hrSuccess;

	AddRef();
	switch(dwEvent)
	{	
		case  CCEV_RINGING:
			fPost = TRUE;
			dwStatus = CONNECTION_PROCEEDING;
		break;
		case  CCEV_CONNECTED:
			fPost = TRUE;
			dwStatus = CONNECTION_CONNECTED;
			NewUserInfo((LPCTRL_USER_INFO)lpvData);
		break;
		case  CCEV_CALLER_ID:
			NewUserInfo((LPCTRL_USER_INFO)lpvData);
		break;
		case  CCEV_CAPABILITIES_READY:
			m_fCapsReady = TRUE;
		break;

		case  CCEV_CHANNEL_REQUEST:
		// another channel (besides the channels supplied by EnumChannels()) is being 
		// requested -  we can't handle arbitrary channels yet.
			ERRORMESSAGE(("%s, not handling CCEV_CHANNEL_REQUEST \r\n",_fx_));
			hr = CADV_E_NOT_SUPPORTED;
			goto out;
		break;
		
		case  CCEV_DISCONNECTING:
			//in the future architecture, this event will be the opportunity to
			//cleanup channels
			if(lpvData)
			{
				// keep summary code
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
			Disconnect(CCR_UNKNOWN);
			// IConnect doesn't yet define a "disconnecting" event, so don't propagate it
		break;			
		case  CCEV_REMOTE_DISCONNECTING:
			if(lpvData)
			{
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
			// do notification before calling back into Disconnect, so the event
			// notifications are posted in the correct order. This is one of
			// the cases where Ref count protection is required.
			AddRef();
			DoControlNotification(CONNECTION_RECEIVED_DISCONNECT);
			// opportunity to cleanup channels
			Disconnect(CCR_UNKNOWN);
			Release();
		break;			
		case  CCEV_DISCONNECTED:
			fPost = TRUE;
			m_ConnectionState = CLS_Idle;
			dwStatus = CONNECTION_DISCONNECTED;
			if(lpvData)
			{
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
		break;		
		case  CCEV_ALL_CHANNELS_READY:
		 	// all *mandatory* channels are open, but not necessarily
		 	// all channels
			m_ConnectionState = CLS_Inuse;
			dwStatus = CONNECTION_READY;
			fPost = TRUE;
		break;
		case CCEV_ACCEPT_INCOMPLETE:
			if(lpvData)
			{
			// known problem is that control channel has already
			// disconnected and may have notified of the disconnect first.
			// This could be fixed, but it's not an issue because an incomplete
			// accept is not made known to the UI, therefore the summary code
			// is dust anyway.
				SummaryCode((HRESULT) *((HRESULT *)lpvData));
			}
			if(lpControlObject && (m_pControlChannel == lpControlObject))
			{
				// remove interest in control channel events, then nuke it
				m_pControlChannel->DeInit((IConfAdvise *) this);
				m_pControlChannel->Release();
			}
			m_pControlChannel = NULL;
			if(m_pH323CallControl)
			{
				m_pH323CallControl->RemoveConnection(this);
			}
			Release();	// release self - this is by design
					
	 	break;		 	
		case  CCEV_CALL_INCOMPLETE:
			hr = OnCallIncomplete(lpControlObject, (lpvData)?  ((DWORD) *((DWORD *)lpvData)) :0);
			goto out;
		break;		

 	}
	if(fPost)
		DoControlNotification(dwStatus);

out:
	Release();
	return hr;
}

HRESULT CConnection::OnCallIncomplete (LPIControlChannel lpControlObject, HRESULT hIncompleteCode)
{
	FX_ENTRY ("CConnection::OnCallIncomplete ");
	// check the reason for incomplete call attempt (busy? rejected? nobody home?
	HRESULT hSummary;
	CloseAllChannels();

	// map the protocol-specific (h.323, msiccp, sip, etc) code to the 
	// connection interface code
	// test for gatekeeper admission reject
	// FACILITY_GKIADMISSION
	if(CUSTOM_FACILITY(hIncompleteCode) == FACILITY_GKIADMISSION)
	{
		// pass GK codes through intact
		hSummary = hIncompleteCode;
	}
	else
	{
		switch (hIncompleteCode)
		{
			case CCCI_GK_NO_RESOURCES:
				hSummary = CCR_GK_NO_RESOURCES;
			break;
			case CCCI_BUSY:
				hSummary = CCR_REMOTE_BUSY;
			break;
			case CCCI_SECURITY_DENIED:
				hSummary = CCR_REMOTE_SECURITY_DENIED;
			break;
			case CCCI_NO_ANSWER_TIMEOUT:
				hSummary = CCR_NO_ANSWER_TIMEOUT;
			break;
			case CCCI_REJECTED:
				hSummary = CCR_REMOTE_REJECTED;
			break;
			case CCCI_REMOTE_ERROR:
				hSummary = CCR_REMOTE_SYSTEM_ERROR;
			break;
			case CCCI_LOCAL_ERROR:
				hSummary = CCR_LOCAL_SYSTEM_ERROR;
			break;
			case CCCI_INCOMPATIBLE:
				hSummary = CCR_LOCAL_PROTOCOL_ERROR;
			break;
			case CCCI_UNKNOWN:
				hSummary = CCR_UNKNOWN;
			default:
				hSummary = CCR_UNKNOWN;
			break;
		}
	}

	DEBUGMSG(ZONE_CONN,("%s: incomplete code = 0x%08lX\r\n",
		_fx_, hIncompleteCode));
	SummaryCode(hSummary);
	return hrLast;
}

VOID CConnection::NewUserInfo(LPCTRL_USER_INFO lpNewUserInfo)
{
	FX_ENTRY ("CConnection::NewUserInfo");
	
	if(!lpNewUserInfo || !lpNewUserInfo->dwCallerIDSize || !lpNewUserInfo->lpvCallerIDData)
		return;

	if(m_pUserInfo)
	{
		DEBUGMSG(ZONE_CONN,("%s:uninitialized m_pUserInfo (0x%08lX) or multiple notification \r\n",
			_fx_, m_pUserInfo ));
		//
		if(!IsBadWritePtr((LPVOID)m_pUserInfo, m_pUserInfo->dwCallerIDSize + sizeof(CTRL_USER_INFO)))
		{
			// chances are it *is* a multiple notification and not an uninitialized
			// variable.  Ther may be some control channel protocols that *update* user
			// information after connection or accepting, but that is pure speculation.
			// the typical case is that caller ID is available before accepting, and
			// it is resupplied in the subsequent "connected" notification.  We're not
			// wasting time realloc'ing and recopying it.
			return;
		}
		// else fallout and overwrite it
	}
	// copy the structure and caller ID data
	m_pUserInfo = (LPCTRL_USER_INFO)MemAlloc(lpNewUserInfo->dwCallerIDSize + sizeof(CTRL_USER_INFO));		
	
	if(m_pUserInfo)
	{
		m_pUserInfo->lpvRemoteProtocolInfo = NULL;  // nothing touchess this later, but being safe anyway
		m_pUserInfo->lpvLocalProtocolInfo = NULL;
		
		m_pUserInfo->dwCallerIDSize = lpNewUserInfo->dwCallerIDSize;
		// point past the structure
		m_pUserInfo->lpvCallerIDData = ((BYTE *)m_pUserInfo) + sizeof(CTRL_USER_INFO);
		memcpy(m_pUserInfo->lpvCallerIDData,
			lpNewUserInfo->lpvCallerIDData,
			m_pUserInfo->dwCallerIDSize);
	}
	else
	{
		ERRORMESSAGE(("%s:allocation of m_pUserInfo failed\r\n",_fx_));
	}
}	

//
// Utility function for passing control channel events to the registered handler
// This is callable only by the control channel code running in the same thread
// as that which created the connection.
VOID CConnection::DoControlNotification(DWORD dwStatus)
{
	FX_ENTRY ("CConnection::DoControlNotification");
	// issue notification to registered entity
	if(m_pH323ConfAdvise)
	{
		AddRef();	// protect ourselves from calls back into methods that
					// wind up in Release().
		DEBUGMSG(ZONE_CONN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
        m_pH323ConfAdvise->CallEvent((IH323Endpoint *)&m_ImpConnection, dwStatus);
  		Release();

	}
}


CConnection::CConnection()
:m_pH323CallControl(NULL),
hrLast(hrSuccess),
next(NULL),
m_fCapsReady(FALSE),
m_ConnectionState(CLS_Idle),
m_pH323ConfAdvise(NULL),
m_pUserInfo(NULL),
m_pControlChannel(NULL),
m_pCapObject(NULL),
m_hSummaryCode(hrSuccess),
uRef(1)
{
	m_ImpConnection.Init(this);
}

CConnection::~CConnection()
{
	ReleaseAllChannels();
	if(m_pH323CallControl)
		m_pH323CallControl->RemoveConnection(this);
		
	if(m_pCapObject)
		m_pCapObject->Release();
	// we really don't allocate much
	if(m_pUserInfo)
		MemFree(m_pUserInfo);
	
}   

HRESULT CConnection::Init(CH323CallControl *pH323CallControl, GUID PIDofProtocolType)
{
	FX_ENTRY(("CConnection::Init"));
	hrLast = hrSuccess;
    BOOL     bAdvertise;
	m_pH323CallControl = pH323CallControl;
	GUID mid;

	if(!pH323CallControl)
		return CCO_E_INVALID_PARAM;
		
	if(m_pControlChannel)
	{
		ASSERT(0);
		// don't cleanup in this case
		return CONN_E_ALREADY_INITIALIZED;
	}
	
	if(PIDofProtocolType != PID_H323)
	{
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;
	}
	
    DBG_SAVE_FILE_LINE
	if(!(m_pControlChannel = (LPIControlChannel) new CH323Ctrl))
	{
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;
	}

    DBG_SAVE_FILE_LINE
	if(!m_pCapObject && !(m_pCapObject = new CapsCtl()))
	{
		ERRORMESSAGE(("%s:cannot create capability resolver\r\n",_fx_));
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;;
	}
	if(!m_pCapObject->Init())
	{
		ERRORMESSAGE(("%s:cannot init capability resolver\r\n",_fx_));
		hrLast = CONN_E_INIT_FAILED;
		goto ERROR_CLEANUP;
	}

    bAdvertise = ((g_capFlags & CAPFLAGS_AV_STREAMS) != 0);
	mid = MEDIA_TYPE_H323AUDIO;
	hrLast = m_pCapObject->EnableMediaType(bAdvertise, &mid);
	if(!HR_SUCCEEDED(hrLast))
		goto ERROR_CLEANUP;

    bAdvertise = ((g_capFlags & CAPFLAGS_AV_STREAMS) != 0);
	mid = MEDIA_TYPE_H323VIDEO;
	hrLast = m_pCapObject->EnableMediaType(bAdvertise, &mid);
	if(!HR_SUCCEEDED(hrLast))
		goto ERROR_CLEANUP;

	hrLast = m_pControlChannel->Init((IConfAdvise *) this);
	if(!HR_SUCCEEDED(hrLast))
		goto ERROR_CLEANUP;

	return hrLast;

	ERROR_CLEANUP:
	ERRORMESSAGE(("%s:ERROR_CLEANUP\r\n",_fx_));
	
	if(m_pControlChannel)
		m_pControlChannel->Release();
	if(m_pCapObject)
		m_pCapObject->Release();
	m_pControlChannel = NULL;
	m_pCapObject = NULL;

	return hrLast;
}

BOOL CConnection::ListenOn(PORT port)
{
	if(!m_pControlChannel)
	{
		hrLast = H323CC_E_NOT_INITIALIZED;
		goto EXIT;
	}
	
	hrLast = m_pControlChannel->ListenOn(port);
EXIT:
	return((HR_SUCCEEDED(hrLast))?TRUE:FALSE);
}


// 	start the asynchronous stuff that will instantiate a control channel
HRESULT CConnection::PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData)
{
	if(m_ConnectionState != CLS_Idle)
		return CONN_E_NOT_IDLE;
		
	m_fCapsReady = FALSE;
	// reset summary code
	m_hSummaryCode = CCR_INVALID_REASON;

	hrLast = m_pH323CallControl->GetGKCallPermission();
	if(!HR_SUCCEEDED(hrLast))
	{
		m_hSummaryCode = hrLast;
		return hrLast;
	}
	
	hrLast = m_pControlChannel->PlaceCall (bUseGKResolution, pCallAddr,		
        pDestinationAliases, pExtraAliases,  	
	    pCalledPartyNumber, pAppData);
	    
	if(HR_SUCCEEDED(hrLast))
		m_ConnectionState = CLS_Connecting;
	return hrLast;
}


HRESULT CConnection::AcceptRejectConnection(CREQ_RESPONSETYPE Response)
{
	if(Response == CRR_ACCEPT)
	{
		m_ConnectionState = CLS_Connecting;
		m_fCapsReady = FALSE;
		// reset summary code
		m_hSummaryCode = CCR_INVALID_REASON;
	}
	return m_pControlChannel->AsyncAcceptRejectCall(Response);
}	


HRESULT CConnection::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	ASSERT(pH323ConfAdvise != NULL);	
	if(!pH323ConfAdvise)
	{
		return CONN_E_INVALID_PARAM;
	}
	m_pH323ConfAdvise = pH323ConfAdvise;
	//EXIT:	
	return hrSuccess;
}

HRESULT CConnection::ClearAdviseInterface()
{
	m_pH323ConfAdvise = NULL;
	return hrSuccess;
}	


// LOOKLOOK - the H323 control channel needs to get the combined cap object
// implementation of IConfAdvise::GetCapResolver()
HRESULT CConnection::GetCapResolver(LPVOID *lplpCapObject, GUID CapType)
{
	if(!lplpCapObject)
		return CONN_E_INVALID_PARAM;

	if(!m_pH323CallControl || !m_pCapObject)
		return CONN_E_NOT_INITIALIZED;	
	
	if(CapType == OID_CAP_ACM_TO_H323)
	{
	   *lplpCapObject = m_pCapObject;
	}
	else
	{
		return CONN_E_INVALID_PARAM;
	}
	return hrSuccess;
}


HRESULT CConnection::GetState(ConnectStateType *pState)
{
	HRESULT hResult = hrSuccess;
	if(!pState)
	{
		hResult = CONN_E_INVALID_PARAM;
		goto EXIT;
	}
	
	*pState = m_ConnectionState;
	EXIT:	
	return hResult;
}



// IConfAdvise::GetUserDisplayName()
LPWSTR CConnection::GetUserDisplayName()
{
	if(!m_pH323CallControl)
		return NULL;	
	return m_pH323CallControl->GetUserDisplayName();
}
PCC_ALIASITEM CConnection::GetUserDisplayAlias()
{
	if(!m_pH323CallControl)
		return NULL;	
	return m_pH323CallControl->GetUserDisplayAlias();
}
PCC_ALIASNAMES CConnection:: GetUserAliases() 
{
	if(!m_pH323CallControl)
		return NULL;
	return m_pH323CallControl->GetUserAliases();
}
HRESULT CConnection::GetLocalPort(PORT *lpPort)
{
	if(!m_pControlChannel)
		return CONN_E_NOT_INITIALIZED;
		
	return m_pControlChannel->GetLocalPort(lpPort);	
}	
HRESULT CConnection::GetRemoteUserName(LPWSTR lpwszName, UINT uSize)
{
	
	if(!lpwszName)
	{
		hrLast = MakeResult(CONN_E_INVALID_PARAM);
		goto EXIT;
	}	
	if(!m_pUserInfo)
	{
	// LOOKLOOK - need CONN_E_UNAVAILABLE or something
		hrLast = MakeResult(CONN_E_INVALID_PARAM);
		goto EXIT;
	}
		
	LStrCpyNW((LPWSTR)lpwszName,(LPWSTR)m_pUserInfo->lpvCallerIDData, uSize);	
	hrLast = hrSuccess;	
	EXIT:	
	return hrLast;
}
HRESULT CConnection::GetRemoteUserAddr(PSOCKADDR_IN psinUser)
{
	PSOCKADDR_IN psin = NULL;
	if(!m_pControlChannel)
		return CONN_E_NOT_INITIALIZED;
	
	if(psinUser)
	{	// get ptr to address, then copy it
		hrLast = m_pControlChannel->GetRemoteAddress(&psin);
		if(HR_SUCCEEDED(hrLast) && psin)
		{
			*psinUser = *psin;
		}
	}
	else
	{
		hrLast = H323CC_E_INVALID_PARAM;
	}
	//EXIT:	
	return hrLast;
}


HRESULT CConnection ::Disconnect()
{
	SummaryCode(CCR_LOCAL_DISCONNECT);
	Disconnect(CCR_LOCAL_DISCONNECT);
	return hrSuccess;
}

HRESULT CConnection::CloseAllChannels()
{
	ICtrlCommChan *pChan = NULL;
	HRESULT hr;	// temp return value so error code does not get overwritten
	FX_ENTRY ("CConnection::CloseAllChannels");

	// This doesn't actually cause channel close PDU's to be sent. It only 
	// shuts off all streams associated with all channels.  
	while (!m_ChannelList.IsEmpty())
	{
		pChan = (ICtrlCommChan *) m_ChannelList.RemoveHead();
		if(pChan)
		{
			hr = pChan->OnChannelClose(CHANNEL_CLOSED);
			if(!HR_SUCCEEDED(hr))
				hrLast = hr;
			hr = pChan->EndControlSession();
			if(!HR_SUCCEEDED(hr))	
				hrLast = hr;
			pChan->Release();
		}
	}
	return hrLast;
}

VOID CConnection::Disconnect(DWORD dwResponse)
{
	AddRef();	// prevent releasing while handling disconnect events
	if(!m_pControlChannel)
	{
		m_ConnectionState = CLS_Idle;
		goto EXIT;
	}

	if((m_ConnectionState == CLS_Disconnecting)
		|| (m_ConnectionState == CLS_Idle))
	{
		goto EXIT;
	}
	m_ConnectionState = CLS_Disconnecting;

	// CloseAllChannels() forces the action that would be taken when all 
	// channels are closed via call control.  Anal channel cleanup is not 
	// implemented on disconnect- CloseAllChannels() turns off all streaming,
	//  then we just end the session.  It takes too long to go through the
	// protocol overhead of closing & acking channel close, and it's legal in  
	// H.323 to end the session.  Ending the session implies channel closure  
	// for all channels. 
	// 

	CloseAllChannels();
	
	// this call can result in callbacks to the UI, which can result in
	// calls back in, which results in releasing the object.  If we're
	// about to go in, we need to be sure we can get back out, so AddRef()
	m_pControlChannel->AddRef();
	m_pControlChannel->Disconnect(dwResponse);
	m_pControlChannel->Release();
EXIT:
	Release();
}




STDMETHODIMP CConnection::QueryInterface( REFIID iid,	void ** ppvObject)
{

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if((iid == IID_IPhoneConnection) 
	|| (iid == IID_IUnknown)) // satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if(iid == IID_IConfAdvise)
	{
	    *ppvObject = (IConfAdvise *)this;
   		hr = hrSuccess;
    	AddRef();
	}
	else if((iid == IID_IAppAudioCap ) && m_pCapObject)
	{
	ASSERT(0);
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IAppVidCap ) && m_pCapObject)
	{
///	ASSERT(0);  CVideoProp still uses this
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IDualPubCap) && m_pCapObject)
	{
	ASSERT(0);
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	return (hr);
}

ULONG CConnection::AddRef()
{
	FX_ENTRY ("CConnection::AddRef");
	uRef++;
	DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->AddRef() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
	return uRef;
}

ULONG CConnection::Release()
{
	FX_ENTRY ("CConnection::Release");
	uRef--;
	if(uRef == 0)
	{
		DEBUGMSG(ZONE_CONN,("%s:(0x%08lX)->Releasing in state:%d\r\n",_fx_, this, m_ConnectionState));
		
		// remove our interest in the control channel
		if(m_pControlChannel)
		{
			hrLast = m_pControlChannel->DeInit((IConfAdvise *) this);
			m_pControlChannel->Release();
		}
		
		// m_pControlChannel = NULL;
		delete this;
		return 0;
	}
	else
	{
		DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->Release() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
		return uRef;
	}

}


STDMETHODIMP CConnection::GetSummaryCode(VOID)
{
	return m_hSummaryCode;
}
VOID CConnection::SummaryCode(HRESULT hCode)
{
	// assign code only if it has not yet been assigned
	if(m_hSummaryCode != CCR_INVALID_REASON)
		return;
	m_hSummaryCode = hCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\ctrlh323.cpp ===
/*
 *  	File: ctrlh323.cpp
 *
 *		Implementation of IControlChannel using H.323 call control protocol
 * 		via apis of CALLCONT.DLL
 *		
 *
 *		Revision History:
 *
 *		09/06/96	mikev	created
 *					
 */

#include "precomp.h"
#include "ctrlh323.h"
#include "version.h"
#include "strutil.h"

#ifdef DEBUG
VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
#else
#define DumpNonstdParameters(a, b)
#define DumpChannelParameters(a, b)
#endif

extern HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource);
extern VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed);

static char DefaultProductID[] = H323_PRODUCTNAME_STR;
static char DefaultProductVersion[] = H323_PRODUCTRELEASE_STR;

HRESULT  CCConferenceCallback (BYTE						bIndication,
										HRESULT						hStatus,
										CC_HCONFERENCE                 hConference,
										DWORD_PTR                   dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams);


VOID  CCListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams);

VOID CH323Ctrl::DoAdvise(DWORD dwEvent, LPVOID lpvData)
{
	FX_ENTRY ("CH323Ctrl::DoAdvise");

	if(IsReleasing())	// don't call out while releasing because it could call
						// back in!
	{
		ERRORMESSAGE(("%s:in releasing state\r\n",_fx_));
		return;
	}

	AddRef();	// protect ourselves from reentrant calls to Release().
	if(m_pConfAdvise)
	{
		hrLast = m_pConfAdvise->OnControlEvent(dwEvent, lpvData, this);
	}
	else
	{
		ERRORMESSAGE(("%s:Invalid m_pConfAdvise\r\n",_fx_));
	}
	
	Release();
}

VOID CH323Ctrl::GoNextPhase(CtlChanStateType phase)
{
	FX_ENTRY ("CH323Ctrl::GoNextPhase");
	BOOL fNotifyReady = FALSE;
	#define InvError() ERRORMESSAGE(("%s:Invalid transition from %d to %d\r\n",_fx_,m_Phase,phase))
	switch(phase)
	{
		case CCS_Idle:
			if(m_Phase != CCS_Idle && m_Phase != CCS_Disconnecting && m_Phase != CCS_Listening)
			{
				InvError();
			}
			else
			{
				m_ChanFlags &= ~(CTRLF_OPEN);
			}
		break;
		case CCS_Connecting:
			if((m_Phase != CCS_Idle) && (m_Phase != CCS_Ringing))
			{
				InvError();
			}
		break;
		case CCS_Accepting:
			if(m_Phase != CCS_Listening)
			{
				InvError();
			}
		
		break;
		case CCS_Ringing:
			// transition from CCS_Idle state is actually only valid if
			// there is an incoming call
			if(m_Phase != CCS_Connecting && m_Phase != CCS_Filtering && m_Phase != CCS_Listening)
			{
				InvError();
			}
		break;
		case CCS_Opening:
			if(m_Phase != CCS_Connecting && m_Phase != CCS_Accepting
				&& m_Phase != CCS_Ringing)
			{
				InvError();
			}
		break;
		case CCS_Closing:
			if(m_Phase != CCS_Opening && m_Phase != CCS_Ready && m_Phase != CCS_InUse)
			{
				InvError();
			}
		break;
		case CCS_Ready:
			// can be reentered. if notification is already pending, (state is
			// already CCS_InUse) stay there,  else do the transition
			if(m_Phase != CCS_InUse)
			{
				if(m_Phase != CCS_Opening)
				{
					InvError();
				}
				else
				{
					//signal "all channels ready" to IConfAdvise	
					fNotifyReady = TRUE;
				}
			}
			phase = CCS_InUse;
		break;
		case CCS_InUse:
			// previous state must be CCS_InUse or CCS_Ready
			if(m_Phase != CCS_InUse && m_Phase != CCS_Ready)
			{
				InvError();
			}
		
		break;
		case CCS_Listening:
			if(m_Phase != CCS_Idle)
			{
				InvError();
			}
		break;
		case CCS_Disconnecting:
			//if(m_Phase != CCS_Closing)
			//{
			//	InvError();
			//}
		break;

	}

	m_Phase = phase;

	if (fNotifyReady)
	{
		DoAdvise(CCEV_ALL_CHANNELS_READY, NULL);
	}
}


HRESULT CCConferenceCallback (BYTE bIndication,
	HRESULT	hConfStatus, CC_HCONFERENCE hConference, DWORD_PTR dwConferenceToken,
	PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams)
{
	HRESULT hr = CC_NOT_IMPLEMENTED;
	FX_ENTRY ("CCConferenceCallback ");
	CH323Ctrl *pConnection = (CH323Ctrl *)dwConferenceToken;

	if(IsBadWritePtr(pConnection, sizeof(CH323Ctrl)))
	{
		ERRORMESSAGE(("%s:invalid conf token: 0x%08lx\r\n",_fx_, dwConferenceToken));
		return CC_NOT_IMPLEMENTED;	// must be either CC_NOT_IMPLEMENTED or CC_OK.
	}
	
	if(pConnection && pConnection->GetConfHandle() == hConference)
	{

		if(pConnection->IsReleasing())
		{
			// we are in the cleanup path.  The object is being deleted without
			// waiting for asynchronous stuff to complete, and we called that one
			// final API (most likely Hangup()) that resulted in a callback.  Don't call
			// back into the object.
			DEBUGMSG(ZONE_CONN,("%s:callback while releasing:0x%08lx, hconf:0x%08lx\r\n",_fx_,
				pConnection, hConference));
			return hr;
		}	
		pConnection->AddRef();	// protect against Release()ing while not in
								// a quiescent state.  We do not want to be
								// released while inside ourself
		hr = pConnection->ConfCallback(bIndication, hConfStatus, pConferenceCallbackParams);
		pConnection->Release();
	}
	#ifdef DEBUG
	else
	{	
		if(pConnection)
			DEBUGMSG(ZONE_CONN,("%s:hConference mismatch, hConference:0x%08lx, object hconf:0x%08lx, pObject:0x%08lx\r\n",_fx_,
				hConference, pConnection->GetConfHandle(), pConnection));
		else
			DEBUGMSG(ZONE_CONN,("%s:null dwConferenceToken\r\n",_fx_));
	}
	#endif //DEBUG
	return hr;
}

VOID  CCListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams)
{
	FX_ENTRY ("CCListenCallback");
	CH323Ctrl *pConnection;
	if(!pListenCallbackParams)
	{
		return;
	}
	pConnection = (CH323Ctrl *)pListenCallbackParams->dwListenToken;

	if(IsBadWritePtr(pConnection, sizeof(CH323Ctrl)))
	{
		ERRORMESSAGE(("%s:invalid listen token: 0x%08lx\r\n",_fx_, pListenCallbackParams->dwListenToken));
		return;
	}

	// BUGBUG there's no hListen passed in - we can't validate it
	//	if(pConnection && (pConnection->GetListenHandle() == pListenCallbackParams->h??????))

	if(pConnection)
	{
		pConnection->AddRef();	// protect against Release()ing while not in
								// a quiescent state.  We do not want to be
								// released while inside ourself
		pConnection->ListenCallback(hStatus,pListenCallbackParams);
		pConnection->Release();
	}
	else
	{
		ERRORMESSAGE(("%s:null listen token\r\n",_fx_));
	}

}
VOID CH323Ctrl::ListenCallback (HRESULT hStatus,PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::ListenCallback");
	HRESULT hr;
	if(hStatus != CC_OK)
	{
		m_hCallCompleteCode = CCCI_LOCAL_ERROR;
		CH323Ctrl *	pAcceptingConnection = NULL;
		BOOL bDisconnect = FALSE;

		ERRORMESSAGE(("%s:error 0x%08lx\r\n",_fx_,hStatus));
		// aaaaghhh!!! an unsolicited error!!!!!
		// MikeV 10/12/96 - observed behavior is that this will occur if the caller disconnects
		// before the call is accepted (or during acceptance - if a BP is set before the call
		// to AcceptRejectConnection(), the caller times out.  But even after that, tracing
		// over AcceptRejectConnection() shown no error is returned. This is bad, because
		// it is hard to tell if this error needs cleaning up after.  The error code in
		// that case is 0xa085a001, which is CC_PEER_REJECT

		// We also don't know if another object has been created to accept the connection
		// or if this is being called in the context of the object that was created and
		// its handle passed to AcceptRejectConnection().  The typical behavior is that it
		// is called in the context of the listening object.

		// once the accepting object is located, need to check state to see if
		// connection is in the process of being accepted.  Find accepting object
		// by matching pListenCallbackParams->ConferenceID;	
		
		// see if this is the correct context
		if(memcmp(&pListenCallbackParams->ConferenceID, &m_ConferenceID, sizeof(m_ConferenceID))==0)
		{
			// check the current state.  If in the process of accepting
			// (either Idle, or filtering), change state to CCS_Closing to make
			// cleanup occur.  If already accepted (accepting or ringing), initiate
			// InternalDisconnect().  This should never happen in any other state.

			// EnterCriticalSection()	// LOOKLOOK - NYI
			switch(m_Phase)
			{
				case CCS_Idle:
				case CCS_Filtering:
				break;
				default:
				case CCS_Ringing:
				case CCS_Accepting:
					bDisconnect = TRUE;
					switch(hStatus)
					{
						case  CC_PEER_REJECT:
							m_hCallCompleteCode = CCCI_REJECTED;
							ERRORMESSAGE(("%s:Received CC_PEER_REJECT in state %d\r\n",_fx_,m_Phase));
						break;

						default:
						case  CC_INTERNAL_ERROR:
							m_hCallCompleteCode = CCCI_LOCAL_ERROR;
		 				break;
						
					}
				
				break;

			}
			// ExitCriticalSection()
			if(bDisconnect)
					InternalDisconnect();
		}
		else
		{
			hr = m_pConfAdvise->FindAcceptingObject((LPIControlChannel *)&pAcceptingConnection,
				&pListenCallbackParams->ConferenceID);
			if(HR_SUCCEEDED(hr) && pAcceptingConnection)
			{
				// call this function in the correct context
				pAcceptingConnection->AddRef();
				pAcceptingConnection->ListenCallback (hStatus, pListenCallbackParams);
				pAcceptingConnection->Release();
			}
			else
			{
					ERRORMESSAGE(("%s:conference ID 0x%08lx 0x%08lx 0x%08lx 0x%08lx\r\n"
						,_fx_,pListenCallbackParams->ConferenceID.buffer[0],
						pListenCallbackParams->ConferenceID.buffer[4],
						pListenCallbackParams->ConferenceID.buffer[8],
						pListenCallbackParams->ConferenceID.buffer[12]));
					ERRORMESSAGE(("%s:Received 0x%08lx in state %d, accepting object not found\r\n"
					,_fx_,hStatus, m_Phase));
			}
		}
		
		return;
	}
	// non error case falls out
	switch(pListenCallbackParams->wGoal)
	{
		default:
		case CC_GOAL_UNKNOWN:
		break;
		
		case CC_GOAL_CREATE:
		case CC_GOAL_JOIN:
		case CC_GOAL_INVITE:
			m_ConferenceID = pListenCallbackParams->ConferenceID;	
			m_hCall =  pListenCallbackParams->hCall;

			if(pListenCallbackParams->pCallerAliasNames || pListenCallbackParams->pszDisplay)
			{			
				NewRemoteUserInfo(pListenCallbackParams->pCallerAliasNames,
					pListenCallbackParams->pszDisplay);
			}
			else
			{
				ERRORMESSAGE(("%s:null pListenCallbackParams->pCallerAliasNames\r\n",_fx_));
			}
			
			if(!OnCallAccept(pListenCallbackParams))
			{
				ERRORMESSAGE(("ListenCallback:OnCallAccept failed\r\n"));
			}
						
		break;
	}
}


//
//  Main conference indication dispatcher
//
#ifdef DEBUG
TCHAR *i_strs[ ] =
{
"ERROR! - INDICATION ZERO",
"CC_RINGING_INDICATION",
"CC_CONNECT_INDICATION", 						
"CC_TX_CHANNEL_OPEN_INDICATION",				
"CC_RX_CHANNEL_REQUEST_INDICATION",			
"CC_RX_CHANNEL_CLOSE_INDICATION",		
"CC_MUTE_INDICATION",			
"CC_UNMUTE_INDICATION",						
"CC_PEER_ADD_INDICATION",						
"CC_PEER_DROP_INDICATION",						
"CC_PEER_CHANGE_CAP_INDICATION",
"CC_CONFERENCE_TERMINATION_INDICATION",
"CC_HANGUP_INDICATION",					
"CC_RX_NONSTANDARD_MESSAGE_INDICATION",
"CC_MULTIPOINT_INDICATION",	
"CC_PEER_UPDATE_INDICATION",				
"CC_H245_MISCELLANEOUS_COMMAND_INDICATION",
"CC_H245_MISCELLANEOUS_INDICATION_INDICATION",
"CC_H245_CONFERENCE_REQUEST_INDICATION",
"CC_H245_CONFERENCE_RESPONSE_INDICATION",
"CC_H245_CONFERENCE_COMMAND_INDICATION",	
"CC_H245_CONFERENCE_INDICATION_INDICATION",
"CC_FLOW_CONTROL_INDICATION",
"CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION",
"CC_REQUEST_MODE_INDICATION",	
"CC_REQUEST_MODE_RESPONSE_INDICATION",
"CC_VENDOR_ID_INDICATION",			
"CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION",
"CC_T120_CHANNEL_REQUEST_INDICATION",	
"CC_T120_CHANNEL_OPEN_INDICATION",			
"CC_BANDWIDTH_CHANGED_INDICATION",
"CC_ACCEPT_CHANNEL_INDICATION",
"CC_TERMINAL_ID_REQUEST_INDICATION",
"CC_PING_RESPONSE_INDICATION",
"CC_TERMINAL_NUMBER_INDICATION"
};
#endif	//DEBUG

HRESULT CH323Ctrl::ConfCallback (BYTE bIndication,
	HRESULT	hStatus, PCC_CONFERENCE_CALLBACK_PARAMS pConferenceCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::ConfCallback");
	HRESULT hr = CC_NOT_IMPLEMENTED;
	DEBUGMSG(ZONE_CONN,("%s: %s\r\n", _fx_, i_strs[bIndication]));

	SHOW_OBJ_ETIME(i_strs[bIndication]);

	switch (bIndication)
	{
		case CC_RINGING_INDICATION:
			// (PCC_RINGING_CALLBACK_PARAMS) pConferenceCallbackParams;
			// user info may be available now and it may not be
			OnCallRinging(hStatus, (PCC_RINGING_CALLBACK_PARAMS) pConferenceCallbackParams);
			
		break;
		case CC_CONNECT_INDICATION:
			OnCallConnect(hStatus, (PCC_CONNECT_CALLBACK_PARAMS) pConferenceCallbackParams);
			hr = CC_OK;
		break;
		case CC_PEER_ADD_INDICATION:
		case CC_PEER_UPDATE_INDICATION:
		case CC_PEER_DROP_INDICATION:
		case CC_TERMINAL_NUMBER_INDICATION:
		break;
		
		case CC_HANGUP_INDICATION:
			OnHangup(hStatus);
			hr = CC_OK;
		break;
		case CC_CONFERENCE_TERMINATION_INDICATION:
		// September 1996 comments:
		// I don't know if there will also be a CC_HANGUP_INDICATION after this.
		// We're going to call Hangup() via Disconnect()
		// December 1996: Hangup() (excuse me, CC_Hangup()) no longer gives back a
		// CC_HANGUP_INDICATION in this state.  It returns an error.  The new behavior
		// seems to indicate that the call control channel is already dead at this point
		// so, set our flags as such!!!
			m_ChanFlags &= ~(CTRLF_OPEN);
			//set state to indicate disconnecting.
			GoNextPhase(CCS_Disconnecting);
			DoAdvise(CCEV_REMOTE_DISCONNECTING ,NULL);
			GoNextPhase(CCS_Idle);	// no need to ck retval - we're disconnected
				// notify the UI or application code or whatever..
			DoAdvise(CCEV_DISCONNECTED ,NULL);
			hr = CC_OK;
		break;
		case CC_PEER_CHANGE_CAP_INDICATION:
		break;
		
		//
		// Channel stuff
		//
		case CC_TX_CHANNEL_OPEN_INDICATION:
			OnChannelOpen(hStatus,(PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;
		break;
		case CC_RX_CHANNEL_REQUEST_INDICATION:
			OnChannelRequest(hStatus, (PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;			
		break;
		
		// the following 4 channel-centric indications have the same basic parameter
		// structure.  When we get the final Intel drop, we can clean it up. 1 - collapse
		// the parameters into a common "channel indication" structure. 2 - make sure
		// that a user pointer is stored in that structure for easy finding of channel
		// context.  3 - collapse separate channel event handling functions into one.
		case CC_MUTE_INDICATION:
		    OnMute(hStatus, (PCC_MUTE_CALLBACK_PARAMS)pConferenceCallbackParams);
        	hr = CC_OK;	
		break;
		case CC_UNMUTE_INDICATION:
		    OnUnMute(hStatus, (PCC_UNMUTE_CALLBACK_PARAMS)pConferenceCallbackParams);
        	hr = CC_OK;	
		break;
		case CC_RX_CHANNEL_CLOSE_INDICATION:
			OnRxChannelClose(hStatus,(PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;
		break;
		case CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION:
			OnTxChannelClose(hStatus,(PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
			hr = CC_OK;
		// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
		//typedef struct {
		//	CC_HCHANNEL				hChannel;
		//} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;
		break;
		case CC_FLOW_CONTROL_INDICATION:
		// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
		// typedef struct {
		//		CC_HCHANNEL				hChannel;
		//		DWORD					dwRate;
		//	} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;
		break;	
		
		case CC_BANDWIDTH_CHANGED_INDICATION:
		case CC_REQUEST_MODE_INDICATION:
		case CC_REQUEST_MODE_RESPONSE_INDICATION:
		break;
		
		case CC_ACCEPT_CHANNEL_INDICATION:
			hr = CC_OK;	
			OnChannelAcceptComplete(hStatus, (PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		//
		//	Misc commands and indications.  Some are related to channels
		//
		case CC_RX_NONSTANDARD_MESSAGE_INDICATION:
		break;
		case CC_H245_MISCELLANEOUS_COMMAND_INDICATION:
			OnMiscCommand(hStatus,
				(PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		case CC_H245_MISCELLANEOUS_INDICATION_INDICATION: // from the Department of Redundancy Department
			OnMiscIndication(hStatus,
				(PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		case CC_T120_CHANNEL_REQUEST_INDICATION:
			OnT120ChannelRequest(hStatus,(PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS)pConferenceCallbackParams);
		break;
		case CC_T120_CHANNEL_OPEN_INDICATION:
			OnT120ChannelOpen(hStatus,(PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS)pConferenceCallbackParams);
		default:
		break;
	}
	return hr;

}


VOID CH323Ctrl::OnT120ChannelRequest(
	HRESULT hStatus,
	PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS pT120RequestParams)
{
	FX_ENTRY ("CH323Ctrl::OnT120ChannelRequest");
	PSOCKADDR_IN	pAddr;
	SOCKADDR_IN		sinD;
	CC_ADDR ChannelAddr;
	PCC_ADDR pChannelAddr;
	GUID mediaID;
	DWORD dwRejectReason = H245_REJ;
	BOOL bFound = FALSE;
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChannel = NULL;

	// look for a matching channel instance.
	while (pos)
	{
		pChannel = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChannel);

		hrLast = pChannel->GetMediaType(&mediaID);
		if(!HR_SUCCEEDED(hrLast))
			goto ERROR_EXIT;
		if(mediaID == MEDIA_TYPE_H323_T120)
		{
			bFound = TRUE;
			break;
		}
	}

	if(!HR_SUCCEEDED(hrLast) || !bFound)
	{
		// Non-default channels Not Yet Implemented!!!!
		// When it is, ask the parent conference object	to create another channel of the
		// specified media type.
		if(hrLast == CCO_E_NODEFAULT_CHANNEL)
			dwRejectReason = H245_REJ_TYPE_NOTAVAIL;

		goto REJECT_CHANNEL;
	}

	// if we are the H.245 master and have requested a T.120 channel already,
	// reject this request.
	if(m_ConferenceAttributes.bMaster && pChannel->GetHChannel())
	{
		goto REJECT_CHANNEL;
	}
	if(!pChannel->IsChannelEnabled())	//   allow this channel ?
	{
		goto REJECT_CHANNEL;
	}

	pChannel->SetHChannel(pT120RequestParams->hChannel);
	if(pT120RequestParams->pAddr)
	{
		// the other end is listening on the specified address
		sinD.sin_family = AF_INET;
		sinD.sin_addr.S_un.S_addr = htonl(pT120RequestParams->pAddr->Addr.IP_Binary.dwAddr);
		sinD.sin_port = htons(pT120RequestParams->pAddr->Addr.IP_Binary.wPort);
		
		DEBUGMSG(ZONE_CONN,("%s, requestor listening on port 0x%04x, address 0x%08lX\r\n",_fx_,
			pT120RequestParams->pAddr->Addr.IP_Binary.wPort,
			pT120RequestParams->pAddr->Addr.IP_Binary.dwAddr));

		hrLast = pChannel->AcceptRemoteAddress(&sinD);
		pChannelAddr = NULL;
	}
	else
	{
		// the channel selects its local address(es)/port(s)
		if(!pChannel->SelectPorts((LPIControlChannel)this))
		{
			ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
			hrLast = CCO_E_BAD_ADDRESS;
			goto REJECT_CHANNEL;
		}
		// get the address and ports of our end of the channel
		pAddr = pChannel->GetLocalAddress();
		// fixup channel addr pair structure.
		ChannelAddr.nAddrType = CC_IP_BINARY;
		ChannelAddr.bMulticast = FALSE;
		ChannelAddr.Addr.IP_Binary.wPort = ntohs(pAddr->sin_port);
		ChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);
		pChannelAddr = &ChannelAddr;
		DEBUGMSG(ZONE_CONN,("%s: accepting on port 0x%04x, address 0x%08lX\r\n",_fx_,
			ChannelAddr.Addr.IP_Binary.wPort,ChannelAddr.Addr.IP_Binary.dwAddr));
	}
	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest accepting");

	hrLast = CC_AcceptT120Channel(
		pChannel->GetHChannel(),
		FALSE,	// BOOL bAssociateConference,
		NULL, 	// PCC_OCTETSTRING					pExternalReference,
		pChannelAddr);

	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s, CC_AcceptT120Channel returned 0x%08lX\r\n",_fx_, hrLast));
		goto ERROR_EXIT;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest accepted");

	// LOOKLOOK !!! the 2 following lines would not be there because we should
	// Wait for CC_ACCEPT_CHANNEL_INDICATION.  But the CC_ACCEPT_CHANNEL_INDICATION
	// is missing if a send audio and send video channel is open at the time this
	// channel is accepted.  A bug in CALLCONT.DLL that needs investigating.
	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest, open done");

	// ******	
	// LOOKLOOK if OnChannelOpen returns an error, need to close the channel
	// but pChannel->Close() is not yet implemented for bidirectional channels	
	// ******
	
	m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_BIDI, pChannel, this);			
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );	//
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelRequest done");

	return;

REJECT_CHANNEL:	
	{
	// need private HRESULT! don't overwrite the reason we're rejecting the channel!!	
		HRESULT hr;	
		ERRORMESSAGE(("%s, rejecting channel\r\n",_fx_));
	
		hr = CC_RejectChannel(pT120RequestParams->hChannel, dwRejectReason);
		if(hr != CC_OK)
		{
			ERRORMESSAGE(("%s, CC_RejectChannel returned 0x%08lX\r\n",_fx_, hr));
		}
	}	
ERROR_EXIT:
	return;
}

VOID CH323Ctrl::OnT120ChannelOpen(
	HRESULT hStatus,
	PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS pT120OpenParams)
{
	FX_ENTRY ("CH323Ctrl::OnT120ChannelOpen");
	SOCKADDR_IN sinD;
	GUID mediaID;
	ICtrlCommChan *pChannel = (ICtrlCommChan *)pT120OpenParams->dwUserToken;	
	// validate channel token - is this what we think it is?
	if(IsBadWritePtr(pChannel, sizeof(ICtrlCommChan)))
	{
		ERRORMESSAGE(("%s:invalid channel token: 0x%08lx\r\n",_fx_, pT120OpenParams->dwUserToken));
		return;
	}

#ifdef DEBUG
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChan;
	BOOL bValid = FALSE;
	// look for a matching channel instance.
	while (pos)
	{
		pChan = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChan);
		if(pChan == pChannel)
		{
			bValid = TRUE;
			break;
		}
	}
	if(!bValid)
	{
		ERRORMESSAGE(("%s:unrecognized token 0x%08lX\r\n",_fx_,
			pT120OpenParams->dwUserToken));
		return;
	}
#endif	//DEBUG

	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen");
	
	if(hStatus != CC_OK)
	{
		DEBUGMSG(ZONE_CONN,("%s: hStatus:0x%08lX\r\n",_fx_,hStatus));
		// LOOKLOOK need to interpret hStatus
		// let the channel know what happened.

		// if the request was rejected due to a collision of T.120 O.L.C. requests,
		// (other end is the master and other end also requested a T.120 channel)
		// then proceed with the call.

		if(m_ConferenceAttributes.bMaster)
		{
			// the slave would only reject in a real error condition
			pChannel->OnChannelOpen(CHANNEL_REJECTED);	
			// the channel knows what happened, so let it do the worrying.
			return;

		}
		else	// just a typical collision
		{
			return;
		}
	}
	// if the other end specified its listen address, use it
	if(pT120OpenParams->pAddr)
	{
		if(pT120OpenParams->pAddr->nAddrType != CC_IP_BINARY)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,
					pT120OpenParams->pAddr->nAddrType));
			goto ERROR_EXIT;
		}	
		
		// we now have the remote port info ( in host byte order)
		sinD.sin_family = AF_INET;
		sinD.sin_addr.S_un.S_addr = htonl(pT120OpenParams->pAddr->Addr.IP_Binary.dwAddr);
		sinD.sin_port = htons(pT120OpenParams->pAddr->Addr.IP_Binary.wPort);
		
		DEBUGMSG(ZONE_CONN,("%s, opened on port 0x%04x, address 0x%08lX\r\n",_fx_,
			pT120OpenParams->pAddr->Addr.IP_Binary.wPort,pT120OpenParams->pAddr->Addr.IP_Binary.dwAddr));

		hrLast = pChannel->AcceptRemoteAddress(&sinD);
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:AcceptRemoteAddress failed\r\n",_fx_));
			goto ERROR_EXIT;
		}
	}
	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen opening");

	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("%s:channel's OnChannelOpen() returned 0x%08lX\r\n", _fx_, hrLast));
		CloseChannel(pChannel);
		goto ERROR_EXIT;
	}

	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen open done");
	
	m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_BIDI, pChannel, this);	
	
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );	
	SHOW_OBJ_ETIME("CH323Ctrl::OnT120ChannelOpen done");
	return;
	
ERROR_EXIT:
	// need to cleanup, disconnect, etc.
	m_hCallCompleteCode = CCCI_CHANNEL_OPEN_ERROR;
	// let the parent Conference object know about the imminent disconnect
	DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
	hrLast = CCO_E_MANDATORY_CHAN_OPEN_FAILED;

	InternalDisconnect();
	return;

}

//
//	This once did something. Currently, it's called whenever a channel is opened.  The
//  call to GoNextPhase(CCS_Ready) changes state and posts a notification upward, but
//  that notification is currently ignored.  (it's useless)
//  Reminder to mikev: A new notification is needed to indicate that capabilities
//  have been exchanged and it is OK to open channels.
//
VOID CH323Ctrl::CheckChannelsReady()
{
	GoNextPhase(CCS_Ready);
}
// handles local hangup indication
VOID CH323Ctrl::OnHangup(HRESULT hStatus)
{
	FX_ENTRY ("CH323Ctrl::OnHangup");
	DEBUGMSG(ZONE_CONN,("%s:CC_HANGUP_INDICATION in phase %d\r\n", _fx_, m_Phase));
	switch(m_Phase)
	{
		case CCS_Disconnecting:
			GoNextPhase(CCS_Idle);
			Cleanup();
			DoAdvise(CCEV_DISCONNECTED ,NULL);
		break;
		
		default: // do nothing
			ERRORMESSAGE(("%s:Unexpected CC_HANGUP_INDICATION\r\n",_fx_));
		break;
	}
}

HRESULT CH323Ctrl::CloseChannel(ICtrlCommChan* pChannel)
{
	FX_ENTRY ("CH323Ctrl::CloseChannel");
	if(!pChannel->IsChannelOpen())
	{
		ERRORMESSAGE(("%s: channel is not open\r\n",_fx_));
		hrLast = CCO_E_INVALID_PARAM;
		goto EXIT;
	}

	hrLast = CC_CloseChannel(pChannel->GetHChannel());
	if(!HR_SUCCEEDED(hrLast))
	{	
		ERRORMESSAGE(("%s: CC_CloseChannel returned 0x%08lX\r\n",_fx_, hrLast));
		goto EXIT;
	}
	// make the channel handle its own media stream specific shutdown and cleanup chores
	hrLast = pChannel->OnChannelClose(CHANNEL_CLOSED);	
	
EXIT:
	return hrLast;
}

HRESULT CH323Ctrl::AddChannel(ICtrlCommChan * pCommChannel, LPIH323PubCap pCapabilityResolver)
{
	ICtrlCommChan *pChan = NULL;


	// get the ICtrlCommChannel interface of each channel
	hrLast = pCommChannel->QueryInterface(IID_ICtrlCommChannel,(void **)&pChan);
	if(!HR_SUCCEEDED(hrLast))
		goto ADD_ERROR;
	
	// make the channel aware of its new scope
	hrLast = pChan->BeginControlSession(this, pCapabilityResolver);
	if(!HR_SUCCEEDED(hrLast))
		goto ADD_ERROR;
	// add it to the list			
	m_ChannelList.AddTail(pChan);
	return hrSuccess;

ADD_ERROR:
	if(pChan)
		pChan->Release();
	return CHAN_E_INVALID_PARAM;

}



HRESULT CH323Ctrl::OpenChannel(ICtrlCommChan* pChan, IH323PubCap *pCapResolver,
	MEDIA_FORMAT_ID dwIDLocalSend, MEDIA_FORMAT_ID dwIDRemoteRecv)
{
	FX_ENTRY ("CH323Ctrl::OpenChannel");
	CC_TERMCAP				H245ChannelCap;
	PSOCKADDR_IN			pAddr;
	CC_ADDR 				ChannelAddr;
	LPVOID pChannelParams;
	PCC_TERMCAP pSaveChannelCapability = NULL;
	UINT uLocalParamSize;
	BYTE SessionID;
	BYTE payload_type;
	DWORD_PTR dwhChannel;
	GUID mediaID;

	ASSERT((pChan->IsChannelOpen()== FALSE) && (pChan->IsOpenPending()== FALSE));
	hrLast = pChan->GetMediaType(&mediaID);
	if(!HR_SUCCEEDED(hrLast))
		goto CHANNEL_ERROR;
		
	if (mediaID == MEDIA_TYPE_H323_T120)
	{
		if(pChan->GetHChannel())	// already accepted a T.120 channel?
		{
			ERRORMESSAGE(("%s, already have a pending channel\r\n",_fx_));
			goto CHANNEL_ERROR;	// this is not an error, excuse the label
		}

		// test the no common capability case.  notify the conference object of the
		// inability to open the channel, and return success
		
		if(dwIDLocalSend == INVALID_MEDIA_FORMAT)
		{
			pChan->OnChannelOpen(CHANNEL_NO_CAPABILITY);
			return hrSuccess;
		}
		// There is no "standard" rule regarding which end specifies the "listen"
		// address of a T.120 channel. However: we want NetMeeting-NetMeeting calls
		// to behave consistently (the "caller" always "places the T.120 call").
		// Therefore, specify the address if this end is not the originator.  That will
		// force the other end to specify it's address.
		
		if(IsOriginating(m_ChanFlags))
		{
			pAddr = NULL;	// the other end "listens" and we "connect"
		}
		else	// listen on local address
		{
			// select ports if they are not already selected
			if(!pChan->SelectPorts((LPIControlChannel)this))
			{
				ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
				hrLast = CCO_E_BAD_ADDRESS;
				goto CHANNEL_ERROR;
			}
			
			// get the address and port
			pAddr = pChan->GetLocalAddress();
			// fixup channel addr structure.
			ChannelAddr.nAddrType = CC_IP_BINARY;
			ChannelAddr.bMulticast = FALSE;
			ChannelAddr.Addr.IP_Binary.wPort = ntohs(pAddr->sin_port);
			ChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);
		}

		hrLast =  CC_OpenT120Channel(
			// CC_HCONFERENCE	hConference,
			m_hConference,
	        // PCC_HCHANNEL     phChannel,
	        &dwhChannel,
			// BOOL				bAssociateConference,
			FALSE,
			// PCC_OCTETSTRING	pExternalReference,
			NULL,
			// PCC_ADDR			pAddr,
			IsOriginating(m_ChanFlags) ? NULL : &ChannelAddr,
			// DWORD			dwChannelBitRate,
			0,
			// DWORD			dwUserToken);
			(DWORD_PTR)pChan);

		// and fall out to test hrLast, etc.
	}
	else	// is an audio or video channel
	{
		// test the no common capability case.  If the channel is mandatory,
		// return an error, else notify the conference object of the
		// inability to open the channel, and return success
		
		if((dwIDLocalSend == INVALID_MEDIA_FORMAT) ||(dwIDRemoteRecv == INVALID_MEDIA_FORMAT))
		{
			pChan->OnChannelOpen(CHANNEL_NO_CAPABILITY);
			return hrSuccess;
		}
				
		//
		//   test if we need to try to open this !!!
		//
		if(!pChan->IsChannelEnabled())
		{
			return hrSuccess;
		}
		
		SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel");
			
		// Get the remote channel parameters for
		// the send channel -  these parameters are used to request a channel
		uLocalParamSize = pCapResolver->GetLocalSendParamSize((MEDIA_FORMAT_ID)dwIDLocalSend);
		pChannelParams=MemAlloc (uLocalParamSize);
		if (pChannelParams == NULL) {
		   //Doom
		   hrLast = CCO_E_SYSTEM_ERROR;
		   goto CHANNEL_ERROR;
		}
		hrLast = pCapResolver->GetEncodeParams(
				(LPVOID)&H245ChannelCap, sizeof(H245ChannelCap),
				(LPVOID)pChannelParams, uLocalParamSize,
				(AUDIO_FORMAT_ID)dwIDRemoteRecv,
				(AUDIO_FORMAT_ID)dwIDLocalSend);
	 	if(!HR_SUCCEEDED(hrLast))
		{	
			ERRORMESSAGE(("%s: GetEncodeParams returned 0x%08lX\r\n",_fx_, hrLast));
			goto CHANNEL_ERROR;
		}

		// set session ID and payload type.  Note that payload type is relevant only for
		// dynamic payloads.  Otherwise, it must be zero.
		if (H245ChannelCap.DataType == H245_DATA_AUDIO)
		{
			payload_type = ((PAUDIO_CHANNEL_PARAMETERS)pChannelParams)->RTP_Payload;
			// Session ID is 1 for Audio, 2 for Video . H245 7.3.1 (H2250 Logical Channel Param)
		   	SessionID=1;
		}
		else if (H245ChannelCap.DataType == H245_DATA_VIDEO)
		{
			payload_type = ((PVIDEO_CHANNEL_PARAMETERS)pChannelParams)->RTP_Payload;
		 	SessionID=2;
		}
		// payload_type must be zero for fixed payload types.  Weird.
		if(!IsDynamicPayload(payload_type))
			payload_type = 0;
			
		// create a marshalled version of channel parameters and store it in the channel
		// for later reference
		if(H245ChannelCap.ClientType == H245_CLIENT_AUD_NONSTD)
		{
			// Make a flat copy of the nonstandard capability to store as the channel
			// parameter
			UINT uSize = H245ChannelCap.Cap.H245Aud_NONSTD.data.length;
			pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
			if(!pSaveChannelCapability)
			{
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}	
			// copy fixed part
			memcpy(pSaveChannelCapability, &H245ChannelCap, sizeof(CC_TERMCAP));
			// variable part follows the fixed part
			pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value	
				= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
			// copy variable part
			memcpy(pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value,
				H245ChannelCap.Cap.H245Aud_NONSTD.data.value,
				H245ChannelCap.Cap.H245Aud_NONSTD.data.length);
			// and length
			pSaveChannelCapability->Cap.H245Aud_NONSTD.data.length
				= H245ChannelCap.Cap.H245Aud_NONSTD.data.length;
			
			// make the channel remember the channel parameters.
			// a zero size as the second arg means that a preallocated chunk is being passed
			hrLast = pChan->ConfigureCapability(pSaveChannelCapability, 0,
				pChannelParams, uLocalParamSize);	
			if(!HR_SUCCEEDED(hrLast))
			{
				ERRORMESSAGE(("%s:ConfigureCapability returned 0x%08lx\r\n",_fx_, hrLast));
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}
			pSaveChannelCapability=NULL;  // the channel owns this memory now
		}
		else if(H245ChannelCap.ClientType == H245_CLIENT_VID_NONSTD)
		{
			// Make a flat copy of the nonstandard capability to store as the channel
			// parameter
			UINT uSize = H245ChannelCap.Cap.H245Vid_NONSTD.data.length;
			pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
			if(!pSaveChannelCapability)
			{
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}	
			// copy fixed part
			memcpy(pSaveChannelCapability, &H245ChannelCap, sizeof(CC_TERMCAP));
			// variable part follows the fixed part
			pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value	
				= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
			// copy variable part
			memcpy(pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value,
				H245ChannelCap.Cap.H245Vid_NONSTD.data.value,
				H245ChannelCap.Cap.H245Vid_NONSTD.data.length);
			// and length
			pSaveChannelCapability->Cap.H245Vid_NONSTD.data.length
				= H245ChannelCap.Cap.H245Vid_NONSTD.data.length;
			
			// make the channel remember the channel parameters.
			// a zero size as the second arg means that a preallocated chunk is being passed
			hrLast = pChan->ConfigureCapability(pSaveChannelCapability, 0,
				pChannelParams, uLocalParamSize);	
			if(!HR_SUCCEEDED(hrLast))
			{
				ERRORMESSAGE(("%s:ConfigureCapability returned 0x%08lx\r\n",_fx_, hrLast));
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}
			pSaveChannelCapability=NULL;  // the channel owns this memory now
		}
		else
		{
			// only need to remember the already-flat H.245 cap structure.
			hrLast = pChan->ConfigureCapability(&H245ChannelCap, sizeof(CC_TERMCAP),
				pChannelParams, uLocalParamSize);	
			if(!HR_SUCCEEDED(hrLast))
			{
				ERRORMESSAGE(("%s:ConfigureCapability returned 0x%08lx\r\n",_fx_, hrLast));
				hrLast = CCO_E_SYSTEM_ERROR;
				goto CHANNEL_ERROR;
			}
		}

		// remember both versions of the resolved send format for the channel
		// we're about to open	
		pChan->SetNegotiatedLocalFormat(dwIDLocalSend);	
		pChan->SetNegotiatedRemoteFormat(dwIDRemoteRecv);
		
		SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel done configuring");

		// select ports if they are not already selected
		if(!pChan->SelectPorts((LPIControlChannel)this))
		{
			ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
			hrLast = CCO_E_BAD_ADDRESS;
			goto CHANNEL_ERROR;
		}
		
		// get the address and port of our RTCP channel
		pAddr = pChan->GetLocalAddress();
		// fixup channel addr structure. There are two ports, but in RTP, it is implicit
		// that the RTCP control port is the next highest port number.
		// The open logical channel request needs the reverse RTCP port to be specified.
		ChannelAddr.nAddrType = CC_IP_BINARY;
		ChannelAddr.bMulticast = FALSE;
		ChannelAddr.Addr.IP_Binary.wPort = pChan->GetLocalRTCPPort();
		ChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);

		DEBUGMSG(ZONE_CONN,("%s: opening using RTCP port 0x%04x, address 0x%08lX\r\n",_fx_,
			ChannelAddr.Addr.IP_Binary.wPort,ChannelAddr.Addr.IP_Binary.dwAddr));
		
		DEBUGMSG(ZONE_CONN,("%s: requesting capability ID:0x%08lX\r\n",
			_fx_, H245ChannelCap.CapId));

		// open a channel
		SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel, opening");
											
		hrLast = CC_OpenChannel(m_hConference, &dwhChannel,
			SessionID,
			0,  //	BYTE bAssociatedSessionID,
			TRUE, //BOOL bSilenceSuppression,  WE ALWAYS DO SILENCE SUPPRESSION
			&H245ChannelCap,	
			&ChannelAddr, 	// the local address on which we're listening for RTCP
			payload_type,	// PAYLOAD TYPE
			0,				//	DWORD dwChannelBitRate,
			(DWORD_PTR)pChan);	// use the channel pointer as the user token
	} // end else is an audio or video channel
	
	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s: OpenChannel returned 0x%08lX\r\n",_fx_, hrLast));
		goto CHANNEL_ERROR;
	}		
	else
	{
		pChan->SetHChannel(dwhChannel);
		pChan->OnChannelOpening();
	}

	SHOW_OBJ_ETIME("CH323Ctrl::OpenChannel done");
	return hrLast;

CHANNEL_ERROR:
	if(pSaveChannelCapability)
		MemFree(pSaveChannelCapability);
		
	return hrLast;
}


VOID CH323Ctrl::CleanupConferenceAttributes()
{
	WORD w;
	if(m_ConferenceAttributes.pParticipantList->ParticipantInfoArray)
	{
		for(w=0;w<m_ConferenceAttributes.pParticipantList->wLength;w++)
		{	
			if(m_ConferenceAttributes.pParticipantList->
				ParticipantInfoArray[w].TerminalID.pOctetString)
			{
				MemFree(m_ConferenceAttributes.pParticipantList->
					ParticipantInfoArray[w].TerminalID.pOctetString);
			}

		}
		
		MemFree(m_ConferenceAttributes.pParticipantList->ParticipantInfoArray);
	}
	m_ConferenceAttributes.pParticipantList->ParticipantInfoArray = NULL;
	m_ConferenceAttributes.pParticipantList->wLength = 0;
	
}	

HRESULT CH323Ctrl::AllocConferenceAttributes()
{
	WORD w;
	#define MAX_PART_LEN 128
	if(m_ConferenceAttributes.pParticipantList->wLength)
	{
		m_ConferenceAttributes.pParticipantList->ParticipantInfoArray =
			(PCC_PARTICIPANTINFO) MemAlloc (sizeof(CC_PARTICIPANTINFO)
				* m_ConferenceAttributes.pParticipantList->wLength);
				
		if(!m_ConferenceAttributes.pParticipantList->ParticipantInfoArray)
			return CCO_E_OUT_OF_MEMORY;
			
		for(w=0;w<m_ConferenceAttributes.pParticipantList->wLength;w++)
		{	
			m_ConferenceAttributes.pParticipantList->
				ParticipantInfoArray[w].TerminalID.pOctetString
				= (BYTE *)MemAlloc(MAX_PART_LEN);
			if(m_ConferenceAttributes.pParticipantList->
				ParticipantInfoArray[w].TerminalID.pOctetString)
			{
				m_ConferenceAttributes.pParticipantList->
					ParticipantInfoArray[w].TerminalID.wOctetStringLength
					= MAX_PART_LEN;
			}
			else
			{
				m_ConferenceAttributes.pParticipantList->
					ParticipantInfoArray[w].TerminalID.wOctetStringLength =0;
				return CCO_E_OUT_OF_MEMORY;
			}
		}
	}
	return hrSuccess;
}

VOID CH323Ctrl::OnCallConnect(HRESULT hStatus, PCC_CONNECT_CALLBACK_PARAMS pConfParams)
{
	FX_ENTRY ("CH323Ctrl::OnCallConnect");
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	CC_TERMCAP				H245ChannelCap;
	PCC_TERMCAP 			pChannelCap = NULL;
	CapsCtl *pCapabilityResolver = NULL;
	GUID mediaID;
	POSITION pos = NULL;
	ICtrlCommChan *pChan = NULL;

	if(hStatus != CC_OK)
	{
		ERRORMESSAGE(("%s hStatus=0x%08lx in phase %d\r\n",_fx_,hStatus,m_Phase));

		// test for gatekeeper admission reject
		// FACILITY_GKIADMISSION
		if(CUSTOM_FACILITY(hStatus) == FACILITY_GKIADMISSION)
		{
			// pass this code intact - do not remap
			m_hCallCompleteCode = hStatus;
		}
		else
		{
			switch (hStatus)
			{
				default:
				// reason is unknown
					m_hCallCompleteCode = CCCI_UNKNOWN;
				break;
				case  CC_PEER_REJECT:
					if(m_Phase == CCS_Connecting)
					{
						switch(pConfParams->bRejectReason)
						{
							case CC_REJECT_ADAPTIVE_BUSY:
							case CC_REJECT_IN_CONF:
							case CC_REJECT_USER_BUSY:
								m_hCallCompleteCode = CCCI_BUSY;
							break;
							case CC_REJECT_SECURITY_DENIED:
								m_hCallCompleteCode = CCCI_SECURITY_DENIED;
							break;
							case CC_REJECT_NO_ANSWER:
							case CC_REJECT_TIMER_EXPIRED:
								m_hCallCompleteCode = CCCI_NO_ANSWER_TIMEOUT;
							break;
							case CC_REJECT_GATEKEEPER_RESOURCES:
								m_hCallCompleteCode = CCCI_GK_NO_RESOURCES;
							break;
							default:
								//#define CC_REJECT_NO_BANDWIDTH              1
								//#define CC_REJECT_GATEKEEPER_RESOURCES      2
								//#define CC_REJECT_UNREACHABLE_DESTINATION   3
								//#define CC_REJECT_DESTINATION_REJECTION     4
								//#define CC_REJECT_INVALID_REVISION          5
								//#define CC_REJECT_NO_PERMISSION             6
								//#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
								//#define CC_REJECT_GATEWAY_RESOURCES         8
								//#define CC_REJECT_BAD_FORMAT_ADDRESS        9
								//#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
	// would be nice to handle this -->> //#define CC_REJECT_CALL_FORWARDED            13
								//#define CC_REJECT_ROUTE_TO_MC               14
								//#define CC_REJECT_UNDEFINED_REASON          15
								//#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
								//#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
								//#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
								//#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
								//#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
								//#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
								//#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call

								m_hCallCompleteCode = CCCI_REJECTED;
							break;
						}
					}
					else
					{
						ERRORMESSAGE(("%s:Received CC_PEER_REJECT in state %d\r\n",_fx_,m_Phase));
					}
				break;
				case  CC_INTERNAL_ERROR:
					m_hCallCompleteCode = CCCI_LOCAL_ERROR;
				break;

			}
		}
		// let the parent Conference object know  (unless this is the answering end)
		if(m_Phase == CCS_Connecting)
		{
			DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
		}

		InternalDisconnect();
		return;
	}
	else if(!pConfParams)
	{
		ERRORMESSAGE(("OnCallConnect: null pConfParams\r\n"));
		m_hCallCompleteCode = CCCI_LOCAL_ERROR;
		DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
		InternalDisconnect();
		return;
	}
	
    SetRemoteVendorID(pConfParams->pVendorInfo);

	GoNextPhase(CCS_Opening);
	m_ChanFlags |= (CTRLF_OPEN);
	DEBUGMSG(ZONE_CONN,("%s:CONNECTION_CONNECTED\r\n", _fx_));
	if((!pConfParams->pLocalAddr) || (pConfParams->pLocalAddr->nAddrType != CC_IP_BINARY))
	{
		if(pConfParams->pLocalAddr)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,pConfParams->pLocalAddr->nAddrType));
		}
		else
		{
			ERRORMESSAGE(("%s: null local address\r\n",_fx_));
		}
	
		ERRORMESSAGE(("%s:where's the local address????\r\n",_fx_));
					PHOSTENT phe;
					PSOCKADDR_IN psin;
				 	char szTemp[200];
					LPCSTR lpHostName;		
					gethostname(szTemp,sizeof(szTemp));
			    	lpHostName = szTemp;
					psin = &local_sin;
					phe = gethostbyname(lpHostName);
					if (phe != NULL)
					{
				   		memcpy((char FAR *)&(psin->sin_addr), phe->h_addr,phe->h_length);
						psin->sin_family = AF_INET;
					}
		
	}	
	else
	{
		// remember our local address
		local_sin.sin_family = AF_INET;
		// in host byte order
		local_sin.sin_addr.S_un.S_addr = htonl(pConfParams->pLocalAddr->Addr.IP_Binary.dwAddr);
		// in host byte order
		local_sin.sin_port = htons(pConfParams->pLocalAddr->Addr.IP_Binary.wPort);
	}
	DEBUGMSG(ZONE_CONN,("%s local port 0x%04x, address 0x%08lX\r\n",_fx_,
	local_sin.sin_port,local_sin.sin_addr.S_un.S_addr));	
	
	// get remote address
	if((!pConfParams->pPeerAddr) || (pConfParams->pPeerAddr->nAddrType != CC_IP_BINARY))
	{
		if(pConfParams->pPeerAddr)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,pConfParams->pPeerAddr->nAddrType));
		}
		else
		{
			ERRORMESSAGE(("%s: null local address\r\n",_fx_));
		}	
	}
	else
	{
		// remember the remote peer address
		remote_sin.sin_family = AF_INET;
		// in host byte order
		remote_sin.sin_addr.S_un.S_addr = htonl(pConfParams->pPeerAddr->Addr.IP_Binary.dwAddr);
		// in host byte order
		remote_sin.sin_port = htons(pConfParams->pPeerAddr->Addr.IP_Binary.wPort);
	}
//
// The only available remote user information in this state is the Q.931 display name.
// If we are the callee, we got the caller alias name (wire format was unicode) in
// the listen callback parameters.  If we are the caller, we really need the callee
// alias name(s), which are not propagated.   Fallback to the Q.931 display name (ASCII)
//

	NewRemoteUserInfo(NULL, pConfParams->pszPeerDisplay);

	// release any stale memory, reset ConferenceAttributes struture
	CleanupConferenceAttributes();
	// get the number of conference participants etc.
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect getting attribs 1");

	hrLast = CC_GetConferenceAttributes(m_hConference, &m_ConferenceAttributes);
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,CC_GetConferenceAttributes returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;

	}
	hrLast = AllocConferenceAttributes();
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,AllocConferenceAttributes returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;

	}
	// now get the real attributes
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect getting attribs 2");
	hrLast = CC_GetConferenceAttributes(m_hConference, &m_ConferenceAttributes);
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,CC_GetConferenceAttributes returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;

	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect got attribs");
	
	m_ConferenceID =m_ConferenceAttributes.ConferenceID;
	m_bMultipointController = m_ConferenceAttributes.bMultipointController;

	hrLast = m_pConfAdvise->GetCapResolver((LPVOID *)&pCapabilityResolver, OID_CAP_ACM_TO_H323);
	if(!HR_SUCCEEDED(hrLast) || (pCapabilityResolver == NULL))
	{// fatal error
		ERRORMESSAGE(("%s,null resolver\r\n", _fx_));
		goto CONNECT_ERROR;

	}
		
	// get the remote capabilities
	// cache the remote capabilities now
	pTermCapList = pConfParams->pTermCapList;
	pTermCapDescriptors = pConfParams->pTermCapDescriptors;
	hrLast = pCapabilityResolver->AddRemoteDecodeCaps(pTermCapList, pTermCapDescriptors, &m_RemoteVendorInfo);
	if(!HR_SUCCEEDED(hrLast))
	{// fatal error
		ERRORMESSAGE(("%s,AddRemoteDecodeCaps returned 0x%08lX\r\n", _fx_, hrLast));
		goto CONNECT_ERROR;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect saved caps");
	DoAdvise(CCEV_CAPABILITIES_READY, NULL);	// put connobj in a state to allow other
												// channels to be added & opened
	//	
	//	 notify UI here.  It wants remote user info.
	//
	ConnectNotify(CCEV_CONNECTED);	
	SHOW_OBJ_ETIME("CH323Ctrl::OnCallConnect notified");
	return;

CONNECT_ERROR:
	// release all channels
	ReleaseAllChannels();
	InternalDisconnect();
}

// LOOKLOOK methinks ConnectNotify might need to propagate the conference ID.
// This will be a moot point if we have a real property interface.  Watch
// for this in the meantime
VOID CH323Ctrl::ConnectNotify(DWORD dwEvent)		
{
	FX_ENTRY ("CH323Ctrl::ConnectNotify");
	CTRL_USER_INFO UserInfo;
	LPWSTR lpwstr = NULL;
	WCHAR wc =0;

	// init to zero in case of error
	UserInfo.dwCallerIDSize = 0;
	UserInfo.lpvCallerIDData = NULL;
	UserInfo.lpvRemoteProtocolInfo = NULL;	
	UserInfo.lpvLocalProtocolInfo = NULL;

	// alias address strings, e.g. caller ID, are in UNICODE
	if(	m_pRemoteAliasItem &&
		m_pRemoteAliasItem->pData &&
		*((LPWSTR*)(m_pRemoteAliasItem->pData)))
	{
		lpwstr =(LPWSTR)m_pRemoteAliasItem->pData;
	}
	else
	{
		lpwstr = pwszPeerDisplayName;
	}

	if(lpwstr)
	{
		if(pwszPeerAliasName)
		{
			MemFree(pwszPeerAliasName);
		}
		ULONG ulSize = (lstrlenW(lpwstr) + 1) * sizeof(WCHAR);
		pwszPeerAliasName = (LPWSTR)MemAlloc(ulSize);
		LStrCpyW(pwszPeerAliasName, lpwstr);
		// point to user name stuff
		UserInfo.dwCallerIDSize = ulSize;
		UserInfo.lpvCallerIDData = (LPVOID)pwszPeerAliasName;
	}
	else
	{
		// point to the single NULL character on the stack
		UserInfo.dwCallerIDSize = 1;
		UserInfo.lpvCallerIDData = &wc;
	}
	DoAdvise(dwEvent, &UserInfo);
}		


	
VOID CH323Ctrl::NewRemoteUserInfo(PCC_ALIASNAMES pRemoteAliasNames,
		LPWSTR pwszRemotePeerDisplayName)
{
	FX_ENTRY ("CH323Ctrl::NewRemoteUserInfo");
	ULONG ulSize;
	PCC_ALIASITEM pItem;
	WORD wC;
	// make a copy of the user display name (what else???)  We need to hold this
	// at least until the parent object is notified and has a chance to copy the
	// information

	// Future implementation will store each item as a distinct property.
	// These will be accessable via the IProperty interface
	
	// find the display name if it exists
	if(pRemoteAliasNames)
	{
		wC = pRemoteAliasNames->wCount;
		pItem = pRemoteAliasNames->pItems;
		while (wC--)
		{
			if(!pItem)
			{
				continue;
			}
			if(pItem->wType == CC_ALIAS_H323_ID)
			{
				if(!pItem->wDataLength  || !pItem->pData)
				{
					continue;
				}
				
				if(m_pRemoteAliasItem)
				{
					DEBUGMSG(ZONE_CONN,("%s: Releasing previous user info\r\n",_fx_));
					MemFree(m_pRemoteAliasItem);
				}
				// The H323 ID is UNICODE, and needs to be converted to ANSI
				// for propagation to UI/client app.  The conversion is done
				// in ConnectNotify()

				// need enough mem for the struct, the name, + null terminator
				ulSize = ((pItem->wDataLength +1)*sizeof(WCHAR)) + sizeof(CC_ALIASITEM);
				
				m_pRemoteAliasItem = (PCC_ALIASITEM)MemAlloc(ulSize);
				memcpy(m_pRemoteAliasItem, pItem, sizeof(CC_ALIASITEM));	
				m_pRemoteAliasItem->pData = (WCHAR*)(((char *)m_pRemoteAliasItem)+sizeof(CC_ALIASITEM));
				memcpy(m_pRemoteAliasItem->pData, pItem->pData, pItem->wDataLength*sizeof(WCHAR));
				// need to null terminate it
				*(WCHAR *)(((BYTE *)m_pRemoteAliasItem->pData) + pItem->wDataLength*sizeof(WCHAR))
					= (WCHAR)0;
			}
			pItem++;
		}
	}
	if(pwszRemotePeerDisplayName)
	{
		if(pwszPeerDisplayName)
		{
			DEBUGMSG(ZONE_CONN,("%s: Releasing previous pwszPeerDisplayName\r\n",_fx_));
			MemFree(pwszPeerDisplayName);
		}
		// this WAS the Q.931 display name which WAS always ascii
		// ulSize = lstrlen(szRemotePeerDisplayName) + 1;
		// Now it's unicode
		ulSize = (lstrlenW(pwszRemotePeerDisplayName) + 1)* sizeof(WCHAR);
		pwszPeerDisplayName = (LPWSTR)MemAlloc(ulSize);
		memcpy(pwszPeerDisplayName, pwszRemotePeerDisplayName, ulSize);	
	}
}

VOID CH323Ctrl::OnCallRinging(HRESULT hStatus, PCC_RINGING_CALLBACK_PARAMS pRingingParams)
{
	if(pRingingParams->pNonStandardData)
	{

		// nyi
	}
	DoAdvise(CCEV_RINGING, NULL);
}



HRESULT CH323Ctrl::FindDefaultRXChannel(PCC_TERMCAP pChannelCapability, ICtrlCommChan **lplpChannel)
{
	FX_ENTRY ("CH323Ctrl::FindDefaultRXChannel");
	HRESULT hr = hrSuccess;
	GUID mediaID;
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChannel;
	if(!pChannelCapability | !lplpChannel)
	{
		ERRORMESSAGE(("%s: null param:pcap:0x%08lX, pchan:0x%08lX\r\n",_fx_,
			pChannelCapability, lplpChannel));
		hr = CCO_E_INVALID_PARAM;
		goto EXIT;
	}

	// look for a matching channel instance.
	while (pos)
	{
		pChannel = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChannel);
		if(pChannel->IsSendChannel() == FALSE)
		{
			hr = pChannel->GetMediaType(&mediaID);
			if(!HR_SUCCEEDED(hr))
				goto EXIT;
			if(((mediaID == MEDIA_TYPE_H323AUDIO) && (pChannelCapability->DataType ==H245_DATA_AUDIO))	
			 	|| ((mediaID == MEDIA_TYPE_H323VIDEO) && (pChannelCapability->DataType ==H245_DATA_VIDEO)))
			{
				*lplpChannel = pChannel;
				return hrSuccess;
			}
		}
	}
	// fallout if not found
	hr = CCO_E_NODEFAULT_CHANNEL;
EXIT:
	return hr;
}	

#ifdef DEBUG
VOID DumpWFX(LPWAVEFORMATEX lpwfxLocal, LPWAVEFORMATEX lpwfxRemote)
{
	FX_ENTRY("DumpWFX");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(lpwfxLocal)
	{
		ERRORMESSAGE((" -------- Local --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxLocal->wFormatTag, lpwfxLocal->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxLocal->nSamplesPerSec, lpwfxLocal->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxLocal->nBlockAlign, lpwfxLocal->wBitsPerSample, lpwfxLocal->cbSize));
	}
	if(lpwfxRemote)
	{
			ERRORMESSAGE((" -------- Remote --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxRemote->wFormatTag, lpwfxRemote->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxRemote->nSamplesPerSec, lpwfxRemote->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxRemote->nBlockAlign, lpwfxRemote->wBitsPerSample, lpwfxRemote->cbSize));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpChannelParameters");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap1->DataType,pChanCap1->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap1->Dir,pChanCap1->CapId));
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap2->DataType,pChanCap2->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap2->Dir,pChanCap2->CapId));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpNonstdParameters");
	
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	DumpChannelParameters(pChanCap1, pChanCap2);
	
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		if(pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap1->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("unrecognized nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		if(pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap2->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
#else
#define DumpWFX(x,y)
#define DumpChannelParameters(x,y)
#define DumpNonstdParameters(x,y)
#endif

// make sure requested channel parameters are valid (data type, ID and capability
// structure are consistent).  Also obtains the local channel parameters needed
// to deal with the resulting stream
//
BOOL CH323Ctrl::ValidateChannelParameters(PCC_TERMCAP pChanCapLocal, PCC_TERMCAP pChanCapRemote)
{
	FX_ENTRY ("CH323Ctrl::ValidateChannelParameters");
	if((pChanCapLocal->DataType != pChanCapRemote->DataType)
	|| (pChanCapLocal->ClientType != pChanCapRemote->ClientType))
	{
		DEBUGMSG(ZONE_CONN,("%s:unmatched type\r\n",_fx_));
		DumpChannelParameters(pChanCapLocal, pChanCapRemote);
		return FALSE;
	}
	if(pChanCapLocal->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		PNSC_AUDIO_CAPABILITY pNSCapLocal, pNSCapRemote;
		
		if((pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice
			 != pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice )
		||(pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode
			!= pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode)
		||(pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension
			!= pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension)
		||(pChanCapLocal->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode
			!= pChanCapRemote->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode)
		||(pChanCapLocal->Cap.H245Aud_NONSTD.data.length
			!= pChanCapRemote->Cap.H245Aud_NONSTD.data.length))
		{
			DEBUGMSG(ZONE_CONN,("%s:unmatched NonStd capability\r\n",_fx_));
			DumpNonstdParameters(pChanCapLocal, pChanCapRemote);
			return FALSE;
		}

		//
		pNSCapLocal = (PNSC_AUDIO_CAPABILITY)pChanCapLocal->Cap.H245Aud_NONSTD.data.value;
		pNSCapRemote = (PNSC_AUDIO_CAPABILITY)pChanCapRemote->Cap.H245Aud_NONSTD.data.value;

		// we only know about NSC_ACM_WAVEFORMATEX at this time
		if(pNSCapRemote->cap_type != NSC_ACM_WAVEFORMATEX)
		{
			DEBUGMSG(ZONE_CONN,("%s:unrecognized NonStd capability type %d\r\n",_fx_, pNSCapRemote->cap_type));
			return FALSE;
		}
		if((pNSCapLocal->cap_data.wfx.cbSize != pNSCapRemote->cap_data.wfx.cbSize)
		|| (memcmp(&pNSCapLocal->cap_data.wfx, &pNSCapRemote->cap_data.wfx, sizeof(WAVEFORMATEX)) != 0))
		{
			DumpWFX(&pNSCapLocal->cap_data.wfx, &pNSCapRemote->cap_data.wfx);
			return FALSE;
		}
		
	}
	else
	{
		
	}
	// if it falls out, it's valid
	return TRUE;

}


BOOL CH323Ctrl::ConfigureRecvChannelCapability(
	ICtrlCommChan *pChannel,
	PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams)
{
	FX_ENTRY ("CH323Ctrl::ConfigureRecvChannelCapability");
	//IH323PubCap *pCapObject = NULL;
	CapsCtl *pCapObject = NULL;
	// CCapability *pCapObject = NULL;			
	DWORD dwFormatID =INVALID_AUDIO_FORMAT;
	PCC_TERMCAP pChannelCapability = pChannelParams->pChannelCapability, pSaveChannelCapability = NULL;
	UINT uSize, uLocalParamSize;
	LPVOID lpvData;
	LPVOID pLocalParams;			
	
	DEBUGMSG(ZONE_CONN,("%s: requested capability ID:0x%08lX, dir %d, type %d\r\n",
		_fx_, pChannelCapability->CapId, pChannelCapability->Dir,
			pChannelCapability->DataType));
			

	// at one time, we thought the capability ID would be valid
	// and we would be receiving the format specified in pChannelCapability->CapId
	// but it IS NOT VALID.   The only viable info is in the channel parameters.
	// The  code would be --->>>  dwFormatID = pChannelCapability->CapId;

	// the ID *should* be all that is necessary to configure ourselves.
	// However.....
	
	// validate media (data) type - why? shouldn't this be prevalidated?
	// shouldn't this be eventually used to select a channel object from
	// among multiple channel objects?
	if((pChannelCapability->DataType != H245_DATA_AUDIO) && (pChannelCapability->DataType != H245_DATA_VIDEO))
	{
		hrLast = CCO_E_UNSUPPORTED_MEDIA_TYPE;
		DumpChannelParameters(NULL, pChannelCapability);
		goto BAD_CAPABILITY_EXIT;
	}

  	// Look at the local capability referenced by pChannelCapability->CapId
 	// and Validate the format details

 	hrLast = m_pConfAdvise->GetCapResolver((LPVOID *)&pCapObject, OID_CAP_ACM_TO_H323);
 	if(!HR_SUCCEEDED(hrLast) || (pCapObject == NULL))
	{
		ERRORMESSAGE(("%s: null resolver\r\n",_fx_));
		goto BAD_CAPABILITY_EXIT;
	}
	
	// Find the local *receive* capability that matches the remote *send* channel
	// parameters and get the local parameters.

	uLocalParamSize = pCapObject->GetLocalRecvParamSize(pChannelCapability);
	pLocalParams=MemAlloc (uLocalParamSize);
	if (pLocalParams == NULL)
	{
	   hrLast = CCO_E_SYSTEM_ERROR;
	   goto BAD_CAPABILITY_EXIT;
	}
	hrLast = ((CapsCtl *)pCapObject)->GetDecodeParams( pChannelParams,
		(MEDIA_FORMAT_ID *)&dwFormatID, pLocalParams, uLocalParamSize);

 	if(!HR_SUCCEEDED(hrLast) || (dwFormatID == INVALID_AUDIO_FORMAT))
	{
		ERRORMESSAGE(("%s:GetDecodeParams returned 0x%08lx\r\n",_fx_, hrLast));
		goto BAD_CAPABILITY_EXIT;
	}

	
	// create a marshalled version of channel parameters and store it in the channel for later
	// reference
	if(pChannelCapability->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		// The nonstandard capability already passed all the recognition tests so
		// don't need to test again.
		// Make a flat copy of the nonstandard capability
		uSize = pChannelCapability->Cap.H245Aud_NONSTD.data.length;
		// lpData = pChannelCapability->Cap.H245Aud_NONSTD.data.value;

		pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
		if(!pSaveChannelCapability)
		{
			hrLast = CCO_E_SYSTEM_ERROR;
			goto BAD_CAPABILITY_EXIT;
		}	
		// copy fixed part
		memcpy(pSaveChannelCapability, pChannelCapability, sizeof(CC_TERMCAP));
		// variable part follows the fixed part
		pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value	
			= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
		// copy variable part
		memcpy(pSaveChannelCapability->Cap.H245Aud_NONSTD.data.value,
			pChannelCapability->Cap.H245Aud_NONSTD.data.value,
			pChannelCapability->Cap.H245Aud_NONSTD.data.length);
		// and length
		pSaveChannelCapability->Cap.H245Aud_NONSTD.data.length
			= pChannelCapability->Cap.H245Aud_NONSTD.data.length;
		
		// make the channel remember the channel parameters.
		// a zero size as the second arg means that a preallocated chunk is being passed
		hrLast = pChannel->ConfigureCapability(pSaveChannelCapability, 0,
			pLocalParams, uLocalParamSize);	
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:ConfigureCapability (recv) returned 0x%08lx\r\n",_fx_, hrLast));
			goto BAD_CAPABILITY_EXIT;
		}
		pSaveChannelCapability=NULL;  // the channel owns this memory now
	}
	else if(pChannelCapability->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// The nonstandard capability already passed all the recognition tests so
		// don't need to test again.
		// Make a flat copy of the nonstandard capability
		uSize = pChannelCapability->Cap.H245Vid_NONSTD.data.length;
		// lpData = pChannelCapability->Cap.H245Vid_NONSTD.data.value;

		pSaveChannelCapability = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP) +  uSize);
		if(!pSaveChannelCapability)
		{
			hrLast = CCO_E_SYSTEM_ERROR;
			goto BAD_CAPABILITY_EXIT;
		}	
		// copy fixed part
		memcpy(pSaveChannelCapability, pChannelCapability, sizeof(CC_TERMCAP));
		// variable part follows the fixed part
		pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value	
			= (unsigned char *)(((BYTE *)pSaveChannelCapability) + sizeof(CC_TERMCAP));
		// copy variable part
		memcpy(pSaveChannelCapability->Cap.H245Vid_NONSTD.data.value,
			pChannelCapability->Cap.H245Vid_NONSTD.data.value,
			pChannelCapability->Cap.H245Vid_NONSTD.data.length);
		// and length
		pSaveChannelCapability->Cap.H245Vid_NONSTD.data.length
			= pChannelCapability->Cap.H245Vid_NONSTD.data.length;
		
		// make the channel remember the channel parameters.
		// a zero size as the second arg means that a preallocated chunk is being passed
		hrLast = pChannel->ConfigureCapability(pSaveChannelCapability, 0,
			pLocalParams, uLocalParamSize);	
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:ConfigureCapability (recv) returned 0x%08lx\r\n",_fx_, hrLast));
			goto BAD_CAPABILITY_EXIT;
		}
		pSaveChannelCapability=NULL;  // the channel owns this memory now
	}
	else
	{
		// only need to remember the already-flat H.245 cap structure.
		hrLast = pChannel->ConfigureCapability(pChannelCapability, sizeof(CC_TERMCAP),
			pLocalParams, uLocalParamSize);	
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s:ConfigureCapability(recv) returned 0x%08lx\r\n",_fx_, hrLast));
			goto BAD_CAPABILITY_EXIT;
		}
	}
	// Remember the receive format ID
	pChannel->SetNegotiatedLocalFormat(dwFormatID);
	
	// very special case check for video Temporal/Spatial tradeoff capability.
	// Set the property of the channel accordingly
	if(pChannelCapability->DataType == H245_DATA_VIDEO )
	{
		BOOL bTSCap;
		bTSCap = ((PVIDEO_CHANNEL_PARAMETERS)pLocalParams)->TS_Tradeoff;
		pChannel->CtrlChanSetProperty(PROP_REMOTE_TS_CAPABLE,&bTSCap, sizeof(bTSCap));
		// don't bother checking or panicking over this SetProperty error
	}
	return TRUE;

///////////////////
BAD_CAPABILITY_EXIT:
	ERRORMESSAGE(("%s:received bad capability\r\n",_fx_));
	hrLast = CCO_E_INVALID_CAPABILITY;
	if(pSaveChannelCapability)
		MemFree(pSaveChannelCapability);
	return FALSE;
}

//
// we're being requested to open a channel for receive
//
VOID CH323Ctrl::OnChannelRequest(HRESULT hStatus,
	PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS pChannelReqParams)
{
	FX_ENTRY("CH323Ctrl::OnChannelRequest");
	
	CC_ADDR CChannelAddr, DChannelAddr;
	PCC_ADDR pCChannelAddr = pChannelReqParams->pPeerRTCPAddr;;
	PCC_TERMCAP				pChannelCapability;
	PSOCKADDR_IN	pAddr;
	SOCKADDR_IN sinC;
	pChannelCapability = pChannelReqParams->pChannelCapability;
	DWORD dwRejectReason = H245_REJ;
	ICtrlCommChan *pChannel;	
		
	if(!pChannelCapability)
	{
		ERRORMESSAGE(("OnChannelRequest: null capability\r\n"));
		goto REJECT_CHANNEL;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest");

//
	// Try to find a default channel to handle this open request.
	hrLast = FindDefaultRXChannel(pChannelCapability, &pChannel);	
	if(!HR_SUCCEEDED(hrLast) || !pChannel)
	{
		// Non-default channels Not Yet Implemented!!!!
		// Ask the parent conference object	to create another channel of the
		// specified media type.  The H.245 media type should map to one of the
		// media type GUIDs that the parent conference object understands.
		// 		GUID typeGuid;
		//		if(!MapGuidType(pChannelCapability, &typeGUID))
		//			goto REJECT_CHANNEL;
		// 		hrLast = m_pConfAdvise->GetChannel(&typeGuid, &pChannel);
		//  	if(!HR_SUCCEEDED(hrLast))
		//			goto REJECT_CHANNEL;
		if(hrLast == CCO_E_NODEFAULT_CHANNEL)
			dwRejectReason = H245_REJ_TYPE_NOTAVAIL;

		goto REJECT_CHANNEL;
	}
	
	if(pChannel->GetHChannel())
	{
		ERRORMESSAGE(("%s: existing channel or leak:0x%08lX\r\n",_fx_,
			pChannel->GetHChannel()));
		goto REJECT_CHANNEL;
	}

	//
	//   test if we want to allow this !!!
	//
	if(!pChannel->IsChannelEnabled())
	{
		goto REJECT_CHANNEL;
	}

	pChannel->SetHChannel(pChannelReqParams->hChannel);
	
	// configure based on the requested capability. (store capability ID, validate requested
	// capabilities
	if(!ConfigureRecvChannelCapability(pChannel, pChannelReqParams))
	{
		goto REJECT_CHANNEL;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest done configuring");

	// select our receive ports for this RTP session
	
	if(!pChannel->SelectPorts((LPIControlChannel)this))
	{
		ERRORMESSAGE(("%s, SelectPorts failed\r\n",_fx_));
		hrLast = CCO_E_BAD_ADDRESS;
		goto REJECT_CHANNEL;
	}

	if(pCChannelAddr)
	{
		if(pCChannelAddr->nAddrType != CC_IP_BINARY)
		{
			ERRORMESSAGE(("%s:invalid address type %d\r\n",_fx_, pCChannelAddr->nAddrType));
			hrLast = CCO_E_BAD_ADDRESS;
			goto REJECT_CHANNEL;
		}
		// pass the remote RTCP address to the channel instance
		sinC.sin_family = AF_INET;
		sinC.sin_addr.S_un.S_addr = htonl(pCChannelAddr->Addr.IP_Binary.dwAddr);
		sinC.sin_port = htons(pCChannelAddr->Addr.IP_Binary.wPort);

		DEBUGMSG(ZONE_CONN,("%s, request reverse port 0x%04x, address 0x%08lX\r\n",_fx_,
			pCChannelAddr->Addr.IP_Binary.wPort,pCChannelAddr->Addr.IP_Binary.dwAddr));
	
		hrLast = pChannel->AcceptRemoteRTCPAddress(&sinC);
		if(hrLast != CC_OK)
		{
			ERRORMESSAGE(("%s, AcceptRemoteRTCPAddress returned 0x%08lX\r\n",_fx_, hrLast));
			goto ERROR_EXIT;
		}
	}
	
	// get the address and ports of our end of the channel
	pAddr = pChannel->GetLocalAddress();
	// fixup channel addr pair structure.
	DChannelAddr.nAddrType = CC_IP_BINARY;
	DChannelAddr.bMulticast = FALSE;
	DChannelAddr.Addr.IP_Binary.wPort = pChannel->GetLocalRTPPort();
	DChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);

	CChannelAddr.nAddrType = CC_IP_BINARY;
	CChannelAddr.bMulticast = FALSE;
	CChannelAddr.Addr.IP_Binary.wPort = pChannel->GetLocalRTCPPort();
	CChannelAddr.Addr.IP_Binary.dwAddr = ntohl(pAddr->sin_addr.S_un.S_addr);

	DEBUGMSG(ZONE_CONN,("%s: accepting on port 0x%04x, address 0x%08lX\r\n",_fx_,
		DChannelAddr.Addr.IP_Binary.wPort,DChannelAddr.Addr.IP_Binary.dwAddr));

	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest accepting");
			
	hrLast = CC_AcceptChannel(pChannelReqParams->hChannel,&DChannelAddr, &CChannelAddr,
		0 /*  this param is the bitrate that will be used by THIS channel !! */);
	
	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s, CC_AcceptChannel returned 0x%08lX\r\n",_fx_, hrLast));
		goto ERROR_EXIT;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelRequest accepted");
	return;
	
REJECT_CHANNEL:	
	{
	// need private HRESULT! don't overwrite the reason we're rejecting the channel!!	
		HRESULT hr;	
		ERRORMESSAGE(("%s, rejecting channel, Dir:%d, DataType:%d, ClientType:%d, CapId:%d\r\n",
		_fx_, pChannelCapability->Dir, pChannelCapability->DataType,
		pChannelCapability->ClientType, pChannelCapability->CapId));
	
		hr = CC_RejectChannel(pChannelReqParams->hChannel, dwRejectReason);
		if(hr != CC_OK)
		{
			ERRORMESSAGE(("%s, CC_RejectChannel returned 0x%08lX\r\n",_fx_, hr));
		}
	}	
ERROR_EXIT:
	return;
}

VOID CH323Ctrl::OnChannelAcceptComplete(HRESULT hStatus,
	PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams)
{
	FX_ENTRY("CH323Ctrl::OnChannelAcceptComplete");
	ICtrlCommChan *pChannel;	
	if(hStatus != CC_OK)	
	{
		return;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelAcceptComplete");

	pChannel = FindChannel(pChannelParams->hChannel);	
	if(!pChannel)
	{
		ERRORMESSAGE(("OnChannelAcceptComplete: hChannel 0x%08lx not found\r\n", pChannelParams->hChannel));
		return;
	}
	
	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	// the receive side is open	
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelAcceptComplete, open done");
	if(HR_SUCCEEDED(hrLast))
	{
		m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_RX, pChannel, this);			
	}
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelAcceptComplete done");
}

VOID CH323Ctrl::OnChannelOpen(HRESULT hStatus,
	PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS pChannelParams )
{
	FX_ENTRY("CH323Ctrl::OnChannelOpen");
	PCC_ADDR	pChannelRTPAddr;
	PCC_ADDR	pChannelRTCPAddr;
    SOCKADDR_IN sinC, sinD;

	ICtrlCommChan *pChannel = (ICtrlCommChan *)pChannelParams->dwUserToken;	
	// validate channel token - is this what we think it is?
	if(IsBadWritePtr(pChannel, sizeof(ICtrlCommChan)))
	{
		ERRORMESSAGE(("%s:invalid channel token: 0x%08lx\r\n",_fx_, pChannelParams->dwUserToken));
		return;
	}
	if(pChannel->IsSendChannel() == FALSE)
	{
		ERRORMESSAGE(("%s:not a send channel:token 0x%08lX\r\n",_fx_,
			pChannelParams->dwUserToken));
		return;
	}
#ifdef DEBUG
	POSITION pos = m_ChannelList.GetHeadPosition();	
	ICtrlCommChan *pChan;
	BOOL bValid = FALSE;
	// look for a matching channel instance.
	while (pos)
	{
		pChan = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChan);
		if(pChan == pChannel)
		{
			bValid = TRUE;
			break;
		}
	}
	if(!bValid)
	{
		ERRORMESSAGE(("%s:unrecognized token 0x%08lX\r\n",_fx_,
			pChannelParams->dwUserToken));
		return;
	}
#endif	//DEBUG

	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen");

	if((hStatus != CC_OK) || (!(pChannelRTPAddr = pChannelParams->pPeerRTPAddr))
		|| (!(pChannelRTCPAddr = pChannelParams->pPeerRTCPAddr)))
	{
		ERRORMESSAGE(("%s: hStatus:0x%08lX, address:0x%08lX\r\n",_fx_,
			hStatus, pChannelRTPAddr));
		// LOOKLOOK need to interpret hStatus
		// let the channel know what happened.
		pChannel->OnChannelOpen(CHANNEL_REJECTED);	
		
		// the channel knows what happened, so let it do the worrying.
		return;
	}
	// what's the need for the different address types ????
	if((pChannelRTPAddr->nAddrType != CC_IP_BINARY)
		|| (pChannelRTCPAddr->nAddrType != CC_IP_BINARY))
	{
		ERRORMESSAGE(("%s: invalid address types %d, %d\r\n",_fx_,
				pChannelRTPAddr->nAddrType, pChannelRTCPAddr->nAddrType));
		goto ERROR_EXIT;
	}	
	
	// we now have the remote port info ( in host byte order)
	sinD.sin_family = AF_INET;
	sinD.sin_addr.S_un.S_addr = htonl(pChannelRTPAddr->Addr.IP_Binary.dwAddr);
	sinD.sin_port = htons(pChannelRTPAddr->Addr.IP_Binary.wPort);
	
	sinC.sin_family = AF_INET;
	sinC.sin_addr.S_un.S_addr = htonl(pChannelRTCPAddr->Addr.IP_Binary.dwAddr);
	//  There are two ports, but in RTP, it is implicit
	// that the RTCP control port is the next highest port number
	// sinC.sin_port = htons(ntohs(pChannelAddr->Addr.IP_Binary.wPort) +1);
	sinC.sin_port = htons(pChannelRTCPAddr->Addr.IP_Binary.wPort);

	DEBUGMSG(ZONE_CONN,("%s, opened on port 0x%04x, address 0x%08lX\r\n",_fx_,
		pChannelRTPAddr->Addr.IP_Binary.wPort,pChannelRTPAddr->Addr.IP_Binary.dwAddr));

	hrLast = pChannel->AcceptRemoteAddress(&sinD);
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("OnChannelOpen: AcceptRemoteAddress failed\r\n"));
		goto ERROR_EXIT;
	}
	hrLast = pChannel->AcceptRemoteRTCPAddress(&sinC);
	if(!HR_SUCCEEDED(hrLast))
	{	
		ERRORMESSAGE(("OnChannelOpen: AcceptRemoteRTCPAddress failed\r\n"));
		goto ERROR_EXIT;
	}
	
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen opening");
	hrLast = pChannel->OnChannelOpen(CHANNEL_OPEN);	// the send side is open
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("OnChannelOpen:channel's OnChannelOpen() returned 0x%08lX\r\n", hrLast));
		CloseChannel(pChannel);
		goto ERROR_EXIT;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen open done");
	m_pConfAdvise->OnControlEvent(CCEV_CHANNEL_READY_TX, pChannel, this);	
	//
	//	Check for readiness to notify that all required channels are open
	//
	CheckChannelsReady( );	
	SHOW_OBJ_ETIME("CH323Ctrl::OnChannelOpen done");
	return;
	
ERROR_EXIT:
	// need to cleanup, disconnect, etc.
	m_hCallCompleteCode = CCCI_CHANNEL_OPEN_ERROR;
	// let the parent Conference object know about the imminent disconnect
	DoAdvise(CCEV_CALL_INCOMPLETE, &m_hCallCompleteCode);
	hrLast = CCO_E_MANDATORY_CHAN_OPEN_FAILED;

	InternalDisconnect();
	return;
}
VOID CH323Ctrl::OnRxChannelClose(HRESULT hStatus,
	PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS pChannelParams )
{
	FX_ENTRY("CH323Ctrl::OnRxChannelClose");
	PCC_ADDR	pChannelRTPAddr;
	PCC_ADDR	pChannelRTCPAddr;
    SOCKADDR_IN sinC, sinD;

	ICtrlCommChan *pChannel;
	if(hStatus != CC_OK)
	{
		ERRORMESSAGE(("%s: hStatus:0x%08lX\r\n",_fx_,hStatus));
		// LOOKLOOK need to interpret hStatus
	}
	if(!(pChannel = FindChannel(pChannelParams->hChannel)))
	{
		ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
		return;
	}
		
	// validate channel - is this really a receive channel?
	if(pChannel->IsSendChannel() == TRUE)
	{
		ERRORMESSAGE(("%s:not a receive channel:hChannel 0x%08lX\r\n",_fx_,
			pChannelParams->hChannel));
		return;
	}
	pChannel->OnChannelClose(CHANNEL_CLOSED);	
	return;
}


VOID CH323Ctrl::OnTxChannelClose(HRESULT hStatus,
	PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pChannelParams )
{
	FX_ENTRY("CH323Ctrl::OnTxChannelClose");
	PCC_ADDR	pChannelRTPAddr;
	PCC_ADDR	pChannelRTCPAddr;
    SOCKADDR_IN sinC, sinD;

	ICtrlCommChan *pChannel;
	if(hStatus != CC_OK)
	{
		ERRORMESSAGE(("%s: hStatus:0x%08lX\r\n",_fx_,hStatus));
		// LOOKLOOK need to interpret hStatus
	}
	
	if(!(pChannel = FindChannel(pChannelParams->hChannel)))
	{
		CC_CloseChannelResponse(pChannelParams->hChannel, FALSE);
		ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
		return;
	}
	
	// validate channel - is this really a send channel?
	if(pChannel->IsSendChannel() == FALSE)
	{
		ERRORMESSAGE(("%s:not a send channel:hChannel 0x%08lX\r\n",_fx_,
			pChannelParams->hChannel));
		CC_CloseChannelResponse(pChannelParams->hChannel, FALSE);
		return;
	}
	CC_CloseChannelResponse(pChannelParams->hChannel, TRUE);
	pChannel->OnChannelClose(CHANNEL_CLOSED);	
	return;
}

BOOL CH323Ctrl::OnCallAccept(PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::OnCallAccept");
	BOOL bRet = FALSE;
	CH323Ctrl *pNewConnection = NULL;
	if(m_Phase != CCS_Listening)
	{
		ERRORMESSAGE(("OnCallAccept: unexpected call, m_Phase = 0x%08lX\r\n", m_Phase));
		goto EXIT;
	}

	if((!pListenCallbackParams->pCalleeAddr)
	    || (pListenCallbackParams->pCalleeAddr->nAddrType != CC_IP_BINARY))
	{
		if(pListenCallbackParams->pCalleeAddr)
		{
			ERRORMESSAGE(("%s: invalid address type %d\r\n",_fx_,pListenCallbackParams->pCalleeAddr->nAddrType));
		}
		else
		{
			ERRORMESSAGE(("%s: null local address\r\n",_fx_));
		}

	
		ERRORMESSAGE(("OnCallAccept:where's the local address????\r\n"));
					PHOSTENT phe;
					PSOCKADDR_IN psin;
				 	char szTemp[200];
					LPCSTR lpHostName;		
					gethostname(szTemp,sizeof(szTemp));
			    	lpHostName = szTemp;
					psin = &local_sin;
					phe = gethostbyname(lpHostName);
					if (phe != NULL)
					{
				   		memcpy((char FAR *)&(psin->sin_addr), phe->h_addr,phe->h_length);
						psin->sin_family = AF_INET;
					}
	
	
	}
	else
	{
		// remember our local address
		local_sin.sin_family = AF_INET;
		// in host byte order
		local_sin.sin_addr.S_un.S_addr = htonl(pListenCallbackParams->pCalleeAddr->Addr.IP_Binary.dwAddr);
		// in host byte order
		local_sin.sin_port = htons(pListenCallbackParams->pCalleeAddr->Addr.IP_Binary.wPort);
	}

	
	hrLast = m_pConfAdvise->GetAcceptingObject((LPIControlChannel *)&pNewConnection,
		&m_PID);
	if(HR_SUCCEEDED(hrLast) && pNewConnection)
	{
		// NOTE: The UI does not yet know this new object exists, and we may
		// need to silently delete it if there is a disconnect or error
		// Its ref count is 1 at this point.  The decision to delete could be
		// made inside pNewConnection->AcceptConnection(), (because sometimes
		// socket reads complete synchronously depending on timing) SO, we need to
		// protect the "unwind path" via AddRef() and Release() around the call
		//
		pNewConnection->AddRef();	//
		hrLast = pNewConnection->AcceptConnection(this, pListenCallbackParams);
		pNewConnection->Release();
		if(HR_SUCCEEDED(hrLast))
		{
			// The Intel Call control DLL already did a socket accept, the
			// Accept() methods simply initialize the handles and states of
			// pNewConnection and get user information (caller ID)
			// BUGBUG - the caller ID may change in Intel's code - it might
			// come via a conference event
			DEBUGMSG(ZONE_CONN,("OnCallAccept:accepted on connection 0x%08lX\r\n",pNewConnection));
			bRet = TRUE;						
		}
		else
		{
			ERRORMESSAGE(("OnCallAccept:Accept failed\r\n"));
			// LOOK -  Q: where does the accepting object get cleaned up?
			// A: pNewConnection->AcceptConnection((LPIControlChannel)this)
			// must call pNewConnection->DoAdvise(CCEV_ACCEPT_INCOMPLETE, NULL)
			// if the error occurred before the conference object got involved,
			// and must call InternalDisconnect() if the error occurred after
			// the conference object got involved,
		}

	}
	else
	{
		ERRORMESSAGE(("OnCallAccept:GetAcceptingObject failed, hr=0x%08lx\r\n",hrLast));
	}
	
	EXIT:
	return bRet;		
}	


HRESULT CH323Ctrl::NewConference()
{
	FX_ENTRY ("CH323Ctrl::NewConference");
	CapsCtl *pCapObject = NULL;
	PCC_TERMCAPLIST pTermCaps = NULL;
	CC_OCTETSTRING TerminalID;
	PCC_TERMCAPDESCRIPTORS pCapsList = NULL;
	LPWSTR lpwUserDisplayName;

	hrLast = m_pConfAdvise->GetCapResolver((LPVOID *)&pCapObject, OID_CAP_ACM_TO_H323);
	if(!HR_SUCCEEDED(hrLast) || (pCapObject == NULL))
	{
		ERRORMESSAGE(("%s: null resolver\r\n",_fx_));
		goto EXIT;
	}
	if(m_hConference)
	{
		ERRORMESSAGE(("%s:leak or uninitialized m_hConference:0x%08lx\r\n",_fx_,
				m_hConference));
	}
	
	hrLast = pCapObject->CreateCapList(&pTermCaps, &pCapsList);
	if(!HR_SUCCEEDED(hrLast))
	{
		goto EXIT;
	}
	
	lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
	if(lpwUserDisplayName)
	{
		TerminalID.pOctetString = (BYTE *)lpwUserDisplayName;
		TerminalID.wOctetStringLength = (WORD)lstrlenW(lpwUserDisplayName)*sizeof(WCHAR);
	}
	
	// create a conference
	hrLast = CC_CreateConference(&m_hConference, NULL,
		0,			// DWORD dwConferenceConfiguration,
		pTermCaps,		// PCC_TERMCAPLIST	
		pCapsList,		// ptr to term cap descriptors (PCC_TERMCAPDESCRIPTORS)
		&m_VendorInfo, 		// PVENDORINFO
		(lpwUserDisplayName)? &TerminalID: NULL, 	// PCC_OCTETSTRING pTerminalID,
		(DWORD_PTR)this,
		NULL, 	// CC_TERMCAP_CONSTRUCTOR TermCapConstructor,
		NULL, 	// CC_SESSIONTABLE_CONSTRUCTOR	SessionTableConstructor,		
		CCConferenceCallback);

	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("%s: CreateConference returned 0x%08lX\r\n", _fx_, hrLast));
	
	}

EXIT:	
	pCapObject->DeleteCapList(pTermCaps, pCapsList);
	return hrLast;

}

HRESULT CH323Ctrl::AcceptConnection(LPIControlChannel pIListenCtrlChan,
    LPVOID lpvListenCallbackParams)
{
	FX_ENTRY ("CH323Ctrl::AcceptConnection");
	BOOL bRet = FALSE;
	CREQ_RESPONSETYPE Response;
	DWORD dwCode = CCR_LOCAL_SYSTEM_ERROR;	// error variable only used in error case
	ULONG ulNameSize, ulSize;
	PSOCKADDR_IN psin;
	LPWSTR lpwUserDisplayName;
	CH323Ctrl *pListenConnection = (CH323Ctrl *)pIListenCtrlChan;	
	P_APP_CALL_SETUP_DATA pAppData = NULL;
	APP_CALL_SETUP_DATA AppData;
	
	PCC_NONSTANDARDDATA	pNSData = ((PCC_LISTEN_CALLBACK_PARAMS)
	    lpvListenCallbackParams)->pNonStandardData;
	
	if(pNSData
	    && pNSData->bCountryCode == USA_H221_COUNTRY_CODE
        // why be this picky -> && pNSData->bExtension == USA_H221_COUNTRY_EXTENSION;
        && pNSData->wManufacturerCode == MICROSOFT_H_221_MFG_CODE
        && pNSData->sData.pOctetString
        && pNSData->sData.wOctetStringLength >= sizeof(MSFT_NONSTANDARD_DATA))
	{
        if(((PMSFT_NONSTANDARD_DATA)pNSData->sData.pOctetString)->
            data_type == NSTD_APPLICATION_DATA)
        {
            AppData.lpData = &((PMSFT_NONSTANDARD_DATA)pNSData->sData.pOctetString)->
                nonstd_data.AppData.data;
            AppData.dwDataSize = (DWORD)
                ((PMSFT_NONSTANDARD_DATA)pNSData->sData.pOctetString)->dw_nonstd_data_size;
            pAppData = &AppData;
        }
    }

    SetRemoteVendorID(((PCC_LISTEN_CALLBACK_PARAMS)lpvListenCallbackParams)->pVendorInfo);
	
	// this object is assuming everything from the listening object, including
	// the "Listening" state

	// enter critical section and make sure another thread is not handling a caller disconnect
	// or timeout
	// EnterCriticalSection()
	if(m_Phase == CCS_Idle)
	{
    	GoNextPhase(CCS_Listening);
		// once in this state, a disconnect on another thread will change the state
		// to something besides CCS_Listening

		pListenConnection->GetLocalAddress(&psin);
		SetLocalAddress(psin);
		
		// steal the conference ID from the listen object
		// m_ConferenceID = pListenConnection->GetConfID();
		memcpy(&m_ConferenceID, pListenConnection->GetConfIDptr(),sizeof(m_ConferenceID));
		ZeroMemory(pListenConnection->GetConfIDptr(),sizeof(m_ConferenceID));

		m_hCall = pListenConnection->GetHCall();

		// steal the user info from the listen object
		m_pRemoteAliasItem = pListenConnection->m_pRemoteAliasItem;
		pListenConnection->m_pRemoteAliasItem = NULL;	// make the listen object forget this

		// steal the peer display name
		pwszPeerDisplayName = pListenConnection->pwszPeerDisplayName;
		pListenConnection->pwszPeerDisplayName = NULL;
		
		lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
	}
	
	// else	already timing out
	// LeaveCriticalSection()

	if (m_Phase != CCS_Listening)	// cleanup before it gets accepted
	{
		goto ACCEPT_ERROR;
	}
	
	// let the conference object know that caller ID info is available
	ConnectNotify(CCEV_CALLER_ID);	

	// Now going to do stuff that might put cleanup responsibility on the
	// conference object or UI. (i.e. the call could be accepted)

	// EnterCriticalSection()
	if(m_Phase == CCS_Listening)
	{	
		// state is still OK
    	GoNextPhase(CCS_Filtering);
		// once in this state, a disconnect on another thread will change the state
		// to something besides CCS_Filtering
	}
	// else	already timing out
	// LeaveCriticalSection()

    if (m_Phase != CCS_Filtering)	// one last chance to cleanup before it gets accepted
	{
		goto ERROR_REJECT;
	}

	// can't (should not) do this inside a critical section
	// create a conference to accept the call
	hrLast = NewConference();
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("%s, NewConference returned 0x%08lX\r\n", _fx_, hrLast));
		goto ERROR_REJECT;
	}

	m_pConfAdvise->AddRef();
	Response = m_pConfAdvise->FilterConnectionRequest(this, pAppData);
	m_pConfAdvise->Release();
	
	// Now it may be in the hands of the Conference object, and the accepted connection will
	// need to go through the "disconnecting" state if cleanup is needed.
	// Because connection code is reentrant, the connection could also have
	// been torn down (via connection methods) while inside
	// m_pConfAdvise->FilterConnectionRequest();
	// In each case below, check validity of the connection state - it might have changed
	// because a connection method was called or because the caller timed out

	switch(Response)
	{	
		default:
		case CRR_ACCEPT:
			if(m_Phase != CCS_Filtering)
			{
				ERRORMESSAGE(("%s, accepting state no longer valid 0x%08lX\r\n", _fx_, hrLast));
				goto CANCEL_ACCEPT;
			}
								
			// accept this request
			hrLast = CC_AcceptCall(m_hConference,
				NULL, 	// PCC_NONSTANDARDDATA	pNonStandardData
				lpwUserDisplayName,
				m_hCall,
				0, 		// DWORD dwBandwidth,
				(DWORD_PTR)this);
				
			if(hrLast != CC_OK)
			{
    	    	m_ChanFlags &= ~CTRLF_OPEN;
				goto CANCEL_ACCEPT;			
			}
				
			GoNextPhase(CCS_Accepting);
			bRet = TRUE;

		break;	
		case CRR_ASYNC:
			if(m_Phase == CCS_Accepting)
			{
				// then call has already been accepted inside FilterConnectionRequest callback
				bRet = TRUE;
			}
			else
			{
				if(m_Phase != CCS_Filtering)
				{
					ERRORMESSAGE(("%s, accepting state no longer valid 0x%08lX\r\n", _fx_, hrLast));
					goto CANCEL_ACCEPT;
				}
				GoNextPhase(CCS_Ringing);
				bRet = TRUE;
			}
		
		break;
		case CRR_BUSY:
			hrLast = CC_RejectCall(CC_REJECT_USER_BUSY,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			// always clean up this object that's not accepting the call
			GoNextPhase(CCS_Idle);
			goto ACCEPT_ERROR;			
		break;
		case CRR_REJECT:
			hrLast = CC_RejectCall(CC_REJECT_DESTINATION_REJECTION,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			// always clean up this object that's not accepting the call
			GoNextPhase(CCS_Idle);
			goto ACCEPT_ERROR;	
		break;
		case CRR_SECURITY_DENIED:
			hrLast = CC_RejectCall(CC_REJECT_SECURITY_DENIED,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			// always clean up this object that's not accepting the call
			GoNextPhase(CCS_Idle);
			goto ACCEPT_ERROR;			
		break;
	}

	return hrLast;		
ERROR_REJECT:
	hrLast = CC_RejectCall(CC_REJECT_UNDEFINED_REASON,
		NULL, // PCC_NONSTANDARDDATA pNonStandardData
		m_hCall);	// always clean up this object that's not accepting the call
	GoNextPhase(CCS_Idle);
			
ACCEPT_ERROR:
	
	DoAdvise(CCEV_ACCEPT_INCOMPLETE, &dwCode);
	return hrLast;	

CANCEL_ACCEPT:
	// InternalDisconnect() can be called from any state, and will do fine if
	// it is already in a disconnecting state.
	InternalDisconnect();
	return hrLast;														
}


VOID CH323Ctrl::Cleanup()
{	
	POSITION pos = m_ChannelList.GetHeadPosition();
	ICtrlCommChan *pChan = NULL;
	
	CleanupConferenceAttributes();
	if(m_hConference)
	{
		hrLast = CC_DestroyConference(m_hConference, FALSE);
		// LOOKLOOK - need to check return code!!!
		m_hConference = 0;
	}

	// reset each channel (cleanup underlying socket references)
	while (pos)
	{
		pChan = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChan);
		// cleanup RTP sockets
		pChan->Reset();
	}
	// clear "socket(s) are open flags
	m_ChanFlags &= ~CTRLF_OPEN;
}

HRESULT CH323Ctrl::GetLocalPort(PORT * lpPort)
{
	*lpPort = ntohs(local_sin.sin_port);
	return hrSuccess;	
}
HRESULT CH323Ctrl::GetRemotePort(PORT * lpPort)
{
	*lpPort = ntohs(remote_sin.sin_port);
	return hrSuccess;	
}

HRESULT CH323Ctrl::GetLocalAddress(PSOCKADDR_IN *lplpAddr)
{
	*lplpAddr = &local_sin;
	return hrSuccess;
}

HRESULT CH323Ctrl::GetRemoteAddress(PSOCKADDR_IN *lplpAddr)
{
	*lplpAddr = &remote_sin;
	return hrSuccess;
}
		
HRESULT CH323Ctrl::ListenOn(PORT Port)
{
	FX_ENTRY ("CH323Ctrl::ListenOn");	
	PCC_ALIASNAMES pAliasNames = m_pConfAdvise->GetUserAliases();
	// temporary hack to override UI's ignorance of multiple protocol types
	if(Port != H323_PORT)
	{
		ERRORMESSAGE(("%s, overriding port %d(d) with H323 port %d\r\n",_fx_,
			Port, H323_PORT));
		Port = H323_PORT;
	}

	// do we need to remember this?
	local_sin.sin_addr.S_un.S_addr =	INADDR_ANY;
	local_sin.sin_family = AF_INET;
	local_sin.sin_port = htons((u_short)Port); // set port
	
	CC_ADDR		ListenAddr;
	
	ListenAddr.nAddrType = CC_IP_BINARY;
	ListenAddr.bMulticast = FALSE;
	// in host byte order
	ListenAddr.Addr.IP_Binary.wPort = (u_short)Port;
	ListenAddr.Addr.IP_Binary.dwAddr = ntohl(INADDR_ANY);

	hrLast = CC_CallListen(&m_hListen, &ListenAddr,
		pAliasNames, (DWORD_PTR)this, CCListenCallback);

	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("CH323Ctrl::ListenOn:CallListen returned 0x%08lX\r\n", hrLast));
		goto EXIT;
	}	
	

	GoNextPhase(CCS_Listening);
	m_ChanFlags = CTRLF_RESET;
	hrLast = hrSuccess;
EXIT:
	return hrLast;
}		
HRESULT CH323Ctrl::StopListen(VOID)
{
	if(m_Phase == CCS_Listening)
	{
		hrLast = CC_CancelListen(m_hListen);
	}
	else
	{
		hrLast = CCO_E_NOT_LISTENING;
	}

//EXIT:
	return hrLast;
}


HRESULT  CH323Ctrl::AsyncAcceptRejectCall(CREQ_RESPONSETYPE Response)
{
	FX_ENTRY ("CH323Ctrl::AsyncAcceptRejectCall");
	HRESULT hr = CCO_E_CONNECT_FAILED;	
	LPWSTR lpwUserDisplayName;
	
	if(Response == CRR_ACCEPT)
	{	
		DEBUGMSG(ZONE_CONN,("%s:accepting\r\n",_fx_));
		lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
		// check call setup phase - send ready if user's acceptance is what
		// was holding us up
		if((m_Phase == CCS_Ringing) || (m_Phase == CCS_Filtering))
		{
			// accept this request
			hrLast = CC_AcceptCall(m_hConference,
				NULL, 	// PCC_NONSTANDARDDATA	pNonStandardData
				lpwUserDisplayName,
				m_hCall,
				0, 		// DWORD dwBandwidth,
				(DWORD_PTR)this);
						
			if(hrLast != CC_OK)
			{
				ERRORMESSAGE(("%s, CC_AcceptCall() returned 0x%08lX\r\n",_fx_, hrLast));
				goto EXIT;
			}
			GoNextPhase(CCS_Accepting);
			hr = hrSuccess;
		}
	}
	else
	{
		// reject only if in accepting state(s)
		// deletion is possible while in advise callback, so protect w/ AddRef()
		AddRef();
		DEBUGMSG(ZONE_CONN,("%s:rejecting\r\n",_fx_));

		if((m_Phase == CCS_Ringing) || (m_Phase == CCS_Filtering))
		{
			hrLast = CC_RejectCall((Response == CRR_BUSY) ?	
				CC_REJECT_USER_BUSY : CC_REJECT_DESTINATION_REJECTION,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			if(hrLast != CC_OK)
			{
				ERRORMESSAGE(("%s, CC_RejectCall() returned 0x%08lX\r\n",_fx_, hrLast));
			}
			GoNextPhase(CCS_Idle);
			// notify the UI or application code or whatever..
			DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
		}
		else
		{
			hr = CCO_E_INVALID_PARAM;	// LOOKLOOK - need INVALID_STATE error code
		}
			
		Release();
	}
EXIT:
	return (hr);
}


ULONG CH323Ctrl ::AddRef()
{
	FX_ENTRY ("CH323Ctrl::AddRef");
	uRef++;
	DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->AddRef() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
	return uRef;
}

ULONG CH323Ctrl ::Release()
{
	FX_ENTRY("CH323Ctrl ::Release");
	uRef--;
	if(uRef == 0)
	{
		DEBUGMSG(ZONE_CONN,("%s:(0x%08lX)->Releasing in phase:%d\r\n",_fx_, this, m_Phase ));

		if(m_Phase != CCS_Idle)
		{
			ERRORMESSAGE(("CMSIACtrl::uRef zero in non idle (%d) state!\r\n",m_Phase));
			InternalDisconnect();
		}
		delete this;
		return 0;
	}
	DEBUGMSG(ZONE_REFCOUNT,("%s:(0x%08lX)->Release() uRef = 0x%08lX\r\n",_fx_, this, uRef ));
	return uRef;
}



// implement IControlChannel::Disconnect().  Map reason codes to the protocol.
VOID CH323Ctrl::Disconnect(DWORD dwReason)
{
	// no way to propagate reason through H.323 stack?????
	InternalDisconnect();
}

VOID CH323Ctrl::InternalDisconnect()
{
	FX_ENTRY ("CH323Ctrl::Disconnect");
	SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect");
	
	m_ChanFlags &= ~CTRLF_ORIGINATING;	// reset "originating" flag.
	
	DEBUGMSG(ZONE_CONN,("%s, called in state %d, uRef = 0x%08lX\r\n",_fx_, m_Phase, uRef));
	switch(m_Phase)
	{
		case CCS_Connecting:
		case CCS_Accepting:
			// if we believe the control channel is still connected, disconnect
			if(IsCtlChanOpen(m_ChanFlags))
			{
				//set state to indicate disconnecting.
				GoNextPhase(CCS_Disconnecting);
				DEBUGMSG(ZONE_CONN,("%s, Expecting a CC_HANGUP_INDICATION\r\n",_fx_));
				hrLast = CC_Hangup(m_hConference, FALSE, (DWORD_PTR)this);
				if(hrLast != CC_OK)
				{
					ERRORMESSAGE(("%s:Hangup() returned 0x%08lX\r\n",_fx_, hrLast));
				}
				SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect hangup done");
			}
			else
			{
				CC_CancelCall(m_hCall);
				GoNextPhase(CCS_Idle);	// no need to ck retval - we're disconnected
				// notify the UI or application code or whatever..
				DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
			}
		break;
		case CCS_Ringing:
			// The call has not yet been accepted!!! Reject it!
			hrLast = CC_RejectCall(CC_REJECT_UNDEFINED_REASON,
				NULL, // PCC_NONSTANDARDDATA pNonStandardData
				m_hCall);
			SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect reject done");
		
			GoNextPhase(CCS_Idle);
			// notify the UI or application code or whatever..
			DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
		break;
		case CCS_Idle:
		case CCS_Disconnecting:
			ERRORMESSAGE(("%s:called in unconnected state %d\r\n",_fx_, m_Phase));
		break;
		default:
			//CCS_Ringing
			//CCS_Opening
			//CCS_Closing
			//CCS_Ready
			//CCS_InUse
			//CCS_Listening

			// if we believe the control channel is still connected, disconnect
			if(IsCtlChanOpen(m_ChanFlags))
			{
				//set state to indicate disconnecting.
				GoNextPhase(CCS_Disconnecting);
				hrLast = CC_Hangup(m_hConference, FALSE, (DWORD_PTR)this);
				if(hrLast != CC_OK)
				{
					ERRORMESSAGE(("%s:Hangup() returned 0x%08lX\r\n",_fx_, hrLast));
					DoAdvise(CCEV_DISCONNECTED ,NULL);
				}
				SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect hangup done");
			}
			else
			{
				GoNextPhase(CCS_Idle);	// no need to ck retval - we're disconnected
				// notify the UI or application code or whatever..
				DoAdvise(CCEV_DISCONNECTED, &m_hCallCompleteCode);
			}
		break;
	}
	SHOW_OBJ_ETIME("CH323Ctrl::InternalDisconnect done");
}



// 	start the asynchronous stuff that will instantiate a control channel
HRESULT CH323Ctrl::PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData)
{
	FX_ENTRY ("CH323Ctrl::PlaceCall");	
	CC_ALIASNAMES pstn_alias;
	PCC_ALIASITEM pPSTNAlias = NULL;
	PCC_ALIASNAMES pRemoteAliasNames = NULL;
	PCC_ALIASNAMES pTranslatedAliasNames = NULL;
	PCC_ALIASNAMES pLocalAliasNames = NULL;
	PCC_ADDR pDestinationAddr = NULL;
	PCC_ADDR pConnectAddr = NULL;
	LPWSTR lpwUserDisplayName = m_pConfAdvise->GetUserDisplayName();
    PCC_NONSTANDARDDATA		pNSData = NULL;
    PMSFT_NONSTANDARD_DATA lpNonstdContent = NULL;
	int iLen;
	LPWSTR lpwszDest;
	HRESULT hResult = hrSuccess;
	// validate current state, don't allow bad actions
	if(m_Phase != CCS_Idle)
	{
		hResult = CCO_E_NOT_IDLE;
		goto EXIT;
	}

	OBJ_CPT_RESET;	// reset elapsed timer

	m_ChanFlags |= CTRLF_INIT_ORIGINATING;
	if(!pCallAddr)
	{
		hResult =  CCO_E_BAD_ADDRESS;
		goto EXIT;
	}
	else
	{
		// keep a copy of the address
		SetRemoteAddress(pCallAddr);
	}
	// temporary hack to override UI's ignorance of multiple protocol types
	if(remote_sin.sin_port != htons(H323_PORT))
	{
		ERRORMESSAGE(("%s, overriding port %d(d) with H323 port %d\r\n",_fx_,
			ntohs(remote_sin.sin_port), H323_PORT));
		remote_sin.sin_port = htons(H323_PORT);
	}

	// check for connecting to self (not supported)
	if(local_sin.sin_addr.s_addr == remote_sin.sin_addr.s_addr)
	{
		hResult =  CCO_E_BAD_ADDRESS;
		goto EXIT;
	}

	if(m_pRemoteAliasItem)
	{
		MemFree(m_pRemoteAliasItem);
		m_pRemoteAliasItem = NULL;
	}

	// Is this a PSTN or H.320 gateway call?
	if(pCalledPartyNumber)
	{
		// Then, due to the bogus way that CC_PlaceCall() is overloaded, the remote alias names
		// must be overridden with the E.164 phone number.  The hack is buried in
		// Q931ConnectCallback() in CALLCONT.DLL (thank you Intel).  That hack propagates
		// the phone number to the "CalledPartyNumber" of the SETUP message only if there is
		// exactly one alias, and that one alias is of type E.164.
		
		// get # of characters
		iLen = lstrlenW(pCalledPartyNumber);
		// need buffer of size CC_ALIASITEM plus the size (in bytes) of the string
		pPSTNAlias = (PCC_ALIASITEM)MemAlloc(sizeof(CC_ALIASITEM)
			+ sizeof(WCHAR)* (iLen+1));
		if(!pPSTNAlias)
		{
	        ERRORMESSAGE(("%s:failed alloc of pPSTNAlias:0x%08lx\r\n",_fx_));
			hResult = CCO_E_OUT_OF_MEMORY;
			goto EXIT;
		}
		
		WORD wIndex, wLength =1;  // init wLength to count the null terminator
		WCHAR E164Chars[] = {CC_ALIAS_H323_PHONE_CHARS};
		LPCWSTR lpSrc = pCalledPartyNumber;
		pPSTNAlias->wType = CC_ALIAS_H323_PHONE;
		// set offsets - the E.164 address (a phone number) is the only thing
		// in the alias name buffer
		lpwszDest = (LPWSTR)(((char *)pPSTNAlias)+ sizeof(CC_ALIASITEM));
		pPSTNAlias->pData = lpwszDest;
		while(iLen--)
		{
			wIndex = (sizeof(E164Chars)/sizeof (WCHAR)) -1;	//scan E164Chars[]
			do
			{
				if(*lpSrc == E164Chars[wIndex])
				{
					*lpwszDest++ = *lpSrc;
					wLength++;
					break;
				}
			}while(wIndex--);
			
			lpSrc++;
		}
		// terminate it
		*lpwszDest = 0;
		
		// wDataLength is the # of UNICODE characters
		pPSTNAlias->wDataLength = wLength;
		pstn_alias.wCount = 1;
		pstn_alias.pItems = pPSTNAlias;
		pRemoteAliasNames = &pstn_alias;
			
	}
	else if (pDestinationAliases && bUseGKResolution)// use the supplied callee alias names
	{
		hrLast = AllocTranslatedAliasList(&pTranslatedAliasNames, pDestinationAliases);
		if(!HR_SUCCEEDED(hrLast))
		{
			ERRORMESSAGE(("%s, AllocTranslatedAliasList returned 0x%08lX\r\n", _fx_, hrLast));
			hResult = CCO_E_SYSTEM_ERROR;
			goto EXIT;
		}
		pRemoteAliasNames = pTranslatedAliasNames;
	}
	// else pRemoteAliasNames is initialized to NULL
	

	pLocalAliasNames = m_pConfAdvise->GetUserAliases();
	// start!!!
	CC_ADDR ConfAddr;
	// fixup the intel version of the address
	// also note that it's all in host byte order
	ConfAddr.bMulticast = FALSE;
	ConfAddr.nAddrType = CC_IP_BINARY;
	//hrLast = GetRemotePort(&ConfAddr.Addr.IP_Binary.wPort);
	ConfAddr.Addr.IP_Binary.wPort = htons(remote_sin.sin_port);
	ConfAddr.Addr.IP_Binary.dwAddr = ntohl(remote_sin.sin_addr.S_un.S_addr);
	
	#ifdef DEBUG	
		if(m_hConference)
			ERRORMESSAGE(("%s:leak or uninitialized m_hConference:0x%08lx\r\n",_fx_,
				m_hConference));
	#endif  // DEBUG
	
	// create a conference to place the call
	SHOW_OBJ_ETIME("PlaceCall ready to create conference");
	hrLast = NewConference();
	if(!HR_SUCCEEDED(hrLast))
	{
		ERRORMESSAGE(("%s, NewConference returned 0x%08lX\r\n", _fx_, hrLast));
		hResult = CCO_E_SYSTEM_ERROR;
		goto EXIT;
	}


	// Set connect timeout value
	// LOOKLOOK - this is a hardcoded value - !!!  Where should this actualy come from?
	// 30 secs == 30000mS
	SHOW_OBJ_ETIME("PlaceCall setting timeout");

	hrLast = CC_SetCallControlTimeout(CC_Q931_ALERTING_TIMEOUT, 30000);
										
    if(pAppData)
    {
        // typical case - app data should be really small
        if(pAppData->dwDataSize <= APPLICATION_DATA_DEFAULT_SIZE)
        {
            m_NonstdContent.data_type = NSTD_APPLICATION_DATA;
            m_NonstdContent.dw_nonstd_data_size = pAppData->dwDataSize;
            memcpy(&m_NonstdContent.nonstd_data.AppData.data,
                pAppData->lpData, pAppData->dwDataSize);
        	m_NonstandardData.sData.pOctetString  = (LPBYTE) &m_NonstdContent;
        	m_NonstandardData.sData.wOctetStringLength  = sizeof(m_NonstdContent);
        }
        else // need some heap
        {
            UINT uTotalSize = sizeof(MSFT_NONSTANDARD_DATA)+ pAppData->dwDataSize;
            lpNonstdContent = (PMSFT_NONSTANDARD_DATA)MemAlloc(uTotalSize);
            if(lpNonstdContent)
            {
                lpNonstdContent->data_type = NSTD_APPLICATION_DATA;
                lpNonstdContent->dw_nonstd_data_size = pAppData->dwDataSize;
                memcpy(&lpNonstdContent->nonstd_data.AppData.data, pAppData->lpData,pAppData->dwDataSize);
        	    m_NonstandardData.sData.pOctetString  = (LPBYTE) lpNonstdContent;
            	m_NonstandardData.sData.wOctetStringLength  = LOWORD(uTotalSize);
            }
            else
            {
                ERRORMESSAGE(("%s, alloc failed\r\n", _fx_));
        		hResult = CCO_E_SYSTEM_ERROR;
        		goto EXIT;
            }
        }
        pNSData = &m_NonstandardData;
    }

	m_NonstandardData.bCountryCode = USA_H221_COUNTRY_CODE;
    m_NonstandardData.bExtension = USA_H221_COUNTRY_EXTENSION;
    m_NonstandardData.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;

	SHOW_OBJ_ETIME("CH323Ctrl::PlaceCall ready to place call");

	// set destination address pointers
	if(bUseGKResolution)
	{
		// the address passed in pCallAddr is the GK's address
		pConnectAddr = &ConfAddr;
	}
	else
	{
		pDestinationAddr = &ConfAddr;
	}
	hrLast = CC_PlaceCall(
		m_hConference,
		&m_hCall,
		pLocalAliasNames, 	// 	PCC_ALIASNAMES			pLocalAliasNames,
		pRemoteAliasNames,
		NULL, 				// PCC_ALIASNAMES			pExtraCalleeAliasNames,
		NULL, 				// PCC_ALIASITEM			pCalleeExtension,
		pNSData,	        // PCC_NONSTANDARDDATA		pNonStandardData,
		lpwUserDisplayName, // PWSTR pszDisplay,
		pDestinationAddr, 	//  Destination call signalling address
		pConnectAddr, 		// 	address to send the SETUP message to, if different than
		 			// 	the destination address.  (used for gatekeeper calls?)
		0, 			//	DWORD                   dwBandwidth,
		(DWORD_PTR) this);

	SHOW_OBJ_ETIME("CH323Ctrl::PlaceCall placed call");

	//  clear these out so that cleanup does not try to free later
	if(lpNonstdContent)
   	    MemFree(lpNonstdContent);
	m_NonstandardData.sData.pOctetString  = NULL;
	m_NonstandardData.sData.wOctetStringLength = 0;

	// check return from CC_PlaceCall
	if(hrLast != CC_OK)
	{
		ERRORMESSAGE(("CH323Ctrl::PlaceCall, PlaceCall returned 0x%08lX\r\n", hrLast));
		hResult = CCO_E_CONNECT_FAILED;	
		goto EXIT;
	}
	// wait for an indication
	GoNextPhase(CCS_Connecting);

	EXIT:	
	if(pTranslatedAliasNames)
	{
		FreeTranslatedAliasList(pTranslatedAliasNames);
	}
	if(pPSTNAlias)
	{
	  MemFree(pPSTNAlias);
	}
	return hResult;
}

//
//	Given HCHANNEL, find the channel object.
//

ICtrlCommChan *CH323Ctrl::FindChannel(CC_HCHANNEL hChannel)
{
	FX_ENTRY ("CH323Ctrl::FindChannel");	
	// find the channel

	POSITION pos = m_ChannelList.GetHeadPosition();
	ICtrlCommChan *pChannel;
	while (pos)
	{
		pChannel = (ICtrlCommChan *) m_ChannelList.GetNext(pos);
		ASSERT(pChannel);
		if(pChannel->GetHChannel() == hChannel)
			return pChannel;
	}

	#ifdef DEBUG
	// fallout to error case
	ERRORMESSAGE(("%s, did not find hChannel 0x%08lX\r\n",_fx_,hChannel));
	#endif // DEBUG
	
	return NULL;
}

VOID  CH323Ctrl::OnMute(HRESULT hStatus,
				PCC_MUTE_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnMute");	
	ICtrlCommChan *pChannel;
	HRESULT hr;
	if(!(pChannel = FindChannel(pParams->hChannel)))
	{
	    ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
        return;
	}
	hr = pChannel->PauseNet(TRUE, TRUE);
	if(!HR_SUCCEEDED(hr))
	{
        ERRORMESSAGE(("%s, Pausenet returned 0x%08lx\r\n", _fx_, hr));
	}
}
VOID  CH323Ctrl::OnUnMute(HRESULT hStatus,
				PCC_UNMUTE_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnUnMute");	
	ICtrlCommChan *pChannel;
	HRESULT hr;

	if(!(pChannel = FindChannel(pParams->hChannel)))
	{
	    ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
        return;
	}
	hr = pChannel->PauseNet(FALSE, TRUE);
	if(!HR_SUCCEEDED(hr))
	{
        ERRORMESSAGE(("%s, Pausenet returned 0x%08lx\r\n", _fx_, hr));
	}
}


VOID  CH323Ctrl::OnMiscCommand(HRESULT hStatus,
				PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnMiscCommand");	
	ICtrlCommChan *pChannel;

	// not every command references an individual channel. The 4 exceptions are:
	// case equaliseDelay_chosen:		
	// case zeroDelay_chosen:
	// case multipointModeCommand_chosen:
	// case cnclMltpntMdCmmnd_chosen:
	//
	// if we were betting on receiving few of the exceptional cases, we would always
	// try to find the channel.
	//if(!(pChannel = FindChannel(pParams->hChannel)))
	//{
	//	ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
		// but don't error because of the exceptions
	//}
	
	switch(pParams->pMiscellaneousCommand->type.choice)
 	{
		// the name and spelling of these constants was invented by the OSS compiler
		//
		case videoFreezePicture_chosen:
			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
	
		break;
		case videoFastUpdatePicture_chosen:		// the receiver wants an I-Frame
		{
			HRESULT hr;
			IVideoChannel *pIVC=NULL;
			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
			hr = pChannel->QueryInterface(IID_IVideoChannel, (void **)&pIVC);
			if(HR_SUCCEEDED(hr))
			{
				pIVC->SendKeyFrame();
				pIVC->Release();
			}
			// else it must not be a video channel
			
		}
		break;
		case MCd_tp_vdTmprlSptlTrdOff_chosen:	
		{
			DWORD dwTradeoff;
			HRESULT hr;
			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
			// set TS value of the channel, also propagate to Datapump
			dwTradeoff  = MAKELONG(
				pParams->pMiscellaneousCommand->type.u.MCd_tp_vdTmprlSptlTrdOff, 0);
			// set channel property
			// NOTE: when PROP_TS_TRADEOFF is set, the channel does all the
			// local tweaking to make it happen. The channel will also signal the
			// new value to the remote as if the local end initiated it.
			hr = pChannel->CtrlChanSetProperty(PROP_TS_TRADEOFF, &dwTradeoff, sizeof(dwTradeoff));
		}
		break;
		
		default:
		// the following are not currently handled
		//	case equaliseDelay_chosen:		
		//	case zeroDelay_chosen:
		//	case videoSendSyncEveryGOB_chosen:
		//	case vdSndSyncEvryGOBCncl_chosen:
		//	case videoFastUpdateGOB_chosen:		// suposedly required by H.323
		//	case videoFastUpdateMB_chosen:		// suposedly required by H.323

		// and the remaining 2 are handled by the call control layer
		// so we will never see these
		//		case multipointModeCommand_chosen:	
		//		case cnclMltpntMdCmmnd_chosen:

		break;

	}

}
VOID  CH323Ctrl::OnMiscIndication(HRESULT hStatus,
				PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS pParams)
{
	FX_ENTRY ("CH323Ctrl::OnMiscIndication");	
	ICtrlCommChan *pChannel;
	HRESULT hr;
	unsigned short choice = pParams->pMiscellaneousIndication->type.choice;
	
	if(!(pChannel = FindChannel(pParams->hChannel)))
	{
		ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
	    // check the exceptional cases for which this is OK
	    if((choice == multipointConference_chosen)
	        || (choice == cnclMltpntCnfrnc_chosen)
	        || (choice == multipointZeroComm_chosen)
	        || (choice == cancelMultipointZeroComm_chosen)
	        || (choice == mltpntScndryStts_chosen)
	        || (choice == cnclMltpntScndryStts_chosen))
	    {
            return;     // as long as the above choices are not supported......
	    }

	}
	switch(choice)
	{
    	case logicalChannelActive_chosen:
		    hr = pChannel->PauseNet(FALSE, TRUE);
		break;
		case logicalChannelInactive_chosen:
		    hr = pChannel->PauseNet(TRUE, TRUE);
		break;

		case MIn_tp_vdTmprlSptlTrdOff_chosen:
		{
			HRESULT hr;
			DWORD dwTradeoff = MAKELONG(0,
				pParams->pMiscellaneousIndication->type.u.MIn_tp_vdTmprlSptlTrdOff);

			if(!(pChannel = FindChannel(pParams->hChannel)))
			{
				ERRORMESSAGE(("%s, channel not found\r\n", _fx_));
				break;
			}
			// Set the indicated TS value of the channel.
			// This should never occur for send channels.
			//
			hr = pChannel->CtrlChanSetProperty(PROP_TS_TRADEOFF_IND, &dwTradeoff, sizeof(dwTradeoff));
		}
		break;

		// the following are not currently handled
		//	case multipointConference_chosen:
		//	case cnclMltpntCnfrnc_chosen:
		//	case multipointZeroComm_chosen:
		//	case cancelMultipointZeroComm_chosen:
		//	case mltpntScndryStts_chosen:
		//	case cnclMltpntScndryStts_chosen:
		//	case vdIndctRdyTActvt_chosen:
		//	case videoNotDecodedMBs_chosen:

	}
}

HRESULT CH323Ctrl::MiscChannelCommand(
	ICtrlCommChan *pChannel,
	VOID * pCmd)
{

#ifdef BETA_2_ASN_PRESENT
    if(m_fAvoidCrashingPDUs)
        return hrSuccess;
#endif // BETA_2_ASN_PRESENT

	return CC_H245MiscellaneousCommand(m_hCall, pChannel->GetHChannel(),
		(MiscellaneousCommand *)pCmd);
}

HRESULT CH323Ctrl::MiscChannelIndication(
	ICtrlCommChan *pChannel,
	VOID * pInd)
{
    MiscellaneousIndication *pMI = (MiscellaneousIndication *)pInd;
            			
#ifdef BETA_2_ASN_PRESENT
    if(m_fAvoidCrashingPDUs)
        return hrSuccess;
#endif

    // Intel decided that they had to wrap two Misc commands with two separate,
    // additional APIs. And it won't allow those to be issued any other way.
    // (it returns an error).  Until we fix that, need to catch and reroute those
    // two special ones
    if(pMI->type.choice  == logicalChannelActive_chosen)
    {
		 return CC_UnMute(pChannel->GetHChannel());
    }
    else if (pMI->type.choice  == logicalChannelInactive_chosen )
    {
        return CC_Mute(pChannel->GetHChannel());
    }
    else
        return CC_H245MiscellaneousIndication(m_hCall,pChannel->GetHChannel(),pMI);
    					
}

VOID CH323Ctrl::SetRemoteVendorID(PCC_VENDORINFO pVendorInfo)
{
    if(!pVendorInfo)
        return;

    m_RemoteVendorInfo.bCountryCode = pVendorInfo->bCountryCode;
    m_RemoteVendorInfo.bExtension = pVendorInfo->bExtension;
    m_RemoteVendorInfo.wManufacturerCode = pVendorInfo->wManufacturerCode;
    if(pVendorInfo->pProductNumber
        && pVendorInfo->pProductNumber->wOctetStringLength
        && pVendorInfo->pProductNumber->pOctetString)
    {
        if(m_RemoteVendorInfo.pProductNumber)
        {
            MemFree(m_RemoteVendorInfo.pProductNumber);
        }
        m_RemoteVendorInfo.pProductNumber = (PCC_OCTETSTRING)
            MemAlloc(sizeof(CC_OCTETSTRING)
            + pVendorInfo->pProductNumber->wOctetStringLength);
        if(m_RemoteVendorInfo.pProductNumber)
        {
            m_RemoteVendorInfo.pProductNumber->wOctetStringLength
              = pVendorInfo->pProductNumber->wOctetStringLength;
            m_RemoteVendorInfo.pProductNumber->pOctetString =
                ((BYTE *)m_RemoteVendorInfo.pProductNumber + sizeof(CC_OCTETSTRING));
            memcpy(m_RemoteVendorInfo.pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->wOctetStringLength);
        }

    }
    if(pVendorInfo->pVersionNumber)
    {
        if(m_RemoteVendorInfo.pVersionNumber)
        {
            MemFree(m_RemoteVendorInfo.pVersionNumber);
        }
        m_RemoteVendorInfo.pVersionNumber = (PCC_OCTETSTRING)
            MemAlloc(sizeof(CC_OCTETSTRING)
            + pVendorInfo->pVersionNumber->wOctetStringLength);
        if(m_RemoteVendorInfo.pVersionNumber)
        {
            m_RemoteVendorInfo.pVersionNumber->wOctetStringLength
              = pVendorInfo->pVersionNumber->wOctetStringLength;
            m_RemoteVendorInfo.pVersionNumber->pOctetString =
                ((BYTE *)m_RemoteVendorInfo.pVersionNumber + sizeof(CC_OCTETSTRING));
            memcpy(m_RemoteVendorInfo.pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->wOctetStringLength);
        }
    }
#ifdef BETA_2_ASN_PRESENT
    char IntelCrashingID[] = "Intel Internet Video Phone";
    char IntelCrashingVer[] = "1.0";

    m_fAvoidCrashingPDUs = FALSE;  // innocent until proven guilty
    if(m_RemoteVendorInfo.bCountryCode == USA_H221_COUNTRY_CODE)
    {
        // then it's possible that it is Intel or Microsoft
        if(m_RemoteVendorInfo.wManufacturerCode == MICROSOFT_H_221_MFG_CODE)
        {
            if((!pVendorInfo->pProductNumber) && (!pVendorInfo->pVersionNumber))
            {
                // safe to assume this is Beta2 or Beta3
                m_fAvoidCrashingPDUs = TRUE;
            }
            else if((pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->wOctetStringLength == 0)
                && (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->wOctetStringLength == 0))
            {
                // safe to assume this is Beta2 or Beta3
                m_fAvoidCrashingPDUs = TRUE;
            }
        }
        else if(m_RemoteVendorInfo.wManufacturerCode == INTEL_H_221_MFG_CODE)
        {
            if(pVendorInfo->pProductNumber
                && pVendorInfo->pVersionNumber
                && pVendorInfo->pProductNumber->wOctetStringLength
                && pVendorInfo->pProductNumber->pOctetString
                && pVendorInfo->pVersionNumber->wOctetStringLength
                && pVendorInfo->pVersionNumber->pOctetString)

            {
                // compare strings, don't care about null terminator
                if((0 == memcmp(pVendorInfo->pProductNumber->pOctetString,
                    IntelCrashingID, min(sizeof(IntelCrashingID)-1,pVendorInfo->pProductNumber->wOctetStringLength)))
                 && (0 == memcmp(pVendorInfo->pVersionNumber->pOctetString,
                    IntelCrashingVer,
                    min(sizeof(IntelCrashingVer)-1, pVendorInfo->pVersionNumber->wOctetStringLength)) ))
                {
                   m_fAvoidCrashingPDUs = TRUE;
                }
            }
        }
    }
#endif  //BETA_2_ASN_PRESENT



}

HRESULT CH323Ctrl::Init(IConfAdvise *pConfAdvise)
{
	hrLast = hrSuccess;
	
	if(!(m_pConfAdvise = pConfAdvise))
	{
		hrLast = CCO_E_INVALID_PARAM;
		goto EXIT;
	}

EXIT:	
	return hrLast;
}

HRESULT CH323Ctrl::DeInit(IConfAdvise *pConfAdvise)
{
	hrLast = hrSuccess;
	if(m_pConfAdvise != pConfAdvise)
	{
		hrLast = CCO_E_INVALID_PARAM;
		goto EXIT;
	}
	m_pConfAdvise = NULL;

EXIT:	
	return hrLast;
}

BOOL CH323Ctrl::IsAcceptingConference(LPVOID lpvConfID)
{
	if(memcmp(lpvConfID, &m_ConferenceID, sizeof(m_ConferenceID))==0)
	{	
		return TRUE;
	}
	return FALSE;
}

HRESULT CH323Ctrl::GetProtocolID(LPGUID lpPID)
{
	if(!lpPID)
		return CCO_E_INVALID_PARAM;

	*lpPID = m_PID;
	hrLast = hrSuccess;
	return hrLast;
}
	
IH323Endpoint * CH323Ctrl::GetIConnIF()
{
	if(!m_pConfAdvise)
		return NULL;
	return m_pConfAdvise->GetIConnIF();
}	

STDMETHODIMP CH323Ctrl::GetVersionInfo(
        PCC_VENDORINFO *ppLocalVendorInfo,
        PCC_VENDORINFO *ppRemoteVendorInfo)
{

	FX_ENTRY ("CH323Ctrl::GetVersionInfo");
	if(!ppLocalVendorInfo || !ppRemoteVendorInfo)
	{
		return CCO_E_INVALID_PARAM;
	}
	*ppLocalVendorInfo = &m_VendorInfo;
	*ppRemoteVendorInfo = &m_RemoteVendorInfo;
	return hrSuccess;
}



CH323Ctrl::CH323Ctrl()
:m_hListen(0),
m_hConference(0),
m_hCall(0),
m_pRemoteAliases(NULL),
m_pRemoteAliasItem(NULL),
pwszPeerDisplayName(NULL),
pwszPeerAliasName(NULL),
m_bMultipointController(FALSE),
m_fLocalT120Cap(TRUE),
m_fRemoteT120Cap(FALSE),
hrLast(hrSuccess),
m_ChanFlags(0),
m_hCallCompleteCode(0),
m_pConfAdvise(NULL),
m_Phase( CCS_Idle ),
#ifdef BETA_2_ASN_PRESENT
    m_fAvoidCrashingPDUs(FALSE),
#endif

uRef(1)
{
	m_PID = PID_H323;
	ZeroMemory(&m_ConferenceID,sizeof(m_ConferenceID));
	ZeroMemory(&local_sin, sizeof(local_sin));
	ZeroMemory(&remote_sin, sizeof(remote_sin));
	ZeroMemory(&m_RemoteVendorInfo, sizeof(m_RemoteVendorInfo));
	local_sin_len =  sizeof(local_sin);
	remote_sin_len = sizeof(remote_sin);
	
	m_VendorInfo.bCountryCode = USA_H221_COUNTRY_CODE;
    m_VendorInfo.bExtension =  USA_H221_COUNTRY_EXTENSION;
    m_VendorInfo.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;

    m_VendorInfo.pProductNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING)
        + sizeof(DefaultProductID));
    if(m_VendorInfo.pProductNumber)
    {
        m_VendorInfo.pProductNumber->wOctetStringLength = sizeof(DefaultProductID);
        m_VendorInfo.pProductNumber->pOctetString =
            ((BYTE *)m_VendorInfo.pProductNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pProductNumber->pOctetString,
            DefaultProductID, sizeof(DefaultProductID));
    }

    m_VendorInfo.pVersionNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING)
            + sizeof(DefaultProductVersion));
    if(m_VendorInfo.pVersionNumber)
    {
        m_VendorInfo.pVersionNumber->wOctetStringLength = sizeof(DefaultProductVersion);
        m_VendorInfo.pVersionNumber->pOctetString =
                ((BYTE *)m_VendorInfo.pVersionNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pVersionNumber->pOctetString,
              DefaultProductVersion, sizeof(DefaultProductVersion));
    }

	m_NonstandardData.bCountryCode = USA_H221_COUNTRY_CODE;
	m_NonstandardData.bExtension =  USA_H221_COUNTRY_EXTENSION;
	m_NonstandardData.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;
	m_NonstandardData.sData.pOctetString  = NULL;
	m_NonstandardData.sData.wOctetStringLength  = 0;
	m_ParticipantList.wLength = 0;
	m_ParticipantList.ParticipantInfoArray = NULL;
	m_ConferenceAttributes.pParticipantList = &m_ParticipantList;
}


VOID CH323Ctrl ::ReleaseAllChannels()
{
	ICtrlCommChan *pChan = NULL;
	if (!m_ChannelList.IsEmpty())
	{
		while (!m_ChannelList.IsEmpty())
		{
			pChan = (ICtrlCommChan *) m_ChannelList.RemoveHead();
			if(pChan)
			{
				pChan->EndControlSession();
				pChan->Release();
				pChan = NULL;
			}
		}
	}
}

CH323Ctrl ::~CH323Ctrl()
{
	Cleanup();
	ReleaseAllChannels();
	if(m_pRemoteAliases)
		FreeTranslatedAliasList(m_pRemoteAliases);
	if(pwszPeerDisplayName)
		MemFree(pwszPeerDisplayName);
	if(pwszPeerAliasName)
		MemFree(pwszPeerAliasName);
	if(m_pRemoteAliasItem)
		MemFree(m_pRemoteAliasItem);
	if(m_NonstandardData.sData.pOctetString)
		MemFree(m_NonstandardData.sData.pOctetString);
    if(m_VendorInfo.pProductNumber)
        MemFree(m_VendorInfo.pProductNumber);
    if(m_VendorInfo.pVersionNumber)
        MemFree(m_VendorInfo.pVersionNumber);
    if(m_RemoteVendorInfo.pProductNumber)
        MemFree(m_RemoteVendorInfo.pProductNumber);
    if(m_RemoteVendorInfo.pVersionNumber)
        MemFree(m_RemoteVendorInfo.pVersionNumber);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\h323cc.cpp ===
// File: h323cc.cpp


#include "precomp.h"
#include "confreg.h"
#include "version.h"

EXTERN_C HINSTANCE g_hInst=NULL;	// global module instance

IRTP *g_pIRTP = NULL;
UINT g_capFlags = CAPFLAGS_AV_ALL;

#ifdef DEBUG
HDBGZONE  ghDbgZoneCC = NULL;
static PTCHAR _rgZonesCC[] = {
	TEXT("H323"),
	TEXT("Init"),
	TEXT("Conn"),
	TEXT("Channels"),
	TEXT("Caps"),
	TEXT("Member"),
	TEXT("unused"),
	TEXT("unused"),
	TEXT("Ref count"),
	TEXT("unused"),
	TEXT("Profile spew")	
};


int WINAPI CCDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("H323CC", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */

//  The product ID fields are defined in the standard as an array of bytes. ASCII
//  characters are used regardless of local character set.
// default Product ID and version ID strings

static char DefaultProductID[] = H323_PRODUCTNAME_STR;
static char DefaultProductVersion[] = H323_PRODUCTRELEASE_STR;

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL,
                                     DWORD  fdwReason,
                                     LPVOID  lpvReserved);

BOOL WINAPI DllEntryPoint(
    HINSTANCE  hinstDLL,	// handle to DLL module
    DWORD  fdwReason,	// reason for calling function
    LPVOID  lpvReserved 	// reserved
   )
{
	switch(fdwReason)
	{

		case DLL_PROCESS_ATTACH:
			DBGINIT(&ghDbgZoneCC, _rgZonesCC);

            DBG_INIT_MEMORY_TRACKING(hinstDLL);

			DisableThreadLibraryCalls(hinstDLL);
			g_hInst = hinstDLL;
            break;

		case DLL_PROCESS_DETACH:
            DBG_CHECK_MEMORY_TRACKING(hinstDLL);

			DBGDEINIT(&ghDbgZoneCC);
			break;

		default:
			break;

	}

 	return TRUE;
}


HRESULT WINAPI CreateH323CC(IH323CallControl ** ppCC, BOOL fForCalling, UINT capFlags)
{
	if(!ppCC)
		return H323CC_E_INVALID_PARAM;

    DBG_SAVE_FILE_LINE
	*ppCC = new CH323CallControl(fForCalling, capFlags);
	if(!(*ppCC))
		return	H323CC_E_CREATE_FAILURE;

	return hrSuccess;
	
}


BOOL CH323CallControl::m_fGKProhibit = FALSE;
RASNOTIFYPROC CH323CallControl::m_pRasNotifyProc = NULL;

CH323CallControl::CH323CallControl(BOOL fForCalling, UINT capFlags) :
    m_uRef(1),
    m_fForCalling(fForCalling),
    m_numlines(0),
 m_pProcNotifyConnect(NULL),
 m_pCapabilityResolver(NULL),
 m_pListenLine(NULL),
 m_pLineList(NULL),
 m_pNextToAccept(NULL),
 m_pUserName(NULL),
 m_pLocalAliases(NULL),
 m_pRegistrationAliases(NULL),
 hrLast(hrSuccess),
 m_pSendAudioChannel(NULL),
 m_pSendVideoChannel(NULL),
 m_uMaximumBandwidth(0)
{
    //
    // Set up caps.
    //
    if (fForCalling)
    {
        g_capFlags = capFlags;
    }

	m_VendorInfo.bCountryCode = USA_H221_COUNTRY_CODE;
    m_VendorInfo.bExtension =  USA_H221_COUNTRY_EXTENSION;
    m_VendorInfo.wManufacturerCode = MICROSOFT_H_221_MFG_CODE;

    m_VendorInfo.pProductNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING) 
        + sizeof(DefaultProductID));
    if(m_VendorInfo.pProductNumber)
    {
        m_VendorInfo.pProductNumber->wOctetStringLength = sizeof(DefaultProductID);
        m_VendorInfo.pProductNumber->pOctetString = 
            ((BYTE *)m_VendorInfo.pProductNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pProductNumber->pOctetString,
            DefaultProductID, sizeof(DefaultProductID));
    }
        
    m_VendorInfo.pVersionNumber = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING) 
            + sizeof(DefaultProductVersion));
    if(m_VendorInfo.pVersionNumber)
    {
        m_VendorInfo.pVersionNumber->wOctetStringLength = sizeof(DefaultProductVersion);
        m_VendorInfo.pVersionNumber->pOctetString = 
                ((BYTE *)m_VendorInfo.pVersionNumber + sizeof(CC_OCTETSTRING));
        memcpy(m_VendorInfo.pVersionNumber->pOctetString,
              DefaultProductVersion, sizeof(DefaultProductVersion));
    }

	RegEntry reCC(szRegInternetPhone TEXT("\\") szRegInternetPhoneNac, 
						HKEY_LOCAL_MACHINE,
						FALSE,
						KEY_READ);

	UINT uAPD = reCC.GetNumberIniStyle(TEXT ("AudioPacketDurationMs"), 0);
	if (uAPD)
	{
		g_AudioPacketDurationMs = uAPD;
		g_fRegAudioPacketDuration = TRUE;
	}

    DBG_SAVE_FILE_LINE
    m_pCapabilityResolver = new CapsCtl();
    if (!m_pCapabilityResolver)
    {
	   	ERRORMESSAGE(("CH323CallControl::CH323CallControl:cannot create capability resolver\r\n"));
	    hrLast = H323CC_E_INIT_FAILURE;
    }

	if(!m_pCapabilityResolver->Init())
   	{
    	ERRORMESSAGE(("CH323CallControl::CH323CallControl cannot init capability resolver\r\n"));
	    hrLast = H323CC_E_INIT_FAILURE;
    }
		
}

HRESULT CH323CallControl::Initialize(PORT *lpPort)
{
	FX_ENTRY("CH323CallControl::Initialize");

	OBJ_CPT_RESET;
	
    ASSERT(m_fForCalling);

	if(!HR_SUCCEEDED(LastHR()))
	{
		goto EXIT;
	}
	if(!lpPort)
	{
		SetLastHR(H323CC_E_INVALID_PARAM);
		goto EXIT;
	}

	if(!Init())
	{
		goto EXIT;
	}
	else
	{
        ASSERT(m_pListenLine);
		hrLast = m_pListenLine->GetLocalPort(lpPort);
	}

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
    	SetLastHR( ::CoCreateInstance(CLSID_RTP,
	                        NULL, 
	                        CLSCTX_INPROC_SERVER,
	                        IID_IRTP, 
	                        (void**)&g_pIRTP) );
    }
	SHOW_OBJ_ETIME("CH323CallControl::Initialize");
	
	EXIT:	
	return LastHR();
				
}

HRESULT CH323CallControl::SetMaxPPBandwidth(UINT Bandwidth)
{
	HRESULT hr = hrSuccess;
	LPAPPVIDCAPPIF  lpIVidAppCap = NULL;
	DWORD dwcFormats = 0;
    DWORD dwcFormatsReturned = 0;
    DWORD x;
	BASIC_VIDCAP_INFO *pvidcaps = NULL;
	
	m_uMaximumBandwidth =Bandwidth;

    if (g_capFlags & CAPFLAGS_AV_STREAMS)
    {
      	//Set the bandwidth on every video format
	    hr = QueryInterface(IID_IAppVidCap, (void **)&lpIVidAppCap);
    	if (! HR_SUCCEEDED (hr))
	    	goto EXIT;

        // Get the number of BASIC_VIDCAP_INFO structures available
        hr = lpIVidAppCap->GetNumFormats((UINT*)&dwcFormats);
    	if (! HR_SUCCEEDED (hr))
	    	goto EXIT;

        if (dwcFormats > 0)
        {
            // Allocate some memory to hold the list in
            if (!(pvidcaps = (BASIC_VIDCAP_INFO*)MemAlloc(dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
            {
		    	hr = H323CC_E_INSUFFICIENT_MEMORY;
			    goto EXIT;
            }
            // Get the list
            hr=lpIVidAppCap->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
        	    (UINT*)&dwcFormatsReturned);
    		if (! HR_SUCCEEDED (hr))
	    		goto EXIT;

            //Set the bandwidth on each format
            for (x=0;x<dwcFormatsReturned;x++)
            {
		    	pvidcaps[x].uMaxBitrate=m_uMaximumBandwidth;
            }

            // Ok, now submit this list
            hr = lpIVidAppCap->ApplyAppFormatPrefs(pvidcaps, dwcFormats);
       		if (! HR_SUCCEEDED (hr))
	    		goto EXIT;
    	}
    }

    //Initialize the default H.323 simcaps.
    hr = m_pCapabilityResolver->ComputeCapabilitySets(m_uMaximumBandwidth);
   	//if(!HR_SUCCEEDED(hr))
    //	goto EXIT;

EXIT:
	// let the interface go
	if (lpIVidAppCap)
	{
		lpIVidAppCap->Release();
		// (going out of scope) lpIVidAppCap = NULL;
	}
	if(pvidcaps)
	{
	    // Free the memory, we're done
        MemFree(pvidcaps);
    }
	return hr;
}

BOOL CH323CallControl::Init()
{
	HRESULT hResult;
	
	DEBUGMSG(ZONE_INIT,("Init: this:0x%08lX\r\n", this));
	SetLastHR(hrSuccess);

    if (m_fForCalling)
    {
        //
        // Only call control code should init CC_ stuff.  Codec manipulation
        // via audiocpl should not.
        //
    	hResult = CC_Initialize();
	    if(!HR_SUCCEEDED(hResult))
    	{
	    	goto CLEANUP;
    	}
    }

   	ASSERT(m_pCapabilityResolver);
		
	// Initialize capability data using default number, but clear the saved
	// bandwidth number afterwards.  This detects attempts to place or  
	// accept calls before the application initializes the real bandwidth
	hResult = SetMaxPPBandwidth(DEF_AP_BWMAX);
	m_uMaximumBandwidth = 0;
	if(!HR_SUCCEEDED(hResult))
	{
		goto CLEANUP;
	}

	// Create dual connection objects for listening for new connections
    if (m_fForCalling)
    {
    	hResult = CreateConnection(&m_pListenLine,PID_H323);
	    if(!HR_SUCCEEDED(hResult))
    	{
	    	goto CLEANUP;
    	}
	    if(!m_pListenLine)
    	{
	    	hResult = H323CC_E_INIT_FAILURE;
		    goto CLEANUP;
    	}
	    if(!(m_pListenLine->ListenOn(H323_PORT)))
    	{
	    	hResult = H323CC_E_NETWORK_ERROR;
		    goto CLEANUP;
    	}
    }
	
	return TRUE;	

CLEANUP:
	if (m_pListenLine)
	{
		m_pListenLine->Release();
		m_pListenLine = NULL;
	}
	SetLastHR(hResult);
	return FALSE;
}


CH323CallControl::~CH323CallControl()
{
	if(m_VendorInfo.pProductNumber)
        MemFree(m_VendorInfo.pProductNumber);
    if(m_VendorInfo.pVersionNumber)
        MemFree(m_VendorInfo.pVersionNumber);
 	if(m_pUserName)
 		MemFree(m_pUserName);
	if(m_pLocalAliases)
		FreeTranslatedAliasList(m_pLocalAliases);
	if(m_pRegistrationAliases)
		FreeTranslatedAliasList(m_pRegistrationAliases);

	if (m_pCapabilityResolver)
    {
		m_pCapabilityResolver->Release();
        m_pCapabilityResolver = NULL;
    }

    if (m_pSendAudioChannel)
    {
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);
 	   	m_pSendAudioChannel->Release();
        m_pSendAudioChannel = NULL;
    }

    if (m_pSendVideoChannel)
    {
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);
	   	m_pSendVideoChannel->Release();
        m_pSendVideoChannel = NULL;
    }

    if (m_fForCalling)
    {
    	// toast backward references to this in all 
	    // connection objects
    	CConnection *pLine = m_pLineList;
 	    CConnection *pNext;
    	while(pLine)
 	    {
 		    pNext = pLine->next;
     		pLine->DeInit();
 	    	pLine = pNext;
     	}

	    // release the listening object if it exists
    	if(m_pListenLine)
	    	m_pListenLine->Release();

    	// shutdown CALLCONT.DLL
	    CC_Shutdown();

      	if (g_pIRTP)
        {
            ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);
    	    g_pIRTP->Release();
   	    	g_pIRTP = NULL;
        }

        // Put capflags back
        g_capFlags = CAPFLAGS_AV_ALL;
    }
    else
    {
        ASSERT(!m_pLineList);
        ASSERT(!m_pListenLine);
    }
}

ULONG CH323CallControl::AddRef()
{
	m_uRef++;
	return m_uRef;
}

ULONG CH323CallControl::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		delete this;
		return 0;
	}
	return m_uRef;
}

HRESULT CH323CallControl::SetUserDisplayName(LPWSTR lpwName)
{
	LPWSTR lpwD;
	ULONG ulSize;
	if(!lpwName)
	{
		return (MakeResult(H323CC_E_INVALID_PARAM));
	}
	if(lpwName)
	{
		ulSize = ((lstrlenW(lpwName) +1)*sizeof(WCHAR));
		lpwD = (LPWSTR)MemAlloc(ulSize);
		if(!lpwD)
			return H323CC_E_INSUFFICIENT_MEMORY;
			
		if(m_pUserName)
		{
			MemFree(m_pUserName);
		}
		
		m_pUserName = lpwD;
		memcpy(m_pUserName, lpwName, ulSize);
	}
	return (MakeResult(hrSuccess));
}

// Find the most suitable alias for display. Return the first H323ID if it exists, 
// else return the first E.164 address
PCC_ALIASITEM CH323CallControl::GetUserDisplayAlias()
{
	WORD wC;
	PCC_ALIASITEM pItem, pFoundItem = NULL;
	if(m_pLocalAliases)
	{
		wC = m_pLocalAliases->wCount;
		pItem = m_pLocalAliases->pItems;
		while (wC--)
		{
			if(!pItem)
			{
				continue;
			}
			if(pItem->wType == CC_ALIAS_H323_ID)
			{
				if(!pItem->wDataLength  || !pItem->pData)
				{
					continue;
				}
				else 
				{
					pFoundItem = pItem;	// done, done, done
					break;				// I said done
				}
			}
			else if(pItem->wType == CC_ALIAS_H323_PHONE)
			{
				if(!pItem->wDataLength  || !pItem->pData)
				{
					continue;
				}
				else 
				{
					if(!pFoundItem)	// if nothing at all was found so far 
						pFoundItem = pItem;	// remember this
				}
			}
			pItem++;
		}
	}
	return pFoundItem;
}

CREQ_RESPONSETYPE CH323CallControl::ConnectionRequest(CConnection *pConnection)
{
	CREQ_RESPONSETYPE Response;
	// decide what to do internally
	// LOOKLOOK hardcoded acceptance
	Response = CRR_ACCEPT;
	return Response;
}	
CREQ_RESPONSETYPE CH323CallControl::FilterConnectionRequest(CConnection *pConnection,
     P_APP_CALL_SETUP_DATA pAppData)
{
	CREQ_RESPONSETYPE Response = CRR_ASYNC;
	ASSERT(m_uMaximumBandwidth);
	// run it past the notification callback (if there is one)
	if(m_pProcNotifyConnect)
	{
		// pass ptr to IConnection
		Response = (m_pProcNotifyConnect)((IH323Endpoint *)&pConnection->m_ImpConnection,
		     pAppData);
		if(Response != CRR_ACCEPT)
		{
			return Response;
		}
	}
	return Response;
}	

		
HRESULT CH323CallControl::RegisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler)
{

	// reject if there's an existing registration
	if (m_pProcNotifyConnect || (!pConnectRequestHandler))
	{
		return H323CC_E_INVALID_PARAM;
	}
	m_pProcNotifyConnect = pConnectRequestHandler;
	return hrSuccess;
}	

HRESULT CH323CallControl::DeregisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler)
{
	// reject if there's not an existing registration
	if (!m_pProcNotifyConnect)
		return H323CC_E_INVALID_PARAM;
	if (pConnectRequestHandler == m_pProcNotifyConnect)
	{
		m_pProcNotifyConnect = NULL;
	}		
	else
	{
		return H323CC_E_INVALID_PARAM;
	}
	return hrSuccess;
}	

HRESULT CH323CallControl::GetNumConnections(ULONG *lp)
{
	ULONG ulRet = m_numlines;
	// hide the "listening" connection object from the client/ui/whatever
	if(ulRet && m_pListenLine)
		ulRet--;
	if(lp)
	{
		*lp = ulRet;
	}
	return hrSuccess;
}	

HRESULT CH323CallControl::GetConnobjArray(CConnection **lplpArray, UINT uSize)
{
	UINT uPublicConnections;	// # of visible objects
	if(!lplpArray)
		return H323CC_E_INVALID_PARAM;

	uPublicConnections = m_numlines;
	if(m_pListenLine)
		uPublicConnections--;
		
	if(uSize < (sizeof(CConnection **) * uPublicConnections))
	{
		return H323CC_E_MORE_CONNECTIONS;
	}
	
	CConnection *pLine = m_pLineList;
	CConnection *pNext;
	int i=0;		
	while(pLine)
	{
		DEBUGCHK(uSize--);
		pNext = pLine->next;
		// return everything but the objects used for listening
		if(pLine != m_pListenLine) 
		{
			lplpArray[i++] = pLine;
		}
		pLine = pNext;
	}
	
	return hrSuccess;
};



HRESULT CH323CallControl::GetConnectionArray(IH323Endpoint * *lplpArray, UINT uSize)
{

	UINT uPublicConnections;	// # of visible objects
	if(!lplpArray)
		return H323CC_E_INVALID_PARAM;

	uPublicConnections = m_numlines;
	if(m_pListenLine)
		uPublicConnections--;

	if(uSize < (sizeof(IH323Endpoint * *) * uPublicConnections))
	{
		return H323CC_E_MORE_CONNECTIONS;
	}
	
	CConnection *pLine = m_pLineList;
	CConnection *pNext;
	int i=0;		
	while(pLine)
	{
		DEBUGCHK(uSize--);
		pNext = pLine->next;
		// return everything but the objects used for listening
		if(pLine != m_pListenLine)
		{
			lplpArray[i++] = (IH323Endpoint *)&pLine->m_ImpConnection;
		}
		pLine = pNext;
	}
	
	return hrSuccess;
};

//
// protocol specific CreateConnection
//
HRESULT CH323CallControl::CreateConnection(CConnection **lplpConnection, GUID PIDofProtocolType)
{
	SetLastHR(hrSuccess);
	CConnection *lpConnection, *lpList;
	if(!lplpConnection)
	{
		SetLastHR(MakeResult(H323CC_E_INVALID_PARAM));
		goto EXIT;
	}
	
	*lplpConnection = NULL;
			
    DBG_SAVE_FILE_LINE
	if(!(lpConnection = new CConnection))
	{
		SetLastHR(MakeResult(H323CC_E_INSUFFICIENT_MEMORY));
		goto EXIT;
	}

	hrLast = lpConnection->Init(this, PIDofProtocolType);

	// LOOKLOOK need to insert this connection in the connection list
	if(!HR_SUCCEEDED(hrSuccess))
	{
		delete lpConnection;
		lpConnection = NULL;
	}
	else	
	{
		*lplpConnection = lpConnection;
		// insert in connection list
		lpList = m_pLineList;
		m_pLineList = lpConnection;
		lpConnection->next =lpList;
		m_numlines++;
	}
	EXIT:
	return (LastHR());


}


//
//	IH323CallControl->CreateConnection(), EXTERNAL create connection interface.  
//
HRESULT CH323CallControl::CreateConnection(IH323Endpoint * *lplpLine, GUID PIDofProtocolType)
{
	SetLastHR(hrSuccess);
	CConnection *lpConnection;
	ASSERT(m_uMaximumBandwidth);
	if(!m_uMaximumBandwidth)
	{
		SetLastHR(MakeResult(H323CC_E_NOT_INITIALIZED));
		goto EXIT;
	}
	if(!lplpLine)
	{
		SetLastHR(MakeResult(H323CC_E_INVALID_PARAM));
		goto EXIT;
	}
	*lplpLine = NULL;
	
	hrLast = CreateConnection(&lpConnection, PIDofProtocolType);
	
	if(HR_SUCCEEDED(LastHR()) && lpConnection)
	{
		*lplpLine = (IH323Endpoint *)&lpConnection->m_ImpConnection;
	}
	EXIT:	
	return (LastHR());
}

//
// CreateLocalCommChannel creates the send side of a media channel outside the context
// of any call.
//

HRESULT CH323CallControl::CreateLocalCommChannel(ICommChannel** ppCommChan, LPGUID lpMID,
	IMediaChannel* pMediaStream)
{

	if(!ppCommChan || !lpMID || !pMediaStream)
		return H323CC_E_INVALID_PARAM;
		
	if (*lpMID == MEDIA_TYPE_H323AUDIO)
	{
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);

		// allow only one of each media type to be created.  This is an artificial
		// limitation.
		if(m_pSendAudioChannel)
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}

        DBG_SAVE_FILE_LINE
		if(!(m_pSendAudioChannel = new ImpICommChan))
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}
		
		hrLast = m_pSendAudioChannel->StandbyInit(lpMID, m_pCapabilityResolver, 
			pMediaStream);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendAudioChannel->Release();
			m_pSendAudioChannel = NULL;
			goto EXIT;
		}
		
		hrLast = m_pSendAudioChannel->QueryInterface(IID_ICommChannel, (void **)ppCommChan);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendAudioChannel->Release();
			m_pSendAudioChannel = NULL;
			goto EXIT;
		}
	}
	else if (*lpMID == MEDIA_TYPE_H323VIDEO)
	{
        ASSERT(g_capFlags & CAPFLAGS_AV_STREAMS);

		// allow only one of each media type to be created.  This is an artificial
		// limitation.
		if(m_pSendVideoChannel)
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}

        DBG_SAVE_FILE_LINE
		if(!(m_pSendVideoChannel = new ImpICommChan))
		{
			hrLast = H323CC_E_CREATE_FAILURE;
			goto EXIT;
		}
		hrLast = m_pSendVideoChannel->StandbyInit(lpMID, m_pCapabilityResolver,
			pMediaStream);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendVideoChannel->Release();
			m_pSendVideoChannel = NULL;
			goto EXIT;
		}
		hrLast = m_pSendVideoChannel->QueryInterface(IID_ICommChannel, (void **)ppCommChan);
		if(!HR_SUCCEEDED(hrLast))
		{
			m_pSendVideoChannel->Release();
			m_pSendVideoChannel = NULL;
			goto EXIT;
		}
	}
	else
		hrLast = H323CC_E_INVALID_PARAM;
EXIT:
	return hrLast;
}


ICtrlCommChan *CH323CallControl::QueryPreviewChannel(LPGUID lpMID)
{
	HRESULT hr;
	ICtrlCommChan *pCommChan = NULL;
	if(*lpMID == MEDIA_TYPE_H323AUDIO)
	{
		if(m_pSendAudioChannel)
		{
			hr = m_pSendAudioChannel->QueryInterface(IID_ICtrlCommChannel, (void **)&pCommChan);
			if(HR_SUCCEEDED(hr))
			{
				return pCommChan;
			}
		}
	}
	else if (*lpMID == MEDIA_TYPE_H323VIDEO)
	{
		if(m_pSendVideoChannel)
		{
			hr = m_pSendVideoChannel->QueryInterface(IID_ICtrlCommChannel, (void **)&pCommChan);
			if(HR_SUCCEEDED(hr))
			{
				return pCommChan;
			}
		}
	}
	// fallout to error case
	return NULL;
}


HRESULT CH323CallControl::RemoveConnection(CConnection *lpConnection)
{
	SetLastHR(hrSuccess);
	CConnection *lpList;
	UINT nLines;
	

	if((lpConnection == NULL) || lpConnection->m_pH323CallControl  != this)
	{
		SetLastHR(MakeResult(H323CC_E_INVALID_PARAM));
		goto EXIT;
	}
	
	m_numlines--; // update count NOW
	

	// use # of lines for bug detection in list management code
	nLines = m_numlines;

	
	if(m_pListenLine == lpConnection)
		m_pListenLine = NULL;
		
	// zap the back pointer of the connection NOW - this is crucial for
	// implementing "asynchronous delete" of connection objects
	lpConnection->m_pH323CallControl = NULL;	

	// find it in the connection list and remove it	
	
	// sp. case head
	if(m_pLineList== lpConnection)
	{
		m_pLineList = lpConnection->next;
	}
	else
	{
		lpList = m_pLineList;
		while(lpList->next && nLines)
		{
			if(lpList->next == lpConnection)
			{
				lpList->next = lpConnection->next;
				break;
			}
			lpList = lpList->next;
			nLines--;
		}	
	}

	EXIT:	
	return (LastHR());
}
	

STDMETHODIMP CH323CallControl::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if ((iid == IID_IH323CC) || (iid == IID_IUnknown))// satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if (iid == IID_IAppAudioCap )
    {
	   	hr = m_pCapabilityResolver->QueryInterface(iid, ppvObject);
    }
    else if(iid == IID_IAppVidCap )
	{
	    hr = m_pCapabilityResolver->QueryInterface(iid, ppvObject);
    }
	else if(iid == IID_IDualPubCap )
    {
	   	hr = m_pCapabilityResolver->QueryInterface(iid, ppvObject);
    }

	return (hr);
}


//
// 	Create a copy of the alias names in the (somewhat bogus) format that 
//	CALLCONT expects.  The destination format has a two-part string for every 
//	entry, but the lower layers concatenate the parts. Someday H323CC and CALLCONT
// 	will be one, and all the extraneous layers, copies of data, and redundant 
//  validations won't be needed.
//

HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource)
{
	HRESULT hr = H323CC_E_INVALID_PARAM;
	WORD w;
	PCC_ALIASNAMES pNewAliases = NULL;
	PCC_ALIASITEM pDestItem;
	P_H323ALIASNAME pSrcItem;
	
	if(!ppDest || !pSource || pSource->wCount == 0)
	{
		goto ERROR_OUT;
	}
	*ppDest = NULL;
	pNewAliases = (PCC_ALIASNAMES)MemAlloc(sizeof(CC_ALIASNAMES));
	if(!pNewAliases)
	{
		hr = H323CC_E_INSUFFICIENT_MEMORY;
		goto ERROR_OUT;
	}
	pNewAliases->wCount = 0;
	pNewAliases->pItems = (PCC_ALIASITEM)MemAlloc(pSource->wCount*sizeof(CC_ALIASITEM));
    if(!pNewAliases->pItems)
	{
		hr = H323CC_E_INSUFFICIENT_MEMORY;
		goto ERROR_OUT;
	}        
	for(w=0;w<pSource->wCount;w++)
	{
		pDestItem = pNewAliases->pItems+w;
		pSrcItem = pSource->pItems+w;
		// don't tolerate empty entries - error out if any exist
		if(pSrcItem->wDataLength && pSrcItem->lpwData)
		{
			if(pSrcItem->aType ==AT_H323_ID)
			{
				pDestItem->wType = CC_ALIAS_H323_ID;
			}
			else if(pSrcItem->aType ==AT_H323_E164)
			{
				pDestItem->wType = CC_ALIAS_H323_PHONE;
			}
			else
			{	// don't know how to translate this.  I hope that the need for translation 
				// goes away before new alias types are added.  Adding an alias type 
				// (H323_URL for example) requires many changes in lower layers anyway, 
				// so that would be a good time to merge H323CC and CALLCONT.
				goto ERROR_OUT;	// return invalid param
			}
			pDestItem->wPrefixLength = 0;	// this prefix thing is bogus
            pDestItem->pPrefix = NULL;
			pDestItem->pData = (LPWSTR)MemAlloc(pSrcItem->wDataLength *sizeof(WCHAR));
			if(pDestItem->pData == NULL)
			{
				hr = H323CC_E_INSUFFICIENT_MEMORY;
				goto ERROR_OUT;
			}
			// got good data. Copy the data, set size/length, and count it
            memcpy(pDestItem->pData, pSrcItem->lpwData, pSrcItem->wDataLength * sizeof(WCHAR));			
            pDestItem->wDataLength = pSrcItem->wDataLength;
			pNewAliases->wCount++;
		}
		else
		{
			goto ERROR_OUT;
		}
	}
	// got here, so output good data 
	hr = hrSuccess;
	*ppDest = pNewAliases;
	//pNewAliases = NULL;   // not needed if returning here instead of falling out
	return hr;
	
ERROR_OUT:
	if(pNewAliases)	// then it's an error condition needing cleanup
	{
		FreeTranslatedAliasList(pNewAliases);
	}
	return hr;
}
VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed)
{
	WORD w;
	PCC_ALIASITEM pDoomedItem;
	if(!pDoomed)
		return;
		
	for(w=0;w<pDoomed->wCount;w++)
	{
		pDoomedItem = pDoomed->pItems+w;
	
		// don't tolerate empty entries - error out if any exist
		if(pDoomedItem->wDataLength && pDoomedItem->pData)
		{
			MemFree(pDoomedItem->pData);
		}
		else
			ASSERT(0);
	}
	MemFree(pDoomed->pItems);
	MemFree(pDoomed);
}


STDMETHODIMP CH323CallControl::SetUserAliasNames(P_H323ALIASLIST pAliases)
{
	HRESULT hr = hrSuccess;
	PCC_ALIASNAMES pNewAliases = NULL;
	PCC_ALIASITEM pItem;
	
	hr = AllocTranslatedAliasList(&pNewAliases, pAliases);
	if(!HR_SUCCEEDED(hr))
		return hr;

	ASSERT(pNewAliases);
	if(m_pLocalAliases)
		FreeTranslatedAliasList(m_pLocalAliases);
		
	m_pLocalAliases = pNewAliases;
	return hr;	
}

STDMETHODIMP CH323CallControl::EnableGatekeeper(BOOL bEnable,  
	PSOCKADDR_IN  pGKAddr, P_H323ALIASLIST pAliases,
	 RASNOTIFYPROC pRasNotifyProc)
{
	HRESULT hr = hrSuccess;

	PCC_ALIASNAMES pNewAliases = NULL;
	PCC_ALIASITEM pItem;

	m_pRasNotifyProc = pRasNotifyProc;
	if(bEnable)
	{
		if(!pRasNotifyProc || !pGKAddr || !pAliases)
		{
			return H323CC_E_INVALID_PARAM;
		}
		if((pGKAddr->sin_addr.s_addr == INADDR_NONE) 
			|| (pGKAddr->sin_addr.s_addr == INADDR_ANY))
		{
			return H323CC_E_INVALID_PARAM;
		}
		hr = AllocTranslatedAliasList(&pNewAliases, pAliases);
		if(!HR_SUCCEEDED(hr))
			return hr;

		ASSERT(pNewAliases);
		if(m_pRegistrationAliases)
			FreeTranslatedAliasList(m_pRegistrationAliases);
			
		m_pRegistrationAliases = pNewAliases;
		// reset "I can place calls" state
		m_fGKProhibit = FALSE;
		hr = CC_EnableGKRegistration(bEnable, 
		    pGKAddr, m_pRegistrationAliases, 
			&m_VendorInfo,
			0,			// no multipoint/MC funtionality
		    RasNotify);
	}
	else
	{
		// we are turning off knowledge of what a gatekeeper is, 
		// so reset "I can place calls" state.  
		m_fGKProhibit = FALSE;
		hr = CC_EnableGKRegistration(bEnable, 
		    NULL, NULL, NULL, 0, RasNotify);
		if(m_pRegistrationAliases)
			FreeTranslatedAliasList(m_pRegistrationAliases);
			
		m_pRegistrationAliases = NULL;
	}
	return hr;
}

STDMETHODIMP CH323CallControl::GetGKCallPermission()
{
	if(m_fGKProhibit)
		return CONN_E_GK_NOT_REGISTERED;
	else
		return hrSuccess;
}

VOID CALLBACK CH323CallControl::RasNotify(DWORD dwRasEvent, HRESULT hReason)
{

	switch(dwRasEvent)
	{
		case RAS_REG_CONFIRM: // received RCF (registration confirmed)
			// reset "I can place calls" state
			m_fGKProhibit = FALSE;
		break;
		
		case RAS_REG_TIMEOUT: // GK did not respond
		case RAS_UNREG_CONFIRM: // received UCF (unregistration confirmed) 
		default:
			// do nothing. (except pass notification upward
		break;
		
		case RAS_REJECTED:  // received RRJ (registration rejected)
			m_fGKProhibit = TRUE;
		break;
		case RAS_UNREG_REQ:  // received URQ 
			m_fGKProhibit = TRUE;
		break;
	}
	if(m_pRasNotifyProc)
	{
		(m_pRasNotifyProc)(dwRasEvent, hReason);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\intelcc.h ===
#define INTELCC
#ifdef INTELCC
#include "apierror.h"
//#include "q931.h"
#include "incommon.h"
#include "callcont.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\iconnect.cpp ===
#include "precomp.h"
//
//	Interface stuff
//

HRESULT ImpIConnection::QueryInterface( REFIID iid,	void ** ppvObject)
{
    HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if((iid == IID_IPhoneConnection) 
	|| (iid == IID_IUnknown)) // satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else 
        hr = m_pConnection->QueryInterface(iid, ppvObject);
    return hr;
}


ULONG ImpIConnection::AddRef()
{
	 return (m_pConnection->AddRef());
}
ULONG ImpIConnection::Release()
{
	 return (m_pConnection->Release());
}
HRESULT ImpIConnection::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	 return (m_pConnection->SetAdviseInterface(pH323ConfAdvise));
}
HRESULT ImpIConnection::ClearAdviseInterface()
{
	 return (m_pConnection->ClearAdviseInterface());
}

HRESULT ImpIConnection::PlaceCall(BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData)
{
	return (m_pConnection->PlaceCall(bUseGKResolution, pCallAddr,		
        pDestinationAliases, pExtraAliases,  	
	    pCalledPartyNumber, pAppData));
}
HRESULT ImpIConnection::Disconnect()
{
	 return (m_pConnection->Disconnect());
}
HRESULT ImpIConnection::GetState(ConnectStateType *pState)
{
	 return (m_pConnection->GetState(pState));
}

HRESULT ImpIConnection::GetRemoteUserName(LPWSTR lpwszName, UINT uSize)
{
	return (m_pConnection->GetRemoteUserName(lpwszName, uSize));
}
HRESULT ImpIConnection::GetRemoteUserAddr(PSOCKADDR_IN psinUser)
{
	return (m_pConnection->GetRemoteUserAddr(psinUser));
}

HRESULT ImpIConnection::AcceptRejectConnection(CREQ_RESPONSETYPE Response)
{
	return (m_pConnection->AcceptRejectConnection(Response));
}
HRESULT ImpIConnection::GetSummaryCode()
{
	 return (m_pConnection->GetSummaryCode());
}
HRESULT ImpIConnection::CreateCommChannel(LPGUID pMediaGuid, ICommChannel **ppICommChannel,
	BOOL fSend)
{
	return (m_pConnection->CreateCommChannel(pMediaGuid, ppICommChannel, fSend));
}
HRESULT ImpIConnection:: ResolveFormats (LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput)
{
	return (m_pConnection->ResolveFormats(pMediaGuidArray, uNumMedia, pResOutput));
}
HRESULT ImpIConnection::GetVersionInfo(PCC_VENDORINFO *ppLocalVendorInfo,
									  PCC_VENDORINFO *ppRemoteVendorInfo)
{
	return (m_pConnection->GetVersionInfo(ppLocalVendorInfo, ppRemoteVendorInfo));
}

ImpIConnection::ImpIConnection()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\h323cc.h ===
/*
 *  	File: h323cc.h
 *
 *      Main H.323 call control interface implementation header file
 *
 *		Revision History:
 *
 *		11/28/95	mikev	created (as NAC.H). 
 *		05/19/98	mikev	H323CC.H -  cleaned obsolete references to
 *              streaming components, changed interface and object names
 */


#ifndef _H323CC_H
#define _H323CC_H
#ifdef __cplusplus
class CConnection;
class CH323CallControl;
typedef class CConnection CIPPhoneConnection;
#endif	// __cplusplus

//
//  utility functions
//
VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed);
HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource);

#define DEF_AP_BWMAX	14400

extern UINT g_capFlags;

/*
 *	Class definitions
 */

#ifdef __cplusplus

class CH323CallControl : public IH323CallControl
{
	
protected:
    PCC_ALIASNAMES m_pLocalAliases;
    PCC_ALIASNAMES m_pRegistrationAliases;
   	CC_VENDORINFO m_VendorInfo;
	LPWSTR	m_pUserName;
	UINT	m_uRef;
	HRESULT hrLast;
    BOOL    m_fForCalling;
	UINT m_uMaximumBandwidth;
	// application data
	CNOTIFYPROC m_pProcNotifyConnect;	// connection notification callback
	// subcomponent object references
	LPIH323PubCap m_pCapabilityResolver;
	CConnection *m_pListenLine;	// connection object listening for incoming
	CConnection *m_pLineList;	
	int m_numlines;	// # of objects in m_pLineList

	ImpICommChan 	*m_pSendAudioChannel;	
	ImpICommChan	*m_pSendVideoChannel;	
	
//  Internal interfaces	
	BOOL Init();	// internal initialization

	OBJ_CPT;		// profiling timer
	
public:
	CConnection *m_pNextToAccept;
	LPWSTR GetUserDisplayName() {return m_pUserName;};
    PCC_ALIASNAMES GetUserAliases() {return m_pLocalAliases;};
    PCC_ALIASITEM GetUserDisplayAlias();
	CH323CallControl(BOOL fForCalling, UINT capFlags);
	~CH323CallControl();
	HRESULT CreateConnection(CConnection **lplpConnection, GUID PIDofProtocolType);
	HRESULT RemoveConnection(CConnection *lpConnection);
	HRESULT LastHR() {return hrLast;};
	VOID SetLastHR(HRESULT hr) {hrLast = hr;};
	HRESULT GetConnobjArray(CConnection **lplpArray, UINT uSize);
	ICtrlCommChan *QueryPreviewChannel(LPGUID lpMID);

	STDMETHOD_( CREQ_RESPONSETYPE, ConnectionRequest(CConnection *pConnection));
	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(CConnection *pConnection,
	    P_APP_CALL_SETUP_DATA pAppData));
    STDMETHODIMP GetGKCallPermission();
	static VOID CALLBACK RasNotify(DWORD dwRasEven