   _OFS_ | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7B {
                          _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x7F 
};



///////////////////////////////////////////////////////
//  Import Netscape Bookmarks to Microsoft
//  Internet Explorer's Favorites
///////////////////////////////////////////////////////

/************************************************************\
    FUNCTION: ImportBookmarks

    PARAMETERS:
    HINSTANCE hInstWithStr - Location of String Resources.
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will see if it can find a IE Favorite's
    registry entry and a Netscape bookmarks registry entry.  If
    both are found, then the conversion can happen.  It will
    attempt to open the verify that the bookmarks file is
    valid and then convert the entries to favorite entries.
    If an error occures, ImportBookmarks() will return FALSE,
    otherwise it will return TRUE.
\*************************************************************/

BOOL ImportBookmarks(HINSTANCE hInstWithStr)
{
    char    szFavoritesDir[MAX_PATH];
    char    szBookmarksDir[MAX_PATH];
    HANDLE  hBookmarksFile        = INVALID_HANDLE_VALUE;
    BOOL    fSuccess                = FALSE;


    // Initialize Variables
    szFavoritesDir[0] = '\0';
    szBookmarksDir[0] = '\0';

    // Get Bookmarks Dir
    if (TRUE == GetNavBkMkDir( szBookmarksDir, sizeof(szBookmarksDir) ) )
    {
        if ((NULL != szBookmarksDir) && (szBookmarksDir[0] != '\0'))
        {
            hBookmarksFile = CreateFile(szBookmarksDir, GENERIC_READ, FILE_SHARE_READ, NULL,
                                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

            if ( hBookmarksFile != INVALID_HANDLE_VALUE )
            {
                // Get Favorites Dir
                if (TRUE == GetPathFromRegistry(szFavoritesDir, MAX_PATH, HKEY_CURRENT_USER,
                    szIEFavoritesRegSub, szIEFavoritesRegKey))
                {
                    if ((NULL != szFavoritesDir) && (szFavoritesDir[0] != '\0'))
                    {
                        // Verify it's a valid Bookmarks file
                        if (TRUE == VerifyBookmarksFile( hBookmarksFile ))
                        {
                            // Do the importing...
                            fSuccess = ConvertBookmarks(szFavoritesDir, hBookmarksFile, hInstWithStr);
                        }
                    }
                }
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hBookmarksFile)
    {
        CloseHandle(hBookmarksFile);
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: ConvertBookmarks

    PARAMETERS:
    char * szFavoritesDir - String containing the path to
            the IE Favorites directory
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will continue in a loop converting each
    entry in the bookmark file.  There are three types of
    entries in the bookmark file, 1) a bookmark, 2) start of
    new level in heirarchy, 3) end of current level in heirarchy.
    The function NextFileEntry() will return these values until
    the file is empty, at which point, this function will end.

    NOTE:
    In order to prevent an infinite loop, it's assumed
    that NextFileEntry() will eventually return ET_NONE or ET_ERROR.
\************************************************************/

BOOL ConvertBookmarks(char * szFavoritesDir, HANDLE hFile, HINSTANCE hInstWithStr)
{
    BOOL    fDone       = FALSE;
    BOOL    fSuccess    = TRUE;
    BOOL    fIsEmpty    = TRUE;
    char    * szData    = NULL;
    char    * szCurrent = NULL;
    char    * szToken   = NULL;
    char    szSubDir[MAX_PATH];

    fSuccess = GetData(&szData, hFile);
    if (NULL == szData)
        fSuccess = FALSE;

    szCurrent = szData;

    // Verify directory exists or that we can make it.
    if ((TRUE == fSuccess) && ( !SetCurrentDirectory(szFavoritesDir)))
    {
        // If the directory doesn't exist, make it...
        if ( !CreateDirectory(szFavoritesDir, NULL))
            fSuccess = FALSE;
        else
            if (!SetCurrentDirectory(szFavoritesDir))
                fSuccess = FALSE;
    }

    // We don't want to install Other Popular Browser's bookmarks on our top level of our
    // favorites, so we create a sub director to put them in.
    if (0 != LoadString(hInstWithStr, IDS_NS_BOOKMARKS_DIR, szSubDir, sizeof(szSubDir)))
    {
        lstrcat(szFavoritesDir, szSubDir);

        if ((TRUE == fSuccess) && (!SetCurrentDirectory(szFavoritesDir)))
        {
            // If the directory doesn't exist, make it...
            if (!CreateDirectory(szFavoritesDir, NULL))
                fSuccess = FALSE;
            else
                if (!SetCurrentDirectory(szFavoritesDir))
                    fSuccess = FALSE;
        }
    }
    else
        fSuccess = FALSE;

    while ((FALSE == fDone) && (TRUE == fSuccess))
    {
        switch(NextFileEntry(&szCurrent, &szToken))
        {
            case ET_OPEN_DIR:
                fSuccess = CreateDir(szToken);
                break;
            case ET_CLOSE_DIR:
                fSuccess = CloseDir();
                break;
            case ET_BOOKMARK:
                fSuccess = CreateBookmark(szToken);
                fIsEmpty = FALSE;
                break;
            case ET_ERROR:
                fSuccess = FALSE;
                break;
            case ET_NONE:
            default:
                fDone = TRUE;
                break;
        }
    }

    if ( fIsEmpty )
    {
        // nothing to import, delete the dir created earlier
        DelNode(szFavoritesDir, 0);
    }

    if (NULL != szData)
    {
        LocalFree(szData);
        szData = NULL;
        szCurrent = NULL;       // szCurrent no longer points to valid data.
        szToken = NULL;     // szCurrent no longer points to valid data.
    }

    return(fSuccess);
}

/************************************************************\
    FUNCTION: NextFileEntry

    PARAMETERS:
    char ** ppStr   - The data to parse.
    char ** ppToken - The token pointer.
    EntryType return- See below.

    DESCRIPTION:
    This function will look for the next entry in the
    bookmark file to create or act on.  The return value
    will indicate this response:
    ET_OPEN_DIR             Create a new level in heirarchy
    ET_CLOSE_DIR,           Close level in heirarchy
    ET_BOOKMARK,            Create Bookmark entry.
    ET_NONE,                End of File
    ET_ERROR                Error encountered

    Errors will be detected by finding the start of a token,
    but in not finding other parts of the token that are needed
    to parse the data.
\************************************************************/

MyEntryType NextFileEntry(char ** ppStr, char ** ppToken)
{
    MyEntryType   returnVal       = ET_NONE;
    char *      pCurrentToken   = NULL;         // The current token to check if valid.
    char *      pTheToken       = NULL;         // The next valid token.
    char *      pszTemp         = NULL;

    //ASSERTSZ(NULL != ppStr, "It's an error to pass NULL for ppStr");
    //ASSERTSZ(NULL != *ppStr, "It's an error to pass NULL for *ppStr");
    //ASSERTSZ(NULL != ppToken, "It's an error to pass NULL for ppToken");

    if ((NULL != ppStr) && (NULL != *ppStr) && (NULL != ppToken))
    {
        // Check for begin dir token
        if (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_DIR_TOKEN)))
        {
            // Begin dir token found
            // Verify that other needed tokens exist or it's an error
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, MID_DIR_TOKEN))) ||
                (NULL == ANSIStrStr(pszTemp, END_DIR_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // This function has to set *ppToken to the name of the directory to create
                *ppToken =  ANSIStrStr(pCurrentToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN)-1;
                pTheToken = pCurrentToken;
                returnVal = ET_OPEN_DIR;
            }
        }
        // Check for exit dir token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_EXITDIR_TOKEN))))
        {
            // Exit dir token found
            // See if this token comes before TheToken.
            if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
            {
                // ppToken is not used for Exit Dir
                *ppToken = NULL;
                pTheToken = pCurrentToken;
                returnVal = ET_CLOSE_DIR;
            }
        }
        // Check for begin dir token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_URL_TOKEN))))
        {
            // Bookmark token found
            // Verify that other needed tokens exist or it's an error
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN))) ||
                (NULL == (pszTemp = ANSIStrStr(pszTemp, BEGIN_BOOKMARK_TOKEN))) ||
                (NULL == ANSIStrStr(pszTemp, END_BOOKMARK_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // See if this token comes before TheToken.
                if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
                {
                    // This function has to set *ppToken to the name of the bookmark
                    *ppToken =  pCurrentToken + sizeof(BEGIN_URL_TOKEN)-1;
                    pTheToken = pCurrentToken;
                    returnVal = ET_BOOKMARK;
                }
            }
        }
    }
    else
        returnVal = ET_ERROR;               // We should never get here.

    if (NULL == pTheToken)
        returnVal = ET_NONE;
    else
    {
        // Next time we will start parsing where we left off.
        switch(returnVal)
        {
            case ET_OPEN_DIR:
                *ppStr = ANSIStrStr(pTheToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN);
                break;
            case ET_CLOSE_DIR:
                *ppStr = pTheToken + sizeof(BEGIN_EXITDIR_TOKEN);
                break;
            case ET_BOOKMARK:
                *ppStr = ANSIStrStr(pTheToken, END_BOOKMARK_TOKEN) + sizeof(END_BOOKMARK_TOKEN);
                break;
            default:
                break;
    }
    }

    return(returnVal);
}


/************************************************************\
    FUNCTION: GetPathFromRegistry

    PARAMETERS:
    LPSTR szPath    - The value found in the registry. (Result of function)
    UINT cbPath     - Size of szPath.
    HKEY theHKEY    - The HKEY to look into (HKEY_CURRENT_USER)
    LPSTR szKey     - Path in Registry (Software\...\Explore\Shell Folders)
    LPSTR szVName   - Value to query (Favorites)
    BOOL return     - TRUE if succeeded, FALSE if Error.
    EXAMPLE:
    HKEY_CURRENT_USER\Software\Microsoft\CurrentVersion\Explore\Shell Folders
    Favorites = "C:\WINDOWS\Favorites"

    DESCRIPTION:
    This function will look in the registry for the value
    to look up.  The caller specifies the HKEY, subkey (szKey),
    value to query (szVName).  The caller also sets a side memory
    for the result and passes a pointer to that memory in szPath
    with it's size in cbPath.  The BOOL return value will indicate
    success or failure of this function.
\************************************************************/

BOOL GetPathFromRegistry(LPSTR szPath, UINT cbPath, HKEY theHKEY,
                LPSTR szKey, LPSTR szVName)
{
    HKEY    hkPath  = NULL;
    DWORD   dwType;
    DWORD   dwSize;

    /*
     * Get Path to program
     *      from the registry
     */
    if (ERROR_SUCCESS != RegOpenKeyEx(theHKEY, szKey, 0, KEY_READ, &hkPath))
    {
    return(FALSE);
    }
    dwSize = cbPath;
    if (ERROR_SUCCESS != RegQueryValueEx(hkPath, szVName, NULL, &dwType, (LPBYTE) szPath, &dwSize))
    {
    RegCloseKey(hkPath);
    hkPath = NULL;
    return(FALSE);
    }
    RegCloseKey(hkPath);
    hkPath = NULL;

    /*
     * If we got nothing or it wasn't a string then
     * we bail out
     */
    if ((dwSize == 0) || (dwType != REG_SZ))
    return(FALSE);

    return(TRUE);
}


/************************************************************\
    FUNCTION: RemoveInvalidFileNameChars

    PARAMETERS:
    char * pBuf     - The data to search.

    DESCRIPTION:
    This function will search pBuf until it encounters
    a character that is not allowed in a file name.  It will
    then replace that character with a SPACE and continue looking
    for more invalid chars until they have all been removed.
\************************************************************/

void RemoveInvalidFileNameChars(char * pBuf)
{
    //ASSERTSZ(NULL != pBuf, "Invalid function parameter");

    // Go through the array of chars, replacing offending characters with a space
    if (NULL != pBuf)
    {
    if (REASONABLE_NAME_LEN < strlen(pBuf))
        pBuf[REASONABLE_NAME_LEN] = '\0';   // String too long. Terminate it.

    while ('\0' != *pBuf)
    {
        // Check if the character is invalid
        if (!IsDBCSLeadByte(*pBuf))
        {
        if  (ANSIStrChr(szInvalidFolderCharacters, *pBuf) != NULL)
            *pBuf = '_';
        }
#if 0
// Old code
        // We look in the array to see if the character is supported by FAT.
        // The array only includes the first 128 values, so we need to fail
        // on the other 128 values that have the high bit set.
        if (((AnsiMaxChar <= *pBuf) && (FALSE == IsDBCSLeadByte(*pBuf))) ||
        (0 == LocalLegalAnsiCharacterArray[*pBuf]))
        *pBuf = '$';
#endif
        pBuf = CharNext(pBuf);
    }
    }
}



/************************************************************\
    FUNCTION: CreateBookmark

    PARAMETERS:
    char * pBookmarkName- This is a pointer that contains
              the name of the bookmark to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the bookmark and it's value to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/

BOOL CreateBookmark(char *pBookmarkName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfBM[REASONABLE_NAME_LEN];
    char    szURL[MAX_URL];
    char    * pstrEndOfStr          = NULL;
    char    * pstrBeginOfName       = NULL;
    long    lStrLen                 = 0;
    HANDLE  hFile                   = NULL;
    DWORD   dwSize;
    char    szBuf[MAX_URL];

    //ASSERTSZ(NULL != pBookmarkName, "Bad input parameter");
    if (NULL != pBookmarkName)
    {
    pstrEndOfStr = ANSIStrStr(pBookmarkName, END_URL_TOKEN);
    if (NULL != pstrEndOfStr)
    {
        lStrLen = (long)(pstrEndOfStr-pBookmarkName);
        if (MAX_URL < lStrLen)
        lStrLen = MAX_URL-1;

        // Create the name of the Bookmark
        lstrcpyn(szURL, pBookmarkName, MAX_URL);
        szURL[lStrLen] = '\0';

        pstrBeginOfName = ANSIStrStr(pstrEndOfStr, BEGIN_BOOKMARK_TOKEN);
        if (NULL != pstrBeginOfName)
        {
        pstrBeginOfName += sizeof(BEGIN_BOOKMARK_TOKEN) - 1;            // Start at beginning of Name

        pstrEndOfStr = ANSIStrStr(pstrBeginOfName, END_BOOKMARK_TOKEN); // Find end of name
        if (NULL != pstrEndOfStr)
        {
            lStrLen = (long)(pstrEndOfStr-pstrBeginOfName);
            if (REASONABLE_NAME_LEN-FILE_EXT < lStrLen)
            lStrLen = REASONABLE_NAME_LEN-FILE_EXT-1;

            // Generate the URL
            lstrcpyn(szNameOfBM, pstrBeginOfName, lStrLen+1);
            //szNameOfBM[lStrLen] = '\0';
            lstrcat(szNameOfBM, ".url");
            RemoveInvalidFileNameChars(szNameOfBM);


            // Check to see if Favorite w/same name exists
            if (INVALID_HANDLE_VALUE != (hFile = CreateFile(szNameOfBM, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                                 CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL )))
            {
                WriteFile(hFile, "[InternetShortcut]\n", lstrlen( "[InternetShortcut]\n" ), &dwSize, NULL);
                wsprintf( szBuf, "URL=%s\n", szURL);
                WriteFile(hFile, szBuf, lstrlen(szBuf), &dwSize, NULL );
                fSuccess = TRUE;
            }
            else
            {
                fSuccess = TRUE;
            }

            if (NULL != hFile)
            {
                CloseHandle( hFile );
                hFile = NULL;
            }

        }
        }
    }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CreateDir

    PARAMETERS:
    char * pDirName - This is a pointer that contains
              the name of the directory to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the directory to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/
BOOL CreateDir(char *pDirName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfDir[REASONABLE_NAME_LEN];
    char    * pstrEndOfName         = NULL;
    long    lStrLen                 = 0;

    //ASSERTSZ(NULL != pDirName, "Bad input parameter");
    if (NULL != pDirName)
    {
        pstrEndOfName = ANSIStrStr(pDirName, END_DIR_TOKEN);
        if (NULL != pstrEndOfName)
        {
            lStrLen = (long)(pstrEndOfName-pDirName);
            if (REASONABLE_NAME_LEN < lStrLen)
            lStrLen = REASONABLE_NAME_LEN-1;

            lstrcpyn(szNameOfDir, pDirName, lStrLen+1);
            //szNameOfDir[lStrLen] = '\0';
            RemoveInvalidFileNameChars(szNameOfDir);

            // BUGBUG : Try to CD into existing dir first
            if ( !SetCurrentDirectory(szNameOfDir) )
            {
                if ( CreateDirectory(szNameOfDir, NULL) )
                {
                    if ( SetCurrentDirectory(szNameOfDir) )
                    {
                        fSuccess = TRUE;// It didn't exist, but now it does.
                    }
                }
            }
            else
                fSuccess = TRUE;        // It exists already.
        }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CloseDir

    PARAMETERS:
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will back out of the current directory.
\************************************************************/
BOOL CloseDir(void)
{
    return( SetCurrentDirectory("..") );
}


/************************************************************\
    FUNCTION: VerifyBookmarksFile

    PARAMETERS:
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - TRUE if No Error and Valid Bookmark file

    DESCRIPTION:
    This function needs to be passed with a valid pointer
    that points to an open file.  Upon return, the file will
    still be open and is guarenteed to have the file pointer
    point to the beginning of the file.
    This function will return TRUE if the file contains
    text that indicates it's a valid Netscape bookmarks file.
\************************************************************/

BOOL VerifyBookmarksFile(HANDLE hFile)
{
    BOOL    fSuccess            = FALSE;
    char    szFileHeader[sizeof(VALIDATION_STR)+1] = "";
    DWORD   dwSize;

    //ASSERTSZ(NULL != pFile, "You can't pass me a NULL File Pointer");
    if (INVALID_HANDLE_VALUE == hFile)
        return(FALSE);

    // Reading the first part of the file.  If the file isn't this long, then
    // it can't possibly be a Bookmarks file.
    if ( ReadFile( hFile, szFileHeader, sizeof(VALIDATION_STR)-1, &dwSize, NULL ) && (dwSize == sizeof(VALIDATION_STR)-1) )
    {
        szFileHeader[sizeof(VALIDATION_STR)] = '\0';            // Terminate String.
        if (0 == lstrcmp(szFileHeader, VALIDATION_STR))          // See if header is the same as the Validation string.
            fSuccess = TRUE;
    }

    // Reset the point to point to the beginning of the file.
    dwSize = SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
    if ( dwSize == 0xFFFFFFFF )
         fSuccess = FALSE;

    return(fSuccess);
}



/************************************************************\
    FUNCTION: GetData

    PARAMETERS:
    char ** ppData  - Where to put the data
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - Return TRUE is successful.

    DESCRIPTION:
    This function will find the size of the bookmarks file,
    malloc that much memory, and put the file's contents in
    that buffer.  ppData will be invalid when the function
    is called and will return with malloced memory that
    needs to be freed by the falling function.
\************************************************************/

BOOL GetData(char ** ppData, HANDLE hFile)
{
    DWORD  dwlength, dwRead;
    BOOL   fSuccess = FALSE;

    //ASSERTSZ(NULL != ppData, "Invalid input parameter");

    if (NULL != ppData)
    {
        *ppData = NULL;

        // Find the size of the data
        if ( dwlength = GetFileSize(hFile, NULL))
        {
            *ppData = (PSTR)LocalAlloc(LPTR, dwlength+1 );
            if (NULL != *ppData)
            {
                if ( ReadFile( hFile, *ppData, dwlength+1, &dwRead, NULL ) &&
                     ( dwlength == dwRead ) )
                {
                    fSuccess = TRUE;
                }

                (*ppData)[dwlength] = '\0';
            }
        }
    }

    return(fSuccess);
}


BOOL GetNavBkMkDir( LPSTR lpszDir, int isize )
{
    char    szDir[MAX_PATH];
    HKEY    hKey;
    HKEY    hKeyUser;
    char    szUser[MAX_PATH];
    DWORD   dwSize;
    BOOL    bDirFound = FALSE;

    lstrcpy( szUser, REGSTR_PATH_APPPATHS );
    AddPath( szUser, "NetScape.exe" );
    if ( GetPathFromRegistry( szDir, MAX_PATH, HKEY_LOCAL_MACHINE, szUser, "" ) &&
         lstrlen(szDir) )
    {
        DWORD dwMV, dwLV;

        if ( SUCCEEDED(GetVersionFromFile( szDir, &dwMV, &dwLV, TRUE)) )
        {
            if ( dwMV < 0x00040000 )
            {
                bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                                 szNetscapeBMRegSub, szNetscapeBMRegKey);
            }
            else
            {
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Netscape\\Netscape Navigator\\Users", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szUser);
                    if (RegQueryValueEx(hKey, "CurrentUser", NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
                    {
                        if (RegOpenKeyEx(hKey, szUser, 0, KEY_READ, &hKeyUser) == ERROR_SUCCESS)
                        {
                            dwSize = sizeof(szDir);
                            if (RegQueryValueEx(hKeyUser, "DirRoot", NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                            {
                                // Found the directory for the current user.
                                lstrcpy( lpszDir, szDir);
                                AddPath( lpszDir, "bookmark.htm" );
                                bDirFound = TRUE;
                            }
                            RegCloseKey(hKeyUser);
                        }
                    }
                    RegCloseKey(hKey);
                }

                if (!bDirFound)
                {
                    szUser[0] = '\0';
                    // NAV 4.5 is not writing the above keys. there is a different way of finding the user dir.
                    if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Netscape\\Netscape Navigator\\biff", 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
                    {
                        dwSize = sizeof(szUser);
                        if (RegQueryValueEx(hKey, "CurrentUser", NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
                        {
                            // Have the current user name. Now get the root folder where the user folder are.
                            if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Netscape\\Netscape Navigator\\Main", 0, KEY_QUERY_VALUE, &hKeyUser) == ERROR_SUCCESS)
                            {
                                dwSize = sizeof(szDir);
                                if (RegQueryValueEx(hKeyUser, "Install Directory", NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                                {
                                    // Got the install folder.
                                    // Need to the the parent folder and then append users\%s , %s gets replaced with
                                    // the CurrentUser name.
                                    if (GetParentDir(szDir))
                                    {
                                        AddPath(szDir, "Users");
                                        AddPath(szDir, szUser);
                                        AddPath(szDir, "bookmark.htm" );
                                        bDirFound = TRUE;
                                        lstrcpy(lpszDir, szDir);
                                    }

                                }
                                RegCloseKey(hKeyUser);
                            }

                        }
                        RegCloseKey(hKey);
                    }
                }
            }
        }
    }
    else
        bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                         szNetscapeBMRegSub, szNetscapeBMRegKey);

    return bDirFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\convert.h ===
/************************************************************\
	FILE: convert.h

	DATE: Apr 1, 1996

	AUTHOR: Bryan Starbuck (bryanst)

	DESCRIPTION:
		This file will handle the logic to convert Netscape
	bookmarks to Microsoft Internet Explorer favorites.  This 
	will happen by finding the location of the Netscape bookmarks
	file and the Microsoft Internet Explorer favorites directory
	from the registry.  Then it will parse the bookmarks file to
	extract the URLs, which will finally be added to the favorites
	directory.

  NOTES:
	This was developed with Netscape 2.0 and IE 2.0.  Future notes
	will be made about compatibility with different versions of
	these browsers.
	
\************************************************************/

#ifndef _CONVERT_H
#define _CONVERT_H



// ItemType is going to be the type of entry found in the bookmarks
// file.
typedef enum MYENTRYTYPE
{
    ET_OPEN_DIR     = 531,  // New level in heirarchy
    ET_CLOSE_DIR,           // Close level in heirarchy
    ET_BOOKMARK,            // Bookmark entry.
    ET_NONE,                // End of File
    ET_ERROR                // Bail, we encountered an error
} MyEntryType;


//////////////////////////////////////////////////////////////////
//	Exprted Functions
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
BOOL    ImportNetscapeProxy(void);		// Import Netscape Proxy Setting
BOOL    UpdateHomePage(void);			// Upgrade IE v1.0 Home URL to v3.0
BOOL    ImportBookmarks(HINSTANCE hInstWithStr);			//  Import Netscape Bookmarks to IE Favorites

BOOL    RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL    GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);

BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL        ConvertBookmarks(char * szFavoritesDir, HANDLE hFile, HINSTANCE hInstWithStr);
MyEntryType   NextFileEntry(char ** ppStr, char ** ppToken);
BOOL        GetData(char ** ppData, HANDLE hFile);
void        RemoveInvalidFileNameChars(char * pBuf);
BOOL        CreateDir(char *pDirName);
BOOL        CloseDir(void);
BOOL        CreateBookmark(char *pBookmarkName);
BOOL        GetPathFromRegistry(LPSTR szPath, UINT cbPath, HKEY theHKEY, LPSTR szKey, LPSTR szVName);
BOOL        GetNavBkMkDir( LPSTR lpszDir, int isize );


#endif // _CONVERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\makefile.inc ===
$(O)\ieuinit.inf : ..\..\ie40\inf\ieuinit.inx
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P) /EP $**
<<NOKEEP
!if "$(BUILD_PRODUCT)" == "NT"
    @$(C_PREPROCESSOR_NAME) /DNT5 @<<$(CL_RSP) /Tc$** > $@
!else
    @$(C_PREPROCESSOR_NAME)       @<<$(CL_RSP) /Tc$** > $@
!endif
$(CPPXX: =
)
<<NOKEEP

$(O)\homepage.inf : makefile.inc
    type << > $@
[Version]
Signature="$$CHICAGO$$"
AdvancedINF=2.5

[DefaultInstall]
ComponentName=IEHomePageInfo
ComponentVersion=6.0
AddReg=RegUpdateHelp
DelReg=StartHomePage.Remove
UpdateInis=RemoveUpdate.Link
;PreRollBack=UpdateHelpKey.Remove

[DefaultInstall.NT]
ComponentName=IEHomePageInfo
ComponentVersion=6.0
AddReg=RegUpdateHelp
DelReg=StartHomePage.Remove
;PreRollBack=UpdateHelpKey.Remove

[!StartHomePage]
HKCU,"Software\Microsoft\Internet Explorer\Main","First Home Page",,%FirstHomePage%

[StartHomePage.Remove]
HKCU,"Software\Microsoft\Internet Explorer\Main","First Home Page"

[RemoveUpdate.Link]
setup.ini, progman.groups,,"IE_INTERNET=%Browser_suite%"
setup.ini, IE_INTERNET,, """%SHORTCUT_UPDATE%"""

[Strings]
FirstHomePage="http://www.microsoft.com/isapi/redir.dll?prd={SUB_PRD}&ar=runonce&pver={SUB_PVER}&plcid={SUB_CLSID}"
Browser_suite="Internet Explorer"
SHORTCUT_UPDATE="Update Product"
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\path.cpp ===
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"

#ifdef WINNT_ENV
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()
#endif

#ifndef NORM_STOP_ON_NULL     // Until we sync up with nt headers again...
#define NORM_STOP_ON_NULL         0x10000000   /* stop at the null termination */
#endif

#define StrIntlEqNI( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)

static const TCHAR c_szPATH[] = TEXT("PATH");
static const TCHAR c_szEllipses[] = TEXT("...");
static const TCHAR c_szColonSlash[] = TEXT(":\\");
//
// Inline function to check for a double-backslash at the
// beginning of a string
//

static __inline BOOL DBL_BSLASH(LPCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}

BOOL RunningOnNT(void)
{
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&VerInfo);

    return (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

// rips the last part of the path off including the backslash
//      C:\foo      -> C:\      ;
//      C:\foo\bar  -> C:\foo
//      C:\foo\     -> C:\foo
//      \\x\y\x     -> \\x\y
//      \\x\y       -> \\x
//      \\x         -> ?? (test this)
//      \foo        -> \  (Just the slash!)
//
// in/out:
//      pFile   fully qualified path name
// returns:
//      TRUE    we stripped something
//      FALSE   didn't strip anything (root directory case)
//

BOOL PathRemoveFileSpec(LPTSTR pFile)
{
    LPTSTR pT;
    LPTSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == TEXT('\\'))
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == TEXT(':')) {   // skip ":\" so we don't
            if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == TEXT('\\'))) {
        // Is it just a '\'?
        if (*(pT+1) != TEXT('\0')) {
            // Nope.
            *(pT+1) = TEXT('\0');
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}


// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo


LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
            && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}

//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
// Cond:    Note that SHELL32 implements its own copy of this
//          function.

BOOL PathIsUNC(LPCTSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}



//---------------------------------------------------------------------------
// Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has
// a drive letter, otherwise returns -1.
//
//
// Cond:    Note that SHELL32 implements its own copy of this
//          function.

int PathGetDriveNumber(LPCTSTR lpsz)
{
    if (!IsDBCSLeadByte(lpsz[0]) && lpsz[1] == TEXT(':'))
    {
        if (lpsz[0] >= TEXT('a') && lpsz[0] <= TEXT('z'))
            return (lpsz[0] - TEXT('a'));
        else if (lpsz[0] >= TEXT('A') && lpsz[0] <= TEXT('Z'))
            return (lpsz[0] - TEXT('A'));
    }
    return -1;
}

//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path to a server only (no share name).
//
// TRUE
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\\foo\bar"
//      "\foo"
//      "foo"
//      "c:\foo"

BOOL PathIsUNCServer(LPCTSTR pszPath)
{
    if (DBL_BSLASH(pszPath))
    {
        int i = 0;
        LPTSTR szTmp;

        for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = CharNext(szTmp) )
        {
            if (*szTmp==TEXT('\\'))
            {
                i++;
            }
        }

       return (i == 2);
    }

    return FALSE;
}



/*----------------------------------------------------------
Purpose: Determines if pszPath is a directory.  "C:\" is
         considered a directory too.

Returns: TRUE if it is

Cond:    Note that SHELL32 implements its own copy of this
         function.
*/
BOOL PathIsDirectory(LPCTSTR pszPath)
{
    DWORD dwAttribs;

    // SHELL32's PathIsDirectory also handles server/share
    // paths, but calls WNet APIs, which we cannot call.

    if (PathIsUNCServer(pszPath))
    {
        return FALSE;
    }
    else
    {
        dwAttribs = GetFileAttributes(pszPath);
        if (dwAttribs != (DWORD)-1)
            return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
    }

    return FALSE;
}

// check if a path is a root
//
// returns:
//  TRUE for "\" "X:\" "\\foo\asdf" "\\foo\"
//  FALSE for others

BOOL PathIsRoot(LPCTSTR pPath)
{
    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, c_szColonSlash))                  // "X:\" case
            return TRUE;
    }

    if ((*pPath == TEXT('\\')) && (*(pPath + 1) == 0))        // "\" case
        return TRUE;

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = CharNext(p)) {
            if (*p == TEXT('\\') && (++cBackslashes > 1))
               return FALSE;   /* not a bare UNC name, therefore not a root dir */
        }
        return TRUE;    /* end of string with only 1 more backslash */
                        /* must be a bare UNC, which looks like a root dir */
    }
    return FALSE;
}

// Removes a trailing backslash from a path
//
// in:
//  lpszPath    (A:\, C:\foo\, etc)
//
// out:
//  lpszPath    (A:\, C:\foo, etc)
//
// returns:
//  ponter to NULL that replaced the backslash
//  or the pointer to the last character if it isn't a backslash.

LPTSTR PathRemoveBackslash( LPTSTR lpszPath )
{
    int len = lstrlen(lpszPath)-1;
    if (IsDBCSLeadByte(*CharPrev(lpszPath,lpszPath+len+1)))
        len--;

    if (!PathIsRoot(lpszPath) && lpszPath[len] == TEXT('\\'))
        lpszPath[len] = TEXT('\0');

    return lpszPath + len;

}

// find the next slash or null terminator

static LPCTSTR StrSlash(LPCTSTR psz)
{
    for (; *psz && *psz != TEXT('\\'); psz = CharNext(psz));

    return psz;
}


/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) {
    int retval;
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

    if ( RunningOnNT() )
    {
        // On NT we can tell CompareString to stop at a '\0' if one is found before nChar chars
        //
        dwFlags |= NORM_STOP_ON_NULL;
    }
    else if (nChar != -1)
    {
        // On Win9x we have to do the check manually
        //
        LPCSTR psz1, psz2;
        int cch = 0;

        psz1 = lpString1;
        psz2 = lpString2;

        while( *psz1 != '\0' && *psz2 != '\0' && cch < nChar) {
            psz1 = CharNextA(psz1);
            psz2 = CharNextA(psz2);

            cch = min((int)(psz1 - lpString1), (int)(psz2 - lpString2));
        }

        // add one in for terminating '\0'
        cch++;

        if (cch < nChar) {
            nChar = cch;
        }
    }

    retval = CompareStringA( GetThreadLocale(),
                             dwFlags,
                             lpString1,
                             nChar,
                             lpString2,
                             nChar );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( LOCALE_SYSTEM_DEFAULT,
                                 dwFlags,
                                 lpString1,
                                 nChar,
                                 lpString2,
                                 nChar );
    }

    return (retval == 2);

}


//
// in:
//      pszFile1 -- fully qualified path name to file #1.
//      pszFile2 -- fully qualified path name to file #2.
//
// out:
//      pszPath  -- pointer to a string buffer (may be NULL)
//
// returns:
//      length of output buffer not including the NULL
//
// examples:
//      c:\win\desktop\foo.txt
//      c:\win\tray\bar.txt
//      -> c:\win
//
//      c:\                                ;
//      c:\                                ;
//      -> c:\  NOTE, includes slash
//
// Returns:
//      Length of the common prefix string usually does NOT include
//      trailing slash, BUT for roots it does.
//

int
PathCommonPrefix(
    LPCTSTR pszFile1,
    LPCTSTR pszFile2,
    LPTSTR  pszPath)
{
    LPCTSTR psz1, psz2, pszNext1, pszNext2, pszCommon;
    int cch;

    pszCommon = NULL;
    if (pszPath)
        *pszPath = TEXT('\0');

    psz1 = pszFile1;
    psz2 = pszFile2;

    // special cases for UNC, don't allow "\\" to be a common prefix

    if (DBL_BSLASH(pszFile1))
    {
        if (!DBL_BSLASH(pszFile2))
            return 0;

        psz1 = pszFile1 + 2;
    }
    if (DBL_BSLASH(pszFile2))
    {
        if (!DBL_BSLASH(pszFile1))
            return 0;

        psz2 = pszFile2 + 2;
    }

    while (1)
    {
        //ASSERT(*psz1 != TEXT('\\') && *psz2 != TEXT('\\'));

        pszNext1 = StrSlash(psz1);
        pszNext2 = StrSlash(psz2);

        cch = (int)(pszNext1 - psz1);

        if (cch != (pszNext2 - psz2))
            break;      // lengths of segments not equal

        if (StrIntlEqNI(psz1, psz2, cch))
            pszCommon = pszNext1;
        else
            break;

        //ASSERT(*pszNext1 == TEXT('\0') || *pszNext1 == TEXT('\\'));
        //ASSERT(*pszNext2 == TEXT('\0') || *pszNext2 == TEXT('\\'));

        if (*pszNext1 == TEXT('\0'))
            break;

        psz1 = pszNext1 + 1;

        if (*pszNext2 == TEXT('\0'))
            break;

        psz2 = pszNext2 + 1;
    }

    if (pszCommon)
    {
        cch = (int)(pszCommon - pszFile1);

        // special case the root to include the slash
        if (cch == 2)
        {
            //ASSERT(pszFile1[1] == TEXT(':'));
            cch++;
        }
    }
    else
        cch = 0;

    if (pszPath)
    {
        CopyMemory(pszPath, pszFile1, cch * sizeof(TCHAR));
        pszPath[cch] = TEXT('\0');
    }

    return cch;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if pszPrefix is the full prefix of pszPath.

Returns:
Cond:    --
*/
BOOL PathIsPrefix( LPCTSTR  pszPrefix, LPCTSTR  pszPath)
{
    int cch = PathCommonPrefix(pszPath, pszPrefix, NULL);

    return (lstrlen(pszPrefix) == cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlguid.h>
#include "resource.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\resource.h ===
#define IDS_CSIDL_PERSONAL_L    1
#define IDS_CSIDL_FAVORITES_L   2
#define IDS_CSIDL_APPDATA_L     3
#define IDS_CSIDL_CACHE_L       4
#define IDS_CSIDL_COOKIES_L     5
#define IDS_CSIDL_HISTORY_L     6
#define IDS_CSIDL_DESKTOP_L     7
#define IDS_CSIDL_RECENT_L      8
#define IDS_CSIDL_NETHOOD_L     9

#define IDS_NS_BOOKMARKS_DIR	10
#define IDS_ERR_NOFOUNDINF	11
#define	IDS_APPNAME		12
#define IDS_IE20_STR		13
#define IDS_IE_LNK		14
#define IDS_IE_APPNAME		15

#define IDS_MYDOCS_SHORTCUT     20
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\reg.cpp ===
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
DWORD
SDSQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize;
    DWORD dwType;
    LPSTR lpsz;

    if (pvData) 
    {
        // Trying to get back data

        cbSize = *pcbData;     // Size of output buffer
        dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                                 (LPBYTE)pvData, &cbSize);

        // Normally, we'd be done with this.  But do some extra work
        // if this is an expandable string (something that has system
        // variables in it), or if we need to pad the buffer.

        if (NO_ERROR == dwRet)
        {
            // Note: on Win95, RegSetValueEx will always write the 
            // full string out, including the null terminator.  On NT,
            // it won't unless the write length was specified.  
            // Hence, we have the following check.

            // Pad the buffer, in case the string didn't have a null
            // terminator when it was stored?
            if (REG_SZ == dwType)
            {
                // Yes
                if (cbSize < *pcbData) 
                {
                    LPSTR lpszData = (LPSTR)pvData;
                    lpszData[cbSize] = '\0';
                }
            }
            // Expand the string?
            else if (REG_EXPAND_SZ == dwType)
            {
                // Yes

                // Use a temporary buffer to expand
                lpsz = (LPSTR)LocalAlloc(LPTR, *pcbData);    
                if ( !lpsz )
                    return ERROR_OUTOFMEMORY;

                cbSize = ExpandEnvironmentStringsA((LPSTR)pvData, lpsz, *pcbData);

                // BUGBUG:: NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlen(lpsz) + 1;
                if (cbSize > 0 && cbSize <= *pcbData) 
                    lstrcpynA((LPSTR)pvData, lpsz, *pcbData);
                else
                    dwRet = GetLastError();

                LocalFree(lpsz);

                // Massage dwType so that callers always see REG_SZ
                dwType = REG_SZ;
            }
        }
    } 
    else 
    {
        // Trying to find out how big of a buffer to use

        cbSize = 0;
        dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                                 NULL, &cbSize);
        if (NO_ERROR == dwRet && REG_EXPAND_SZ == dwType)
        {
            CHAR szBuff[1];

            // Find out the length of the expanded string
            //
            lpsz = (LPSTR)LocalAlloc(LPTR, cbSize);
            if (!lpsz)
                return ERROR_OUTOFMEMORY;

            dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, NULL,
                                     (LPBYTE)lpsz, &cbSize);

            if (NO_ERROR == dwRet)
            {
                cbSize = ExpandEnvironmentStringsA(lpsz, szBuff, ARRAYSIZE(szBuff));

                // BUGBUG:: NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlen(lpsz) + 1;
            }

            LocalFree(lpsz);

            // Massage dwType so that callers always see REG_SZ
            dwType = REG_SZ;
        }
    }

    if (pdwType)
        *pdwType = dwType;

    if (pcbData)
        *pcbData = cbSize;

    return dwRet;
}

//  Copied from nt\shell\shlwapi\reg.c
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        if (pszSubKey)
        {
            dwRet = RegDeleteKeyA(hkey, pszSubKey);
        }
        else
        {
            //  we want to delete all the values by hand
            cchSubKeyName = ARRAYSIZE(szSubKeyName);
            while (ERROR_SUCCESS == RegEnumValueA(hkey, 0, szSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValueA(hkey, szSubKeyName))
                    break;
                    
                cchSubKeyName = ARRAYSIZE(szSubKeyName);
            }
        }
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iedetect.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\utils.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  utils.h
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _UTILS_H_
#define _UTILS_H_



#define IsSpace(c)  ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
#define IsAlpha(c)  ( ((c) >= 'A'  &&  (c) <= 'Z') || ((c) >= 'a'  &&  (c) <= 'z'))

BOOL PathRemoveFileSpec(LPTSTR pFile);
LPTSTR PathFindFileName(LPCTSTR pPath);
BOOL PathIsUNC(LPCTSTR pszPath);
int PathGetDriveNumber(LPCTSTR lpsz);
BOOL PathIsUNCServer(LPCTSTR pszPath);
BOOL PathIsDirectory(LPCTSTR pszPath);
BOOL PathIsRoot(LPCTSTR pPath);
LPTSTR PathRemoveBackslash( LPTSTR lpszPath );
BOOL PathIsPrefix( LPCTSTR  pszPrefix, LPCTSTR  pszPath);

DWORD
SDSQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData);


DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey);

#endif //  _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\ime.cpp ===
#include "pch.h"
#include "iedetect.h"

DWORD WINAPI DetectPrimaryLang(DETECTION_STRUCT *pDet, UINT cpID);
DWORD WINAPI DetectLCID(DETECTION_STRUCT *pDet, LCID lcid);
BOOL DetectCicero();

DWORD WINAPI DetectKoreanIME(DETECTION_STRUCT *pDet)
{
    if(DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 1042);
}

DWORD WINAPI DetectJapaneseIME(DETECTION_STRUCT *pDet)
{
    if (DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 1041);
}

DWORD WINAPI DetectTraditionalChineseIME(DETECTION_STRUCT *pDet)
{
    if (DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 1028);
}

DWORD WINAPI DetectSimplifiedChineseIME(DETECTION_STRUCT *pDet)
{
    if (DetectCicero())
        return DET_NEWVERSIONINSTALLED;
    else
        return DetectLCID(pDet, 2052);
}

// Returns true if msctf.dll is installed on system
BOOL DetectCicero()
{
    char szFile[MAX_PATH] = {0};
    char szRenameFile[MAX_PATH] = {0}; 
    DWORD dwInstalledVer, dwInstalledBuild;

    GetSystemDirectory(szFile, sizeof(szFile));
    AddPath(szFile, "msctf.dll");
    ReadFromWininitOrPFRO(szFile, szRenameFile);
    if (*szRenameFile != '\0')
        GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
    else
        GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
   
    return (dwInstalledVer != 0);
}

DWORD WINAPI DetectLCID(DETECTION_STRUCT *pDet, LCID lcid)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (GetSystemDefaultLCID() == lcid)
    {
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}

DWORD WINAPI DetectKoreanLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 949);
}

DWORD WINAPI DetectJapaneseLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 932);
}

DWORD WINAPI DetectSimpChineseLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 936);
}

DWORD WINAPI DetectTradChineseLangPack(DETECTION_STRUCT *pDet)
{
    return DetectPrimaryLang(pDet, 950);
}


DWORD WINAPI DetectPrimaryLang(DETECTION_STRUCT *pDet, UINT cpID)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (GetACP() == cpID)
    {
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\iedetect.h ===
#ifndef _IEDETECT_H
#define _IEDETECT_H
#include <inseng.h> 

extern HINSTANCE g_hInstance;
extern HANDLE g_hHeap;

// from inseng, cifcomp.h
#define ISINSTALLED_YES      1
#define ISINSTALLED_NO       0

#define COMPONENT_KEY "Software\\Microsoft\\Active Setup\\Installed Components"
#define IEXPLORE_APPPATH_KEY REGSTR_PATH_APPPATHS "\\iexplore.exe"

#define IE_KEY        "Software\\Microsoft\\Internet Explorer"


#define DEFAULT_LOCALE      "en"
#define ISINSTALLED_KEY     "IsInstalled"
#define LOCALE_KEY          "Locale"
#define VERSION_KEY         "Version"
#define BUILD_KEY           "Build"
#define QFE_VERSION_KEY     "QFEVersion"


#define IE_3_MS_VERSION 0x00040046
#define IE_4_MS_VERSION 0x00040047
// Build number 1712.0 (IE4.0 RTW)
#define IE_4_LS_VERSION 0x06B00000

// Version numver 5.0
#define IE_5_MS_VERSION 0x00050000
#define IE_5_LS_VERSION 0x00000000

// Version numver 6.0
#define IE_6_MS_VERSION 0x00060000
#define IE_6_LS_VERSION 0x00000000

// Note: for now we only allow 10 characters in the cPath part of the structure.
// If more characters are needed change the amount below.
typedef struct _DETECT_FILES
{
    char    cPath[10];
    char    szFilename[13];
    DWORD   dwMSVer;
    DWORD   dwLSVer;
} DETECT_FILES;

// From utils.cpp
int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2);
void ConvertVersionStrToDwords(LPSTR pszVer, char cDelimiter, LPDWORD pdwVer, LPDWORD pdwBuild);
DWORD GetStringField(LPSTR szStr, UINT uField, char cDelimiter, LPSTR szBuf, UINT cBufSize);
DWORD GetIntField(LPSTR szStr, char cDelimiter, UINT uField, DWORD dwDefault);
LPSTR FindChar(LPSTR pszStr, char ch);
BOOL FRunningOnNT(void);
DWORD CompareVersions(DWORD dwAskVer, DWORD dwAskBuild, DWORD dwInstalledVer, DWORD dwInstalledBuild);
BOOL GetVersionFromGuid(LPSTR pszGuid, LPDWORD pdwVer, LPDWORD pdwBuild);
BOOL CompareLocal(LPCSTR pszGuid, LPCSTR pszLocal);
VOID ReadFromWininitOrPFRO(PCSTR pcszKey, PSTR pszValue);
DWORD CheckFile(DETECT_FILES Detect_Files);
DWORD WINAPI DetectFile(DETECTION_STRUCT *pDet, LPSTR pszFilename);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\iedetect.cpp ===
#include "pch.h"
#include "iedetect.h"
#include "sdsutils.h"

HINSTANCE g_hInstance = NULL;
HANDLE g_hHeap = NULL;


DWORD MyDetectInternetExplorer(LPSTR guid, LPSTR pLocal, 
                               DWORD dwAskVer, DWORD dwAskBuild, 
                               LPDWORD pdwInstalledVer, LPDWORD pdwInstalledBuild)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    char    szValue[MAX_PATH];
    HKEY    hKey = NULL;
    DWORD   dwSize;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = (DWORD)-1;
    dwInstalledBuild  = (DWORD)-1;
    if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, IE_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szValue);
        if(RegQueryValueEx(hKey, VERSION_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            // Everything is fine. This should be IE4 or greater.
            ConvertVersionStrToDwords(szValue, '.', &dwInstalledVer, &dwInstalledBuild);
            dwRet = CompareVersions(dwAskVer, dwAskBuild, dwInstalledVer, dwInstalledBuild);
        }
        else if(RegQueryValueEx(hKey, BUILD_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            // See if we find a IE3 entry.
            ConvertVersionStrToDwords(szValue, '.', &dwInstalledVer, &dwInstalledBuild);
            // Now generate a IE3 version number.
            dwInstalledBuild = (DWORD)HIWORD(dwInstalledVer);
            dwInstalledVer = IE_3_MS_VERSION;        // 4.70 IE3 major version
            dwRet = CompareVersions(dwAskVer, dwAskBuild, dwInstalledVer, dwInstalledBuild);
        }
        RegCloseKey(hKey);
    }
    // If we could not find anything, check the AppPath for Iexplore.exe
    if (dwInstalledVer == (DWORD)-1)
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, IEXPLORE_APPPATH_KEY, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            if (RegQueryValueEx(hKey, NULL, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
            {
                GetVersionFromFile(szValue, &dwInstalledVer, &dwInstalledBuild, TRUE);
                if ((dwInstalledVer != 0) && (dwInstalledBuild != 0))
                    dwRet = CompareVersions(dwAskVer, dwAskBuild, dwInstalledVer, dwInstalledBuild);
            }
            RegCloseKey(hKey);
        }
    }
    if (pdwInstalledVer && pdwInstalledBuild)
    {
        *pdwInstalledVer = dwInstalledVer;
        *pdwInstalledBuild = dwInstalledBuild;
    }
    return dwRet;
}


DWORD WINAPI DetectInternetExplorer(DETECTION_STRUCT *pDet)
{
   return(MyDetectInternetExplorer(pDet->pszGUID, pDet->pszLocale, pDet->dwAskVer, pDet->dwAskBuild,
                                   pDet->pdwInstalledVer, pDet->pdwInstalledBuild));
}


DWORD WINAPI DetectDCOM(DETECTION_STRUCT *pDet)
{
    DWORD dwRet = DET_NOTINSTALLED;
    DWORD dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = (DWORD) -1;
    dwInstalledBuild = (DWORD) -1;
    if (FRunningOnNT())
    {
        // On NT assume DCOM is installed;
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        char szFile[MAX_PATH];
        char szRenameFile[MAX_PATH];
        GetSystemDirectory(szFile, sizeof(szFile));
        AddPath(szFile, "ole32.dll");
        ReadFromWininitOrPFRO(szFile, szRenameFile);
        if (*szRenameFile != '\0')
            GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
        else
            GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

        if (dwInstalledVer != 0)
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

LPSTR g_szMFCFiles[] = { "MFC40.DLL", "MSVCRT40.DLL", "OLEPRO32.DLL", NULL}; 

DWORD WINAPI DetectMFC(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    LPSTR   lpTmp;
    char    szFile[MAX_PATH];
    BOOL    bInstallMFC = FALSE;
    UINT    uiIndex = 0;

    lpTmp = g_szMFCFiles[uiIndex];
    while (!bInstallMFC && lpTmp)
    {
        GetSystemDirectory(szFile, sizeof(szFile));
        AddPath(szFile, lpTmp);

        if (GetFileAttributes(szFile) == 0xFFFFFFFF)
            bInstallMFC = TRUE;
        uiIndex++;
        lpTmp = g_szMFCFiles[uiIndex];
    }
    if (bInstallMFC)
        dwRet = DET_NOTINSTALLED;
    else
        dwRet = DET_INSTALLED;

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = (DWORD)-1;
        *(pDet->pdwInstalledBuild) = (DWORD)-1;
    }
    return dwRet;
}

// Detection for MediaPlayer, called DirectShow in IE4
//
// For IE lite we want to ask for DirectShow version 2.0. Unfortunatly
// the version in the registry and the versino of the files don't reflect this.
// Also the version in the CIF and the version of the files don't fit anymore 
// in IE5.Therefore the code below spezial cases the 2.0 case, which ie lite
// should ask for. All other modes are asking for the version of the CIF and
// the detection code has to get the version from the registry.
//
#define DIRECTSHOW_IE4_VER   0x00050001
#define DIRECTSHOW_IE4_BUILD 0x00120400

DWORD WINAPI DetectDirectShow(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwVerDevenum, dwBuildDevenum;
    DWORD   dwVerQuartz, dwBuildQuartz;
    DWORD   dwInstalledVer, dwInstalledBuild;
    char    szFile[MAX_PATH];

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->dwAskVer == 0x00020000)
    {
        // Called for ie-lite
        GetSystemDirectory( szFile, sizeof(szFile) );
        AddPath(szFile, "quartz.dll");
        if (SUCCEEDED(GetVersionFromFile(szFile, &dwVerQuartz, &dwBuildQuartz, TRUE)))
        {
            GetSystemDirectory( szFile, sizeof(szFile) );
            AddPath(szFile, "devenum.dll");
            if (SUCCEEDED(GetVersionFromFile(szFile, &dwVerDevenum, &dwBuildDevenum, TRUE)))
            {
                // Both files found.
                if ((dwVerQuartz == dwVerDevenum) &&
                    (dwBuildQuartz == dwBuildDevenum) &&
                    ((dwVerQuartz > DIRECTSHOW_IE4_VER) ||
                     ((dwVerQuartz == DIRECTSHOW_IE4_VER) && (dwBuildQuartz >= DIRECTSHOW_IE4_BUILD))) )
                {
                    dwRet = DET_INSTALLED;
                }
            }
        }
    }
    else
    {
        // If we got a version number passed in, check against the installed version from
        // the 'Installed component' branch for that GUID.
        
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

#define DIRECTXD3_MSVER 0x00040002
#define DIRECTXD3_LSVER 0x0000041E
#define DIRECTXDD_MSVER 0x00040004
#define DIRECTXDD_LSVER 0x00000044

DETECT_FILES DirectX_Win[] = 
        { {"S", "d3dim.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3drg16f.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3drgbf.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3drm.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "d3dxof.dll", DIRECTXD3_MSVER, DIRECTXD3_LSVER},
          {"S", "ddhelp.exe", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"S", "ddraw.dll", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"S", "ddraw16.dll", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"S", "dsound.dll", DIRECTXDD_MSVER, DIRECTXDD_LSVER},
          {"\0", "", 0, 0} };

DWORD WINAPI DetectDirectX(DETECTION_STRUCT *pDet)
{
    int     iIndex = 0;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (FRunningOnNT())
    {
        // On NT assume DirectXMini is newer.
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else
    {
        if (pDet->dwAskVer == 0)
        {
            // Call for ie-lite,
            // just check if IE4 is installed.
            dwRet = MyDetectInternetExplorer(pDet->pszGUID, pDet->pszLocale, 
                                            IE_4_MS_VERSION, 0, 
                                            &dwInstalledVer, &dwInstalledBuild);
            if (dwRet == DET_OLDVERSIONINSTALLED)
                dwRet = DET_NOTINSTALLED;
            if (dwRet == DET_NEWVERSIONINSTALLED)
                dwRet = DET_INSTALLED;
        }
        else
        {
            do 
            {
                if (DirectX_Win[iIndex].cPath[0])
                    dwRet = CheckFile(DirectX_Win[iIndex]);
                iIndex++;
            } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (DirectX_Win[iIndex].cPath[0] != '\0'));
        }
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

#define DDRAWEX_MSVER 0x00040047
#define DDRAWEX_LSVER 0x04580000
DETECT_FILES DDrawEx[] = 
        { {"S", "ddrawex.dll", DDRAWEX_MSVER, DDRAWEX_LSVER },
          {"\0", "", 0, 0} };
DWORD WINAPI DetectDirectDraw(DETECTION_STRUCT *pDet)
{
    int     iIndex = 0;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    do 
    {
        if (DDrawEx[iIndex].cPath[0])
            dwRet = CheckFile(DDrawEx[iIndex]);
        iIndex++;
    } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (DDrawEx[iIndex].cPath[0] != '\0'));

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

DWORD WINAPI DetectICW(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->dwAskVer == 0)
    {
        // Call for ie-lite,
        // just check if IE4 is installed.
        // If we don't get a version number pass in, assume we only check for default browser
        if (IsIEDefaultBrowser())
            dwRet = DET_INSTALLED;
    }
    else
    {
        // If we got a version number passed in, check against the installed version from
        // the 'Installed component' branch for that GUID.
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}

// NT version of setupapi.dll (4.0.1381.10)
#define SETUPAPI_NT_MSVER   0x00040000
#define SETUPAPI_NT_LSVER   0x0565000A
// Win9x version of setupapi.dll (5.0.1453.7)
#define SETUPAPI_WIN_MSVER   0x00050000
#define SETUPAPI_WIN_LSVER   0x05AD0007    
// Win9x version of cfgmgr32.dll (4.10.0.1422)
#define CFGMGR32_WIN_MSVER   0x0004000a
#define CFGMGR32_WIN_LSVER   0x0000058e
// minimal Cabinet.dll version (1.0.601.4)
#define CABINET_MSVER   0x00010000
#define CABINET_LSVER   0x02590004
// Version of w95inf16.dll
#define W95INF16_MSVER  0x00040047
#define W95INF16_LSVER  0x02c00000
// Version of w95inf32.dll
#define W95INF32_MSVER  0x00040047
#define W95INF32_LSVER  0x00100000
// Version of regsvr32.exe
#define REGSVR32_MSVER  0x00050000
#define REGSVR32_LSVER  0x06310001

// Note: for now we only allow 10 characters in the cPath part of the structure.
// If more characters are needed change the amount below.
//
DETECT_FILES Gensetup_W95[] = 
        { {"S", "cabinet.dll", CABINET_MSVER, CABINET_LSVER },
          {"S", "setupapi.dll", SETUPAPI_WIN_MSVER, SETUPAPI_WIN_LSVER}, 
          {"S", "cfgmgr32.dll", CFGMGR32_WIN_MSVER, CFGMGR32_WIN_LSVER}, 
          {"S", "regsvr32.exe", REGSVR32_MSVER, REGSVR32_LSVER }, 
          {"S", "w95inf16.dll", W95INF16_MSVER, W95INF16_LSVER }, 
          {"S", "w95inf32.dll", W95INF32_MSVER, W95INF32_LSVER }, 
          {"W,C", "extract.exe", -1, -1 }, 
          {"W,C", "iextract.exe", -1, -1 }, 
          {"\0", "", 0, 0} };

DETECT_FILES Gensetup_NT[] = 
        { {"S", "cabinet.dll", CABINET_MSVER, CABINET_LSVER },
          {"S", "setupapi.dll", SETUPAPI_NT_MSVER, SETUPAPI_NT_LSVER}, 
          {"S", "regsvr32.exe", REGSVR32_MSVER, REGSVR32_LSVER }, 
          {"W", "extract.exe", -1, -1 }, 
          {"W", "iextract.exe", -1, -1 }, 
          {"\0", "", 0, 0} };

DWORD WINAPI DetectGenSetup(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    int     iIndex = 0;
    DETECT_FILES *Detect_Files;
    if (FRunningOnNT())
        Detect_Files = Gensetup_NT;
    else
        Detect_Files = Gensetup_W95;

    do 
    {
        if (Detect_Files[iIndex].cPath[0])
            dwRet = CheckFile(Detect_Files[iIndex]);
        iIndex++;
    } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (Detect_Files[iIndex].cPath[0] != '\0'));

    return dwRet;
}


DWORD WINAPI DetectOfflinePkg(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    char szFile[MAX_PATH];
    char szRenameFile[MAX_PATH];
    
    dwInstalledVer = dwInstalledBuild = (DWORD)-1;

    // If we got a version number passed in, check against the installed version from
    // the 'Installed component' branch for that GUID.
    if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
        dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);

    if (dwRet == DET_NOTINSTALLED)
    {
        // check if webcheck.dll is on the users machine, we should update it.
        GetSystemDirectory( szFile, sizeof(szFile) );
        AddPath(szFile, "webcheck.dll");
        ReadFromWininitOrPFRO(szFile, szRenameFile);
        if (*szRenameFile != '\0')
            GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
        else
            GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

        if (dwInstalledVer != 0)
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }

    return dwRet;
}


DWORD WINAPI DetectJapaneseFontPatch(DETECTION_STRUCT *pDet)
{
    DWORD   dwInstalledVer, dwInstalledBuild;
    DWORD   dwRet = DET_NEWVERSIONINSTALLED;
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = -1;
        *(pDet->pdwInstalledBuild) = -1;
    }
    if (GetSystemDefaultLCID() == 1041)
    {
        // If we are running locale Japanese, Install the font.
        dwRet = DET_NOTINSTALLED;
    }
    // If we are running on a Japanese system, see if the component is installed using the GUID
    if (dwRet == DET_NOTINSTALLED)
    {
        if (GetVersionFromGuid(pDet->pszGUID, pDet->pdwInstalledVer, pDet->pdwInstalledBuild))
        {
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, *(pDet->pdwInstalledVer), *(pDet->pdwInstalledBuild));
        }
    }
    return dwRet;
}

DWORD WINAPI DetectAOLSupport(DETECTION_STRUCT *pDet)
{
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->dwAskVer == 0)
    {
        // Call for ie-lite,
        char szFile[MAX_PATH];

        GetSystemDirectory( szFile, sizeof(szFile) );
        AddPath(szFile, "jgaw400.dll");
        // See if one of the AOL support files exist.
        if (GetFileAttributes(szFile) == 0xFFFFFFFF)
        {
            dwRet = DET_NOTINSTALLED;
        }
        else
        {
            dwRet = DET_INSTALLED;
        }
    }
    else
    {
        // If we got a version number passed in, check against the installed version from
        // the 'Installed component' branch for that GUID.
        if (GetVersionFromGuid(pDet->pszGUID, &dwInstalledVer, &dwInstalledBuild))
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
    }
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}


DWORD WINAPI DetectHTMLHelp(DETECTION_STRUCT *pDet)
{
    return DetectFile(pDet, "hhctrl.ocx");
}


DWORD WINAPI DetectOLEAutomation(DETECTION_STRUCT *pDet)
{
    return DetectFile(pDet, "oleaut32.dll");
}

DWORD WINAPI DetectJavaVM(DETECTION_STRUCT *pDet)
{
    HKEY hKey;
    DWORD   dwRet = DET_NOTINSTALLED;
    char    szValue[MAX_PATH];
    DWORD   dwValue = 0;
    DWORD   dwSize;

    lstrcpy(szValue, COMPONENT_KEY);
    AddPath(szValue, pDet->pszGUID);
    if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szValue, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        if(RegQueryValueEx(hKey, "IgnoreFile", 0, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue != 0)
            {
                dwRet = DET_INSTALLED;
                if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
                {
                    *(pDet->pdwInstalledVer) = (DWORD)-1;
                    *(pDet->pdwInstalledBuild) = (DWORD)-1;
                }
            }
        }
        else
            dwValue = 0;
        RegCloseKey(hKey);
    }

    if (dwValue == 0)
        dwRet = DetectFile(pDet, "msjava.dll");
    return dwRet;
}

#define MSAPSSPC_MSVER 0x00050000
#define MSAPSSPC_LSVER 0x00001E31 
DETECT_FILES msn_auth[] = 
        { {"S", "MSAPSSPC.dll", MSAPSSPC_MSVER, MSAPSSPC_LSVER },
          {"\0", "", 0, 0} };

DWORD WINAPI DetectMsn_Auth(DETECTION_STRUCT *pDet)
{
    int     iIndex = 0;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;
    
    do 
    {
        if (msn_auth[iIndex].cPath[0])
            dwRet = CheckFile(msn_auth[iIndex]);
        iIndex++;
    } while (((dwRet == DET_INSTALLED) || (dwRet == DET_NEWVERSIONINSTALLED)) && (msn_auth[iIndex].cPath[0] != '\0'));

    dwInstalledVer = dwInstalledBuild = (DWORD)-1;
    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}

DWORD WINAPI DetectTdc(DETECTION_STRUCT *pDet)
{
    return DetectFile(pDet, "tdc.ocx");
}

DWORD WINAPI DetectMDAC(DETECTION_STRUCT *pDet)
{
    char    szValue[MAX_PATH];
    HKEY    hKey = NULL;
    DWORD   dwSize;
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwInstalledVer, dwInstalledBuild;

    dwInstalledVer = (DWORD)-1;
    dwInstalledBuild  = (DWORD)-1;
    if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\DataAccess", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szValue);
        if (RegQueryValueEx(hKey, "FullInstallVer", NULL, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            ConvertVersionStrToDwords(szValue, '.', &dwInstalledVer, &dwInstalledBuild);
            dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
        }
        RegCloseKey(hKey);
    }

    // Did not find the registry key or entry,
    // need to do file comparison to detect MDAC version 2.1
    if (dwRet == DET_NOTINSTALLED)
    {
        char    szRenameFile[MAX_PATH];
        if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            if (RegQueryValueEx(hKey, "CommonFilesDir", NULL, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
            {
                AddPath(szValue, "system\\ado\\msado15.dll");
                ReadFromWininitOrPFRO(szValue, szRenameFile);
                if (*szRenameFile != '\0')
                    GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
                else
                    GetVersionFromFile(szValue, &dwInstalledVer, &dwInstalledBuild, TRUE);
                dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);
            }
            RegCloseKey(hKey);
        }


    }
    return dwRet;
}


STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
   DWORD dwThreadID;

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         g_hInstance = (HINSTANCE)hDll;
         g_hHeap = GetProcessHeap();
         DisableThreadLibraryCalls(g_hInstance);
         break;

      case DLL_PROCESS_DETACH:
         break;

      default:
         break;
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\pch.h ===
#include <Windows.h>
#include <Windowsx.h>
#include <shlobj.h>
#include <prsht.h>
#include <commctrl.h>
#include <regstr.h>
#include <wininet.h>
#include <objbase.h>
#include <shlwapi.h>
#include <urlmon.h>
#include <advpub.h>
#include "sdsutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iedetect\utils.cpp ===
#include "pch.h"
#include "iedetect.h"

#define VALID_SIGNATURE     0x5c3f3f5c              // string "\??\"
#define REMOVE_QUOTES       0x01
#define IGNORE_QUOTES       0x02

CONST CHAR g_cszWininit[]           = "wininit.ini";
CONST CHAR g_cszRenameSec[]         = "Rename";
CONST CHAR g_cszPFROKey[]           = REGSTR_PATH_CURRENT_CONTROL_SET "\\SESSION MANAGER";
CONST CHAR g_cszPFRO[]              = "PendingFileRenameOperations";

DWORD CheckFileEx(LPSTR szDir, DETECT_FILES Detect_Files);

DWORD GetStringField(LPSTR szStr, UINT uField, char cDelimiter, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, cDelimiter);
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, cDelimiter);
   while(pszBegin <= pszEnd && *pszBegin == ' ')
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);

   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

DWORD GetIntField(LPSTR szStr, char cDelimiter, UINT uField, DWORD dwDefault)
{
   char szNumBuf[16];

   if(GetStringField(szStr, uField, cDelimiter, szNumBuf, sizeof(szNumBuf)) == 0)
      return dwDefault;
   else
      return AtoL(szNumBuf);
}

int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2)
{
   int ret;

   if(pcszLoc1[0] == '*' || pcszLoc2[0] == '*')
      ret = 0;
   else
      ret = lstrcmpi(pcszLoc1, pcszLoc2);

   return ret;
}


void ConvertVersionStrToDwords(LPSTR pszVer, char cDelimiter, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   DWORD dwTemp1,dwTemp2;

   dwTemp1 = GetIntField(pszVer, cDelimiter, 0, 0);
   dwTemp2 = GetIntField(pszVer, cDelimiter, 1, 0);

   *pdwVer = (dwTemp1 << 16) + dwTemp2;

   dwTemp1 = GetIntField(pszVer, cDelimiter, 2, 0);
   dwTemp2 = GetIntField(pszVer, cDelimiter, 3, 0);

   *pdwBuild = (dwTemp1 << 16) + dwTemp2;
}

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
      pszStr++;
   return pszStr;
}

DWORD CompareVersions(DWORD dwAskVer, DWORD dwAskBuild, DWORD dwInstalledVer, DWORD dwInstalledBuild)
{
    DWORD dwRet = DET_NOTINSTALLED;
    if((dwInstalledVer == dwAskVer) && (dwInstalledBuild == dwAskBuild))
    {
        dwRet = DET_INSTALLED;
    }
    else if( (dwInstalledVer >  dwAskVer) ||
            ((dwInstalledVer == dwAskVer) && (dwInstalledBuild > dwAskBuild)) )

    {
        dwRet = DET_NEWVERSIONINSTALLED;
    }
    else if( (dwInstalledVer <  dwAskVer) ||
            ((dwInstalledVer == dwAskVer) && (dwInstalledBuild < dwAskBuild)) )

    {
        dwRet = DET_OLDVERSIONINSTALLED;
    }
    return dwRet;
}


BOOL FRunningOnNT(void)
{
    static BOOL fIsNT = 2 ;
    OSVERSIONINFO VerInfo;

    // If we have calculated this before just pass that back.
    // else find it now.
    //
    if (fIsNT == 2)
    {
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        GetVersionEx(&VerInfo);

        // Note: We don't check for Win32S on Win 3.1 here -- that should
        // have been a blocking check earlier in fn CheckWinVer().
        // Also, we don't check for failure on the above call as it
        // should succeed if we are on NT 4.0 or Win 9X!
        //
        fIsNT = (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    }

    return fIsNT;
}

BOOL GetVersionFromGuid(LPSTR pszGuid, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    HKEY hKey;
    char    szValue[MAX_PATH];
    DWORD   dwValue = 0;
    DWORD   dwSize;
    BOOL    bVersion = FALSE;

    if (pdwVer && pdwBuild)
    {
        *pdwVer = 0;
        *pdwBuild = 0;
        lstrcpy(szValue, COMPONENT_KEY);
        AddPath(szValue, pszGuid);
        if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szValue, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwValue);
            if(RegQueryValueEx(hKey, ISINSTALLED_KEY, 0, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
            {
                if (dwValue != 0)
                {
                    dwSize = sizeof(szValue);
                    if(RegQueryValueEx(hKey, VERSION_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
                    {
                        ConvertVersionStrToDwords(szValue, ',', pdwVer, pdwBuild);
                        bVersion = TRUE;
                    }
                }
            }
            RegCloseKey(hKey);
        }
    }
    return bVersion;
}

BOOL CompareLocal(LPCSTR pszGuid, LPCSTR pszLocal)
{
    HKEY hKey;
    char    szValue[MAX_PATH];
    DWORD   dwSize;
    BOOL    bLocal = FALSE;
    if (lstrcmpi(pszLocal, "*") == 0)
    {
        bLocal = TRUE;
    }
    else
    {
        lstrcpy(szValue, COMPONENT_KEY);
        AddPath(szValue, pszGuid);
        if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szValue, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            if(RegQueryValueEx(hKey, LOCALE_KEY, 0, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
            {
                bLocal = (lstrcmpi(szValue, pszLocal) == 0);
            }

            RegCloseKey(hKey);
        }
    }
    return bLocal;
}

PSTR GetNextField(PSTR *ppszData, PCSTR pcszDeLims, DWORD dwFlags)
// If (dwFlags & IGNORE_QUOTES) is TRUE, then look for any char in pcszDeLims in *ppszData.  If found,
// replace it with the '\0' char and set *ppszData to point to the beginning of the next field and return
// pointer to current field.
//
// If (dwFlags & IGNORE_QUOTES) is FALSE, then look for any char in pcszDeLims outside of balanced quoted sub-strings
// in *ppszData.  If found, replace it with the '\0' char and set *ppszData to point to the beginning of
// the next field and return pointer to current field.
//
// If (dwFlags & REMOVE_QUOTES) is TRUE, then remove the surrounding quotes and replace two consecutive quotes by one.
//
// NOTE: If IGNORE_QUOTES and REMOVE_QUOTES are both specified, then IGNORE_QUOTES takes precedence over REMOVE_QUOTES.
//
// If you just want to remove the quotes from a string, call this function as
// GetNextField(&pszData, "\"" or "'" or "", REMOVE_QUOTES).
//
// If you call this function as GetNextField(&pszData, "\"" or "'" or "", 0), you will get back the
// entire pszData as the field.
//
{
    PSTR pszRetPtr, pszPtr;
    BOOL fWithinQuotes = FALSE, fRemoveQuote;
    CHAR chQuote;

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == '\0')
        return NULL;

    for (pszRetPtr = pszPtr = *ppszData;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        if (!(dwFlags & IGNORE_QUOTES)  &&  (*pszPtr == '"'  ||  *pszPtr == '\''))
        {
            fRemoveQuote = FALSE;

            if (*pszPtr == *(pszPtr + 1))           // two consecutive quotes become one
            {
                pszPtr++;

                if (dwFlags & REMOVE_QUOTES)
                    fRemoveQuote = TRUE;
                else
                {
                    // if pcszDeLims is '"' or '\'', then *pszPtr == pcszDeLims would
                    // be TRUE and we would break out of the loop against the design specs;
                    // to prevent this just continue
                    continue;
                }
            }
            else if (!fWithinQuotes)
            {
                fWithinQuotes = TRUE;
                chQuote = *pszPtr;                  // save the quote char

                fRemoveQuote = dwFlags & REMOVE_QUOTES;
            }
            else
            {
                if (*pszPtr == chQuote)             // match the correct quote char
                {
                    fWithinQuotes = FALSE;
                    fRemoveQuote = dwFlags & REMOVE_QUOTES;
                }
            }

            if (fRemoveQuote)
            {
                // shift the entire string one char to the left to get rid of the quote char
                MoveMemory(pszPtr, pszPtr + 1, lstrlen(pszPtr));
            }
        }

        // BUGBUG: Is type casting pszPtr to UNALIGNED necessary? -- copied it from ANSIStrChr
        // check if pszPtr is pointing to one of the chars in pcszDeLims
        if (!fWithinQuotes  &&
            ANSIStrChr(pcszDeLims, (WORD) (IsDBCSLeadByte(*pszPtr) ? *((UNALIGNED WORD *) pszPtr) : *pszPtr)) != NULL)
            break;
    }

    // NOTE: if fWithinQuotes is TRUE here, then we have an unbalanced quoted string; but we don't care!
    //       the entire string after the beginning quote becomes the field

    if (*pszPtr)                                    // pszPtr is pointing to a char in pcszDeLims
    {
        *ppszData = CharNext(pszPtr);               // save the pointer to the beginning of next field in *ppszData
        *pszPtr = '\0';                             // replace the DeLim char with the '\0' char
    }
    else
        *ppszData = pszPtr;                         // we have reached the end of the string; next call to this function
                                                    // would return NULL

    return pszRetPtr;
}

PSTR GetDataFromWininitOrPFRO(PCSTR pcszWininit, HKEY hkPFROKey, PDWORD pdwLen)
{
    PSTR pszData, pszPtr;

    *pdwLen = 0;

    if (!FRunningOnNT())
    {
        HANDLE hFile;
        WIN32_FIND_DATA FileData;

        // find the size of pcszWininit
        if ((hFile = FindFirstFile(pcszWininit, &FileData)) != INVALID_HANDLE_VALUE)
        {
            *pdwLen = FileData.nFileSizeLow;
            FindClose(hFile);
        }

        if (*pdwLen == 0  ||  (pszData = (PSTR) LocalAlloc(LPTR, *pdwLen)) == NULL)
            return NULL;

        GetPrivateProfileSection(g_cszRenameSec, pszData, *pdwLen, pcszWininit);

        // replace the ='s by \0's
        // BUGBUG: assuming that all the lines in wininit.ini have the correct format, i.e., to=from
        for (pszPtr = pszData;  *pszPtr;  pszPtr += lstrlen(pszPtr) + 1)
            GetNextField(&pszPtr, "=", IGNORE_QUOTES);
    }
    else
    {
        if (hkPFROKey == NULL)
            return NULL;

        // get the length of value data
        RegQueryValueEx(hkPFROKey, g_cszPFRO, NULL, NULL, NULL, pdwLen);

        if (*pdwLen == 0  ||  (pszData = (PSTR) LocalAlloc(LPTR, *pdwLen)) == NULL)
            return NULL;

        // get the data
        RegQueryValueEx(hkPFROKey, g_cszPFRO, NULL, NULL, (PBYTE) pszData, pdwLen);
    }

    return pszData;
}

VOID ReadFromWininitOrPFRO(PCSTR pcszKey, PSTR pszValue)
{
    CHAR szShortName[MAX_PATH];
    CHAR szWininit[MAX_PATH];
    PSTR pszData, pszLine, pszFrom, pszTo;
    DWORD dwLen;
    HKEY hkPFROKey = NULL;

    if (!FRunningOnNT())
    {
        GetWindowsDirectory(szWininit, sizeof(szWininit));
        AddPath(szWininit, g_cszWininit);
    }
    else
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_cszPFROKey, 0, KEY_READ, &hkPFROKey);

    // return empty string if pcszKey could not be found
    *pszValue = '\0';

    if ((pszData = GetDataFromWininitOrPFRO(szWininit, hkPFROKey, &dwLen)) == NULL)
    {
        if (hkPFROKey != NULL)
            RegCloseKey(hkPFROKey);

        return;
    }

    if (!FRunningOnNT())
    {
        GetShortPathName(pcszKey, szShortName, sizeof(szShortName));
        pcszKey = szShortName;
    }

    pszLine = pszData;
    while (*pszLine)
    {
        // NOTE: On Win95, the format is (To, From) but on NT4.0, the format is (From, To)
        if (!FRunningOnNT())
        {
            // format of GetPrivateProfileSection data is:
            //
            // to1=from1\0                      ; from1 is the Value and to1 is the Key
            // to2=from2\0
            // NUL=del1\0                       ; del1 is the Key
            // NUL=del2\0
            //    .
            //    .
            //    .
            // to<n>=from<n>\0\0

            pszTo = pszLine;                            // key
            pszFrom = pszLine + lstrlen(pszLine) + 1;
            pszLine = pszFrom + lstrlen(pszFrom) + 1;   // point to the next line
        }
        else
        {
            // format of the value data for PFRO value name is:
            //
            // from1\0to1\0                     ; from1 is the Value and to1 is the Key
            // from2\0to2\0
            // del1\0\0                         ; del1 is the Key
            // del2\0\0
            //    .
            //    .
            //    .
            // from<n>\0to<n>\0\0

            pszFrom = pszLine;
            pszTo = pszLine + lstrlen(pszLine) + 1;     // key
            pszLine = pszTo + lstrlen(pszTo) + 1;       // point to the next line

            // skip over "\??\"
            if (*pszFrom == '\\')                       // '\\' is not a Leading DBCS byte
            {
                if (*((PDWORD) pszFrom) == VALID_SIGNATURE)
                    pszFrom += 4;
                else
                    continue;
            }

            if (*pszTo == '!')                          // '!' is neither a Leading nor a Trailing DBCS byte
                pszTo++;

            if (*pszTo == '\\')
            {
                if (*((PDWORD) pszTo) == VALID_SIGNATURE)
                    pszTo += 4;
                else
                    continue;
            }
        }

        if (lstrcmpi(pcszKey, pszTo) == 0)              // if there is more than one entry, return the last one
            lstrcpy(pszValue, pszFrom);
    }

    LocalFree(pszData);

    if (hkPFROKey != NULL)
        RegCloseKey(hkPFROKey);
}

DWORD CheckFile(DETECT_FILES Detect_Files)
{
    char    szFile[MAX_PATH] = { 0 };
    DWORD   dwRet = DET_NOTINSTALLED;
    DWORD   dwRetLast = DET_NOTINSTALLED;
    int     i =0;

    while (Detect_Files.cPath[i])
    {
        switch (Detect_Files.cPath[i])
        {
            case 'S':
            case 's':
                GetSystemDirectory( szFile, sizeof(szFile) );
                break;

            case 'W':
            case 'w':
                GetWindowsDirectory( szFile, sizeof(szFile) );
                break;

                // Windows command folder
            case 'C':
            case 'c':
                GetWindowsDirectory( szFile, sizeof(szFile) );
                AddPath(szFile, "Command");
                break;

            default:
                *szFile = '\0';
        }
        if (*szFile)
        {
            dwRet = CheckFileEx(szFile, Detect_Files);
            switch (dwRet)
            {
                case DET_NOTINSTALLED:
                    break;
                case DET_OLDVERSIONINSTALLED:
                    if (dwRetLast == DET_NOTINSTALLED)
                        dwRetLast = dwRet;
                    break;

                case DET_INSTALLED:
                    if ((dwRetLast == DET_NOTINSTALLED) ||
                        (dwRetLast == DET_OLDVERSIONINSTALLED))
                        dwRetLast = dwRet;
                    break;

                case DET_NEWVERSIONINSTALLED:
                    if ((dwRetLast == DET_NOTINSTALLED) ||
                        (dwRetLast == DET_OLDVERSIONINSTALLED) ||
                        (dwRetLast == DET_INSTALLED))
                    dwRetLast = dwRet;
                    break;
            }
        }

        // go to the next directory letter.
        while ((Detect_Files.cPath[i]) && (Detect_Files.cPath[i] != ','))
            i++;
        if (Detect_Files.cPath[i] == ',')
            i++;
    }
    return dwRetLast;
}

DWORD CheckFileEx(LPSTR szDir, DETECT_FILES Detect_Files)
{
    char    szFile[MAX_PATH];
    char    szRenameFile[MAX_PATH];
    DWORD   dwInstalledVer, dwInstalledBuild;
    DWORD   dwRet = DET_NOTINSTALLED;

    if (*szDir)
    {
        lstrcpy(szFile, szDir);
        AddPath(szFile, Detect_Files.szFilename);
        if (Detect_Files.dwMSVer == (DWORD)-1)
        {
            if (GetFileAttributes(szFile) != 0xFFFFFFFF)
                dwRet = DET_INSTALLED;
        }
        else
        {
            ReadFromWininitOrPFRO(szFile, szRenameFile);
            if (*szRenameFile != '\0')
                GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
            else
                GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

            if (dwInstalledVer != 0)
                dwRet = CompareVersions(Detect_Files.dwMSVer, Detect_Files.dwLSVer, dwInstalledVer, dwInstalledBuild);
        }
    }
    return dwRet;
}

DWORD WINAPI DetectFile(DETECTION_STRUCT *pDet, LPSTR pszFilename)
{
    DWORD dwRet = DET_NOTINSTALLED;
    DWORD dwInstalledVer, dwInstalledBuild;
    char szFile[MAX_PATH];
    char szRenameFile[MAX_PATH];

    dwInstalledVer = (DWORD) -1;
    dwInstalledBuild = (DWORD) -1;
    GetSystemDirectory(szFile, sizeof(szFile));
    AddPath(szFile, pszFilename);
    ReadFromWininitOrPFRO(szFile, szRenameFile);
    if (*szRenameFile != '\0')
        GetVersionFromFile(szRenameFile, &dwInstalledVer, &dwInstalledBuild, TRUE);
    else
        GetVersionFromFile(szFile, &dwInstalledVer, &dwInstalledBuild, TRUE);

    if (dwInstalledVer != 0)
        dwRet = CompareVersions(pDet->dwAskVer, pDet->dwAskBuild, dwInstalledVer, dwInstalledBuild);

    if (pDet->pdwInstalledVer && pDet->pdwInstalledBuild)
    {
        *(pDet->pdwInstalledVer) = dwInstalledVer;
        *(pDet->pdwInstalledBuild) = dwInstalledBuild;
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\ie4uinit.cpp ===
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"
#include "convert.h"
#include "regstr.h"

const TCHAR c_szAppName[]   = TEXT("ie4uinit");
const TCHAR c_szProfRecKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation");
const TCHAR c_szHomeDirValue[] = TEXT("ProfileDirectory");
const TCHAR c_szExplorerKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
const TCHAR c_szIExploreMain[] = TEXT( "Software\\microsoft\\Internet Explorer\\Main" );
const TCHAR c_szIExplorerSearchUrl[] = TEXT( "Software\\microsoft\\Internet Explorer\\SearchUrl" );
const TCHAR c_szIExplorer[] = TEXT( "Software\\microsoft\\Internet Explorer" );

const TCHAR c_szCentralFile[] = TEXT("CentralFile");
const TCHAR c_szLocalFile[] = TEXT("LocalFile");
const TCHAR c_szName[] = TEXT("Name");
const TCHAR c_szRegKey[] = TEXT("RegKey");
const TCHAR c_szRegValue[] = TEXT("RegValue");
const TCHAR c_szMustBeRelative[] = TEXT("MustBeRelative");
const TCHAR c_szDefault[] = TEXT("Default");
const TCHAR c_szDefaultDir[] = TEXT("DefaultDir");
const TCHAR c_szIExploreLnk[] = TEXT("Internet Explorer.lnk" );
const TCHAR c_szIExploreBackLnk[] = TEXT("Internet Explorer Lnk.bak" );
const TCHAR c_szIExploreBackLnkIni[] = TEXT("IELnkbak.ini" );
const TCHAR c_szIESetupPath[] = TEXT( "software\\microsoft\\IE Setup\\setup" );
const TCHAR c_szIE4Path[] = TEXT( "software\\microsoft\\IE4" );
const TCHAR c_szAdvINFSetup[] = TEXT( "software\\microsoft\\Advanced INF Setup" );
const TCHAR c_szIEModRollback[] = TEXT( "IE CompList" );
const TCHAR c_szRegBackup[] = TEXT( "RegBackup" );
const TCHAR c_szInstallMode[]  = TEXT("InstallMode");
const TCHAR c_szStarDotStar[] = "*.*";
const TCHAR c_szSearchUrl[] = TEXT("CleanSearchUrl");

const TCHAR c_szPrevStubINF[] = TEXT("ie4uinit.inf");
const TCHAR c_szStubINFFile[] = TEXT("ieuinit.inf");
const TCHAR c_szActInstalledIEGUID[] = TEXT( "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4383}");
const TCHAR c_szActInstalledIEGUIDRestore[] = TEXT( "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4383}.Restore");
const TCHAR c_szMyDocsDLL[] = TEXT("\\mydocs.dll");

const TCHAR c_szIE4Setup[]= TEXT("Software\\Microsoft\\IE Setup\\Setup");
const TCHAR c_szPreIEVer[]= TEXT("PreviousIESysFile");
const TCHAR c_szPreShellVer[]= TEXT("PreviousShellFile");


typedef VOID (*LPFNMYDOCSINIT)(VOID);

// used only at install stub time
BOOL IsPrevIE4();
BOOL IsPrevIE4WebShell();
UINT CheckIEVersion();
void RemoveOldMouseException();
void ProcessMouseException();

// used at uninstall stub time
UINT CheckUninstIEVersion();

//
//====== DllGetVersion  =======================================================
//

typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
//#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
//#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);
//
//====== DllGetVersion  =from shlwapi.h==========================================
//


HINSTANCE g_hinst;

BOOL g_fRunningOnNT = FALSE;
BOOL g_fRunningOnNT5 = FALSE;
BOOL g_fRunningOnWinXP = FALSE;
BOOL g_fRunningOnWin95 = FALSE;
BOOL g_fRunningOnXPSP1OrLater = FALSE;

// shlwapi.dll api
typedef void (* PFNSHFLUSHSFCACHEWRAP)();
PFNSHFLUSHSFCACHEWRAP pfnSHFlushSFCacheWrap = NULL;

// old shell32.dll api
typedef void (* PFNSHFLUSHSFCACHE)();
PFNSHFLUSHSFCACHE pfnSHFlushSFCache = NULL;

struct FolderDescriptor;
typedef void (* PFNINITFOLDER)(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory);

void InitFolderFromDefault(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory);
void InitFolderMyDocs(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory);

struct FolderDescriptor {
    UINT idsDirName;        /* Resource ID for directory name */
    LPCTSTR pszRegKey;      /* Name of reg key under which to set path */
    LPCTSTR pszRegValue;    /* Name of reg value to set path in */
    LPCTSTR pszStaticName;  /* Static name for ProfileReconciliation subkey */
    LPCTSTR pszFiles;       /* Spec for which files should roam */
    PFNINITFOLDER InitFolder;   /* Function to init contents */
    DWORD dwAttribs;            /* Desired directory attributes */
    BOOL fIntShellOnly : 1;     /* TRUE if should not do this in browser only mode */
    BOOL fMustBePerUser : 1;    /* TRUE if should always be forced per-user on all platforms */
    BOOL fDefaultInRoot : 1;    /* TRUE if default location is root of drive, not windows dir */
    BOOL fWriteToUSF : 1;       /* TRUE if we should write to User Shell Folders to work around Win95 bug */
} aFolders[] = {
    { IDS_CSIDL_DESKTOP_L, c_szExplorerKey, TEXT("Desktop"), TEXT("Desktop"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, FALSE, FALSE } ,
    { IDS_CSIDL_RECENT_L, c_szExplorerKey, TEXT("Recent"), TEXT("Recent"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, FALSE, FALSE } ,
    { IDS_CSIDL_NETHOOD_L, c_szExplorerKey, TEXT("NetHood"), TEXT("NetHood"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, FALSE, FALSE } ,
    { IDS_CSIDL_PERSONAL_L, c_szExplorerKey, TEXT("Personal"), TEXT("Personal"), c_szStarDotStar, InitFolderMyDocs, FILE_ATTRIBUTE_DIRECTORY, TRUE, FALSE, TRUE, FALSE } ,
    { IDS_CSIDL_FAVORITES_L, c_szExplorerKey, TEXT("Favorites"), TEXT("Favorites"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_DIRECTORY, FALSE, FALSE, FALSE, TRUE },
    { IDS_CSIDL_APPDATA_L, c_szExplorerKey, TEXT("AppData"), TEXT("AppData"), c_szStarDotStar, InitFolderFromDefault, FILE_ATTRIBUTE_DIRECTORY, FALSE, TRUE, FALSE, FALSE },
    { IDS_CSIDL_CACHE_L, c_szExplorerKey, TEXT("Cache"), TEXT("Cache"), TEXT(""), NULL, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, FALSE, FALSE, FALSE, FALSE },
    { IDS_CSIDL_COOKIES_L, c_szExplorerKey, TEXT("Cookies"), TEXT("Cookies"), c_szStarDotStar, NULL, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, FALSE, TRUE, FALSE, FALSE },
    { IDS_CSIDL_HISTORY_L, c_szExplorerKey, TEXT("History"), TEXT("History"), c_szStarDotStar, NULL, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, FALSE, TRUE, FALSE, FALSE },
};

// Verion number 4.71
#define IE_4_MS_VERSION 0x00040047
// Build number 1712.0 (IE4.0 RTW)
#define IE_4_LS_VERSION 0x06B00000
// IE5 Major version
#define IE_5_MS_VERSION 0x00050000
// IE5.5 Major version
#define IE_55_MS_VERSION 0x00050032
// IE6 (Whistler) Major version
#define IE_6_MS_VERSION 0x00060000

// check IE version return code
#define     LESSIE4 0
#define     IE4     1
#define     IE5     2
#define     IE55    3
#define     IE6     4   // Whistler


BOOL CheckWebViewShell(UINT *puiShell32)
{
    HINSTANCE           hInstShell32;
    DLLGETVERSIONPROC   fpGetDllVersion;
    char                szShell32[MAX_PATH];
    BOOL                bRet = FALSE;

    GetSystemDirectory(szShell32, sizeof(szShell32));
    AddPath(szShell32,"Shell32.dll");
    hInstShell32 = LoadLibrary(szShell32);
    if ( hInstShell32 )
    {
        DLLVERSIONINFO dllinfo;

        fpGetDllVersion = (DLLGETVERSIONPROC)GetProcAddress(hInstShell32, "DllGetVersion");
        bRet = (fpGetDllVersion != NULL);
        if (puiShell32 && fpGetDllVersion)
        {
            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if ( fpGetDllVersion(&dllinfo) == NOERROR )
                *puiShell32 = dllinfo.dwMajorVersion;
            else
                *puiShell32 = 0;  // error case, should never be here
        }
        FreeLibrary(hInstShell32);
    }

    return bRet;
}

// this code need to be updated whenever the new major version is released!!
UINT CheckIEVersion()
{
    char szIE[MAX_PATH] = { 0 };
    DWORD   dwMSVer, dwLSVer;

    GetSystemDirectory(szIE, sizeof(szIE));
    AddPath(szIE, "shdocvw.dll");
    GetVersionFromFile(szIE, &dwMSVer, &dwLSVer, TRUE);

    if (dwMSVer < IE_4_MS_VERSION)
    {
        return LESSIE4;
    }

    if ((dwMSVer >= IE_4_MS_VERSION) && (dwMSVer < IE_5_MS_VERSION))
    {
        return IE4;
    }

    if ((dwMSVer >= IE_5_MS_VERSION) && (dwMSVer < IE_55_MS_VERSION))
    {
        return IE5;
    }

    if ((dwMSVer >= IE_55_MS_VERSION) && (dwMSVer < IE_6_MS_VERSION))
    {
        return IE55;
    }

    if (dwMSVer == IE_6_MS_VERSION)
    {
        return IE6;
    }

#ifdef DEBUG
    OutputDebugStringA("CheckIEVersion - unknown shdocvw.dll version# ! Need to add new IE_XX_MS_VERSION id\n");
    DebugBreak();
#endif

    return IE6;
}



void InitFolderFromDefault(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory)
{
    SHFILEOPSTRUCT fos;
    TCHAR szFrom[MAX_PATH];

    lstrcpy(szFrom, pszBaseName);

    /* Before we build the complete source filespec, check to see if the
     * directory exists.  In the case of lesser-used folders such as
     * "Application Data", the default may not have ever been created.
     * In that case, we have no contents to copy.
     */
    DWORD dwAttr = GetFileAttributes(szFrom);
    if (dwAttr == 0xffffffff || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
        return;

    AddPath(szFrom,"");
    lstrcat(szFrom, pFolder->pszFiles);
    szFrom[lstrlen(szFrom)+1] = '\0';   /* double null terminate from string */
    pszUserDirectory[lstrlen(pszUserDirectory)+1] = '\0';   /* and to string */

    fos.hwnd = NULL;
    fos.wFunc = FO_COPY;
    fos.pFrom = szFrom;
    fos.pTo = pszUserDirectory;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI;
    fos.fAnyOperationsAborted = FALSE;
    fos.hNameMappings = NULL;
    fos.lpszProgressTitle = NULL;

    SHFileOperation(&fos);
}

void InitFolderMyDocs(FolderDescriptor *pFolder, LPTSTR pszBaseName, LPTSTR pszUserDirectory)
{
    HRESULT hres = E_FAIL;
    TCHAR szFrom[MAX_PATH];
    TCHAR szPathDest[MAX_PATH];
    BOOL fCopyLnk;

    lstrcpy(szFrom, pszBaseName);

    /* Before we build the complete source filespec, check to see if the
     * directory exists.  In the case of lesser-used folders such as
     * "Application Data", the default may not have ever been created.
     * In that case, we have no contents to copy.
     */
    DWORD dwAttr = GetFileAttributes(szFrom);
    if (dwAttr == 0xffffffff || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
        return;

    IShellLink *psl;
    if (FAILED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                IID_IShellLink, (void **)&psl)))
        return;

    if (SHGetNewLinkInfo(szFrom,
                         pszUserDirectory, szPathDest, &fCopyLnk,
                         SHGNLI_PREFIXNAME)) {

        if (fCopyLnk) {
            if (GetFileAttributes(szPathDest) == 0xffffffff &&
                CopyFile(szFrom, szPathDest, TRUE)) {
                hres = S_OK;
                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szPathDest, NULL);
                SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPathDest, NULL);
            } else {
//                DebugMsg(TF_ERROR, TEXT("****copy failed (%d)"),GetLastError());
            }
        } else {
            IPersistFile *ppf;

            psl->SetPath(szFrom);

            //
            // make sure the working directory is set to the same
            // directory as the app (or document).
            //
            // dont do this for non-FS pidls (ie control panel)
            //
            // what about a UNC directory? we go ahead and set
            // it, wont work for a WIn16 app.
            //
            if (!PathIsDirectory(szFrom)) {
                PathRemoveFileSpec(szFrom);
                psl->SetWorkingDirectory(szFrom);
            }

            /* We only did the SHGetNewLinkInfo for the fCopyLnk flag;
             * load a resource string to get a more descriptive name
             * for the shortcut.
             */
            LPTSTR pszPathEnd = PathFindFileName(szPathDest);
            LoadString(g_hinst, IDS_MYDOCS_SHORTCUT, pszPathEnd, ARRAYSIZE(szPathDest) - (int)(pszPathEnd - szPathDest));

            if (GetFileAttributes(szPathDest) == 0xffffffff) {
                hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
                if (SUCCEEDED(hres)) {
#ifdef UNICODE
                    hres = ppf->Save(szPathDest, TRUE);
#else
                    WCHAR wszPath[MAX_PATH];
                    MultiByteToWideChar(CP_ACP, 0, szPathDest, -1, wszPath, ARRAYSIZE(wszPath));
                    hres = ppf->Save(wszPath, TRUE);
#endif
                    ppf->Release();
                }
            }
        }
    }

    psl->Release();


}


HRESULT SetupFolder(HKEY hkeyProfRec, LPTSTR pszHomeDir, LPTSTR pszHomeDirEnd,
                    int cchHomeDir, FolderDescriptor *pFolder, BOOL fDefaultProfile,
                    HKEY hkeyFolderPolicies)
{
    DWORD dwType, cbData;
    BOOL fMakeFolderPerUser;
    BOOL fGotFromPolicy = FALSE;

    /* Figure out whether to make this folder be per-user or not.  On NT we
     * make everything per-user.  Some folders (notably Application Data)
     * are also always per-user.  The default for everything else is to not
     * make it per-user here unless a policy is set to force it.  If we do
     * not want to make it per-user here, we'll just leave it the way it is;
     * of course, the folder could have already been made per-user by some
     * other means.
     *
     * "Make per-user" means set a profile-relative path if we're not operating
     * on the default profile, plus adding a ProfileReconciliation key on win95
     * (any profile, including default).
     */
    if (hkeyFolderPolicies != NULL) {
        DWORD dwFlag;
        cbData = sizeof(dwFlag);
        if (RegQueryValueEx(hkeyFolderPolicies, pFolder->pszStaticName, NULL,
                            &dwType, (LPBYTE)&dwFlag, &cbData) == ERROR_SUCCESS &&
            (dwType == REG_DWORD || (dwType == REG_BINARY && cbData == sizeof(dwFlag)))) {
            fMakeFolderPerUser = dwFlag;
            fGotFromPolicy = TRUE;
        }
    }
    if (!fGotFromPolicy)
        fMakeFolderPerUser = (g_fRunningOnNT || pFolder->fMustBePerUser);

    TCHAR szUserHomeDir[MAX_PATH];

    *pszHomeDirEnd = '\0';          /* strip off dir name from last time through */
    lstrcpy(szUserHomeDir, pszHomeDir);
    PathRemoveBackslash(szUserHomeDir);

    /* Get the localized name for the directory, as it should appear in
     * the file system.
     */
    int cchDir = LoadString(g_hinst, pFolder->idsDirName, pszHomeDirEnd, cchHomeDir);
    if (!cchDir)
        return HRESULT_FROM_WIN32(GetLastError());
    cchDir++;   /* count null character */

    /* Create the reg key where a pointer to the new directory is supposed to
     * be stored, and write the path there.
     */
    HKEY hkeyFolder;

    LONG err = RegCreateKeyEx(HKEY_CURRENT_USER, pFolder->pszRegKey,0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_READ|KEY_WRITE, NULL, &hkeyFolder, NULL);

    if (err != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(err);

    /* Build the default location for this directory (usually just under the
     * Windows directory, except for My Documents).  We'll use this as the
     * location to create if nothing is in the registry, and also to compare
     * the registry-set location to see if we should move it or leave it
     * alone.
     */

    TCHAR szDefaultDir[MAX_PATH];
    GetWindowsDirectory(szDefaultDir, ARRAYSIZE(szDefaultDir));

    if (pFolder->fDefaultInRoot) {
        LPTSTR pszRoot;
        if (PathIsUNC(szDefaultDir)) {
            pszRoot = ANSIStrChr(szDefaultDir, (WORD)'\\');
            if (pszRoot != NULL)
                pszRoot = ANSIStrChr(pszRoot+1, (WORD)'\\');
            if (pszRoot != NULL)
                *(pszRoot+1) = '\0';
        }
        else {
            pszRoot = CharNext(szDefaultDir);
            if (*pszRoot == ':')
                pszRoot++;
            if (*pszRoot == '\\')
                pszRoot++;
            *pszRoot = '\0';
        }
    }
    else {
        AddPath(szDefaultDir, "");
    }
    lstrcat(szDefaultDir, pszHomeDirEnd);

    /* Get the path that was recorded for this folder before we ran.  We will
     * use it as the default for migrating contents, unless it's not there or
     * it's already set to the new directory.  In either of those cases we use
     * the localized name, relative to the Windows directory.
     */
    TCHAR szOldDir[MAX_PATH];
    BOOL fDefaultLocation = FALSE;
    cbData = sizeof(szOldDir);
    szOldDir[0] = '\0';
    err = SDSQueryValueExA(hkeyFolder, pFolder->pszRegValue, 0, &dwType,
                         (LPBYTE)szOldDir, &cbData);

    BOOL fGotPathFromRegistry = (err == ERROR_SUCCESS);

    if (!fGotPathFromRegistry) {
        lstrcpy(szOldDir, szDefaultDir);
        if (!pFolder->fDefaultInRoot)
            fDefaultLocation = TRUE;
    }
    else {
        /* Previous path is present in the registry.  If it's a net path,
         * it's probably been set by system policies and we want to leave
         * it the way it is.
         */
        BOOL fIsNet = FALSE;
        if (PathIsUNC(szOldDir))
            fIsNet = TRUE;
        else {
            int nDriveNumber = PathGetDriveNumber(szOldDir);
            if (nDriveNumber != -1) {
                TCHAR szRootPath[4] = TEXT("X:\\");
                szRootPath[0] = nDriveNumber + TEXT('A');
                if (::GetDriveType(szRootPath) == DRIVE_REMOTE)
                    fIsNet = TRUE;
            }
        }
        if (fIsNet) {
            RegCloseKey(hkeyFolder);
            return S_OK;
        }
    }

    LPSTR pszDirToCreate;
    BOOL fInit = TRUE;

    if (fDefaultProfile || !fMakeFolderPerUser) {
        /* On the default profile, the directory path we want is the one we
         * read from the registry (or the default windir-based path we built).
         * Also, most folders we want to keep as the user has them already
         * configured.  In either case, we do not initialize the contents
         * because there's no place to initialize them from in the first case,
         * and we want the contents undisturbed in the second case.
         */
        pszDirToCreate = szOldDir;
        fInit = FALSE;
    }
    else {
        /* We want to give this user a profile-relative path for this folder.
         * However, if they already have an explicit non-default path set for
         * this folder, we don't bother initializing it since they already have
         * it set up someplace where they want it.
         */
        if (fGotPathFromRegistry &&
            ::GetFileAttributes(szOldDir) != 0xffffffff &&
            lstrcmpi(szOldDir, szDefaultDir)) {
            pszDirToCreate = szOldDir;
            fInit = FALSE;
        }
        else {
            pszDirToCreate = pszHomeDir;
        }
    }

    /* Only write the path out to the registry if we didn't originally get it
     * from the registry.
     */
    if (!fGotPathFromRegistry) {
        /* If we're writing to the User Shell Folders key, only write non-
         * default paths there.
         */
        /* There are some applications (German Corel Office 7) which
         * depend on the entry being in User Shell Folders for some shell
         * folders.  This dependency is due to the fact that the entry use
         * to be created always by down level browsers (IE30).
         *
         * We do not do this generically because no value under
         * USF is supposed to mean "use the one in the Windows
         * directory", whereas an absolute path means "use that
         * path";  if there's a path under USF, it will be used
         * literally, which is a problem if the folder is set up
         * to use the shared folder location but roams to a machine
         * with Windows installed in a different directory.
         */
        if ((pFolder->pszRegKey != c_szExplorerKey) ||
            pszDirToCreate != szOldDir ||
            !fDefaultLocation ||
            pFolder->fWriteToUSF) {

            if (g_fRunningOnNT) {
                TCHAR szRegPath[MAX_PATH];

                lstrcpy(szRegPath, TEXT("%USERPROFILE%\\"));
                lstrcat(szRegPath, pszHomeDirEnd);
                RegSetValueEx( hkeyFolder, pFolder->pszRegValue, 0, REG_EXPAND_SZ,
                               (LPBYTE)szRegPath, (lstrlen(szRegPath)+1) * sizeof(TCHAR));
            }
            else {
                if (!pFolder->fWriteToUSF || g_fRunningOnWin95)
                {
                    RegSetValueEx(hkeyFolder, pFolder->pszRegValue, 0, REG_SZ,
                                  (LPBYTE)pszDirToCreate, (lstrlen(pszDirToCreate)+1) * sizeof(TCHAR));
                }
                else
                {

//  98/12/30 #238093 (IE#50598 / Office#188177) vtan: There exists a
//  case where HKCU\..\Explorer\User Shell Folders\Favorites does NOT
//  exist on Win98 (unknown cause). This case simulates a Windows95
//  bug which the fWriteToUSF flag is designed to get around. In the
//  German Win9x this replaces the Favorites folder in User Shell
//  Folders key with the english name and this is propogated below to
//  Shell Folders which destroys the localization.

//  In this case we want to write the value of the key in Shell Folders
//  (if that points to a valid directory) to the User Shell Folders key
//  and just let the code below write the same value back to the Shell
//  Folders key. A little bit of wasted effort.

                    HKEY    hkeySF;

                    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                                       "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_READ,
                                       NULL,
                                       &hkeySF,
                                       NULL) == ERROR_SUCCESS)
                    {
                        DWORD   dwRegDataType, dwRegDataSize;
                        TCHAR   szRegValue[MAX_PATH];

                        dwRegDataSize = sizeof(szRegValue);
                        if (RegQueryValueEx(hkeySF,
                                            pFolder->pszRegValue,
                                            0,
                                            &dwRegDataType,
                                            reinterpret_cast<LPBYTE>(szRegValue),
                                            &dwRegDataSize) == ERROR_SUCCESS)
                        {
                            if (GetFileAttributes(szRegValue) != 0xFFFFFFFF)
                            {
                                lstrcpy(pszDirToCreate, szRegValue);
                                RegSetValueEx(hkeyFolder,
                                              pFolder->pszRegValue,
                                              0,
                                              REG_SZ,
                                              (LPBYTE)pszDirToCreate,
                                              (lstrlen(pszDirToCreate)+1) * sizeof(TCHAR));
                            }
                        }
                        RegCloseKey(hkeySF);
                    }
                }
            }
        }

        /* The User Shell Folders key has a near-twin: Shell Folders, which
         * (a) should always contain the path to a folder, even if the folder
         * is in its default location, and (b) should contain the expanded
         * path on NT.
         */
        if (pFolder->pszRegKey == c_szExplorerKey) {
            HKEY hkeySF;
            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                               "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                               0, NULL, REG_OPTION_NON_VOLATILE,
                               KEY_READ|KEY_WRITE, NULL, &hkeySF, NULL) == ERROR_SUCCESS) {
                RegSetValueEx(hkeySF, pFolder->pszRegValue, 0, REG_SZ,
                              (LPBYTE)pszDirToCreate, (lstrlen(pszDirToCreate)+1) * sizeof(TCHAR));
                RegCloseKey(hkeySF);
            }
        }

        /* Initialize default contents of the folder.
         */
        if (fInit && pFolder->InitFolder != NULL)
            pFolder->InitFolder(pFolder, szOldDir, pszHomeDir);
    }

    /* Always try to create the directory we want, if it doesn't already
     * exist.
     */

    if (::GetFileAttributes(pszDirToCreate) == 0xffffffff) {
        CreateDirectory(pszDirToCreate, NULL);
        if (pFolder->dwAttribs != FILE_ATTRIBUTE_DIRECTORY)
            SetFileAttributes(pszDirToCreate, pFolder->dwAttribs);
    }

    RegCloseKey(hkeyFolder);

    /*
     * If it's the My Documents folder, there is some per-user initialization
     * to do regardless of whether we set the values or they already existed.
     */
    if (pFolder->InitFolder == InitFolderMyDocs)
    {
        TCHAR szMyDocs[ MAX_PATH ];

        if (GetSystemDirectory( szMyDocs, ARRAYSIZE(szMyDocs) ))
        {
            HINSTANCE hMyDocs;

            lstrcat( szMyDocs, c_szMyDocsDLL );

            hMyDocs = LoadLibrary( szMyDocs );

            if (hMyDocs)
            {

                LPFNMYDOCSINIT pMyDocsInit =
                        (LPFNMYDOCSINIT)GetProcAddress( hMyDocs, "PerUserInit" );

                if (pMyDocsInit)
                {
                    pMyDocsInit();
                }

                FreeLibrary( hMyDocs );
            }
        }
    }


    /* Now, for Windows 95 systems, create a ProfileReconciliation subkey
     * which will make this folder roam.  Only if we want to make this folder
     * per-user, of course.
     */
    if (fMakeFolderPerUser && !g_fRunningOnNT) {
        TCHAR szDefaultPath[MAX_PATH];
        lstrcpy(szDefaultPath, TEXT("*windir\\"));
        lstrcat(szDefaultPath, pszHomeDirEnd);

        HKEY hSubKey;

        LONG err = RegCreateKeyEx(hkeyProfRec, pFolder->pszStaticName, 0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE, NULL, &hSubKey, NULL);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szCentralFile, 0, REG_SZ, (LPBYTE)pszHomeDirEnd,
                                cchDir);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szLocalFile, 0, REG_SZ, (LPBYTE)pszHomeDirEnd,
                                cchDir);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szName, 0, REG_SZ, (LPBYTE)pFolder->pszFiles,
                                lstrlen(pFolder->pszFiles) + 1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szDefaultDir, 0, REG_SZ, (LPBYTE)szDefaultPath,
                                lstrlen(szDefaultPath) + 1);

        DWORD dwOne = 1;
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szMustBeRelative, 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szDefault, 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));

        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szRegKey, 0, REG_SZ, (LPBYTE)pFolder->pszRegKey,
                                lstrlen(pFolder->pszRegKey) + 1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, c_szRegValue, 0, REG_SZ, (LPBYTE)pFolder->pszRegValue,
                                lstrlen(pFolder->pszRegValue) + 1);

        RegCloseKey(hSubKey);

        if (err != ERROR_SUCCESS)
            return HRESULT_FROM_WIN32(err);
    }
    return S_OK;
}


BOOL GetModulePath( LPTSTR szPath, UINT cbPath )
{
    PSTR pszTmp;

    if (GetModuleFileName(g_hinst, szPath, cbPath ) == 0)
    {
        szPath[0] = '\0';
        return FALSE;
    }
    else
    {
        pszTmp = ANSIStrRChr( szPath, '\\' );
        if ( pszTmp )
            *pszTmp = '\0';
    }
    return TRUE ;
}


int DoMsgBoxParam(HWND hwnd, UINT TextString, UINT TitleString, UINT style, PTSTR param )
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[2*MAX_PATH];

    if (!LoadString(g_hinst, TextString, szMsg, sizeof(szMsg)))
        szMsg[0] = '\0';

    if ( param )
    {
        TCHAR szBuf[2*MAX_PATH];

        wsprintf( szBuf, szMsg, param );
        lstrcpy( szMsg, szBuf );
    }

    if (!LoadString(g_hinst, TitleString, szTitle, sizeof(szTitle)))
        szTitle[0] = '\0';

    return MessageBox(hwnd, szMsg, szTitle, style);
}

void InstINFFile( LPCTSTR pcszInf, LPTSTR pszSec, BOOL bInstall, BOOL bSaveRollback, DWORD dwFlag )
{
    TCHAR szPath[MAX_PATH];
    CABINFO   cabInfo;


    if ( GetModulePath( szPath, sizeof(szPath) ) )
    {
        if ( bSaveRollback )
        {
            ZeroMemory( &cabInfo, sizeof(CABINFO) );
            // install IE4Uinit.INF
            lstrcpy( cabInfo.szSrcPath, szPath );
            AddPath( szPath, pcszInf );

            if ( FileExists( szPath ) )
            {
                cabInfo.pszInf = szPath;
                cabInfo.pszSection = pszSec;
                cabInfo.dwFlags = (bInstall ? ALINF_BKINSTALL : ALINF_ROLLBACK);
                cabInfo.dwFlags |= ALINF_QUIET;
                ExecuteCab( NULL, &cabInfo, NULL );
            }
            else if (!(dwFlag & RSC_FLAG_QUIET))
            {
                DoMsgBoxParam( NULL, IDS_ERR_NOFOUNDINF, IDS_APPNAME, MB_OK|MB_ICONINFORMATION, szPath );
            }
        }
        else
        {
            char szInfFile[MAX_PATH];

            lstrcpy( szInfFile, szPath);
            AddPath( szInfFile, pcszInf);
            RunSetupCommand(NULL, szInfFile, pszSec, szPath,
                            NULL, NULL, dwFlag, NULL);
        }

    }
}


void DoRollback()
{
    HKEY hLMkey;
    HKEY hSubkey1, hSubkey2;
    TCHAR szBuf[MAX_PATH];
    DWORD dwSize;
    DWORD dwIndex = 0;
    int   ilen;

    // rollback all the components listed in c_szIEModRollback key
    //
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szAdvINFSetup, 0, KEY_READ , &hLMkey) == ERROR_SUCCESS )
    {
        if ( RegOpenKeyEx(hLMkey, c_szIEModRollback, 0, KEY_READ , &hSubkey1) == ERROR_SUCCESS )
        {
            lstrcpy( szBuf, c_szAdvINFSetup );
            AddPath( szBuf, "" );
            ilen = lstrlen(szBuf);
            dwSize = ARRAYSIZE(szBuf) - ilen;
            while ( RegEnumValue( hSubkey1, dwIndex, &szBuf[ilen], &dwSize,
                                  NULL, NULL, NULL, NULL ) == ERROR_SUCCESS  )
            {
                if ( RegOpenKeyEx(hLMkey, &szBuf[ilen], 0, KEY_READ | KEY_WRITE, &hSubkey2) == ERROR_SUCCESS )
                {
                    RegSetValueEx( hSubkey2, TEXT("BackupRegistry"), 0, REG_SZ, (LPBYTE)TEXT("n"), (lstrlen(TEXT("n"))+1)*sizeof(TCHAR) );
                    RegCloseKey( hSubkey2 );
                }

                AddPath( szBuf, c_szRegBackup );

                ///////////////////////////////////////////////////////////////////////////
                // ShabbirS  - 8/17/98
                // Bug# 26774 : Found that this restoring of backup reg data undoes our
                // dll registering done during the RunOnceEx phase.
                ///////////////////////////////////////////////////////////////////////////
                // restore HKLM if there
                //if ( RegOpenKeyEx(hLMkey, &szBuf[ilen], 0, KEY_READ | KEY_WRITE, &hSubkey2) == ERROR_SUCCESS )
                //{
                //    RegRestoreAll( NULL, NULL, hSubkey2 );
                //    RegCloseKey( hSubkey2 );
                //}

                // restore HKCU if there
                if ( RegOpenKeyEx( HKEY_CURRENT_USER, szBuf, 0, KEY_READ | KEY_WRITE, &hSubkey2) == ERROR_SUCCESS )
                {
                    RegRestoreAll( NULL, NULL, hSubkey2 );
                    RegCloseKey( hSubkey2 );
                }

                dwIndex++;
                dwSize = ARRAYSIZE( szBuf ) - ilen;
            }

            RegCloseKey( hSubkey1 );
        }

        RegCloseKey( hLMkey );
    }
}

#define NT_MEMORYLIMIT      0x03f00000
#define WIN9X_MEMORYLIMIT   0x01f00000

void DoINFWork( BOOL bInstall, LPCTSTR pcszInfFile, LPTSTR pszInfSec, DWORD dwFlag )
{
    HKEY    hkey;
    TCHAR   szBuf[MAX_PATH] = { 0 };
    DWORD   dwSize;
    DWORD   dwRedist = 0;
    BOOL    bRedistMode = FALSE;

    // check the InstallMode and determin if make the desktop icon and StartMenu item.
    if ( bInstall && (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIESetupPath, 0, KEY_READ, &hkey) == ERROR_SUCCESS) )
    {
        dwSize = sizeof(dwRedist);
        // If we can read the Installmode and bit 0 is set, assume redist (Remove short cuts)
        if ( (RegQueryValueEx( hkey, c_szInstallMode, 0, NULL, (LPBYTE)&dwRedist, &dwSize) == ERROR_SUCCESS) &&
             (dwRedist & 1) )
        {
            bRedistMode = TRUE;
        }
        RegCloseKey( hkey );
    }

    // if not installed over SP4 level crypto, then backup/restore the crypto keys.
    // NOTE that bInstall is passed in the 4th argument, so during install bSaveRollback is TRUE.  During
    // uninstall, the reg backup data should be restored when the DefaultInstall section is processed, so
    // set bSaveRollback to FALSE
    if (!FSP4LevelCryptoInstalled())
        InstINFFile( pcszInfFile, bInstall ? "BackupCryptoKeys" : "DelCryptoKeys", bInstall, bInstall, dwFlag );
    else
    {
        // BUGBUG: if bInstall is FALSE, need to delete the reg backup data for the crypto keys
    }

    // install the WinXP specific section
    if(g_fRunningOnWinXP && !pszInfSec ) {
        InstINFFile( pcszInfFile, TEXT("DefaultInstall.WinXP"), bInstall, TRUE, dwFlag);
    }
    else {
        // install the current shortcut and HKCU settings by stub INF
        InstINFFile( pcszInfFile, pszInfSec, bInstall, TRUE, dwFlag );
    }

    //  Even though IE5.0 does not install channelband, if the channelband exists on IE4.0, it should works in
    //  IE5.0.  Therefore if there is channelbar link exists(PrevIE Version is IE4.0 browser only), IE5 will update
    //  the channelbar link to the current browser.  Otherwise, do nothing.
    if (bInstall && IsPrevIE4() && !IsPrevIE4WebShell())
    {
        InstINFFile( pcszInfFile, TEXT("Shell.UserStub.Uninstall"), bInstall, FALSE, RSC_FLAG_INF | RSC_FLAG_QUIET );
    }

    if ( bRedistMode )
    {
        LPTSTR lpszSection;

        if ( g_fRunningOnNT )
            lpszSection = TEXT("RedistIE.NT");
        else
            lpszSection = TEXT("RedistIE.Win");

        InstINFFile( pcszInfFile, lpszSection, bInstall, TRUE, dwFlag );
    }

    // On uninstall, check what the current browser version and determin if we need to cleanup the
    // Channel and quick launch folders
    if ( !bInstall && ( CheckIEVersion() == LESSIE4))
    {
        LPTSTR lpszSection;

        if ( g_fRunningOnNT )
            lpszSection = TEXT("CleanFolders.NT");
        else
            lpszSection = TEXT("CleanFolders.Win");

        InstINFFile( pcszInfFile, lpszSection, bInstall, FALSE, RSC_FLAG_INF | RSC_FLAG_QUIET | RSC_FLAG_NGCONV );
    }

    // Enable sounds if user has a big enough machine
    // NT - 64MB, Win9x - 32MB
    if(bInstall)
    {
        LPTSTR lpszSection = NULL;
        MEMORYSTATUS ms;

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus(&ms);

        if ( g_fRunningOnNT)
        {
           if(ms.dwTotalPhys >= NT_MEMORYLIMIT)
           {
              lpszSection = TEXT("SoundInstall.NT");
           }
        }
        else
        {
           if(ms.dwTotalPhys >= WIN9X_MEMORYLIMIT)
           {
              lpszSection = TEXT("SoundInstall");
           }
        }

        if(lpszSection)
           InstINFFile( pcszInfFile, lpszSection, bInstall, TRUE, RSC_FLAG_INF | RSC_FLAG_QUIET | RSC_FLAG_NGCONV );
    }

    if (bInstall)
    {
        // in fact this is only true for IE5 install inf, but IE4 inf is called ok too since there is no
        // such section in IE4 stub inf.
        if (CheckWebViewShell(NULL)) {
            LPSTR lpszSection = NULL;
            if(g_fRunningOnWinXP)
                lpszSection = TEXT("IE5onIE4Shell.WinXP");
            else
                lpszSection = TEXT("IE5onIE4Shell");
                
            InstINFFile( pcszInfFile, lpszSection, bInstall, FALSE, RSC_FLAG_INF | RSC_FLAG_QUIET );
        }
    }

    // check if the user's home page is bogus one
    if ( bInstall && (RegOpenKeyEx( HKEY_CURRENT_USER, c_szIExploreMain, 0, KEY_READ, &hkey ) == ERROR_SUCCESS) )
    {
        DWORD dwSize;

        dwSize = sizeof(szBuf);
        if ( RegQueryValueEx( hkey, TEXT("Start Page"), NULL, NULL, (LPBYTE)szBuf, &dwSize ) == ERROR_SUCCESS )
        {
            if ( (g_fRunningOnNT && ANSIStrStrI(szBuf, "Plus!") && ANSIStrStrI(szBuf, "File:")) ||
                 (!lstrcmpi(szBuf, TEXT("http://home.microsoft.com"))) ||
                 (!lstrcmpi(szBuf, TEXT("http://home.microsoft.com/"))) )
            {
                InstINFFile( pcszInfFile, TEXT("OverrideHomePage.NT"), bInstall, TRUE, dwFlag );
            }
        }

        RegCloseKey( hkey );
    }

    if ( !bRedistMode )
            InstINFFile( TEXT("homepage.inf"), NULL, bInstall, TRUE, dwFlag );

    // DoRollback if needed
    if ( !bInstall )
    {
        DoRollback();
    }
}


/*----------------------------------------------------------
Purpose: Detect if it is run on Russian LangID
*/

//DWORD dwLangList[] = { 0x0419, 0xFFFF };
#define RUSSIANLANG     0x0419

BOOL IsBrokenLang()
{
    char    szTmp[MAX_PATH] = { 0 };
    DWORD   dwLangKernel32;
    DWORD   dwTmp;
    BOOL    bBadLang = FALSE;

    GetSystemDirectory(szTmp, sizeof(szTmp));
    AddPath(szTmp,"kernel32.dll" );
    GetVersionFromFile(szTmp, &dwLangKernel32, &dwTmp, FALSE);

    if ( dwLangKernel32 == RUSSIANLANG )
    {
        bBadLang = TRUE;
    }
    return bBadLang;
}

BOOL IsPrevStubRun()
{
    HKEY hLMKey, hCUKey;
    BOOL bRet = FALSE;
    char szStubVer[50], szPreIEVer[50];
    DWORD dwSize;
    WORD wStubVer[4]={0}, wPreIEVer[4]={0};

    // check if the pre-version iestub is run
    if ( RegOpenKeyEx( HKEY_CURRENT_USER, c_szActInstalledIEGUID, 0, KEY_READ, &hCUKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof(szStubVer);
        if ( RegQueryValueEx( hCUKey, TEXT("Version"), NULL, NULL, (LPBYTE)szStubVer, &dwSize ) == ERROR_SUCCESS )
        {
            ConvertVersionString( szStubVer, wStubVer, ',' );
        }
        RegCloseKey(hCUKey);
    }

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szIESetupPath, 0, KEY_READ, &hLMKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof(szPreIEVer);
        if ( RegQueryValueEx( hLMKey, TEXT("PreviousIESysFile"), NULL, NULL, (LPBYTE)szPreIEVer, &dwSize ) == ERROR_SUCCESS )
        {
            ConvertVersionString( szPreIEVer, wPreIEVer, '.' );

            if ( (MAKELONG(wPreIEVer[1],wPreIEVer[0])<IE_4_MS_VERSION) ||
                 (wStubVer[0] > wPreIEVer[0]) ||
                 ((wStubVer[0] == wPreIEVer[0]) && (wStubVer[1] >= wPreIEVer[1])) )
            {
                bRet = TRUE;
            }
        }
        else //should never be here. OW
            bRet = TRUE; //not forcing rerun the prev-stub

        RegCloseKey(hLMKey);
    }
    else //should never be here. OW
        bRet = TRUE; //not forcing rerun the prev-stub


    return bRet;
}

/*----------------------------------------------------------
Purpose: Stripping off the trailing spaces for the registry data in the list
*/

typedef struct _REGDATACHECK
{
    HKEY    hRootKey;
    LPSTR   lpszSubKey;
    LPSTR   lpszValueName;
} REGDATACHECK;

REGDATACHECK chkList[] = {
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "AppData" },
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "Start Menu" },
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "AppData" },
    { HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "Start Menu" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "AppData" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", "Start Menu" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "AppData" },
    { HKEY_USERS, ".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "Start Menu" },
};

void FixRegData()
{
    int     iList, i;
    LPSTR   pszTmp;
    char   szBuf[MAX_PATH];
    DWORD   dwSize, dwType;
    HKEY    hKey;

    iList = ARRAYSIZE( chkList );
    for ( i = 0; i < iList; i++ )
    {
        if ( RegOpenKeyEx(chkList[i].hRootKey, chkList[i].lpszSubKey, 0, KEY_READ|KEY_WRITE,
                          &hKey) == ERROR_SUCCESS )
        {
            dwSize = sizeof(szBuf);
            if ( RegQueryValueEx(hKey, chkList[i].lpszValueName, 0, &dwType, (LPBYTE)szBuf,
                                 &dwSize) == ERROR_SUCCESS )
            {
                // strip off the trailing blanks
                pszTmp = szBuf;
                pszTmp += lstrlen(szBuf) - 1;

                while ( (pszTmp >= szBuf) && (*pszTmp == ' ') )
                {
                    *pszTmp = '\0';
                    pszTmp--;
                }

                RegSetValueEx( hKey, chkList[i].lpszValueName, 0, dwType, (LPBYTE)szBuf, lstrlen(szBuf)+1 );
            }
            RegCloseKey( hKey );
        }
    }
}


void FixSearchUrl()
{
    HKEY hkey, hIEKey;
    TCHAR szBuf[MAX_PATH];
    DWORD dwSize;

    // if HKCU, software\microsoft\internet explorer\SearchUrl, "default" value is ""
    // Delete the "" default value.
    //
    if ( RegOpenKeyEx(HKEY_CURRENT_USER, c_szIExplorerSearchUrl, 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS )
    {
        dwSize = 0;
        if ( RegQueryValueEx( hkey, TEXT(""), 0, NULL, (LPBYTE)szBuf, &dwSize ) != ERROR_SUCCESS )
        {
            dwSize = sizeof(szBuf);
            if ( (RegQueryValueEx( hkey, TEXT(""), 0, NULL, (LPBYTE)szBuf, &dwSize ) == ERROR_SUCCESS) &&
                 (szBuf[0] == TEXT('\0')) )
            {
                // found "" empty string as default value, check if we have cleaned up before.
                // If not, clean it now, otherwise do nothing.
                if ( RegCreateKeyEx( HKEY_CURRENT_USER, c_szIE4Path,0, NULL, REG_OPTION_NON_VOLATILE,
                                     KEY_READ|KEY_WRITE, NULL, &hIEKey, NULL) == ERROR_SUCCESS )
                {
                    dwSize = sizeof(szBuf);
                    if ( (RegQueryValueEx( hIEKey, c_szSearchUrl, 0, NULL, (LPBYTE)szBuf, &dwSize ) != ERROR_SUCCESS) ||
                         (*CharUpper(szBuf) != TEXT('Y')) )
                    {
                        RegDeleteValue( hkey, TEXT("") );
                        lstrcpy( szBuf, TEXT("Y") );
                        RegSetValueEx( hIEKey, c_szSearchUrl, 0, REG_SZ, (LPBYTE)szBuf, (lstrlen(szBuf)+1)*sizeof(TCHAR) );
                    }

                    RegCloseKey( hIEKey );
                }
            }
        }
        RegCloseKey( hkey );
    }
}



/*----------------------------------------------------------
 * Helper function to check if the Channels folder exists in
 * the current user profile.
 *----------------------------------------------------------
 */

// "Channels" resid from CdfView. (Need to use this, b'cos could be localized
#define CHANNEL_FOLDER_RESID 0x1200

// SHGetSpecialFolderPath function from Shell32.dll
typedef BOOL (WINAPI *SH_GSFP_PROC) (HWND, LPTSTR, int, BOOL);

BOOL DoesChannelFolderExist()
{
    char szChannelName[MAX_PATH];
    char szSysPath[MAX_PATH] = { 0 };
    char szChannelPath[MAX_PATH];
    BOOL  bRet = FALSE;
    BOOL  bGetRC = TRUE;
    HMODULE hShell32 = NULL;
    SH_GSFP_PROC fpSH_GSFP = NULL;
    DWORD dwAttr = 0;
    
    GetSystemDirectory( szSysPath,sizeof(szSysPath));

    lstrcpy(szChannelPath, szSysPath);
    AddPath( szChannelPath, "shell32.dll" );
    hShell32 = LoadLibrary(szChannelPath);

    // This stubs runs on IE4 or IE5 systems. Hence shell32 is garunteed
    // to have the SHGetSpecialFolderPath API.
    if (hShell32)
    {
        fpSH_GSFP = (SH_GSFP_PROC)GetProcAddress(hShell32,"SHGetSpecialFolderPathA");

        *szChannelPath = '\0';
        if (fpSH_GSFP && fpSH_GSFP(NULL, szChannelPath, CSIDL_FAVORITES, FALSE))
        {
            HKEY hKey;
            DWORD cbSize = sizeof(szChannelName);

            // Get the potentially localized name of the Channel folder from the
            // registry if it is there.  Otherwise use "Channels"
            // Then tack this on the favorites path.
            //
    
            if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hKey,"ChannelFolderName", NULL, NULL, (LPBYTE)szChannelName,&cbSize) == ERROR_SUCCESS)
                {
                    bGetRC = FALSE;
                }
                RegCloseKey(hKey);
            }

            if (bGetRC)
            {
                HMODULE hLib;

                // Get the default name for Channels folder from the
                // CdfView.dll
                AddPath(szSysPath,"cdfview.dll");

                hLib = LoadLibraryEx(szSysPath,NULL,LOAD_LIBRARY_AS_DATAFILE);
                if (hLib)
                {
                    if (LoadString(hLib, CHANNEL_FOLDER_RESID,szChannelName,sizeof(szChannelName)) == 0)
                    {
                        // Fail to read the resource, default to English
                        lstrcpy(szChannelName,"Channels");
                    }

                    FreeLibrary(hLib);
                }
                        
            }
    
            AddPath(szChannelPath, szChannelName);
    
            // Check if the folder exists...
            dwAttr = GetFileAttributes(szChannelPath);
            if ((dwAttr != 0xffffffff) && (dwAttr & FILE_ATTRIBUTE_DIRECTORY))
                bRet = TRUE;
        }

        FreeLibrary(hShell32);
    }    


    return bRet;
}

HRESULT IEAccessHideExplorerIcon()
{
    const TCHAR *szKeyComponent = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\{871C5380-42A0-1069-A2EA-08002B30309D}");
    const TCHAR *szShellFolder = TEXT("ShellFolder");
    const TCHAR *szAttribute = TEXT("Attributes");
    DWORD dwValue, dwSize, dwDisposition;
    HKEY hKeyComponent, hKeyShellFolder;
    HRESULT hResult = ERROR_SUCCESS;

    hResult = RegCreateKeyEx(HKEY_CURRENT_USER, szKeyComponent, NULL, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_CREATE_SUB_KEY, NULL, &hKeyComponent, &dwDisposition);

    if (hResult != ERROR_SUCCESS)
        return hResult;

    hResult = RegCreateKeyEx(hKeyComponent, szShellFolder, NULL, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKeyShellFolder, &dwDisposition);

    RegCloseKey(hKeyComponent);
    
    if (hResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        hResult = RegQueryValueEx( hKeyShellFolder, szAttribute, NULL, NULL, (LPBYTE)&dwValue, &dwSize);

        if (hResult != ERROR_SUCCESS)
            dwValue = 0;

        dwValue |= SFGAO_NONENUMERATED;

        hResult = RegSetValueEx(hKeyShellFolder, szAttribute, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

        RegCloseKey(hKeyShellFolder);
    }

    return hResult;
}

#define REGVAL_SHOW_CHANNELBAND "Show_ChannelBand"
#define REGVAL_SOURCE           "Source"
#define REGVAL_FLAGS            "Flags"

#define REG_IE_MAIN      "Software\\Microsoft\\Internet Explorer\\Main"
#define REG_DESKTOP_COMP "Software\\Microsoft\\Internet Explorer\\Desktop\\Components"

#define GUID_CHNLBAND "131A6951-7F78-11D0-A979-00C04FD705A2"
#define FLAG_ENABLE_CHNLBAND 0x00002000

/*----------------------------------------------------------
Purpose: Worker function to do the work
*/

void DoWork( BOOL bInstall )
{
    TCHAR szHomeDir[MAX_PATH] = { 0 };
    HKEY  hkeyProfRec = NULL;
    HKEY  hkeyFolderPolicies;
    BOOL  fIntShellMode = FALSE;
    HMODULE hmodShell = NULL;
//    HINSTANCE hlib;
    TCHAR szPath[MAX_PATH] = { 0 };
    DWORD dwMV, dwLV;
    BOOL  fUseShell32 = FALSE;

    if ( bInstall )
    {
        if (g_fRunningOnNT) {
            ExpandEnvironmentStrings("%USERPROFILE%", szHomeDir, ARRAYSIZE(szHomeDir));
        }
        else {
            szHomeDir[0] = '\0';
            LONG err = RegCreateKeyEx(HKEY_CURRENT_USER, c_szProfRecKey, 0, NULL,
                                      REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                                      NULL, &hkeyProfRec, NULL);
            if (err == ERROR_SUCCESS) {
                DWORD dwType;
                DWORD cbData = sizeof(szHomeDir);
                RegQueryValueEx(hkeyProfRec, c_szHomeDirValue, 0, &dwType,
                                (LPBYTE)szHomeDir, &cbData);
            }
        }

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Per User Folders",
                         0, KEY_QUERY_VALUE, &hkeyFolderPolicies) != ERROR_SUCCESS)
            hkeyFolderPolicies = NULL;

        /* Dynamically link to the SHFlushSFCache API in SHELL32.DLL.  Its ordinal
         * is 526.  This API tells the shell to reinitialize the shell folder cache
         * in all processes.
         */

        // due to the buggy in the old shell32 of this api function.  We are advised to use the new wrap
        // which is in shlwapi.dll.  Its ordinal is 419.
        fIntShellMode = FALSE;
        GetSystemDirectory( szPath,sizeof( szPath ) );
        AddPath( szPath, "shlwapi.dll" );
        GetVersionFromFile( szPath, &dwMV, &dwLV, TRUE );

        // if major version >= 5.0
        //
        if ( (dwMV >= 0x00050000))
        {
            hmodShell = ::LoadLibrary(szPath);
        }
        else
        {
            hmodShell = ::LoadLibrary("shell32.dll");
            fUseShell32 = TRUE;
        }

        if (hmodShell != NULL)
        {
            if ( !fUseShell32 )
            {
                ::pfnSHFlushSFCacheWrap = (PFNSHFLUSHSFCACHEWRAP)::GetProcAddress(hmodShell, (LPCTSTR)419);
                if (::pfnSHFlushSFCacheWrap != NULL)
                {
                    fIntShellMode = TRUE;
                }
            }
            else
            {
                ::pfnSHFlushSFCache = (PFNSHFLUSHSFCACHE)::GetProcAddress(hmodShell, (LPCTSTR)526);
                if (::pfnSHFlushSFCache != NULL)
                {
                    fIntShellMode = TRUE;
                }
            }
        }

        BOOL fDefaultProfile;
        LPTSTR pchHomeDirEnd = szHomeDir;
        int cchHomeDir = 0;

        if (szHomeDir[0] != '\0') {
            fDefaultProfile = FALSE;
        }
        else {
            GetWindowsDirectory(szHomeDir, ARRAYSIZE(szHomeDir));
            fDefaultProfile = TRUE;
        }
        AddPath(szHomeDir,"");
        pchHomeDirEnd = szHomeDir + lstrlen(szHomeDir);
        cchHomeDir = ARRAYSIZE(szHomeDir) - (int)(pchHomeDirEnd - szHomeDir);

        for (UINT i=0; i<ARRAYSIZE(aFolders); i++) {
            if (aFolders[i].fIntShellOnly && !fIntShellMode)
                continue;

            if (FAILED(SetupFolder(hkeyProfRec, szHomeDir, pchHomeDirEnd,
                                   cchHomeDir, &aFolders[i], fDefaultProfile,
                                   hkeyFolderPolicies)))
                break;
        }

        if (hkeyProfRec != NULL)
            RegCloseKey(hkeyProfRec);

        if (hkeyFolderPolicies != NULL)
            RegCloseKey(hkeyFolderPolicies);

        // import NS stuff if there
        ImportNetscapeProxySettings( IMPTPROXY_CALLAFTIE4 );
        ImportBookmarks(g_hinst);

        if ( !fUseShell32 )
        {
            if (::pfnSHFlushSFCacheWrap != NULL)
            {
                (*::pfnSHFlushSFCacheWrap)();
            }
        }
        else
        {
            if (::pfnSHFlushSFCache != NULL)
            {
                (*::pfnSHFlushSFCache)();
            }
        }

        if (hmodShell != NULL) {
            ::FreeLibrary(hmodShell);
        }
    }

    /* BUGBUG - add code to populate the default IE4 favorites, channels, and
     * shortcuts here
     */

    // #75346: Upgrade from Win9x to NT5, new users have no Channels folder
    // and the ChannelBand pops-up with Fav. entries in it. This hack will
    // ensure that the Ch.Band does not pop-up when the new user logs in for
    // the first time.
    if (bInstall && g_fRunningOnNT5)
    {
        if (!DoesChannelFolderExist())
        {   
            HKEY hKey;
            char szNo[] = "No";

            // Turn off the Show_ChannelBand for this user.
            if (RegOpenKeyEx(HKEY_CURRENT_USER,REG_IE_MAIN, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(hKey, REGVAL_SHOW_CHANNELBAND,0, REG_SZ,(LPBYTE)szNo,sizeof(szNo));
                RegCloseKey(hKey);
            }

            // Also turn off the Desktop\Components(ChannelBand)
            // Open HKCU\S\M\InternetExplorer\Desktop\Coomponents and enum for
            // the ChannelBand GUID. Disable the show flag.
            if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKTOP_COMP, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                HKEY hSubKey = NULL;
                char szSubKey[MAX_PATH];
                char szSourceID[130];
                DWORD dwSize = sizeof(szSubKey);

                for (int i = 0; 
                     RegEnumKeyEx(hKey,i, szSubKey, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS; 
                     i++, dwSize = sizeof(szSubKey))
                {
                    // Open this subkey and checks its SourceID.
                    if (RegOpenKeyEx(hKey,szSubKey,0, KEY_READ|KEY_WRITE, &hSubKey) == ERROR_SUCCESS)
                    {
                        dwSize = sizeof(szSourceID);
                        if ((RegQueryValueEx(hSubKey, REGVAL_SOURCE, NULL, NULL, (LPBYTE)szSourceID,&dwSize) == ERROR_SUCCESS)
                           && (lstrcmpi(szSourceID, GUID_CHNLBAND) == 0))
                        {
                            // Read the current Flags setting.
                            DWORD dwFlags = 0;

                            dwSize = sizeof(dwFlags);
                            RegQueryValueEx(hSubKey,REGVAL_FLAGS, NULL, NULL, (LPBYTE)&dwFlags, &dwSize);

                            dwFlags &= ~(FLAG_ENABLE_CHNLBAND);
                            dwSize = sizeof(dwFlags);
                            RegSetValueEx(hSubKey, REGVAL_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, dwSize);

                            // close the key since we have a match and are therefore going to break out
                            RegCloseKey(hSubKey);
                            break;
                        }
                        
                        RegCloseKey(hSubKey);
                    }

                }  // end of RegEnum loop

                RegCloseKey(hKey);
            }


        }
    }


    // before we do the INF work, we have to run the following function which is
    // hack way to fix Russian NT 4.0 localization problem.  This only apply to Russian NT box.
    if (g_fRunningOnNT && IsBrokenLang() )
    {
        FixRegData();
    }

    // On win95, due to the RegSave/Restore problem on default valuename, and valuename is space,
    // we will do a specific fix for SearchUrl subkey.  The generic registry operation fix will in advpack.dll.
    if ( (!g_fRunningOnNT) && bInstall )
    {
        FixSearchUrl();
    }

    // because this stub code is left after uninstall IE5 to do both IE4 and IE5 work, we need the smartness to
    // know when to run IE4 inf and when only needed to run IE5 inf
    // BUGBUG:  this portion of code is very version specific and need to be updated whenever the new Major
    // version is shipped. Bud pain!! Most likely, in IE6 time we need to stub EXE to get around the problem!!

    if (bInstall)
    {
        UINT uIEVer = CheckIEVersion();

        // install stub case:
        if (uIEVer == IE4)
        {
            DoINFWork(bInstall, c_szPrevStubINF, NULL, 0); // NULL means DefaultInstall section
        }
        else if (uIEVer >= IE5)
        {
            if (!IsPrevStubRun() )
            {
                // Simulate a pre-installation of IE4. So run IE4 browser stub
                // first, then followed by the IE4 Shell stub (if required).
                DoINFWork( bInstall, c_szPrevStubINF, NULL, RSC_FLAG_INF | RSC_FLAG_QUIET );

                if (IsPrevIE4WebShell())
                {
                    DoINFWork( bInstall, c_szPrevStubINF, g_fRunningOnNT ? TEXT("Shell.UserStubNT") : TEXT("Shell.UserStub"), RSC_FLAG_INF | RSC_FLAG_QUIET);
                }

            }

            DoINFWork( bInstall, c_szStubINFFile, NULL, 0 );
            ProcessMouseException();
        }
    }
    else
    {
        // uninstall stub case:  use HKCU value to make sure which version it is uninstalling
        UINT uUninstIEVer = CheckUninstIEVersion();

        if (uUninstIEVer == IE4)
        {
            DoINFWork(bInstall, c_szPrevStubINF, NULL, 0);
        }
        else if (uUninstIEVer == IE5)
        {
            DoINFWork(bInstall, c_szStubINFFile, NULL, 0);
        }
        else if (uUninstIEVer == IE55 || uUninstIEVer == IE6)
        {
            DoINFWork(bInstall, c_szStubINFFile, NULL, 0);
        }

    }

    if (bInstall && g_fRunningOnWinXP)
        IEAccessHideExplorerIcon();
    
}


INT WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPTSTR lpszCmdLine, INT nCmdShow )
{
    BOOL bInstall;

    if ( !lpszCmdLine || !*lpszCmdLine )
        bInstall = TRUE;
    else
        bInstall = FALSE;

    DoWork( bInstall );

    if (g_fRunningOnXPSP1OrLater)
    {
        TCHAR szCmdLine[MAX_PATH];

        GetSystemDirectory(szCmdLine, ARRAYSIZE(szCmdLine));
        AddPath(szCmdLine, TEXT("shmgrate.exe"));
        ShellExecute(NULL, NULL, szCmdLine, TEXT("OCInstallUserConfigIE"), NULL, SW_SHOWDEFAULT);
    }

    return 0;
}

BOOL IsXPSP1OrLater(OSVERSIONINFO& osvi)
{
    BOOL fResult = FALSE;
    
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
    {
        if (osvi.dwMajorVersion > 5)
        {
            fResult = TRUE;
        }
        else if (osvi.dwMajorVersion == 5)
        {
            if (osvi.dwMinorVersion > 1)
            {
                fResult = TRUE;
            }
            else if (osvi.dwMinorVersion == 1)
            {
                if (osvi.dwBuildNumber > 2600)
                {
                    fResult = TRUE;
                }
                else if (osvi.dwBuildNumber == 2600)
                {                                
                    HKEY hkey;

                    //  HIVESFT.INF and UPDATE.INF set this for service packs:
                    //  HKLM,SYSTEM\CurrentControlSet\Control\Windows,"CSDVersion",0x10001,0x100
                    
                    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows"), 0, KEY_QUERY_VALUE, &hkey);

                    if (ERROR_SUCCESS == lResult)
                    {
                        DWORD dwValue;
                        DWORD cbValue = sizeof(dwValue);
                        DWORD dwType;

                        lResult = RegQueryValueEx(hkey, TEXT("CSDVersion"), NULL, &dwType, (LPBYTE)&dwValue, &cbValue);

                        if ((ERROR_SUCCESS == lResult) && (REG_DWORD == dwType) && (dwValue >= 0x100))
                        {
                            fResult = TRUE;
                        }
                        
                        RegCloseKey(hkey);
                    }
                }
            }
        }
    }

    return fResult;
}

// stolen from the CRT, used to shrink our code

int
_stdcall
ModuleEntry(void)
{
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    g_hinst = GetModuleHandle(NULL);

#ifdef DEBUG

    CcshellGetDebugFlags();

    if (IsFlagSet(g_dwBreakFlags, BF_ONOPEN))
        DebugBreak();

#endif

    if (FAILED(OleInitialize(NULL)))
        return 0;

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
    {
        g_fRunningOnNT = TRUE;

        if (osvi.dwMajorVersion >= 5) {
            g_fRunningOnNT5 = TRUE;
            if (osvi.dwMinorVersion >= 1)
                g_fRunningOnWinXP = TRUE;
        }
    }
    else if ((VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId) && (0 == osvi.dwMinorVersion))
    {
        g_fRunningOnWin95 = TRUE;
    }

    g_fRunningOnXPSP1OrLater = IsXPSP1OrLater(osvi);

    // turn off critical error stuff
    SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    OleUninitialize();

    ExitProcess(0);
    return 0;           // We never come here
}

UINT CheckUninstIEVersion()
{
    HKEY hKey;
    DWORD dwSize;
    TCHAR szPreIEVer[50];
    WORD wPreIEVer[4];
    UINT uRet = LESSIE4;

    if ( RegOpenKeyEx( HKEY_CURRENT_USER, c_szActInstalledIEGUIDRestore, 0, KEY_READ, &hKey) != ERROR_SUCCESS )
    {
        if ( RegOpenKeyEx( HKEY_CURRENT_USER, c_szActInstalledIEGUID, 0, KEY_READ, &hKey) != ERROR_SUCCESS )
        {
            return uRet;
        }
    }

    dwSize = sizeof( szPreIEVer );
    if ( RegQueryValueEx(hKey, TEXT("Version"), NULL, NULL, (LPBYTE)szPreIEVer, &dwSize) == ERROR_SUCCESS )
    {
        ConvertVersionString( szPreIEVer, wPreIEVer, ',' );
        if ((wPreIEVer[0] == 0x0004) && (wPreIEVer[1]>=0x0047))
            uRet = IE4;
        else if (wPreIEVer[0] == 0x0005)
        {
            if (wPreIEVer[1] >= 0x0032)
                uRet = IE55;
            else
                uRet = IE5;
        } 
        else if (wPreIEVer[0] == 0x0006)
            uRet = IE6; 
    }
    RegCloseKey(hKey);

    return uRet;
}

BOOL IsPrevIE4()
{
    HKEY hKey;
    DWORD dwSize;
    TCHAR szPreIEVer[50];
    WORD wPreIEVer[4];
    BOOL bRet = FALSE;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szIE4Setup, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        dwSize = sizeof( szPreIEVer );
        if ( RegQueryValueEx(hKey, c_szPreIEVer, NULL, NULL, (LPBYTE)szPreIEVer, &dwSize) == ERROR_SUCCESS )
        {
            ConvertVersionString( szPreIEVer, wPreIEVer, '.' );
            if ( (wPreIEVer[0] == 0x0004) && (wPreIEVer[1]>=0x0047) )
            {
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    return bRet;
}

BOOL IsPrevIE4WebShell()
{
    HKEY hKey;
    DWORD dwSize;
    TCHAR szPreShellVer[50];
    WORD wPreShellVer[4];
    BOOL bRet = FALSE;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szIE4Setup, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        dwSize = sizeof( szPreShellVer );
        if ( RegQueryValueEx(hKey, c_szPreShellVer, NULL, NULL, (LPBYTE)szPreShellVer, &dwSize) == ERROR_SUCCESS )
        {
            ConvertVersionString( szPreShellVer, wPreShellVer, '.' );
            if ((wPreShellVer[0] == 0x0004) && (wPreShellVer[1]>=0x0047) )
            {
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    return bRet;
}

const TCHAR c_szMouseExceptions[]   = TEXT("Control Panel\\Microsoft Input Devices\\Mouse\\Exceptions");
// This gets written to the registry 
const TCHAR c_szFilename[] = TEXT("FileName");
const TCHAR c_szInternetExplorer[] = TEXT("Internet Explorer");
const TCHAR c_szDescription[] = TEXT("Description");
const TCHAR c_szVersion[] = TEXT("Version");
const TCHAR c_szIE[] = TEXT("IEXPLORE.EXE");
#define IE_VERSION 0x50000

void ProcessMouseException()
{
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwIndex = 1001;   // start with 1001.
    TCHAR szSubKey[16];
    BOOL  bCannotUse = TRUE;
    TCHAR szData[MAX_PATH];

    RemoveOldMouseException();
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szMouseExceptions, 0, NULL, 0, KEY_WRITE|KEY_READ, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        while (bCannotUse)
        {
            wsprintf(szSubKey, "%d", dwIndex);
            if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
            {
                RegCloseKey(hSubKey);
                dwIndex++;
            }
            else
                bCannotUse = FALSE;
        }
        if (RegCreateKeyEx(hKey, szSubKey, 0, NULL, 0, KEY_WRITE, NULL, &hSubKey, NULL) == ERROR_SUCCESS)
        {
            if (!LoadString(g_hinst, IDS_IE_APPNAME, szData, sizeof(szData)))
                lstrcpy(szData, c_szInternetExplorer);
            RegSetValueEx(hSubKey, c_szDescription, 0, REG_SZ, (LPBYTE)szData, (lstrlen(szData)+1) * sizeof(TCHAR));
            RegSetValueEx(hSubKey, c_szFilename, 0, REG_SZ, (LPBYTE)c_szIE, (lstrlen(c_szIE)+1) * sizeof(TCHAR));
            dwIndex = IE_VERSION;
            RegSetValueEx(hSubKey, c_szVersion, 0, REG_DWORD, (LPBYTE)&dwIndex , sizeof(DWORD));
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }
}

void RemoveOldMouseException()
{
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwIndex = 0;
    BOOL  bFound = FALSE;
    LONG  lRet = ERROR_SUCCESS;
    TCHAR szSubKey[MAX_PATH];
    DWORD dwSize;
    TCHAR szData[MAX_PATH];

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szMouseExceptions, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
    {
        while (!bFound && (lRet == ERROR_SUCCESS))    
        {
            dwSize = sizeof(szSubKey);
            lRet = RegEnumKeyEx(hKey, dwIndex, szSubKey, &dwSize, NULL, NULL, NULL, NULL);
            if (lRet == ERROR_SUCCESS)
            {
                if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szData);
                    if (RegQueryValueEx(hSubKey, c_szFilename,NULL, NULL, (LPBYTE)szData, &dwSize) == ERROR_SUCCESS)
                    {
                        bFound = (lstrcmpi(szData, c_szIE) == 0);
                    }
                    RegCloseKey(hSubKey);
                }
                if (bFound)
                {
                    RegDeleteKey(hKey, szSubKey);
                }
                else
                    dwIndex++;
            }
        }
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iernonce\roexui.cpp ===
// **************************************************************************
//
// RunOnce.Cpp
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
//  RunOnce wrapper. This encapsulates all applications that would like
//  to run the first time we re-boot. It lists these apps for the user
//  and allows the user to launce the apps (like apple at ease).
//
//  5 June 1994 FelixA  Started
//  8 June  Felix   Defined registry strings and functionality.
//                  Got small buttons displayed, but not working.
//  9 June  Felix   Both big and small buttons. Nice UI.
//                  Got single click app launching.
//
// 23 June  Felix   Moving it to a Chicago make thingy not Dolphin
//
// *************************************************************************/
//
#include "iernonce.h"
#include "resource.h"


#define CXBORDER 3


// globals
HDC g_hdcMem = NULL;            // Run time can be set for big or small buttons.
int g_cxSmIcon = 0;             // Icon sizes.
SIZE g_SizeTextExt;             // Extent of text in buttons.
HFONT g_hfont = NULL;
HFONT g_hBoldFont = NULL;
HBRUSH g_hbrBkGnd = NULL;
ARGSINFO g_aiArgs;


// prototypes
BOOL CreateGlobals(HWND hwndCtl);
BOOL RunOnceFill(HWND hWndLB);
void ShrinkToFit(HWND hWnd, HWND hLb);
DWORD RunAppsInList(LPVOID lp);
LRESULT HandleLBMeasureItem(HWND hwndLB, MEASUREITEMSTRUCT *lpmi);
LRESULT HandleLBDrawItem(HWND hwndLB, DRAWITEMSTRUCT *lpdi);
void DestroyGlobals(void);


LRESULT CALLBACK DlgProcRunOnceEx(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HANDLE s_hThread = NULL;
    DWORD dwThread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        g_aiArgs = *((ARGSINFO *) lParam);
        CreateGlobals(hWnd);
        SetWindowPos(hWnd, NULL, 32, 32, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        RunOnceFill(GetDlgItem(hWnd, IDC_LIST2));
        // Now calculate the size needed for the LB and resize LB and parent.
        ShrinkToFit(hWnd, GetDlgItem(hWnd, IDC_LIST2));
        if ((s_hThread = CreateThread(NULL, 0, RunAppsInList, (LPVOID) GetDlgItem(hWnd, IDC_LIST2), 0, &dwThread)) == NULL)
            PostMessage(hWnd, WM_FINISHED, 0, 0L);
        break;

    case WM_SETCURSOR:
        if (g_aiArgs.dwFlags & RRA_WAIT)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;

    case WM_MEASUREITEM:
        if (((MEASUREITEMSTRUCT *) lParam)->CtlType == ODT_LISTBOX)
            return HandleLBMeasureItem(hWnd, (MEASUREITEMSTRUCT *) lParam);
        else
            return FALSE;

    case WM_DRAWITEM:
        if (((DRAWITEMSTRUCT *) lParam)->CtlType == ODT_LISTBOX)
            return HandleLBDrawItem(hWnd, (DRAWITEMSTRUCT *) lParam);
        else
            return FALSE;

    case WM_CTLCOLORLISTBOX:
        SetTextColor((HDC) wParam, GetSysColor(COLOR_BTNTEXT));
        SetBkColor((HDC) wParam, GetSysColor(COLOR_BTNFACE));
        return (LRESULT) g_hbrBkGnd;

    case WM_FINISHED:
        if (s_hThread != NULL)
        {
            while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
            {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            CloseHandle(s_hThread);
            s_hThread = NULL;
        }
        DestroyGlobals();
        EndDialog(hWnd, 0);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

LPSTR MakeAnsiStrFromWide(LPWSTR pwsz)
{
    LPSTR psz;
    int i;

    // arg checking.
    //
    if (!pwsz)
        return NULL;

    // compute the length
    //
    i =  WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
    if (i <= 0) return NULL;

    psz = (LPSTR) CoTaskMemAlloc(i * sizeof(CHAR));

    if (!psz) return NULL;
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, i, NULL, NULL);
    psz[i - 1] = 0;
    return psz;
}


BOOL CreateGlobals(HWND hwndCtl)
{

    LOGFONT lf;
    HDC hdc;
    HFONT hfontOld;

    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

    if ((hfontOld = (HFONT) (WORD) SendMessage(hwndCtl, WM_GETFONT, 0, 0L)) != NULL)
    {
        if (GetObject(hfontOld, sizeof(LOGFONT), (LPSTR) &lf))
        {
            // The CreateFontIndirect calls in IESetup Wzd works correctly on
            // all platforms... and they convert the Font name to Ansi
            // Hence to solve the Thai NT/Thai Win9x problem, we also convert
            // the font name to Ansi before calling CreateFontIndirect.

            // #58923: Now the FaceName returned by GetObject is not UNICODE on all
            // platforms. On Win9x, it is Ansi and this screws up things when
            // we call MakeAnsiStrFromWide on it. Hence to avoid problems, check
            // if returned FaceName is Wide <asumming FaceName always has more
            // than 2 chars in it.>
            if (lf.lfFaceName[1] == '\0')
            {
                LPSTR pszAnsiName;

                pszAnsiName = MakeAnsiStrFromWide((unsigned short *)lf.lfFaceName);
                lstrcpy((char *)lf.lfFaceName, pszAnsiName);
                CoTaskMemFree((LPVOID)pszAnsiName);
            }

            lf.lfWeight = 400;
            g_hfont = CreateFontIndirect(&lf);

            lf.lfWeight = 700;
            g_hBoldFont = CreateFontIndirect(&lf);
        }
    }

    if (g_hfont)
    {
        TCHAR *szLotsaWs = TEXT("WWWWWWWWWW");

        // Calc sensible size for text in buttons.
        hdc = GetDC(NULL);
        hfontOld = (HFONT) SelectObject(hdc, g_hfont);
        GetTextExtentPoint(hdc, szLotsaWs, lstrlen(szLotsaWs), &g_SizeTextExt);
        SelectObject(hdc, hfontOld);
        ReleaseDC(NULL, hdc);

        return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//
// RunOnceFill()
//   Fills the List box in the run-once dlg.
//
// ENTRY:
//  HWND of the thing to fill.
//
// EXIT:
//  <Params>
//
//***************************************************************************
BOOL RunOnceFill(HWND hWndLB)
{
    RunOnceExSection *pCurrentRunOnceExSection;
    int iSectionIndex;

    // if Title value is present, display it
    if (*g_szTitleString)
        SetWindowText(GetParent(hWndLB), g_szTitleString);

    for (iSectionIndex = 0;  iSectionIndex < g_aiArgs.iNumberOfSections;  iSectionIndex++)
    {
        pCurrentRunOnceExSection = (RunOnceExSection *) DPA_GetPtr(g_aiArgs.hdpaSections, iSectionIndex);

        if (*pCurrentRunOnceExSection->m_szDisplayName != TEXT('\0'))
            SendMessage(hWndLB, LB_ADDSTRING, 0, (LPARAM) pCurrentRunOnceExSection->m_szDisplayName);
    }

    return TRUE;
}


//***************************************************************************
//
// ShrinkToFit()
//     Makes the List box no bigger then it has to be
//     makes the parent window rsize to the LB size.
//
// ENTRY:
//     hwnd Parent
//     hwnd List box
//
// EXIT:
//
//***************************************************************************
void ShrinkToFit(HWND hWnd, HWND hLb)
{
    LONG lCount;
    LONG lNumItems;
    LONG lTotalHeight;
    LONG lHeight;
    RECT rWnd;
    LONG lChange;

    lTotalHeight = 0;
    lNumItems = (LONG)SendMessage(hLb, LB_GETCOUNT, 0, 0L);

    for (lCount = 0;  lCount < lNumItems;  lCount++)
    {
         lHeight = (LONG)SendMessage(hLb, LB_GETITEMHEIGHT, lCount, 0L);
         lTotalHeight += lHeight;
    }

    // Set the height of the ListBox to the number of items in it.
    GetWindowRect(hLb, &rWnd);
    SetWindowPos(hLb, hWnd, 0, 0, rWnd.right - rWnd.left - (CXBORDER * 2 + g_cxSmIcon), lTotalHeight, SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER);

    // Work out how much it changed in height
    lChange = lTotalHeight - (rWnd.bottom - rWnd.top);

    // Size the parent to fit around the child.
    GetWindowRect(hWnd, &rWnd);
    SetWindowPos(hWnd, 0, 0, 0, rWnd.right - rWnd.left, rWnd.bottom - rWnd.top + lChange, SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER);
}


//***************************************************************************
//
// RunAppsInList()
// Enumerates all the items in the list box, spawning each in turn.
//
// ENTRY:
//  HWND of Parent.
//
// EXIT:
//  <Params>
//
//***************************************************************************
DWORD RunAppsInList(LPVOID lp)
{
    ProcessSections(g_aiArgs.hkeyParent, g_aiArgs.pszSubkey, g_aiArgs.dwFlags, g_aiArgs.hdpaSections, g_aiArgs.iNumberOfSections, (HWND) lp);

    // terminate the dialog box
    PostMessage(GetParent((HWND) lp), WM_FINISHED, 0, 0L);

    return 0;
}


LRESULT HandleLBMeasureItem(HWND hDlg, MEASUREITEMSTRUCT *lpmi)
{
    RECT    rWnd;
    int     wWnd;
    HDC     hDC;
    HFONT   hfontOld;
    TCHAR   szText[MAX_ENTRYNAME];

    // Get the Height and Width of the child window
    GetWindowRect(hDlg, &rWnd);
    wWnd = rWnd.right - rWnd.left;

    lpmi->itemWidth = wWnd;

    hDC = GetDC(NULL);

    if ((hfontOld = (HFONT) SelectObject(hDC, g_hBoldFont)) != 0)
    {
        rWnd.top    = 0;
        rWnd.left   = CXBORDER * 2 + g_cxSmIcon;
        rWnd.right  = lpmi->itemWidth - rWnd.left - CXBORDER * 2 - g_cxSmIcon;
        rWnd.bottom = 0;

        *szText = TEXT('\0');
        SendMessage(GetDlgItem(hDlg, IDC_LIST2), LB_GETTEXT, (WPARAM) lpmi->itemID, (LPARAM) szText);
        DrawText(hDC, szText, lstrlen(szText), &rWnd, DT_CALCRECT | DT_WORDBREAK);

        SelectObject(hDC, hfontOld);
    }

    ReleaseDC(NULL, hDC);

    lpmi->itemHeight = rWnd.bottom + CXBORDER * 2;

    return TRUE;
}


//***************************************************************************
//
// HandleLBDrawItem()
//  Draws the Title, Text, and icon for an entry.
//
// ENTRY:
//  HWND and the Item to draw.
//
// EXIT:
//  <Params>
//
//***************************************************************************
LRESULT HandleLBDrawItem(HWND hDlg, DRAWITEMSTRUCT *lpdi)
{
    RECT rc;
    HFONT hfontOld;
    int xArrow,y;
    BITMAP bm;
    HGDIOBJ hbmArrow, hbmOld;
    TCHAR   szText[MAX_ENTRYNAME];

    // Don't draw anything for an empty list.
    if ((int) lpdi->itemID < 0)
        return TRUE;

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        // Put in the Title text
        hfontOld  = (HFONT) SelectObject(lpdi->hDC, (lpdi->itemState & ODS_SELECTED) ? g_hBoldFont : g_hfont);

        ExtTextOut(lpdi->hDC, lpdi->rcItem.left + CXBORDER * 2 + g_cxSmIcon, lpdi->rcItem.top + CXBORDER,
                   ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

        rc.top    = lpdi->rcItem.top    + CXBORDER;
        rc.left   = lpdi->rcItem.left   + CXBORDER * 2 + g_cxSmIcon;
        rc.right  = lpdi->rcItem.right;
        rc.bottom = lpdi->rcItem.bottom;

        *szText = TEXT('\0');
        SendMessage(GetDlgItem(hDlg, IDC_LIST2), LB_GETTEXT, (WPARAM) lpdi->itemID, (LPARAM) szText);
        DrawText(lpdi->hDC, szText, lstrlen(szText), &rc, DT_WORDBREAK);

        SelectObject(lpdi->hDC, hfontOld);

        // Draw the little triangle thingies.
        if (lpdi->itemState & ODS_SELECTED)
        {
            if (!g_hdcMem)
            {
                g_hdcMem = CreateCompatibleDC(lpdi->hDC);
            }

            if (g_hdcMem)
            {
                hbmArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
                GetObject(hbmArrow, sizeof(bm), &bm);

                hbmOld = SelectObject(g_hdcMem, hbmArrow);

                xArrow = lpdi->rcItem.left + CXBORDER;
                y = ((g_SizeTextExt.cy - bm.bmHeight) / 2) + CXBORDER + lpdi->rcItem.top;
                BitBlt(lpdi->hDC, xArrow, y, bm.bmWidth, bm.bmHeight, g_hdcMem, 0, 0, SRCAND);

                SelectObject(g_hdcMem, hbmOld);

                DeleteObject(hbmArrow);
            }
        }
    }

    return TRUE;
}


void DestroyGlobals(void)
{
    if (g_hfont)
    {
        DeleteObject(g_hfont);
        g_hfont = NULL;
    }

    if (g_hBoldFont)
    {
        DeleteObject(g_hBoldFont);
        g_hBoldFont = NULL;
    }

    if (g_hbrBkGnd)
    {
        DeleteObject(g_hbrBkGnd);
        g_hbrBkGnd = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iernonce\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iernonce.rc
//
#define IDS_RUNONCEEX_BAD_FUNCTIONNAME  100
#define IDS_RUNONCEEX_CANNOT_LOAD_DLL   101
#define IDS_RUNONCEEX_EXCEPTION         102
#define IDS_RUNONCEEX_BAD_SHELLEXEC_CMD 103
#define IDS_RUNONCEEX_CANNOT_FIND_FUNCTION 104
#define IDS_RUNONCEEX_EXE_EXCEPTION     105
#define IDS_RUNONCEEX_FIND_FUNC_FAILED  106
#define IDS_RUNONCEEX_LOAD_DEPEND_FAILED 107
#define IDS_RUNONCEEX_REGISTER_ERROR    108
#define IDS_RUNONCEEX_NOT_NT_ADMIN      109
#define IDS_RUNONCEEX_TITLE             110
#define IDS_RUNONCEEX_SERVICE_REQUIRES_REBOOT 111
#define IDI_SETUP                       132
#define IDD_RUNONCE                     1999
#define IDC_LIST2                       2009
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\fixie.h ===
#include "inseng.h"
#include "advpub.h"
#include "iesetup.h"
#include "resource.h"
#include <regstr.h>

extern HINSTANCE g_hInstance;

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
HRESULT FixIE(BOOL bConfirm, DWORD dwFlags);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#define WM_FINISHED             (WM_USER + 0x123)

#define MAX_STRING      1024
#define MAX_VER           64
#define MAX_CONTENT   0x7fff
#define BUFFERSIZE      1024

#define FIXIE_NORMAL    0x00000000
#define FIXIE_QUIET     0x00000001
#define FIXIE_ICONS     0x00000002

typedef struct _LINKEDCIFCOMPONENT
{
    ICifComponent *pCifComponent;
    char szGuid[MAX_STRING];
    char szVFS[MAX_STRING];
    char szROEX[MAX_STRING];
    char szPostROEX[MAX_STRING];
    struct _LINKEDCIFCOMPONENT *next;
} LINKEDCIFCOMPONENT, *LCIFCOMPONENT;

// ENTRY POINT FOR IERNONCE.DLL

#define achRunOnceExProcess "RunOnceExProcess"

void WINAPI RunOnceExProcess(HWND hWnd, HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow);

typedef HRESULT (WINAPI *RUNONCEEXPROCESS)
(
 HWND hWnd,
 HINSTANCE hInstance,
 LPSTR lpCmdLine,
 int nCmdShow
 );


typedef VOID (*RUNONCEEXPROCESSCALLBACK)
(
 int nCurrent,
 int nMax,
 LPSTR pszError
 );

#define achInitCallback "InitCallback"

void WINAPI InitCallback(RUNONCEEXPROCESSCALLBACK pCallbackProc, BOOL bQuiet);

typedef VOID (WINAPI *INITCALLBACK)
(
 RUNONCEEXPROCESSCALLBACK pCallbackProc,
 BOOL bQuiet
 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\guids.cpp ===
#include "pch.h"

#define INITGUID
#include <initguid.h>

#include "inseng.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iernonce\iernonce.cpp ===
/************************************************************\
    FILE: iernonce.cpp

    CREATED: October 16, 1996

  HISTORY:
        Initial version from BryanSt.
        Modified extensively for UI, root dependencies, bug fixes, etc. by PritObla.

    COPYRIGHT:
        Copyright (c) 1996 Microsoft Coporation.


    DEFINITIONS:
        SECTION - The old RunOnce API is in a flat section.  The RunOnceEx
            API groups entries into sections for managability.  If the
            Status dialog is displayed, it will display each section
            name while it's being processed.  Example sections for
            Internet Explorer would be: ActiveX, Java, Internet Explorer.
        ENTRY   - Entries are listed in a section.  These are commands
            that need to be carried out.  The commands can be a string
            to execute, a DLL to register (regsvr32), a DLL to unregister (regsvr32 -u),
            or to call a function in a DLL that has WinMain parameters (rundll32).

    DESCRIPTION:
    1.0 Goal
        Currently the "Run" and "RunOnce" feature in Explorer.exe will shell
        execute commands when the shell starts up.  Several features are
        needed for this to be more robust for Internet Explorer 4.0.

        The replacements are RunEx for Run and RunOnceEx for RunOnce.  The
        main features are:
         Status - A dialog will be displayed while the items are being
          processed.  Internet Explorer 4.0 adds at least 30 items which
          take more than a minute on 486 machines.  The entries to be
          processed will be grouped into sections and the dialog will
          highlight the current section being processed.  The status dialog
          feature can be turned off by using a flag.
         Performance - The majority of the Run and RunOnce commands are
          calls to regsvr32.exe and runonce32.exe.  These create separate
          processes which is very inefficient.  This API will not create
          separate processes for DLLs that need to be called in the same way
          that regsvr32.exe or rundll32.exe calls DLLs.  This API also supports
          a dependency list of DLLs that should remain loaded while either all
          the sections or some of the sections are being processed.
         Error Handling - If an exception occurs while calling a function in
          a DLL, the exception will be caught and error dialog will be
          displayed to the user.  This error dialog can be suppressed using a
          flag in the API, but this is recommended only for cases where a
          debug is installed because it will crash explorer.exe.  If a flag is
          set, an error and/or logging file can be generated in %WinDir% for
          debugging purposes.
         Deterministic - Currently the order that the entries are processed
          is not deterministic.  This new API will sort the entries and
          sections alphabetically to force a deterministic order.  The current
          API will not wait until one entry is finished before starting the
          next entry, except for RunOnce items in Local_Machine.  In order to
          be deterministic, this API will process command synchronously unless
          a flag is set to turned off this functionality.
         Export Functionality - This API will be added to shell32.dll and
          called from explorer.exe.  API functions will be exported so other
          applications can use this functionality if needed.

    2.0 Registry Structure
    2.1 RegistryFormat
        Text in italics are strings generated by the user.

        [Local_Machine] or [Current_User]
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunEx (same as RunOnceEx below)
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx
            Flags = [DWORD] 0x0000000
            Title = [STR] "Status Dialog Title"  (Example, "Installing Internet Explorer 4.0")
            Depend\
                <PlaceHolder1> = [STR] "<DLL/OCX Filename>" (filename with or without the path)
                <PlaceHolder...> = [STR] "<DLL/OCX Filename>" (filename with or without the path)
            <SectionPlaceHolder1>\
                @="SectionName1"
                <Entry1> = [STR] "<EntryFormat>" (See Entry Format description below)
                <Entry...> = [STR] "<EntryFormat >"
            Depend\
                <PlaceHolder1> = [STR] "<DLL/OCX Filename>"
                <PlaceHolder...> = [STR] "<DLL/OCX Filename>"
            < SectionPlaceHolder2>\

    2.1.1 Flags
        // Old RunOnce Flags
        #define    RRA_DEFAULT          0x0000
        #define    RRA_DELETE               0x0001
        #define    RRA_WAIT             0x0002
        #define    RRA_SHELLSERVICEOBJECTS  0x0004

        // New RunOnceEx Flags
        #define    RRAEX_NO_ERROR_DIALOGS   0x0008
        #define    RRAEX_ERRORFILE          0x0010
        #define    RRAEX_LOG_FILE           0x0020
        #define    RRAEX_NO_EXCEPTION_TRAPPING  0x0040
        #define    RRAEX_NO_STATUS_DIALOG       0x0080
        #define    RRAEX_IGNORE_REG_FLAGS       0x0100


        RRA_DEFAULT - All features are off but can be turned on by the flags
            in the Flags registry key.
        RRA_DELETE - Delete the registry entries after processing them.
            Normally used for RunOnceEx and not used for RunEx.
        RRA_WAIT - If the entry is a command to be executed, this flag causes
            the items to be processed synchronously.
        RRA_SHELLSERVICEOBJECTS - If this flag is set, we load inproc dlls
            from the registry key and QI them for IOleCommandTarget.
            CGID_ShellServiceObject notifications are sent to these objects
            letting them know about shell status.
        RRAEX_NO_STATUS_DIALOG - Use this flag to cause the Status dialog to
            not be displayed while processing the entries.
        RRAEX_ NO_ERROR_DIALOGS - This flag will turn off error dialogs from
            being displayed.
        RRAEX_ERRORFILE - This flag will cause the file "C:\Windows\RunOnceEx.err"
            to be created if errors occur.
        RRAEX_LOG_FILE - This flag will cause the file "C:\Windows\RunOnceEx.log"
            to be created giving the status of commands being executed.  (For debugging)
        RRAEX_ NO_EXCEPTION_TRAPPING - If this flag is set, exceptions will
            not be caught when registering DLLs.  This should only be used when a
            debug is setup or buggy DLLs will cause explorer.exe to crash.
        RRAEX_IGNORE_REG_FLAGS - If this flag is set, then the Flags registry
            entry will be ignored.

        The Flags registry key will be deleted if the RRAEX_DELETE flag was
        set.

    2.1.2 Title
        The Status Dialogs title will be set to Title registry key if it
        exists.  This key will be deleted if the RRAEX_DELETE flag was set.
    2.1.3 Top Level Depend Entries
        Each entry under the Depend branch will be read.  These registry
        entries need to be type STR and the data needs to be a valid filename
        with or without a path.  The registry value will be ignored.
        LoadLibrary() will be called on each entry and they will remain loaded
        until all the sections have been processed.  This key will be deleted
        if the RRA_DELETE flag was set.

        Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\Depend
            "Should stay loaded" = [STR] "shell32.dll"
    2.1.4 Sections
        Each non-"Depend" keys under RunEx and RunOnceEx is considered a
        section.  The names of the Sections are read into memory, sorted
        alphabetically.  The key name is displayed in the Status Dialog if
        the key doesnt have data to specify the Display Name.  The sections
        will be processed in alphabetic order.  The Sections branch in the
        registry will be deleted after being processed if the RRAEX_DELETE
        flag was set.

        Each Section will contain "entries" which are string registry keys.
        The registry entry value is only used to sort the entries.  The
        registry entry data will be in the format specified in 2.2 Entry
        Format.

        Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\IE4 03 Java
            @="Java"
            "IE4 01 Java" = [STR] "||my.exe -quiet -url http://www.microsft.com/"
            "IE4 02 Main Java File" = [STR] "msjava.dll|DllRegisterServer"

        If the Section has a Display Name, then the key name should contain
        an abbreviation of the product followed by a number that specifies
        the order that this section should be processed in.  Because the
        section names are sorted alphabetically, this will make sure that
        all entries for one product are processed together and that the number
        makes the order obvious.

        An Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\IE4 03 Java
            @="Java"
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\IE4 04 Scripting
            @="ActiveX Scripting"

    2.1.4.1 Section Dependencies
        The list off DLLs in the sections Depend key are loaded before a
        sections entries are executed and then unloaded after they have
        been executed.  This key will be deleted if the RRA_DELETE flag was
        set.

        Example:
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\Java
            "IE4 01 Java" = [STR] "||my.exe -quiet -url http://www.microsft.com/"
            "IE4 02 Java" = [STR] "shdocvw.dll|DllRegisterServer"
        SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\Java\Depend
            "Keep Loaded" = [STR] "urlmon.dll"

    2.2 Entry Format
        "<DllFileName>|<FunctionName>|<CmdLineArgs>"

        The Entry Format will fall into one of three categories,
        1) Shell Execute (same as old RunOnce method),
        2) Call DllRegisterServer or DllUnregisterServer in the
        specified DLL (same as regsvr32.exe), and 3) Call a function
        in the specified DLL with WinMain parameters (same as rundll32.exe)
        and the <CmdLineArgs> will be passed in the CmdLine parameter.
         Register DLL - The <DllFileName> is required to be non-empty.  The
          <FunctionName> sections must equal "DllRegisterServer" or
          "DllUnregisterServer".  The <CmdLineArgs> must be empty and there
          must not be a semicolon after <FunctionName>.
          Example: "shdocvw.dll|DllRegisterServer".
         Calling a Function - The <DllFileName> and <FunctionName> sections
          are required to be non-empty. The <CmdLineArgs> can be empty and there
          must be a semicolon after <FunctionName>.
          Example: "C:\winnt\system32\my.dll|MyWinMain|-Start".
         Shell Execute - The <DllFileName> and <FunctionName> sections are
          required to be empty.  The <DllFileName> string will be executed in
          same way the old RunOnce items where executed.
          Example: "||iexplore.exe http://www.microsoft.com/".

    3.0 Function Calls
        void ProcessRunOnceEx(DWORD dwFlags);
        This function will call RunRegAppsAndObjectsEx() with the RunEx and
        RunOnceEx registry keys in both Local_Machine and Current_User
        sections of the registry with the Flags passed in. RRA_WAIT will be
        passed because its on be default. RRA_DELETE will be passed for
        RunOnceEx.

        void RunRegAppsAndObjectsEx(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags);
        This function will process the entries in this section of the registry.
        The szSubKey cannot point to a section of the registry that has the
        old Run or RunOnce format.


\************************************************************/

/*Includes---------------------------------------------------------*/

#include "iernonce.h"
#include "resource.h"

#ifdef WX86
#include <wx86ofl.h>
#endif // WX86

//////////////////////////////////////////////////////////////////
//  Constants:
//////////////////////////////////////////////////////////////////
#define MAX_REG_PATH            256             // Registry paths should not get much longer than this or there is a major perf hit
#define MAX_REG_VALUE           80              // Registry values should not get much longer than this or there is a major perf hit
#define ARRAY_GROW_RATE         32              // This should be large enough to cover most applications
#define SEPERATOR_CHAR          TEXT('|')

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

typedef enum
{
    eHDL_Load,
    eHDL_Unload
} HDL_Type;

typedef int (*WINMAIN_PARAMS)(HINSTANCE, HINSTANCE, LPSTR, int);
typedef LONG (*DLLREGISTERSERVER_PARAMS)();
typedef HRESULT (*DLLINSTALL_PARAMS)(BOOL bInstall, LPCWSTR pszCmdLine);


//////////////////////////////////////////////////////////////////
//  GLOBALS:
//////////////////////////////////////////////////////////////////

const TCHAR   * c_szDependencyName          = TEXT("Depend");
const TCHAR   * c_szFlagsRegValue           = TEXT("Flags");
const TCHAR   * g_c_szTitleRegValue         = TEXT("Title");
const TCHAR   * g_c_szSystemDat             = TEXT("system.dat");
const TCHAR   * g_c_szSystem1st             = TEXT("system.1st");
const TCHAR   * g_c_szSetupKey              = TEXT("Software\\Microsoft\\IE Setup\\Setup");
const TCHAR   * g_c_szRegBackupPath         = TEXT("RegistryBackup");
const TCHAR   * g_c_szServicesRegValue      = TEXT("Services");


HINSTANCE       g_hinst                     = NULL;
HANDLE          g_hHeap                     = NULL;

RUNONCEEXPROCESSCALLBACK g_pCallbackProc    = NULL;
BOOL                     g_bQuiet           = FALSE;
int                      g_nTotal           = 0;
int                      g_nCurrent         = 0;

BOOL            g_bRunningOnNT              = FALSE;
BOOL            g_bBackupSystemDat          = FALSE;
#if 0
BOOL            g_bDeleteSystemIE4          = FALSE;
#endif
int             g_iNDisplaySections         = 0;
TCHAR           g_szTitleString[256]        = TEXT("");

// related to logging
HANDLE          g_hLogFile                  = INVALID_HANDLE_VALUE;

#ifdef WX86
//  If Wx86 has to be loaded we use this flag to make sure it is unloaded
//  at the end of RunOnceExProcess.
BOOL            g_fWx86Loaded               = FALSE;
#endif

//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
void    WINAPI  RunOnceExProcess(HWND hWnd, HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow);
void            RunOnceExProcessReg(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags);
HDPA            GetSections(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags, int * pNumberOfSections);
HDPA            GetEntries(HKEY hRootKey, LPCTSTR szSectionName, DWORD dwFlags, int * pNumberOfEntries);
void            HandleDependencyDLLs(HKEY hkeyParent, LPCTSTR szRegPath, LPCTSTR szRegSubPath, DWORD dwFlags, HDL_Type hdlDirection);
DWORD           GetFlagsInRegistry(HKEY hkeyParent, LPCTSTR szSubkey);
void            ShellExecuteRegApp(LPTSTR pszCmdLine, DWORD dwFlags);
BOOL            HaveDependServices(SC_HANDLE hService);
void            CheckServices(DWORD dwFlags);

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        OSVERSIONINFO osvi;

        DisableThreadLibraryCalls(hDLLInst);

        // The DLL is being loaded for the first time by a given process.
        // Perform per-process initialization here.  If the initialization
        // is successful, return TRUE; if unsuccessful, return FALSE.

        // Initialize the global variable holding the hinstance:
        g_hinst = hDLLInst;
        g_hHeap = GetProcessHeap();

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
            g_bRunningOnNT = TRUE;
    }
    return TRUE;
}

#ifdef WX86

/****************************************************\
    FUNCTION: RunOnceLoadLibrary

    PARAMETERS:
        LPCTSTR lpszFileName - DLL to load

        BOOL* pfWx86DLL - Ptr to a BOOL that we set to
            TRUE if the DLL is x86.            

    DESCRIPTION:
        This function will is a wrapper for LoadLibraryEx()
        that will also load x86 DLLs on RISC.
\***************************************************/

HINSTANCE RunOnceLoadLibrary( LPCTSTR lpszFileName, BOOL* pfWx86DLL )
{
    HINSTANCE hInstance = LoadLibraryEx(lpszFileName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if ( (hInstance == NULL) && (GetLastError() == ERROR_BAD_EXE_FORMAT) )
    {
        WCHAR achDllToLoad[ MAX_PATH ];
#ifdef UNICODE
        lstrcpy(achDllToLoad, lpszFileName);
#else // UNICODE
        MultiByteToWideChar(CP_ACP, 0, lpszFileName, -1,
                            achDllToLoad, ARRAYSIZE(achDllToLoad));
#endif // UNICODE
        if ( !g_fWx86Loaded )
        {
            g_fWx86Loaded = Wx86Load();
        }

        if ( g_fWx86Loaded )
        {
            hInstance = Wx86LoadX86Dll(achDllToLoad, LOAD_WITH_ALTERED_SEARCH_PATH);
            if ( hInstance != NULL )
            {
                *pfWx86DLL = TRUE;
            }
        }
    }
    return hInstance;
}

#else // WX86

//  If we're on x86 then a simple macro works...
#define RunOnceLoadLibrary(_arg1, _arg2) LoadLibraryEx(_arg1, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)

#endif // WX86

void BackupRegistry()
{
   HKEY hkSetup = NULL;
   DWORD unused;
   TCHAR szSystemDatPath[MAX_PATH]         = TEXT("");
   TCHAR szSystemIE4Path[MAX_PATH]         = TEXT("");

   // flush the registry and copy system.dat to system.ie4;
   // this is for the PSS folks; if the registry gets corrupt after IE4 has been installed, user can copy system.ie4 to system.dat
   // quite an expensive operation!
   RegFlushKey(HKEY_CLASSES_ROOT);
   RegFlushKey(HKEY_CURRENT_USER);
   RegFlushKey(HKEY_LOCAL_MACHINE);
   RegFlushKey(HKEY_USERS);

   GetWindowsDirectory(szSystemDatPath, ARRAYSIZE(szSystemDatPath));
   if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, g_c_szSetupKey, 0, NULL,
                     REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                     NULL, &hkSetup, &unused) == ERROR_SUCCESS)
   {
      unused = sizeof(szSystemIE4Path);
      RegQueryValueEx(hkSetup, g_c_szRegBackupPath, 0, NULL, (BYTE *)szSystemIE4Path, &unused);
   }
   // if we don't have a path yet default to root of windows drive
   if(szSystemIE4Path[0] == TEXT('\0'))
   {
      lstrcpy(szSystemIE4Path, szSystemDatPath);
      GetParentDir(szSystemIE4Path);
      AddPath(szSystemIE4Path, g_c_szSystem1st);
   }

   AddPath(szSystemDatPath, g_c_szSystemDat);

   SetFileAttributes(szSystemDatPath, FILE_ATTRIBUTE_NORMAL);
   SetFileAttributes(szSystemIE4Path, FILE_ATTRIBUTE_NORMAL);

   if(CopyFile(szSystemDatPath, szSystemIE4Path, FALSE))
   {
      // Record where we put it in the registry
      if(hkSetup)
         RegSetValueEx(hkSetup, g_c_szRegBackupPath, 0, REG_SZ,
                       (BYTE *)szSystemIE4Path, sizeof(TCHAR) * (lstrlen(szSystemIE4Path) + 1));

      // Write something to the active setup log


   }

   if(hkSetup)
      RegCloseKey(hkSetup);

   SetFileAttributes(szSystemDatPath, FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
   SetFileAttributes(szSystemIE4Path, FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
}

VOID InitCallback(RUNONCEEXPROCESSCALLBACK pCallbackProc, BOOL bQuiet)
{
    g_pCallbackProc = pCallbackProc;
    g_bQuiet = bQuiet;
}

/****************************************************\
    FUNCTION: RunOnceExProcess

    PARAMETERS:
        DWORD dwFlags - Caller can specify behavior
                with flags.

    DESCRIPTION:
        This function will run the RunEx API.  It will
    process RunOnceEx and RunEx in both Current_User
    and Local_Machine
\***************************************************/
void WINAPI RunOnceExProcess(HWND hWnd, HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow)
{
    const TCHAR    * szRunOnceExPath            = REGSTR_PATH_RUNONCEEX;
    //const TCHAR    * szRunExPath                = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunEx");
    DWORD           dwFlags                     = RRA_DEFAULT;

    if (lpCmdLine != NULL)
        dwFlags |= AtoL(lpCmdLine);

    if (g_bQuiet)
        dwFlags |= RRAEX_NO_STATUS_DIALOG | RRAEX_NO_ERROR_DIALOGS;

    RunOnceExProcessReg(HKEY_LOCAL_MACHINE, szRunOnceExPath, dwFlags | RRA_DELETE | RRA_WAIT);
    RunOnceExProcessReg(HKEY_CURRENT_USER, szRunOnceExPath, dwFlags | RRA_DELETE | RRA_WAIT);

#ifdef WX86
    if ( g_fWx86Loaded )
    {
        Wx86Unload();
    }
#endif

    //RunOnceExProcessReg(HKEY_LOCAL_MACHINE, szRunExPath, dwFlags);
    //RunOnceExProcessReg(HKEY_CURRENT_USER, szRunExPath, dwFlags);

    if (!g_bRunningOnNT  &&  g_bBackupSystemDat)
    {
        BackupRegistry();
    }
    if (g_bRunningOnNT)
    {
        CheckServices(dwFlags);
    }
}


/****************************************************\
    FUNCTION: RunOnceExProcessReg

    PARAMETERS:
        HKEY hkeyParent - Registry Branch to process.
        LPCTSTR pszSubkey - Registry Path to process.
        DWORD dwFlags - Registry Entry to modify.

    DESCRIPTION:
        This function will run the API on one part of
    the registry.
\***************************************************/
void RunOnceExProcessReg(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags)
{
    HDPA                hdpaSections            = NULL;
    HKEY                hRunExKey               = NULL;
    RunOnceExSection    * pCurrentSection       = NULL;
    int                 iNumberOfSections       = 0;
    int                 iIndex;
    ARGSINFO            aiArgs;
    static DWORD        dwCreationFlags         = CREATE_ALWAYS;    // first time the log file is opened, the contents should be truncated
    static TCHAR        szLogFileName[MAX_PATH] = TEXT("");

    if (!(RRAEX_IGNORE_REG_FLAGS & dwFlags))
        dwFlags |= GetFlagsInRegistry(hkeyParent, pszSubkey);

    *g_szTitleString = TEXT('\0');
    if (RegOpenKeyEx(hkeyParent, pszSubkey, NULL, KEY_READ, &hRunExKey) == ERROR_SUCCESS)
    {
        DWORD dwTitleSize = sizeof(g_szTitleString);

        // if a value for Title is specified, read it in
        RegQueryValueEx(hRunExKey, g_c_szTitleRegValue, NULL, NULL, (LPBYTE) g_szTitleString, &dwTitleSize);
        RegCloseKey(hRunExKey);
    }

    // don't process if there are entries in wininit.ini or PendingFileRenameOperations
    if ((dwFlags & RRAEX_QUIT_IF_REBOOT_NEEDED)  &&  NeedReboot(0))
        return;

    if (g_bRunningOnNT  &&  (dwFlags & RRAEX_CHECK_NT_ADMIN)  &&  !IsNTAdmin(0, NULL))
    {
        // user has no NT Admin privileges; we cannot process the RunOnceEx items

        // make sure that the msg box is displayed
        ReportError((dwFlags & ~RRAEX_NO_ERROR_DIALOGS), IDS_RUNONCEEX_NOT_NT_ADMIN);
        LogOff(FALSE);

        // won't reach here
        return;
    }

    if (dwFlags & RRAEX_BACKUP_SYSTEM_DAT)
        g_bBackupSystemDat = TRUE;

    if (dwFlags & RRAEX_LOG_FILE)
    {
        if (*szLogFileName == TEXT('\0'))
            GetLogFileName(TEXT("RunOnceExLogFile"), szLogFileName, ARRAYSIZE(szLogFileName));

        if (*szLogFileName)
        {
            if (hkeyParent == HKEY_LOCAL_MACHINE)
            {
                TCHAR szBuf[MAX_PATH + MAX_REG_PATH + 16];

                // dump the registry entries before we process them so that if some error occurs,
                // it is easy to cut and paste the entries to a reg file and import it.
                wsprintf(szBuf, TEXT("regedit /e \"%s\" HKEY_LOCAL_MACHINE\\%s"), szLogFileName, pszSubkey);
                ShellExecuteRegApp(szBuf, RRA_WAIT);
                dwCreationFlags = OPEN_ALWAYS;      // from now on, the log file should be opened in append mode
            }

            StartLogging(szLogFileName, dwCreationFlags);
            dwCreationFlags = OPEN_ALWAYS;      // from now on, the log file should be opened in append mode
        }
    }

    // Log that we are starting to process these commands.
    WriteToLog(TEXT("[%1:%2]\r\n"), (HKEY_LOCAL_MACHINE == hkeyParent) ? TEXT("HKLM"):TEXT("HKCU"), pszSubkey);
    LogFlags(dwFlags);

    g_iNDisplaySections = 0;
    hdpaSections = GetSections(hkeyParent, pszSubkey, dwFlags, &iNumberOfSections);

    // Load the dependency DLLs that are common to all sections
    HandleDependencyDLLs(hkeyParent, pszSubkey, "", dwFlags, eHDL_Load);

    if (iNumberOfSections)          // call ProcessSections only if there is atleast one section to process
    {
        // show UI if the NO_STATUS_DIALOG flag is NOT specified, and
        // there is atleast one section that has display text
        if (0 == (RRAEX_NO_STATUS_DIALOG & dwFlags)  &&  g_iNDisplaySections)
        {
            // pack the args of ProcessSections into aiArgs
            aiArgs.hkeyParent = hkeyParent;
            aiArgs.pszSubkey = pszSubkey;
            aiArgs.dwFlags = dwFlags;
            aiArgs.hdpaSections = hdpaSections;
            aiArgs.iNumberOfSections = iNumberOfSections;

            DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_RUNONCE), NULL, (DLGPROC) DlgProcRunOnceEx, (LPARAM) &aiArgs);
        }
        else
            ProcessSections(hkeyParent, pszSubkey, dwFlags, hdpaSections, iNumberOfSections, NULL);
    }

    // Unload the dependency DLLs that are common to all sections
    HandleDependencyDLLs(hkeyParent, pszSubkey, "", dwFlags, eHDL_Unload);

    // We iterate twice.  Once to process all the entries, and the second time to delete
    // the entries.  We do this because some code (like Dialog Status drawing) might want
    // to access previously processed entries.
    for (iIndex = 0; iIndex < iNumberOfSections; iIndex++)
    {
        pCurrentSection = (RunOnceExSection *) DPA_GetPtr(hdpaSections, iIndex);
        if (pCurrentSection)
        {
            delete pCurrentSection;
        }
    }

    if (hdpaSections)
    {
        DPA_Destroy(hdpaSections);
        hdpaSections = NULL;
    }

    // Delete the Flags and Title registry entry if the Delete flag is set.
    if (RRA_DELETE & dwFlags)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, pszSubkey, NULL, KEY_READ | KEY_WRITE, &hRunExKey))
        {
            // Delete this key if the Delete key is set anywhere.
            RegDeleteValue(hRunExKey, c_szFlagsRegValue);
            RegDeleteValue(hRunExKey, g_c_szTitleRegValue);
            RegCloseKey(hRunExKey);
        }
    }

    WriteToLog(TEXT("\r\n"));

    if (dwFlags & RRAEX_LOG_FILE)
        StopLogging();
}


/****************************************************\
    FUNCTION: ProcessSections

    PARAMETERS:
        HKEY hkeyParent - Registry Branch to process.
        LPCTSTR pszSubkey - Registry Path to process.
        DWORD dwFlags - Registry Entry to modify.
        HDPA hdpaSections - Array of Sections
        int iNumberOfSections - Number of Sections in the Array

    DESCRIPTION:
        This function will call to have each Section
    processed.
\***************************************************/
void ProcessSections(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags, HDPA hdpaSections, int iNumberOfSections, HWND hWnd)
{
    RunOnceExSection    * pCurrentSection         = NULL;
    int                 iIndex, iDisplayIndex;
    BOOL                fOleInitialized           = TRUE;

    // Got to initialize it here; if it's done in RunOnceExProcess, i.e., process level initialization,
    // registration of asctrls.ocx fails -- looks like OleInitialize needs to be done per thread
    if (FAILED(OleInitialize(NULL)))
        fOleInitialized = FALSE;

    iDisplayIndex = -1;

    // If there's a callback, count total things to do...
    if (g_pCallbackProc)
    {
        g_nTotal = 0;
        g_nCurrent = 0;
        for (iIndex = 0; iIndex < iNumberOfSections; iIndex++)
        {
            if ((pCurrentSection = (RunOnceExSection *) DPA_GetPtr(hdpaSections, iIndex)) == NULL)
                continue;
            g_nTotal += pCurrentSection->m_NumberOfEntries;
        }
    }

    for (iIndex = 0; iIndex < iNumberOfSections; iIndex++)
    {
        if ((pCurrentSection = (RunOnceExSection *) DPA_GetPtr(hdpaSections, iIndex)) == NULL)
            continue;

        if (hWnd != NULL)
        {
            if (*pCurrentSection->m_szDisplayName != TEXT('\0'))
                SendMessage(hWnd, LB_SETCURSEL, ++iDisplayIndex, 0);
            else if (iDisplayIndex == -1)
                SendMessage(hWnd, LB_SETCURSEL, 0, 0);
        }

        pCurrentSection->Process(hkeyParent, pszSubkey, dwFlags);
    }

    if (fOleInitialized)
        OleUninitialize();
}


/****************************************************\
    FUNCTION: GetFlagsInRegistry

    PARAMETERS:
        HKEY hkeyParent - What branch of the registry to look.
        LPCTSTR szSubkey - What path in the registry to look.
        DWORD return - Flags that were found in the registry

    DESCRIPTION:
        Return with the Flags found in the registry
    or RRA_DEFAULT if none where found.
\***************************************************/
DWORD GetFlagsInRegistry(HKEY hkeyParent, LPCTSTR szSubkey)
{
    DWORD           dwFlagsInRegistry           = RRA_DEFAULT;
    HKEY            hFlagsKey                   = NULL;
    DWORD           dwKeySize                   = sizeof(dwFlagsInRegistry);

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, szSubkey, NULL, KEY_QUERY_VALUE, &hFlagsKey))
    {
        RegQueryValueEx(hFlagsKey, c_szFlagsRegValue, NULL, NULL, (LPBYTE) &dwFlagsInRegistry, &dwKeySize);
        RegCloseKey(hFlagsKey);
    }

    return(dwFlagsInRegistry);
}


/****************************************************\
    FUNCTION: HandleDependencyDLLs

    PARAMETERS:
        HKEY hkeyParent - Registry Branch to process.
        LPCTSTR szRegPath - Registry Path to process.
        LPCTSTR szRegSubPath - Registry Path to process.
        DWORD dwFlags - Flags.  Do we want to delete after Unload?
        HDL_Type hdlDirection - Load or Unload?

    DESCRIPTION:
        This function will be passed a "Depend" section
    of the registry that will contain registry keys.
    These STR registry keys have filenames and data.
    These filenames need to be loaded (LoadLibrary())
    or freed (FreeLibrary()) depending on the HDL_Type
    parameter to this function.
\***************************************************/
void HandleDependencyDLLs(HKEY hkeyParent, LPCTSTR szRegPath, LPCTSTR szRegSubPath, DWORD dwFlags, HDL_Type hdlDirection)
{
    TCHAR           szBasePath[MAX_REG_PATH];
    TCHAR           szValueName[MAX_REG_VALUE];
    TCHAR           szDLLFileName[MAX_PATH];
    HKEY            hBaseKey                        = NULL;
    HKEY            hDependKey                      = NULL;
    DWORD           dwCurrDLL                       = 0;
    DWORD           dwKeyType                       = 0;
    DWORD           dwValueSize                     = ARRAYSIZE(szValueName);
    DWORD           dwDLLNameSize                   = sizeof(szDLLFileName);
    long            lEnumError;

    if ((NULL != szRegSubPath) && (TEXT('\0') != *szRegSubPath))      // If the szRegSubPath isn't empty, we concatonate the two strings.
        wsprintf(szBasePath, TEXT("%s\\%s"), szRegPath, szRegSubPath);
    else
        lstrcpy(szBasePath, szRegPath);

    // Open the key for Read only if we are doing a load or an unload where the registry does not need to be deleted.
    // If we are unloading and we need to remove the registry entry, this function will fail if the user doesn't have
    // permission.

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, szBasePath, NULL,
                                (KEY_READ | (((eHDL_Unload == hdlDirection) && (dwFlags & RRA_DELETE)) ? KEY_WRITE:0)), &hBaseKey))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, c_szDependencyName, NULL,
                                (KEY_READ | (((eHDL_Unload == hdlDirection) && (dwFlags & RRA_DELETE)) ? KEY_WRITE:0)), &hDependKey))
        {
            // Iterate through each value
            for (dwCurrDLL = 0;
                 ERROR_NO_MORE_ITEMS != (lEnumError = RegEnumValue(hDependKey, dwCurrDLL, szValueName, &dwValueSize, NULL, &dwKeyType, (LPBYTE) szDLLFileName, &dwDLLNameSize));
                 dwCurrDLL++)
            {
                if ((REG_SZ == dwKeyType) && (ERROR_SUCCESS == lEnumError))
                {
                    if (eHDL_Load == hdlDirection)
                    {
                        // We need to load this library to keep it in memory.
                        BOOL fWx86DLL;
                        if (NULL == RunOnceLoadLibrary( szDLLFileName, &fWx86DLL ))
                            ReportError(dwFlags, IDS_RUNONCEEX_LOAD_DEPEND_FAILED, szDLLFileName);
                        else
                            WriteToLog(TEXT("Dependency DLL loaded: %1\r\n"), szDLLFileName);
                    }
                    else        // Else Unload
                    {
                        // We need to unload this library
                        HINSTANCE   hInst   = GetModuleHandle(szDLLFileName);
                        if (NULL != hInst)
                        {
                            if (FreeLibrary(hInst))
                                WriteToLog(TEXT("Dependency DLL unloaded: %1\r\n"), szDLLFileName);
                        }
                    }
                }

                dwValueSize = ARRAYSIZE(szValueName);
                dwDLLNameSize = sizeof(szDLLFileName);
            }

            RegCloseKey(hDependKey);

            if ((eHDL_Unload == hdlDirection) && (dwFlags & RRA_DELETE))
            {
                // We need to remove the registry key so we don't process this again next time.
                RegDeleteKey(hBaseKey, c_szDependencyName);
            }
        }

        RegCloseKey(hBaseKey);
    }
}


/////////////////////////////////////////////////////////////////////
//  CLASS: RunOnceExEntry
/////////////////////////////////////////////////////////////////////

/****************************************************\
    FUNCTION: RunOnceExEntry

    PARAMETERS:
        LPTSTR lpszNewEntryName - Name of Entry
        LPTSTR lpszNewCmd       - Entry Command
        DWORD dwFlags           - Flags

    DESCRIPTION:
        This function will create a RunOnceEx Entry
    and set it's Name, Cmd, and section.
\***************************************************/
RunOnceExEntry::RunOnceExEntry(LPTSTR lpszNewEntryName, LPTSTR lpszNewCmd, DWORD dwFlags)
{
    const TCHAR * szRegisterFunctionName    = TEXT("DllRegisterServer");
    const TCHAR * szUnregisterFunctionName  = TEXT("DllUnregisterServer");
    const TCHAR * szInstallFunctionName     = TEXT("DllInstall");
    LPTSTR      lpszFileName                = lpszNewCmd;
    LPTSTR      lpszFunctionName            = NULL;
    LPTSTR      lpszCmdLineArgs             = NULL;
    LPTSTR      lpszCurrentChar             = lpszNewCmd;

    lstrcpy(m_szRunOnceExEntryName, lpszNewEntryName);
    m_ROAction = eRO_Unknown;
    *m_szFileName = TEXT('\0');
    *m_szFunctionName = TEXT('\0');
    *m_szCmdLineArgs = TEXT('\0');

    // These entries come in this format "<FileName>|<FunctionName>|<CmdLineArgs>".
    // We first need to find the end of the <FileName>.

    // Find the end of the filename.
    if (NULL == (lpszCurrentChar = LocalStrChr(lpszCurrentChar, SEPERATOR_CHAR)))
    {
        // It must be an EXE (or something that is executable) because it doesn't have a function name.
        lstrcpy(m_szCmdLineArgs, lpszNewCmd);
        m_ROAction = eRO_Exe;                           // Remember that we will need to ShellExec this later.
    }
    else
    {
        // We found a '|' so we have the <FileName>.
        *lpszCurrentChar = TEXT('\0');                  // Terminate the filename.
        lstrcpy(m_szFileName, lpszNewCmd);
        *lpszCurrentChar = SEPERATOR_CHAR;              // Remove the temporary termination.
        lpszCurrentChar = CharNext(lpszCurrentChar);

        // Now lets work on Getting the <FunctionName>.

        lpszFunctionName = lpszCurrentChar;             // Remember the beginning of the FunctionName before iterating.

        if (NULL == (lpszCurrentChar = LocalStrChr(lpszCurrentChar, SEPERATOR_CHAR)))
        {
            // If we have found the end of the string without the second '|', then
            // this needs to be a DllRegisterServer or DllUnregisterServer.

            lstrcpy(m_szFunctionName, lpszFunctionName);
            if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpszFunctionName, -1, szRegisterFunctionName, -1))
            {
                m_ROAction = eRO_Register;
            }
            else
            {
                if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpszFunctionName, -1, szUnregisterFunctionName, -1))
                {
                    m_ROAction = eRO_Unregister;
                }
                else
                {
                    m_ROAction = eRO_Unknown;
                    // An error has occured.  The user didn't specify a valid FunctionName.
                    ReportError(dwFlags, IDS_RUNONCEEX_BAD_FUNCTIONNAME, m_szFunctionName);
                }
            }
        }
        else
        {
            // We have enountered the second '|' which delemites the <CmdLineArgs> section.  By this point, the function we
            // are calling needs WinMain() parameters.or it's a DllInstall function

            *lpszCurrentChar = TEXT('\0');
            lstrcpy(m_szFunctionName, lpszFunctionName);
            *lpszCurrentChar = SEPERATOR_CHAR;            // Remove the temporary termination.
            lpszCurrentChar = CharNext(lpszCurrentChar);
            lstrcpy(m_szCmdLineArgs, lpszCurrentChar);

            if (TEXT('\0') == *m_szFunctionName)
            {
                if (TEXT('\0') == *m_szFileName)
                {
                    m_ROAction = eRO_Exe;
                }
                else
                {
                    // This command is invalid because commands to be shell execed need to start
                    // Need to have the <FileName> and <FunctionName> parameters empty.
                    m_ROAction = eRO_Unknown;
                    ReportError(dwFlags, IDS_RUNONCEEX_BAD_SHELLEXEC_CMD, lpszNewCmd);
                }
            }
            else
            {
                // check if it's DllInstall
                if (2 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, m_szFunctionName, -1, szInstallFunctionName, -1))
                {
                    m_ROAction = eRO_Install;
                }
                else
                {
                    m_ROAction = eRO_WinMainFunction;
                }
            }
        }
    }
}


/****************************************************\
    FUNCTION: ~RunOnceExEntry

    PARAMETERS:
        none

    DESCRIPTION:
        This destructor will free memory that it used.
\***************************************************/
RunOnceExEntry::~RunOnceExEntry()
{
}


/****************************************************\
    FUNCTION: RunOnceExEntry::Process

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        LPCTSTR szSectonName - Only used for logging purposes.
        DWORD dwFlags - Flags to determine if we delete command after executing it.

    DESCRIPTION:
        This function will Processes the entry.
    This means it will execute the command or
    call a function in a DLL.  After it finishes,
    it will delete the registry entry if appropriate.
\***************************************************/
void RunOnceExEntry::Process(HKEY hkeyParent, LPCTSTR szSubkey, LPCTSTR szSectionName, DWORD dwFlags)
{
    HINSTANCE       hInstance                       = NULL;
    WINMAIN_PARAMS  pfWinMainFunction               = NULL;
    DLLREGISTERSERVER_PARAMS    pfDllRegisterServer = NULL;
    DLLINSTALL_PARAMS           pfDllInstall        = NULL;

    TCHAR           szRegKeyPath[MAX_REG_PATH]      = TEXT("");
    HKEY            hCurrentSectionKey              = NULL;

    BOOL            fWx86DLL                        = FALSE;

    // Delete Registry Entry
    if ((NULL != szSectionName) && (RRA_DELETE & dwFlags))
    {
        wsprintf(szRegKeyPath, TEXT("%s\\%s"), szSubkey, szSectionName);
        LocalSHDeleteValue(hkeyParent, szRegKeyPath, m_szRunOnceExEntryName);
    }

    WriteToLog(TEXT("File:%1; Function:%2; Args:%3; Action:"), m_szFileName, m_szFunctionName, m_szCmdLineArgs);

    switch(m_ROAction)
    {
        case eRO_Register:
        case eRO_Unregister:
            WriteToLog(m_ROAction == eRO_Register ? TEXT("DllRegisterServer()\r\n") : TEXT("DllUnRegisterServer()\r\n"));
            hInstance = RunOnceLoadLibrary( m_szFileName, &fWx86DLL );
            if (NULL != hInstance)
            {
                HRESULT hResult = S_OK;
                char    pcstrDLLToLoad[MAX_PATH];

#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, m_szFunctionName, -1,
                                    pcstrDLLToLoad, ARRAYSIZE(pcstrDLLToLoad), NULL, NULL);
#else // UNICODE
                lstrcpy(pcstrDLLToLoad, m_szFunctionName);
#endif // UNICODE

                if (NULL != (pfDllRegisterServer = (DLLREGISTERSERVER_PARAMS) GetProcAddress(hInstance, pcstrDLLToLoad)))
                {
                    if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)      // Don't trap exceptions if that's what the user wants.
                    {
                        // This flag is off be default because you better have a debugger installed if you don't catch
                        // these exceptions
#ifdef WX86
                        if ( fWx86DLL )
                        {
                            hResult = Wx86EmulateX86(pfDllRegisterServer, 0, NULL );
                        }
                        else
#endif
                            hResult = (*pfDllRegisterServer)();
                    }
                    else
                    {
                        _try
                        {
#ifdef WX86
                            if ( fWx86DLL )
                            {
                                hResult = Wx86EmulateX86(pfDllRegisterServer, 0, NULL );
                            }
                            else
#endif
                                hResult = (*pfDllRegisterServer)();
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                        {
                            ReportError(dwFlags, IDS_RUNONCEEX_EXCEPTION, m_szFunctionName, m_szFileName);
                        }
                    }
                    if (FAILED(hResult))
                    {
                        WriteToLog(TEXT("An error occurred calling ""%1"" in ""%2"".  (HRESULT = %3!lx!)\r\n"), m_szFunctionName, m_szFileName, hResult);
                        ReportError(dwFlags, IDS_RUNONCEEX_REGISTER_ERROR, m_szFileName);
                    }
                }
                else
                {
                    ReportError(dwFlags, IDS_RUNONCEEX_FIND_FUNC_FAILED, m_szFunctionName, m_szFileName);
                }
                FreeLibrary(hInstance);
            }
            else
            {
                ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_LOAD_DLL, m_szFileName);
            }

            break;

        case eRO_Install:
            WriteToLog(TEXT("DllInstall()\r\n"));
            hInstance = RunOnceLoadLibrary( m_szFileName, &fWx86DLL );
            if (NULL != hInstance)
            {
                char    pcstrDLLToLoad[MAX_PATH];
                WCHAR   pwstrDLLCmdLineArgs[MAX_PATH];
                HRESULT hResult = S_OK;

#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, m_szFunctionName, -1,
                                    pcstrDLLToLoad, ARRAYSIZE(pcstrDLLToLoad), NULL, NULL);
                lstrcpy(pwstrDLLCmdLineArgs, m_szCmdLineArgs);
#else // UNICODE
                lstrcpy(pcstrDLLToLoad, m_szFunctionName);
                MultiByteToWideChar(CP_ACP, 0, m_szCmdLineArgs, -1, pwstrDLLCmdLineArgs, ARRAYSIZE(pwstrDLLCmdLineArgs));
#endif // UNICODE

                if (NULL != (pfDllInstall = (DLLINSTALL_PARAMS) GetProcAddress(hInstance, pcstrDLLToLoad)))
                {
                    BOOL    bInstall;
                    WCHAR   *pwszArgs;

                    // parse the command line
                    for (pwszArgs = pwstrDLLCmdLineArgs;  *pwszArgs != L',' && *pwszArgs != L'\0';  pwszArgs++)
                        ;
                    if (*pwszArgs == L',')
                        *pwszArgs++ = L'\0';

                    // args to DllInstall is (BOOL, LPWSTR)
                    bInstall = (*pwstrDLLCmdLineArgs != L'u')  &&  (*pwstrDLLCmdLineArgs != L'U');

                    if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)  // Don't trap exceptions if that's what the caller wants.
                    {
                        // This flag is off by default because you better have a debugger installed if you don't catch
                        // these exceptions

#ifdef WX86
                        if ( fWx86DLL )
                        {
                            DWORD dwArgs[ 2 ];
                            dwArgs[ 0 ] = (DWORD) bInstall;
                            dwArgs[ 1 ] = (DWORD) pwszArgs;
                            hResult = Wx86EmulateX86(pfDllInstall, ARRAYSIZE(dwArgs), dwArgs);
                        }
                        else
#endif
                            hResult = (*pfDllInstall)(bInstall, pwszArgs);
                    }
                    else
                    {
                        _try
                        {
#ifdef WX86
                            if ( fWx86DLL )
                            {
                                DWORD dwArgs[ 2 ];
                                dwArgs[ 0 ] = (DWORD) bInstall;
                                dwArgs[ 1 ] = (DWORD) pwszArgs;
                                hResult = Wx86EmulateX86(pfDllInstall, ARRAYSIZE(dwArgs), dwArgs);
                            }
                            else
#endif
                                hResult = (*pfDllInstall)(bInstall, pwszArgs);
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                        {
                            ReportError(dwFlags, IDS_RUNONCEEX_EXCEPTION, m_szFunctionName, m_szFileName);
                        }
                    }
                    if (FAILED(hResult))
                    {
                        WriteToLog(TEXT("An error occurred calling ""%1"" in ""%2"".  (HRESULT = %3!lx!)\r\n"), m_szFunctionName, m_szFileName, hResult);
                        ReportError(dwFlags, IDS_RUNONCEEX_REGISTER_ERROR, m_szFileName);
                    }
                }
                else
                {
                    ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_FIND_FUNCTION, m_szFunctionName, m_szFileName);
                }
                FreeLibrary(hInstance);
            }
            else
            {
                ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_LOAD_DLL, m_szFileName);
            }
            break;

        case eRO_WinMainFunction:
            WriteToLog(TEXT("WinMain type function\r\n"));
            hInstance = RunOnceLoadLibrary( m_szFileName, &fWx86DLL );
            if (NULL != hInstance)
            {
                char    pcstrDLLToLoad[MAX_PATH];
                char    pcstrDLLCmdLineArgs[MAX_PATH];

#ifdef UNICODE
                WideCharToMultiByte(CP_ACP, 0, m_szFunctionName, -1,
                                    pcstrDLLToLoad, ARRAYSIZE(pcstrDLLToLoad), NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, m_szCmdLineArgs, -1,
                                    pcstrDLLCmdLineArgs, ARRAYSIZE(pcstrDLLCmdLineArgs), NULL, NULL);
#else // UNICODE
                lstrcpy(pcstrDLLToLoad, m_szFunctionName);
                lstrcpy(pcstrDLLCmdLineArgs, m_szCmdLineArgs);
#endif // UNICODE

                if (NULL != (pfWinMainFunction = (WINMAIN_PARAMS) GetProcAddress(hInstance, pcstrDLLToLoad)))
                {
                    if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)  // Don't trap exceptions if that's what the caller wants.
                    {
                        // This flag is off be default because you better have a debugger installed if you don't catch
                        // these exceptions

#ifdef WX86
                        if ( fWx86DLL )
                        {
                            DWORD dwArgs[ 4 ];
                            dwArgs[ 0 ] = (DWORD) NULL;
                            dwArgs[ 1 ] = (DWORD) NULL;
                            dwArgs[ 2 ] = (DWORD) pcstrDLLCmdLineArgs;
                            dwArgs[ 3 ] = (DWORD) 0;
                            Wx86EmulateX86(pfWinMainFunction, ARRAYSIZE(dwArgs), dwArgs);
                        }
                        else
#endif
                            (*pfWinMainFunction)(NULL, NULL, pcstrDLLCmdLineArgs, 0);
                    }
                    else
                    {
                        _try
                        {
#ifdef WX86
                            if ( fWx86DLL )
                            {
                                DWORD dwArgs[ 4 ];
                                dwArgs[ 0 ] = (DWORD) NULL;
                                dwArgs[ 1 ] = (DWORD) NULL;
                                dwArgs[ 2 ] = (DWORD) pcstrDLLCmdLineArgs;
                                dwArgs[ 3 ] = (DWORD) 0;
                                Wx86EmulateX86(pfWinMainFunction, ARRAYSIZE(dwArgs), dwArgs);
                            }
                            else
#endif
                                (*pfWinMainFunction)(NULL, NULL, pcstrDLLCmdLineArgs, 0);
                        }
                        _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                        {
                            ReportError(dwFlags, IDS_RUNONCEEX_EXCEPTION, m_szFunctionName, m_szFileName);
                        }
                    }
                }
                else
                {
                    ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_FIND_FUNCTION, m_szFunctionName, m_szFileName);
                }
                FreeLibrary(hInstance);
            }
            else
            {
                ReportError(dwFlags, IDS_RUNONCEEX_CANNOT_LOAD_DLL, m_szFileName);
            }
            break;

        case eRO_Exe:
            WriteToLog(TEXT("ShellExec Command\r\n"));
            {
                if (RRAEX_NO_EXCEPTION_TRAPPING & dwFlags)      // Don't trap exceptions if that's what the caller wants.
                {
                    // This flag is off be default because you better have a debugger installed if you don't catch
                    // these exceptions
                    ShellExecuteRegApp(m_szCmdLineArgs, dwFlags);
                }
                else
                {
                    _try
                    {
                        ShellExecuteRegApp(m_szCmdLineArgs, dwFlags);
                    }
                    _except(EXCEPTION_EXECUTE_HANDLER)      // Catch all exceptions.
                    {
                        ReportError(dwFlags, IDS_RUNONCEEX_EXE_EXCEPTION, m_szCmdLineArgs);
                    }
                }
            }
            break;

        case eRO_Unknown:
        default:
            WriteToLog(TEXT("Unknown\r\n"));
            break;
    }
}


/////////////////////////////////////////////////////////////////////
//  CLASS: RunOnceExSection
/////////////////////////////////////////////////////////////////////

/****************************************************\
    FUNCTION: RunOnceExSection

    PARAMETERS:
        LPTSTR lpszNewSectionName - The name of the new section
        LPTSTR lpszNewDisplayName - The display name of the new section

    DESCRIPTION:
        This constructor will set the name of the newly
    created section.
\***************************************************/
RunOnceExSection::RunOnceExSection(LPTSTR lpszNewSectionName, LPTSTR lpszNewDisplayName)
{
    lstrcpy(m_szRunOnceExSectionName, lpszNewSectionName);

    if ((NULL != lpszNewDisplayName) && (TEXT('\0') != *lpszNewDisplayName))
    {
        // Set the DisplayName as long as it was valid.
        lstrcpy(m_szDisplayName, lpszNewDisplayName);
    }
    else
    {
        // It was invalid, so we use the SectionName for the DisplayName.
        //lstrcpy(m_szDisplayName, lpszNewSectionName);
        *m_szDisplayName = TEXT('\0');              // just don't display anything
    }
    m_hEntryArray = NULL;
    m_NumberOfEntries = 0;
}


/****************************************************\
    FUNCTION: ~RunOnceExSection

    PARAMETERS:
        none

    DESCRIPTION:
        This destructor will free memory that it used.
\***************************************************/
RunOnceExSection::~RunOnceExSection()
{
    if (NULL != m_hEntryArray)
    {
        RunOnceExEntry * pFirstSection;

        for (int iIndex = 0; iIndex < m_NumberOfEntries; iIndex++)
        {
            pFirstSection = (RunOnceExEntry *) DPA_GetPtr(m_hEntryArray, iIndex);
            delete pFirstSection;
        }

        DPA_Destroy(m_hEntryArray);
    }
}


/****************************************************\
    FUNCTION: RunOnceExSection::Process

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        DWORD dwFlags - Flags to determine if we delete command after executing it.

    DESCRIPTION:
        This function will process each entry in it,
    delete the registry key it used, and then
    repeat the process with the next section.
\***************************************************/
void RunOnceExSection::Process(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags)
{
    RunOnceExEntry      * pCurrentEntry     = NULL;
    HKEY                hSectionKey         = NULL;
    int                 iEntryIndex;

    WriteToLog(TEXT("\r\n"));
    LogDateAndTime();
    WriteToLog(TEXT("Section:%1\r\n"), m_szRunOnceExSectionName);

    // Load the dependency DLLs for this sections
    HandleDependencyDLLs(hkeyParent, szSubkey, m_szRunOnceExSectionName, dwFlags, eHDL_Load);

    if (NULL != m_hEntryArray)
    {
        for (iEntryIndex = 0; iEntryIndex < m_NumberOfEntries; iEntryIndex++)
        {
            pCurrentEntry = (RunOnceExEntry *) DPA_GetPtr(m_hEntryArray, iEntryIndex);
            if (pCurrentEntry)
                pCurrentEntry->Process(hkeyParent, szSubkey, m_szRunOnceExSectionName, dwFlags);

            // If there is a call back, send back information
            if (g_pCallbackProc)
            {
                g_nCurrent++;
                g_pCallbackProc(g_nCurrent, g_nTotal, NULL);
            }
        }
    }

    // Unload the dependency DLLs for this sections
    HandleDependencyDLLs(hkeyParent, szSubkey, m_szRunOnceExSectionName, dwFlags, eHDL_Unload);

    LogDateAndTime();

    if (RRA_DELETE & dwFlags)
    {
        TCHAR   szKeyToDelete[MAX_REG_PATH];
        wsprintf(szKeyToDelete, TEXT("%s\\%s"), szSubkey, m_szRunOnceExSectionName);
        LocalSHDeleteKey(hkeyParent, szKeyToDelete);
    }

}


/****************************************************\
    FUNCTION: CompareSection

    PARAMETERS:
        RunOnceExSection * pSection1    - The first Section to be compared
        RunOnceExSection * pSection2    - The second Section to be compared
        LPARAM lpNotUsed                - Not used.
        int return                      - (-1) if the first is smaller.

    DESCRIPTION:
        The following function will determine which
    comes first when sorted.
\***************************************************/
INT CALLBACK CompareSection(RunOnceExSection * pSection1, RunOnceExSection * pSection2, LPARAM lpNotUsed)
{
    if (1 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, pSection1->m_szRunOnceExSectionName, -1, pSection2->m_szRunOnceExSectionName, -1))
        return(-1);

    return(1);
}


/****************************************************\
    FUNCTION: CompareEntries

    PARAMETERS:
        RunOnceExEntry * pEntry1    - The first Entry to be compared
        RunOnceExEntry * pEntry2    - The second Entry to be compared
        LPARAM lpNotUsed            - Not used.
        int return                  - (-1) if the first is smaller.

    DESCRIPTION:
        The following function will determine which
    comes first when sorted.
\***************************************************/
INT CALLBACK CompareEntries(RunOnceExEntry * pEntry1, RunOnceExEntry * pEntry2, LPARAM lpNotUsed)
{
    if (1 == CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, pEntry1->m_szRunOnceExEntryName, -1, pEntry2->m_szRunOnceExEntryName, -1))
        return(-1);

    return(1);
}


/****************************************************\
    FUNCTION: GetSections

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        DWORD dwFlags - Flags.

    DESCRIPTION:
        This function will open the RunOnceEx registry
    key and read all the sections and entries.  It will
    read these into memory and set *ppFirstSection to
    the first (root) section.
\***************************************************/
HDPA GetSections(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags, int * pNumberOfSections)
{
    TCHAR           szCurrentSectionName[MAX_ENTRYNAME] = TEXT("");
    TCHAR           szCurrSectionDisplayName[MAX_ENTRYNAME] = TEXT("");
    HKEY            hRootKey                            = NULL;
    DWORD           dwCurrentSection                    = 0;

    DWORD           dwRegType                           = 0;
    long            lDisplayNameSize                    = ARRAYSIZE(szCurrSectionDisplayName);
    long            lEnumError;
    HDPA            hDPA_Sections                       = DPA_Create(ARRAY_GROW_RATE);
    RunOnceExSection    * pNewSection                   = NULL;

    *pNumberOfSections = 0;

    if (NULL != hDPA_Sections)
    {
        // Do we have any RegOpenKeyEx sections to process/read?
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent, szSubkey, NULL, KEY_READ, &hRootKey))
        {
            // IthkeyParenterate through each section
            for (dwCurrentSection = 0;
                 ERROR_NO_MORE_ITEMS != (lEnumError = RegEnumKey(hRootKey, dwCurrentSection, szCurrentSectionName, ARRAYSIZE(szCurrentSectionName)));
                 dwCurrentSection++)
            {
                if (ERROR_SUCCESS == lEnumError)
                {
                    lDisplayNameSize = sizeof(szCurrSectionDisplayName);
                    if (RegQueryValue(hRootKey, szCurrentSectionName, szCurrSectionDisplayName, &lDisplayNameSize) != ERROR_SUCCESS)
                        *szCurrSectionDisplayName = TEXT('\0');

                    //  Only Process non-"Depend" entries.
                    if (2 != CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szCurrentSectionName, -1, c_szDependencyName, -1))
                    {
                        pNewSection = new RunOnceExSection(szCurrentSectionName, szCurrSectionDisplayName);
                        if (NULL != pNewSection)
                        {
                            if (*szCurrSectionDisplayName)
                                g_iNDisplaySections++;
                            DPA_SetPtr(hDPA_Sections, *pNumberOfSections, (void *) pNewSection);
                            pNewSection->m_hEntryArray = GetEntries(hRootKey, szCurrentSectionName, dwFlags, &(pNewSection->m_NumberOfEntries));
                            (*pNumberOfSections)++;
                        }
                    }
                }
            }

            RegCloseKey(hRootKey);
        }

        DPA_Sort(hDPA_Sections, (PFNDPACOMPARE) CompareSection, 0);
    }

    return(hDPA_Sections);
}


/****************************************************\
    FUNCTION: GetEntries

    PARAMETERS:
        HKEY hkeyParent - Section of the registry being processed.
        LPCTSTR szSubkey - Path to the registry entries being processed.
        DWORD dwFlags - Flags.
        int * pNumberOfEntries - OUT: Number of sections read.

    DESCRIPTION:
        This function will open the RunOnceEx registry
    section key and read all the entries.
\***************************************************/
HDPA GetEntries(HKEY hRootKey, LPCTSTR szSectionName, DWORD dwFlags, int * pNumberOfEntries)
{
    HKEY            hCurrentSectionKey                  = NULL;

    TCHAR           szCurrentEntryName[MAX_ENTRYNAME]   = TEXT("");
    TCHAR           szCurrentEntryCmd[MAX_PATH]         = TEXT("");
    DWORD           dwEntrySize                         = 0;
    DWORD           dwEntryCmdSize                      = 0;

    DWORD           dwCurrentEntry                      = 0;
    DWORD           dwRegType                           = 0;
    long            lEnumError;
    HDPA            hDPA_Entries                        = DPA_Create(ARRAY_GROW_RATE);
    RunOnceExEntry  * pNewEntry                         = NULL;

    *pNumberOfEntries = 0;

    if (NULL != hDPA_Entries)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hRootKey, szSectionName, NULL, KEY_READ, &hCurrentSectionKey))
        {
            DWORD   dwKeyType;

            // Iterate through each value
            dwEntrySize = ARRAYSIZE(szCurrentEntryName);
            dwEntryCmdSize = sizeof(szCurrentEntryCmd);

            for (dwCurrentEntry = 0;
                ERROR_NO_MORE_ITEMS != (lEnumError = RegEnumValue(hCurrentSectionKey, dwCurrentEntry, szCurrentEntryName, &dwEntrySize, NULL, &dwKeyType, (LPBYTE) szCurrentEntryCmd, &dwEntryCmdSize));
                dwCurrentEntry++)
            {
                if (ERROR_SUCCESS == lEnumError)
                {
                    // An empty Entry Name is not acceptable because that is the Display Name for the section.
                    if ((REG_SZ == dwKeyType) && (TEXT('\0') != *szCurrentEntryName))
                    {
                        pNewEntry = new RunOnceExEntry(szCurrentEntryName, szCurrentEntryCmd, dwFlags);
                        if (NULL != pNewEntry)
                        {
                            if (eRO_Unknown != pNewEntry->m_ROAction)
                            {
                                DPA_SetPtr(hDPA_Entries, *pNumberOfEntries, (void *) pNewEntry);
                                (*pNumberOfEntries)++;
                            }
                            else
                                delete pNewEntry;
                        }
                    }
                }

                dwEntrySize = ARRAYSIZE(szCurrentEntryName);
                dwEntryCmdSize = sizeof(szCurrentEntryCmd);
            }

            RegCloseKey(hCurrentSectionKey);
        }

        DPA_Sort(hDPA_Entries, (PFNDPACOMPARE) CompareEntries, 0);
    }

    return(hDPA_Entries);
}


// taken from \\trango\slmadd\src\shell\shell32\shellprv.h
#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFO);

//
// Path processing function
//
#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_NORELATIVEOBJECTQUALIFY 0x00000020        // don't return fully qualified relative objects
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names

typedef LONG WINSHELLAPI (WINAPI * LPPATHPROCESSCOMMAND)(LPCTSTR, LPTSTR, int, DWORD);

/****************************************************\
    FUNCTION: ShellExecuteRegApp

    PARAMETERS:
        LPCTSTR pszCmdLine      - Cmd line to execute
        DWORD dwFlags            - Flags to specify if we need to wait for command to finish.

    DESCRIPTION:
        The following handles running an application
    and optionally waiting for it to terminate.
\***************************************************/
void ShellExecuteRegApp(LPTSTR pszCmdLine, DWORD dwFlags)
{
    TCHAR szBuf[MAX_PATH];

    GetSystemDirectory(szBuf, ARRAYSIZE(szBuf));

    if (RunningOnIE4())
    {
        HINSTANCE               hShell32DLL = NULL;
        LPPATHPROCESSCOMMAND    pfnPathProcessCommand;
        TCHAR                   szQuotedCmdLine[MAX_PATH+2];
        SHELLEXECUTEINFO        ExecInfo;
        LPTSTR                  lpszArgs;
        BOOL                    fPPCSuccess = FALSE;                    // PathProcessCommand succeeded

        AddPath(szBuf, TEXT("shell32.dll"));

        if ((hShell32DLL = LoadLibraryEx(szBuf, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)) != NULL)
        {
            if ((pfnPathProcessCommand = (LPPATHPROCESSCOMMAND) GetProcAddress(hShell32DLL, (LPCSTR) 653)) != NULL)
            {
                //
                // We used to call CreateProcess( NULL, szCmdLine, ...) here,
                // but thats not useful for people with apppaths stuff.
                //

                // Gross, but if the process command fails, copy the command line to let
                // shell execute report the errors

                if ((pfnPathProcessCommand)(pszCmdLine, szQuotedCmdLine, ARRAYSIZE(szQuotedCmdLine), PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) != -1)
                    fPPCSuccess = TRUE;
            }

            FreeLibrary(hShell32DLL);
        }

        if (!fPPCSuccess)
            lstrcpy(szQuotedCmdLine, pszCmdLine);

        lpszArgs = LocalPathGetArgs(szQuotedCmdLine);
        if (*lpszArgs)
            *(lpszArgs-1) = TEXT('\0');                                 // Strip args

        LocalPathUnquoteSpaces(szQuotedCmdLine);

        FillExecInfo(ExecInfo, NULL, NULL, szQuotedCmdLine, lpszArgs, szBuf, SW_SHOWNORMAL);
        ExecInfo.fMask |= SEE_MASK_NOCLOSEPROCESS;
        if (dwFlags & RRAEX_NO_ERROR_DIALOGS)                           // Don't display Error dialog
            ExecInfo.fMask |= SEE_MASK_FLAG_NO_UI;

        if (ShellExecuteEx(&ExecInfo))
        {
            if ((dwFlags & RRA_WAIT) && (ExecInfo.hProcess != NULL))
            {
                MsgWaitForMultipleObjectsLoop(ExecInfo.hProcess, INFINITE);
            }

            CloseHandle(ExecInfo.hProcess);
        }
    }
    else                                                                // old Win95 logic -- just call CreateProcess
    {
        STARTUPINFO startup;
        PROCESS_INFORMATION pi;

        ZeroMemory(&startup, sizeof(startup));
        startup.cb = sizeof(startup);

        if (CreateProcess(NULL, pszCmdLine, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, szBuf, &startup, &pi))
        {
            if (dwFlags & RRA_WAIT)
            {
                MsgWaitForMultipleObjectsLoop(pi.hProcess, INFINITE);
            }

            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
}

#define BUFFER_SIZE 1024
BOOL HaveDependServices(SC_HANDLE hService)
{
    HRESULT hr = S_OK;
    LPBYTE  lpBuffer = NULL;
    DWORD   dwSize   = BUFFER_SIZE;    // Start with 1k
    DWORD   dwBytesNeeded;
    DWORD   dwNumServices;
    BOOL    bDependServices = FALSE;

    lpBuffer = (LPBYTE) LocalAlloc(LPTR, dwSize);
    if (lpBuffer)
    {
        if (!EnumDependentServices(hService, SERVICE_STATE_ALL,
                                   (LPENUM_SERVICE_STATUS)lpBuffer, dwSize,
                                   &dwBytesNeeded, &dwNumServices))
        {
            if (GetLastError() == ERROR_MORE_DATA)
            {
                dwSize = dwBytesNeeded + 32;
                LocalFree(lpBuffer);
                lpBuffer = (LPBYTE) LocalAlloc(LPTR, dwSize);
                if (lpBuffer)
                {
                    if (!EnumDependentServices(hService, SERVICE_STATE_ALL,
                                               (LPENUM_SERVICE_STATUS)lpBuffer, dwSize,
                                               &dwBytesNeeded, &dwNumServices))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());

        }
        if (SUCCEEDED(hr))
        {
            // If at least one service depends on this one?
            bDependServices = (dwNumServices != 0);
        }
        if (lpBuffer)
            LocalFree(lpBuffer);
    }
    return bDependServices;
}

void CheckServices(DWORD dwFlags)
{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL    bRebootNeeded = FALSE;
    HKEY    hKey = NULL;
    LPSTR   pServices = NULL;
    LPSTR   pCheckService = NULL;
    LONG    lRet = 0;
    DWORD   dwSize;

    pServices = (LPSTR)LocalAlloc(LPTR, BUFFER_SIZE);
    if (pServices)
    {
        // Get the services to check for from the registry.
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCEEX, NULL, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = BUFFER_SIZE - 1;
            lRet = RegQueryValueEx(hKey, g_c_szServicesRegValue, NULL, NULL, (LPBYTE)pServices, &dwSize);
            if (lRet == ERROR_MORE_DATA)
            {
                dwSize += 32;
                LocalFree(pServices);
                pServices = (LPSTR)LocalAlloc(LPTR, dwSize);

                if (pServices)
                {
                    lRet = RegQueryValueEx(hKey, g_c_szServicesRegValue, NULL, NULL, (LPBYTE)pServices, &dwSize);
                }
            }
            if (lRet != ERROR_SUCCESS)
            {
                if (pServices)
                {
                    LocalFree(pServices);
                    pServices = NULL;
                }
            }
            RegDeleteValue(hKey, g_c_szServicesRegValue);
            RegCloseKey(hKey);
        }

        if ((pServices) && (*pServices))
        {
            hSCM = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
            if (hSCM)
            {
                pCheckService = pServices;
                // zero out all forward slashes to get the services terminated
                while (*pCheckService)
                {
                    if (*pCheckService == '/')
                    {
                        *pCheckService = '\0';
                        pCheckService++;
                    }
                    else
                        pCheckService = CharNext(pCheckService);
                }
                // RegQueryValueExA is using the same buffer to convert the UNICODE
                // string to a ANSI string. This will leave some UNICODE characters
                // after the ANSI strings and the services are not realy double 0
                // terminated anymore. This will ensure that the list is still
                // double 0 terminated
                pCheckService++;
                *pCheckService = '\0';

                pCheckService = pServices;
                while (!bRebootNeeded && (*pCheckService))
                {
                    hService = OpenService(hSCM,
                                           (LPCSTR)pCheckService,
                                           STANDARD_RIGHTS_REQUIRED | SERVICE_ENUMERATE_DEPENDENTS);
                    if (hService)
                    {
                        bRebootNeeded = HaveDependServices(hService);
                        CloseServiceHandle(hService);
                    }

                    pCheckService += lstrlen(pCheckService) + 1;
                }
                CloseServiceHandle(hSCM);
            }
        }
        if (pServices)
            LocalFree(pServices);
    }
    if (bRebootNeeded)
    {
        ReportError((dwFlags & ~RRAEX_NO_ERROR_DIALOGS), IDS_RUNONCEEX_SERVICE_REQUIRES_REBOOT);
        LogOff(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iernonce\utils.cpp ===
#include "iernonce.h"
#include "resource.h"


//==================================================================
// AddPath()
//
void AddPath(LPTSTR szPath, LPCTSTR szName)
{
    LPTSTR szTmp;

    // Find end of the string
    szTmp = szPath + lstrlen(szPath);

    // If no trailing backslash then add one
    if (szTmp > szPath  &&  *(CharPrev(szPath, szTmp)) != TEXT('\\'))
        *szTmp++ = TEXT('\\');

    // Add new name to existing path string
    while (*szName == TEXT(' '))
        szName = CharNext(szName);

    lstrcpy(szTmp, szName);
}

// function will upated the given buffer to parent dir
//
BOOL GetParentDir( LPTSTR szFolder )
{
    LPTSTR lpTmp;
    BOOL  bRet = FALSE;

    // remove the trailing '\\'
    lpTmp = CharPrev( szFolder, (szFolder + lstrlen(szFolder)) );
    lpTmp = CharPrev( szFolder, lpTmp );

    while ( (lpTmp > szFolder) && (*lpTmp != TEXT('\\') ) )
    {
       lpTmp = CharPrev( szFolder, lpTmp );
    }

    if ( *lpTmp == TEXT('\\') )
    {
        if ( (lpTmp == szFolder) || (*CharPrev(szFolder, lpTmp)==TEXT(':') ) )
            lpTmp = CharNext( lpTmp );
        *lpTmp = TEXT('\0');
        bRet = TRUE;
    }

    return bRet;
}

// This is the value for the major version 4.71
#define IE4_MS_VER   0x00040047

BOOL RunningOnIE4()
{
    static BOOL fIsIE4 = 2;
    TCHAR   szFile[MAX_PATH];
#ifdef UNICODE
    char    szANSIFile[MAX_PATH];
#endif
    DWORD   dwMSVer;
    DWORD   dwLSVer;

    if (fIsIE4 != 2)
        return fIsIE4;

    GetSystemDirectory(szFile, ARRAYSIZE(szFile));
    AddPath(szFile, TEXT("shell32.dll"));

#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szFile, -1, szANSIFile, sizeof(szANSIFile), NULL, NULL);
#endif

    GetVersionFromFile(
#ifdef UNICODE
                        szANSIFile,
#else
                        szFile,
#endif
                        &dwMSVer, &dwLSVer, TRUE);

    fIsIE4 = dwMSVer >= IE4_MS_VER;

    return fIsIE4;
}


/****************************************************\
    FUNCTION: MsgWaitForMultipleObjectsLoop

    PARAMETERS:
        HANDLE hEvent       - Pointer to the object-handle array of Objects
        DWORD dwTimeout     - Time out duration
        DWORD return        - Return is WAIT_FAILED or WAIT_OBJECT_0

    DESCRIPTION:
        Waits for the object (Process) to complete.
\***************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE, dwTimeout, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                DispatchMessage(&msg);
            break;
        }
    }
    // never gets here
    // return dwObject;
}


void LogOff(BOOL bRestart)
{
    if (g_bRunningOnNT)
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;

        // get a token from this process
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            // get the LUID for the shutdown privilege
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            //get the shutdown privilege for this proces
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);
        }
    }

    ExitWindowsEx(bRestart?EWX_REBOOT|EWX_FORCE:EWX_LOGOFF, 0);
    // this is a hack to prevent explorer from continue starting (In Integrated Shell)
    // and runonce from continue processing other items.
    // If we use a timer wait (which contains a messageloop), in browser only mode our 
    // process gets terminated before explorer and explorer would try and continue 
    // processing runonce items. With the while loop below this seem to not happen.
    if (bRestart)
        while (true) ;
}


//
//  Performs a message box with the text and title string loaded from the string table.
void ReportError(DWORD dwFlags, UINT uiResourceNum, ...)
{
    TCHAR           szResourceStr[1024]     = TEXT("");
    va_list         vaListOfMessages;
    LPTSTR          pszErrorString = NULL;

    LoadString(g_hinst, uiResourceNum, szResourceStr, ARRAYSIZE(szResourceStr));

    va_start(vaListOfMessages, uiResourceNum);          // Initialize variable arguments.
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) szResourceStr, 0, 0, (LPTSTR) &pszErrorString, 0, &vaListOfMessages);
    va_end(vaListOfMessages);

    if (pszErrorString != NULL)
    {
        if (!(RRAEX_NO_ERROR_DIALOGS & dwFlags))        // Display Error dialog
        {
            if (*g_szTitleString == TEXT('\0'))         // Initialize this only once
                LoadString(g_hinst, IDS_RUNONCEEX_TITLE, g_szTitleString, ARRAYSIZE(g_szTitleString));
            MessageBox(NULL, pszErrorString, g_szTitleString, MB_OK | MB_ICONERROR | MB_SETFOREGROUND);
        }

        // If there is a cllback then callback with error string
        if (g_pCallbackProc)
            g_pCallbackProc(0, 0, pszErrorString);

        WriteToLog(pszErrorString);
        WriteToLog(TEXT("\r\n"));

        LocalFree(pszErrorString);
    }
}


// copied from msdev\crt\src\atox.c
/***
*long AtoL(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long AtoL(const char *nptr)
{
        int c;                  /* current char */
        long total;             /* current total */
        int sign;               /* if '-', then negative, otherwise positive */

        // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
        // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
        // DBCS Trailing bytes -- pritvi

        /* skip whitespace */
        while ( IsSpace((int)(unsigned char)*nptr) )
                ++nptr;

        c = (int)(unsigned char)*nptr++;
        sign = c;               /* save sign indication */
        if (c == '-' || c == '+')
                c = (int)(unsigned char)*nptr++;        /* skip sign */

        total = 0;

        while (IsDigit(c)) {
                total = 10 * total + (c - '0');         /* accumulate digit */
                c = (int)(unsigned char)*nptr++;        /* get next char */
        }

        if (sign == '-')
                return -total;
        else
                return total;   /* return result, negated if necessary */
}


// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// "foo.exe bar.txt"    -> "bar.txt"
// "foo.exe"            -> ""
//
// Spaces in filenames must be quoted.
// " "A long name.txt" bar.txt " -> "bar.txt"
STDAPI_(LPTSTR)
LocalPathGetArgs(
    LPCTSTR pszPath)                        // copied from \\trango\slmadd\src\shell\shlwapi\path.c
{
    BOOL fInQuotes = FALSE;

    if (!pszPath)
            return NULL;

    while (*pszPath)
    {
        if (*pszPath == TEXT('"'))
            fInQuotes = !fInQuotes;
        else if (!fInQuotes && *pszPath == TEXT(' '))
            return (LPTSTR)pszPath+1;
        pszPath = CharNext(pszPath);
    }

    return (LPTSTR)pszPath;
}


/*----------------------------------------------------------
Purpose: If a path is contained in quotes then remove them.

Returns: --
Cond:    --
*/
STDAPI_(void)
LocalPathUnquoteSpaces(
    LPTSTR lpsz)                            // copied from \\trango\slmadd\src\shell\shlwapi\path.c
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = TEXT('\0');
        hmemcpy(lpsz, lpsz+1, (cch-1) * sizeof(TCHAR));
    }
}


#ifdef UNICODE
LPWSTR FAR PASCAL LocalStrChrW(LPCWSTR lpStart, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    for ( ; *lpStart; lpStart++)
    {
        // Need a tmp word since casting ptr to WORD * will
        // fault on MIPS, ALPHA

        WORD wTmp;
        memcpy(&wTmp, lpStart, sizeof(WORD));

        if (!ChrCmpW_inline(wTmp, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}


__inline BOOL ChrCmpW_inline(WORD w1, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    return(!(w1 == wMatch));
}
#else
/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL LocalStrChrA(LPCSTR lpStart, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}


/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}
#endif


#ifdef UNICODE
/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
LocalSHDeleteKeyW(
    HKEY    hkey, 
    LPCWSTR pwszSubKey)                     // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    CHAR sz[MAX_PATH];

    WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, sz, ARRAYSIZE(sz), NULL, NULL);

    if (g_bRunningOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, sz);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, sz);
    }

    RegFlushKey(hkey);

    return dwRet;
}
#else
/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
LocalSHDeleteKeyA(
    HKEY   hkey, 
    LPCSTR pszSubKey)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;

    if (g_bRunningOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, pszSubKey);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    RegFlushKey(hkey);

    return dwRet;
}
#endif


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    HKEY   hkey, 
    LPCSTR pszSubKey)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_READ | KEY_WRITE, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}


#ifdef UNICODE
/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         On Win95, this function thunks and calls the ansi
         version.  On NT, this function calls the unicode
         registry APIs directly.

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
LocalSHDeleteValueW(
    HKEY    hkey,
    LPCWSTR pwszSubKey,
    LPCWSTR pwszValue)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    HKEY hkeyNew;

    if (g_bRunningOnNT)
    {
        dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
        if (NO_ERROR == dwRet)
        {
            dwRet = RegDeleteValueW(hkeyNew, pwszValue);
            RegFlushKey(hkeyNew);
            RegCloseKey(hkeyNew);
        }
    }
    else
    {
        CHAR szSubKey[MAX_PATH];
        CHAR szValue[MAX_PATH];
        LPSTR pszSubKey = NULL;
        LPSTR pszValue = NULL;

        if (pwszSubKey)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, szSubKey, ARRAYSIZE(szSubKey), NULL, NULL);
            pszSubKey = szSubKey;    
        }
        
        if (pwszValue)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszValue, -1, szValue, ARRAYSIZE(szValue), NULL, NULL);
            pszValue = szValue;
        }

        dwRet = LocalSHDeleteValueA(hkey, pszSubKey, pszValue);
    }

    return dwRet;
}
#endif


/*----------------------------------------------------------
Purpose: Deletes a registry value.  This opens and closes the
         key in which the value resides.  

         Perf:  if your code involves setting/getting a series
         of values in the same key, it is better to open
         the key once and set/get the values with the regular
         Win32 registry functions, rather than using this 
         function repeatedly.

Returns:
Cond:    --
*/
STDAPI_(DWORD)
LocalSHDeleteValueA(
    HKEY    hkey,
    LPCSTR  pszSubKey,
    LPCSTR  pszValue)                       // copied from \\trango\slmadd\src\shell\shlwapi\reg.c
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_SET_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegDeleteValueA(hkeyNew, pszValue);
        RegFlushKey(hkeyNew);
        RegCloseKey(hkeyNew);
    }
    return dwRet;
}


LPTSTR GetLogFileName(LPCTSTR pcszLogFileKeyName, LPTSTR pszLogFileName, DWORD dwSizeInChars)
{
    TCHAR szBuf[MAX_PATH];

    *pszLogFileName = TEXT('\0');
    szBuf[0] = TEXT('\0');

    // get the name for the log file
    GetProfileString(TEXT("IE4Setup"), pcszLogFileKeyName, TEXT(""), szBuf, ARRAYSIZE(szBuf));
    if (*szBuf == TEXT('\0'))                                       // check in the registry
    {
        HKEY hkSubKey;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\IE Setup\\Setup"), 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
        {
            DWORD dwDataLen = sizeof(szBuf);

            RegQueryValueEx(hkSubKey, pcszLogFileKeyName, NULL, NULL, (LPBYTE) szBuf, &dwDataLen);
            RegCloseKey(hkSubKey);
        }
    }

    if (*szBuf)
    {
        // crude way of determining if fully qualified path is specified or not.
        if (szBuf[1] != TEXT(':'))
        {
            GetWindowsDirectory(pszLogFileName, dwSizeInChars);     // default to windows dir
            AddPath(pszLogFileName, szBuf);
        }
        else
            lstrcpy(pszLogFileName, szBuf);
    }

    return pszLogFileName;
}


VOID StartLogging(LPCTSTR pcszLogFileName, DWORD dwCreationFlags)
{
    if (*pcszLogFileName  &&  (g_hLogFile = CreateFile(pcszLogFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, dwCreationFlags, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(g_hLogFile, 0, NULL, FILE_END);
        WriteToLog(TEXT("\r\n"));
        WriteToLog(TEXT("************************"));
        WriteToLog(TEXT(" Begin logging "));
        WriteToLog(TEXT("************************"));
        WriteToLog(TEXT("\r\n"));
        LogDateAndTime();
        WriteToLog(TEXT("\r\n"));
    }
}


VOID WriteToLog(LPCTSTR pcszFormatString, ...)
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        va_list vaArgs;
        LPTSTR pszFullErrMsg = NULL;
        LPSTR pszANSIFullErrMsg;
        DWORD dwBytesWritten;
#ifdef UNICODE
        DWORD dwANSILen;
#endif

        va_start(vaArgs, pcszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pcszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &vaArgs);
        va_end(vaArgs);

        if (pszFullErrMsg != NULL)
        {
#ifdef UNICODE
            dwANSILen = lstrlen(pszFullErrMsg) + 1;
            if ((pszANSIFullErrMsg = (LPSTR) LocalAlloc(LPTR, dwANSILen)) != NULL)
                WideCharToMultiByte(CP_ACP, 0, pszFullErrMsg, -1, pszANSIFullErrMsg, dwANSILen, NULL, NULL);
#else
            pszANSIFullErrMsg = pszFullErrMsg;
#endif

            if (pszANSIFullErrMsg != NULL)
            {
                WriteFile(g_hLogFile, pszANSIFullErrMsg, lstrlen(pszANSIFullErrMsg), &dwBytesWritten, NULL);
#ifdef UNICODE
                LocalFree(pszANSIFullErrMsg);
#endif
            }

            LocalFree(pszFullErrMsg);
        }
    }
}


VOID StopLogging()
{
    LogDateAndTime();
    WriteToLog(TEXT("************************"));
    WriteToLog(TEXT(" End logging "));
    WriteToLog(TEXT("************************"));
    WriteToLog(TEXT("\r\n"));

    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}


VOID LogDateAndTime()
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME SystemTime;

        GetLocalTime(&SystemTime);

        WriteToLog(TEXT("Date: %1!02d!/%2!02d!/%3!04d! (mm/dd/yyyy)\tTime: %4!02d!:%5!02d!:%6!02d! (hh:mm:ss)\r\n"),
                                        SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                                        SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
    }
}


VOID LogFlags(DWORD dwFlags)
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        WriteToLog(TEXT("RRA_DELETE = %1!lu!\r\n"), (dwFlags & RRA_DELETE) ? 1 : 0);
        WriteToLog(TEXT("RRA_WAIT = %1!lu!\r\n"), (dwFlags & RRA_WAIT) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_NO_ERROR_DIALOGS = %1!lu!\r\n"), (dwFlags & RRAEX_NO_ERROR_DIALOGS) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_ERRORFILE = %1!lu!\r\n"), (dwFlags & RRAEX_ERRORFILE) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_LOG_FILE = %1!lu!\r\n"), (dwFlags & RRAEX_LOG_FILE) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_NO_EXCEPTION_TRAPPING = %1!lu!\r\n"), (dwFlags & RRAEX_NO_EXCEPTION_TRAPPING) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_NO_STATUS_DIALOG = %1!lu!\r\n"), (dwFlags & RRAEX_NO_STATUS_DIALOG) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_IGNORE_REG_FLAGS = %1!lu!\r\n"), (dwFlags & RRAEX_IGNORE_REG_FLAGS) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_CHECK_NT_ADMIN = %1!lu!\r\n"), (dwFlags & RRAEX_CHECK_NT_ADMIN) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_QUIT_IF_REBOOT_NEEDED = %1!lu!\r\n"), (dwFlags & RRAEX_QUIT_IF_REBOOT_NEEDED) ? 1 : 0);
#if 0
        /****
        WriteToLog(TEXT("RRAEX_BACKUP_SYSTEM_DAT = %1!lu!\r\n"), (dwFlags & RRAEX_BACKUP_SYSTEM_DAT) ? 1 : 0);
        WriteToLog(TEXT("RRAEX_DELETE_SYSTEM_IE4 = %1!lu!\r\n"), (dwFlags & RRAEX_DELETE_SYSTEM_IE4) ? 1 : 0);
        ****/
#endif
#if 0
        /**** enable this when explorer.exe is fixed (bug #30866)
        WriteToLog(TEXT("RRAEX_CREATE_REGFILE = %1!lu!\r\n"), (dwFlags & RRAEX_CREATE_REGFILE) ? 1 : 0);
        ****/
#endif
    }
}



// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(g_hHeap, 0, ptr);
}


void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, n);
#else
        return HeapAlloc(g_hHeap, 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
   return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, n * s);
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(g_hHeap, 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(g_hHeap, 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iernonce\iernonce.h ===
#define OEMRESOURCE
#include <windows.h>
#include <windowsx.h>
#include <objidl.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <regstr.h>
#include <shlobj.h>
#include <shellapi.h>
#include <advpub.h>


#define MAX_ENTRYNAME           256
#define WM_FINISHED             (WM_USER + 0x123)

// taken from \\trango\slmadd\src\shell\inc\shellp.h
#define ARRAYSIZE(a)            (sizeof(a)/sizeof(a[0]))

#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)              ((c) >= '0'  &&  (c) <= '9')

// Callback proc stuff for RunOnceExProcess

typedef VOID (*RUNONCEEXPROCESSCALLBACK)
(
 int nCurrent,
 int nMax,
 LPSTR pszError
 );

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

typedef enum {
    RRA_DEFAULT = 0x0000,
    RRA_DELETE  = 0x0001,
    RRA_WAIT    = 0x0002,
} RRA_FLAGS;

typedef enum {
    RRAEX_NO_ERROR_DIALOGS      =   0x0008,
    RRAEX_ERRORFILE             =   0x0010,
    RRAEX_LOG_FILE              =   0x0020,
    RRAEX_NO_EXCEPTION_TRAPPING =   0x0040,
    RRAEX_NO_STATUS_DIALOG      =   0x0080,
    RRAEX_IGNORE_REG_FLAGS      =   0x0100,
    RRAEX_CHECK_NT_ADMIN        =   0x0200,
    RRAEX_SHOW_SOFTBOOT_UI      =   0x0400,
    RRAEX_QUIT_IF_REBOOT_NEEDED =   0x0800,
    RRAEX_BACKUP_SYSTEM_DAT     =   0x1000,
#if 0
    /****
    RRAEX_DELETE_SYSTEM_IE4     =   0x2000,
    ****/
#endif
#if 0
    /**** enable this when explorer.exe is fixed (bug #30866)
    RRAEX_CREATE_REGFILE        =   0x4000,
    ****/
#endif
} RRAEX_FLAGS;

typedef struct tagArgsInfo
{
    HKEY hkeyParent;
    LPCTSTR pszSubkey;
    DWORD dwFlags;
    HDPA hdpaSections;
    int iNumberOfSections;
} ARGSINFO;

enum eRunOnceExAction
{
    eRO_Unknown,                                // This indicates that we don't yet know the action
    eRO_Register,
    eRO_Unregister,
    eRO_Install,
    eRO_WinMainFunction,
    eRO_Exe
};


//////////////////////////////////////////////////////////////////
//  Class Definitions
//////////////////////////////////////////////////////////////////

/****************************************************\
    CLASS: RunOnceExEntry

    DESCRIPTION:
        This class will contain one command that needs
    to be executed.
\***************************************************/
class RunOnceExEntry
{
public:
    // Member Variables
    TCHAR               m_szRunOnceExEntryName[MAX_ENTRYNAME];
    TCHAR               m_szFileName[MAX_PATH];
    TCHAR               m_szFunctionName[MAX_ENTRYNAME];
    TCHAR               m_szCmdLineArgs[MAX_PATH];
    eRunOnceExAction    m_ROAction;

    // Member Functions
    RunOnceExEntry(LPTSTR lpszNewEntryName, LPTSTR lpszNewCmd, DWORD dwFlags);
    ~RunOnceExEntry();
    void                Process(HKEY hkeyParent, LPCTSTR szSubkey, LPCTSTR szSectionName, DWORD dwFlags);
};

/****************************************************\
    CLASS: RunOnceExSection

    DESCRIPTION:
        This class will contain one grouping of 
    commands that will need to be executed.
\***************************************************/
class RunOnceExSection
{
public:
    // Member Variables
    TCHAR               m_szRunOnceExSectionName[MAX_ENTRYNAME];
    TCHAR               m_szDisplayName[MAX_ENTRYNAME];
    HDPA                m_hEntryArray;
    int                 m_NumberOfEntries;

    // Member Functions
    RunOnceExSection(LPTSTR lpszNewSectionName, LPTSTR lpszNewDisplayName);
    ~RunOnceExSection();
    void                Process(HKEY hkeyParent, LPCTSTR szSubkey, DWORD dwFlags);
};


LRESULT CALLBACK DlgProcRunOnceEx(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void ProcessSections(HKEY hkeyParent, LPCTSTR pszSubkey, DWORD dwFlags, HDPA hdpaSections, int iNumberOfSections, HWND hWnd);

extern const TCHAR *g_c_szTitleRegValue;
extern TCHAR g_szTitleString[256];
extern BOOL g_bRunningOnNT;
extern HINSTANCE g_hinst;
extern HANDLE g_hHeap;
extern HANDLE g_hLogFile;

extern RUNONCEEXPROCESSCALLBACK g_pCallbackProc;

// internal functions defined in utils.cpp
void            AddPath(LPTSTR szPath, LPCTSTR szName);
BOOL            GetParentDir(LPTSTR szPath);
BOOL            RunningOnIE4();
DWORD           MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout);
void            LogOff(BOOL bRestart);
void            ReportError(DWORD dwFlags, UINT uiResourceNum, ...);
long            AtoL(const char *nptr);

#ifdef UNICODE
#define     LocalStrChr             LocalStrChrW
#define     LocalSHDeleteKey        LocalSHDeleteKeyW
#define     LocalSHDeleteValue      LocalSHDeleteValueW
#else
#define     LocalStrChr             LocalStrChrA
#define     LocalSHDeleteKey        LocalSHDeleteKeyA
#define     LocalSHDeleteValue      LocalSHDeleteValueA
#endif

// following copied from \\trango\slmadd\src\shell\shlwapi\path.c
STDAPI_(LPTSTR) LocalPathGetArgs(LPCTSTR pszPath);
STDAPI_(void) LocalPathUnquoteSpaces(LPTSTR lpsz);

// following copied from \\trango\slmadd\src\shell\shlwapi\strings.c
#ifdef UNICODE
LPWSTR FAR PASCAL LocalStrChrW(LPCWSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpW_inline(WORD w1, WORD wMatch);
#else
LPSTR FAR PASCAL LocalStrChrA(LPCSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch);
#endif

// following copied from \\trango\slmadd\src\shell\shlwapi\reg.c
#ifdef UNICODE
STDAPI_(DWORD) LocalSHDeleteKeyW(HKEY hkey, LPCWSTR pwszSubKey);
#else
STDAPI_(DWORD) LocalSHDeleteKeyA(HKEY hkey, LPCSTR pszSubKey);
#endif
DWORD DeleteKeyRecursively(HKEY hkey, LPCSTR pszSubKey);

#ifdef UNICODE
STDAPI_(DWORD) LocalSHDeleteValueW(HKEY hkey, LPCWSTR pwszSubKey, LPCWSTR pwszValue);
#endif
STDAPI_(DWORD) LocalSHDeleteValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue);

// related to logging
LPTSTR GetLogFileName(LPCTSTR pcszLogFileKeyName, LPTSTR pszLogFileName, DWORD dwSizeInChars);
VOID StartLogging(LPCTSTR pcszLogFileName, DWORD dwCreationFlags);
VOID WriteToLog(LPCTSTR pcszFormatString, ...);
VOID StopLogging();
VOID LogDateAndTime();
VOID LogFlags(DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\fixie.cpp ===
#include "pch.h"
#include "fixie.h"

HANDLE g_hHeap                  = NULL;
HWND g_hWnd                     = NULL;
HWND g_hProgress                = NULL;
int g_nNumGuids                 = 0;
HRESULT g_hr                    = E_FAIL;
char g_szLogFileName[MAX_PATH];
LPSTORAGE     g_pIStorage       = NULL;
LPSTREAM      g_pIStream        = NULL;
DWORD g_dwPlatform              = NULL;
LCIFCOMPONENT g_pLinkCif        = NULL;

// #40352 - always repair the Icons. g_bRestoreIcons does not get changed anywhere else.
BOOL g_bRestoreIcons            = TRUE;
BOOL g_bQuiet                   = FALSE;
BOOL g_bRunningWin95;
BOOL g_bNeedReboot              = FALSE;

LPSTR g_pszError                = NULL;

// Used for the progress bar
// start and end for each section (out of 100)
int g_nVerifyAllFilesStart             =   0;
int g_nVerifyAllFilesEnd               =  10;
int g_nRunSetupCommandPreROEXStart     =  10;
int g_nRunSetupCommandPreROEXEnd       =  11;
int g_nRunSetupCommandAllROEXStart     =  11;
int g_nRunSetupCommandAllROEXEnd       =  21;
int g_nDoRunOnceExProcessStart         =  21;
int g_nDoRunOnceExProcessEnd           =  80;
int g_nRunSetupCommandAllPostROEXStart =  80;
int g_nRunSetupCommandAllPostROEXEnd   =  90;
int g_nRestoreIconsStart               =  90;
int g_nRestoreIconsEnd                 = 100;

int g_nProgressStart                   =   0;
int g_nProgressEnd                     = 100;

const char c_gszRegstrPathIExplore[]    = REGSTR_PATH_APPPATHS "\\iexplore.exe";
const char c_gszLogFileName[]           = "Fix IE Log.txt";
char g_szFixIEInf[MAX_STRING];
const char c_gszFixIEInfName[]          = "fixie.inf";
const char c_gszIERnOnceDLL[]           = "iernonce.dll";
const char c_gszMainSectionName[]       = "FixIE";
const char c_gszPreSectionName[]        = "PreROEX";

const char c_gszRegRestoreIcons[]     = "Software\\Microsoft\\Active Setup\\Installed Components";

char g_szModifiedMainSectionName[MAX_STRING];
char g_szCryptoSectionName[MAX_STRING];
const char c_gszWin95[]                 = "";
const char c_gszMillen[]                = ".Millen";
const char c_gszNTx86[]                 = ".NT";
const char c_gszW2K[]                   = ".W2K";
const char c_gszNTalpha[]               = ".Alpha";
const char c_gszCrypto[]                = ".Crypto";

LPSTR MakeAnsiStrFromWide(LPWSTR pwsz);
LPWSTR MakeWideStrFromAnsi(LPSTR psz);
void ConvertIStreamToFile(LPSTORAGE *pIStorage, LPSTREAM *pIStream);
void MakePath(LPSTR lpPath);
void LogTimeDate();
HRESULT MyRunSetupCommand(HWND hwnd, LPCSTR lpszInfFile, LPCSTR lpszSection, DWORD dwFlags);
DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize);
LPSTR FindChar(LPSTR pszStr, char ch);

// Reboot stuff
BOOL MyNTReboot();
HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow);
BOOL MyRestartDialog(HWND hParent, BOOL bShowPrompt, UINT nIdMessage);

VOID MyConvertVersionString(LPSTR lpszVersion, LPDWORD pdwMSVer, LPDWORD pdwLSVer);
VOID MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer);
int DisplayMessage(char* pszMessage, UINT uStyle);
int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize);
VOID GetPlatform();
BOOL CheckForNT4_SP4();
VOID GetInfFile();
VOID AddComponent(ICifComponent *pCifComp);
VOID WriteToLog(char *pszFormatString, ...);
HRESULT InitComponentList();
HRESULT VerifyAllFiles();
HRESULT RunSetupCommandPreROEX();
HRESULT RunSetupCommandAllROEX();
HRESULT RunSetupCommandAllPostROEX();
HRESULT DoRunOnceExProcess();
HRESULT RestoreIcons();
HRESULT Process();
void    AddRegMunger();

DWORD RunProcess(LPVOID lp);
LRESULT CALLBACK DlgProcFixIE(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK DlgProcConfirm(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK DlgProcReinstall(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void uiCenterDialog( HWND hwndDlg );
void RunOnceExProcessCallback(int nCurrent, int nMax, LPSTR pszError);
void LogError(char *pszFormatString, ...);
void VersionToString(DWORD dwMSVer, DWORD dwLSVer, LPSTR pszVersion);

HRESULT FixIE(BOOL bConfirm, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    HANDLE  hMutex ;
    OSVERSIONINFO VerInfo;

    // allow only one instance running at a time
    // ALSO : mutex wrt to IESetup.EXE. Hence use specific named mutex only
    hMutex = CreateMutex(NULL, TRUE, "Ie4Setup.Mutext");
    if ((hMutex != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        CloseHandle(hMutex);
        return S_FALSE;
    }

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // If the user does not have Admin rights, bail out.
        if ( !IsNTAdmin(0, NULL))
        {
            char szMsg[MAX_STRING];

            LoadSz(IDS_NEED_ADMIN, szMsg, sizeof(szMsg));
            DisplayMessage(szMsg, MB_OK|MB_ICONEXCLAMATION);

            if (hMutex)
                CloseHandle(hMutex);

            return S_OK;
        }
    }

    if (bConfirm)
    {
        if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_CONFIRM), NULL, (DLGPROC) DlgProcConfirm) == IDNO)
        {
            WriteToLog("\r\nUser selected not to repair.\r\n");
            if (g_pIStream)
                ConvertIStreamToFile(&g_pIStorage, &g_pIStream);

            if (hMutex)
                CloseHandle(hMutex);

            return S_OK;
        }
    }

    // #40352 - always repair Icons. No need to check if flag is set for it.
    ////////////////////////////////////////////////////////////////
    // else
    // {
    //     g_bRestoreIcons = dwFlags & FIXIE_ICONS;
    // }
    ////////////////////////////////////////////////////////////////

    if (g_bRestoreIcons)
    {
        WriteToLog("Restore icon set to true.\r\n");
    }
    else
    {
        WriteToLog("Restore icon set to false.\r\n");
    }

    if (dwFlags & FIXIE_QUIET)
    {
        g_bQuiet = TRUE;
        WriteToLog("Quiet mode on.\r\n");
    }
    else
    {
        WriteToLog("Quiet mode off.\r\n");
    }

    // Get the heap - used for HeapAlloc and HeapReAlloc
    g_hHeap = GetProcessHeap();
    InitCommonControls();

    GetPlatform();
    WriteToLog("Main section name: %1\r\n",g_szModifiedMainSectionName);

    // if running on NT5 or Millennium or
    // If NT4-SP4, don't process the Crypto files else process them too.
    if ( (g_dwPlatform == PLATFORM_MILLEN) || (g_dwPlatform == PLATFORM_NT5) ||
         ((g_dwPlatform == PLATFORM_NT4 || g_dwPlatform == PLATFORM_NT4ALPHA) && CheckForNT4_SP4()))
        
    {
        // Null string the Crypto section name
        *g_szCryptoSectionName = '\0';
        WriteToLog("No Crypto section to be processed!\r\n");
    }
    else
    {
        lstrcpy(g_szCryptoSectionName, c_gszMainSectionName);
        lstrcat(g_szCryptoSectionName, c_gszCrypto);
        WriteToLog("Crypto section name: %1\r\n",g_szCryptoSectionName);
    }

    GetInfFile();
    WriteToLog("Inf file used: %1\r\n",g_szFixIEInf);

    WriteToLog("\r\nFixIE started.\r\n\r\n");

    if (!g_bQuiet)
    {

        if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_FIXIE), NULL, (DLGPROC) DlgProcFixIE) == -1)
        {
            WriteToLog("\r\nERROR - Display dialog failed!\r\n\r\n");
            hr = E_FAIL;
        }
        else
        {
            hr = g_hr;
        }
    }
    else
    {
        hr = Process();
    }

    if (SUCCEEDED(hr))
    {
        WriteToLog("\r\nFixIE successful!\r\n");

        // Success, so ask user to reboot
        MyRestartDialog(g_hWnd, !g_bQuiet, IDS_REBOOT);
    }
    else
    {
        WriteToLog("\r\nERROR - FixIE failed!\r\n\r\n");

        if (g_bNeedReboot)
        {
            MyRestartDialog(g_hWnd, !g_bQuiet, IDS_REBOOTFILE);
        }
        else
        {
            DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_REINSTALL), NULL, (DLGPROC) DlgProcReinstall);
        }
    }

    if (g_pszError)
        HeapFree(g_hHeap,0,g_pszError);

    if (g_pIStream)
        ConvertIStreamToFile(&g_pIStorage, &g_pIStream);

    if (hMutex)
        CloseHandle(hMutex);

    return hr;
}

HRESULT Process()
{
    HRESULT hr = S_OK;

    WriteToLog("\r\nInside Process.\r\n");

    // Get all the components that are successfully installed for the current platform
    if (SUCCEEDED(hr))
    {
        hr = InitComponentList();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nInitComponentList succeeded!\r\n\r\n");
            WriteToLog("There are a total of %1!ld! installed components.\r\n\r\n",g_nNumGuids);
        }
        else
        {
            WriteToLog("\r\nERROR - InitComponentList failed!\r\n\r\n");
        }
    }

    // Verify all the files in the VFS sections exists and have valid version #s
    if (SUCCEEDED(hr))
    {
        hr = VerifyAllFiles();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nVerifyAllFiles succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - VerifyAllFiles failed!\r\n\r\n");
        }
    }

    // Run RunSetupCommand on the PreROEX section
    if (SUCCEEDED(hr))
    {
        hr = RunSetupCommandPreROEX();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRunSetupCommandPreROEX succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RunSetupCommandPreROEX failed!\r\n\r\n");
        }
    }

    // Run RunSetupCommand on all the ROEX sections
    if (SUCCEEDED(hr))
    {
        hr = RunSetupCommandAllROEX();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRunSetupCommandAllROEX succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RunSetupCommandAllROEX failed!\r\n\r\n");
        }
    }

    // Call runonceexprocess
    if (SUCCEEDED(hr))
    {
        hr = DoRunOnceExProcess();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nDoRunOnceExProcess succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - DoRunOnceExProcess failed!\r\n\r\n");
        }
    }

    // If there are any errors, then set hr to E_FAIL
    if (g_pszError)
        hr = E_FAIL;

    // Run RunSetupCommand on all the PostROEX sections
    if (SUCCEEDED(hr))
    {
        hr = RunSetupCommandAllPostROEX();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRunSetupCommandAllPostROEX succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RunSetupCommandAllPostROEX failed!\r\n\r\n");
        }
    }

    // Restore icons
    if (SUCCEEDED(hr) && g_bRestoreIcons)
    {
        hr = RestoreIcons();
        if (SUCCEEDED(hr))
        {
            WriteToLog("\r\nRestoreIcons succeeded!\r\n\r\n");
        }
        else
        {
            WriteToLog("\r\nERROR - RestoreIcons failed!\r\n\r\n");
        }
    }

    return hr;
}

DWORD RunProcess(LPVOID lp)
{
    WriteToLog("\r\nInside RunProcess.\r\n");

    SendMessage(g_hProgress, PBM_SETRANGE, 0, MAKELPARAM(g_nProgressStart, g_nProgressEnd));
    SendMessage(g_hProgress, PBM_SETPOS, g_nProgressStart, 0);

    g_hr = Process();

    SendMessage(g_hProgress, PBM_SETPOS, g_nProgressEnd, 0);

    // terminate the dialog box
    PostMessage((HWND) lp, WM_FINISHED, 0, 0L);

    return 0;
}

LRESULT CALLBACK DlgProcConfirm(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiCenterDialog(hWnd);
        g_hWnd = hWnd;
        break;

    case WM_COMMAND:
        switch( wParam )
        {
        case IDYES:
        case IDNO:
            // #40352 - Icon check box no longer exists. Always repair icons.
            // g_bRestoreIcons = (IsDlgButtonChecked(hWnd, IDC_REPAIR_ICONS) == BST_CHECKED);
            g_hWnd = NULL;
            EndDialog(hWnd, wParam);
            break;

        case IDCANCEL:
            g_hWnd = NULL;
            EndDialog(hWnd, IDNO);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

LRESULT CALLBACK DlgProcReinstall(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPSTR pszMessage;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiCenterDialog(hWnd);
        if (!g_pszError)
        {
            EnableWindow(GetDlgItem(hWnd, IDC_DETAILS), FALSE);
        }
        else
        {
            char szString[MAX_STRING];

            LoadSz(IDS_FOLLOWINGERROR, szString, sizeof(szString));
            pszMessage = (LPSTR)HeapAlloc(g_hHeap, 0, lstrlen(g_pszError) + sizeof(szString) + 1);

            lstrcpy(pszMessage, szString);
            lstrcat(pszMessage, g_pszError);
        }
        g_hWnd = hWnd;
        break;

    case WM_COMMAND:
        switch( wParam )
        {
        case IDOK:
        case IDCANCEL:
            g_hWnd = NULL;
            HeapFree(g_hHeap, 0, pszMessage);
            EndDialog(hWnd, wParam);
            break;

        case IDC_DETAILS:
            // Display failure messages.
            char szTitle[MAX_STRING];
            GetWindowText(hWnd, szTitle, sizeof(szTitle));
            MessageBox(hWnd, pszMessage, szTitle, MB_OK);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

LRESULT CALLBACK DlgProcFixIE(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HANDLE s_hThread = NULL;
    DWORD dwThread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiCenterDialog(hWnd);
        g_hWnd = hWnd;
        g_hProgress = GetDlgItem(hWnd, IDC_PROGRESS);

        if ((s_hThread = CreateThread(NULL, 0, RunProcess, (LPVOID) hWnd, 0, &dwThread)) == NULL)
            PostMessage(hWnd, WM_FINISHED, 0, 0L);

        break;

    case WM_FINISHED:
        if (s_hThread != NULL)
        {
            while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
            {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            CloseHandle(s_hThread);
            s_hThread = NULL;
        }
        g_hWnd = NULL;
        EndDialog(hWnd, 0);
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

void RunOnceExProcessCallback(int nCurrent, int nMax, LPSTR pszError)
{
    int nStart = g_nDoRunOnceExProcessStart;
    int nEnd = g_nDoRunOnceExProcessEnd;

    WriteToLog("Current=%1!ld! ; Max=%2!ld! ; Error=%3\r\n", nCurrent, nMax, pszError);

    if (g_hProgress && nMax)
    {
        SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurrent/nMax, 0);
    }

    if (pszError)
    {
        LogError(pszError);
    }
}

void LogError(char *pszFormatString, ...)
{
    va_list args;
    char *pszFullErrMsg   = NULL;
    LPSTR pszErrorPreFail = NULL;

    // If error string does not exist, then malloc it
    if (!g_pszError)
    {
        g_pszError = (LPSTR)HeapAlloc(g_hHeap, 0, BUFFERSIZE);
		if ( ! g_pszError )
			return; // Is it OK to fail quietly here ?
        *g_pszError = '\0';
    }

    va_start(args, pszFormatString);
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
        (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
    if (pszFullErrMsg)
    {
        // Make room for new string and newline
        while (lstrlen(g_pszError)+lstrlen(pszFullErrMsg)+2>(int)HeapSize(g_hHeap, 0, g_pszError))
        {
            WriteToLog("Error string size is %1!ld!", HeapSize(g_hHeap, 0, g_pszError));
            pszErrorPreFail = g_pszError;
//#pragma prefast(suppress: 308, "PREfast noise - pointer was saved")
            g_pszError = (LPSTR)HeapReAlloc(g_hHeap, 0, g_pszError, HeapSize(g_hHeap, 0, g_pszError)+BUFFERSIZE);
            if(!g_pszError)
            {
                if (pszErrorPreFail)
                    HeapFree(g_hHeap, 0, pszErrorPreFail);
                break;
            }

            WriteToLog(", increasing it to %1!ld!\r\n", HeapSize(g_hHeap, 0, g_pszError));
        }

		if ( g_pszError )
		{
			// Add string and then add newline
			lstrcat(g_pszError, pszFullErrMsg);
			lstrcat(g_pszError, "\n");
		}

        LocalFree(pszFullErrMsg);
    }
}

HRESULT RestoreIcons()
{
    HRESULT hr = S_OK;

    const char szIEAccess[] = "Software\\Microsoft\\Active Setup\\Installed Components\\{ACC563BC-4266-43f0-B6ED-9D38C4202C7E}";
    int nStart = g_nRestoreIconsStart;
    int nEnd = g_nRestoreIconsEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    char szKey[MAX_PATH];
    lstrcpy(szKey, c_gszRegRestoreIcons);
    char* pszEnd = szKey + lstrlen(szKey);

    while (pComp && SUCCEEDED(hr))
    {
        // Add guid to end
        AddPath(szKey, pComp->szGuid);

        // Delete key
        if (RegDeleteKey(HKEY_CURRENT_USER, szKey) == ERROR_SUCCESS)
        {
            WriteToLog("Reg key HKCU\\%1 deleted\r\n", szKey);
        }
        else
        {
            WriteToLog("Reg key HKCU\\%1 cannot be deleted\r\n", szKey);
        }

        // Remove the guid
        *pszEnd = '\0';

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    RegDeleteKey(HKEY_CURRENT_USER, szIEAccess);

    return hr;
}

HRESULT DoRunOnceExProcess()
{
    HRESULT hr = E_FAIL;

    int nStart = g_nDoRunOnceExProcessStart;
    int nEnd = g_nDoRunOnceExProcessEnd;

    // Load iernonce.dll
    HINSTANCE hIERnOnceDLL;
    char szDLLPath[MAX_PATH];
    GetSystemDirectory(szDLLPath, sizeof(szDLLPath));
    AddPath(szDLLPath, c_gszIERnOnceDLL);
    hIERnOnceDLL = LoadLibrary(szDLLPath);

    if (hIERnOnceDLL)
    {
        RUNONCEEXPROCESS fpRunOnceExProcess;
        INITCALLBACK fpInitCallback;

        // Add callback and set to quiet
        if (fpInitCallback = (INITCALLBACK)GetProcAddress(hIERnOnceDLL, achInitCallback))
        {
            fpInitCallback(&RunOnceExProcessCallback, TRUE);
        }
        else
        {
            WriteToLog("\r\nERROR - GetProcAddress on %1 failed!\r\n\r\n", achInitCallback);
        }

        // Run RunOnceExProcess
        if (fpRunOnceExProcess = (RUNONCEEXPROCESS)GetProcAddress(hIERnOnceDLL, achRunOnceExProcess))
        {
            hr = fpRunOnceExProcess(g_hWnd, NULL, NULL, 1);
        }
        else
        {
            WriteToLog("\r\nERROR - GetProcAddress on %1 failed!\r\n\r\n", achRunOnceExProcess);
        }

        FreeLibrary(hIERnOnceDLL);
    }
    else
    {
        WriteToLog("\r\nERROR - %1 cannot be loaded!\r\n\r\n", szDLLPath);
    }

    if (g_hProgress)
        SendMessage(g_hProgress, PBM_SETPOS, nEnd, 0);

    return hr;
}

HRESULT RunSetupCommandPreROEX()
{
    HRESULT hr = S_OK;

    int nStart = g_nRunSetupCommandPreROEXStart;
    int nEnd = g_nRunSetupCommandPreROEXEnd;

    hr = MyRunSetupCommand(g_hWnd, g_szFixIEInf, c_gszPreSectionName, 0);

    if (g_hProgress)
        SendMessage(g_hProgress, PBM_SETPOS, nEnd, 0);

    return hr;
}

HRESULT RunSetupCommandAllPostROEX()
{
    HRESULT hr = S_OK;

    int nStart = g_nRunSetupCommandAllPostROEXStart;
    int nEnd = g_nRunSetupCommandAllPostROEXEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    while (pComp && SUCCEEDED(hr))
    {
        if ( *(pComp->szPostROEX) != '\0')
            hr = MyRunSetupCommand(g_hWnd, g_szFixIEInf, pComp->szPostROEX, 0);

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    return hr;
}

HRESULT RunSetupCommandAllROEX()
{
    HRESULT hr = S_OK;

    int nStart = g_nRunSetupCommandAllROEXStart;
    int nEnd = g_nRunSetupCommandAllROEXEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    while (pComp && SUCCEEDED(hr))
    {
        if ( *(pComp->szROEX) != '\0')
            hr = MyRunSetupCommand(g_hWnd, g_szFixIEInf, pComp->szROEX, 0);

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    return hr;
}

HRESULT VerifyAllFiles()
{
    HRESULT hr = S_OK;
    char szError[MAX_STRING];

    int nStart = g_nVerifyAllFilesStart;
    int nEnd = g_nVerifyAllFilesEnd;

    int nCurGuid = 0;

    LCIFCOMPONENT pComp = g_pLinkCif;

    char szMessage[MAX_STRING];
    char  szLocation[MAX_PATH];
    GetSystemDirectory(szLocation, sizeof(szLocation));
    char *pTmp = szLocation + lstrlen(szLocation);

    LPSTR lpVFSSection = NULL;
    while (pComp)
    {
        lpVFSSection = (LPSTR)LocalAlloc(LPTR, MAX_CONTENT);

        if(!lpVFSSection) {
            return E_FAIL;
        }

        WriteToLog("Looking up %1...\r\n", pComp->szVFS);

        if (GetPrivateProfileSection(pComp->szVFS, lpVFSSection, MAX_CONTENT, g_szFixIEInf))
        {
            LPSTR lpVFSLine = lpVFSSection;
            while (*lpVFSLine)
            {
                int nLength = lstrlen(lpVFSLine);

                // Need to allow new-line comments.
                if ( *lpVFSLine == ';' )
                {
                    lpVFSLine += nLength + 1;
                    continue;    // Go on with next iteration of the WHILE loop
                }

                WriteToLog("  Verifying %1\r\n", lpVFSLine);

                char szFile[MAX_STRING];

                // Find '=' so that file and versions can be seperated
                char* pChar;
                pChar = ANSIStrChr(lpVFSLine, '=');

                // if can't find '=' or '=' is last character then make sure file exists
                if (!pChar || (*(pChar+1)=='\0'))
                {
                    // Kill the '=' if it exists
                    if (pChar)
                        *pChar = '\0';

                    // Get the filename
                    lstrcpy(szFile, lpVFSLine);

                    // Add the filename to the path
                    AddPath(szLocation, szFile);

                    // If can't find file, then set error
                    if (GetFileAttributes(szLocation) == 0xFFFFFFFF)
                    {
                        hr = E_FAIL;

                        if (GetLastError() == ERROR_FILE_NOT_FOUND)
                        {
                            WriteToLog("   ERROR - File %1 does not exist.\r\n", szFile);
                            LoadSz(IDS_FILEMISSING, szError, sizeof(szError));
                            LogError(szError, szFile);
                        }
                        else
                        {
                            WriteToLog("   ERROR - File %1 exists but cannot be accessed.\r\n", szFile);
                            LoadSz(IDS_FILELOCKED, szError, sizeof(szError));
                            LogError(szError, szFile);
                            g_bNeedReboot = TRUE;
                        }
                    }
                    else
                    {
                        WriteToLog("   File %1 exists.\r\n", szFile);
                    }

                    // Reset the location to just the path again
                    *pTmp = '\0';
                }
                else // Make sure version in the given limits
                {
                    *pChar = '\0';
                    pChar++;

                    // Get the filename
                    lstrcpy(szFile, lpVFSLine);

                    DWORD   dwMSVer;
                    DWORD   dwLSVer;

                    // Add the filename to the path
                    AddPath(szLocation, szFile);
                    // Get the version of that file
                    MyGetVersionFromFile(szLocation, &dwMSVer, &dwLSVer);

                    // If file cannot be read then report error
                    if (dwMSVer==0 && dwLSVer==0 && GetFileAttributes(szLocation) == 0xFFFFFFFF)
                    {
                        hr = E_FAIL;

                        if (GetLastError() == ERROR_FILE_NOT_FOUND)
                        {
                            WriteToLog("   ERROR - File %1 does not exist.\r\n", szFile);
                            LoadSz(IDS_FILEMISSING, szError, sizeof(szError));
                            LogError(szError, szFile);
                        }
                        else
                        {
                            WriteToLog("   ERROR - File %1 exists but cannot be accessed.\r\n", szFile);
                            LoadSz(IDS_FILELOCKED, szError, sizeof(szError));
                            LogError(szError, szFile);
                            g_bNeedReboot = TRUE;
                        }
                    }
                    else
                    {
                        // Find '-' so that if there are more than one versions then they are seperated
                        char* pChar2;
                        pChar2 = ANSIStrChr(pChar, '-');
                        if (pChar2)
                        {
                            BOOL bVerifyError = FALSE;
                            char szVersionFound[MAX_VER];
                            char szVersionLow[MAX_VER];
                            char szVersionHigh[MAX_VER];
                            VersionToString(dwMSVer, dwLSVer, szVersionFound);

                            *pChar2 = '\0';
                            pChar2++;

                            // pChar points to first version
                            // pChar2 points to second version

                            // '-' found
                            // so it's one of: xxxx- ; -xxxx ; xxxx-xxxx
                            if (lstrlen(pChar)) // Low version exists
                            {
                                DWORD   dwMSVerLow = 0;
                                DWORD   dwLSVerLow = 0;
                                MyConvertVersionString(pChar, &dwMSVerLow, &dwLSVerLow);
                                VersionToString(dwMSVerLow, dwLSVerLow, szVersionLow);

                                // Make sure this version is greater than low version
                                if ((dwMSVerLow<dwMSVer) || ((dwMSVerLow==dwMSVer) && (dwLSVerLow<=dwLSVer)))
                                {
                                }
                                else
                                {
                                    bVerifyError = TRUE;
                                }
                            }

                            if (lstrlen(pChar2)) // High version exists
                            {
                                DWORD   dwMSVerHigh = 0;
                                DWORD   dwLSVerHigh = 0;
                                MyConvertVersionString(pChar2, &dwMSVerHigh, &dwLSVerHigh);
                                VersionToString(dwMSVerHigh, dwLSVerHigh, szVersionHigh);

                                // Make sure this version is lesser than high version
                                if ((dwMSVerHigh>dwMSVer) || ((dwMSVerHigh==dwMSVer) && (dwLSVerHigh>=dwLSVer)))
                                {
                                }
                                else
                                {
                                    bVerifyError = TRUE;
                                }
                            }

                            if (bVerifyError)
                            {
                                WriteToLog("   ERROR - File %1 (version %2) version check failed.\r\n", szFile, szVersionFound);
                                hr = E_FAIL;

                                if (lstrlen(pChar)&&lstrlen(pChar2))
                                {
                                    LoadSz(IDS_VERSIONINBETWEEN, szError, sizeof(szError));
                                    LogError(szError, szVersionFound, szFile, szVersionLow, szVersionHigh);
                                }
                                else if (lstrlen(pChar))
                                {
                                    LoadSz(IDS_VERSIONGREATER, szError, sizeof(szError));
                                    LogError(szError, szVersionFound, szFile, szVersionLow);
                                }
                                else if (lstrlen(pChar2))
                                {
                                    LoadSz(IDS_VERSIONLESS, szError, sizeof(szError));
                                    LogError(szError, szVersionFound, szFile, szVersionHigh);
                                }
                            }
                            else
                            {
                                WriteToLog("   File %1 version checked.\r\n", szFile);
                            }
                        }
                        else // no '-' is found
                        {
                            // so it's a unique version
                            // the current version must be exact
                            DWORD   dwMSVerExact = 0;
                            DWORD   dwLSVerExact = 0;
                            MyConvertVersionString(pChar, &dwMSVerExact, &dwLSVerExact);

                            char szVersionFound[MAX_VER];
                            char szVersionRequired[MAX_VER];
                            VersionToString(dwMSVer, dwLSVer, szVersionFound);
                            VersionToString(dwMSVerExact, dwLSVerExact, szVersionRequired);

                            // If it is not an exact match then signal error occured
                            if ((dwMSVerExact==dwMSVer) && (dwLSVerExact==dwLSVer))
                            {
                                WriteToLog("   File %1 version checked.\r\n", szFile);
                            }
                            else
                            {
                                WriteToLog("   ERROR - File %1 (version %2) version check failed.\r\n", szFile, szVersionFound);
                                LoadSz(IDS_VERSIONEXACT, szError, sizeof(szError));
                                LogError(szError, szVersionFound, szFile, szVersionRequired);
                                hr = E_FAIL;
                            }
                        }
                    }
                    // Reset the location to just the path again
                    *pTmp = '\0';
                }
                lpVFSLine += nLength + 1;
            }
        }

        nCurGuid++;
        if (g_hProgress)
            SendMessage(g_hProgress, PBM_SETPOS, nStart+(nEnd-nStart)*nCurGuid/g_nNumGuids, 0);

        pComp = pComp->next;
    }

    if (lpVFSSection)
        LocalFree(lpVFSSection);

    return hr;
}

void VersionToString(DWORD dwMSVer, DWORD dwLSVer, LPSTR pszVersion)
{
    wsprintf(pszVersion, "%d.%d.%d.%d", HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer));
}


VOID GetInfFile()
{
    DWORD dwType;
    DWORD dwSize = sizeof(g_szFixIEInf);
    HKEY hKey;

    *g_szFixIEInf = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_gszRegstrPathIExplore, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)g_szFixIEInf, &dwSize) == ERROR_SUCCESS) && (dwType == REG_SZ))
        {
            GetParentDir(g_szFixIEInf);
        }
        RegCloseKey(hKey);
    }

    AddPath(g_szFixIEInf, c_gszFixIEInfName);
}

VOID GetPlatform()
{
    LPCSTR        pTemp = NULL;
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);

    lstrcpy(g_szModifiedMainSectionName, c_gszMainSectionName);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        // Running NT
        g_bRunningWin95 = FALSE;

        SYSTEM_INFO System_info;
        GetSystemInfo(&System_info);
        if (System_info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA)
        {
            g_dwPlatform = PLATFORM_NT5ALPHA;
            if (VerInfo.dwMajorVersion == 4)
                g_dwPlatform = PLATFORM_NT4ALPHA;
            pTemp = c_gszNTalpha;
        }
        else
        {
            g_dwPlatform = PLATFORM_NT5;
            pTemp = c_gszW2K;
            if (VerInfo.dwMajorVersion == 4)
            {
                g_dwPlatform = PLATFORM_NT4;
                pTemp = c_gszNTx86;
            }
        }
    }
    else
    {
        // Running Windows 9x
        // Assume Win98
        g_bRunningWin95 = TRUE;

        g_dwPlatform = PLATFORM_WIN98;
        pTemp = c_gszWin95;
        if (VerInfo.dwMinorVersion == 0)
        {
            g_dwPlatform = PLATFORM_WIN95;
        }
        else if (VerInfo.dwMinorVersion == 90)
        {
            pTemp = c_gszMillen;
            g_dwPlatform = PLATFORM_MILLEN;
        }
    }
    if (pTemp)
        lstrcat(g_szModifiedMainSectionName, pTemp);
}

#define REGSTR_CCS_CONTROL_WINDOWS  REGSTR_PATH_CURRENT_CONTROL_SET "\\WINDOWS"
#define CSDVERSION      "CSDVersion"
#define NTSP4_VERSION   0x0600
// version updated to SP6!

BOOL CheckForNT4_SP4()
{
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;
    BOOL    bNTSP4 = -1;

    if ( bNTSP4 == -1)
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            // assign the default
            bNTSP4 = FALSE;
            dwSize = sizeof(dwCSDVersion);
            if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (unsigned char*)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
            {
                bNTSP4 = (LOWORD(dwCSDVersion) >= NTSP4_VERSION);
            }
            RegCloseKey(hKey);
        }
    }
    return bNTSP4;
}


HRESULT InitComponentList()
{
    HRESULT hr = E_FAIL;

    ICifFile *pCifFile = NULL;
    IEnumCifComponents *pEnumCifComponents = NULL;
    ICifComponent *pCifComponent = NULL;

    hr = GetICifFileFromFile(&pCifFile, "iesetup.cif");
    if (SUCCEEDED(hr))
    {
        hr = pCifFile->EnumComponents(&pEnumCifComponents, g_dwPlatform , NULL);
        if (SUCCEEDED(hr))
        {
            while (pEnumCifComponents->Next(&pCifComponent) == S_OK)
            {
                if (pCifComponent->IsComponentInstalled() == ICI_INSTALLED)
                    AddComponent(pCifComponent);
            }
            pEnumCifComponents->Release();
        }
        else
        {
            WriteToLog("\r\nERROR - Cannot pCifFile->EnumComponents!\r\n\r\n");
        }
        pCifFile->Release();
    }
    else
    {
        WriteToLog("\r\nERROR - Cannot GetICifFileFromFile!\r\n\r\n");
    }

    return hr;
}


VOID AddLink(LPSTR szGuid, ICifComponent *pCifComp, LPSTR szGuidProfileString)
{
    char            szID[MAX_STRING];
    LCIFCOMPONENT   pComp;
    char            *pStart = szGuidProfileString;
    char            *pChar;
    LCIFCOMPONENT   pTemp = g_pLinkCif;
    LCIFCOMPONENT   pLast = NULL;

    pCifComp->GetID(szID, sizeof(szID));
    WriteToLog("Add component %1 with GUID %2\r\n", szID, szGuid);

    // Initialize all the members of the new LCIFCOMPONENT link.
    pComp = (LCIFCOMPONENT)LocalAlloc(LPTR, sizeof(LINKEDCIFCOMPONENT));
    pComp->pCifComponent = pCifComp;
    lstrcpy(pComp->szGuid, szGuid);
    *(pComp->szVFS) = '\0';
    *(pComp->szROEX) = '\0';
    *(pComp->szPostROEX) = '\0';
    pComp->next = NULL;


    GetStringField(szGuidProfileString, 0, pComp->szVFS, sizeof(pComp->szVFS));
    GetStringField(szGuidProfileString, 1, pComp->szROEX, sizeof(pComp->szROEX));
    GetStringField(szGuidProfileString, 2, pComp->szPostROEX, sizeof(pComp->szPostROEX));

    WriteToLog("   VFS = %1\r\n",pComp->szVFS);
    WriteToLog("   ROEX = %1\r\n", pComp->szROEX);
    WriteToLog("   PostROEX = %1\r\n", pComp->szPostROEX);

    // Add the new link to the linklist pointed to be g_pLinkCif
    while (pTemp)
    {
        pLast = pTemp;
        pTemp = pTemp->next;
    }

    if (pLast)
        pLast->next = pComp;
    else
        g_pLinkCif = pComp;

    // Increment global count of number of guids
    g_nNumGuids++;

    if (pTemp)
    {
        pComp->next = pTemp;
    }
}


VOID AddComponent(ICifComponent *pCifComp)
{
    char szGuid[MAX_STRING];
    if (SUCCEEDED(pCifComp->GetGUID(szGuid, sizeof(szGuid))))
    {
        char szGuidProfileString[MAX_STRING];
        if (GetPrivateProfileString(g_szModifiedMainSectionName, szGuid, "", szGuidProfileString, sizeof(szGuidProfileString), g_szFixIEInf))
        {
            AddLink(szGuid, pCifComp, szGuidProfileString);
        }

        // If a valid Crypto section exists, process this GUID entry under it too.
        if ( *g_szCryptoSectionName )
        {
            if (GetPrivateProfileString(g_szCryptoSectionName, szGuid, "", szGuidProfileString, sizeof(szGuidProfileString), g_szFixIEInf))
            {
                AddLink(szGuid, pCifComp, szGuidProfileString);
            }
        }
    }
}

VOID MyConvertVersionString(LPSTR lpszVersion, LPDWORD pdwMSVer, LPDWORD pdwLSVer)
{
    WORD wVer[4];

    ConvertVersionString(lpszVersion, wVer, '.' );
    *pdwMSVer = (DWORD)wVer[0] << 16;    // Make hi word of MS version
    *pdwMSVer += (DWORD)wVer[1];         // Make lo word of MS version
    *pdwLSVer = (DWORD)wVer[2] << 16;    // Make hi word of LS version
    *pdwLSVer += (DWORD)wVer[3];         // Make lo word of LS version

}

VOID MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    LPVOID      lpVerBuffer;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize(lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            // Read version stamping info
            if (GetFileVersionInfo(lpszFilename, dwHandle, dwVerInfoSize, lpBuffer))
            {
                // Get the value for Translation
                if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                    (uiSize))

                {
                    *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                    *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                }
            }
            LocalFree(lpBuffer);
        }
    }
    return ;
}

VOID WriteToLog(char *pszFormatString, ...)
{
    va_list args;
    char *pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (!g_pIStream)
    {
        char szTmp[MAX_PATH];
        LPWSTR  pwsz = NULL;

        if (GetWindowsDirectory(g_szLogFileName, sizeof(g_szLogFileName)))
        {
            AddPath(g_szLogFileName, c_gszLogFileName);
            if (GetFileAttributes(g_szLogFileName) != 0xFFFFFFFF)
            {
                // Make a backup of the current log file
                lstrcpyn(szTmp, g_szLogFileName, lstrlen(g_szLogFileName) - 2 );    // don't copy extension
                lstrcat(szTmp, "BAK");
                SetFileAttributes(szTmp, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szTmp);
                MoveFile(g_szLogFileName, szTmp);
            }

            pwsz = MakeWideStrFromAnsi(g_szLogFileName);

            if ((pwsz) &&
                (!FAILED(StgCreateDocfile(pwsz,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0, &g_pIStorage))) )
            {
                g_pIStorage->CreateStream( L"CONTENTS",
                    STGM_READWRITE| STGM_SHARE_EXCLUSIVE,
                    0, 0, &g_pIStream );

                if (g_pIStream == NULL)
                {
                    // Could not open the stream, close the storage and delete the file
                    g_pIStorage->Release();
                    g_pIStorage = NULL;
                    DeleteFile(g_szLogFileName);
                }
            }

            if (pwsz)
                CoTaskMemFree(pwsz);

            WriteToLog("Logging information for FixIE ...\r\n");
            LogTimeDate();
            WriteToLog("\r\n");
        }
    }

    if (g_pIStream)
    {
        va_start(args, pszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
            (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
        if (pszFullErrMsg)
        {
            g_pIStream->Write(pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten);
            LocalFree(pszFullErrMsg);
        }
    }
}

void ConvertIStreamToFile(LPSTORAGE *pIStorage, LPSTREAM *pIStream)
{
    HANDLE  fh;
    char szTempFile[MAX_PATH];      // Should use the logfilename
    LPVOID lpv = NULL;
    LARGE_INTEGER li;
    DWORD   dwl;
    ULONG   ul;
    HRESULT hr;

    lstrcpy (szTempFile, g_szLogFileName);
    MakePath(szTempFile);
    if (GetTempFileName(szTempFile, "~VS", 0, szTempFile) != 0)
    {
        fh = CreateFile(szTempFile, GENERIC_READ|GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (fh != INVALID_HANDLE_VALUE)
        {
            lpv = (LPSTR)LocalAlloc(LPTR, BUFFERSIZE);
            if (lpv)
            {
                LISet32(li, 0);
                (*pIStream)->Seek(li, STREAM_SEEK_SET, NULL); // Set the seek pointer to the beginning
                do
                {
                    hr = (*pIStream)->Read(lpv, BUFFERSIZE, &ul);
                    if(SUCCEEDED(hr))
                    {
                        if (!WriteFile(fh, lpv, ul, &dwl, NULL))
                            hr = E_FAIL;
                    }
                }
                while ((SUCCEEDED(hr)) && (ul == BUFFERSIZE));
                LocalFree(lpv);
            }
            CloseHandle(fh);
            // Need to release stream and storage to close the storage file.
            (*pIStream)->Release();
            (*pIStorage)->Release();
            *pIStream = NULL;
            *pIStorage = NULL;

            if (SUCCEEDED(hr))
            {
                DeleteFile(g_szLogFileName);
                MoveFile(szTempFile, g_szLogFileName);
            }
        }
    }
    if (*pIStream)
    {
        // If we did not manage to convert the file to a text file
        (*pIStream)->Release();
        (*pIStorage)->Release();
        *pIStream = NULL;
        *pIStorage = NULL;
    }

    return ;
}

LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

LPSTR MakeAnsiStrFromWide(LPWSTR pwsz)
{
    LPSTR psz;
    int i;

    // arg checking.
    //
    if (!pwsz)
        return NULL;

    // compute the length
    //
    i =  WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
    if (i <= 0) return NULL;

    psz = (LPSTR) CoTaskMemAlloc(i * sizeof(CHAR));

    if (!psz) return NULL;
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, i, NULL, NULL);
    psz[i - 1] = 0;
    return psz;
}

void MakePath(LPSTR lpPath)
{
    LPSTR lpTmp;
    lpTmp = CharPrev( lpPath, lpPath+lstrlen(lpPath));

    // chop filename off
    //
    while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
        lpTmp = CharPrev( lpPath, lpTmp );

    if ( *CharPrev( lpPath, lpTmp ) != ':' )
        *lpTmp = '\0';
    else
        *CharNext( lpTmp ) = '\0';
    return;
}

void LogTimeDate()
{
    SYSTEMTIME  SystemTime;
    GetLocalTime(&SystemTime);

    WriteToLog("Date:%1!d!/%2!d!/%3!d! (M/D/Y) Time:%4!d!:%5!d!:%6!d!\r\n",
        SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
        SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
}

HRESULT MyRunSetupCommand(HWND hwnd, LPCSTR lpszInfFile, LPCSTR lpszSection, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    char szSourceDir[MAX_PATH];
    lstrcpy(szSourceDir, lpszInfFile);
    GetParentDir(szSourceDir);

    WriteToLog("Run setup command. File:%1: Section:%2:\r\n",lpszInfFile, lpszSection);

    dwFlags |= (RSC_FLAG_INF | RSC_FLAG_NGCONV | RSC_FLAG_QUIET);

    hr = RunSetupCommand(hwnd, lpszInfFile, lpszSection, szSourceDir, NULL, NULL, dwFlags, NULL);

    WriteToLog("RunSetupCommand returned :%1!lx!:\r\n", hr);

    if (!SUCCEEDED(hr))
        WriteToLog("\r\nERROR - RunSetupCommand failed\r\n\r\n");

    return hr;
}

void uiCenterDialog( HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0);

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect(hwndDlg,&rc);

    x = rc.left;    // Default is to leave the dialog where the template
    y = rc.top;     //  was going to place it.

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ((cyScreen - cyDlg) / 2);
    x = rcScreen.left + ((cxScreen - cxDlg) / 2);

    // Position the dialog.
    //
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
}

BOOL MyNTReboot()
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
        return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
    {
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
    STARTUPINFO startInfo;
    PROCESS_INFORMATION processInfo;
    HRESULT hr = S_OK;
    BOOL fRet;

    if(phProc)
        *phProc = NULL;

    // Create process on pszCmd
    ZeroMemory(&startInfo, sizeof(startInfo));
    startInfo.cb = sizeof(startInfo);
    startInfo.dwFlags |= STARTF_USESHOWWINDOW;
    startInfo.wShowWindow = (USHORT)uShow;
    fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE,
        NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
    if(!fRet)
        return E_FAIL;

    if(phProc)
        *phProc = processInfo.hProcess;
    else
        CloseHandle(processInfo.hProcess);

    CloseHandle(processInfo.hThread);

    return S_OK;
}

#define SOFTBOOT_CMDLINE   "softboot.exe /s:,60"

// Display a dialog asking the user to restart Windows, with a button that
// will do it for them if possible.
//
BOOL MyRestartDialog(HWND hParent, BOOL bShowPrompt, UINT nIdMessage)
{
    char szBuf[MAX_STRING];
    char szTitle[MAX_STRING];
    UINT    id = IDYES;

    if(bShowPrompt)
    {
        LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
        LoadSz(nIdMessage, szBuf, sizeof(szBuf));
        id = MessageBox(hParent, szBuf, szTitle, MB_ICONQUESTION | MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND);
    }

    if ( id == IDYES )
    {
        // path to softboot plus a little slop for the command line
        char szBuf[MAX_PATH + 10];
        szBuf[0] = 0;

        GetSystemDirectory(szBuf, sizeof(szBuf));
        AddPath(szBuf, SOFTBOOT_CMDLINE);
        if(FAILED(LaunchProcess(szBuf, NULL, NULL, SW_SHOWNORMAL)))
        {
            if(g_bRunningWin95)
            {
                ExitWindowsEx( EWX_REBOOT , 0 );
            }
            else
            {
                MyNTReboot();
            }
        }

    }
    return (id == IDYES);
}

int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize)
{
    if(cMaxSize == 0)
        return 0;

    pszBuf[0] = 0;

    return LoadString(g_hInstance, id, pszBuf, cMaxSize);
}

DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, ',');
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, ',');
   while(pszBegin <= pszEnd && *pszBegin == ' ')
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);

   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
      pszStr++;
   return pszStr;
}

int DisplayMessage(char* pszMessage, UINT uStyle)
{
    int iReturn = 0;
    if (!g_bQuiet)
    {
        char szTitle[MAX_STRING];
        LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
        iReturn = MessageBox(g_hWnd, pszMessage, szTitle, uStyle);
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\iesetup.h ===
extern HINSTANCE g_hInstance;

void AddRegMunger();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\makefile.inc ===
clean:
    -del /F /Q $(O)\selfreg_iesetup.inf


!if "$(BUILD_PRODUCT)" == "NT"
$(O)\selfreg_iesetup.inf: selfreg.inx
    cl -nologo -D_MSC_VER=1000  -DNASHVILLE=1 -DBUILD_PRODUCT=1 -I $(SDK_INC_PATH) -FI $(SDK_INC_PATH)\ntverp.h -FI ..\ie40\html\ieverdef.h -EP -Tc$** > $@
!else
$(O)\selfreg_iesetup.inf: selfreg.inx
    cl -nologo -D_MSC_VER=1000  -DNASHVILLE=1 -I $(SDK_INC_PATH) -FI $(SDK_INC_PATH)\ntverp.h -FI ..\ie40\html\ieverdef.h -EP -Tc$** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\pch.h ===
#include <windows.h>
#include <commctrl.h>
#include "sdsutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else  // DEBUG

#define SZTHISFILE
#define ASSERT(fTest, err)
#define FAIL(err)

#define CHECK_POINTER(val)
#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iesetup.rc
//
#define IDD_FIXIE                       1
#define IDS_TITLE                       1
#define IDD_CONFIRM                     2
#define IDS_REBOOT                      2
#define IDS_FOLLOWINGERROR              3
#define IDD_REINSTALL                   3
#define IDS_CANTFIX                     4
#define IDS_REINSTALL                   5
#define IDS_REBOOTFILE                  6
#define IDS_FILEMISSING                 7
#define IDC_PROGRESS                    8
#define IDS_FILELOCKED                  8
#define IDC_REPAIR_ICONS                9
#define IDS_VERSIONINBETWEEN            9
#define IDS_VERSIONGREATER              10
#define IDS_VERSIONLESS                 11
#define IDS_VERSIONEXACT                12
#define IDS_NEED_ADMIN                  13
#define IDI_INETCPL                     102
#define IDC_DETAILS                     1001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\ctrlobj.h ===
//=--------------------------------------------------------------------------=
// CtrlObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the COleControl object
//
#ifndef _CTRLOBJ_H_

// we need the automation object and ctlole.h
//
#include "AutoObj.H"
#include <olectl.h>

// forward declaration
//
class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.
//
COleControl *ControlFromUnknown(IUnknown *);


//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// maximum number of arguments that can be sent to FireEvent()
//
#define MAX_ARGS    32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these
//
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1

// superclass window support.  you can pass this in to DoSuperClassPaint
//
#define DRAW_SENDERASEBACKGROUND        1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number.  Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.
//
#define CTLIVERB_PROPERTIES     1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.
//
typedef struct tagVERBINFO {

    LONG    lVerb;                // verb id
    ULONG   idVerbName;           // resource ID of verb name
    DWORD   fuFlags;              // verb flags
    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

// describes an event
//
typedef struct tagEVENTINFO {

    DISPID    dispid;                    // dispid of the event
    int       cParameters;               // number of arguments to the event
    VARTYPE  *rgTypes;                   // type of each argument

} EVENTINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.  the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information
    const IID      *piidEvents;                    // IID of primary event interface
    DWORD           dwOleMiscFlags;                // control flags
    DWORD           dwActivationPolicy;            // IPointerInactive support
    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque?
    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can?
    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap
    LPCSTR          szWndClass;                    // name of window control class
    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet?
    WORD            cPropPages;                    // number of property pages
    const GUID    **rgPropPageGuids;               // array of the property page GUIDs
    WORD            cCustomVerbs;                  // number of custom verbs
    const VERBINFO *rgCustomVerbs;                 // description of custom verbs
    WNDPROC         pfnSubClass;                   // for subclassed controls.

} CONTROLOBJECTINFO;


#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \


#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define EVENTIIDOFCONTROL(index)         (*(((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->piidEvents))
#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass


//=--------------------------------------------------------------------------=
// COleControl
//=--------------------------------------------------------------------------=
// the mother of all C++ objects
//
class COleControl : public CAutomationObject,
                    public IOleObject, public IOleControl,
                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject,
                    public IViewObjectEx, public IPersistPropertyBag,
                    public IPersistStreamInit, public IPersistStorage,
                    public IConnectionPointContainer, public ISpecifyPropertyPages,
                    public IProvideClassInfo, public IPointerInactive,
                    public IQuickActivate
{
  public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.  just delegate to controlling
    // unknown
    //
    DECLARE_STANDARD_UNKNOWN();

    //=--------------------------------------------------------------------------=
    // IPersist methods.  used by IPersistStream and IPersistStorage
    //
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

    // IPersistStreamInit methods
    //
    STDMETHOD(IsDirty)(THIS);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
    STDMETHOD(InitNew)();

    // IPersistStorage
    //
    STDMETHOD(InitNew)(IStorage  *pStg);
    STDMETHOD(Load)(IStorage  *pStg);
    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

    // IPersistPropertyBag
    //
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    // IOleControl methods
    //
    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
    STDMETHOD(OnMnemonic)(LPMSG pMsg);
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
    STDMETHOD(FreezeEvents)(BOOL bFreeze);

    // IOleObject methods
    //
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                                     HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID  *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject
    //
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceObject/IOleInPlaceObjectWindowless
    //
    STDMETHOD(InPlaceDeactivate)(void);
    STDMETHOD(UIDeactivate)(void);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    STDMETHOD(ReactivateAndUndo)(void);
    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                            IOleInPlaceUIWindow  *pUIWindow,
                            BOOL fFrameWindow);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IViewObject2/IViewObjectEx
    //
    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw,
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                    BOOL ( __stdcall  *pfnContinue )(ULONG_PTR dwContinue),
                    ULONG_PTR dwContinue);
    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                           DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                           LOGPALETTE  * *ppColorSet);
    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                      void  *pvAspect,DWORD  *pdwFreeze);
    STDMETHOD(Unfreeze)(DWORD dwFreeze);
    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
    STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

    // IConnectionPointContainer methods
    //
    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    // ISpecifyPropertyPages
    //
    STDMETHOD(GetPages)(CAUUID * pPages);

    // IProvideClassInfo methods
    //
    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

    // IPointerInactive methods
    //
    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

    // IQuickActivate methods
    //
    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
    STDMETHOD(SetContentExtent)(LPSIZEL);
    STDMETHOD(GetContentExtent)(LPSIZEL);

    // constructor and destructor
    //
    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface,
		BOOL fExpandoEnabled=FALSE);
    virtual ~COleControl();

    //=--------------------------------------------------------------------------=
    // callable by anybody
    //
    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static COleControl * ControlFromHwnd(HWND hwnd) {
        return (COleControl *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);
    HINSTANCE    GetResourceHandle(void);


    //=--------------------------------------------------------------------------=
    // ole controls that want to support both windowed and windowless operations
    // should use these wrappers instead of the appropriate win32 api routine.
    // controls that don't care and just want to be windowed all the time can
    // just go ahead and use the api routines.
    //
    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API
    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd
    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect
    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc
    HDC     OcxGetDC(void);                             // GetDC(m_hwnd);
    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc);
    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL);
    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd
    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f);
    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...);

  protected:

    //=--------------------------------------------------------------------------=
    // member variables that derived controls can get at.
    //
    // derived controls Should NOT modify the following.
    //
    IOleClientSite     *m_pClientSite;             // client site
    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site
    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation
    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client
    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site
    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer
    SIZEL               m_Size;                    // the size of this control
    RECT                m_rcLocation;              // where we at
    HWND                m_hwnd;                    // our window
    HWND                m_hwndParent;              // our parent window
    HRGN                m_hRgn;

    // Windowless OLE controls support
    //
    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

    // flags indicating internal state.  do not modify.
    //
    unsigned m_fDirty:1;                           // does the control need to be resaved?
    unsigned m_fInPlaceActive:1;                   // are we in place active or not?
    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not?
    unsigned m_fUIActive:1;                        // are we UI active or not.
    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not

    //=--------------------------------------------------------------------------=
    // methods that derived controls can override, but may need to be called
    // from their versions.
    //
    virtual void      ViewChanged(void);
    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual BOOL      SetGUIFocus(HWND hwndSet);

    //=--------------------------------------------------------------------------=
    // member functions that provide for derived controls, or that we use, but
    // derived controls might still find useful.
    //
    HRESULT      DoSuperClassPaint(HDC, LPCRECTL);
    HRESULT      RecreateControlWindow(void);
    BOOL         DesignMode(void);
    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *);
    BOOL         GetAmbientFont(IFont **ppFontOut);
    void         ModalDialog(BOOL fShow);
    void         InvalidateControl(LPCRECT prc);
    BOOL         SetControlSize(SIZEL *pSizel);

    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
    HRESULT      InPlaceActivate(LONG lVerb);
    void         SetInPlaceVisible(BOOL);
    void         SetInPlaceParent(HWND);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.DoOnChanged(dispid);
    }
    inline BOOL  RequestPropertyEdit(DISPID dispid) {
        return m_cpPropNotify.DoOnRequestEdit(dispid);
    }

    // subclassed windows controls support ...
    //
    inline HWND  GetOuterWindow(void) {
        return (m_hwndReflect) ? m_hwndReflect : m_hwnd;
    }

    // little routine for people to tell if they are windowless or not
    //
    inline BOOL  Windowless(void) {
        return !m_fInPlaceActive || m_pInPlaceSiteWndless;
    }

    // some people don't care if they're windowed or not -- they just need
    // a site pointer.  this makes it a little easier.
    //
    inline IOleInPlaceSite    *GetInPlaceSite(void) {
        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
    }

  private:
    //=--------------------------------------------------------------------------=
    // the following are methods that ALL control writers must override and implement
    //
    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
    virtual BOOL    RegisterClassData(void) PURE;

    //=--------------------------------------------------------------------------=
    // OVERRIDABLES -- methods controls can implement for customized functionality
    //
    virtual void    AmbientPropertyChanged(DISPID dispid);
    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR);
    virtual void    BeforeDestroyWindow(void);
    virtual HRESULT DoCustomVerb(LONG lVerb);
    virtual BOOL    OnSetExtent(const SIZEL *pSizeL);
    virtual BOOL    OnSpecialKey(LPMSG);
    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **);
    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
    virtual BOOL    InitializeNewState();
    virtual BOOL    AfterCreateWindow(void);
    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect);
    virtual void    OnSetObjectRectsChangingWindowPos(DWORD *dwFlag);
    virtual void    OnVerb(LONG lVerb);

    //=--------------------------------------------------------------------------=
    // methods that various people internally will share.  not needed, however, by
    // any inherting classes.
    //
    HRESULT         m_SaveToStream(IStream *pStream);
    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    HRESULT         LoadStandardState(IStream *pStream);
    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag);
    HRESULT         SaveStandardState(IStream *pStream);

    //=--------------------------------------------------------------------------=
    // member variables we don't want anybody to get their hands on, including
    // inheriting classes
    //
    HWND              m_hwndReflect;               // for subclassed windows
    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object
    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2
    unsigned short    m_nFreezeEvents;             // count of freezes versus thaws
    unsigned          m_fHostReflects:1;           // does the host reflect messages?
    unsigned          m_fCheckedReflecting:1;      // have we checked above yet?

    // internal flags.  various other flags are visible to the end control class.
    //
    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible
    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly?
    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise
    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise
    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping
    unsigned m_fRunMode:1;                         // are we in run mode or not?

    class CConnectionPoint : public IConnectionPoint {
      public:
        IUnknown **m_rgSinks;

        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
        STDMETHOD_(ULONG,AddRef)(THIS) ;
        STDMETHOD_(ULONG,Release)(THIS) ;

        // IConnectionPoint methods
        //
        STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
        void    DoOnChanged(DISPID dispid);
        BOOL    DoOnRequestEdit(DISPID dispid);
        HRESULT AddSink(void *, DWORD *);

        COleControl *m_pOleControl();
        CConnectionPoint(BYTE b){
            m_bType = b;
            m_rgSinks = NULL;
            m_cSinks = 0;
            m_cAllocatedSinks = 0;
            m_SingleSink = NULL;
        }
        ~CConnectionPoint();

      private:
        BYTE   m_bType;
        unsigned short m_cSinks;
        IUnknown *m_SingleSink;
        unsigned short m_cAllocatedSinks;

    } m_cpEvents, m_cpPropNotify;

    // so they can get at some of our protected things, like AddRef, QI, etc.
    //
    friend CConnectionPoint;
};

#define _CTRLOBJ_H_
#endif // _CTRLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\iesetup\iodver.cpp ===
//=--------------------------------------------------------------------------=
// iodver.cpp
//=--------------------------------------------------------------------------=
// Copyright 1997-1998 Microsoft Corporation.  All Rights Reserved.
//
//
//

#include "string.h"
#include "pch.h"
#include "advpub.h"
#include "iesetup.h"

WINUSERAPI HWND    WINAPI  GetShellWindow(void);

HINSTANCE g_hInstance = NULL;

STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
   DWORD dwThreadID;

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         g_hInstance = (HINSTANCE)hDll;
         break;

      case DLL_PROCESS_DETACH:
         break;

      default:
         break;
   }
   return TRUE;
}

STDAPI DllRegisterServer(void)
{
    // BUGBUG: pass back return from RegInstall ?
    RegInstall(g_hInstance, "DllReg", NULL);

    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    RegInstall(g_hInstance, "DllUnreg", NULL);

    return S_OK;
}

BOOL IsXPSP1OrLater()
{
    BOOL fResult = FALSE;
    
    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
    {
        if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        {
            if (osvi.dwMajorVersion > 5)
            {
                fResult = TRUE;
            }
            else if (osvi.dwMajorVersion == 5)
            {
                if (osvi.dwMinorVersion > 1)
                {
                    fResult = TRUE;
                }
                else if (osvi.dwMinorVersion == 1)
                {
                    if (osvi.dwBuildNumber > 2600)
                    {
                        fResult = TRUE;
                    }
                    else if (osvi.dwBuildNumber == 2600)
                    {                                
                        HKEY hkey;

                        //  HIVESFT.INF and UPDATE.INF set this for service packs:
                        //  HKLM,SYSTEM\CurrentControlSet\Control\Windows,"CSDVersion",0x10001,0x100
                        
                        LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows"), 0, KEY_QUERY_VALUE, &hkey);

                        if (ERROR_SUCCESS == lResult)
                        {
                            DWORD dwValue;
                            DWORD cbValue = sizeof(dwValue);
                            DWORD dwType;

                            lResult = RegQueryValueEx(hkey, TEXT("CSDVersion"), NULL, &dwType, (LPBYTE)&dwValue, &cbValue);

                            if ((ERROR_SUCCESS == lResult) && (REG_DWORD == dwType) && (dwValue >= 0x100))
                            {
                                fResult = TRUE;
                            }
                            
                            RegCloseKey(hkey);
                        }
                    }
                }
            }
        }
    }

    return fResult;
}


BOOL IsWinNT4()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
         return (VerInfo.dwMajorVersion == 4) ;
    }

    return FALSE;
}

BOOL IsWinXP()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
         return (VerInfo.dwMajorVersion > 5) || 
            (VerInfo.dwMajorVersion == 5 && VerInfo.dwMinorVersion >= 1);
    }

    return FALSE;
}

STDAPI DllInstall(BOOL bInstall, LPCSTR lpCmdLine)
{
    // BUGBUG: pass back return from RegInstall ?
    if (bInstall)
    {
        RegInstall(g_hInstance, "DllUninstall", NULL);
        if(IsWinNT4())
            RegInstall(g_hInstance, "DllInstall.NT4Only", NULL);
        else if(IsWinXP())
            RegInstall(g_hInstance, "DllInstall.WinXP", NULL);
        else
            RegInstall(g_hInstance, "DllInstall", NULL);
    }
    else
        RegInstall(g_hInstance, "DllUninstall", NULL);

    return S_OK;
}

const TCHAR * const szStartMenuInternet = TEXT("SOFTWARE\\Clients\\StartMenuInternet");
const TCHAR szIexplore[] = TEXT("IEXPLORE.EXE");
const TCHAR * const szAdvPack = TEXT("advpack.dll");
const TCHAR * const szExecuteCab = TEXT("ExecuteCab");

const TCHAR * const szIEGUID = TEXT("{871C5380-42A0-1069-A2EA-08002B30309D}");
const TCHAR * const szHTTPAssoc = TEXT("http\\shell\\open\\command");
const TCHAR * const szIEAppPath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE");
const TCHAR * const szKeyComponent = TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{ACC563BC-4266-43f0-B6ED-9D38C4202C7E}");

typedef HRESULT (WINAPI *EXECUTECAB)(
    HWND     hwnd,
    PCABINFO pCab,
    LPVOID   pReserved 
);

BOOL IsNtSetupRunning();

HRESULT IEAccessAddStartMenuIcon(HKEY hKey)
{
    HKEY hKeyStartMenuInternet = NULL;
    HRESULT hResult;
    TCHAR szValue[32];
    DWORD dwSize = sizeof(szValue);
    
    if (ERROR_SUCCESS == (hResult = RegOpenKeyEx(hKey, szStartMenuInternet, 0,
            KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyStartMenuInternet)))
    {
        hResult = RegQueryValueEx(hKeyStartMenuInternet, NULL, NULL, NULL, 
                                    (LPBYTE)szValue, &dwSize);
        //Add IE icon only when there is no default browser icon.
        if ( (hResult == ERROR_SUCCESS && *szValue == 0) //empty data
            || (hResult != ERROR_SUCCESS && hResult != ERROR_MORE_DATA)) //value does not exist
        {
            hResult = RegSetValueEx(hKeyStartMenuInternet, NULL, NULL, REG_SZ, 
                                (CONST BYTE *)szIexplore, sizeof(szIexplore));
        }
    }
    
    if (hKeyStartMenuInternet)
        RegCloseKey(hKeyStartMenuInternet);
    
    return hResult;
}

HRESULT IEAccessDelStartMenuIcon(HKEY hKey)
{
    HKEY hKeyStartMenuInternet = NULL;
    HRESULT hResult;
    TCHAR szValue[32];
    DWORD dwSize = sizeof(szValue);
    
    if (ERROR_SUCCESS == (hResult = RegOpenKeyEx(hKey, szStartMenuInternet, 0,
            KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyStartMenuInternet)))
    {
        hResult = RegQueryValueEx(hKeyStartMenuInternet, NULL, NULL, NULL, 
                                    (LPBYTE)szValue, &dwSize);
        //Remove IE icon only when the default browser icon points to IE.
        if (SUCCEEDED(hResult))
        {
            if (0 == lstrcmpi (szValue, szIexplore))
                hResult = RegDeleteValue(hKeyStartMenuInternet, NULL);
        }
    }

    if (hKeyStartMenuInternet)
        RegCloseKey(hKeyStartMenuInternet);
    
    return hResult;
}

HRESULT IEAccessHTTPAssociate()
{
    DWORD dRes;
    HKEY hKeyAssoc = NULL, hKeyIEAppPath;
    const TCHAR szNoHome[] = TEXT("\" -nohome");
    TCHAR szValue[MAX_PATH + sizeof(szNoHome) + 2];
    DWORD dwSize;
    HRESULT hr;

    // if szHTTPAssoc doesn't exist then write path\iexplore.exe -nohome
    hr = RegCreateKeyEx(HKEY_CLASSES_ROOT, szHTTPAssoc, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyAssoc, &dRes);
    if(hr == ERROR_SUCCESS && REG_CREATED_NEW_KEY == dRes) 
    {
        // Get IE default location and append iexplore.exe -nohome 
        hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szIEAppPath, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE, &hKeyIEAppPath);
        if (hr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szValue);
            szValue[0]='\"';
            hr = RegQueryValueEx(hKeyIEAppPath, NULL, NULL, NULL, (LPBYTE)(szValue+1), &dwSize);
            if(hr == ERROR_SUCCESS)
            {
                lstrcat(szValue, szNoHome);
                dwSize = lstrlen(szValue) + 1;
                hr = RegSetValueEx(hKeyAssoc, NULL, NULL, REG_SZ, (LPBYTE)szValue, dwSize);
            }

            RegCloseKey(hKeyIEAppPath);
        }
    }

    if (hKeyAssoc)
        RegCloseKey(hKeyAssoc);
    
    return hr;
}

HRESULT IEAccessHTTPDisassociate()
{
    HKEY hKeyAssoc;
    TCHAR szValue[MAX_PATH];
    DWORD dwSize = sizeof(szValue);
    HRESULT hr;

    // Delete key szHTTPAssoc if it contains iexplore.exe
    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, szHTTPAssoc, 0, KEY_READ|KEY_WRITE, &hKeyAssoc);
    if (hr == ERROR_SUCCESS)
    {
        hr = RegQueryValueEx( hKeyAssoc, NULL, NULL, NULL, (LPBYTE)&szValue, &dwSize);
        if ( hr == ERROR_SUCCESS) 
        {
            _strlwr(szValue); //Convert string to lower case
            //Delete the reg key if it is IE
            if (strstr(szValue, "iexplore.exe"))
                hr = RegDeleteKey(HKEY_CLASSES_ROOT, szHTTPAssoc);
       } 
       RegCloseKey(hKeyAssoc);
   }
   return hr;
}

BOOL IsInstall()
{
    const TCHAR *szIsInstalled = TEXT("IsInstalled");
    BOOL bInstall = FALSE;
    DWORD dwValue, dwSize;
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyComponent, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        if (RegQueryValueEx( hKey, szIsInstalled, NULL, NULL, (LPBYTE)&dwValue, &dwSize) != ERROR_SUCCESS)
        {
            dwValue = 0;
        }
        bInstall = (dwValue != 0);

        RegCloseKey(hKey);
    }

    return bInstall;
}

typedef HWND (*PFNDLL)();
HRESULT RefreshDesktop()
{
// explorer\rcids.h and shell32\unicpp\resource.h have DIFFERENT
// VALUES FOR FCIDM_REFRESH!  We want the one in unicpp\resource.h
// because that's the correct one...
#define FCIDM_REFRESH_REAL 0x0a220

    PFNDLL pfnGetShellWindow = NULL;
    HMODULE hLib = NULL;
 
    if (hLib = LoadLibrary("user32.dll"))
    {
        pfnGetShellWindow = (PFNDLL) GetProcAddress (hLib,"GetShellWindow");

        if(pfnGetShellWindow) {
            PostMessage(pfnGetShellWindow(), WM_COMMAND, FCIDM_REFRESH_REAL, 0); // refresh desktop
        }

        FreeLibrary(hLib);
    }

    // Refresh start menu
    DWORD dwFlags = SMTO_ABORTIFHUNG;

    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM) szStartMenuInternet, dwFlags, 30*1000, NULL);

    return S_OK;
}

#define SFGAO_NONENUMERATED     0x00100000L     // is a non-enumerated object. Copied from public\sdk\inc\shobjidl.h

HRESULT IEAccessShowExplorerIcon(BOOL bShow)
{
    const TCHAR *szKeyComponent = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\{871C5380-42A0-1069-A2EA-08002B30309D}");
    const TCHAR *szShellFolder = TEXT("ShellFolder");
    const TCHAR *szAttribute = TEXT("Attributes");
    DWORD dwValue, dwSize, dwDisposition;
    HKEY hKeyComponent, hKeyShellFolder;
    HRESULT hResult = ERROR_SUCCESS;

    hResult = RegCreateKeyEx(HKEY_CURRENT_USER, szKeyComponent, NULL, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_CREATE_SUB_KEY, NULL, &hKeyComponent, &dwDisposition);

    if (hResult != ERROR_SUCCESS)
        return hResult;

    hResult = RegCreateKeyEx(hKeyComponent, szShellFolder, NULL, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKeyShellFolder, &dwDisposition);

    RegCloseKey(hKeyComponent);
    
    if (hResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        hResult = RegQueryValueEx( hKeyShellFolder, szAttribute, NULL, NULL, (LPBYTE)&dwValue, &dwSize);

        if (hResult != ERROR_SUCCESS)
            dwValue = 0;

        if (bShow)
            dwValue &= ~ SFGAO_NONENUMERATED;
        else
            dwValue |= SFGAO_NONENUMERATED;

        hResult = RegSetValueEx(hKeyShellFolder, szAttribute, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

        RegCloseKey(hKeyShellFolder);
    }

    return hResult;
}

HRESULT WINAPI IEAccessUserInst()
{
    HRESULT hResult = S_OK;

    if (!IsXPSP1OrLater())
    {
        BOOL bWinXP=IsWinXP();
        BOOL bInstall;
        DWORD dwValue;
        DWORD dwSize;
        EXECUTECAB pfExecuteCab;
        HMODULE hAdvPack = NULL;
        CABINFO CabInfo;
        char szInfFileName[MAX_PATH];
        HKEY hKey;
        
        memset(&CabInfo, 0, sizeof(CabInfo));

        GetSystemDirectory(szInfFileName, sizeof(szInfFileName));
        AddPath(szInfFileName, "ieuinit.inf");
        CabInfo.pszInf = szInfFileName;
        CabInfo.dwFlags = ALINF_QUIET;

        hAdvPack = LoadLibrary(szAdvPack);
        if (hAdvPack == NULL)
        {
            hResult = GetLastError();
            goto Cleanup;
        }

        pfExecuteCab = (EXECUTECAB)GetProcAddress(hAdvPack, szExecuteCab);
        if (pfExecuteCab == NULL)
        {
            hResult = GetLastError();
            goto Cleanup;
        }
        
        bInstall = IsInstall();
        
        if (bInstall)
        {
            //We don't call IEAccessAddStartMenuIcon on HKCU
            //Because if the user has anything there, we keep it.
            //If the user does not have his own default browser, shell defaults
            //to HKLM.

            if (bWinXP)
                CabInfo.pszSection = "IEAccess.Install.WinXP";
            else
                CabInfo.pszSection = "IEAccess.Install";
            hResult = pfExecuteCab(NULL, &CabInfo, NULL);
        }
        else
        {
            if (bWinXP)
            {
                IEAccessDelStartMenuIcon(HKEY_CURRENT_USER);
                CabInfo.pszSection = "IEAccess.Uninstall.WinXP";
            }
            else
                CabInfo.pszSection = "IEAccess.Uninstall";

            hResult = pfExecuteCab(NULL, &CabInfo, NULL);
        }

        IEAccessShowExplorerIcon(bInstall);
            
        RefreshDesktop();

    Cleanup:
        if (hAdvPack)
            FreeLibrary(hAdvPack);
    }
    return hResult;
}

//Copy data from HKLM to HKCU
HRESULT CopyRegValue(LPCTSTR szSubKey, LPCTSTR szValue)
{
    BYTE buffer[128];
    HKEY hKeyDst, hKeySrc;
    HRESULT hResult;
    DWORD dwSize = sizeof(buffer);
    
    hResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_QUERY_VALUE, &hKeySrc);
    if (FAILED(hResult))
        goto Cleanup;

    hResult = RegQueryValueEx(hKeySrc, szValue, NULL, NULL, (LPBYTE)buffer, &dwSize);
    if (FAILED(hResult))
        goto Cleanup;

    hResult = RegCreateKeyEx(HKEY_CURRENT_USER, szSubKey, 0, NULL, 
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyDst, NULL);
    if (FAILED(hResult))
        goto Cleanup;

    hResult = RegSetValueEx(hKeyDst, szValue, NULL, REG_SZ, (CONST BYTE *)buffer, dwSize);

Cleanup:
    if (hKeySrc)
        RegCloseKey(hKeySrc);
    
    if (hKeyDst)
        RegCloseKey(hKeyDst);

    return hResult;
}

BOOL IsNtSetupRunning()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"system\\Setup",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,
                (LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return true;
    }
    return false;
}

HRESULT WINAPI IEAccessSysInst(HWND, HINSTANCE, PSTR pszCmd, INT)
{
    if (!IsXPSP1OrLater())
    {
        BOOL bInstall;
        EXECUTECAB pfExecuteCab;
        HMODULE hAdvPack = NULL;
        CABINFO CabInfo;
        char szInfFileName[MAX_PATH];
        HRESULT hResult;
        
        memset(&CabInfo, 0, sizeof(CabInfo));
        BOOL bWinXP = IsWinXP();

        GetWindowsDirectory(szInfFileName, sizeof(szInfFileName));
        AddPath(szInfFileName, "inf\\ie.inf");
        
        CabInfo.pszInf = szInfFileName;
        CabInfo.dwFlags = ALINF_QUIET;

        hAdvPack = LoadLibrary(szAdvPack);
        if (hAdvPack == NULL)
        {
            hResult = GetLastError();
            goto Cleanup;
        }

        pfExecuteCab = (EXECUTECAB)GetProcAddress(hAdvPack, szExecuteCab);
        if (pfExecuteCab == NULL)
        {
            hResult = GetLastError();
            goto Cleanup;
        }

        bInstall = IsInstall();
        if (bInstall)
        {
            if (bWinXP)
            {
                IEAccessAddStartMenuIcon(HKEY_LOCAL_MACHINE);
                IEAccessHTTPAssociate();
                CabInfo.pszSection = "IEAccess.Install.WinXP";
            }
            else
                CabInfo.pszSection = "IEAccess.Install";
            
            hResult = pfExecuteCab(NULL, &CabInfo, NULL);
        }   
        else
        {
            if (bWinXP)
            {
                IEAccessDelStartMenuIcon(HKEY_LOCAL_MACHINE);
                IEAccessHTTPDisassociate();
                CabInfo.pszSection = "IEAccess.Uninstall.WinXP";
            }
            else
                CabInfo.pszSection = "IEAccess.Uninstall";
            
            hResult = pfExecuteCab(NULL, &CabInfo, NULL);
        }

        if (SUCCEEDED(hResult) && !IsNtSetupRunning())
        {
            IEAccessUserInst();

            //Update HKCU active setup components reg keys.
            const TCHAR *szLocale = "Locale";
            const TCHAR *szVersion = "Version";
            if (bInstall)
            {
                CopyRegValue(szKeyComponent, szLocale);
                CopyRegValue(szKeyComponent, szVersion);
            }
            else
                RegDeleteKey(HKEY_CURRENT_USER, szKeyComponent);
        }
    Cleanup:
        if (hAdvPack)
            FreeLibrary(hAdvPack);
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\autoobj.h ===
//=--------------------------------------------------------------------------=
// AutoObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown and dispatch
// implementations for them.
//
#ifndef _AUTOOBJ_H_

// all automation objects will use the Unknown object that supports aggegation.
//
#include "Unknown.H"

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"
#include "extobj.h"

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable
    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
    const IID   *riid;                           // object's type
    LPCSTR       pszHelpFile;                    // the helpfile for this automation object.
    ITypeInfo   *pTypeInfo;                      // typeinfo for this object
    UINT         cTypeInfo;                      // number of refs to the type info

} AUTOMATIONOBJECTINFO;

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.
//
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define INTERFACEOFOBJECT(index)       *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid)
#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile


#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, fn }, ver, riid, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
        return CAutomationObject::GetTypeInfoCount(pctinfo); \
    } \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
    } \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
    } \
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
    } \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
    } \

enum {EXPANDO_DISABLED=FALSE, EXPANDO_ENABLED=TRUE};

//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo
//
//
class CAutomationObject : public CUnknownObject {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT *);
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    //  ISupportErrorInfo methods
    //
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

    CAutomationObject(IUnknown *, int , void *, BOOL fExpandoEnabled=FALSE);
    virtual ~CAutomationObject();

    // callable functions -- things that most people will find useful.
    //
    virtual HINSTANCE GetResourceHandle(void);
    HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);

  protected:
    // member variables that derived objects might need to get at information in the
    // global object table
    //
    int   m_ObjectType;

  private:
    // member variables we don't share.
    //
    BYTE  m_fLoadedTypeInfo;
	BYTE  m_fExpandoEnabled;
	CExpandoObject* m_pexpando;
};


#define _AUTOOBJ_H_
#endif // _AUTOOBJ_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

// the library that we are
//
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// support for licensing
//
extern BOOL   g_fMachineHasLicense;
extern BOOL   g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
extern BOOL   g_fServerHasTypeLibrary;

//=--------------------------------------------------------------------------=
// our instance handle, and various pieces of information interesting to
// localization
//
extern HINSTANCE    g_hInstance;

extern const VARIANT_BOOL g_fSatelliteLocalization;
extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
extern HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
extern BOOL g_fSysWin95;                    // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;                    // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)

#define _GLOBALS_H_
#endif // _GLOBALS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\extobj.h ===
#ifndef __EXTOBJ_H
#define __EXTOBJ_H
////
//
// ExpandoObject header file
//
//
//
#include "IPServer.H"

////
//
// IDispatchEx
//
////

////
//
// the GUID
//

// {A0AAC450-A77B-11cf-91D0-00AA00C14A7C}
DEFINE_GUID(IID_IDispatchEx, 0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);

////
//
// IDispatchEx flags:
//

enum
{
	fdexNil = 0x00,				// empty
	fdexDontCreate = 0x01,		// don't create slot if non-existant otherwise do
	fdexInitNull = 0x02,		// init a new slot to VT_NULL as opposed to VT_EMPTY
	fdexCaseSensitive = 0x04,	// match names as case sensitive
};

////
//
// This is the interface for extensible IDispatch objects.
//

class IDispatchEx : public IDispatch
{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	) = 0;
};

////
//
// Globals and definitions
//
////

#define NUM_EXPANDO_DISPIDS		250
#define	NUM_CORE_DISPIDS		250
#define NUM_RESERVED_EXTENDER_DISPIDS (NUM_CORE_DISPIDS + NUM_EXPANDO_DISPIDS)
#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000))
#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) & 0xFFFF0000 ) == EXTENDER_DISPID_BASE )

////
//
// Slot: the state of a value slot
//

inline WCHAR ToUpper(WCHAR ch)
{
	if (ch>='a' && ch <= 'z')
		return ch - 'a' + 'A';
	else
		return ch;

}

class CExpandoObjectSlot
{
public:
	////
	//
	// Constructor/Destructor
	//

	// because these monsters are malloc'ed, we need a manual constructor and destructor methods
	void Construct()
	{
		m_name = NULL;
		m_next = -1;
		VariantInit(&m_value);
		// set hash and dispId to dummy values
		m_hash = 0;
		m_dispId = DISPID_UNKNOWN;
	}

	void Destruct()
	{
		if (m_name)
			SysFreeString(m_name);
		VariantClear(&m_value);
	}

private:
	// the constructors and destructors are private because they should never be called ...
	// we could use in-place construction if we wanted to be clever ...
	CExpandoObjectSlot()
	{
	}

	~CExpandoObjectSlot()
	{
	}

public:
	////
	//
	// Init the slot
	//

	HRESULT Init(LPOLESTR name, LCID lcid, DISPID dispId, VARIANT* value)
	{
		// allocate the string
		m_name = SysAllocString(name);
		if (m_name == NULL)
			return E_OUTOFMEMORY;

		// compute the hash: uses the standard OLE string hashing function
		// note that this function is case insensitive
		m_hash = LHashValOfName(lcid, name);

		// set the dispId
		m_dispId = dispId;

		// Copy the variant value
		return VariantCopy(&m_value, value);
	}

	////
	//
	// Name information
	//

	// get the name
	BSTR Name()
	{ return m_name; }

	// compare two names
	BOOL CompareName(LPOLESTR name, ULONG hash, BOOL caseSensitive)
	{
		unsigned int strLen;

		// hash should be the same, length should be the same, and strings should compare
		// BUGBUG robwell 8May96 These functions are probably verboten.
		if (hash != m_hash)
			return FALSE;

		if (!name)
			return !m_name;

		WCHAR *c1 = name;
		WCHAR *c2 = m_name;

		// Travel down both strings until we reach a mismatched character
		// or the end of one (or both) of the strings

		if (caseSensitive)
			while (*c1 && *c2 && *c1++==*c2++);
		else
			while (*c1 && *c2 && ToUpper(*c1++)==ToUpper(*c2++));

		// The strings match if we reached the end of both without a mismatch
		return !*c1 && !*c2;
 	}

	////
	//
	// DispId information
	//

	// get the dispatch id
	DISPID DispId()
	{ return m_dispId; }

	////
	//
	// Get and set the property values
	//

	HRESULT Get(VARIANT* result)
	{ return VariantCopy(result, &m_value); }

	HRESULT Set(VARIANT* value)
	{ return VariantCopy(&m_value, value); }

	////
	//
	// List management
	//

	CExpandoObjectSlot* Next(CExpandoObjectSlot* base)
	{ return m_next == -1? NULL: &base[m_next]; }

	CExpandoObjectSlot* Insert(CExpandoObjectSlot* base, LONG& prev)
	{
		m_next = prev;
		prev = (LONG)(this - base);
		return this;
	}

private:
	// the DispId
	DISPID		m_dispId;
	// the name
	LPOLESTR	m_name;
	// the name hash
	ULONG		m_hash;
	// the property value
	VARIANT		m_value;
	// the hash bucket link (index based)
	LONG		m_next;
};

// NB: CExpandoObject implements a crippled version of aggegation.
// It delegates all IUnknown calls to its controlling IUnknown, and has no
// private IUnknown interface.
// If you want the CExpandoObject to go away, simply call delete on it.
class CExpandoObject: public IDispatchEx
{
public:

	////
	//
	// Constructor/Destructor
	//

	CExpandoObject(IUnknown *punkOuter, IDispatch *pdisp, ULONG dispIdBase = EXTENDER_DISPID_BASE + NUM_CORE_DISPIDS)
	{
		// remember our controlling outer
		m_punkOuter = punkOuter;

		// remember the IDispatch to try first for IDispatch functionality
		m_pdisp = pdisp;
		
		// clear the name hash table
		ClearHashTable();
		// set the total slots and the table of slots to 0 and empty respectively)
		m_totalSlots = 0;
		m_slotTableSize = 0;
		m_slots = NULL;
		m_dispIdBase = dispIdBase;
	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return m_punkOuter->AddRef();
	}

	STDMETHODIMP_(ULONG)Release()
	{
		return m_punkOuter->Release();
	}

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObjOut)
	{
		return m_punkOuter->QueryInterface(riid, ppvObjOut);
	}

    virtual ~CExpandoObject(void)
	{
		FreeAllSlots();
	}


    // Copy all of the properties from obj
   	HRESULT CloneProperties(CExpandoObject& obj);

	////
	//
	//
	// Utility functions
	//

	// free all slots
	void FreeAllSlots();

	// IDispatch methods
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
		UINT itinfo,
		LCID lcid,
		ITypeInfo **pptinfo
	);
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgdispID
	);
	virtual HRESULT STDMETHODCALLTYPE Invoke(
		DISPID dispID,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pdispparams,
		VARIANT *pvarRes,
		EXCEPINFO *pexcepinfo,
		UINT *puArgErr
	);

	// IDispatchEx methods

	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	);

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	);

private:
	////
	//
	// Implementation constants
	//

	enum
	{
		kSlotHashTableSize = 10,
		kInitialSlotTableSize = 4,
		kMaxTotalSlots = NUM_EXPANDO_DISPIDS
	};

	////
	//
	// Utility functions
	//

	//
	CExpandoObjectSlot* GetHashTableHead(UINT hashIndex)
	{
		LONG index;

		return (index = m_hashTable[hashIndex]) == -1? NULL: &m_slots[index];
	}

	// get the ID of from a slot name
	HRESULT GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id);
	// add a slot to the object
	HRESULT AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id);
	// allocate a slot from the slot table
	CExpandoObjectSlot* AllocSlot();
	// clear the hash table
	void ClearHashTable()
	{
		UINT i;

		for (i=0; i<kSlotHashTableSize; ++i)
			m_hashTable[i] = -1;
	}

	////
	//
	// Slot operations
	//
	// DISPIDS start at kInitialDispId so we need to offset them by that amount
	// in this code.
	//

	HRESULT GetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Get(result);
	}

	HRESULT SetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Set(result);
	}

	////
	//
	// Iteration operations
	//

	UINT	NumDispIds()
	{ return m_totalSlots; }

	DISPID	First()
	{ return m_dispIdBase; }

	DISPID	Last()
	{ return m_totalSlots + m_dispIdBase - 1; }

	BOOL	ValidDispId(DISPID id)
	{ return id >= First() && id <= Last(); }

	HRESULT	Next(DISPID key, CExpandoObjectSlot*& slot)
	{
		// zero restarts the enumerator
		if (key == 0)
		{
			// if there are no slots we are done
			if (NumDispIds() == 0)
				return S_FALSE;

			// return the first slot
			slot = &m_slots[0];
			return NOERROR;
		}
		else
		if (key == Last())
		{
			// the key was the last slot so we are done
			return S_FALSE;
		}
		else
		if (ValidDispId(key))
		{
			// return the next slot
			slot = &m_slots[key-m_dispIdBase+1];
			return NOERROR;
		}
		else
			// the key must be invalid
			return E_INVALIDARG;
	}

	////
	//
	// The local state of the object
	//

	// the objects reference count
	ULONG	m_ref;

	// the base of objectIds
	ULONG	m_dispIdBase;

	// the hash table of slots - for fast GetIDSofNames lookup
	LONG	m_hashTable[kSlotHashTableSize];

	// the number of slots (and the next dispId to allocate)
	UINT	m_totalSlots;

	// the size of the allocated array of slots
	UINT	m_slotTableSize;

	// a pointer to the allocated array of slots
	CExpandoObjectSlot* m_slots;

	// controlling unknown
	IUnknown *m_punkOuter;

	// controlling IDispatch
	IDispatch *m_pdisp;
};

#endif // __EXTOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\internet.h ===
//=--------------------------------------------------------------------------=
// Internet.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the URLDib2 control.
//
#ifndef _INTERNET_H
#define _INTERNET_H

#define DISPID_PROGRESS 1958

#ifndef __MKTYPLIB__

#include "urlmon.H"
// ZZ BUGBUG: BUILD-ISSUE: changed from <ocidl.h> to this.
// ZZ Also removed datapath.h as all it had was myocidl.h and enum
// for the READYSTATE_ stuff.
//
#include "myocidl.h"
#include "docobj.h"   // for IServiceProvider

#include "IPServer.H"
#include "CtrlObj.H"



class CInternetControl : public COleControl
{
public:
	CInternetControl(IUnknown *     pUnkOuter, 
					int                     iPrimaryDispatch, 
					void *          pMainInterface);

	virtual ~CInternetControl();

    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

	// Call this method to start the download of a URL. 'propId' will 
	//      be passed back to you OnData below.
	HRESULT SetupDownload( LPOLESTR url, DISPID propId);


	//      Derived classes implement this method. It will be called when
	//      data has arrived for a given dispid.
	virtual HRESULT OnData( DISPID id, DWORD grfBSCF,
					IStream * bitstrm, DWORD amount );


	//      Derived classes can implement this method. It will be
	//      called at various times during the download.
	virtual HRESULT OnProgress( DISPID id, ULONG ulProgress,
					ULONG ulProgressMax,
					ULONG ulStatusCode,
					LPCWSTR pwzStatusText);

	//      Call this method to turn a URL into a Moniker.
	HRESULT GetAMoniker( LPOLESTR   url, IMoniker ** );


    HRESULT FireReadyStateChange( long newState );
	HRESULT FireProgress( ULONG dwAmount );


	// Override base class implementation...

    virtual HRESULT InternalQueryInterface(REFIID, void **);

protected:
	HRESULT GetBindHost();

    IBindHost *             m_host;
    long                    m_readyState;

    // BUGBUG: We should track all the downloads

};

#endif __MKTYPLIB__

#endif _INTERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\myocidl.h ===
// BUGBUG: Following is a hack to get around the re-definitions of these
// interfaces in ocidl.h
//
#define __IEnumConnections_INTERFACE_DEFINED__
#define __IOleControlTypes_INTERFACE_DEFINED__
#define __IConnectionPoint_INTERFACE_DEFINED__
#define __IEnumConnectionPoints_INTERFACE_DEFINED__
#define __IConnectionPointContainer_INTERFACE_DEFINED__
#define __IClassFactory2_INTERFACE_DEFINED__
#define __IProvideClassInfo_INTERFACE_DEFINED__
#define __IOleControl_INTERFACE_DEFINED__
#define __IProvideClassInfo2_INTERFACE_DEFINED__
#define __IOleControlSite_INTERFACE_DEFINED__
#define __IPropertyPage_INTERFACE_DEFINED__
#define __IPropertyPage2_INTERFACE_DEFINED__
#define __IPropertyPageSite_INTERFACE_DEFINED__
#define __IPropertyNotifySink_INTERFACE_DEFINED__
#define __ISpecifyPropertyPages_INTERFACE_DEFINED__
#define __IPersistMemory_INTERFACE_DEFINED__
#define __IPersistStreamInit_INTERFACE_DEFINED__
#define __IPersistPropertyBag_INTERFACE_DEFINED__
#define __ISimpleFrameSite_INTERFACE_DEFINED__
#define __IFont_INTERFACE_DEFINED__
#define __IPicture_INTERFACE_DEFINED__
#define __IFontDisp_INTERFACE_DEFINED__
#define __IPictureDisp_INTERFACE_DEFINED__
#define __IErrorLog_INTERFACE_DEFINED__
#define __IPropertyBag_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing_INTERFACE_DEFINED__

#include <ocidl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\ipserver.h ===
//=--------------------------------------------------------------------------=
// IPServer.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _IPSERVER_H_

//#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>

// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// controls can register for thread notifications in their InitializeLibrary()
//
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef void (CALLBACK *THRDNFYPROC)(HANDLE, DWORD, void *);
void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify);

#ifdef __cplusplus
}
#endif // __cplusplus
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=
//
//void * _cdecl operator new(size_t size);
//void  _cdecl operator delete(void *ptr);


//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define QUICK_RELEASE(ptr)     if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface
//
#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95                  0x9a4bbfb5
#define Data1_IControl                     0xa7fddba0
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataFrame                   0x97F254E0
#define Data1_IDataFrameExpert             0x73687490
#define Data1_IDataObject                  0x0000010e
#define Data1_IDispatch                    0x00020400
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoActions          0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IFormExpert                  0x5aac7f70
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMsoCommandTarget            0xb722bccb
#define Data1_IMsoDocument                 0xb722bcc5
#define Data1_IOleInPlaceComponent         0x5efc7970
#define Data1_IMsoView                     0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleCompoundUndoAction       0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoAction               0x894ad3b0
#define Data1_IOleUndoActionManager        0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideDynamicClassInfo     0x6d5140d1
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10


#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#include "extobj.h"


#define _IPSERVER_H_
#endif // _IPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\localsrv.h ===
//=--------------------------------------------------------------------------=
// LocalSrv.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1995 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...
//
#ifndef _LOCALSRV_H_

void      InitializeLibrary(void);
void      UninitializeLibrary(void);
BOOL      RegisterData(void);
BOOL      UnregisterData(void);
BOOL      CheckForLicense();
BOOL      CheckLicenseKey(LPWSTR wszCheckme);
BSTR      GetLicenseKey(void);

// global variables that various people use to get information about the control.
//
extern const char g_szLibName [];
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS         0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)      (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,      (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,      (void *)&(name##Control) }
#define PROPERTYPAGE(name)     { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT            { OI_BOGUS, NULL }

#define _LOCALSRV_H_
#endif // _LOCALSRV_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif


#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080

#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)


#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SNDMSG(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        SNDMSG(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\proppage.h ===
//=--------------------------------------------------------------------------=
// PropPage.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPPAGE_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject, public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

    HINSTANCE GetResourceHandle(void);            // returns current resource handle.

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    int      m_ObjectType;                        // what type of object we are
    UINT     m_cObjects;                          // how many objects we're holding on to

    void     m_ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  m_EnsureLoaded(void);                // forces the load of the page.

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    // default dialog proc for a page.
    //
    static BOOL CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual BOOL DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPPAGE_H_
#endif // _PROPPAGE_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\stdenum.h ===
//=--------------------------------------------------------------------------=
// StdEnum.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STDENUM_H_

#include "Unknown.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STDENUM_H_
#endif // _STDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\unknown.h ===
//=--------------------------------------------------------------------------=
// Unknown.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// a class definition for an IUnknown super-class that will support
// aggregation.
//
#ifndef _UNKNOWN_H_

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...
//
typedef struct {

    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable!
    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable!
    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable!

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, fn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
        return ExternalQueryInterface(riid, ppvObjOut); \
    } \
    STDMETHOD_(ULONG, AddRef)(void) { \
        return ExternalAddRef(); \
    } \
    STDMETHOD_(ULONG, Release)(void) { \
        return ExternalRelease(); \
    } \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp
//
extern LONG g_cLocks;



//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.
//
class CUnknownObject {

  public:
    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
        : m_pvInterface(pvInterface),
          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
        {  InterlockedIncrement(&g_cLocks); }

    virtual ~CUnknownObject() { InterlockedDecrement(&g_cLocks); }

    // these are all protected so that classes that inherit from this can
    // at get at them.
    //
  protected:
    // IUnknown methods.  these just delegate to the controlling
    // unknown.
    //
    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
        return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
    }
    ULONG ExternalAddRef(void) {
        return m_pUnkOuter->AddRef();
    }
    ULONG ExternalRelease(void) {
        return m_pUnkOuter->Release();
    }

    // people should use this during creation to return their private
    // unknown
    //
    inline IUnknown *PrivateUnknown (void) {
        return &m_UnkPrivate;
    }

    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IUnknown *m_pUnkOuter;            // outer controlling Unknown
    void     *m_pvInterface;          // the real interface we're working with.

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object, and for those cases where
    // this object isn't aggregated.
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(1) {}

      private:
        CUnknownObject *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    // so they can reference themselves in CUnknownObject from pMainUnknown()
    //
    friend class CPrivateUnknownObject;

    // by overriding this, people inheriting from this unknown can implement
    // additional interfaces.  declared as private here so they have to use their
    // own version.
    //
};




#define _UNKNOWN_H_
#endif // _UNKNOWN_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\strcoll.h ===
//=--------------------------------------------------------------------------=
// StrColl.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRCOLL_H_
#endif // _STRCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "Globals.H"


//=--------------------------------------------------------------------------=
// Misc Helper Routines
//=--------------------------------------------------------------------------=
//
HWND      GetParkingWindow(void);
HINSTANCE GetResourceHandle(void);

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);


//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegSetMultipleValues(HKEY hkey, ...);
BOOL RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject);
BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject);
BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId);
BOOL UnregisterUnknownObject(REFCLSID riidObject);
BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
#define UnregisterControlObject UnregisterAutomationObject
BOOL UnregisterTypeLibrary(REFCLSID riidLibrary);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey);


//=--------------------------------------------------------------------------=
// conversion helpers.
//
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);


#define _UTIL_H_
#endif // _UTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\ciffile.h ===
#include <wininet.h>
#include "cifcomp.h"
#include "cifmode.h"
#include "cifgroup.h"
#include "enum.h"

class CInstallEngine;


class CCifFile : public ICifFile
{
   public:
      CCifFile();
      ~CCifFile();

      HRESULT Download();
      HRESULT Install(BOOL *pfOneInstalled);
      void    SortEntries();     // sort the arrays
      void    ReinsertComponent(CCifComponent *pComp);


      HRESULT DownloadCifFile(LPCSTR pszUrl, LPCSTR pszCif);
      HRESULT SetCifFile(LPCSTR pszCifPath, BOOL bRWFlag);
      void    MarkCriticalComponents(CCifComponent *);
      void    RemoveFromCriticalComponents(CCifComponent *);
      LPCSTR  GetCifPath()     { return _szCifPath; }
      LPCSTR  GetDownloadDir() { return _szDLDir; }
      LPCSTR  GetFilelist()    { return _szFilelist; }
      void    SetDownloadDir(LPCSTR pszDir);
      void    SetInstallEngine(CInstallEngine *p)  {  _pInsEng = p; }
      BOOL    CanCancel()      { return ( _pLastCriticalComp == NULL); }
      void    ClearQueueState();
      CInstallEngine *GetInstallEngine()  { return _pInsEng; }
      CCifComponent **GetComponentList() { return _rpComp ? _rpComp:(CCifComponent **)_rpRWComp; }

      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();
 
      // *** ICifFile methods ***
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindComponent)(LPCSTR pszID, ICifComponent **p);

      STDMETHOD(EnumGroups)(IEnumCifGroups **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindGroup)(LPCSTR pszID, ICifGroup **p);

      STDMETHOD(EnumModes)(IEnumCifModes **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindMode)(LPCSTR pszID, ICifMode **p);

      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);  
      STDMETHOD(GetDetDlls)(LPSTR pszDlls, DWORD dwSize);

   protected:
      // private data
      UINT            _cRef;                 // ref count
      char            _szCifPath[MAX_PATH];  // local path to cif
      char            _szFilelist[MAX_PATH]; // filelist.dat
      char            _szDLDir[MAX_PATH];    // download directory
      CInstallEngine  *_pInsEng;
      CCifComponent **_rpComp;               // array of components
      CCifGroup     **_rpGroup;              // array of groups
      CCifMode      **_rpMode;               // array of modes
      UINT            _cComp;
      UINT            _cGroup;
      UINT            _cMode;
      CCifComponent   *_pLastCriticalComp;

      // for read write arrays
      CCifRWComponent **_rpRWComp;               // array of components
      CCifRWGroup     **_rpRWGroup;              // array of groups
      CCifRWMode      **_rpRWMode;               // array of modes
      
      BOOL            _fCleanDir:1;

      // private methods
      HRESULT         _ParseCifFile(BOOL bRWFlag);       // parse cif into arrays
      void            _SortComponents(CCifComponent **, UINT start, UINT finish);
      void            _SortGroups(CCifGroup **, UINT start, UINT finish);
      HRESULT         _ExtractDetDlls(LPCSTR pszCab, LPCSTR pszPath);
      HRESULT         _CopyDetDlls(LPCSTR pszPath);
      HRESULT         _FindCifComponent(LPCSTR pszID, CCifComponent **p);
      void            _CheckDependencyPriority();

};


class CCifRWFile : public ICifRWFile, public CCifFile
{
   public:
      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();
 
      // *** ICifFile methods ***
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindComponent)(LPCSTR pszID, ICifComponent **p);

      STDMETHOD(EnumGroups)(IEnumCifGroups **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindGroup)(LPCSTR pszID, ICifGroup **p);

      STDMETHOD(EnumModes)(IEnumCifModes **, DWORD dwFilter, LPVOID pv);
      STDMETHOD(FindMode)(LPCSTR pszID, ICifMode **p);

      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);      
      STDMETHOD(GetDetDlls)(LPSTR pszDlls, DWORD dwSize);

      // 
      CCifRWFile();
      ~CCifRWFile();

      // ICifRWFile methods
      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(CreateComponent)(THIS_ LPCSTR pszID, ICifRWComponent **p);
      STDMETHOD(CreateGroup)(THIS_ LPCSTR pszID, ICifRWGroup **p);
      STDMETHOD(CreateMode)(THIS_ LPCSTR pszID, ICifRWMode **p);
      STDMETHOD(DeleteComponent)(THIS_ LPCSTR pszID);
      STDMETHOD(DeleteGroup)(THIS_ LPCSTR pszID);
      STDMETHOD(DeleteMode)(THIS_ LPCSTR pszID);
      STDMETHOD(Flush)();

   private:
      UINT _cCompUnused;
      UINT _cGroupUnused;
      UINT _cModeUnused;
};


typedef struct _SetCifArgs
{
   char szUrl[INTERNET_MAX_URL_LENGTH];
   char szCif[MAX_PATH];
   CCifFile *pCif;
} SETCIFARGS;


DWORD WINAPI DownloadCifFile(LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\cifcomp.h ===
// Keys in cif file
#include "download.h"

#define URL_KEY             "URL"
#define GUID_KEY            "GUID"
#define ARGS_KEY            "Switches"
#define CMD_KEY             "Command"
#define SIZE_KEY            "Size"
#define INSTALLSIZE_KEY     "InstalledSize"
#define DISPLAYNAME_KEY     "DisplayName"
#define VERSION_KEY         "Version"
#define QFE_VERSION_KEY     "QFEVersion"
#define TYPE_KEY            "Type"
#define UNINSTALL_KEY       "Uninstall"
#define DEPENDENCY_KEY      "Dependencies"
#define UNINSTALLSTRING_KEY "UninstallKey"
#define SUCCESS_KEY         "SuccessKey"
#define REBOOT_KEY          "Reboot"
#define ADMIN_KEY           "AdminCheck"
#define LOCALE_KEY          "Locale"
#define MUTEX_KEY           "CancelMutex"
#define ISINSTALLED_KEY     "IsInstalled"
#define ACTSETUPAWARE_KEY   "ActiveSetupAware"
#define PRIORITY            "Priority"
#define PROGRESS_KEY        "ProgressKey"
#define COMPID_KEY          "ComponentID"
#define STUBPATH_KEY        "StubPath"
#define PARENTID_KEY        "ParentID"
#define PATCHID_KEY         "PatchID"
#define APPLIESTO_KEY       "AppliesTo"
#define MINFILESIZE_KEY     "MinFileSize"
#define URLSIZE_KEY         "Size"
#define DETAILS_KEY         "Details"
#define MODES_KEY           "Modes"
#define UIVISIBLE_KEY       "UIVisible"
#define PLATFORM_KEY        "Platform"
#define GROUP_KEY           "Group"
#define ENTRYTYPE_KEY       "SectionType"
#define DETVERSION_KEY      "DetectVersion"
#define TREATAS_KEY         "TreatAsOne"
#define BUDDY_KEY           "Buddies"

#define DETDLLS_KEY         "DetectDlls"

#define ENTRYTYPE_COMP      "Component"
#define ENTRYTYPE_GROUP     "Group"
#define ENTRYTYPE_MODE      "Mode"


#define REGSTR_PROGRESS_KEY "Software\\Microsoft\\Active Setup\\Component Progress\\"
#define COMPONENT_KEY "Software\\Microsoft\\Active Setup\\Installed Components"
#define ACTIVESETUP_KEY "Software\\Microsoft\\Active Setup"
#define COMPONENTBLOCK_KEY "Software\\Microsoft\\Active Setup\\Component Block"

#define CANCEL_VALUENAME     "Cancel"
#define SAFE_VALUENAME       "Safe"
#define PROGRESS_DISPLAY     "DisplayString"

#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'
#define DEP_BUDDY           'B'

#define DEFAULT_LOCALE    "en"

#define ISINSTALLED_YES      1
#define ISINSTALLED_NO       0

// Default command type
#define CMDF_DEFAULT        0


#define STR_WIN95     "win95"
#define STR_WIN98     "win98"
#define STR_NT4       "nt4"
#define STR_NT5       "nt5"
#define STR_NT4ALPHA  "nt4alpha"
#define STR_NT5ALPHA  "nt5alpha"
#define STR_MILLEN    "millen"

#define SETACTION_DEPENDENCYINSTALL  0x00010000
#define SETACTION_DEPENDENCYNONE     0x00020000

#define BUFFERSIZE 4096

class CCifFile;

class CCifEntry 
{
   public:
      BOOL    IsID(LPCSTR pszID)  { return (lstrcmpi(_szID, pszID) == 0); }
      virtual void  ClearCachedInfo()  { _uPriority = 0xffffffff; }
  
      
   protected:
      CCifEntry(LPCSTR pszID, CCifFile *pCif) { lstrcpyn(_szID, pszID, sizeof(_szID)); _pCif = pCif; _uPriority = 0xffffffff; }
      ~CCifEntry() {}
      
      CCifFile   *_pCif;
      char        _szID[MAX_ID_LENGTH];
      UINT        _uPriority;
};

class CCifComponent : public ICifComponent, public CCifEntry, public IMyDownloadCallback
{
   public:
      CCifComponent(LPCSTR pszID, CCifFile *pCif);
      ~CCifComponent();

      HRESULT Download();
      HRESULT Install();
      void    ClearQueueState()  { _uInstallCount = 0; }
      void    ClearCachedInfo()  { CCifEntry::ClearCachedInfo(); _dwPlatform = 0xffffffff; _uInstallStatus = 0xffffffff; }
      
      // IMyDownloadCallback
      HRESULT OnProgress(ULONG progress, LPCSTR pszStatus);
      

      // ICifComponent interface
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetGUID)(LPSTR pszGUID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(LPSTR pszDetails, DWORD dwSize);
      STDMETHOD(GetUrl)(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags);
      STDMETHOD(GetFileExtractList)(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize);
      STDMETHOD(GetUrlCheckRange)(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax);
      STDMETHOD(GetCommand)(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
         DWORD dwSwitchSize, LPDWORD pdwType);
      STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD(GetLocale)(LPSTR pszLocale, DWORD dwSize);
      STDMETHOD(GetUninstallKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetInstalledSize)(LPDWORD pdwWin, LPDWORD pdwApp);
      STDMETHOD_(DWORD, GetDownloadSize)();
      STDMETHOD_(DWORD, GetExtractSize)();
      STDMETHOD(GetSuccessKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetProgressKeys)(LPSTR pszProgress, DWORD dwProgSize, 
         LPSTR pszCancel, DWORD dwCancelSize);
      STDMETHOD(IsActiveSetupAware)();
      STDMETHOD(IsRebootRequired)();
      STDMETHOD(RequiresAdminRights)();
      STDMETHOD_(DWORD, GetPriority)();
      STDMETHOD(GetDependency)(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetPlatform)();
      STDMETHODIMP_(BOOL) DisableComponent();
      STDMETHOD(GetMode)(UINT uModeNum, LPSTR pszModes, DWORD dwSize);
      STDMETHOD(GetGroup)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(IsUIVisible)();
      STDMETHOD(GetPatchID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDetVersion)(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize);
      STDMETHOD(GetTreatAsOneComponents)(UINT uNum, LPSTR pszID, DWORD dwBuf);
      STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize);


      // access to state
      STDMETHOD_(DWORD, IsComponentInstalled)();
      STDMETHOD(IsComponentDownloaded)();
      STDMETHOD_(DWORD, IsThisVersionInstalled)(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetInstallQueueState)();
      STDMETHOD(SetInstallQueueState)(DWORD dwState);
      STDMETHOD_(DWORD, GetActualDownloadSize)();
      STDMETHOD_(DWORD, GetCurrentPriority)();
      STDMETHOD(SetCurrentPriority)(DWORD dwPriority);


   protected:
      static char _szDetDllName[MAX_PATH];
      static HINSTANCE _hDetLib;
      char _szDesc[MAX_DISPLAYNAME_LENGTH];
      char _szDLDir[MAX_PATH];
      UINT _dwPlatform;
      UINT _uInstallStatus;
      UINT _uInstallCount;    // refcount of dependendant installs, 0x80000000 if directly installed
      UINT _uTotalProgress;
      UINT _uIndivProgress;
      UINT _uTotalGoal;
      UINT _uPhase;
      BOOL _fDependenciesQueued:1;
      BOOL _fUseSRLite:1;
      BOOL _fBeforeInstall:1;
  
      HRESULT _DownloadUrl(UINT uUrlNum, LPCSTR pszUrl, UINT dwType);
      BOOL    _FileIsDownloaded(LPCSTR pszFile, UINT i, DWORD *pdwSize);
      BOOL    _CompareDownloadInfo();
      void    _MarkAsInstalled();
      void    _MarkDownloadStarted();
      void    _MarkFileDownloadStarted(UINT i);
      void    _MarkFileDownloadFinished(LPCSTR pszFilePath, UINT i, LPCSTR pszFilename);
      HRESULT _CheckForTrust(LPCSTR pszURL, LPCSTR pszFilename);
      HRESULT _CopyAllUrls(LPCSTR pszTemp);
      void    _MarkComponentInstallStarted();
      HRESULT _RunAllCommands(LPCSTR psDir, DWORD *pdwStatus);
      HRESULT _ExtractFiles(UINT i, LPCSTR pszFile, DWORD dwType);
      HRESULT _CheckForDependencies(); 
      HRESULT _GetDetVerResult(LPCSTR pszDll, LPCSTR pszEntry, DETECTION_STRUCT *pDet, UINT *uStatus);
      HRESULT _SRLiteDownloadFiles();
      LPCSTR  GetDownloadDir() { return _szDLDir; }
      void    SetDownloadDir(LPCSTR pszDownloadDir);
};    

class CCifRWComponent : public ICifRWComponent, public CCifComponent
{
   public:
      // ICifComponent interface
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetGUID)(LPSTR pszGUID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(LPSTR pszDetails, DWORD dwSize);
      STDMETHOD(GetUrl)(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags);
      STDMETHOD(GetFileExtractList)(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize);
      STDMETHOD(GetUrlCheckRange)(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax);
      STDMETHOD(GetCommand)(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                            DWORD dwSwitchSize, LPDWORD pdwType);
      STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD(GetLocale)(LPSTR pszLocale, DWORD dwSize);
      STDMETHOD(GetUninstallKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetInstalledSize)(LPDWORD pdwWin, LPDWORD pdwApp);
      STDMETHOD_(DWORD, GetDownloadSize)();
      STDMETHOD_(DWORD, GetExtractSize)();
      STDMETHOD(GetSuccessKey)(LPSTR pszKey, DWORD dwSize);
      STDMETHOD(GetProgressKeys)(LPSTR pszProgress, DWORD dwProgSize, 
                                 LPSTR pszCancel, DWORD dwCancelSize);
      STDMETHOD(IsActiveSetupAware)();
      STDMETHOD(IsRebootRequired)();
      STDMETHOD(RequiresAdminRights)();
      STDMETHOD_(DWORD, GetPriority)();
      STDMETHOD(GetDependency)(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetPlatform)();
      STDMETHOD(GetMode)(UINT uModeNum, LPSTR pszModes, DWORD dwSize);
      STDMETHOD(GetGroup)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(IsUIVisible)();
      STDMETHOD(GetPatchID)(LPSTR pszID, DWORD dwSize);      
      STDMETHOD(GetDetVersion)(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize);
      STDMETHOD(GetTreatAsOneComponents)(UINT uNum, LPSTR pszID, DWORD dwBuf);
      STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize);

      // access to state
      STDMETHOD_(DWORD, IsComponentInstalled)();
      STDMETHOD(IsComponentDownloaded)();
      STDMETHOD_(DWORD, IsThisVersionInstalled)(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild);
      STDMETHOD_(DWORD, GetInstallQueueState)();
      STDMETHOD(SetInstallQueueState)(DWORD dwState);
      STDMETHOD_(DWORD, GetActualDownloadSize)();
      STDMETHOD_(DWORD, GetCurrentPriority)();
      STDMETHOD(SetCurrentPriority)(DWORD dwPriority);

      // ICifRWComponent interface
      CCifRWComponent(LPCSTR pszID, CCifFile *pCif);
      ~CCifRWComponent();

      STDMETHOD(SetGUID)(THIS_ LPCSTR pszGUID);
      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(SetCommand)(THIS_ UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType);
      STDMETHOD(SetVersion)(THIS_ LPCSTR pszVersion);
      STDMETHOD(SetUninstallKey)(THIS_ LPCSTR pszKey);
      STDMETHOD(SetInstalledSize)(THIS_ DWORD dwWin, DWORD dwApp);
      STDMETHOD(SetDownloadSize)(THIS_ DWORD);
      STDMETHOD(SetExtractSize)(THIS_ DWORD);
      STDMETHOD(DeleteDependency)(THIS_ LPCSTR pszID, char chType);
      STDMETHOD(AddDependency)(THIS_ LPCSTR pszID, char chType);
      STDMETHOD(SetUIVisible)(THIS_ BOOL);
      STDMETHOD(SetGroup)(THIS_ LPCSTR pszID);
      STDMETHOD(SetPlatform)(THIS_ DWORD);
      STDMETHOD(SetPriority)(THIS_ DWORD);
      STDMETHOD(SetReboot)(THIS_ BOOL);
      STDMETHOD(SetUrl)(THIS_ UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags);   

      STDMETHOD(DeleteFromModes)(THIS_ LPCSTR pszMode);
      STDMETHOD(AddToMode)(THIS_ LPCSTR pszMode);
      STDMETHOD(SetModes)(THIS_ LPCSTR pszMode);
      STDMETHOD(CopyComponent)(THIS_ LPCSTR pszCifFile);
      STDMETHOD(AddToTreatAsOne)(THIS_ LPCSTR pszCompID);
      STDMETHOD(SetDetails)(THIS_ LPCSTR pszDesc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\ciffile.cpp ===
#include "inspch.h"
#include <regstr.h>
#include "resource.h"
#include "insobj.h"


#define STR_FILELIST "filelist.dat"
#define GENERAL_SECTION "General"
#define MIN_SUPPORTED_FILELIST_VER 1
#define CURRENT_FILELIST_VER "1"

HRESULT GetICifFileFromFile(ICifFile **p, LPCSTR pszPath)
{
   HRESULT hr;
   CCifFile *pcif;

   *p = 0;
   pcif = new CCifFile();
   if(pcif)
   {
      hr = pcif->SetCifFile(pszPath, FALSE); // FALSE: Read version
      if(FAILED(hr))
         delete pcif;
      else
      {
         pcif->AddRef();
         *p = (ICifFile *)pcif;
      }
   }   
   else
      hr = E_OUTOFMEMORY;

   return hr;
}

HRESULT GetICifRWFileFromFile(ICifRWFile **p, LPCSTR pszPath)
{
   HRESULT hr;
   CCifRWFile *pcifrw;

   *p = 0;
   pcifrw = new CCifRWFile();
   if(pcifrw)
   {
      hr = pcifrw->SetCifFile(pszPath, TRUE);  // TRUE: ReadWrite version
      if(FAILED(hr))
         delete pcifrw;
      else
      {
         pcifrw->AddRef();
         *p = (ICifRWFile *)pcifrw;
      }
   }   
   else
      hr = E_OUTOFMEMORY;

   return hr;
}


CCifFile::CCifFile()
{
   _cRef = 0;
   _cComp = 0;
   _cGroup = 0;
   _cMode = 0;
   _rpGroup = 0;
   _rpComp = 0;
   _rpMode = 0;
   _rpRWGroup = 0;
   _rpRWComp = 0;
   _rpRWMode = 0;   
   _fCleanDir = FALSE;
   _pLastCriticalComp = NULL;
}

CCifFile::~CCifFile()
{
   UINT i;
   if(_rpGroup)
   {
      CCifGroup *pgrp;

      i = 0;
      for(pgrp = _rpGroup[i]; pgrp != 0; pgrp = _rpGroup[++i])
         delete pgrp;
   
      free(_rpGroup);
   }
   
   
   if(_rpComp)
   {
      CCifComponent *pcomp;

      i = 0;
      for(pcomp = _rpComp[i]; pcomp != 0; pcomp = _rpComp[++i])
          delete pcomp;
   
      free(_rpComp);
   }

   if(_rpMode)
   {

      CCifMode *pmode;

      i = 0;
      for(pmode = _rpMode[i]; pmode != 0; pmode = _rpMode[++i])
         delete pmode;
   
      free(_rpMode);
   }

   if(_fCleanDir)
   {
      GetParentDir(_szCifPath);
      CleanUpTempDir(_szCifPath);
   }

}

//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifFile::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifFile::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifFile::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = 0;

   if((riid == IID_IUnknown) || (riid == IID_ICifFile))
      *ppv = (ICifFile *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

// ICifFile implementation

STDMETHODIMP CCifFile::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum(_rpComp, dwFilter, PARENTTYPE_CIF, NULL);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}
 
STDMETHODIMP CCifFile::FindComponent(LPCSTR pszID, ICifComponent **p)
{
   CCifComponent *pcomp;
   UINT i = 0;
   
   *p = 0;
   if(_rpComp)
   {
      for(pcomp = _rpComp[i]; pcomp != 0; pcomp = _rpComp[++i])
         if(pcomp->IsID(pszID))
         {
            *p = (ICifComponent *) pcomp;
            return NOERROR;
         }
   }

   return E_FAIL;
}

STDMETHODIMP CCifFile::EnumGroups(IEnumCifGroups **pp, DWORD dwFilter, LPVOID pv)
{
   CCifGroupEnum *pge;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pge = new CCifGroupEnum(_rpGroup, dwFilter);
   if(pge)
   {
      *pp = (IEnumCifGroups *) pge;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifFile::FindGroup(LPCSTR pszID, ICifGroup **p)
{
   CCifGroup *pgrp;
   UINT i = 0;
   
   *p = 0;
   if(_rpGroup)
   {
      for(pgrp = _rpGroup[i]; pgrp != 0; pgrp = _rpGroup[++i])
         if(pgrp->IsID(pszID))
         {
            *p = (ICifGroup *) pgrp;
            return NOERROR;
         }
   }
   return E_FAIL;

}

STDMETHODIMP CCifFile::EnumModes(IEnumCifModes **pp, DWORD dwFilter, LPVOID pv)
{
   CCifModeEnum *pme;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pme = new CCifModeEnum(_rpMode, dwFilter);
   if(pme)
   {
      *pp = (IEnumCifModes *) pme;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;

}

STDMETHODIMP CCifFile::FindMode(LPCSTR pszID, ICifMode **p)
{
   CCifMode *pmode;
   UINT i = 0;
   
   *p = 0;
   if(_rpMode)
   {
      for(pmode = _rpMode[i]; pmode != 0; pmode = _rpMode[++i])
         if(pmode->IsID(pszID))
         {
            *p = (ICifMode *) pmode;
            return NOERROR;
         }
   }
   return E_FAIL;
}

STDMETHODIMP CCifFile::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   // Get display title out of version section
   if(FAILED(MyTranslateString(_szCifPath, "Version", DISPLAYNAME_KEY, pszDesc, dwSize)))
      LoadSz(IDS_DEFAULTTITLE, pszDesc, dwSize);
   return NOERROR;
}

STDMETHODIMP CCifFile::GetDetDlls(LPSTR pszDlls, DWORD dwSize)
{
   return(GetPrivateProfileString("Version", DETDLLS_KEY, "", pszDlls, dwSize, _szCifPath)?NOERROR:E_FAIL);
}

//const char c_gszRegstrPathIExplore[] = REGSTR_PATH_APPPATHS "\\iexplore.exe";

HRESULT CCifFile::SetCifFile(LPCSTR pszCifPath, BOOL bRWFlag)
{
   HRESULT hr = NOERROR;
   UINT i;

   // if it is not quallified, start from ie
   if(PathIsFileSpec(pszCifPath))
   {
      DWORD dwSize, dwType;
      char szTmp[MAX_PATH];

      if ( SUCCEEDED(hr=GetIEPath(szTmp, sizeof(szTmp))))
      {
         lstrcpy(_szCifPath, szTmp);
         SafeAddPath(_szCifPath, pszCifPath, sizeof(_szCifPath));
      }
   }
   else   // we were given a full path
      lstrcpyn(_szCifPath, pszCifPath, MAX_PATH);
   
   if(SUCCEEDED(hr))
   {
      if(_rpComp)
      {
         // we already have a cif, so just reset cached stuff, and pray...
         for(i = 0; i < _cComp; i++)
         {
            _rpComp[i]->ClearCachedInfo();            
         }
         for(i = 0; i < _cGroup; i++)
         {
            _rpGroup[i]->ClearCachedInfo();
         }
         for(i = 0; i < _cMode; i++)
         {
            _rpMode[i]->ClearCachedInfo();
         }
         
         // Sort all again, in case priorities changed
         SortEntries();
      }
      else
         hr = _ParseCifFile(bRWFlag);
   }

   return(hr);
}

HRESULT CCifFile::_ParseCifFile(BOOL bRWFlag)
{
   LPSTR pszSections;
   LPSTR pszSectionsPreFail = NULL;
   DWORD dwSize = ALLOC_CHUNK_SIZE;
   LPSTR pszTemp;
   char szEntryBuf[MAX_DISPLAYNAME_LENGTH];
   
   pszSections = (LPSTR) malloc(dwSize);
   // when the buffer is too small, GPPS returns bufsize - 2
   while(pszSections && 
        (GetPrivateProfileStringA(NULL, NULL, "", pszSections, dwSize, _szCifPath) == (dwSize - 2)))
   {
      dwSize += ALLOC_CHUNK_SIZE;
      pszSectionsPreFail = pszSections;
//#pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
      pszSections = (LPSTR) realloc(pszSections, dwSize);
   }

   if(!pszSections)
   {
      if(pszSectionsPreFail)
         free(pszSectionsPreFail);
      return E_OUTOFMEMORY;
   }

   if(lstrlen(pszSections) == 0)
      return E_FAIL;

   // whip thru the sections, and find counts for modes, groups, and components
   _cComp = _cGroup = _cMode = 0;

   for(pszTemp = pszSections; *pszTemp != 0; pszTemp += (lstrlen(pszTemp) + 1))
   {
      // skip String section and Version section
      if( (lstrcmpi(pszTemp, "Strings") != 0)
              && (lstrcmpi(pszTemp, "Version") != 0) )
      {
         GetPrivateProfileString(pszTemp, ENTRYTYPE_KEY, ENTRYTYPE_COMP, szEntryBuf, sizeof(szEntryBuf), _szCifPath);
         // see if this is a comp, group, or mode
         if(lstrcmpi(szEntryBuf, ENTRYTYPE_COMP) == 0)
            _cComp++;
         else if(lstrcmpi(szEntryBuf, ENTRYTYPE_GROUP) == 0)
            _cGroup++;
         else if(lstrcmpi(szEntryBuf, ENTRYTYPE_MODE) == 0)
            _cMode++;
      }
   }

   // alloc arrays to hold each type (1 more than count - last entry null)
   if (bRWFlag)
   {
      _rpRWComp  = (CCifRWComponent **) calloc(sizeof(CCifRWComponent *), _cComp + 1);
      _rpRWGroup = (CCifRWGroup **) calloc(sizeof(CCifRWGroup *), _cGroup + 1);
      _rpRWMode  = (CCifRWMode **) calloc(sizeof(CCifRWMode *), _cMode + 1);
   }
   else
   {
      _rpComp  = (CCifComponent **) calloc(sizeof(CCifComponent *), _cComp + 1);
      _rpGroup = (CCifGroup **) calloc(sizeof(CCifGroup *), _cGroup + 1);
      _rpMode  = (CCifMode **) calloc(sizeof(CCifMode *), _cMode + 1);
   }
   _cComp = _cGroup = _cMode = 0;

   if((!bRWFlag && _rpComp && _rpGroup && _rpMode) || (bRWFlag && _rpRWComp && _rpRWGroup && _rpRWMode))
   {   
      // pass thru sections again, adding to lists
      for(pszTemp = pszSections; *pszTemp != 0; pszTemp += (lstrlen(pszTemp) + 1))
      {
         // skip String section and Version section
         if( (lstrcmpi(pszTemp, "Strings") != 0)
            && (lstrcmpi(pszTemp, "Version") != 0) )
         {
            GetPrivateProfileString(pszTemp, ENTRYTYPE_KEY, ENTRYTYPE_COMP, szEntryBuf, sizeof(szEntryBuf), _szCifPath);
            // see if this is a comp, group, or mode
            if(lstrcmpi(szEntryBuf, ENTRYTYPE_COMP) == 0)
            {
               if (bRWFlag)
                  _rpRWComp[_cComp++] = new CCifRWComponent(pszTemp, this);
               else
                  _rpComp[_cComp++] = new CCifComponent(pszTemp, this);
            }
            else if(lstrcmpi(szEntryBuf, ENTRYTYPE_GROUP) == 0)
            {
               if (bRWFlag)
                  _rpRWGroup[_cGroup++] = new CCifRWGroup(pszTemp, _cGroup, this);
               else
                  _rpGroup[_cGroup++] = new CCifGroup(pszTemp, _cGroup, this);
            }
            else if(lstrcmpi(szEntryBuf, ENTRYTYPE_MODE) == 0)
            {
               if (bRWFlag)
                  _rpRWMode[_cMode++] = new CCifRWMode(pszTemp, this);
               else
                  _rpMode[_cMode++] = new CCifMode(pszTemp, this);
            }
         }
      }
   }
   if(_cComp) _cComp--;
   if(_cGroup) _cGroup--;
   if(_cMode)  _cMode--;


   if (!bRWFlag)
      SortEntries();
   free(pszSections);
   return NOERROR;
}

void CCifFile::ReinsertComponent(CCifComponent *pComp)
{
   int i,j;

   // find it in list
   for(i = 0; i <= (int) _cComp; i++)
   {
      if(pComp == _rpComp[i])
      {
         // once found, move everything under it up
         for(j = i + 1; j <=(int) (_cComp + 1); j++)
            _rpComp[j-1] = _rpComp[j];

         break;
      }
   }

   // now find where we should insert it
   for(i = 0; _rpComp[i] != 0; i++)
   {
      if(_rpComp[i]->GetCurrentPriority() < pComp->GetCurrentPriority())
         break;
   }
   
   // we want to isert new guy at i
   // move everyone down first
   for(j = _cComp; j >= i; j--)
      _rpComp[j+1] = _rpComp[j];

      // reinsert at i
   _rpComp[i] = pComp;
   

	// Now check that the dependencies are maintained.
	_CheckDependencyPriority();
}





void CCifFile::SortEntries()
{
   _SortComponents(_rpComp, 0, _cComp);
   _SortGroups(_rpGroup, 0, _cGroup);
   _CheckDependencyPriority();
}

void CCifFile::_CheckDependencyPriority()
{
   char szCompBuf[MAX_ID_LENGTH];
   CCifComponent *pCompxkokr;
   CCifComponent *pCompxenus;
   DWORD ixkokr = 0xffffffff;
   DWORD ixenus = 0xffffffff;
   
   // this is a complete hack for Outlook 98 Korean, which has bugs
   //  in prorities.
   
   for(int i = 0; _rpComp[i] != 0; i++)
   {
      if(_rpComp[i]->IsID("Outlook98_xkokr"))
      {
         pCompxkokr = _rpComp[i];
         ixkokr = i;
      }
      else if(_rpComp[i]->IsID("Outlook98_xenus")) 
      {
         pCompxenus = _rpComp[i];
         ixenus = i;
      }
   }
   if(ixkokr != 0xffffffff && ixenus != 0xffffffff)
   {
      if(ixenus > ixkokr)
      {
         _rpComp[ixenus] = pCompxkokr;
         _rpComp[ixkokr] = pCompxenus;
      }
   }
   
}

void CCifFile::ClearQueueState()
{
   for(int i = 0; _rpComp[i] != 0; i++)
   {
      _rpComp[i]->ClearQueueState();
   }

}

void CCifFile::_SortComponents(CCifComponent * a[], UINT p, UINT r)
{
   UINT i, j, x;
   CCifComponent *t;

   if(p < r)
   {
      i = p - 1;
      j = r + 1;
      x = a[p]->GetCurrentPriority();
      for(;;)
      {
         while(a[++i]->GetCurrentPriority() > x);
         while(a[--j]->GetCurrentPriority() < x);
         if(i >= j) break;
         t = a[i]; a[i] = a[j]; a[j] = t;
      }
      _SortComponents(a, p, j);
      _SortComponents(a, j + 1, r);
   }
}

void CCifFile::_SortGroups(CCifGroup * a[], UINT p, UINT r)
{
   UINT i, j, x;
   CCifGroup *t;

   if(p < r)
   {
      i = p - 1;
      j = r + 1;
      x = a[p]->GetCurrentPriority();
      for(;;)
      {
         while(a[++i]->GetCurrentPriority() > x);
         while(a[--j]->GetCurrentPriority() < x);
         if(i >= j) break;
         t = a[i]; a[i] = a[j]; a[j] = t;
      }
      _SortGroups(a, p, j);
      _SortGroups(a, j + 1, r);
   }   
}


void CCifFile::SetDownloadDir(LPCSTR pszDownloadDir)
{
   char szBuf[MAX_PATH];
   DWORD dwLen;
   DWORD dwVer;
   
   lstrcpyn(_szDLDir, pszDownloadDir, MAX_PATH);

   if(_szDLDir[0] >= 'a' && _szDLDir[0] <= 'z')
      _szDLDir[0] -= 32;


   lstrcpyn(_szFilelist, pszDownloadDir, MAX_PATH);
   SafeAddPath(_szFilelist, STR_FILELIST, MAX_PATH);
   
   // check to see if the download list has a version we like
   dwVer = GetPrivateProfileInt(GENERAL_SECTION, VERSION_KEY, 0, _szFilelist); 
   if(dwVer < MIN_SUPPORTED_FILELIST_VER)
      DeleteFilelist(_szFilelist);
      
   WritePrivateProfileString(GENERAL_SECTION, VERSION_KEY, CURRENT_FILELIST_VER, _szFilelist);

   // flush due to wierd stacker bug
   WritePrivateProfileString(NULL, NULL, NULL, _szFilelist);
}

HRESULT CCifFile::Download()
{
   CCifComponent *pcomp;
   UINT i = 0;
   HRESULT hr = NOERROR;

   for(pcomp = _rpComp[i]; pcomp != 0 && SUCCEEDED(hr); pcomp = _rpComp[++i])
   {
      // if it is queued up and not downloded, download it 
      if((pcomp->GetInstallQueueState() == SETACTION_INSTALL) && 
         (pcomp->IsComponentDownloaded() == S_FALSE) )
      {
         hr = pcomp->Download();
         if(FAILED(hr) && _pInsEng->IgnoreDownloadError() && hr != E_ABORT)
            hr = NOERROR;
         
         if(SUCCEEDED(hr))
            hr = _pInsEng->CheckForContinue();
       
      }
   }

   return hr;
}

HRESULT CCifFile::Install(BOOL *pfOneInstalled)
{
   CCifComponent *pcomp;
   UINT i = 0;
   *pfOneInstalled = FALSE;
   HRESULT hr = NOERROR;

   for(pcomp = _rpComp[i]; (pcomp != 0) && SUCCEEDED(hr); pcomp = _rpComp[++i])
   {
      // if it is queued up and not downloded, download it 
      if(pcomp->GetInstallQueueState() == SETACTION_INSTALL)
      {
         hr = pcomp->Install();
         
         if(SUCCEEDED(hr))
            *pfOneInstalled = TRUE;
         
         if(hr != E_ABORT)
            hr = NOERROR;

         if(SUCCEEDED(hr))
            hr = _pInsEng->CheckForContinue();
      }
   }
 
   return hr;
}

HRESULT CCifFile::_ExtractDetDlls( LPCSTR pszCab, LPCSTR pszPath )
{
   char szDetDlls[MAX_PATH];
   char szLogBuf[MAX_PATH*2];
   char szBuf[64];
   UINT i = 0;
   LPSTR pszTmp;
   HRESULT hr = NOERROR;

      // check if we need to extract & copy the detection dlls
   if (SUCCEEDED(GetDetDlls(szDetDlls, sizeof(szDetDlls))))
   {      
      while(SUCCEEDED(hr) && GetStringField(szDetDlls, i++, szBuf, sizeof(szBuf)))
      {
         if(SUCCEEDED(ExtractFiles(pszCab, pszPath, 0, szBuf, NULL, 0)))
         {
            wsprintf(szLogBuf, "Extract DetDll path:%s file:%s\r\n",pszPath, szBuf ); 
            _pInsEng->WriteToLog(szLogBuf, TRUE);
         }
         else
         {
            wsprintf(szLogBuf, "Extract DetDll:%s from: %s\r\n", szBuf, pszCab); 
            _pInsEng->WriteToLog(szLogBuf, TRUE);
            hr = E_FAIL;
         }
      }     
   }

   return hr;
}

HRESULT CCifFile::_CopyDetDlls( LPCSTR pszPath )
{
   char szDetDlls[MAX_PATH];
   char szSrcFile[MAX_PATH];
   char szDestFile[MAX_PATH];
   char szLogBuf[MAX_PATH*2];
   char szBuf[64];
   UINT i = 0;
   LPSTR pszTmp;

      // check if we need to extract & copy the detection dlls
   if (SUCCEEDED(GetDetDlls(szDetDlls, sizeof(szDetDlls))))
   {
      lstrcpy(szDestFile, _szCifPath);
      GetParentDir(szDestFile);
      pszTmp = szDestFile + lstrlen(szDestFile);
      
      while(GetStringField(szDetDlls, i++, szBuf, sizeof(szBuf)))
      {
        lstrcpy(szSrcFile, pszPath);
        AddPath(szSrcFile, szBuf);
        
        *pszTmp = 0;
        AddPath(szDestFile, szBuf);
        CopyFile(szSrcFile, szDestFile, FALSE);

        wsprintf(szLogBuf, "Copy DetDll fr:%s to:%s\r\n", szSrcFile, szDestFile); 
        _pInsEng->WriteToLog(szLogBuf, TRUE);
      }
      return NOERROR;
   }
   else
      return E_FAIL;   
}


HRESULT CCifFile::DownloadCifFile(LPCSTR pszUrl, LPCSTR pszCif)
{
   HRESULT hr;
   char szTempfile[MAX_PATH];
   char szDownldfile[MAX_PATH];
   char szPath[MAX_PATH];
    
   _pInsEng->AddRef();
   _pInsEng->OnEngineStatusChange(ENGINESTATUS_LOADING, 0);
   CDownloader *pDL = _pInsEng->GetDownloader();
   if(!pDL)
      return E_UNEXPECTED;
   
   hr = pDL->SetupDownload(pszUrl, NULL, 0, NULL);
   
   szPath[0] = 0;
   if(SUCCEEDED(hr))
      hr = pDL->DoDownload(szDownldfile, sizeof(szDownldfile));
   
   if(SUCCEEDED(hr))
   {
      hr = ::CheckTrustEx(pszUrl, szDownldfile, _pInsEng->GetHWND(), FALSE, NULL);
      
      // For compat reasons, we need to copy the cif cab into the download dir
      if(SUCCEEDED(hr))
      {
         lstrcpy(szPath, _szDLDir);
         SafeAddPath(szPath, ParseURLA(pszUrl), sizeof(szPath));
         CopyFile(szDownldfile, szPath, FALSE);
      }
   
      
      lstrcpy(szPath, szDownldfile);
      GetParentDir(szPath);
   }
   
   if(SUCCEEDED(hr))
      hr=ExtractFiles(szDownldfile, szPath, 0, pszCif, NULL, 0);
    
   if(SUCCEEDED(hr))
   {
      //BUGBUG: we should validate cif we got somehow!
   
      
      // if we already have a cif, copy what we need over old cif, delete temp now
      if(_rpComp)
      {
         // Dest
         lstrcpy(szTempfile, _szCifPath);
         GetParentDir(szTempfile);
         AddPath(szTempfile, pszCif);
      
         // source
         SafeAddPath(szPath, pszCif, sizeof(szPath));
     
         // copy to old one
         CopyFile(szPath, szTempfile, FALSE);
         hr = SetCifFile(szTempfile, FALSE);  // read only version

         GetParentDir(szPath);
         
         // check if we need to extract & copy the detection dlls
         if (SUCCEEDED(hr))
         {
            if(SUCCEEDED(hr =_ExtractDetDlls(szDownldfile,szPath)))
                _CopyDetDlls(szPath);
         }

         DelNode(szPath, 0);
      }
      else
      {
         // new cif, use it in place in temp dir, mark temp dir to clean up
         _fCleanDir = TRUE;
         SafeAddPath(szPath, pszCif, sizeof(szPath)); 
         hr = SetCifFile(szPath, FALSE);  // read only version
         if (SUCCEEDED(hr))
         {
            GetParentDir(szPath);
            hr =_ExtractDetDlls(szDownldfile,szPath);
         }
      }      
   } 
   else
   {
      // cleanup now
      if(szPath[0] != 0)
         DelNode(szPath, 0);
   }
    
   _pInsEng->OnEngineStatusChange(SUCCEEDED(hr) ? ENGINESTATUS_READY : ENGINESTATUS_NOTREADY, hr);

    // we are done; release the install engine
   _pInsEng->Release();

   return hr;
}

HRESULT CCifFile::_FindCifComponent(LPCSTR pszID, CCifComponent **p)
{
   CCifComponent *pcomp;
   UINT i = 0;
   
   *p = 0;
   if(_rpComp)
   {
      for(pcomp = _rpComp[i]; pcomp != 0; pcomp = _rpComp[++i])
         if(pcomp->IsID(pszID))
         {
            *p = pcomp;
            return NOERROR;
         } 
   }
   return E_FAIL;
}

void CCifFile::MarkCriticalComponents(CCifComponent *pOwner)
{
   char szID[MAX_ID_LENGTH];
   UINT j;
   CCifComponent *pComp;
   
   for(j = 0;SUCCEEDED(pOwner->GetTreatAsOneComponents(j, szID, sizeof(szID))); j++)
   {
      if(SUCCEEDED(_FindCifComponent(szID, &pComp)))
      {
         if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
         {
            if(_pLastCriticalComp == NULL)
               _pLastCriticalComp = pComp;
            else
            {
               UINT i = 0;

               CCifComponent *ptemp;
               for(ptemp = _rpComp[i]; ptemp != 0 && ptemp != _pLastCriticalComp && ptemp != pComp ; ptemp = _rpComp[++i]);
      
               if(ptemp == _pLastCriticalComp)
                  _pLastCriticalComp = pComp;
            }
         }
      }
   }
}

void CCifFile::RemoveFromCriticalComponents(CCifComponent *pComp)
{
   if(_pLastCriticalComp == pComp)
      _pLastCriticalComp = NULL;
}
     

DWORD WINAPI DownloadCifFile(LPVOID pv)
{
   SETCIFARGS *p = (SETCIFARGS *) pv;

   p->pCif->DownloadCifFile(p->szUrl, p->szCif);

   delete p;

   return 0;
}

CCifRWFile::CCifRWFile() : CCifFile()
{
   _cCompUnused = 0;
   _cGroupUnused = 0;
   _cModeUnused = 0;   
}

CCifRWFile::~CCifRWFile()
{
   // flus out the cif file
   WritePrivateProfileString( NULL, NULL, NULL, _szCifPath );

   if(_rpRWGroup)
   {
      for ( UINT i=0; i<=_cGroup; i++)
         delete(_rpRWGroup[i]);
      free(_rpRWGroup);
   }

   if(_rpRWComp)
   {
      for ( UINT i=0; i<=_cComp; i++)
         delete(_rpRWComp[i]);
      free(_rpRWComp);
   }

   if(_rpRWMode)
   {
      for ( UINT i=0; i<=_cMode; i++)
         delete(_rpRWMode[i]);
      free(_rpRWMode);
   }
}


// ICifRWFile implementation

// wrapper of the CCifFile functions
STDMETHODIMP CCifRWFile::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
   return (CCifFile::QueryInterface(riid, ppvObj));
}

STDMETHODIMP_(ULONG) CCifRWFile::AddRef()                      
{
   return(_cRef++);
}

STDMETHODIMP_(ULONG) CCifRWFile::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}
 
STDMETHODIMP CCifRWFile::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum((CCifComponent **)_rpRWComp, dwFilter, PARENTTYPE_CIF, NULL);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWFile::FindComponent(LPCSTR pszID, ICifComponent **p)
{
   CCifRWComponent *pcomp;
   UINT i = 0;
   
   *p = 0;
   if(_rpRWComp)
   {
      for(pcomp = _rpRWComp[i]; pcomp != 0; pcomp = _rpRWComp[++i])
         if(pcomp->IsID(pszID))
         {
            CCifComponent *ptmp;

            ptmp = (CCifComponent *)pcomp;
            *p = (ICifComponent *) ptmp;
            return NOERROR;
         }
   }
   return E_FAIL;
}

STDMETHODIMP CCifRWFile::EnumGroups(IEnumCifGroups **pp, DWORD dwFilter, LPVOID pv)
{
   CCifGroupEnum *pge;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pge = new CCifGroupEnum((CCifGroup **)_rpRWGroup, dwFilter);
   if(pge)
   {
      *pp = (IEnumCifGroups *) pge;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWFile::FindGroup(LPCSTR pszID, ICifGroup **p)
{
   CCifRWGroup *pgrp;
   UINT i = 0;
   
   *p = 0;
   if(_rpRWGroup)
   {
      for(pgrp = _rpRWGroup[i]; pgrp != 0; pgrp = _rpRWGroup[++i])
         if(pgrp->IsID(pszID))
         {
            CCifGroup *ptmp;

            ptmp = (CCifGroup *)pgrp;

            *p = (ICifGroup *) ptmp;
            return NOERROR;
         }
   }
   return E_FAIL;

}

STDMETHODIMP CCifRWFile::EnumModes(IEnumCifModes **pp, DWORD dwFilter, LPVOID pv)
{
   CCifModeEnum *pme;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pme = new CCifModeEnum((CCifMode **)_rpRWMode, dwFilter);
   if(pme)
   {
      *pp = (IEnumCifModes *) pme;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWFile::FindMode(LPCSTR pszID, ICifMode **p)
{
   CCifRWMode *pmode;
   UINT i = 0;
   
   *p = 0;
   if(_rpRWMode)
   {
      for(pmode = _rpRWMode[i]; pmode != 0; pmode = _rpRWMode[++i])
         if(pmode->IsID(pszID))
         {
            CCifMode *ptmp;

            ptmp = (CCifMode *)pmode;

            *p = (ICifMode *) ptmp;
            return NOERROR;
         }
   }

   return E_FAIL;
}

STDMETHODIMP CCifRWFile::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifFile::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP CCifRWFile::GetDetDlls(LPSTR pszDlls, DWORD dwSize)
{
   return(CCifFile::GetDetDlls(pszDlls, dwSize));
}


STDMETHODIMP CCifRWFile::SetDescription(LPCSTR pszDesc)
{
   return(WriteTokenizeString(_szCifPath, "Version", DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWFile::CreateComponent(LPCSTR pszID, ICifRWComponent **p)
{
   CCifRWComponent *prwcomp;
   CCifRWComponent **ppRWCompPreFail;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   *p = 0;
   for(prwcomp = _rpRWComp[i]; prwcomp != 0; prwcomp = _rpRWComp[++i])
   {
      if(prwcomp->IsID(pszID))
      {
         *p = (ICifRWComponent*)prwcomp;
         bFound = TRUE;
         break;
      }
   }
   
   // create the new component
   if (!bFound)
   {
      prwcomp = new CCifRWComponent(pszID, this);
      if (!prwcomp)
         return E_OUTOFMEMORY;

      // check to see if we need to grow the array size
      if (_cCompUnused <= 0)
      {
         // growing the array size to acomdate the new component
         ppRWCompPreFail = _rpRWComp;
// #pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
         _rpRWComp = (CCifRWComponent **) realloc(_rpRWComp, sizeof(CCifRWComponent **)*(i+10));
         if (_rpRWComp)
         {
            _cCompUnused = 9;  // terminator used up one slot and the new comp use the one, s
         }
         else
         {
            if(ppRWCompPreFail)
            {
               for ( UINT i=0; i<=_cComp; i++)
                  delete(ppRWCompPreFail[i]);
               free(ppRWCompPreFail);
            }
            return E_OUTOFMEMORY;
         }
      }
      _rpRWComp[i] = prwcomp;
      _rpRWComp[i+1] = 0;
      _cCompUnused--;
      _cComp++;
      *p = (ICifRWComponent*)prwcomp;
      WritePrivateProfileString(pszID, ENTRYTYPE_KEY, ENTRYTYPE_COMP, _szCifPath);

   }
   
   return NOERROR;
}

STDMETHODIMP CCifRWFile::CreateGroup(LPCSTR pszID, ICifRWGroup **p)
{
   CCifRWGroup *prwgroup;
   CCifRWGroup **ppwgroupPreFail;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   *p = 0;
   for(prwgroup = _rpRWGroup[i]; prwgroup != 0; prwgroup = _rpRWGroup[++i])
   {
      if(prwgroup->IsID(pszID))
      {
         *p = (ICifRWGroup *)prwgroup;
         bFound = TRUE;
         break;
      }
   }
   
   // create the new component
   if (!bFound)
   {
      prwgroup = new CCifRWGroup(pszID, i+1, this);
      if (!prwgroup)
         return E_OUTOFMEMORY;

      // check to see if we need to grow the array size
      if (_cGroupUnused <= 0)
      {
         ppwgroupPreFail = _rpRWGroup;
         // growing the array size to acomdate the new component
// #pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
         _rpRWGroup = (CCifRWGroup **) realloc(_rpRWGroup, sizeof(CCifRWGroup **)*(i+10));
         if (_rpRWGroup)
         {
            _cGroupUnused = 9;
         }
         else
         {
            if(ppwgroupPreFail)
            {
               for ( UINT i=0; i<=_cGroup; i++)
                  delete(ppwgroupPreFail[i]);
               free(ppwgroupPreFail);
            }
            return E_OUTOFMEMORY;
         }
      }
      _rpRWGroup[i] = prwgroup;
      _rpRWGroup[i+1] = 0;
      _cGroupUnused--;
      _cGroup++;
      *p = (ICifRWGroup *)prwgroup;
      WritePrivateProfileString(pszID, ENTRYTYPE_KEY, ENTRYTYPE_GROUP, _szCifPath);

   }      
   return NOERROR;

}
      
STDMETHODIMP CCifRWFile::CreateMode(LPCSTR pszID, ICifRWMode **p)
{
   CCifRWMode *prwmode;
   CCifRWMode **prwmodePreFail;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   *p = 0;
   for(prwmode = _rpRWMode[i]; prwmode != 0; prwmode = _rpRWMode[++i])
   {
      if(prwmode->IsID(pszID))
      {
         *p = (ICifRWMode *)prwmode;
         bFound = TRUE;
         break;
      }
   }
   
   // create the new component
   if (!bFound)
   {
      prwmode = new CCifRWMode(pszID, this);
      if (!prwmode)
         return E_OUTOFMEMORY;

      // check to see if we need to grow the array size
      if (_cModeUnused <= 0)
      {
         prwmodePreFail = _rpRWMode;
         // growing the array size to acomdate the new component

//#pragma prefast(suppress: 308, "PREfast noise - pointer was saved before")
         _rpRWMode = (CCifRWMode **) realloc(_rpRWMode, sizeof(CCifRWMode **)*(i+10));
         if (_rpRWMode)
         {
            _cModeUnused = 9;
         }
         else
         {
            if(prwmodePreFail)
            {
               for ( UINT i=0; i<=_cMode; i++)
                  delete(prwmodePreFail[i]);
               free(prwmodePreFail);
            }
            return E_OUTOFMEMORY;
         }
      }
      _rpRWMode[i] = prwmode;
      _rpRWMode[i+1] = 0;
      _cModeUnused--;
      _cMode++;
      *p = (ICifRWMode *)prwmode;
      WritePrivateProfileString(pszID, ENTRYTYPE_KEY, ENTRYTYPE_MODE, _szCifPath);         

   }

   return NOERROR;
}
      
STDMETHODIMP CCifRWFile::DeleteComponent(LPCSTR pszID)
{
   CCifRWComponent *prwcomp;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   for(prwcomp = _rpRWComp[i]; prwcomp != 0; prwcomp = _rpRWComp[++i])
   {
      if(prwcomp->IsID(pszID))
      {
         bFound = TRUE;
         break;
      }
   }
   
   // Delete the component
   if (bFound)
   {
      delete(prwcomp);
      for ( UINT j=i+1; j<=_cComp; j++)
      {
         _rpRWComp[i] = _rpRWComp[j];
         i= j;
      }
      _rpRWComp[i] = 0;
      _cCompUnused++;
      _cComp--;
      
   }

   return (WritePrivateProfileString(pszID, NULL, NULL, _szCifPath)?NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWFile::DeleteGroup(LPCSTR pszID)
{
   CCifRWGroup *prwgroup;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   for(prwgroup = _rpRWGroup[i]; prwgroup != 0; prwgroup = _rpRWGroup[++i])
   {
      if(prwgroup->IsID(pszID))
      {
         bFound = TRUE;
         break;
      }
   }
   
   // Delete the Group
   if (bFound)
   {
      delete(prwgroup);
      for (UINT j=i+1; j<=_cGroup; j++)
      {
         _rpRWGroup[i] = _rpRWGroup[j];
         i= j;
      }
      _rpRWGroup[i] = 0;      
      _cGroupUnused++;
      _cGroup--;
   }

   return (WritePrivateProfileString(pszID, NULL, NULL, _szCifPath)?NOERROR:E_FAIL);
}
      
STDMETHODIMP CCifRWFile::DeleteMode(LPCSTR pszID)
{
   CCifRWMode *prwmode;
   BOOL  bFound = FALSE;
   UINT i = 0;
   
   for(prwmode = _rpRWMode[i]; prwmode != 0; prwmode = _rpRWMode[++i])
   {
      if(prwmode->IsID(pszID))
      {
         bFound = TRUE;
         break;
      }
   }
   
   // Delete the Mode
   if (bFound)
   {
      delete(prwmode);
      for (UINT j=i+1; j<=_cMode; j++)
      {
         _rpRWMode[i] = _rpRWMode[j];
         i= j;
      }
      _rpRWMode[i] = 0;      
      _cModeUnused++;
      _cMode--;
   }

   return (WritePrivateProfileString(pszID, NULL, NULL, _szCifPath)?NOERROR:E_FAIL);      
}

STDMETHODIMP CCifRWFile::Flush()
{
    WritePrivateProfileString(NULL, NULL, NULL, _szCifPath);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\cifgroup.cpp ===
#include "inspch.h"
#include "util2.h"
#include "inseng.h"
#include "ciffile.h"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifGroup::CCifGroup(LPCSTR pszCompID, UINT uGrpNum, CCifFile *pCif) : CCifEntry(pszCompID, pCif) 
{
   _uGrpNum = uGrpNum;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifGroup::~CCifGroup()
{
}


STDMETHODIMP CCifGroup::GetID(LPSTR pszID, DWORD dwSize)
{
   lstrcpyn(pszID, _szID, dwSize);
   return NOERROR;
}


STDMETHODIMP CCifGroup::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc, dwSize));   
}

STDMETHODIMP_(DWORD) CCifGroup::GetPriority()
{
   return(GetPrivateProfileInt(_szID, PRIORITY, 0, _pCif->GetCifPath()));
}

STDMETHODIMP CCifGroup::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum(_pCif->GetComponentList(), dwFilter, PARENTTYPE_GROUP, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP_(DWORD) CCifGroup::GetInstallQueueState()
{
   return E_NOTIMPL;
}


STDMETHODIMP_(DWORD) CCifGroup::GetCurrentPriority()
{
   if(_uPriority == 0xffffffff)
      _uPriority = ((GetPriority() << 10) + _uGrpNum) << 10;
   
   return _uPriority;
}

//=========== ICifRWGroup implementation ============================================
//
CCifRWGroup::CCifRWGroup(LPCSTR pszID, UINT uGrpNum, CCifFile *pCif) : CCifGroup(pszID, uGrpNum, pCif)
{
}

CCifRWGroup::~CCifRWGroup()
{

}

STDMETHODIMP CCifRWGroup::GetID(LPSTR pszID, DWORD dwSize)
{
   return(CCifGroup::GetID(pszID, dwSize));
}

STDMETHODIMP CCifRWGroup::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifGroup::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP_(DWORD) CCifRWGroup::GetPriority()
{
   return(CCifGroup::GetPriority());
}

STDMETHODIMP CCifRWGroup::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum((CCifComponent**)_pCif->GetComponentList(), dwFilter, PARENTTYPE_GROUP, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;

}

// access to state
STDMETHODIMP_(DWORD) CCifRWGroup::GetCurrentPriority()
{
   return(CCifGroup::GetCurrentPriority());
}

STDMETHODIMP CCifRWGroup::SetDescription(LPCSTR pszDesc)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWGroup::SetPriority(DWORD dwPri)
{
   char szbuf[20];

   return(WritePrivateProfileString(_szID, PRIORITY, ULtoA(dwPri, szbuf, 10), _pCif->GetCifPath()));
}   
   
STDMETHODIMP CCifRWGroup::SetDetails(LPCSTR pszDetails)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails));   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\cifgroup.h ===
class CCifGroup : public ICifGroup, public CCifEntry
{
   public:
      CCifGroup(LPCSTR pszID, UINT uGrpNum, CCifFile *);
      ~CCifGroup();
      
      // ICifGroup interface
        // for properties
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD_(DWORD, GetPriority)();
  
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);

      // access to state
      STDMETHOD_(DWORD, GetInstallQueueState)();
      STDMETHOD_(DWORD, GetCurrentPriority)();

   protected:
      UINT            _uGrpNum;
};

class CCifRWGroup : public ICifRWGroup, public CCifGroup
{
   public:
      CCifRWGroup(LPCSTR pszID, UINT uGrpNum, CCifFile *);
      ~CCifRWGroup();

      // ICifGroup interface
      // for properties
      STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
      STDMETHOD_(DWORD, GetPriority)();
      STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      // access to state
      STDMETHOD_(DWORD, GetCurrentPriority)();
      
      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(SetPriority)(THIS_ DWORD);
      STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inc\urlhlink.h ===
#ifndef __URLHLINK_H
#define __URLHLINK_H

#include "urlmon.h"

#ifdef __cplusplus
extern "C" {
#endif


// Flags for the UrlDownloadToCacheFile
#define	URLOSTRM_USECACHEDCOPY_ONLY		0x1								// Only get from cache
#define	URLOSTRM_USECACHEDCOPY			URLOSTRM_USECACHEDCOPY_ONLY	+1	// Get from cache if available else download
#define	URLOSTRM_GETNEWESTVERSION		URLOSTRM_USECACHEDCOPY		+1	// Get new version only. But put it in cache too


typedef HRESULT (STDAPICALLTYPE *LPFNUOSCALLBACK)(LPBINDSTATUSCALLBACK);


STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenStream  URLOpenStreamW
#else
#define URLOpenStream  URLOpenStreamA
#endif // !UNICODE
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenPullStream  URLOpenPullStreamW
#else
#define URLOpenPullStream  URLOpenPullStreamA
#endif // !UNICODE
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToFile  URLDownloadToFileW
#else
#define URLDownloadToFile  URLDownloadToFileA
#endif // !UNICODE

STDAPI URLDownloadToCacheFileA(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToCacheFileW(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToCacheFile  URLDownloadToCacheFileW
#else
#define URLDownloadToCacheFile  URLDownloadToCacheFileA
#endif // !UNICODE

STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenBlockingStream  URLOpenBlockingStreamW
#else
#define URLOpenBlockingStream  URLOpenBlockingStreamA
#endif // !UNICODE

#define UOSM_PUSH  0
#define UOSM_PULL  1
#define UOSM_BLOCK 2
#define UOSM_FILE  3

#define UOS_URLENCODEPOSTDATA BINDINFOF_URLENCODESTGMEDDATA
#define UOS_URLENCODEURL      BINDINFOF_URLENCODEDEXTRAINFO

typedef struct _UOSHTTPINFOA
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCSTR  	szURL;
	LPCSTR  	szVerb;
	LPCSTR  	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCSTR  	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOA, * LPUOSHTTPINFOA; 
typedef struct _UOSHTTPINFOW
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCWSTR 	szURL;
	LPCWSTR 	szVerb;
	LPCWSTR 	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCWSTR 	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOW, * LPUOSHTTPINFOW; 
#ifdef UNICODE
typedef UOSHTTPINFOW UOSHTTPINFO;
typedef LPUOSHTTPINFOW LPUOSHTTPINFO;
#else
typedef UOSHTTPINFOA UOSHTTPINFO;
typedef LPUOSHTTPINFOA LPUOSHTTPINFO;
#endif // UNICODE

STDAPI URLOpenHttpStreamA(LPUOSHTTPINFOA);
STDAPI URLOpenHttpStreamW(LPUOSHTTPINFOW);
#ifdef UNICODE
#define URLOpenHttpStream  URLOpenHttpStreamW
#else
#define URLOpenHttpStream  URLOpenHttpStreamA
#endif // !UNICODE

struct IBindStatusCallback;

STDAPI HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkGoBack(IUnknown *pUnk);
STDAPI HlinkGoForward(IUnknown *pUnk);
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\cifcomp.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "insobj.h"
#include "util2.h"


#define MAX_VALUE_LEN 256
#define MAX_SMALL_BUF 64
#define NO_ENTRY ""

#define UNINSTALL_BRANCH  "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"

char g_pBuffer[BUFFERSIZE];

#define NUM_RETRIES 2
 

HINSTANCE CCifComponent::_hDetLib = NULL;
char      CCifComponent::_szDetDllName[] = "";

const char c_gszSRLiteOffset[] = "patch/";
char         gszIsPatchable[]  = "IsPatchable";


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//


CCifComponent::CCifComponent(LPCSTR pszCompID, CCifFile *pCif) : CCifEntry(pszCompID, pCif) 
{
   _dwPlatform = 0xffffffff;
   _uInstallStatus = 0xffffffff;
   _uInstallCount = 0;
   _fDependenciesQueued = FALSE;
   _fUseSRLite = FALSE;
   _fBeforeInstall = TRUE;
   SetDownloadDir("");
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifComponent::~CCifComponent()
{
   if(_hDetLib)
   {
      FreeLibrary(_hDetLib);
      _hDetLib = NULL;
   }
}



STDMETHODIMP CCifComponent::GetID(LPSTR pszID, DWORD dwSize)
{
   lstrcpyn(pszID, _szID, dwSize);
   return NOERROR;
}

STDMETHODIMP CCifComponent::GetGUID(LPSTR pszGUID, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, GUID_KEY, "", pszGUID, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL);      
}

STDMETHODIMP CCifComponent::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc, dwSize));
}

STDMETHODIMP CCifComponent::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails, dwSize));   
}

STDMETHODIMP CCifComponent::GetUrl(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   // in cif, these things start at 1. we want to start at 0 when handing them out
   uUrlNum++;

   // Build up the key
   wsprintf(szKey, "%s%lu", URL_KEY, uUrlNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath());
   
   // See if there is any such entry
   if(lstrcmp(szBuf, NO_ENTRY) != 0)
   {
      // snatch the url name
      if(GetStringField(szBuf, 0, pszUrl, dwSize) != 0)
      {
         // This url looks ok
         hr = NOERROR;
      
         *pdwUrlFlags = GetIntField(szBuf, 1, URLF_DEFAULT);
      }
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetFileExtractList(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   uUrlNum++;

   // Build up the key
   wsprintf(szKey, "%s%lu", URL_KEY, uUrlNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath());
   
   // See if there is any such entry
   if(lstrcmp(szBuf, NO_ENTRY) != 0)
   {
      // snatch the extract list
      if(GetStringField(szBuf, 2, pszExtract, dwSize))
      hr = NOERROR;
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetUrlCheckRange(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   uUrlNum++;
   *pdwMin = *pdwMax = 0;

   // Build up the key
   wsprintf(szKey, "%s%lu", URLSIZE_KEY, uUrlNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath());
   
   // See if there is any such entry
   if(lstrcmp(szBuf, NO_ENTRY) != 0)
   {
      // snatch the extract list
      *pdwMin = GetIntField(szBuf, 0, 0);
      *pdwMax = GetIntField(szBuf, 1, *pdwMin);
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetCommand(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, 
                                       LPSTR pszSwitches, DWORD dwSwitchSize, LPDWORD pdwType)
{
   char szKey[16];
   HRESULT hr = E_FAIL;
 
   uCmdNum++;
   // Build up the key
   wsprintf(szKey, "%s%lu", CMD_KEY, uCmdNum);
   GetPrivateProfileString(_szID, szKey, NO_ENTRY, pszCmd, dwCmdSize, _pCif->GetCifPath());
   if(lstrcmp(pszCmd, NO_ENTRY) != 0)
   {
      // Build up the key
      wsprintf(szKey, "%s%d", ARGS_KEY, uCmdNum);
      GetPrivateProfileString(_szID, szKey, NO_ENTRY, pszSwitches, dwSwitchSize, _pCif->GetCifPath());
      // expand #W (or #w) to windows directory
      ExpandString( pszSwitches, dwSwitchSize );
   
      // Build up the key
      wsprintf(szKey, "%s%d", TYPE_KEY, uCmdNum);
   
      *pdwType = GetPrivateProfileInt(_szID, szKey, CMDF_DEFAULT, _pCif->GetCifPath());

      hr = NOERROR;
   }
   return hr;
}

STDMETHODIMP CCifComponent::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   char szBuf[MAX_VALUE_LEN];

   szBuf[0] = '\0';

   // Version
   GetPrivateProfileString(_szID, VERSION_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath());
   ConvertVersionStrToDwords(szBuf, pdwVersion, pdwBuild);
   return NOERROR;
}
      
STDMETHODIMP CCifComponent::GetLocale(LPSTR pszLocale, DWORD dwSize)
{
   if(FAILED(MyTranslateString(_pCif->GetCifPath(), _szID, LOCALE_KEY, pszLocale, dwSize)))
      lstrcpyn(pszLocale, DEFAULT_LOCALE, dwSize);

   return NOERROR;
}

STDMETHODIMP CCifComponent::GetUninstallKey(LPSTR pszKey, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, UNINSTALLSTRING_KEY, "", pszKey, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL);      
}

STDMETHODIMP CCifComponent::GetInstalledSize(LPDWORD pdwWin, LPDWORD pdwApp)
{
   char szBuf[MAX_VALUE_LEN];

   if(GetPrivateProfileString(_szID, INSTALLSIZE_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath()))
   {
      *pdwApp = GetIntField(szBuf, 0, 0);
      *pdwWin = GetIntField(szBuf, 1, 0);
   }
   else
   {
      *pdwWin = 0;
      *pdwApp = 2 * GetDownloadSize();
   }
   return NOERROR;
}

STDMETHODIMP_(DWORD) CCifComponent::GetDownloadSize()
{
   char szBuf[MAX_VALUE_LEN];

   szBuf[0] = '\0';

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0,0", szBuf, sizeof(szBuf), _pCif->GetCifPath());   
   return(GetIntField(szBuf, 0, 0));
}   

STDMETHODIMP_(DWORD) CCifComponent::GetExtractSize()
{
   char szBuf[MAX_VALUE_LEN];
   DWORD dwSize;

   szBuf[0] = '\0'; 

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0,0", szBuf, sizeof(szBuf), _pCif->GetCifPath());   
   dwSize = GetIntField(szBuf, 1, 2 * GetIntField(szBuf, 0, 0));
   
   return dwSize;
}   

STDMETHODIMP CCifComponent::GetSuccessKey(LPSTR pszKey, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, SUCCESS_KEY, "", pszKey, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL);      
}

STDMETHODIMP CCifComponent::GetProgressKeys(LPSTR pszProgress, DWORD dwProgSize, LPSTR pszCancel, DWORD dwCancelSize)
{
   GetPrivateProfileString(_szID, PROGRESS_KEY, "", pszProgress, dwProgSize, _pCif->GetCifPath());
   GetPrivateProfileString(_szID, MUTEX_KEY, "", pszCancel, dwCancelSize, _pCif->GetCifPath());
   if(*pszProgress != 0 || *pszCancel != 0)
      return NOERROR;
   else
      return E_FAIL;
}

STDMETHODIMP CCifComponent::IsActiveSetupAware()
{
   return(GetPrivateProfileInt(_szID, ACTSETUPAWARE_KEY, 0, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}

STDMETHODIMP CCifComponent::IsRebootRequired()
{
   return(GetPrivateProfileInt(_szID, REBOOT_KEY, 0, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}

STDMETHODIMP CCifComponent::RequiresAdminRights()
{
   return(GetPrivateProfileInt(_szID, ADMIN_KEY, 0, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}

STDMETHODIMP_(DWORD) CCifComponent::GetPriority()
{
   return(GetPrivateProfileInt(_szID, PRIORITY, 0, _pCif->GetCifPath()));
}

STDMETHODIMP CCifComponent::GetDependency(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   char szBuf[MAX_VALUE_LEN];
   char szBuf2[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;
   DWORD dwLen;
   LPSTR pszTemp;
   DWORD dwV, dwBld;

   dwV = dwBld = 0xffffffff;

   if(GetPrivateProfileString(_szID, DEPENDENCY_KEY, NO_ENTRY, szBuf2, sizeof(szBuf2), _pCif->GetCifPath()))
   {
      if(GetStringField(szBuf2, uDepNum, szBuf, sizeof(szBuf)))
      {
         // Do some funky parsing 
         dwLen = lstrlen(szBuf);
         *pchType = DEP_INSTALL;

         pszTemp = FindChar(szBuf, ':');
         if(*pszTemp)
         {
            *pszTemp = 0;
            lstrcpyn(pszID, szBuf, dwBuf);
            pszTemp++;
            *pchType = *pszTemp;
            // see if we have a version
            pszTemp = FindChar(pszTemp, ':');
            if(*pszTemp)
            {
               pszTemp++;
               // wierdness - scan the string, convert . to , for parsing
               LPSTR pszTemp2 = pszTemp;
               while(*pszTemp2 != 0)
               {
                  if(*pszTemp2 == '.')
                     *pszTemp2 = ',';
                  pszTemp2++;
               }
               
               ConvertVersionStrToDwords(pszTemp, &dwV, &dwBld);
               
            }
         }
         else
            lstrcpyn(pszID, szBuf, dwBuf);
      
         if(dwV == 0xffffffff && dwBld == 0xffffffff)
         {
            // get version of dependency from cif
            ICifComponent *pcomp;
              
            if(SUCCEEDED(_pCif->FindComponent(pszID, &pcomp)))
               pcomp->GetVersion(&dwV, &dwBld);
         }
         hr = NOERROR;
      }
           
   }
   if(pdwVer)
      *pdwVer = dwV;

   if(pdwBuild)
      *pdwBuild = dwBld;

   return hr;
}

LPSTR g_pszComp[] = { "Branding.cab", 
                      "desktop.cab", 
                      "custom0", 
                      "custom1",
                      "custom2",
                      "custom3",
                      "custom4",
                      "custom5",
                      "custom6",
                      "custom7",
                      "custom8",
                      "custom9",
                      "CustIcmPro",
                      NULL};

STDMETHODIMP_(DWORD) CCifComponent::GetPlatform()
{
   if(_dwPlatform == 0xffffffff)
   {
      char *rszPlatforms[7] = { STR_WIN95, STR_WIN98, STR_NT4, STR_NT5, STR_NT4ALPHA, STR_NT5ALPHA,STR_MILLEN };
      DWORD rdwPlatforms[] = { PLATFORM_WIN95, PLATFORM_WIN98, PLATFORM_NT4, PLATFORM_NT5, 
         PLATFORM_NT4ALPHA, PLATFORM_NT5ALPHA, PLATFORM_MILLEN };
      char szBuf[MAX_VALUE_LEN];
      char szPlatBuf[MAX_VALUE_LEN];
      BOOL  bFound = FALSE;
      int i = 0;

      while (!bFound && g_pszComp[i])
      {
          bFound = (lstrcmpi(g_pszComp[i], _szID) == 0);
          i++;
      }
      
      _dwPlatform = 0;

      if(!bFound && GetPrivateProfileString(_szID, PLATFORM_KEY, NO_ENTRY, szBuf, sizeof(szBuf), _pCif->GetCifPath()))
      {
         int j = 0;
         while(GetStringField(szBuf, j++, szPlatBuf, sizeof(szPlatBuf)))
         {
            for(int i = 0; i < 7; i++)
            {
               if(lstrcmpi(szPlatBuf, rszPlatforms[i]) == 0)
               {
                  // check if we should add this platform for this component.
                  if ((GetCurrentPlatform() != rdwPlatforms[i])  ||
                       !DisableComponent())
                    _dwPlatform |= rdwPlatforms[i];
               }
            }
         }
      }
      else
         _dwPlatform = PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN;
   }
   return _dwPlatform;
}

STDMETHODIMP_(BOOL) CCifComponent::DisableComponent()
{
   BOOL bDisableComp = FALSE;
   BOOL bGuidMatch = FALSE;
   HKEY hKey;
   DWORD dwIndex = 0;
   CHAR szGUIDComp[MAX_VALUE_LEN];
   CHAR szGUID[MAX_VALUE_LEN];
   DWORD dwGUIDSize = sizeof(szGUID);
   CHAR szData[MAX_VALUE_LEN];
   DWORD dwDataSize = sizeof(szData);
   LPSTR pTmp;
   DWORD dwVersion , dwBuild;
   DWORD dwInstallVer, dwInstallBuild;

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, COMPONENTBLOCK_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
   {
      while (!bDisableComp &&
             (RegEnumValue(hKey, dwIndex, szGUID, &dwGUIDSize, NULL, NULL,
                         (LPBYTE)szData, &dwDataSize) == ERROR_SUCCESS) )
      {
         GetGUID(szGUIDComp, sizeof(szGUIDComp));
         pTmp = ANSIStrChr( szGUID, '*' );
         if (pTmp)
         {
            // If there is a * assume it is at the end
            *pTmp = '\0';
            szGUIDComp[lstrlen(szGUID)] = '\0';
         }
         bGuidMatch = (lstrcmpi(szGUID, szGUIDComp) == 0);
         // Did the Guids match?
         if (bGuidMatch)
         {
            // now see if we have version info.
            if (dwDataSize == 0)
               bDisableComp = TRUE;
            else
            {
               // Convert the versin number for the registry
               ConvertVersionStrToDwords(szData, &dwVersion, &dwBuild);
               if (dwVersion == 0)
                  bDisableComp = TRUE;
               else
               {
                  // Get the versin we would install.
                  GetVersion(&dwInstallVer, &dwInstallBuild);
                  // If the version we would install is equal or less, disable the component.
                  if ((dwInstallVer < dwVersion) ||
                      ((dwInstallVer == dwVersion) && (dwInstallBuild <= dwBuild)) )
                     bDisableComp = TRUE;
               }
            }
         }
         dwGUIDSize = sizeof(szGUID);
         dwDataSize = sizeof(szData);
         dwIndex++;
      }
      RegCloseKey(hKey);
   }
   return bDisableComp;
}

STDMETHODIMP CCifComponent::GetMode(UINT uModeNum, LPSTR pszMode, DWORD dwSize)
{
   char szBuf[MAX_VALUE_LEN];

   if(FAILED(MyTranslateString(_pCif->GetCifPath(), _szID, MODES_KEY, szBuf, sizeof(szBuf))))
      return E_FAIL;
   return(GetStringField(szBuf, uModeNum, pszMode, dwSize) ? NOERROR : E_FAIL);
   
}

STDMETHODIMP CCifComponent::GetGroup(LPSTR pszID, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, GROUP_KEY, "", pszID, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL); 
}

STDMETHODIMP CCifComponent::IsUIVisible()
{
   return(GetPrivateProfileInt(_szID, UIVISIBLE_KEY, 1, _pCif->GetCifPath()) ? S_OK : S_FALSE);
}


STDMETHODIMP CCifComponent::GetPatchID(LPSTR pszID, DWORD dwSize)
{
   return(GetPrivateProfileString(_szID, PATCHID_KEY, "", pszID, dwSize, _pCif->GetCifPath()) ? NOERROR : E_FAIL); 
}

STDMETHODIMP CCifComponent::GetTreatAsOneComponents(UINT uNum, LPSTR pszID, DWORD dwBuf)
{
   char szBuf[MAX_VALUE_LEN];

   szBuf[0] = '\0';

   GetPrivateProfileString(_szID, TREATAS_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath());
   return(GetStringField(szBuf, uNum, pszID, dwBuf) ? NOERROR : E_FAIL);
}

STDMETHODIMP CCifComponent::GetCustomData(LPSTR pszKey, LPSTR pszData, DWORD dwSize)
{
   char szNewKey[MAX_VALUE_LEN];

   wsprintf(szNewKey, "_%s", pszKey);

   return(MyTranslateString(_pCif->GetCifPath(), _szID, szNewKey, pszData, dwSize));
}


STDMETHODIMP_(DWORD) CCifComponent::IsComponentInstalled()
{
   CHAR szCifBuf[512];
   CHAR szCompBuf[512];
   CHAR szGUID[MAX_VALUE_LEN];
   CHAR szLocale[8];
   HKEY hComponentKey = NULL;
   DETECTION_STRUCT Det;
   
   DWORD dwCifVer, dwCifBuild, dwInstalledVer, dwInstalledBuild;
   DWORD dwUnused, dwType, dwIsInstalled;
   BOOL bVersionFound = FALSE;
   
   if(_uInstallStatus  != ICI_NOTINITIALIZED)
      return _uInstallStatus;

   _uInstallStatus = ICI_NOTINSTALLED;

   // use detection dll first if it is available
   if ( SUCCEEDED(GetDetVersion(szCifBuf, sizeof(szCifBuf), szCompBuf, sizeof(szCompBuf))))
   {
      GetVersion(&dwCifVer, &dwCifBuild);
      Det.dwSize = sizeof(DETECTION_STRUCT);
      Det.pdwInstalledVer = &dwInstalledVer;
      Det.pdwInstalledBuild = &dwInstalledBuild;
      GetLocale(szLocale, sizeof(szLocale));
      Det.pszLocale = szLocale;
      GetGUID(szGUID, sizeof(szGUID));
      Det.pszGUID = szGUID;
      Det.dwAskVer = dwCifVer;
      Det.dwAskBuild = dwCifBuild;
      Det.pCifFile = (ICifFile *) _pCif;
      Det.pCifComp = (ICifComponent *) this; 
      if (SUCCEEDED(_GetDetVerResult(szCifBuf, szCompBuf, &Det, &_uInstallStatus)))
      {
         // only wizard want to know this status, if the newer version is installed, means Installed.
         if (_uInstallStatus == ICI_OLDVERSIONAVAILABLE)
            _uInstallStatus = ICI_INSTALLED;
         return _uInstallStatus;
      }
   }
   
   // Build GUID Key
   lstrcpy(szCompBuf, COMPONENT_KEY);
   lstrcat(szCompBuf, "\\");
   GetGUID(szCifBuf, sizeof(szCifBuf));
   lstrcat(szCompBuf, szCifBuf);

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szCompBuf, 0, KEY_READ, &hComponentKey) == ERROR_SUCCESS)
   {
      // first check for the IsInstalled valuename
      // if the valuename is there AND equals zero, we say not installed.
      // otherwise continue.
      // NOTE: We default to ISINSTALLED_YES if valuename not present to be Back-compatible
      // with when we didn't write this valuename at all.....

      dwUnused = sizeof(dwIsInstalled);
      if(RegQueryValueEx(hComponentKey, ISINSTALLED_KEY, 0, NULL, (LPBYTE) (&dwIsInstalled), &dwUnused) != ERROR_SUCCESS)
         dwIsInstalled = ISINSTALLED_YES;
           
      if(dwIsInstalled == ISINSTALLED_YES)
      {

         // next check for a locale match (no locale entry use default)
         dwUnused = sizeof(szCompBuf);
         if(RegQueryValueEx(hComponentKey, LOCALE_KEY, 0, NULL, (LPBYTE) szCompBuf, &dwUnused) != ERROR_SUCCESS)
            lstrcpy(szCompBuf, DEFAULT_LOCALE);

         GetLocale(szCifBuf, sizeof(szCifBuf));
         
         if(_fBeforeInstall || (CompareLocales(szCompBuf, szCifBuf) == 0))
         {
            // locales match so go check the version
                 
            // first check for updated version key
            dwUnused = sizeof(szCompBuf);
            bVersionFound = (RegQueryValueEx(hComponentKey, QFE_VERSION_KEY, 
                    0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
            
              // if QFEVersion doesn't exist, look for version
            if(!bVersionFound)
            {
               dwUnused = sizeof(szCompBuf);
               bVersionFound = (RegQueryValueEx(hComponentKey, VERSION_KEY, 
                    0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
            }

            // figure out if we have REG_STR 
            if(bVersionFound)
            {
               // if we have a string convert to ver, if we have binary directly copy into version struct
               if(dwType == REG_SZ)
               {
                  ConvertVersionStrToDwords(szCompBuf, &dwInstalledVer, &dwInstalledBuild);
               
                  GetVersion(&dwCifVer, &dwCifBuild);
               
                  if( (dwInstalledVer >  dwCifVer) ||
                     ((dwInstalledVer == dwCifVer) && (dwInstalledBuild >= dwCifBuild)) )
                  {
                     _uInstallStatus = ICI_INSTALLED;
                  }
                  else
                  {
                     _uInstallStatus = ICI_NEWVERSIONAVAILABLE;
                  }
               }
               else
                  _uInstallStatus = ICI_NEWVERSIONAVAILABLE;
            }
         }
      }
   }
   if(hComponentKey)
      RegCloseKey(hComponentKey);
   
   // We think its installed, now check 
   if(_uInstallStatus != ICI_NOTINSTALLED)
   {
      // if there is an uninstall key to check do it
      if(SUCCEEDED(GetUninstallKey(szCompBuf, sizeof(szCompBuf))))
      {
         
         if(!UninstallKeyExists(szCompBuf))
         {   
            _uInstallStatus = ICI_NOTINSTALLED;
         }
         else
         {
            // if there is a success key to check do it
            if(SUCCEEDED(GetSuccessKey(szCompBuf, sizeof(szCompBuf))))
            {
               if(!SuccessCheck(szCompBuf))
               {   
                  _uInstallStatus = ICI_NOTINSTALLED;
               }
            }
         }
      }
   }
   return _uInstallStatus;
}

   

STDMETHODIMP CCifComponent::IsComponentDownloaded()
{
   if(GetActualDownloadSize() == 0)
      return S_OK;
   else
      return S_FALSE;
}

STDMETHODIMP_(DWORD) CCifComponent::IsThisVersionInstalled(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   CHAR szCifBuf[512];
   CHAR szCompBuf[512];
   CHAR szLocale[8];
   CHAR szGUID[MAX_VALUE_LEN];
   DETECTION_STRUCT Det;
   HKEY hComponentKey = NULL;
   UINT uStatus = ICI_NOTINSTALLED;

   *pdwVersion = 0;
   *pdwBuild = 0;
   
   // use detection dll first if it is available
   if ( SUCCEEDED(GetDetVersion(szCifBuf, sizeof(szCifBuf), szCompBuf, sizeof(szCompBuf))))
   {
      Det.dwSize = sizeof(DETECTION_STRUCT);
      Det.pdwInstalledVer = pdwVersion;
      Det.pdwInstalledBuild = pdwBuild;
      GetLocale(szLocale, sizeof(szLocale));
      Det.pszLocale = szLocale;
      GetGUID(szGUID, sizeof(szGUID));
      Det.pszGUID = szGUID;
      Det.dwAskVer = dwAskVer;
      Det.dwAskBuild = dwAskBld;
      Det.pCifFile = (ICifFile *) _pCif;
      Det.pCifComp = (ICifComponent *) this; 
      if (SUCCEEDED(_GetDetVerResult(szCifBuf, szCompBuf, &Det, &uStatus)))
      {
         return uStatus;
      }
   }

   if(IsComponentInstalled() == ICI_NOTINSTALLED)
      return uStatus;

   DWORD dwUnused, dwType;
   BOOL bVersionFound = FALSE;

    // Build GUID Key
   lstrcpy(szCompBuf, COMPONENT_KEY);
   lstrcat(szCompBuf, "\\");
   GetGUID(szCifBuf, sizeof(szCifBuf));
   lstrcat(szCompBuf, szCifBuf);

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szCompBuf, 0, KEY_READ, &hComponentKey) == ERROR_SUCCESS)
   {
      // first check for updated version key
      dwUnused = sizeof(szCompBuf);
      bVersionFound = (RegQueryValueEx(hComponentKey, QFE_VERSION_KEY, 
                0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
            
      // if QFEVersion doesn't exist, look for version
      if(!bVersionFound)
      {
         dwUnused = sizeof(szCompBuf);
         bVersionFound = (RegQueryValueEx(hComponentKey, VERSION_KEY, 
                  0, &dwType, (LPBYTE) szCompBuf, &dwUnused) == ERROR_SUCCESS);
      }

      //figure out if we have REG_STR 
      if(bVersionFound)
      {
         // if we have a string convert to ver, if we have binary directly copy into version struct
         if(dwType == REG_SZ)
         {
            ConvertVersionStrToDwords(szCompBuf, pdwVersion, pdwBuild);

            if((*pdwVersion == dwAskVer) && (*pdwBuild == dwAskBld) )
            {
               uStatus = ICI_INSTALLED;
            }
            else if ((*pdwVersion >  dwAskVer) ||
                     (*pdwVersion == dwAskVer) && (*pdwBuild > dwAskBld) )
            {
               uStatus = ICI_OLDVERSIONAVAILABLE;
            }
            else
            {
               uStatus = ICI_NEWVERSIONAVAILABLE;
            }            
         }
         else
            uStatus = ICI_NEWVERSIONAVAILABLE;
      }
      RegCloseKey(hComponentKey);
   }
   return uStatus;
}
 
STDMETHODIMP_(DWORD) CCifComponent::GetInstallQueueState()
{
   if(_uInstallCount)
      return SETACTION_INSTALL;
   else
      return SETACTION_NONE;
}

STDMETHODIMP CCifComponent::SetInstallQueueState(DWORD dwState)
{
   HRESULT hr = NOERROR;
   DWORD  uDependencyAction; 
   char szCompBuf[MAX_ID_LENGTH];
   char chType;
   ICifComponent *pcomp;
   BOOL fProcessDependencies = TRUE;

   // check to see if we allow install on this platform
   if((dwState != SETACTION_NONE) && (dwState != SETACTION_DEPENDENCYNONE) && 
      !_pCif->GetInstallEngine()->AllowCrossPlatform())
   {
      if(!(GetPlatform() & GetCurrentPlatform()))
         return S_FALSE;
   }

   switch(dwState)
   {
      case SETACTION_INSTALL:
         // check if it was already on. If so, don't process dependencies
         if(_uInstallCount & 0x80000000)
            fProcessDependencies = FALSE;
         
         _uInstallCount |= 0x80000000;
         uDependencyAction = SETACTION_DEPENDENCYINSTALL;
         break;
      case SETACTION_DEPENDENCYINSTALL:
         _uInstallCount++;
         uDependencyAction = SETACTION_DEPENDENCYINSTALL;
         break;
      case SETACTION_NONE:
         // check if it was not on to begin with. If not, don't process dependencies
         if(!(_uInstallCount & 0x80000000))
            fProcessDependencies = FALSE;

         _uInstallCount &= 0x7fffffff;
         uDependencyAction = SETACTION_DEPENDENCYNONE;
         break;
      case SETACTION_DEPENDENCYNONE:
         // if our depdency refcount is greater than zero, decrement it.
         // this allows us to unconditionally call this when an item is "unqueued"
         if(_uInstallCount & 0x7fffffff) _uInstallCount--;
         uDependencyAction = SETACTION_DEPENDENCYNONE;
         break;
      default:
         hr = E_INVALIDARG;
         break;
   }
   
   // now set each dependency, if needed
   if(SUCCEEDED(hr) && fProcessDependencies)
   {
      if(!_fDependenciesQueued)
      {
         _fDependenciesQueued = TRUE;
         DWORD dwNeedVer, dwNeedBuild, dwInsVer, dwInsBuild;
         for(int i = 0; SUCCEEDED(GetDependency(i, szCompBuf, sizeof(szCompBuf), &chType, &dwNeedVer, &dwNeedBuild)); i++)
         {
            if(chType == DEP_INSTALL || chType == DEP_BUDDY)
            {
               if(SUCCEEDED(_pCif->FindComponent(szCompBuf, &pcomp)))
               {
                  // queue for install if
                  //  1. Not installed
                  //  2. Not a good enough version
                  //  3. FORCEDEPENDIECIES is set
                  UINT uStatus = pcomp->IsThisVersionInstalled(dwNeedVer, dwNeedBuild, &dwInsVer, &dwInsBuild);
                  if( (uStatus == ICI_NOTINSTALLED) || 
                      (uStatus == ICI_NEWVERSIONAVAILABLE) ||
                      (_pCif->GetInstallEngine()->ForceDependencies()) )
                     pcomp->SetInstallQueueState(uDependencyAction);
               }

            }
         }
            
         _fDependenciesQueued = FALSE;
      }
   }
   
   
   return hr;
}
 

STDMETHODIMP_(DWORD) CCifComponent::GetActualDownloadSize()
{
   char szCompBuf[MAX_PATH];
   LPSTR pszFilename = NULL;
   LPSTR pszPathEnd = NULL;
   DWORD dwUrlSize, dwFlags;
   DWORD dwTotalSize = 0;
   BOOL alldownloaded = TRUE;

   if (_fUseSRLite)
   {
       // Let the patching engine determine the correct value
       dwTotalSize = 0;
   }
   else
   {

       if(_CompareDownloadInfo())
       {
          // so our versions match correctly, check each file
          for(UINT i = 0; SUCCEEDED(GetUrl(i, szCompBuf, sizeof(szCompBuf), &dwFlags)); i++)  
          {
             pszFilename = ParseURLA(szCompBuf);

             if(_FileIsDownloaded(pszFilename, i, &dwUrlSize))
                dwTotalSize += dwUrlSize;
             else
                alldownloaded = FALSE;
          }
       }
       else
          alldownloaded = FALSE;

       if(alldownloaded)
          dwTotalSize = 0;
       else
          dwTotalSize = GetDownloadSize() - (dwTotalSize >> 10);
   }

   return dwTotalSize;
}

HRESULT CCifComponent::OnProgress(ULONG uProgSoFar, LPCSTR pszStatus)
{
   _uIndivProgress = uProgSoFar;
   if(_uTotalProgress + _uIndivProgress > _uTotalGoal)
      _uIndivProgress = _uTotalGoal - _uTotalProgress;

   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, 
                               pszStatus, _uTotalProgress + _uIndivProgress, _uTotalGoal); 

   return NOERROR;
}
 


STDMETHODIMP_(DWORD) CCifComponent::GetCurrentPriority()
{
   if(_uPriority == 0xffffffff)
   {
      char szID[MAX_ID_LENGTH];
      ICifGroup *pgrp;

      _uPriority = 0;
      GetGroup(szID, sizeof(szID));
      
      if(SUCCEEDED(_pCif->FindGroup(szID, &pgrp)))
      {
         _uPriority = pgrp->GetCurrentPriority();
      }
      _uPriority += GetPriority();
   }
   return _uPriority;
}

STDMETHODIMP CCifComponent::SetCurrentPriority(DWORD dwPriority)
{
   _uPriority = dwPriority;

   // priorities may have changed need to resort
   _pCif->ReinsertComponent(this);
   return NOERROR;
}

HRESULT CCifComponent::Download()
{
   char szBuf[INTERNET_MAX_URL_LENGTH];
   HRESULT hr = NOERROR;
   DWORD uType;

   GetDescription(_szDesc, sizeof(_szDesc));
   // BUGBUG:  Download size isn't accurate for SR lite and patching
   _uTotalGoal = GetActualDownloadSize();

   // Engage SR lite behavior only if we're going to install the component,
   // and the new advpack extension is available.
   DWORD dwOptions = 0;
   BOOL fRetryClassic = TRUE;
   CHAR szCompBuf[MAX_VALUE_LEN];
   CHAR szDir[MAX_PATH];
   LPSTR pszSubDir = NULL;
   CHAR szCanPatch[MAX_VALUE_LEN];

   lstrcpyn(szDir, _pCif->GetDownloadDir(), sizeof(szDir));
   SetDownloadDir(szDir);

   if (IsPatchableIEVersion() &&
       SUCCEEDED(_pCif->GetInstallEngine()->GetInstallOptions(&dwOptions)) &&
       (dwOptions & INSTALLOPTIONS_INSTALL) &&
       (dwOptions & INSTALLOPTIONS_DOWNLOAD) &&
       _pCif->GetInstallEngine()->IsAdvpackExtAvailable() &&
       _pCif->GetInstallEngine()->GetPatchDownloader()->IsEnabled() &&
       SUCCEEDED(GetCustomData(gszIsPatchable, szCanPatch, sizeof(szCanPatch))) &&
       lstrcmp(szCanPatch, "1") == 0)
   {
       _fUseSRLite = TRUE;
       // Adjust the download directory
       // The idea here is that the download directory will contain
       // subdirectories which will contain the empty cabs + inf +
       // the downloaded files.
       //
       GetID(szCompBuf, sizeof(szCompBuf));

       wsprintf(szLogBuf, "Attempting to download empty cabs for %s\r\n", szCompBuf);
       _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);

       AddPath(szDir, szCompBuf);
       SetDownloadDir(szDir);

       if (GetFileAttributes(szDir) == 0xFFFFFFFF)
           CreateDirectory(szDir, NULL);
   }
   
   _pCif->GetInstallEngine()->OnStartComponent(_szID, _uTotalGoal, 0 , _szDesc);

   _MarkDownloadStarted();

   // check for disk space
   _uPhase = INSTALLSTATUS_INITIALIZING;
   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 

   if(!IsEnoughSpace(GetDownloadDir(), _uTotalGoal))
      hr = E_FAIL;
   
   _uTotalProgress = 0;
   for(int i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szBuf, sizeof(szBuf), &uType)); i++)
   {
      // Change the download loc to point to the special
      // "empty cab" location, so we can download the empty
      // cabs + the INF that will contain instructions for
      // generating the file list for this type of installation.
      //
      // Assume the new download loc to be in the "patch" subdirectory
      // relative to the passed in URL
      //
      // BUGBUG... only handle the case for relative URLs
      if (_fUseSRLite && (uType & URLF_RELATIVEURL) && lstrlen(c_gszSRLiteOffset) + lstrlen(szBuf) < INTERNET_MAX_URL_LENGTH)
      {
          char szBuf2[INTERNET_MAX_URL_LENGTH];
          lstrcpy(szBuf2, c_gszSRLiteOffset);
          lstrcat(szBuf2, szBuf);
          
          hr = _DownloadUrl(i, szBuf2, uType);

          wsprintf(szLogBuf, "Empty cab download of %s returned 0x%lx\r\n", szBuf2, hr);
          _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
      }
      else
      {
          wsprintf(szLogBuf, "Initial download attempt will be tried as a full download.\r\n");
          _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
          // No need to retry because the first attempt will be the old way...
          fRetryClassic = FALSE;

          // Restore the download dir to the same state as a normal
          // full download.
          if (_fUseSRLite)
          {
              SetDownloadDir(_pCif->GetDownloadDir());

              // Ensure we're set to false...just in case there was a problem
              // with obtaining the URL for the SR Lite download.
              _fUseSRLite = FALSE;
          }
          hr = _DownloadUrl(i, szBuf, uType);
      }
   }

   if (_fUseSRLite && SUCCEEDED(hr))
   {
       // Ok...time for the real action of using advpext.dll to
       // download the needed files.
       hr = _SRLiteDownloadFiles();
   }

   if (_fUseSRLite && !SUCCEEDED(hr))
   {
       DelNode(szDir, 0);
       // Restore the download dir
       SetDownloadDir(_pCif->GetDownloadDir());
   }

   if(SUCCEEDED(hr))
      _uPhase = INSTALLSTATUS_DOWNLOADFINISHED;
   else if (_fUseSRLite && fRetryClassic)
   {
       // Fall back to downloading the full cabs.
       _fUseSRLite = FALSE;

       _pCif->GetInstallEngine()->WriteToLog("Retrying via full download\r\n", FALSE);

       hr = S_OK;
       // this re-sets the progress for the retry 
       _uPhase = INSTALLSTATUS_DOWNLOADING;
       _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 
       _uTotalProgress = 0;

       for(int i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szBuf, sizeof(szBuf), &uType)); i++)
       {
          hr = _DownloadUrl(i, szBuf, uType);
       }
       if(SUCCEEDED(hr))
          _uPhase = INSTALLSTATUS_DOWNLOADFINISHED;
   }
   
   _pCif->GetInstallEngine()->OnStopComponent(_szID, hr, _uPhase, _szDesc, 0);
   return hr;
}

HRESULT CCifComponent::_DownloadUrl(UINT uUrlNum, LPCSTR pszUrl, UINT uType)
{
   // call the downloader
   // check the file
   // if good
   //     move to download dir
   // else
   //     redo
   HRESULT hr;
   char szTempfile[MAX_PATH];
   char szFullUrl[INTERNET_MAX_URL_LENGTH];
   UINT uStartProgress;
   char szDest[MAX_PATH];
   char szTimeStamp[MAX_PATH*2];


   _uPhase = INSTALLSTATUS_DOWNLOADING;
      
   if(_FileIsDownloaded(ParseURLA(pszUrl), uUrlNum, NULL))
      return NOERROR;

   
   CDownloader *pDL = _pCif->GetInstallEngine()->GetDownloader();
   
   
   
   uStartProgress = _uTotalProgress;

   
   // retry until success
   // save starting progress in case we retry
   hr = E_FAIL;
   for(int i = 1; i <= NUM_RETRIES && FAILED(hr) && (hr != E_ABORT); i++)
   {
      _uTotalProgress = uStartProgress;
      
      if(uType & URLF_RELATIVEURL)
      {
         lstrcpyn(szFullUrl, _pCif->GetInstallEngine()->GetBaseUrl(),
                  INTERNET_MAX_URL_LENGTH - (lstrlen(pszUrl) + 2));
         lstrcat(szFullUrl, "/");
         lstrcat(szFullUrl, pszUrl);
      }
      else
         lstrcpy(szFullUrl, pszUrl);
	  
	   if(SUCCEEDED(_pCif->GetInstallEngine()->CheckForContinue()))
      {
         DWORD dwFlags = 0;

         if(_pCif->GetInstallEngine()->UseCache())
            dwFlags |= DOWNLOADFLAGS_USEWRITECACHE;

         hr = pDL->SetupDownload(szFullUrl, (IMyDownloadCallback *) this, dwFlags, NULL);
         szTempfile[0] = 0;
         if(SUCCEEDED(hr))
		 {
			// Log the start time.
			wsprintf(szLogBuf, "     Downloading : %s\r\n", szFullUrl);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
			GetTimeDateStamp(szTimeStamp);
			wsprintf(szLogBuf, "       Start : %s\r\n", szTimeStamp);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);

            hr = pDL->DoDownload(szTempfile, sizeof(szTempfile));
			
			// Log the stop time.
			GetTimeDateStamp(szTimeStamp);
			wsprintf(szLogBuf, "       Stop  : %s\r\n", szTimeStamp);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
			wsprintf(szLogBuf, "       Result: %x (%s)\r\n", hr, SUCCEEDED(hr) ? STR_OK : STR_FAILED);
			_pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
		 }
      }
      else
         hr = E_ABORT;
      
      if(SUCCEEDED(hr))
      {
         // Check if it is save to download from this URL
         _uPhase = INSTALLSTATUS_CHECKINGTRUST;
         
         hr = _pCif->GetInstallEngine()->CheckForContinue();
         
         if(SUCCEEDED(hr))
            hr = _CheckForTrust(szFullUrl, szTempfile);

         if(SUCCEEDED(hr) && (hr == S_FALSE) )
         {
            DWORD dwMin, dwMax;
            DWORD dwFileSize = 0;
            dwFileSize = MyGetFileSize(szTempfile);
            dwFileSize = dwFileSize >> 10;
/*
            // Open the file
            HANDLE h = CreateFile(szTempfile, GENERIC_READ, 0, NULL, 
               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  
            
            if(h != INVALID_HANDLE_VALUE)
            {
               dwFileSize = GetFileSize(h, NULL);
               CloseHandle(h);
            }
*/
            GetUrlCheckRange(uUrlNum, &dwMin, &dwMax);
            if(dwMin != 0)
            {
               if(dwMin > dwFileSize || dwMax < dwFileSize)
                  hr = E_FAIL;
               else
                  hr = S_OK;
            }
         }
         
         if(SUCCEEDED(hr))
            hr = _pCif->GetInstallEngine()->CheckForContinue();
         
      
         // so now we downloaded and checked
         // if it is OK, move to download dir
         if(SUCCEEDED(hr))
         {
            lstrcpy(szDest, GetDownloadDir());
            AddPath(szDest, ParseURLA(pszUrl));
          
            if(!CopyFile(szTempfile, szDest, FALSE))
            {
                wsprintf(szLogBuf, "CopyFile FAILED, szTempfile=%s, szDest=%s\r\n", szTempfile, szDest);
                _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
                hr = E_FAIL;
            }

            _uTotalProgress += _uIndivProgress;
         }
      
         // delete the temp download copy
         if(szTempfile[0] != 0)
         {
            GetParentDir(szTempfile);
            DelNode(szTempfile, 0);
         }
      
      }    
         
         
      if(FAILED(hr) && (hr != E_ABORT))
      {
         // we failed 
         // if this is last retry, call EngineProblem
         // else just retry
         if(i == NUM_RETRIES)
         {
            HRESULT hEngProb;
            DWORD dwResult = 0;
            
            hEngProb = _pCif->GetInstallEngine()->OnEngineProblem(ENGINEPROBLEM_DOWNLOADFAIL, &dwResult);
            if(hEngProb == S_OK)
            {
               if(dwResult == DOWNLOADFAIL_RETRY)
                  i = 0;
            }
         }
      }   
   }   
   if(SUCCEEDED(hr))
      _MarkFileDownloadFinished(szDest, uUrlNum, ParseURLA(pszUrl));
   
   return hr;
}

HRESULT CCifComponent::Install()
{
   CHAR szCompBuf[MAX_PATH];
   HKEY hKey;
   DWORD dwWin, dwApp;
   HRESULT hr = NOERROR;
   DWORD dwStatus = 0;

   GetTimeDateStamp(szCompBuf);
   wsprintf(szLogBuf, "       Start : %s\r\n", szCompBuf);
   _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);

   szCompBuf[0] = 0;
    
   _uInstallStatus = ICI_NOTINITIALIZED;

   GetDescription(_szDesc, sizeof(_szDesc));
   
   GetInstalledSize(&dwWin, &dwApp);
   _uTotalGoal = dwWin + dwApp;
   _pCif->GetInstallEngine()->OnStartComponent(_szID, 0, _uTotalGoal, _szDesc);

   _uPhase = INSTALLSTATUS_DEPENDENCY;
   hr = _CheckForDependencies();
   
   // check for disk space here
   if(SUCCEEDED(hr))
   {
      _uPhase = INSTALLSTATUS_INITIALIZING;
      _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 
      hr = CreateTempDir(GetDownloadSize(), GetExtractSize(), _pCif->GetInstallEngine()->GetInstallDrive(),
                         dwApp, dwWin, szCompBuf, sizeof(szCompBuf), 0); 
   }

   if(SUCCEEDED(hr))
   {
      if( IsNT() && (RequiresAdminRights() == S_OK) && !IsNTAdmin(0,NULL))
      {
         hr = E_ACCESSDENIED;
         _pCif->GetInstallEngine()->WriteToLog("Admin Check failed\n", TRUE);
      }
   }

   _uTotalProgress = 0;
      
   // BUGBUG:  ie6wzd sets the download directory for non web-based
   //          installs at a later time.  Make sure it's set here
   //          if we weren't successful with installing via SR Lite.
   if (lstrlen(GetDownloadDir()) == 0)
   {
       SetDownloadDir(_pCif->GetDownloadDir());
   }

   if(SUCCEEDED(hr))
   {
      hr = _CopyAllUrls(szCompBuf);
   
      if(SUCCEEDED(hr))
      {
         // The new PerUser method requires to leave the IsInstalled flag & StubPath as it was
         //_MarkComponentInstallStarted();

         _pCif->GetInstallEngine()->GetInstaller()->StartClock();

         hr = _RunAllCommands(szCompBuf, &dwStatus);
      }
   }
 
   if(szCompBuf[0] != 0)
      DelNode(szCompBuf, 0);

   if(SUCCEEDED(hr))
   {
      _fBeforeInstall = FALSE;
      // we think it made it, now double check
      if(IsActiveSetupAware() == S_OK)
      {
         if(IsComponentInstalled() != ICI_INSTALLED)
         {
               // we think they made it but they didn't write their key ...
            _pCif->GetInstallEngine()->WriteToLog("Component did not write to InstalledComponent branch\r\n", TRUE);
            hr = E_FAIL;
         }
      }
      else
      {
         char szCompBuf[MAX_VALUE_LEN];
         // if there is an uninstall key to check do it
         if(SUCCEEDED(GetUninstallKey(szCompBuf, sizeof(szCompBuf))))
         {
            if(!UninstallKeyExists(szCompBuf))
            {
               _pCif->GetInstallEngine()->WriteToLog("UninstallKey check failed\r\n", TRUE);
               hr = E_FAIL;
            }
            else
            {
               // if there is a success key to check do it
               if(SUCCEEDED(GetSuccessKey(szCompBuf, sizeof(szCompBuf))))
               {
                  if(!SuccessCheck(szCompBuf))
                  {   
                     _pCif->GetInstallEngine()->WriteToLog("Success key check failed\r\n", TRUE);
                     hr = E_FAIL;
                  }
               }
            }
         }
      }
   }    
   
   _pCif->RemoveFromCriticalComponents(this);

   if(SUCCEEDED(hr))
   {
      _MarkAsInstalled();
   
      _pCif->MarkCriticalComponents(this);
   
      _uPhase = INSTALLSTATUS_FINISHED;
      _pCif->GetInstallEngine()->GetInstaller()->SetBytes((dwWin + dwApp) << 10, TRUE);
      if(IsRebootRequired() == S_OK)
      {
         dwStatus |= STOPINSTALL_REBOOTNEEDED;
      }
      _pCif->GetInstallEngine()->SetStatus(dwStatus);
   }
   _pCif->GetInstallEngine()->GetInstaller()->StopClock();
   _pCif->GetInstallEngine()->OnStopComponent(_szID, hr, _uPhase, _szDesc, dwStatus);
   GetTimeDateStamp(szCompBuf);
   wsprintf(szLogBuf, "       Stop  : %s\r\n", szCompBuf);
   _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
   return hr;
}

HRESULT CCifComponent::_RunAllCommands(LPCSTR pszDir, DWORD *pdwStatus)
{
   char szCmd[MAX_PATH];
   char szArg[MAX_VALUE_LEN];
   char szProg[MAX_VALUE_LEN];
   char szCancel[MAX_VALUE_LEN];
   char szPath[] = "X:\\";
   DWORD dwWinSpace, dwInstallSpace;
   
   DWORD dwType;
   HRESULT hr = NOERROR;
   
   // Save the widows space and install drive space
   szPath[0] = g_szWindowsDir[0];
   dwWinSpace = GetSpace(szPath);
   if(szPath[0] != _pCif->GetInstallEngine()->GetInstallDrive())
   {
      szPath[0] = _pCif->GetInstallEngine()->GetInstallDrive();
      dwInstallSpace = GetSpace(szPath);
   }
   else
   {
      dwInstallSpace = 0;
   }

   

   _uTotalProgress = 0;
   _uPhase = INSTALLSTATUS_RUNNING;
   _pCif->GetInstallEngine()->OnComponentProgress(_szID, INSTALLSTATUS_RUNNING,
                                _szDesc, NULL, _uTotalProgress, _uTotalGoal); 

   
   hr = _pCif->GetInstallEngine()->CheckForContinue();
            
   for(UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(GetCommand(i, szCmd, sizeof(szCmd), szArg, sizeof(szArg), &dwType)); i++)
   {
      _uIndivProgress = 0;
      GetProgressKeys(szProg, sizeof(szProg), szCancel, sizeof(szCancel));
      hr = _pCif->GetInstallEngine()->GetInstaller()->DoInstall(pszDir, szCmd, szArg, 
                          lstrlen(szProg) ? szProg : NULL, lstrlen(szCancel) ? szCancel : NULL,
                          dwType, pdwStatus, (IMyDownloadCallback *) this) ;
      _uTotalProgress += _uIndivProgress;
   }
   
   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, _uTotalGoal,_uTotalGoal); 

   // figure how much we used, and log it
   szPath[0] = g_szWindowsDir[0];
   dwWinSpace = dwWinSpace - GetSpace(szPath);
   if(szPath[0] != _pCif->GetInstallEngine()->GetInstallDrive())
   {
      szPath[0] = _pCif->GetInstallEngine()->GetInstallDrive();
      dwInstallSpace = dwInstallSpace - GetSpace(szPath);
   }
   
   // log the space used
   wsprintf(szCmd, "SpaceUsed: Windows drive: %d   InstallDrive: %d\r\n", dwWinSpace, dwInstallSpace);
   _pCif->GetInstallEngine()->WriteToLog(szCmd, FALSE);
   
   
   return hr;
}




HRESULT CCifComponent::_CopyAllUrls(LPCSTR pszTemp)
{
   char szCompBuf[MAX_VALUE_LEN];
   char szDest[MAX_PATH];
   char szSource[MAX_PATH];
   DWORD dwType;
   HRESULT hr = NOERROR;
   HANDLE hFind;
   WIN32_FIND_DATA ffd;
   char szBuf[MAX_PATH];
    
   
   for(UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szCompBuf, sizeof(szCompBuf), &dwType)) ; i++)
   {
       _uPhase = INSTALLSTATUS_COPYING;
       _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0); 
       
       lstrcpy(szSource, GetDownloadDir());
       AddPath(szSource, ParseURLA(szCompBuf));

       lstrcpy(szDest, pszTemp);
       AddPath(szDest, ParseURLA(szCompBuf));

       // Copy the file
       if(!CopyFile(szSource, szDest, FALSE))
       {
          wsprintf(szLogBuf, "CopyFile failed for szSource=%s, szDest=%s, DLDir=%s\r\n", szSource, szDest, GetDownloadDir());
          _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
          hr = E_FILESMISSING;
       } 
       
       if(SUCCEEDED(hr))
          hr = _pCif->GetInstallEngine()->CheckForContinue();
       
       if(SUCCEEDED(hr)) 
       {
          _uPhase = INSTALLSTATUS_CHECKINGTRUST;
          
          hr = _CheckForTrust(szSource, szDest);
          
          if(FAILED(hr))
          {
             DeleteFile(szSource);
          }
       }
       
       if(SUCCEEDED(hr))
          hr = _pCif->GetInstallEngine()->CheckForContinue();
       
       if(SUCCEEDED(hr)) 
          hr = _ExtractFiles(i, szDest, dwType);
       
       if(SUCCEEDED(hr))
          hr = _pCif->GetInstallEngine()->CheckForContinue();
       

   }

   // Now, if we're attempting an SR Lite install, then after
   // extracting cab files to the temp directory...copy all of
   // downloaded files to the temp directory.
   if (_fUseSRLite)
   {
       lstrcpy(szSource, GetDownloadDir());
       AddPath(szSource, "*.*");

       if ( (hFind = FindFirstFile(szSource, &ffd)) != INVALID_HANDLE_VALUE)
       {
           do
           {
               if (ffd.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)
               {
                   lstrcpyn(szSource, GetDownloadDir(), sizeof(szSource));
                   SafeAddPath(szSource, ffd.cFileName, sizeof(szSource) - lstrlen(szSource));

                   lstrcpy(szDest, pszTemp);
                   AddPath(szDest, ffd.cFileName);
                   MoveFile(szSource, szDest);
               }
           } while (SUCCEEDED(hr) && FindNextFile(hFind, &ffd));
           FindClose(hFind);
       }
   }

   return hr;
}

STDMETHODIMP CCifComponent::GetDetVersion(LPSTR pszDll, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize)
{
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = E_FAIL;

   if(pszDll && pszEntry)
      *pszDll = *pszEntry = 0;
   else
      return hr;

   if(GetPrivateProfileString(_szID, DETVERSION_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath()))
   {
      if((GetStringField(szBuf, 0, pszDll, dwdllSize) != 0) && (GetStringField(szBuf, 1, pszEntry, dwentSize) != 0))
      {                       
         hr = NOERROR;
      }
   }
   return hr;
}

HRESULT CCifComponent::_GetDetVerResult(LPCSTR pszDll, LPCSTR pszEntry, DETECTION_STRUCT *pDet, UINT *puStatus)
{
   char szBuf[MAX_PATH];
   HRESULT hr = E_FAIL;
   HINSTANCE hLib;
   DETECTVERSION fpDetVer;

   *puStatus = ICI_NOTINSTALLED;

   if (pszDll && pszEntry)
   {
      if(_hDetLib && (lstrcmpi(pszDll, _szDetDllName) == 0))
      {
         hLib = _hDetLib;
      }
      else
      {
         lstrcpy(szBuf, _pCif->GetCifPath());
         GetParentDir(szBuf);
         AddPath(szBuf, pszDll);

         hLib = LoadLibrary(szBuf);
         if (hLib == NULL)
         {
            // if Cif folder failed try IE folder before using searching path
            if (SUCCEEDED(GetIEPath(szBuf, sizeof(szBuf))))
            {
               AddPath(szBuf, pszDll);
               hLib = LoadLibrary(szBuf);
            }
         }
         if(hLib)
         {
            lstrcpy(_szDetDllName, pszDll);
            _hDetLib = hLib;
         }         
      }

      if (hLib)
      {
         fpDetVer = (DETECTVERSION)GetProcAddress(hLib, pszEntry);
         if (fpDetVer)
         {
            switch(fpDetVer(pDet))
            {
               case DET_NOTINSTALLED:
                  *puStatus = ICI_NOTINSTALLED;
                  break;

               case DET_INSTALLED:
                  *puStatus = ICI_INSTALLED;
                  break;

               case DET_NEWVERSIONINSTALLED:
                  *puStatus = ICI_OLDVERSIONAVAILABLE;
                  break;
                                  
               case DET_OLDVERSIONINSTALLED:
                  *puStatus = ICI_NEWVERSIONAVAILABLE;
                  break;

            }
            hr = NOERROR;
         }
      
      }
   }
   
   return hr;
}






//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CCifComponent::_CheckForTrust(LPCSTR pszURL, LPCSTR pszFilename)
{
   HRESULT hr = S_FALSE;

   // BUGBUG: Our internal workaround for non signed stuff
//   if(rdwUrlFlags[i] & URLF_NOCHECKTRUST)
//      return S_OK;
   _uPhase = INSTALLSTATUS_CHECKINGTRUST;

   _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL,  0, 0);
   
  if(!_pCif->GetInstallEngine()->IgnoreTrustCheck())
      hr = ::CheckTrustEx(pszURL, pszFilename, _pCif->GetInstallEngine()->GetHWND(), FALSE, NULL);
   
   wsprintf(szLogBuf, "       CheckTrust: %s, Result: %x (%s)\r\n", pszFilename, hr, SUCCEEDED(hr) ? STR_OK : STR_FAILED);
   _pCif->GetInstallEngine()->WriteToLog(szLogBuf, TRUE);

   return hr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CCifComponent::_ExtractFiles(UINT i, LPCSTR pszFile, DWORD dwType)
{
   HRESULT hr = NOERROR;
   char szPath[MAX_PATH];
   char szExtractList[MAX_VALUE_LEN];

   // Need to pay attention to rdwUrlFlags[i] to see if there is anything to do
   if(dwType & URLF_EXTRACT)
   {
      _uPhase = INSTALLSTATUS_EXTRACTING;

      _pCif->GetInstallEngine()->OnComponentProgress(_szID, _uPhase, _szDesc, NULL, 0, 0);
     
      lstrcpy(szPath, pszFile);
      GetParentDir(szPath);
      
      GetFileExtractList(i, szExtractList, sizeof(szExtractList));
      hr=ExtractFiles(pszFile, szPath, 0, lstrlen(szExtractList) ? szExtractList : NULL, NULL, 0);
      
      wsprintf(szLogBuf, "File extraction: %s, Result: %x (%s)\r\n", pszFile, hr, SUCCEEDED(hr) ? STR_OK : STR_FAILED);
      _pCif->GetInstallEngine()->WriteToLog(szLogBuf, TRUE);

      // if the flag is set to delte the cab after an extract, do it
      // I don't really care too much if this fails, at least not 
      // enough to fail this component

      if(dwType & URLF_DELETE_AFTER_EXTRACT)
         DeleteFile(pszFile);
   }
   return hr;
}





void CCifComponent::_MarkComponentInstallStarted()
{
   char szReg[MAX_PATH];
   char szCompBuf[MAX_DISPLAYNAME_LENGTH];
   HKEY hKey;
   DWORD dwDumb;

   lstrcpy(szReg, COMPONENT_KEY);
   lstrcat(szReg, "\\");
   
   GetGUID(szCompBuf, sizeof(szCompBuf));
   lstrcat(szReg, szCompBuf);
   if(RegOpenKeyEx( HKEY_LOCAL_MACHINE, szReg, 0, 
                       KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
   {
      // Set IsInstalled=0
      dwDumb = ISINSTALLED_NO;
      RegSetValueExA(hKey, ISINSTALLED_KEY, 0, REG_DWORD, 
                       (BYTE *) &dwDumb , sizeof(dwDumb));

      // Delete StubPath so peruser isn't confused
      RegDeleteValue(hKey, STUBPATH_KEY);
      RegCloseKey(hKey);
   }
}


BOOL CCifComponent::_CompareDownloadInfo()
{
   char szCompBuf[MAX_VALUE_LEN];
   char szInfoBuf[128];
   DWORD dwCompVer, dwCompBuild, dwDLVer, dwDLBuild;

   // first check this is the same language
   GetPrivateProfileString(_szID, LOCALE_KEY, "", szInfoBuf, sizeof(szInfoBuf), _pCif->GetFilelist());
   GetLocale(szCompBuf, sizeof(szCompBuf));
   if(CompareLocales(szInfoBuf, szCompBuf) == 0)
   {
      // compare guids
      GetPrivateProfileString(_szID, GUID_KEY, "", szInfoBuf, sizeof(szInfoBuf), _pCif->GetFilelist());
      GetGUID(szCompBuf, sizeof(szCompBuf));
      // intentionally let blank guid match to be backward compatible
      if(lstrcmpi(szCompBuf, szInfoBuf) == 0)
      {

         GetPrivateProfileString(_szID, VERSION_KEY,"",szInfoBuf, 
                           sizeof(szInfoBuf), _pCif->GetFilelist()); 
         ConvertVersionStrToDwords(szInfoBuf, &dwDLVer, &dwDLBuild);
         GetVersion(&dwCompVer, &dwCompBuild);

         if((dwDLVer == dwCompVer) && (dwDLBuild == dwCompBuild))
            return TRUE;
      }
   }
   return FALSE;
}

BOOL CCifComponent::_FileIsDownloaded(LPCSTR pszFile, UINT i, DWORD *pdwSize)
{
   HANDLE h;
   DWORD dwSize, dwFileSize;
   char szKey[16];
   char szBuf[MAX_PATH];
 
   szBuf[0] = '\0'; 

   if(pdwSize)
      *pdwSize = 0;
   
   wsprintf(szKey, "URL%d", i);
   GetPrivateProfileString(_szID, szKey,"0",szBuf, 
                           sizeof(szBuf), _pCif->GetFilelist()); 
   dwSize = GetIntField(szBuf, 0, 0);
   
   if(dwSize == 0)
      return FALSE;

    if (_fUseSRLite && lstrlen(GetDownloadDir()) != 0)
       lstrcpy(szBuf, GetDownloadDir());
   else
       lstrcpy(szBuf, _pCif->GetDownloadDir());

   AddPath(szBuf, pszFile);
   dwFileSize = MyGetFileSize(szBuf);
/*
      // Open the file
   h = CreateFile(pszFile, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  
   
   if(h == INVALID_HANDLE_VALUE)
      return FALSE;

   // dont worry about files over 4 gig
   dwFileSize = GetFileSize(h, NULL);
   CloseHandle(h);
*/
   if(dwFileSize == dwSize)
   {
      if(pdwSize)
         *pdwSize = dwFileSize;
      return TRUE;   
   }

   return FALSE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

void CCifComponent::_MarkAsInstalled()
{
   CHAR szCompBuf[MAX_VALUE_LEN];
   HKEY hComponentKey = NULL;
   HKEY hGUIDKey = NULL;
   DWORD dwDumb, dwVer, dwBuild;
   LPSTR psz;
   
   if(RegCreateKeyExA(HKEY_LOCAL_MACHINE, COMPONENT_KEY, 0, 0, 0, 
                  KEY_WRITE, NULL, &hComponentKey, &dwDumb) == ERROR_SUCCESS)
   {
      GetGUID(szCompBuf, sizeof(szCompBuf));
      if(RegCreateKeyExA(hComponentKey, szCompBuf, 0, 0, 0, KEY_WRITE, NULL, &hGUIDKey, &dwDumb) == ERROR_SUCCESS)
      {
         // we only write to the key if this guy is NOT active setup aware
         if(IsActiveSetupAware() == S_FALSE)
         {
            // write Display name to Default
            GetDescription(szCompBuf, sizeof(szCompBuf));
            RegSetValueExA(hGUIDKey, NULL, 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1 );
            
            // write component ID
            GetID(szCompBuf, sizeof(szCompBuf));
            RegSetValueExA(hGUIDKey, "ComponentID", 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1 );
   
            // write out version
            GetVersion(&dwVer, &dwBuild);
            wsprintf(szCompBuf, "%d,%d,%d,%d", HIWORD(dwVer),LOWORD(dwVer),HIWORD(dwBuild),LOWORD(dwBuild));
            RegSetValueExA(hGUIDKey, VERSION_KEY, 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1);

            // write out locale
            GetLocale(szCompBuf, sizeof(szCompBuf));
            RegSetValueExA(hGUIDKey, LOCALE_KEY, 0, REG_SZ, (BYTE *)szCompBuf , lstrlen(szCompBuf) + 1);

            // Write out "IsInstalled=1"
            dwDumb = ISINSTALLED_YES;
            RegSetValueExA(hGUIDKey, ISINSTALLED_KEY, 0, REG_DWORD, (BYTE *) &dwDumb , sizeof(dwDumb));
         }
      }
   }

   if(hComponentKey)
      RegCloseKey(hComponentKey);

   if(hGUIDKey)
      RegCloseKey(hGUIDKey);
}


void CCifComponent::_MarkFileDownloadFinished(LPCSTR pszFilePath, UINT i, LPCSTR pszFilename)
{
   char szSize[MAX_PATH];
   char szKey[16];
   DWORD dwFileSize;
   HANDLE h;

   // put any entry in filelist.dat
   // [CompID]
   // URLi=Filesize

   dwFileSize = MyGetFileSize(pszFilePath);
/*
      // Create the file
   h = CreateFile(pszFilePath, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  
   
   if(h == INVALID_HANDLE_VALUE)
      return;

   // dont worry about files over 4 gig
   dwFileSize = GetFileSize(h, NULL);
   CloseHandle(h);
*/
   if(dwFileSize != 0xffffffff)
   {
      wsprintf(szKey, "URL%d", i);
      wsprintf(szSize, "%d,%s", dwFileSize, pszFilename);

      WritePrivateProfileString(_szID, szKey, szSize, _pCif->GetFilelist());

      // need to flush the pszFileList file; otherwise, with Stacker installed,
      // it GPFs when trying to open the file in another thread (bug #13041)
      WritePrivateProfileString(NULL, NULL, NULL, _pCif->GetFilelist());
   }
}

void CCifComponent::_MarkFileDownloadStarted(UINT i)
{
   char szKey[10];
  
   wsprintf(szKey, "URL%d", i);
  
   WritePrivateProfileString(_szID, szKey, NULL, _pCif->GetFilelist());

   // flush -- fixes the Stacker bug #13041
   WritePrivateProfileString(NULL, NULL, NULL, _pCif->GetFilelist());
}


void CCifComponent::_MarkDownloadStarted()
{
   char szCompBuf[MAX_VALUE_LEN];
   DWORD dwVer, dwBuild;

   // if the section doesn't match what we expect, we kill
   // section so we will redownload everything
   if(!_CompareDownloadInfo())
      WritePrivateProfileSection(_szID, NULL, _pCif->GetFilelist());   

   // write the version
   GetVersion(&dwVer, &dwBuild);
   wsprintf(szCompBuf, "%d,%d,%d,%d", HIWORD(dwVer),LOWORD(dwVer),HIWORD(dwBuild),LOWORD(dwBuild));
   WritePrivateProfileString(_szID, VERSION_KEY, szCompBuf, _pCif->GetFilelist());

   // write locale
   GetLocale(szCompBuf, sizeof(szCompBuf));
   WritePrivateProfileString(_szID, LOCALE_KEY, szCompBuf, _pCif->GetFilelist());
   
   // write the guid
   GetGUID(szCompBuf, sizeof(szCompBuf));
   WritePrivateProfileString(_szID, GUID_KEY, szCompBuf, _pCif->GetFilelist());
   
   // flush -- fixes the Stacker bug #13041
   WritePrivateProfileString(NULL, NULL, NULL, _pCif->GetFilelist());
}

HRESULT CCifComponent::_CheckForDependencies()
{
   char szCompBuf[MAX_ID_LENGTH];
   char chType;
   ICifComponent *pcomp;
   HRESULT hr = NOERROR;
   DWORD dwNeedVer, dwNeedBuild, dwInsVer, dwInsBuild;

   for(int i = 0; SUCCEEDED(GetDependency(i, szCompBuf, sizeof(szCompBuf), &chType, &dwNeedVer, &dwNeedBuild)); i++)
   {
      if(SUCCEEDED(_pCif->FindComponent(szCompBuf, &pcomp)))
      {
         if(chType != DEP_BUDDY)
         {
            UINT uStatus = pcomp->IsThisVersionInstalled(dwNeedVer, dwNeedBuild, &dwInsVer, &dwInsBuild);
            if( (uStatus == ICI_NOTINSTALLED) || (uStatus == ICI_NEWVERSIONAVAILABLE) )
            {
               hr = E_FAIL;
               break;
            }
         }
      }
   }
   return hr;
}

HRESULT CCifComponent::_SRLiteDownloadFiles()
{
    HANDLE hFile;
    WIN32_FIND_DATA ffd = {0};
    CHAR szFile[MAX_PATH];
    LPSTR pszFile = NULL;
    HRESULT hr = S_OK;
    CHAR szCompBuf[INTERNET_MAX_URL_LENGTH];
    DWORD dwType;
    BOOL fRet;
    UINT uPatchCount = 0;

    _uPhase = INSTALLSTATUS_DOWNLOADING;

    // Look for presence of [DownloadFileSection] in a single
    // .inf file extracted from the cabs.
    for(UINT i = 0; SUCCEEDED(hr) && SUCCEEDED(GetUrl(i, szCompBuf, sizeof(szCompBuf), &dwType)) ; i++)
    {
        TCHAR szShortPath[MAX_PATH] = "";
        GetShortPathName(GetDownloadDir(), szShortPath, sizeof(szShortPath));
        // If all goes well, we should just get a single INF file extracted
        lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
        SafeAddPath(szFile, szCompBuf, sizeof(szCompBuf));

        hr = ExtractFiles(szFile, szShortPath, 0, NULL, NULL, 0);
       wsprintf(szLogBuf, "Extracting empty cabs for %s in %s returned 0x%lx\r\n", szCompBuf, szShortPath, hr);
       _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
    }

    lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
    SafeAddPath(szFile, "*.inf", sizeof(szFile));

    // Get the file count because we're going to hack the
    // progress bar UI since we don't know the real download sizes
    // for the patch INFs upfront.
    hFile = FindFirstFile(szFile, &ffd);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Strip filename from path
            lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
            SafeAddPath(szFile, ffd.cFileName, sizeof(szFile) - lstrlen(szFile));

            if (IsPatchableINF(szFile))
            {
                uPatchCount++;
            }
        } while (FindNextFile(hFile, &ffd));
        FindClose(hFile);
    }

    lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
    SafeAddPath(szFile, "*.inf", sizeof(szFile));

    hFile = FindFirstFile(szFile, &ffd);

    // No need to keep the grep pattern...
    lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
    pszFile = szFile + lstrlen(szFile);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            // Strip filename from path
            lstrcpyn(szFile, GetDownloadDir(), sizeof(szFile));
            SafeAddPath(szFile, ffd.cFileName, sizeof(szFile) - lstrlen(szFile));

            if (IsPatchableINF(szFile))
            {
                fRet = TRUE;
                // Found an inf that supports SR Lite.  Try downloading the patch files.
                // Use our downloader wrapper for the advpack extension to do the
                // downloading.
                hr = _pCif->GetInstallEngine()->GetPatchDownloader()->SetupDownload(_uTotalGoal, uPatchCount, (IMyDownloadCallback *) this, GetDownloadDir());
                hr = _pCif->GetInstallEngine()->GetPatchDownloader()->DoDownload(szFile);
            }
            else
            {
                wsprintf(szLogBuf, "%s INF found with no DownloadFileSection\r\n", szFile);
                _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
            }

            _uTotalProgress += _uIndivProgress;

        } while (SUCCEEDED(hr) && FindNextFile(hFile, &ffd));
        FindClose(hFile);
    }

    if (!fRet || !SUCCEEDED(hr))
    {
       wsprintf(szLogBuf, "Either no INF was found with a DownloadFileSection or an error occured during processing\r\n");
       _pCif->GetInstallEngine()->WriteToLog(szLogBuf, FALSE);
        return E_FAIL;
    }

    return hr;
}

void CCifComponent::SetDownloadDir(LPCSTR pszDownloadDir)
{
    if (pszDownloadDir)
        lstrcpyn(_szDLDir, pszDownloadDir, MAX_PATH);
}

//========= ICifRWComponent implementation ================================================
//
CCifRWComponent::CCifRWComponent(LPCSTR pszID, CCifFile *pCif) : CCifComponent(pszID, pCif)
{
}

CCifRWComponent::~CCifRWComponent()
{
}

STDMETHODIMP CCifRWComponent::GetID(LPSTR pszID, DWORD dwSize)
{
   return(CCifComponent::GetID(pszID, dwSize));
}
   
STDMETHODIMP CCifRWComponent::GetGUID(LPSTR pszGUID, DWORD dwSize)
{
   return(CCifComponent::GetGUID(pszGUID, dwSize));
}

STDMETHODIMP CCifRWComponent::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifComponent::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP CCifRWComponent::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(CCifComponent::GetDetails(pszDetails, dwSize));
}

STDMETHODIMP CCifRWComponent::GetUrl(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)
{
   return(CCifComponent::GetUrl(uUrlNum, pszUrl, dwSize, pdwUrlFlags));
}

STDMETHODIMP CCifRWComponent::GetFileExtractList(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)
{
   return(CCifComponent::GetFileExtractList(uUrlNum, pszExtract, dwSize));
}

STDMETHODIMP CCifRWComponent::GetUrlCheckRange(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)
{
   return(CCifComponent::GetUrlCheckRange(uUrlNum, pdwMin, pdwMax));
}

STDMETHODIMP CCifRWComponent::GetCommand(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                                         DWORD dwSwitchSize, LPDWORD pdwType)
{
   return(CCifComponent::GetCommand(uCmdNum, pszCmd, dwCmdSize, pszSwitches, dwSwitchSize, pdwType));
}

STDMETHODIMP CCifRWComponent::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   return(CCifComponent::GetVersion(pdwVersion, pdwBuild));
}

STDMETHODIMP CCifRWComponent::GetLocale(LPSTR pszLocale, DWORD dwSize)
{
   return(CCifComponent::GetLocale(pszLocale, dwSize));
}

STDMETHODIMP CCifRWComponent::GetUninstallKey(LPSTR pszKey, DWORD dwSize)
{
   return(CCifComponent::GetUninstallKey(pszKey, dwSize));
}

STDMETHODIMP CCifRWComponent::GetInstalledSize(LPDWORD pdwWin, LPDWORD pdwApp)
{
   return(CCifComponent::GetInstalledSize(pdwWin, pdwApp));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetDownloadSize()
{
   return(CCifComponent::GetDownloadSize());
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetExtractSize()
{
   return(CCifComponent::GetExtractSize());
}

STDMETHODIMP CCifRWComponent::GetSuccessKey(LPSTR pszKey, DWORD dwSize)
{
   return(CCifComponent::GetSuccessKey(pszKey, dwSize));
}

STDMETHODIMP CCifRWComponent::GetProgressKeys(LPSTR pszProgress, DWORD dwProgSize, 
                                               LPSTR pszCancel, DWORD dwCancelSize)
{
   return(CCifComponent::GetProgressKeys(pszProgress, dwProgSize, pszCancel, dwCancelSize));
}

STDMETHODIMP CCifRWComponent::IsActiveSetupAware()
{
   return(CCifComponent::IsActiveSetupAware());
}

STDMETHODIMP CCifRWComponent::IsRebootRequired()
{
   return(CCifComponent::IsActiveSetupAware());
}

STDMETHODIMP CCifRWComponent::RequiresAdminRights()
{
   return(CCifComponent::RequiresAdminRights());
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetPriority()
{
   return(CCifComponent::GetPriority());
}

STDMETHODIMP CCifRWComponent::GetDependency(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   return(CCifComponent::GetDependency(uDepNum, pszID, dwBuf, pchType, pdwVer, pdwBuild));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetPlatform()
{
   return(CCifComponent::GetPlatform());
}

STDMETHODIMP CCifRWComponent::GetMode(UINT uModeNum, LPSTR pszModes, DWORD dwSize)
{
   return(CCifComponent::GetMode(uModeNum, pszModes, dwSize));
}

STDMETHODIMP CCifRWComponent::GetTreatAsOneComponents(UINT uNum, LPSTR pszID, DWORD dwBuf)
{
   return(CCifComponent::GetTreatAsOneComponents(uNum, pszID, dwBuf));
}

STDMETHODIMP CCifRWComponent::GetCustomData(LPSTR pszKey, LPSTR pszData, DWORD dwSize)
{
   return(CCifComponent::GetCustomData(pszKey, pszData, dwSize));
}

STDMETHODIMP CCifRWComponent::GetGroup(LPSTR pszID, DWORD dwSize)
{
   return(CCifComponent::GetGroup(pszID, dwSize));
}

STDMETHODIMP CCifRWComponent::IsUIVisible()
{
   return(CCifComponent::IsUIVisible());
}

STDMETHODIMP CCifRWComponent::GetPatchID(LPSTR pszID, DWORD dwSize)
{
   return(CCifComponent::GetPatchID(pszID, dwSize));
}

STDMETHODIMP_(DWORD) CCifRWComponent::IsComponentInstalled()
{
   return(CCifComponent::IsComponentInstalled());
}

STDMETHODIMP CCifRWComponent::IsComponentDownloaded()
{
   return(CCifComponent::IsComponentDownloaded());
}

STDMETHODIMP_(DWORD) CCifRWComponent::IsThisVersionInstalled(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild)
{
   return(CCifComponent::IsThisVersionInstalled(dwAskVer, dwAskBld, pdwVersion, pdwBuild));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetInstallQueueState()
{
   return(CCifComponent::GetInstallQueueState());
}

STDMETHODIMP CCifRWComponent::SetInstallQueueState(DWORD dwState)
{
   return(CCifComponent::SetInstallQueueState(dwState));
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetActualDownloadSize()
{
   return(CCifComponent::GetActualDownloadSize());
}

STDMETHODIMP_(DWORD) CCifRWComponent::GetCurrentPriority()
{
   return(CCifComponent::GetCurrentPriority());
}

STDMETHODIMP CCifRWComponent::SetCurrentPriority(DWORD dwPriority)
{
   return(CCifComponent::SetCurrentPriority(dwPriority));
}


STDMETHODIMP CCifRWComponent:: GetDetVersion(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize)
{
   return(CCifComponent::GetDetVersion(pszDLL, dwdllSize, pszEntry, dwentSize));
}


STDMETHODIMP CCifRWComponent::SetGUID(LPCSTR pszGUID)
{
   return (WritePrivateProfileString(_szID, GUID_KEY, pszGUID, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetDescription(LPCSTR pszDesc)
{
   return (WriteTokenizeString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWComponent::SetDetails(LPCSTR pszDesc)
{
   return (WriteTokenizeString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDesc));   
}

STDMETHODIMP CCifRWComponent::SetVersion(LPCSTR pszVersion)
{
   return (WritePrivateProfileString(_szID, VERSION_KEY, pszVersion, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetUninstallKey(LPCSTR pszKey)
{
   return (MyWritePrivateProfileString(_szID, UNINSTALLSTRING_KEY, pszKey, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetInstalledSize(DWORD dwWin, DWORD dwApp)
{
   char szBuf[50];

   wsprintf(szBuf,"%d,%d", dwWin, dwApp);
   return (WritePrivateProfileString(_szID, INSTALLSIZE_KEY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetDownloadSize(DWORD dwSize)
{
   char szBuf1[MAX_VALUE_LEN];
   char szBuf2[MAX_VALUE_LEN];
   DWORD dwExtractSize;

   szBuf1[0] = '\0';

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0", szBuf1, sizeof(szBuf1), _pCif->GetCifPath());   
   dwExtractSize = GetIntField(szBuf1, 1, (DWORD)-1);
   if (dwExtractSize == (DWORD)-1)
      wsprintf(szBuf2,"%d", dwSize);
   else
      wsprintf(szBuf2,"%d,%d", dwSize, dwExtractSize);
   return (WritePrivateProfileString(_szID, SIZE_KEY, szBuf2, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetExtractSize(DWORD dwSize)
{
   char szBuf1[MAX_VALUE_LEN];
   char szBuf2[MAX_VALUE_LEN];

   szBuf1[0] = '\0';

   // Read in size
   GetPrivateProfileString(_szID, SIZE_KEY, "0,0", szBuf1, sizeof(szBuf1), _pCif->GetCifPath());   
   wsprintf(szBuf2,"%d,%d", GetIntField(szBuf1, 0, 0), dwSize);
   return (WritePrivateProfileString(_szID, SIZE_KEY, szBuf2, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::DeleteDependency(LPCSTR pszID, char chType)
{
   HRESULT hr;

   if (pszID ==  NULL) //delete all from all modes
      hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, NULL, _pCif->GetCifPath())?NOERROR:E_FAIL;
   else
   {
      // delete only the given ones
      char szBuf[MAX_VALUE_LEN];
      char szBufIn[MAX_VALUE_LEN];
      char szBufOut[MAX_VALUE_LEN];
      char szOne[MAX_ID_LENGTH];
      LPSTR pszTmp;
      UINT i = 0;
      
      szBufOut[0] =0;
      wsprintf( szBuf, "%s:%c", pszID, chType);
      if (GetPrivateProfileString(_szID, DEPENDENCY_KEY, "", szBufIn, sizeof(szBufIn), _pCif->GetCifPath()))
      {
         pszTmp = szBufOut;
         while(GetStringField(szBufIn, i++, szOne, sizeof(szOne)))
         {
            if (lstrcmpi(szOne, szBuf))
            {
               if ( i != 1)
               {
                  lstrcpy(pszTmp,",");
                  pszTmp++;
               }
               lstrcpy(pszTmp, szOne);
               pszTmp = pszTmp + lstrlen(szOne);
            }
         }
         hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, szBufOut, _pCif->GetCifPath())? NOERROR:E_FAIL;
      }                         
   }   
   return hr;

}

STDMETHODIMP CCifRWComponent::AddDependency(LPCSTR pszID, char chType)
{
   char szBuf[MAX_VALUE_LEN];   
   char szBuf1[MAX_VALUE_LEN];   
   char szOne[MAX_ID_LENGTH];
   LPSTR pszTmp;
   UINT i = 0;
   BOOL bFound = FALSE;
   HRESULT hr = NOERROR;

   if (pszID==NULL)
      return hr;

   if (chType == '\\')
       wsprintf( szBuf1, "%s:N:6.0.0.0", pszID, chType);
   else
       wsprintf( szBuf1, "%s:%c", pszID, chType);

   if (GetPrivateProfileString(_szID, DEPENDENCY_KEY, "", szBuf, sizeof(szBuf), _pCif->GetCifPath()))
   {          
      while(GetStringField(szBuf, i++, szOne, sizeof(szOne)))
      {
         if (lstrcmpi(szOne, szBuf1) == 0)
         {
            // found it, no need to add
            bFound = TRUE;
            break;
         }
      }
      if (!bFound)
      {
         LPSTR pszTmp = szBuf + lstrlen(szBuf);
         lstrcpy(pszTmp, ",");
         pszTmp++;
         lstrcpy(pszTmp, szBuf1);         
         hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL;
      }
   }
   else
      hr = WritePrivateProfileString(_szID, DEPENDENCY_KEY, szBuf1, _pCif->GetCifPath())? NOERROR:E_FAIL;

   return hr;
}

STDMETHODIMP CCifRWComponent::SetUIVisible(BOOL bFlag)
{
   return (WritePrivateProfileString(_szID, UIVISIBLE_KEY, bFlag? "1" : "0", _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetGroup(LPCSTR pszID)
{
   return (WritePrivateProfileString(_szID, GROUP_KEY, pszID, _pCif->GetCifPath())? NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::SetPlatform(DWORD dwPlatform)
{
   char szBuf[MAX_VALUE_LEN];
   char *rszPlatforms[7] = { STR_WIN95, STR_WIN98, STR_NT4, STR_NT5, STR_NT4ALPHA, STR_NT5ALPHA, STR_MILLEN };
   DWORD rdwPlatforms[] = { PLATFORM_WIN95, PLATFORM_WIN98, PLATFORM_NT4, PLATFORM_NT5, 
                            PLATFORM_NT4ALPHA, PLATFORM_NT5ALPHA, PLATFORM_MILLEN };

   _dwPlatform = dwPlatform;
   szBuf[0] = 0;

   for(int i = 0; i < 7; i++)
   {
      if(dwPlatform & rdwPlatforms[i]) 
      {
         lstrcat(szBuf, rszPlatforms[i]);
         lstrcat(szBuf, ",");
      }            
   }   

   return (WritePrivateProfileString(_szID, PLATFORM_KEY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL);   
}

STDMETHODIMP CCifRWComponent::SetPriority(DWORD dwPri)
{
   char szBuf[MAX_SMALL_BUF];

   wsprintf(szBuf, "%d", dwPri);
   return (WritePrivateProfileString(_szID, PRIORITY, szBuf, _pCif->GetCifPath())? NOERROR:E_FAIL);   
}

STDMETHODIMP CCifRWComponent::SetReboot(BOOL bReboot)
{
   return (WritePrivateProfileString(_szID, REBOOT_KEY, bReboot? "1":"0", _pCif->GetCifPath())? NOERROR:E_FAIL);   
}

STDMETHODIMP CCifRWComponent::SetCommand(UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType)
{
   char szKey[16];
   char szType[10];
   HRESULT hr = NOERROR;
 
   uCmdNum++;
   wsprintf(szKey, "%s%lu", CMD_KEY, uCmdNum);
   if (!MyWritePrivateProfileString(_szID, szKey, pszCmd, _pCif->GetCifPath()))
      hr = E_FAIL;
   wsprintf(szKey, "%s%lu", ARGS_KEY, uCmdNum);
   if(!MyWritePrivateProfileString(_szID, szKey, (pszCmd==NULL)?NULL:pszSwitches, _pCif->GetCifPath()))
      hr = E_FAIL;
   wsprintf(szKey, "%s%lu", TYPE_KEY, uCmdNum);
   wsprintf(szType,"%d", dwType);
   if(!WritePrivateProfileString(_szID, szKey, (pszCmd==NULL)? NULL:szType, _pCif->GetCifPath()))
      hr = E_FAIL;

   return hr;
}

STDMETHODIMP CCifRWComponent::SetUrl(UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags)
{
   char szKey[16];
   char szBuf[MAX_VALUE_LEN];
   HRESULT hr = NOERROR;

   uUrlNum++;
   wsprintf(szKey, "%s%lu", URL_KEY, uUrlNum);
   wsprintf(szBuf, "\"%s\",%d", pszUrl, dwUrlFlags);
   if (!WritePrivateProfileString(_szID, szKey, szBuf, _pCif->GetCifPath()))
      hr = E_FAIL;
   wsprintf(szKey, "%s%lu", SIZE_KEY, uUrlNum);
   if(!WritePrivateProfileString(_szID, szKey, NULL, _pCif->GetCifPath()))
      hr = E_FAIL;

   return hr;   
}

STDMETHODIMP CCifRWComponent::DeleteFromModes(LPCSTR pszMode)
{
   HRESULT hr;

   if (pszMode ==  NULL) //delete all from all modes
      hr = WritePrivateProfileString(_szID, MODES_KEY, pszMode, _pCif->GetCifPath())?NOERROR:E_FAIL;
   else
   {
      // delete only the given ones
      char szBufIn[MAX_VALUE_LEN];
      char szBufOut[MAX_VALUE_LEN];
      char szOneMode[MAX_ID_LENGTH];
      LPSTR pszTmp;
      UINT i = 0;
      
      szBufOut[0] =0;
      if (SUCCEEDED(MyTranslateString(_pCif->GetCifPath(), _szID, MODES_KEY, szBufIn, sizeof(szBufIn))))
      {
         pszTmp = szBufOut;
         while(GetStringField(szBufIn, i++, szOneMode, sizeof(szOneMode)))
         {
            if (lstrcmpi(szOneMode, pszMode))
            {
               if ( i != 1)
               {
                  lstrcpy(pszTmp,",");
                  pszTmp++;
               }
               lstrcpy(pszTmp, szOneMode);
               pszTmp = pszTmp + lstrlen(szOneMode);
            }
         }
         hr = WriteTokenizeString(_pCif->GetCifPath(), _szID, MODES_KEY, szBufOut);
      }                         
   }   
   return hr;
}

STDMETHODIMP CCifRWComponent::AddToMode(LPCSTR pszMode)
{
   char szBuf[MAX_VALUE_LEN];   
   char szOneMode[MAX_ID_LENGTH];
   LPSTR pszTmp;
   UINT i = 0;
   BOOL bFound = FALSE;
   HRESULT hr = NOERROR;

   if (SUCCEEDED(MyTranslateString(_pCif->GetCifPath(), _szID, MODES_KEY, szBuf, sizeof(szBuf))))
   {    
      while(GetStringField(szBuf, i++, szOneMode, sizeof(szOneMode)))
      {
         if (lstrcmpi(szOneMode, pszMode) == 0)
         {
            // found it, no need to add
            bFound = TRUE;
            break;
         }
      }
      if (!bFound)
      {
         LPSTR pszTmp = szBuf + lstrlen(szBuf);
         lstrcpy(pszTmp, ",");
         pszTmp++;
         lstrcpy(pszTmp, pszMode);         
         hr = WriteTokenizeString(_pCif->GetCifPath(), _szID, MODES_KEY, szBuf);
      }
   }
   else
      hr = WritePrivateProfileString(_szID, MODES_KEY, pszMode, _pCif->GetCifPath()) ? NOERROR : E_FAIL;

   return hr;
}

STDMETHODIMP CCifRWComponent::SetModes(LPCSTR pszMode)
{
    return (WriteTokenizeString(_pCif->GetCifPath(), _szID, MODES_KEY, pszMode)?NOERROR:E_FAIL);
}

STDMETHODIMP CCifRWComponent::CopyComponent(LPCSTR pszCifFile)
{
   LPSTR pszSec;
   DWORD dwSize;
   HRESULT hr = NOERROR;

   dwSize = MAX_VALUE_LEN*4*4;
   pszSec = (LPSTR)LocalAlloc(LPTR, dwSize);  //allocate 4K buffer to read section
   while(pszSec && GetPrivateProfileSection(_szID, pszSec, dwSize, pszCifFile)==(dwSize-2))
   {
      LocalFree(pszSec);
      dwSize = dwSize*2;
      pszSec = (LPSTR)LocalAlloc(LPTR, dwSize);
   }

   if (pszSec)
   {
      // first clean the Old section if there
      WritePrivateProfileString(_szID, NULL, NULL, _pCif->GetCifPath());
      // write out the copied section
      WritePrivateProfileSection(_szID, pszSec, _pCif->GetCifPath());

      LocalFree(pszSec);
   }
   else
      hr = E_OUTOFMEMORY;

   // need to check to see if we need to get strings out of the Strings section

   CopyCifString(_szID, DISPLAYNAME_KEY, pszCifFile, _pCif->GetCifPath());
   CopyCifString(_szID, DETAILS_KEY, pszCifFile, _pCif->GetCifPath());
   CopyCifString(_szID, MODES_KEY, pszCifFile, _pCif->GetCifPath());
   CopyCifString(_szID, LOCALE_KEY, pszCifFile, _pCif->GetCifPath());

   return hr;
}

STDMETHODIMP CCifRWComponent::AddToTreatAsOne(LPCSTR pszCompID)
{
   char szBuf[MAX_VALUE_LEN];   
   char szOneID[MAX_ID_LENGTH];
   LPSTR pszTmp;
   UINT i = 0;
   BOOL bFound = FALSE;
   HRESULT hr = NOERROR;

   if (SUCCEEDED(MyTranslateString(_pCif->GetCifPath(), _szID, TREATAS_KEY, szBuf, sizeof(szBuf))))
   {    
      while(GetStringField(szBuf, i++, szOneID, sizeof(szOneID)))
      {
         if (lstrcmpi(szOneID, pszCompID) == 0)
         {
            // found it, no need to add
            bFound = TRUE;
            break;
         }
      }
      if (!bFound)
      {
         LPSTR pszTmp = szBuf + lstrlen(szBuf);
         lstrcpy(pszTmp, ",");
         pszTmp++;
         lstrcpy(pszTmp, pszCompID);         
         hr = WriteTokenizeString(_pCif->GetCifPath(), _szID, TREATAS_KEY, szBuf);
      }
   }
   else
      hr = WritePrivateProfileString(_szID, TREATAS_KEY, pszCompID, _pCif->GetCifPath()) ? NOERROR : E_FAIL;

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\cifmode.cpp ===
#include "inspch.h"
#include "util2.h"
#include "inseng.h"
#include "ciffile.h"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifMode::CCifMode(LPCSTR pszCompID, CCifFile *pCif) : CCifEntry(pszCompID, pCif) 
{
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CCifMode::~CCifMode()
{
}



STDMETHODIMP CCifMode::GetID(LPSTR pszID, DWORD dwSize)
{
   lstrcpyn(pszID, _szID, dwSize);
   return NOERROR;
}

STDMETHODIMP CCifMode::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc, dwSize));   
}

STDMETHODIMP CCifMode::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(MyTranslateString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails, dwSize));   
}

STDMETHODIMP CCifMode::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum(_pCif->GetComponentList(), dwFilter, PARENTTYPE_MODE, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

//================= ICifRWMode Implementation =============================
//
CCifRWMode::CCifRWMode(LPCSTR pszID, CCifFile *pCif) : CCifMode(pszID, pCif)
{
}

CCifRWMode::~CCifRWMode()
{
}

STDMETHODIMP CCifRWMode::GetID(LPSTR pszID, DWORD dwSize)
{
   return(CCifMode::GetID(pszID, dwSize));
}

STDMETHODIMP CCifRWMode::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
   return(CCifMode::GetDescription(pszDesc, dwSize));
}

STDMETHODIMP CCifRWMode::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
   return(CCifMode::GetDetails(pszDetails, dwSize));
}

STDMETHODIMP CCifRWMode::EnumComponents(IEnumCifComponents **pp, DWORD dwFilter, LPVOID pv)
{
   CCifComponentEnum *pce;
   HRESULT hr = E_FAIL;

   *pp = 0;

   pce = new CCifComponentEnum((CCifComponent**)_pCif->GetComponentList(), dwFilter, PARENTTYPE_MODE, _szID);
   if(pce)
   {
      *pp = (IEnumCifComponents *) pce;
      (*pp)->AddRef();
      hr = NOERROR;
   }
   
   return hr;
}

STDMETHODIMP CCifRWMode::SetDescription(LPCSTR pszDesc)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DISPLAYNAME_KEY, pszDesc));   
}

STDMETHODIMP CCifRWMode::SetDetails(LPCSTR pszDetails)
{
   return(WriteTokenizeString(_pCif->GetCifPath(), _szID, DETAILS_KEY, pszDetails));   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\diskspac.cpp ===
#include "inspch.h"
#include "diskspac.h"
#include "util2.h"

void AddTempSpace(DWORD dwDownloadSize, DWORD dwExtractSize, DriveInfo drvinfo[])
{
   DWORD uTempDrive = 0xffffffff;
   char szRoot[5] = { "A:\\" };
   BOOL bEnoughSpaceFound = FALSE;
   DWORD dwNeededSize;

   while ( szRoot[0] <= 'Z' && !bEnoughSpaceFound)
   {
      UINT uType;

      uType = GetDriveType(szRoot);

      // even the drive type is OK, verify the drive has valid connection
      //
      if ( ( ( uType != DRIVE_RAMDISK) && (uType != DRIVE_FIXED) ) ||
             ( GetFileAttributes( szRoot ) == -1) )
      {
         szRoot[0]++;
         continue;
      }
      // see if this drive is one of our "special drives" and use our own disk space
      BOOL bFoundDrive = FALSE;
      for(UINT i = 0; i < 3 && !bFoundDrive ; i++)
      {
         if(szRoot[0] == drvinfo[i].Drive())
         {
            bFoundDrive = TRUE;
            dwNeededSize = dwDownloadSize * drvinfo[i].CompressFactor() / 10 + dwExtractSize;
            if(dwNeededSize < drvinfo[i].Free())
            {   
               uTempDrive = i;
               bEnoughSpaceFound = TRUE;
            }
         }
      }
      // if !bFoundDrive, this is not a special drive, do old check
      if(!bFoundDrive)
      {
         DWORD dwVolFlags, dwCompressFactor;
         if(!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolFlags, NULL, 0))
         {
            szRoot[0]++;
            continue;
         }
         if(dwVolFlags & FS_VOL_IS_COMPRESSED)
            dwCompressFactor = 19;
         else
            dwCompressFactor = 10;
         // Decide how much we need if we extract to this drive
         dwNeededSize = dwDownloadSize * dwCompressFactor / 10 + dwExtractSize;;
       
         // if this drive has enough bump Req if appropiate
         if(IsEnoughSpace(szRoot, dwNeededSize ))
         {
            bEnoughSpaceFound = TRUE;
         }
      
      }

      szRoot[0]++;
   }

   // ok, if we haven't found enough space anywhere, add it to install drive or win drive
   if(!bEnoughSpaceFound)
   {
      if(drvinfo[1].Drive() != 0)
         uTempDrive = 1;
      else
         uTempDrive = 0;
   }   
   
   if(uTempDrive != 0xffffffff)
   {
      drvinfo[uTempDrive].UseSpace(dwDownloadSize, TRUE);
      drvinfo[uTempDrive].UseSpace(dwExtractSize, FALSE);
      // now free up what we used
      drvinfo[uTempDrive].FreeSpace(dwDownloadSize, TRUE);
      drvinfo[uTempDrive].FreeSpace(dwExtractSize, FALSE);
   }
}



DriveInfo::DriveInfo() : m_dwUsed(0), m_dwMaxUsed(0), 
                         m_dwStart(0xffffffff), m_chDrive(0),
                         m_uCompressFactor(10)
{
    
}

void DriveInfo::InitDrive(char chDrive)
{
   char szPath[5] = { "?:\\" };
   DWORD dwVolFlags = 0;

   m_chDrive = chDrive;
   szPath[0] = chDrive;
   m_dwStart = GetSpace(szPath);
   GetVolumeInformation(szPath,NULL,0,NULL,NULL, &dwVolFlags,NULL,0);
   if(dwVolFlags & FS_VOL_IS_COMPRESSED)
      m_uCompressFactor = 19;
   else
      m_uCompressFactor = 10;
}

void DriveInfo::UseSpace(DWORD dwAmt, BOOL bCompressed)
{ 
   if(bCompressed)
      dwAmt = dwAmt * m_uCompressFactor/10;

   m_dwUsed += dwAmt;
   if(m_dwUsed > m_dwMaxUsed) 
      m_dwMaxUsed = m_dwUsed; 
}

void DriveInfo::FreeSpace(DWORD dwAmt, BOOL bCompressed)
{ 
   if(bCompressed)
      dwAmt = dwAmt * m_uCompressFactor/10;

   m_dwUsed -= dwAmt; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\diskspac.h ===
class DriveInfo
{
   public:
      DriveInfo();
      void InitDrive(char chDrive);

      DWORD Free()   { if(m_dwUsed < m_dwStart) return m_dwStart - m_dwUsed; else return 0; }
      void UseSpace(DWORD dwAmt, BOOL bCompressed);
      void FreeSpace(DWORD dwAmt, BOOL bCompressed);
      UINT CompressFactor() { return m_uCompressFactor; }

      DWORD MaxUsed()  { return m_dwMaxUsed; }
      char  Drive()    { return m_chDrive; }

   private:
      DWORD m_dwUsed;
      DWORD m_dwMaxUsed;
      DWORD m_dwStart;
      char  m_chDrive;
      UINT  m_uCompressFactor;
};

void AddTempSpace(DWORD dwDownloadSize, DWORD dwExtractSize, DriveInfo drvinfo[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\dialmon.cpp ===
/*
 * Dialmon.cpp
 *
 * Stuff to deal with the autodial monitor
 *
 * Copyright (c) 1996 Microsoft Corporation
 */
#include "inspch.h"
#include "util2.h"

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME "MS_AutodialMonitor"
#define WEBCHECK_MONITOR_CLASS_NAME "MS_WebcheckMonitor"

static const CHAR szAutodialMonitorClass[] = AUTODIAL_MONITOR_CLASS_NAME;
static const CHAR szWebcheckMonitorClass[] = WEBCHECK_MONITOR_CLASS_NAME;

#define WM_DIALMON_FIRST    WM_USER+100

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0


#define MIN_ACTIVITY_MSG_INTERVAL	15000

VOID IndicateWinsockActivity(VOID)
{
	// if there is an autodisconnect monitor, send it an activity message
	// so that we don't get disconnected during long downloads.  For perf's sake,
	// don't send a message any more often than once every MIN_ACTIVITY_MSG_INTERVAL
	// milliseconds (15 seconds).  Use GetTickCount to determine interval;
	// GetTickCount is very cheap.
	DWORD dwTickCount = GetTickCount();
	static DWORD dwLastActivityMsgTickCount = 0;
	DWORD dwElapsed = dwTickCount - dwLastActivityMsgTickCount;

	// have we sent an activity message recently?
	if (dwElapsed > MIN_ACTIVITY_MSG_INTERVAL) 
    {
		HWND hwndMonitorApp = FindWindow(szAutodialMonitorClass,NULL);
        if(!hwndMonitorApp)
           hwndMonitorApp = FindWindow(szWebcheckMonitorClass,NULL);
		if (hwndMonitorApp) 
        {
			SendNotifyMessage(hwndMonitorApp,WM_WINSOCK_ACTIVITY,0,0);
		}	
					
		// record the tick count of the last time we sent an
		// activity message
			dwLastActivityMsgTickCount = dwTickCount;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\enum.cpp ===
#include "inspch.h"
#include "util2.h"
#include "inseng.h"
#include "ciffile.h"

CCifEntryEnum::CCifEntryEnum(UINT dwFilter, UINT dwParentType, LPSTR pszParentID)
{
   _cRef = 0;
   _uIndex = 0;
   _uFilter = dwFilter;
   if(_uFilter == 0)
      _uFilter = PLATFORM_ALL;
   _uParentType = dwParentType;
   if(_uParentType != PARENTTYPE_CIF)
      lstrcpyn(_szParentID, pszParentID, MAX_ID_LENGTH);
}

CCifEntryEnum::~CCifEntryEnum()
{
}

CCifComponentEnum::CCifComponentEnum(CCifComponent **rpcomp, UINT dwFilter, UINT dwParentType, LPSTR pszParentID)
                         :  CCifEntryEnum(dwFilter, dwParentType, pszParentID)
{
   _rpComp = rpcomp;
}

CCifComponentEnum::~CCifComponentEnum()
{
}



//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifComponentEnum::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifComponentEnum::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifComponentEnum::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if(riid == IID_IUnknown)
      *ppv = (IEnumCifComponents *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

STDMETHODIMP CCifComponentEnum::Next(ICifComponent **pp)
{
   *pp = NULL;
   HRESULT hr = E_FAIL;
   CCifComponent *pcomp;

   for(pcomp = _rpComp[_uIndex]; pcomp != 0; pcomp = _rpComp[++_uIndex]) 
   {
      // check filters
      if(_rpComp[_uIndex]->GetPlatform() & _uFilter)
      {
         char szID[MAX_ID_LENGTH];
         BOOL bParentOK = FALSE;

         // platform is ok
         if(_uParentType == PARENTTYPE_GROUP)
         {
            pcomp->GetGroup(szID, sizeof(szID));
            if(lstrcmpi(_szParentID, szID) == 0)
               bParentOK = TRUE;
         }
         else if(_uParentType == PARENTTYPE_MODE)
         {
            // look though the modes for one that matches
            for(int i = 0; SUCCEEDED(pcomp->GetMode(i, szID, sizeof(szID))); i++)
            {
               if(lstrcmpi(szID, _szParentID) == 0)
                  bParentOK = TRUE;
            }
         }
         else
            bParentOK = TRUE;

         if(bParentOK)
         {
            hr = NOERROR;
            *pp = (ICifComponent *) pcomp;
            _uIndex++;   // increment _uIndex so next call to Next keeps moving
            break;
         }
      }
   }
   return hr;
}

STDMETHODIMP CCifComponentEnum::Reset()
{
   _uIndex = 0;
   return NOERROR;
}




//***************** CCifGroupEnum *****************************

CCifGroupEnum::CCifGroupEnum(CCifGroup **rpgrp, UINT dwFilter)
                         :  CCifEntryEnum(dwFilter, PARENTTYPE_CIF, NULL)
{
   _rpGroup = rpgrp;
}

CCifGroupEnum::~CCifGroupEnum()
{
}



//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifGroupEnum::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifGroupEnum::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifGroupEnum::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if(riid == IID_IUnknown)
      *ppv = (IEnumCifGroups *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

STDMETHODIMP CCifGroupEnum::Next(ICifGroup **pp)
{
   HRESULT hr = E_FAIL;
   CCifGroup *pgrp;

   *pp = NULL;

   for(pgrp = _rpGroup[_uIndex]; pgrp != 0; pgrp = _rpGroup[++_uIndex]) 
   {
      hr = NOERROR;
      *pp = (ICifGroup *) pgrp;
      _uIndex++;   // increment _uIndex so next call to Next keeps moving
      break;
   }
   return hr;
}

STDMETHODIMP CCifGroupEnum::Reset()
{
   _uIndex = 0;
   return NOERROR;
}


//***************** CCifModeEnum *****************************

CCifModeEnum::CCifModeEnum(CCifMode **rpmode, UINT dwFilter)
                         :  CCifEntryEnum(dwFilter, PARENTTYPE_CIF, NULL)
{
   _rpMode = rpmode;
}

CCifModeEnum::~CCifModeEnum()
{
}



//************ IUnknown implementation ***************


STDMETHODIMP_(ULONG) CCifModeEnum::AddRef()                      
{
   return(_cRef++);
}


STDMETHODIMP_(ULONG) CCifModeEnum::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}


STDMETHODIMP CCifModeEnum::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if(riid == IID_IUnknown)
      *ppv = (IEnumCifModes *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

STDMETHODIMP CCifModeEnum::Next(ICifMode **pp)
{
   HRESULT hr = E_FAIL;
   CCifMode *pmode;

   *pp = NULL;

   for(pmode = _rpMode[_uIndex]; pmode != 0; pmode = _rpMode[++_uIndex]) 
   {
      hr = NOERROR;
      *pp = (ICifMode *) pmode;
      _uIndex++;   // increment _uIndex so next call to Next keeps moving
      break;
   }
   return hr;
}

STDMETHODIMP CCifModeEnum::Reset()
{
   _uIndex = 0;
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\cifmode.h ===
class CCifMode : public ICifMode, public CCifEntry
{
   public:
      CCifMode(LPCSTR pszID, CCifFile *);
      ~CCifMode();
 
      DWORD GetCurrentPriority() { return 0; }
      // ICifMode interface
        // for properties
        // for properties
      STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize);
  
      STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv);

};

class CCifRWMode : public ICifRWMode, public CCifMode
{
   public:
      STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize);
      STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize);
      STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize);
  
      STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
      
      // ICifRWMode interface
      CCifRWMode(LPCSTR pszID, CCifFile *);
      ~CCifRWMode();

      STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc);
      STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\download.h ===
#include <wininet.h>
#include <urlmon.h>
#include "timetrak.h"
#include "util2.h"

// Our download sink. Works with out IMyDownloadCallback class. Consider making generic
// so you can pass any class that implements the OnData and OnProgress and OnStop

extern CRITICAL_SECTION g_cs;

#define DOWNLOADFLAGS_USEWRITECACHE   0x00000001

class CInstallEngine;

struct IMyDownloadCallback
{
	   //	OnProgess is called to allow you to present progess indication UI
	   virtual HRESULT OnProgress(ULONG progress, LPCSTR pszStatus) = 0;
};



class CDownloader
        : public IBindStatusCallback,
          public IAuthenticate,
          public CTimeTracker
   
{
   public:
      CDownloader();
      ~CDownloader();
    
      HRESULT SetupDownload(LPCSTR pszUrl, IMyDownloadCallback *, DWORD dwFlags, LPCSTR szFilename);
      HRESULT DoDownload(LPSTR szPath, DWORD dwBufSize);
      HRESULT Abort();
      HRESULT Suspend();
      HRESULT Resume();

      
      STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
      STDMETHOD_(ULONG, AddRef)();
      STDMETHOD_(ULONG, Release)();

      STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

      STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

      STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

      STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

      STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

      STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

      STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

      STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);

              // IAuthenticate methods
      STDMETHOD(Authenticate)(HWND *phwnd,
                              LPWSTR *pszUserName, LPWSTR *pszPassword);

   private:
      char                 _szURL[INTERNET_MAX_URL_LENGTH];
      char                 _szDest[MAX_PATH];
      IBinding            *_pBnd;
      IMyDownloadCallback *_pCb;
      IMoniker            *_pMkr;

      UINT                 _uFlags;
      DWORD                _cRef;
      IStream             *_pStm;
      BOOL                 _fTimeout;
      BOOL                 _fTimeoutValid;
      UINT                 _uBytesSoFar;
      HANDLE               _hFile;
      HANDLE               _hDL;
      HRESULT              _hDLResult;
      UINT                 _uTickCount;
      IBindCtx            *_pBndContext;
};

HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr );

class CInstaller : public CTimeTracker
{
   public:
      CInstaller(CInstallEngine *);
      ~CInstaller();
    
      HRESULT DoInstall(LPCSTR pszDir, LPSTR pszCmd, LPSTR pszArgs, LPCSTR pszProg, LPCSTR pszCancel, 
                        UINT uType, LPDWORD pdwStatus, IMyDownloadCallback *);
      HRESULT Abort();
      HRESULT Suspend();
      HRESULT Resume();
      
      STDMETHOD_(ULONG, AddRef)();
      STDMETHOD_(ULONG, Release)();
      
   private:
      DWORD                _cRef;
      UINT                 _uTotalProgress;
      CInstallEngine      *_pInsEng;
      HKEY                _hkProg;
      HANDLE              _hMutex;
      HANDLE              _hStatus;

      void _WaitAndPumpProgress(HANDLE hProc, IMyDownloadCallback *pcb);
};

class CPatchDownloader : public CTimeTracker
{
   public:
      CPatchDownloader(BOOL fEnable);
      ~CPatchDownloader();

      HRESULT SetupDownload(DWORD dwFullTotalSize, UINT uPatchCount, IMyDownloadCallback *pcb, LPCSTR pszDLDir);
      HRESULT DoDownload(LPCSTR szFile);

      BOOL IsEnabled()                     { return _fEnable; }
      DWORD GetFullDownloadSize()          { return _dwFullTotalSize; }
      UINT GetDownloadCount()              { return _uNumDownloads; }
      LPSTR GetPath()                      { return _szPath; }
      IMyDownloadCallback *GetCallback()   { return _pCb; }

      static BOOL Callback(PATCH_DOWNLOAD_REASON Reason, PVOID lpvInfo, PVOID pvContext);
   private:
      IMyDownloadCallback *_pCb;
      BOOL                 _fEnable;
      DWORD                _dwFullTotalSize;
      UINT                 _uNumDownloads;
      char                 _szPath[MAX_PATH];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\download.cpp ===
#include "inspch.h"
#include "util2.h"
#include "download.h"

#define BUFFERSIZE 4096
char g_szBuffer[BUFFERSIZE];

#define TIMEOUT_PERIOD   120
#define PATCHWIN9xKEY "SOFTWARE\\Microsoft\\Advanced INF Setup"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

CDownloader::CDownloader() : CTimeTracker(0)
{
   _pCb    = NULL;
   _pBnd   = NULL;
   _cRef   = 1;
   _pStm   = NULL;
   _pMkr   = NULL;
   _uFlags = NULL;
   _hDL    = CreateEvent(NULL, TRUE, FALSE, NULL);
   DllAddRef();
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

CDownloader::~CDownloader()
{
   if(_hDL)
      CloseHandle(_hDL);

   DllRelease();
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::QueryInterface(const GUID &riid,void **ppv )
{
   *ppv = NULL ;
    if( IsEqualGUID(riid,IID_IUnknown) ) {
        *ppv = (IUnknown *) (IBindStatusCallback *)this;
    } else if (IsEqualGUID(riid,IID_IBindStatusCallback) ) {
        *ppv = (IBindStatusCallback *) this;
    } else if (IsEqualGUID(riid, IID_IAuthenticate))
        *ppv = (IAuthenticate *) this;

    if (*ppv)
    {
        // increment our reference count before we hand out our interface
        ((LPUNKNOWN)*ppv)->AddRef();
        return(NOERROR);
    }

    return( E_NOINTERFACE );
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloader::AddRef()
{
   return(++_cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloader::Release()
{
   if(!--_cRef)
   {
      delete this;
      return(0);
   }
   return( _cRef );
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
   // clear BINDINFO but keep its size
   DWORD cbSize = pbindInfo->cbSize;
   ZeroMemory( pbindInfo, cbSize );
   pbindInfo->cbSize = cbSize;
   
   *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE | BINDF_PREFERDEFAULTHANDLER;
   pbindInfo->dwBindVerb = BINDVERB_GET;
   return(NOERROR);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *p)
{
        // BUGBUG: should check to see options are what we think they are
   EnterCriticalSection(&g_cs);
   _pBnd = p;
   _pBnd->AddRef();
   LeaveCriticalSection(&g_cs);
   return(NOERROR);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::GetPriority(LONG *pnPriority)
{
   return(E_NOTIMPL);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
   IndicateWinsockActivity();
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM *pstgmed)
{
   // bring in major changes here
   HRESULT hr = NOERROR;

   DWORD dwRead = 0;
   DWORD dwReadThisCall = 0;
   DWORD dwWritten = 0;
   
   if(!_pStm)
   {
      _pStm = pstgmed->pstm;
      _pStm->AddRef();
   }
 
   
   // should ignore WAIT_TIMEOUT while getting bytes from urlmon
   _fTimeoutValid = FALSE;

   do
   {
      hr = _pStm->Read(g_szBuffer, BUFFERSIZE, &dwRead);
      if( SUCCEEDED(hr) || ( (hr == E_PENDING) && (dwRead > 0) ) )
      {
         if(_hFile)
            if(WriteFile(_hFile, g_szBuffer, dwRead, &dwWritten, NULL)) 
            {
               _uBytesSoFar += dwRead;
               dwReadThisCall += dwRead;
               if(_pCb)
                  _pCb->OnProgress(_uBytesSoFar >> 10, NULL);
            }
            else
            {
               hr = E_FAIL;
               Abort();
            }
      }     
   }  while (hr == NOERROR);
   // SetInstallBytes 
   SetBytes(dwReadThisCall, TRUE);

   _uTickCount = 0;
   _fTimeoutValid = TRUE;            // should increment dwTickCount if WAIT_TIMEOUT occurs now
           
	return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CDownloader::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
   return(E_NOTIMPL);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnLowResource(DWORD reserved)
{
   // BUGBUG: really should have this kind of harsh policy on this ...
   _pBnd->Abort();
   return(S_OK);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloader::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
   _fTimeoutValid = FALSE;
   StopClock(); 
  
   if((hrError == E_ABORT) && _fTimeout)
   {
      // This is the timeout case
      _hDLResult = INET_E_CONNECTION_TIMEOUT;
   }
   else
   {
      // this is all other cases
      _hDLResult = hrError;
   }
  
   SetEvent(_hDL);
   return(NOERROR);
}

/* IAuthenticate::Authenticate
*/

STDMETHODIMP CDownloader::Authenticate(HWND *phwnd,
                          LPWSTR *pszUserName, LPWSTR *pszPassword)
{
    if (!phwnd || !pszUserName || !pszPassword)
        return E_POINTER;

    *pszUserName = NULL;
    *pszPassword = NULL;

    // BUGBUG: Need to have our own window! NULL does not work!
    // *phwnd = NULL;
    *phwnd = GetDesktopWindow() ;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
   // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
   HRESULT hr = CreateURLMoniker(0,url,ppmkr);
   // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
   return( hr );
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT CDownloader::SetupDownload(LPCSTR pszUrl, IMyDownloadCallback *pcb, DWORD dwFlags, LPCSTR pszFilenameToUse)
{
   LPOLESTR pwszUrl;
   LPSTR pszFilename;

   if(!pszUrl) return E_INVALIDARG;

   lstrcpyn(_szURL, pszUrl, INTERNET_MAX_URL_LENGTH);
   
   pwszUrl = OLESTRFROMANSI(pszUrl);
   if(!pwszUrl) return E_OUTOFMEMORY;

   IMoniker *ptmpmkr;
   
   HRESULT hr = GetAMoniker( pwszUrl, &ptmpmkr );

   IBindCtx * pBindCtx = 0;

   if( SUCCEEDED(hr) )
   {
      if(SUCCEEDED(::CreateBindCtx(0,&pBindCtx)))
         hr = ::RegisterBindStatusCallback(pBindCtx, (IBindStatusCallback *) this, 0, 0) ;
   }

     
   if( SUCCEEDED(hr) )
   {
      AddRef();
   
      // setup path for download
      if(FAILED( CreateTempDirOnMaxDrive(_szDest, sizeof(_szDest))))
         goto GetOut;
      if(pszFilenameToUse)
      {
         SafeAddPath(_szDest, pszFilenameToUse, sizeof(_szDest));
      }
      else
      {
         pszFilename = ParseURLA(pszUrl);
         SafeAddPath(_szDest, pszFilename, sizeof(_szDest));
      }
   
      _pMkr = ptmpmkr;
      _pCb = pcb;
      _uFlags = dwFlags;
      _pBndContext = pBindCtx;
      _fTimeout = FALSE;
      _fTimeoutValid = TRUE;
      _uBytesSoFar = 0;
      _uTickCount = 0;
      _pStm = 0;
   }

GetOut:
   if(pwszUrl)
      CoTaskMemFree(pwszUrl);
   return hr;
}

HRESULT CDownloader::DoDownload(LPSTR pszPath, DWORD dwBufSize)
{
   HRESULT hr = NOERROR;
   BOOL fQuit = FALSE;
   DWORD dwRet;
   
   if(!_pMkr)
      return E_UNEXPECTED;
   
   pszPath[0] = 0;
   
   StartClock(); 

   // Create the file
   _hFile = CreateFile(_szDest, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
                 CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);  
   
   if(_hFile == INVALID_HANDLE_VALUE)
      hr = E_FAIL;
    
         
   if( SUCCEEDED(hr) )
      hr = _pMkr->BindToStorage( _pBndContext, 0, IID_IStream, (void**)&_pStm );

   // we need this here because it synchronus *FAIL* case, 
   // we Set the event in onstopbinding, but we skip the loop below so it
   // never gets reset.
   // If BindToStorage fails without even sending onstopbinding, we are resetting
   // an unsignalled event, which is OK.
   if(FAILED(hr))
      ResetEvent(_hDL);

   _pBndContext->Release();
   _pBndContext = 0;

   // here we wait for Bind to complete
   //Wait for download event or abort
   while(SUCCEEDED(hr) && !fQuit)
   {
      dwRet = MsgWaitForMultipleObjects(1, &_hDL, FALSE, 1000, QS_ALLINPUT);
      if(dwRet == WAIT_OBJECT_0)
      {
         // Download is finished
         hr = _hDLResult;
         ResetEvent(_hDL);
         break;
      }      
      else if(dwRet == WAIT_TIMEOUT)  // our wait has expired
      {
         if(_fTimeoutValid)
            _uTickCount++;

          // if our tick count is past threshold, abort the download
          // BUGBUG: What about synch. case? We can't time out
          if(_uTickCount >= TIMEOUT_PERIOD)
          {
             _fTimeout = TRUE;
             Abort();
          }
      }  
      else
      {
         MSG msg;
         // read all of the messages in this next loop 
         // removing each message as we read it 
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         { 
             // if it's a quit message we're out of here 
            if (msg.message == WM_QUIT)
               fQuit = TRUE; 
            else
            {
               // otherwise dispatch it 
              DispatchMessage(&msg); 
            } // end of PeekMessage while loop 
         }
      }
   }
   
   // clean up all our stuff
   if(_hFile != INVALID_HANDLE_VALUE)
      CloseHandle(_hFile);
   _hFile = INVALID_HANDLE_VALUE;

   // if we are not using cache and download succeeded, delete from cache
   if(SUCCEEDED(hr) && !(_uFlags & DOWNLOADFLAGS_USEWRITECACHE))
      DeleteUrlCacheEntry(_szURL);


   if(FAILED(hr))
   {
      GetParentDir(_szDest);
      DelNode(_szDest,0);
   }

   EnterCriticalSection(&g_cs);
   if(_pBnd)
   {
      _pBnd->Release();
      _pBnd = 0;
   }
   LeaveCriticalSection(&g_cs);

   _pCb = 0;
   
   if(_pStm)
   {
      _pStm->Release();
      _pStm = 0;
   }

   if(SUCCEEDED(hr))
      lstrcpyn(pszPath, _szDest, dwBufSize);

   _szDest[0] = 0;
   _szURL[0] = 0;
   Release();
   return hr;
}

HRESULT CDownloader::Suspend()
{

   // in theory, we could call _pBnd->Suspend here

   return NOERROR;
}

HRESULT CDownloader::Resume()
{

   // in theory, we could call _pBnd->Resume here

   return NOERROR;
}


HRESULT CDownloader::Abort()
{
   EnterCriticalSection(&g_cs);
   if(_pBnd) 
   {
      _pBnd->Abort();
   }
   LeaveCriticalSection(&g_cs);

   return NOERROR;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//
/*
HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
   // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
   HRESULT hr = CreateURLMoniker(0,url,ppmkr);
   // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
   return( hr );
}
*/

CPatchDownloader::CPatchDownloader(BOOL fEnable=FALSE) : CTimeTracker(0), _fEnable(fEnable)
{
}

CPatchDownloader::~CPatchDownloader()
{
    ;
}

HRESULT CPatchDownloader::SetupDownload(DWORD dwFullTotalSize, UINT uPatchCount, IMyDownloadCallback *pcb, LPCSTR pszDLDir)
{
    _dwFullTotalSize = dwFullTotalSize;
    _pCb             = pcb;
    _uNumDownloads   = uPatchCount;
    if (pszDLDir)
        lstrcpyn(_szPath, pszDLDir, sizeof(_szPath));
    else
        lstrcpy(_szPath, "");

    return S_OK;
}

HRESULT CPatchDownloader::DoDownload(LPCTSTR szFile)
{
    HINF hInf = NULL;
    HRESULT hr = S_OK;

    // We shouldn't be called if patching isn't available.
    if (!IsEnabled())
        return E_FAIL;

    // TODO: Advpext currently behaves as a synchronous call, so
    //       right now we can't do timeouts and progress bar ticks.
    StartClock(); 
   
    if(!IsNT())
    {
        DWORD fWin9x = 1;
        HKEY hKey;
        
        if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, PATCHWIN9xKEY,
                            0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            RegSetValueEx(hKey, "Usewin9xDirectory", 0, REG_DWORD, 
                            (LPBYTE)&fWin9x, sizeof(DWORD));
            RegCloseKey(hKey);
        }
    }



    if (SUCCEEDED(hr = OpenINFEngine(szFile, NULL, 0, &hInf, NULL)))
    {
        hr = g_pfnProcessFileSection(hInf, NULL, TRUE, "DefaultInstall", _szPath, CPatchDownloader::Callback, (LPVOID) this);
        CloseINFEngine(hInf);
    }

    _pCb = NULL;

    return hr;
}


BOOL CPatchDownloader::Callback(PATCH_DOWNLOAD_REASON Reason, PVOID lpvInfo, PVOID pvContext)
{
    if (!pvContext)
    {
        return FALSE;
    }

    CPatchDownloader *pPatchInst = (CPatchDownloader *) pvContext;

    switch (Reason) 
    {
        case PATCH_DOWNLOAD_ENDDOWNLOADINGDATA:
            break;

        case PATCH_DOWNLOAD_CONNECTING:   
        case PATCH_DOWNLOAD_FINDINGSITE:
        case PATCH_DOWNLOAD_DOWNLOADINGDATA:
            // Not interesting here...
            break;

        case PATCH_DOWNLOAD_PROGRESS:
            {
                PDOWNLOAD_INFO ProgressInfo = (PDOWNLOAD_INFO)lpvInfo;
                DWORD dwBytesDownloaded = ProgressInfo->dwBytesToDownload - ProgressInfo->dwBytesRemaining;

                // Convert to KB
                dwBytesDownloaded = dwBytesDownloaded >> 10;

                // Adjust because the progress needs to be reflected as if
                // it was a full download.
                dwBytesDownloaded *= pPatchInst->GetFullDownloadSize();
                if (ProgressInfo->dwBytesToDownload != 0)
                    dwBytesDownloaded /= ProgressInfo->dwBytesToDownload >> 10;
                
                // BUGBUG:  We have to handle more than 1 patching INF.
                //          This hack divides up the progress across
                //          multiple downloads.
                if (pPatchInst->GetDownloadCount() > 0)
                    dwBytesDownloaded /= pPatchInst->GetDownloadCount();

                pPatchInst->GetCallback()->OnProgress(dwBytesDownloaded, NULL);

                break;
            }


        case PATCH_DOWNLOAD_FILE_COMPLETED:     // AdditionalInfo is Source file downloaded
            {
                TCHAR szDstFile[MAX_PATH+1];

                lstrcpyn(szDstFile, pPatchInst->GetPath(), MAX_PATH);
                SafeAddPath(szDstFile, ParseURLA((LPCTSTR) lpvInfo), sizeof(szDstFile));

                // advpext cleans up for us when it's finished downloading all the files.
                CopyFile((LPCTSTR)lpvInfo, szDstFile, FALSE);
            }

            break;
        case PATCH_DOWNLOAD_FILE_FAILED:
            // advpext automatically retries failures 3 times
            return PATCH_DOWNLOAD_FLAG_RETRY;
        default:
            break;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\extract.cpp ===
#include "inspch.h"
#include "debug.h"
#include "extract.h"

// for ASSERT and FAIL
//
SZTHISFILE

//
//
//  THIS FILE IS NOT USED ANYMORE -- EXTRACT FUNCGIONALITY IS NOW IN ADVPACK
//  AND IT TALKS TO CABINET.DLL/URLMON.DLL AS APPROPRIATE. THIS WILL BE
//  DELFILE-D
//
//
typedef HRESULT (WINAPI *EXTRACT) (PSESSION psess, LPCSTR lpCabName);

VOID FreeFileList(PSESSION psess);
VOID FreeFileNode(PFNAME pfname);
BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList);
int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList);


//=--------------------------------------------------------------------------=
// ExtractFiles
//=--------------------------------------------------------------------------=
//
// Parameters:
//    LPCSTR	pszCabName	- [in]  full qualified filename to the .CAB file
//    LPCSTR	pszExpandDir- [in]  full qualified path to where to extract the file(s)
//    DWORD     dwFlags		- [in]  Flags, currently not used
//    LPCSTR    pszFileList - [in]  colon separated list of files to extract from pszCabName
//                                  or NULL for all files
//    LPVOID    lpReserved  - [in]  currently not used
//    DWORD		dwReserved	- [in]  currently not used
//
// Return HRESULT:
//      E_INVALIDARG    - if pszCabName or pszExpandDir == NULL
//      E_OUTOFMEMORY   - if we could not allocate our memory
//      E_FAIL          - if no files in pszFileList and pszFileList!=NULL
//                        if not all files from pszFileList are in the .CAB file
//                        if Extract return S_FALSE
//      any E_ code Extract returns
//
// Note: This function would not extract any file from the pszFileList, if not all
//       of them are in the .CAB file. If one or more are not in the .CAB file
//       the function does not extract any and returns E_FAIL
//
HRESULT ExtractFiles(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                     LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved)
{
    HINSTANCE hinst;
    PSESSION  psess = NULL;
    PFNAME    pf = NULL;
    PFNAME    pfPriv = NULL;
    HRESULT   hr = E_FAIL;          // Return error
    LPSTR     pszMyFileList = NULL;
    EXTRACT   fpExtract = NULL;
    int       iFiles = 0;                // number of files in list

    // Do checking for valid values??
    if ((!pszCabName) || (!pszExpandDir))
        return E_INVALIDARG;

    hinst = LoadLibrary("URLMON.DLL");
    if (hinst)
    {
        fpExtract = (EXTRACT)GetProcAddress(hinst, "Extract");
        if (fpExtract)
        {
            psess = (PSESSION)LocalAlloc(LPTR, sizeof(SESSION));
            if (psess) 
            {
                lstrcpy(psess->achLocation, pszExpandDir);
                // Initialize the structure
                if (pszFileList == NULL)
                {
                    // Extract all
                    psess->flags = SESSION_FLAG_EXTRACT_ALL|SESSION_FLAG_ENUMERATE;
                    hr = fpExtract(psess, pszCabName);
                    // BUGBUG: What if psess->erf reports an error??
                }
                else
                {
                    // I append a '/0' therefor +2
                    pszMyFileList = (LPSTR)LocalAlloc(LPTR, lstrlen(pszFileList)+2);
                    if (pszMyFileList)
                    {
                        iFiles = PrepareFileList(pszMyFileList, pszFileList);
                        psess->flags = SESSION_FLAG_ENUMERATE;

                        if  ((iFiles > 0) &&
                             ( !FAILED(hr = fpExtract(psess, pszCabName)) ))
                            // What if psess->erf reports an error??
                        {
                        // If there are files in the list and we enumarated files
                        
                            // Got the list of files in the cab
                            pfPriv = NULL;
                            pf = psess->pFileList;
                            while (pf != NULL )
                            {
                                if (!IsFileInList(pf->pszFilename, pszMyFileList))
                                {
                                    // Delete the node from the list
                                    if (pfPriv == NULL)
                                    {
                                        // Delete the head
                                        psess->pFileList = pf->pNextName;
                                        FreeFileNode(pf);
                                        pf = psess->pFileList;
                                    }
                                    else
                                    {
                                        pfPriv->pNextName = pf->pNextName;
                                        FreeFileNode(pf);
                                        pf = pfPriv->pNextName;
                                    }
                                }
                                else
                                {
                                    // Just go to the next one
                                    pfPriv = pf;
                                    pf = pf->pNextName;
                                    iFiles--;
                                }
                            }

                            if ((psess->pFileList) && (iFiles == 0))
                            {
                                // Reset the error flag
                                psess->erf.fError = FALSE;
                                psess->erf.erfOper = 0;

                                psess->pFilesToExtract = psess->pFileList;
                                psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated
                                hr = fpExtract(psess, pszCabName);
                                // BUGBUG: What if psess->erf reports an error??
                            }
                            else
                                hr = E_FAIL;    // File(s) is not in cab.
                        }

                        LocalFree(pszMyFileList);
                        pszMyFileList = NULL;

                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                FreeFileList(psess);
                LocalFree(psess);
                psess = NULL;
            }
            else
                hr = E_OUTOFMEMORY;

        }
        FreeLibrary(hinst);
    }

    // Extract may only return S_FALSE in a failure case.
    if (!FAILED(hr) && (hr == S_FALSE))
        hr = E_FAIL;
    return (hr);
}


VOID FreeFileList(PSESSION psess)
{
    PFNAME      rover = psess->pFileList;
    PFNAME      roverprev;

    while (rover != NULL)  
    {

        roverprev = rover;  // save for free'ing current rover below
        rover = rover->pNextName;

        FreeFileNode(roverprev);
    }

    psess->pFileList = NULL; // prevent use after deletion!
}

VOID FreeFileNode(PFNAME pfname)
{
    CoTaskMemFree(pfname->pszFilename);
    CoTaskMemFree(pfname);
}


BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList)
{
    char *p;
    int  iLenFile = lstrlen(pszFile);
    BOOL bFound = FALSE;

    p = pszFileList;
    while ((*p != '\0') && (!bFound))
    {
        if (lstrlen(p) == iLenFile)
            bFound = (lstrcmpi(p, pszFile) == 0);
        if (!bFound)
            p += lstrlen(p) + 1;
    }
    return (bFound);
}

int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList)
{
    int  iFiles = 0;                // number of files in list
    char *p;
    p = (LPSTR)pszInFileList;       // p is used to point into both arrays 

    // trim leading spaces, tabs or : 
    while ((*p == ' ') || (*p == '\t') || (*p == ':'))
        p++;
    lstrcpy(pszOutFileList, p);

    p = pszOutFileList;
    if (lstrlen(pszOutFileList) > 0)
    {
        // Only if we have atleast one character left.
        // This cannot be a space of tab, because we 
        // would have removed this above.
        p += (lstrlen(pszOutFileList) - 1);

        // trim railing spaces, tabs or :
        while ((*p == ' ') || (*p == '\t') || (*p == ':'))
            p--;

        // Put a '\0' for the last space/tab
        *(++p) = '\0';
    }

    if (*pszOutFileList)
    {
        iFiles++;
        // Now replace ':' with '\0'
        p = pszOutFileList;
        while (*p != '\0')
        {
            if (*p == ':')
            {
                *p = '\0';
                iFiles++;
            }
            p++;
        }
        // Make sure we have a double '\0' at the end.
        *(++p) = '\0';
    }
    return iFiles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\enum.h ===
#define PARENTTYPE_CIF      0
#define PARENTTYPE_GROUP    1
#define PARENTTYPE_MODE     2

// 0 = CCifCile, 1 = CCifGroup, 2 = CCifMode


class CCifEntryEnum
{
   public:
      CCifEntryEnum(UINT dwFilter, UINT dwParentType, LPSTR pszParentID);
      ~CCifEntryEnum();

   protected:
      UINT    _cRef;
      UINT    _uIndex;
      char    _szParentID[MAX_ID_LENGTH];
      UINT    _uFilter;
      UINT    _uParentType;   // 0 = CCifCile, 1 = CCifGroup, 2 = CCifMode

};

class CCifComponentEnum : public CCifEntryEnum, public IEnumCifComponents
{
   public:
      CCifComponentEnum(CCifComponent **pp, UINT dwFilter, UINT dwParentType, LPSTR pszParentID);
      ~CCifComponentEnum();


      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();

      // enum methods
      STDMETHOD(Next)(ICifComponent **);
      STDMETHOD(Reset)();
   private:
       CCifComponent **_rpComp;
};

class CCifGroupEnum : public CCifEntryEnum, public IEnumCifGroups
{
public:
      CCifGroupEnum(CCifGroup **pp, UINT dwFilter);
      ~CCifGroupEnum();


      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();

      // enum methods
      STDMETHOD(Next)(ICifGroup **);
      STDMETHOD(Reset)();
   private:
       CCifGroup **_rpGroup;
};

class CCifModeEnum : public CCifEntryEnum, public IEnumCifModes
{
   public:
      CCifModeEnum(CCifMode **pp, UINT dwFilter);
      ~CCifModeEnum();


      // *** IUnknown methods ***
      STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
      STDMETHOD_(ULONG,AddRef) ();
      STDMETHOD_(ULONG,Release) ();

      // enum methods
      STDMETHOD(Next)(ICifMode **);
      STDMETHOD(Reset)();
   private:
       CCifMode **_rpMode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\iguids.cpp ===
//=--------------------------------------------------------------------------=
// iguids.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// contains the guids we will define 
//


#include "inspch.h"

#define INITGUID
#include <initguid.h>
#include "inseng.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\extract.h ===
#ifndef _CDL_H_
#define _CDL_H_

// #define  USE_BINDHOST    1


// CDL.h
// Code Downloader header file
//
// Read "class descriptions" first for understanding how the
// code downloader works.

#ifdef __cplusplus
extern "C" {
#endif

/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */


// buffer size for downloads in CBSC::m_cbuffer
#define BUFFERMAX 2048

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;

// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

// FILE extentions we know about
typedef enum {
    FILEXTN_NONE,
    FILEXTN_UNKNOWN,
    FILEXTN_CAB,
    FILEXTN_DLL,
    FILEXTN_OCX,
    FILEXTN_INF,
    FILEXTN_EXE,
} FILEXTN;


//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERF         erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    char        achLocation[MAX_PATH];  // Dest Dir
    char        achFile[MAX_PATH];      // Current File
    char        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;



#ifdef __cplusplus
}
#endif
#endif // _CDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\insdown.cpp ===
//=--------------------------------------------------------------------------=
// inseng.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
//
#include "inspch.h"
#include "regstr.h"
#include "globals.h"
#include "insobj.h"
#include "resource.h"
#include "diskspac.h"

#define GRPCONV  "grpconv -o"

#define BUFFERSIZE 4096



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CInstallEngine::CInstallEngine(IUnknown **punk)
{
   DWORD dwThreadID;
   HANDLE hThread;
   HKEY hKey = NULL;
   char szBuf[16];
   DWORD dwType;

   GetWindowsDirectory(g_szWindowsDir, sizeof(g_szWindowsDir));
   if(g_szWindowsDir[0] >= 'a' && g_szWindowsDir[0] <= 'z')
      g_szWindowsDir[0] -= 32;

   hThread = CreateThread(NULL, 0, CleanUpAllDirs, NULL, 0, &dwThreadID);
   CloseHandle(hThread);
   _chInsDrive = g_szWindowsDir[0];
   
   // Decide whether we are in stepping mode or not
   _uCommandMode = 0;
   _fSteppingMode = FALSE;
   _fResetTrust = TRUE;
   _fIgnoreTrust = FALSE;
   if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACTIVESETUP_KEY,0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
   {
      // Get Steeping mode value. OK if not present
      DWORD dwSize = sizeof(szBuf);
      if(RegQueryValueEx(hKey, STEPPING_VALUE, NULL, &dwType, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
      {
         if(szBuf[0] == 'y' || szBuf[0] == 'Y')
            _fSteppingMode = TRUE;
      }
 
      // Get CommandMode value. OK if not present
      dwSize = sizeof(szBuf);
      if(RegQueryValueEx(hKey, COMMAND_VALUE, NULL, &dwType, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
      {
         _uCommandMode = AtoL(szBuf);
         // Once we read it, set it to zero
         // BUGBUG: beware of hardcoded "0" and 2 below (2 includes null terminator)
         RegSetValueEx(hKey, COMMAND_VALUE, 0, REG_SZ, (BYTE *) "0", 2 ); 
      }

      if(RegQueryValueEx(hKey, CHECKTRUST_VALUE, NULL, &dwType, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
      {
         if(szBuf[0] == 'Y' || szBuf[0] == 'y')
         {
            _fIgnoreTrust = TRUE;
            _fResetTrust = FALSE;
         }
         // Once we read it, set it to zero
         // BUGBUG: beware of hardcoded "0" and 2 below (2 includes null terminator)
         RegDeleteValue(hKey, CHECKTRUST_VALUE); 
      }
 
 
      RegCloseKey(hKey);
   }
    
   _hwndForUI = NULL;
   _pStmLog = NULL;
   _fIgnoreDownloadError = FALSE;
   _enginestatus = ENGINESTATUS_NOTREADY;
   _dwStatus = 0;
   _pcb = NULL;
   _cRef = 0;
   _dwDLRemaining = 0;
   _dwInstallRemaining = 0;
   _dwInstallOld = 0;
   _dwDLOld = 0;
   _fUseCache = FALSE;
   _dwInstallOptions = INSTALLOPTIONS_DOWNLOAD | INSTALLOPTIONS_INSTALL;
   _hContinue = NULL;
   _hAbort = NULL;
   _fCleanUpDir = FALSE;
   //init CCifFile
   _pCif = new CCifFile();
   _pCif->AddRef();
   _pCif->SetInstallEngine(this);
   // init downloader
   _pDL = new CDownloader();
   _pIns = new CInstaller(this);

   _szBaseUrl[0] = 0;

   _fSRLiteAvailable = IsPatchableIEVersion() && IsCorrectAdvpExt() && InitSRLiteLibs();
   if (!_fSRLiteAvailable)
       WriteToLog("Install engine failed to initialize the advpack extension DLL\r\n", FALSE);
   
   _pPDL = new CPatchDownloader(_fSRLiteAvailable);

   AddRef();
   *punk = (IInstallEngine *) this;
}

//=--------------------------------------------------------------------------=
// CInstallEngine::~CInstallEngine
//=--------------------------------------------------------------------------=
// Destructor for InstallEngine class
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CInstallEngine::~CInstallEngine()
{
   char szBuf[MAX_PATH];

   WriteToLog("Install Engine - object destroyed\r\n", TRUE);
   
   if(_fCleanUpDir)
   {
      lstrcpy(szBuf, _pCif->GetDownloadDir());
   }

   if(_hAbort)
      CloseHandle(_hAbort);
   
   if(_hContinue)
      CloseHandle(_hContinue);
      
   if(_pStmLog)
      _pStmLog->Release();

   _pcb = NULL;
                               
   _pCif->Release();

   _pDL->Release();

   delete _pPDL;

   _pIns->Release();

   if(_fCleanUpDir)
   {
      CleanUpTempDir(szBuf);
   }

   FreeSRLiteLibs();

   DllRelease();
}

//************ IUnknown implementation ***************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngine::AddRef()                      
{
   return(_cRef++);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngine::Release()
{
   ULONG temp = --_cRef;

   if(temp == 0)
      delete this;
   return temp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if((riid == IID_IUnknown) || (riid == IID_IInstallEngine))
      *ppv = (IInstallEngine *)this;
   else if(riid == IID_IInstallEngineTiming)
      *ppv = (IInstallEngineTiming *)this;
   else if(riid == IID_IInstallEngine2)
      *ppv = (IInstallEngine2 *)this;

   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

//************* IInstallEngine interface ************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetLocalCif(LPCSTR pszCifPath)
{
   HCURSOR hNew = NULL;
   HCURSOR hOld = NULL;
   
   OnEngineStatusChange(ENGINESTATUS_LOADING, 0);
   
   hNew = LoadCursor(NULL, IDC_WAIT);
   hOld = SetCursor(hNew);
   
   HRESULT hr = _pCif->SetCifFile(pszCifPath, FALSE);
   if(SUCCEEDED(hr))
      OnEngineStatusChange(ENGINESTATUS_READY, 0);
   else 
      OnEngineStatusChange(ENGINESTATUS_NOTREADY, hr);
   
   SetCursor(hOld);
   
   return hr;
}

STDMETHODIMP CInstallEngine::GetICifFile(ICifFile **pic)
{
   *pic = (ICifFile *) _pCif;
   (*pic)->AddRef();
   return NOERROR;
}

STDMETHODIMP CInstallEngine::GetEngineStatus(DWORD * theenginestatus)
{
  *theenginestatus = _enginestatus;
   return(NOERROR);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::Abort(DWORD lFlag)
{
   // If we are NOT downLOADING or INSTALLING, an abort command makes no sense.
   if( !(_enginestatus == ENGINESTATUS_INSTALLING || _enginestatus == ENGINESTATUS_LOADING) )
      return E_UNEXPECTED;

   // if we are downloading, this will cause the abort to filter thru
   _pDL->Abort();

   // this will abort an install if possible
   _pIns->Abort();
   
   // any other time, we will pick this up just as soon as we can
   SetEvent(_hAbort);

   WriteToLog("Install Engine - Abort called\r\n", FALSE);
   
   return(NOERROR);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::Suspend()
{
   HRESULT hr;

   if(_enginestatus != ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;

   WriteToLog("Install Engine - Suspend called\r\n", FALSE);
   
 
   _pDL->Suspend();

   // we only catch suspend return, because it tells us "zsafe to cancel or not"
   hr = _pIns->Suspend();
   
   ResetEvent(_hContinue);
 
   // If we cant create the resume event, we will fail this call and not pause
        
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::Resume()
{
   if(_enginestatus != ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;

   WriteToLog("Install Engine - Resume called\r\n", FALSE);
   
   _pDL->Resume();

   _pIns->Resume();

   SetEvent(_hContinue);
   
   return NOERROR;
}
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetCifFile(LPCSTR pszCabName, LPCSTR pszCifName)
{
   HRESULT hr = NOERROR;
   HANDLE hThread;
   DWORD dwThreadID;

   if(_enginestatus == ENGINESTATUS_LOADING || _enginestatus == ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;

   SETCIFARGS *p = new SETCIFARGS;

   if(_szBaseUrl[0] != 0)
   {
      p->szUrl[0] = '\0';
      lstrcpyn(p->szUrl, _szBaseUrl, 
               INTERNET_MAX_URL_LENGTH - (lstrlen(pszCabName) + 2));
      lstrcat(p->szUrl, "/");
      lstrcat(p->szUrl, pszCabName);
   }
   else
   {
      lstrcpy(p->szUrl, "file://");
      lstrcat(p->szUrl, _pCif->GetDownloadDir());
      SafeAddPath(p->szUrl, pszCabName, sizeof(p->szUrl));
   }

   lstrcpyn(p->szCif, pszCifName, MAX_PATH);

   p->pCif = _pCif;
    
   // do the actual downloading of the CIF file in a separate thread
   if ((hThread = CreateThread(NULL, 0, DownloadCifFile, (LPVOID) p, 0, &dwThreadID)) != NULL)
      CloseHandle(hThread);
   else
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
   }
   
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetBaseUrl(LPCSTR pszBaseName)
{
   DWORD dwLen;

   if(_enginestatus == ENGINESTATUS_INSTALLING)
      if(!_IsValidBaseUrl(pszBaseName))
         return E_UNEXPECTED;
   
   lstrcpyn(_szBaseUrl, pszBaseName, INTERNET_MAX_URL_LENGTH);

   wsprintf(szLogBuf,"Install Engine - base url set to %s\r\n", pszBaseName);
   WriteToLog(szLogBuf, FALSE);

   return NOERROR;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetDownloadDir(LPCSTR pszDLDir)
{
   char szBuf[MAX_PATH];
   DWORD dwLen;
   DWORD dwVer;
   
   if(_enginestatus == ENGINESTATUS_INSTALLING)
      return E_UNEXPECTED;
   
   if(pszDLDir != NULL && lstrlen(pszDLDir) > (MAX_PATH - 20))
      return E_FAIL;

   // clean up what we have
   if(_fCleanUpDir)
   {
      DelNode(_pCif->GetDownloadDir(), 0);
      _fCleanUpDir = FALSE;
   }

   if(pszDLDir == NULL)
   {
      _fCleanUpDir = TRUE;
      if(FAILED(CreateTempDirOnMaxDrive(szBuf, sizeof(szBuf))))
         return E_FAIL;
   }
   else
   {
      _fCleanUpDir = FALSE;
      // Make sure the directory exists
      if(GetFileAttributes(pszDLDir) == 0xffffffff)
         CreateDirectory(pszDLDir, NULL);
   }

   _pCif->SetDownloadDir(pszDLDir ? pszDLDir : szBuf);

   wsprintf(szLogBuf,"Install Engine - download directory set to %s\r\n", _pCif->GetDownloadDir());
   WriteToLog(szLogBuf, FALSE);

   return NOERROR;
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::IsComponentInstalled(LPCSTR pszComponentID, DWORD *lResult)
{
   DWORD dwResult = ICI_NOTINSTALLED;
   
   ICifComponent *pComp = NULL;
   
   if(SUCCEEDED(_pCif->FindComponent(pszComponentID, &pComp)))
   {
      dwResult = pComp->IsComponentInstalled();
   }
      
   *lResult = dwResult;

   return(pComp ? NOERROR : E_INVALIDARG);
}


STDMETHODIMP CInstallEngine::SetInstallDrive(CHAR chDrive)
{
   HRESULT hr = E_INVALIDARG;

   if(chDrive >= 'a' && chDrive <= 'z')
      chDrive -= 32;

   if(chDrive >= 'A' && chDrive <= 'Z')
   {
      hr = NOERROR;
      _chInsDrive = chDrive;
   }   
   return hr;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetInstallOptions(DWORD dwOptions)
{
   _fUseCache = !(dwOptions & INSTALLOPTIONS_NOCACHE);
   _dwInstallOptions = dwOptions;
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetInstallOptions(DWORD *pdwOptions)
{
    if (!pdwOptions)
        return E_POINTER;
    else
    {
        *pdwOptions = _dwInstallOptions;
        return NOERROR;
    }
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetSizes(LPCSTR pszID, COMPONENT_SIZES *p) 
{
   if(!p)
      return E_POINTER;

   // work around bug in old versions of jobexec where it didn't init
   // this field properly

   if(p->cbSize > sizeof(COMPONENT_SIZES))
      p->cbSize = COMPONENTSIZES_SIZE_V1;

   DWORD dwSize = p->cbSize; 
   ZeroMemory(p, p->cbSize);
   p->cbSize = dwSize;
   
   if(_enginestatus != ENGINESTATUS_READY)
      return E_UNEXPECTED;
  
   if(pszID != NULL)
   {
      ICifComponent *pComp = NULL;

      if(SUCCEEDED(_pCif->FindComponent(pszID, &pComp)))
      {
         DWORD dwWin, dwApp;
         p->dwDownloadSize = pComp->GetDownloadSize();
         pComp->GetInstalledSize(&dwWin, &dwApp);
         p->dwInstallSize = dwApp;
         p->dwWinDriveSize = dwWin;
      }
      else
         return E_INVALIDARG;
   }
   else
      _GetTotalSizes(p);
   
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//


void CInstallEngine::_GetTotalSizes(COMPONENT_SIZES *pSizes)
{
   ICifComponent *pComp;
   DriveInfo drvinfo[3];
   LPSTR pszDep = NULL;
   UINT uTempDrive;
   UINT uWinDrive = 0;
   UINT uInstallDrive = 1;
   UINT uDownloadDrive = 2;
   LPCSTR pszDownloadDir = _pCif->GetDownloadDir();
   COMPONENT_SIZES   Sizes;

   ZeroMemory(&Sizes, sizeof(COMPONENT_SIZES));
   
   // Fill in all arrays to start
   
   drvinfo[uWinDrive].InitDrive(g_szWindowsDir[0]);
   
   if(_dwInstallOptions & INSTALLOPTIONS_INSTALL)
   {
      // We know we can do a compare because these are always uppcase
      if(_chInsDrive != drvinfo[uWinDrive].Drive())
      {
         drvinfo[uInstallDrive].InitDrive(_chInsDrive);
      }
      else 
         uInstallDrive = uWinDrive;
   }

   if(_dwInstallOptions & INSTALLOPTIONS_DOWNLOAD)
   {
      if(pszDownloadDir[0] == drvinfo[uWinDrive].Drive())
         uDownloadDrive = uWinDrive;
      else if(pszDownloadDir[0] == drvinfo[uInstallDrive].Drive())
         uDownloadDrive = uInstallDrive;
      else
         drvinfo[uDownloadDrive].InitDrive(pszDownloadDir[0]);
   }

   // do space for download phase (easy part)
   if(_dwInstallOptions & INSTALLOPTIONS_DOWNLOAD)
   {
      Sizes.dwDownloadSize = _GetActualDownloadSize(FALSE);
      Sizes.dwTotalDownloadSize = _GetTotalDownloadSize();
      Sizes.dwDependancySize = 0;

      // add download to download drive
      drvinfo[uDownloadDrive].UseSpace(Sizes.dwDownloadSize + Sizes.dwDependancySize, TRUE);
   
      // if going to cache
      // BUGBUG: we still assume cache is on windows drive
      if(_fUseCache)
      {
         drvinfo[uWinDrive].UseSpace(Sizes.dwDownloadSize + Sizes.dwDependancySize, TRUE);
      }
   }

   // do space for install (hard part)
   if(_dwInstallOptions & INSTALLOPTIONS_INSTALL)
   {
      // walk the install list in order (very important)
      // do any dependancy, then original
      IEnumCifComponents *penum;
      ICifComponent *pComp = NULL;

      _pCif->EnumComponents(&penum, 0, NULL);
      for(penum->Next(&pComp); pComp; penum->Next(&pComp))
      {
         if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
         {
            DWORD dwWin, dwApp;
            
            pComp->GetInstalledSize(&dwWin, &dwApp);
            // add install
            // add the install size
            Sizes.dwInstallSize += dwApp;
            // size that goes to windows dir
            Sizes.dwWinDriveSize += dwWin;
                           
            drvinfo[uInstallDrive].UseSpace(dwApp, FALSE);
            drvinfo[uWinDrive].UseSpace(dwWin, FALSE);
            // Add (and then remove) temp space
            AddTempSpace(pComp->GetDownloadSize(), pComp->GetExtractSize(), drvinfo);
                           
          
         }
      }
      penum->Release();
   }
    
   // fill in the required amounts
   Sizes.dwWinDriveReq = drvinfo[uWinDrive].MaxUsed();
   Sizes.chWinDrive = drvinfo[uWinDrive].Drive();

   if(uWinDrive != uInstallDrive)
   {
      Sizes.dwInstallDriveReq = drvinfo[uInstallDrive].MaxUsed();
      Sizes.chInstallDrive = drvinfo[uInstallDrive].Drive();
   }
   if((uDownloadDrive != uWinDrive) && (uDownloadDrive != uInstallDrive))
   {
      Sizes.dwDownloadDriveReq = drvinfo[uDownloadDrive].MaxUsed();
      Sizes.chDownloadDrive = drvinfo[uDownloadDrive].Drive();
   }

   CopyMemory((LPVOID)(&(pSizes->dwInstallSize)), (LPVOID)(&(Sizes.dwInstallSize)), 
      pSizes->cbSize - sizeof(DWORD)); 
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetAction(LPCSTR pszComponentID, DWORD action, DWORD dwPriority)
{
   HRESULT hr = NOERROR;

   if(_enginestatus != ENGINESTATUS_READY)
      return E_UNEXPECTED;
  
   ICifComponent *pComp = NULL;  
   
   if(pszComponentID == NULL || lstrlen(pszComponentID) == 0)
   {
      _pCif->ClearQueueState();
   }
   else
   {
      if(SUCCEEDED(_pCif->FindComponent(pszComponentID, &pComp)))
      {
         if(dwPriority != 0xffffffff)
            pComp->SetCurrentPriority(dwPriority);
         hr = pComp->SetInstallQueueState(action);
      }
      else
         hr = E_INVALIDARG;
   }
   return hr;
}

// the following two are now ridiculously inefficient. New clients should use the enumerators

STDMETHODIMP CInstallEngine::EnumInstallIDs(UINT uIndex, LPSTR *ppszID)
{
   HRESULT hr;
   UINT i = 0;
   *ppszID = NULL;

   IEnumCifComponents *penum;
   ICifComponent *pComp;
   
   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState())
      {
         if(uIndex == i)
            break;
         i++;
      }
   }
   penum->Release();
   if(pComp)
   {
      char szID[MAX_ID_LENGTH];
      pComp->GetID(szID, sizeof(szID));
      *ppszID = COPYANSISTR(szID);
      hr = NOERROR;
   }
   else
      hr = E_FAIL;

   return hr;
}


STDMETHODIMP CInstallEngine::EnumDownloadIDs(UINT uIndex, LPSTR *ppszID)
{
   HRESULT hr;
   UINT i = 0;
   *ppszID = NULL;

   IEnumCifComponents *penum;
   ICifComponent *pComp;
   
   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() && (pComp->IsComponentDownloaded() == S_FALSE))
      {
         if(uIndex == i)
            break;
         i++;
      }
   }
   penum->Release();
   if(pComp)
   {
      char szID[MAX_ID_LENGTH];
      pComp->GetID(szID, sizeof(szID));
      *ppszID = COPYANSISTR(szID);
      hr = NOERROR;
   }
   else
      hr = E_FAIL;

   return hr;
   
}

 
//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::DownloadComponents(DWORD lFlags)
{
   DWORD dwThreadID;
   HRESULT hr = NOERROR;
   
   WriteToLog("Install Engine - Starting download phase\r\n", TRUE);
   if(_enginestatus == ENGINESTATUS_NOTREADY || _enginestatus == ENGINESTATUS_LOADING)
      hr = E_UNEXPECTED;

   // BUGBUG - add a downloading status? it really just a "busy" indication
   if(_enginestatus == ENGINESTATUS_INSTALLING)
      hr = E_PENDING;


   if(SUCCEEDED(hr))
   {   
      OnEngineStatusChange(ENGINESTATUS_INSTALLING, 0);

      // since trust may be set globally, only turn it on, not off
      if(EXECUTEJOB_IGNORETRUST & lFlags)
         _fIgnoreTrust = TRUE;

      if(EXECUTEJOB_IGNOREDOWNLOADERROR & lFlags)
         _fIgnoreDownloadError = TRUE;
      else
         _fIgnoreDownloadError = FALSE;

      HANDLE h = CreateThread(NULL, 0, InitDownloader, this, 0, &dwThreadID);
      if(h == NULL)
      {
         // Won't be doing any downloading today.....
         hr = E_FAIL;
      }
      else
         CloseHandle(h);
   }

   return hr;
} 

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::InstallComponents(DWORD lFlags)
{
   DWORD dwThreadID;
   HRESULT hr = NOERROR;

   WriteToLog("Install Engine - Starting install phase\r\n", TRUE);

   EnterCriticalSection(&g_cs);
   if(_enginestatus == ENGINESTATUS_NOTREADY || _enginestatus == ENGINESTATUS_LOADING)
      hr = E_UNEXPECTED;

   if(_enginestatus == ENGINESTATUS_INSTALLING)
      hr = E_PENDING;
   LeaveCriticalSection(&g_cs);

   if(SUCCEEDED(hr))
   {   
      // We first check to see if all files are present
      // by seeing if we would download anything!!!
      //
      if(EXECUTEJOB_VERIFYFILES & lFlags)
      {
         WriteToLog("Checking for missing files\r\n", FALSE);
         if(_GetActualDownloadSize(TRUE) != 0)
           return E_FILESMISSING;
      }
         
      OnEngineStatusChange(ENGINESTATUS_INSTALLING, 0);

      // since trust may be set globally, only turn it on, not off
      if(EXECUTEJOB_IGNORETRUST & lFlags)
         _fIgnoreTrust = TRUE;

      HANDLE h = CreateThread(NULL, 0, InitInstaller, this, 0, &dwThreadID);
      if(h == NULL)
      {
         // Won't be doing any installing today.....
         hr = E_FAIL;
      }
      else
         CloseHandle(h);
   }

   return hr;
} 


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD WINAPI InitInstaller(LPVOID pv)
{
   CInstallEngine *pInsEng = (CInstallEngine *) pv;
   HRESULT hr = S_OK;
   BOOL fOneInstalled = FALSE;
   
   ICifComponent *pComp;

   EnableSage(FALSE);
   EnableScreenSaver(FALSE);
   EnableDiskCleaner(FALSE);

   pInsEng->_dwStatus = 0;
   
   pInsEng->_hAbort = CreateEvent(NULL, FALSE, FALSE, NULL);
   pInsEng->_hContinue = CreateEvent(NULL, TRUE, TRUE, NULL);
   
   //BUGBUG check for failure
   
   pInsEng->AddRef();

   pInsEng->OnStartInstall(0, pInsEng->_GetTotalInstallSize());

   // check trust the Cif cab if it has not been done so
   hr = pInsEng->CheckForContinue();
  
   // this is the install pass
   if(SUCCEEDED(hr))
      hr = pInsEng->_pCif->Install(&fOneInstalled);
      
   if(fOneInstalled && FNeedGrpConv())
   {
      if(!(pInsEng->GetStatus() & STOPINSTALL_REBOOTNEEDED))
      {
         // if we dont need a reboot launch grpconv immeadiatly
         HANDLE h = NULL;
         pInsEng->WriteToLog("Install Engine - No reboot required\r\n", FALSE);
         LaunchAndWait(GRPCONV, NULL, &h, NULL, SW_SHOWMINIMIZED);
         if(h)
            CloseHandle(h);
      }
      else
      {
         HKEY hKey;
         DWORD dumb;
         // otherwise put grpconv into runonce
         if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE,
            0,0,0, KEY_SET_VALUE, NULL, &hKey, &dumb) == ERROR_SUCCESS)
         {
            RegSetValueEx(hKey, "GrpConv", 0, REG_SZ, 
               (BYTE *) GRPCONV, sizeof(GRPCONV));
            RegCloseKey(hKey);
         }
      }
   }
   
   
   // reset to checking trust
   if(pInsEng->_fResetTrust)
      pInsEng->_fIgnoreTrust = FALSE;
   // Send a install all done message

   if(!(pInsEng->GetStatus() & STOPINSTALL_REBOOTNEEDED))
   {
       // If we don't need a reboot, enable the screen saver and sage.
       EnableScreenSaver(TRUE);
       EnableSage(TRUE);
   }
   EnableDiskCleaner(TRUE);

   CloseHandle(pInsEng->_hAbort);
   pInsEng->_hAbort = NULL;
   
   CloseHandle(pInsEng->_hContinue);
   pInsEng->_hContinue = NULL;
      
   
   pInsEng->OnStopInstall(hr, NULL, pInsEng->GetStatus());
   pInsEng->OnEngineStatusChange(ENGINESTATUS_READY, 0);
   
   pInsEng->Release();


   return 0;
}   

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD WINAPI InitDownloader(LPVOID pv)
{
   CInstallEngine *pInsEng = (CInstallEngine *) pv;
   HRESULT hr = S_OK;
  
   EnableSage(FALSE);
   EnableScreenSaver(FALSE);
   EnableDiskCleaner(FALSE);

   pInsEng->_hAbort = CreateEvent(NULL, FALSE, FALSE, NULL);
   pInsEng->_hContinue = CreateEvent(NULL, TRUE, TRUE, NULL);
   
   //BUGBUG check for failure
   
   pInsEng->AddRef();

   pInsEng->OnStartInstall(pInsEng->_GetActualDownloadSize(FALSE), 0);

   // check trust the Cif cab if it has not been done so
   hr = pInsEng->CheckForContinue();
  
   // this is the download pass
   if(SUCCEEDED(hr))
   {
      hr = pInsEng->_pCif->Download();
   }

   if(SUCCEEDED(hr))
   {
      pInsEng->WriteToLog("Install Engine - Download complete\r\n", FALSE);
   }
   
   // reset to checking trust
   if(pInsEng->_fResetTrust)
      pInsEng->_fIgnoreTrust = FALSE;
   

   CloseHandle(pInsEng->_hAbort);
   pInsEng->_hAbort = NULL;
   
   CloseHandle(pInsEng->_hContinue);
   pInsEng->_hContinue = NULL;
   
   EnableScreenSaver(TRUE);
   EnableSage(TRUE);
   EnableDiskCleaner(TRUE);
   // Send a install all done message
   EnterCriticalSection(&g_cs);
   pInsEng->OnStopInstall(hr, NULL, 0);
   pInsEng->OnEngineStatusChange(ENGINESTATUS_READY, 0);
   LeaveCriticalSection(&g_cs);
   
   pInsEng->Release();
   return 0;
}   


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD CInstallEngine::_GetTotalDownloadSize()
{
   DWORD dwTotalSize = 0;
   IEnumCifComponents *penum;
   ICifComponent *pComp = NULL;

   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
      dwTotalSize += pComp->GetDownloadSize();
   }
   penum->Release();
   return dwTotalSize;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD CInstallEngine::_GetActualDownloadSize(BOOL bLogMissing)
{
   DWORD dwTotalSize = 0;
   IEnumCifComponents *penum;
   ICifComponent *pComp = NULL;

   _pCif->EnumComponents(&penum, 0, NULL);
   for( penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
         dwTotalSize += pComp->GetActualDownloadSize();
   }
   penum->Release();
   return dwTotalSize;
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

DWORD CInstallEngine::_GetTotalInstallSize()
{
   DWORD dwTotalSize = 0;
   DWORD dwWin, dwApp;
   IEnumCifComponents *penum;
   ICifComponent *pComp = NULL;

   _pCif->EnumComponents(&penum, 0, NULL);
   for(penum->Next(&pComp); pComp; penum->Next(&pComp))
   {
      if(pComp->GetInstallQueueState() == SETACTION_INSTALL)
      {
         pComp->GetInstalledSize(&dwWin, &dwApp);
         dwTotalSize += (dwWin + dwApp);
      }
   }
   penum->Release();
   return dwTotalSize;
}
   

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::LaunchExtraCommand(LPCSTR pszInfName, LPCSTR pszSection)
{
   return E_NOTIMPL;
}

//=---------------------------------------------------------------------------=
// RegisterInstallEngineCallback
//=---------------------------------------------------------------------------=
// Register the callback interface
//
// Parameters:
//    IInstallEngineCallback *  - the callback interface
//    HWND - For ui
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::RegisterInstallEngineCallback(IInstallEngineCallback *pcb)
{ 
   _pcb = pcb;
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::UnregisterInstallEngineCallback()
{ 
   _pcb = NULL;
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::SetHWND(HWND h)
{
   _hwndForUI = h;
   return NOERROR;
}

//***********  IInstallEngineCallback implementation ************

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnEngineStatusChange(DWORD status,DWORD substatus)
{
   _enginestatus = status; 
   if(_pcb)
      _pcb->OnEngineStatusChange(_enginestatus, substatus);
   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStartInstall(DWORD dwDLSize, DWORD dwInstallSize) 
{
   _dwDLRemaining = dwDLSize;
   _dwInstallRemaining = dwInstallSize;
   
   wsprintf(szLogBuf, "\r\nOnStartInstall:\r\n   Download: %d KB\r\n   Install %d KB\r\n", dwDLSize, dwInstallSize);
   WriteToLog(szLogBuf, TRUE);

   if(_pcb)
      _pcb->OnStartInstall(dwDLSize, dwInstallSize);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStartComponent(LPCSTR pszID, DWORD dwDLSize, 
                                   DWORD dwInstallSize, LPCSTR pszString)
{
   wsprintf(szLogBuf, "OnStartComponent:\r\n   ID: %s\r\n   Download: %d KB\r\n   Install %d KB\r\n", 
                         pszID, dwDLSize, dwInstallSize);
   WriteToLog(szLogBuf, TRUE);

   _dwDLOld = 0;
   _dwInstallOld = 0;
   if(_pcb)
      _pcb->OnStartComponent(pszID, dwDLSize, dwInstallSize, pszString);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnEngineProblem(DWORD dwProblem, LPDWORD pdwAction)
{
   HRESULT hr = S_FALSE;

   if(_pcb)
      hr = _pcb->OnEngineProblem(dwProblem, pdwAction);

   return hr;
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnComponentProgress(LPCSTR pszID, DWORD dwPhase,
                        LPCSTR pszString, LPCSTR pszMsgString,  ULONG prog, ULONG max)
{
   DWORD dwNew;
   
   if(dwPhase == INSTALLSTATUS_DOWNLOADING)
   {
      _dwDLOld = prog;
   }
   else if(dwPhase == INSTALLSTATUS_RUNNING)
   {
      _dwInstallOld = prog;
   }
   
   if(_pcb)
      _pcb->OnComponentProgress(pszID, dwPhase, pszString, pszMsgString, prog, max);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStopComponent(LPCSTR pszID, HRESULT hError,
                        DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{
   // adjust remaining
   if(_dwDLRemaining > _dwDLOld)
      _dwDLRemaining -= _dwDLOld;
   else
      _dwDLRemaining = 0;
   
   // adjust remaining
   if(_dwInstallRemaining > _dwInstallOld)
      _dwInstallRemaining -= _dwInstallOld;
   else
      _dwInstallRemaining = 0;
   

   wsprintf(szLogBuf, "Timing rates: Download: %d, Install %d\r\n", 
                _pDL->GetBytesPerSecond(), _pIns->GetBytesPerSecond());
   WriteToLog(szLogBuf, TRUE);

   
   wsprintf(szLogBuf, "OnStopComponent:\r\n   ID: %s\r\n   HRESULT: %x (%s)\r\n   Phase: %d\r\n   Status: %d\r\n", 
                         pszID, hError, SUCCEEDED(hError) ? STR_OK : STR_FAILED, dwPhase, dwStatus);
   WriteToLog(szLogBuf, TRUE);
   
   if(_pcb)
      _pcb->OnStopComponent(pszID, hError, dwPhase, pszString, dwStatus);

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::OnStopInstall(HRESULT hrError, LPCSTR szError,
                        DWORD dwStatus)
{
   _dwDLRemaining = 0;
   _dwInstallRemaining = 0;
   
   wsprintf(szLogBuf, "\r\nOnStopInstall:\r\n   HRESULT: %x (%s)\r\n   Status: %d\r\n", 
                         hrError, SUCCEEDED(hrError) ? STR_OK : STR_FAILED, dwStatus);
   WriteToLog(szLogBuf, TRUE);

   
   if(_pcb)
      _pcb->OnStopInstall(hrError, szError, dwStatus);

   return NOERROR;
}


//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngine::SetIStream(IStream *pstm)
{
   if(_pStmLog)
      _pStmLog->Release();

   _pStmLog = pstm;
   if(_pStmLog)
      _pStmLog->AddRef();

   return NOERROR;
}

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetDisplayName(LPCSTR pszComponentID, LPSTR *ppszName)
{ 
   HRESULT hr = E_INVALIDARG;
   char szTitle[MAX_DISPLAYNAME_LENGTH];
   
   if(!ppszName)
      return E_POINTER;

   *ppszName = 0;

   ICifComponent *pComp = NULL;

   if(pszComponentID)
   {
      if(SUCCEEDED(_pCif->FindComponent(pszComponentID, &pComp)))
      {
         pComp->GetDescription(szTitle, sizeof(szTitle));
         *ppszName = COPYANSISTR(szTitle);
         if(!(*ppszName))
            hr = E_OUTOFMEMORY;
         else
            hr = NOERROR;
      }
   }
   else
   {
      _pCif->GetDescription(szTitle, sizeof(szTitle));
      *ppszName = COPYANSISTR(szTitle);
      if(!(*ppszName))
         hr = E_OUTOFMEMORY;
      else
         hr = NOERROR;
   }
   return hr;
}

//************** IInstallEngineTiming **********************

//=---------------------------------------------------------------------------=
// Function name here
//=---------------------------------------------------------------------------=
// Function description
//
// Parameters
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngine::GetRates(DWORD *pdwDownload, DWORD *pdwInstall)
{ 
   *pdwDownload = _pDL->GetBytesPerSecond();
   *pdwInstall = _pIns->GetBytesPerSecond();
   return NOERROR;
}

STDMETHODIMP CInstallEngine::GetInstallProgress(INSTALLPROGRESS *pinsprog)
{
   if(!pinsprog)
      return E_POINTER;

   DWORD dwTemp;

   pinsprog->dwDownloadKBRemaining = _dwDLRemaining - _dwDLOld;
   pinsprog->dwInstallKBRemaining = _dwInstallRemaining - _dwInstallOld;

   dwTemp = _pDL->GetBytesPerSecond();
   if(dwTemp == 0)
      pinsprog->dwDownloadSecsRemaining = 0xffffffff;
   else
      pinsprog->dwDownloadSecsRemaining = (pinsprog->dwDownloadKBRemaining << 10)/dwTemp;

   dwTemp = _pIns->GetBytesPerSecond();
   if(dwTemp == 0)
      pinsprog->dwInstallSecsRemaining = 0xffffffff;
   else
      pinsprog->dwInstallSecsRemaining = (pinsprog->dwInstallKBRemaining << 10)/dwTemp;

   return NOERROR;
}


HRESULT CInstallEngine::CheckForContinue()
{
   HRESULT hr = S_OK;

   // Need to check Abort before AND after check for pause...
   if(_pCif->CanCancel() && (WaitForSingleObject(_hAbort, 0) == WAIT_OBJECT_0))
   {
      hr = E_ABORT;
   }
   
   if(SUCCEEDED(hr))
   {
      WaitForEvent(_hContinue, NULL);
   }

   if(_pCif->CanCancel() && (WaitForSingleObject(_hAbort, 0) == WAIT_OBJECT_0))
   {
      hr = E_ABORT;
   }
 
   return hr;
}

#define STEPPINGMODE_NO "n"

void CInstallEngine::WriteToLog(char *sz, BOOL pause)
{
   ULONG foo;
   UINT ret;
   HKEY hKey;
   
   if(_fSteppingMode && pause)
   {
      ret = MessageBox(_hwndForUI, sz, "Stepping Mode Message", MB_OKCANCEL | MB_ICONINFORMATION); 
      if(ret == IDCANCEL)
      {
         // turn off stepping mode
         _fSteppingMode = FALSE;
         // Whack the key
         if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACTIVESETUP_KEY,0, 
                     KEY_WRITE, &hKey) == ERROR_SUCCESS)
         {
            // I don't check for failure of delete - what would I do anyways?
            RegSetValueEx(hKey, STEPPING_VALUE, 0, REG_SZ, 
                        (BYTE *) STEPPINGMODE_NO, lstrlen(STEPPINGMODE_NO) + 1);
            RegCloseKey(hKey);
         }
      }
   }
      
   if(_pStmLog)
      _pStmLog->Write(sz, lstrlen(sz), &foo);
}

BOOL CInstallEngine::_IsValidBaseUrl(LPCSTR pszUrl)
{
   BOOL bValid = TRUE;

   if(!pszUrl)
      bValid = FALSE;

   return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\insengmn.cpp ===
//=--------------------------------------------------------------------------=
// insengmn.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// various globals which the framewrk requires
//
//

#include "inspch.h"
#include "insobj.h"
#include "insfact.h"
#include "sitefact.h"
#include "insengmn.h"
#include "resource.h"
#include "advpub.h"


LONG g_cLocks = 0;
HINSTANCE g_hInstance = NULL;
HANDLE g_hHeap = NULL;
CRITICAL_SECTION    g_cs = {0};     // per-instance

#define GUID_STR_LEN 40
//
// helper macros
//


OBJECTINFO g_ObjectInfo[] =
{
   { NULL, &CLSID_InstallEngine, NULL, OI_COCREATEABLE, "InstallEngine", 
       MAKEINTRESOURCE(IDS_INSTALLENGINE), NULL, NULL, VERSION_0, 0, 0 },
   { NULL, &CLSID_DownloadSiteMgr, NULL, OI_COCREATEABLE, "DownloadSiteMgr", 
       MAKEINTRESOURCE(IDS_DOWNLOADSITEMGR), NULL, NULL, VERSION_0, 0, 0 },
   { NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, 0, 0, 0 },
} ;


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if((riid == IID_IClassFactory) || (riid == IID_IUnknown))
    {
        const OBJECTINFO *pcls;
        for (pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if(rclsid == *pcls->pclsid)
            {
                *ppv = pcls->cf;
                ((IUnknown *)*ppv)->AddRef();
                return NOERROR;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_cLocks)
        return S_FALSE;

    return S_OK;
}


void InitClassFactories()
{
   g_ObjectInfo[0].cf = (void *) new CInstallEngineFactory();
   g_ObjectInfo[1].cf = (void *) new CSiteManagerFactory();
}


void DeleteClassFactories()
{
   delete g_ObjectInfo[0].cf;
   delete g_ObjectInfo[1].cf;
}



STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
   DWORD dwThreadID;

   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         g_hInstance = (HINSTANCE)hDll;
         g_hHeap = GetProcessHeap();
         InitializeCriticalSection(&g_cs);
         DisableThreadLibraryCalls(g_hInstance);
         InitClassFactories();
         break;

      case DLL_PROCESS_DETACH:
         DeleteCriticalSection(&g_cs);
         DeleteClassFactories();
         break;

      default:
         break;
   }
   return TRUE;
}

void DllAddRef(void)
{
    InterlockedIncrement(&g_cLocks);
}

void DllRelease(void)
{
    InterlockedDecrement(&g_cLocks);
}

HRESULT PurgeDownloadDirectory(LPCSTR pszDownloadDir)
{
   return DelNode(pszDownloadDir, ADN_DONT_DEL_DIR);  
}


STDAPI DllRegisterServer(void)
{
    // BUGBUG: pass back return from RegInstall ?
    RegInstall(g_hInstance, "DllReg", NULL);

    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    RegInstall(g_hInstance, "DllUnreg", NULL);

    return S_OK;
}

STDAPI DllInstall(BOOL bInstall, LPCSTR lpCmdLine)
{
    // BUGBUG: pass back return from RegInstall ?
    if (bInstall)
        RegInstall(g_hInstance, "DllInstall", NULL);
    else
        RegInstall(g_hInstance, "DllUninstall", NULL);

    return S_OK;
}




//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(g_hHeap, 0, ptr);
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif


void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        void* p = HeapAlloc(g_hHeap, 0, n);
        if (p != NULL)
                ZeroMemory(p, n);
        return p;
#else
        return HeapAlloc(g_hHeap, 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
        return malloc(n * s);
#else
        void* p = malloc(n * s);
        if (p != NULL)
                ZeroMemory(p, n * s);
        return p;
#endif
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(g_hHeap, 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(g_hHeap, 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\install.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\insfact.cpp ===
#include "inspch.h"
#include "insobj.h"
#include "insfact.h"


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineFactory::QueryInterface(REFIID riid, void **ppv)
{
   if((riid == IID_IClassFactory) || (riid == IID_IUnknown))
   {
      cRef++;
      *ppv = (void *)this;
      return NOERROR;
   }

   *ppv = NULL;
   return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngineFactory::AddRef()
{
   return(++cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstallEngineFactory::Release()
{
   return(--cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
   CInstallEngine *pinseng = NULL;
   IUnknown *punk;
   HRESULT hr;

   if(pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;
   
   pinseng = new CInstallEngine(&punk);
   if(!pinseng)
      return (E_OUTOFMEMORY);

   hr = punk->QueryInterface(riid, ppv);
   if(FAILED(hr))
      delete pinseng;
   else
      DllAddRef();
   
   punk->Release();
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineFactory::LockServer(BOOL fLock)
{
   if(fLock)
      DllAddRef();
   else
      DllRelease();
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\insobj.h ===
#include "inseng.h"
#include <wininet.h>
#include "util2.h"
#include "ciffile.h"

#define CMDLINE  "\"%s%s\" %s"

#define COMPONENT_KEY "Software\\Microsoft\\Active Setup\\Installed Components"
#define ACTIVESETUP_KEY "Software\\Microsoft\\Active Setup"
#define STEPPING_VALUE  "SteppingMode"
#define COMMAND_VALUE   "CommandMode"
#define CHECKTRUST_VALUE "DisableCheckTrust"
#define VERSION_KEY  "Version"

#define STR_FAILED "Failed"
#define STR_OK     "OK"

#define COMPONENTSIZES_SIZE_V1   32
#define COMPONENTSIZES_SIZE_V2   35
#define COMPONENTSIZES_SIZE_V3   39

class CInstallEngine : public IInstallEngine2, public IInstallEngineTiming,
                       public IInstallEngineCallback
{
   friend DWORD WINAPI InitInstaller(LPVOID pv);
   friend DWORD WINAPI InitDownloader(LPVOID pv);

   public:
      CInstallEngine(IUnknown **punk);
      ~CInstallEngine();

      // the usual IUnknown members
      STDMETHOD_(ULONG, AddRef)(void);
      STDMETHOD_(ULONG, Release)(void);
      STDMETHOD(QueryInterface)(REFIID, void **); 
      
      // IInstallEngine methods
      //
      STDMETHOD(GetEngineStatus)(THIS_ DWORD *theenginestatus);
      STDMETHOD(GetSizes)(THIS_ LPCSTR pszID, COMPONENT_SIZES *p);
      STDMETHOD(SetAction)(THIS_ LPCSTR pszID,DWORD dwAction,DWORD dwPriority);
      STDMETHOD(EnumInstallIDs)(THIS_ UINT uIndex, LPSTR *ppszID);
      STDMETHOD(EnumDownloadIDs)(THIS_ UINT uIndex, LPSTR *ppszID);
      STDMETHOD(IsComponentInstalled)(THIS_ LPCSTR pszID, DWORD *pdwStatus);
      STDMETHOD(DownloadComponents)(THIS_ DWORD dwFlags);
      STDMETHOD(InstallComponents)(THIS_ DWORD dwFlags);
      STDMETHOD(LaunchExtraCommand)(THIS_ LPCSTR pszInfName, LPCSTR pszSection);
      STDMETHOD(RegisterInstallEngineCallback)(THIS_ IInstallEngineCallback *pcb);
      STDMETHOD(UnregisterInstallEngineCallback)(THIS);
      STDMETHOD(GetDisplayName)(THIS_ LPCSTR pszComponentID, LPSTR *ppszName);

      // Intall info stuff
      STDMETHOD(SetCifFile)(THIS_ LPCSTR pszCabName, LPCSTR pszCifName);
      STDMETHOD(SetBaseUrl)(THIS_ LPCSTR pszBaseName);
      STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir);
      STDMETHOD(SetInstallDrive)(THIS_ char chDrive);
      STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag);
      STDMETHOD(GetInstallOptions)(THIS_ DWORD *pdwInsFlag);

      STDMETHOD(SetHWND)(THIS_ HWND hForUI);
      STDMETHOD(SetIStream)(THIS_ IStream *pstm);

      // Engine Control
      STDMETHOD(Abort)(THIS_ DWORD dwFlags);
      STDMETHOD(Suspend)(THIS);
      STDMETHOD(Resume)(THIS);


      // IInstallEngineTiming
      STDMETHOD(GetRates)(THIS_ DWORD *pdwDownload, DWORD *pdwInstall);
      STDMETHOD(GetInstallProgress)(THIS_ INSTALLPROGRESS *pinsprog);      

      // IInstallEngine2
      STDMETHOD(SetLocalCif)(THIS_ LPCSTR pszLocalCif);
      STDMETHOD(GetICifFile)(THIS_ ICifFile **pcif);



      // IInstallEngineCallback
      STDMETHOD(OnEngineStatusChange)(THIS_ DWORD dwEngStatus, DWORD substatus);
      STDMETHOD(OnStartInstall)(THIS_ DWORD dwDLSize, DWORD dwInstallSize);
      STDMETHOD(OnStartComponent)(THIS_ LPCSTR pszID, DWORD dwDLSize, 
                                  DWORD dwInstallSize, LPCSTR pszString);
      STDMETHOD(OnComponentProgress)(THIS_ LPCSTR pszID, DWORD dwPhase, 
                              LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax);
      STDMETHOD(OnStopComponent)(THIS_ LPCSTR pszID, HRESULT hError, 
                              DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
      STDMETHOD(OnStopInstall)(THIS_ HRESULT hrError, LPCSTR szError, 
                              DWORD dwStatus); 
      STDMETHOD(OnEngineProblem)(THIS_ DWORD dwProblem, LPDWORD dwAction); 

      void WriteToLog(char *sz, BOOL pause);
      CDownloader   *GetDownloader()            {  return _pDL; }
      CInstaller    *GetInstaller()             {  return _pIns; }
      CPatchDownloader *GetPatchDownloader()    {  return _pPDL; }
    
      LPCSTR         GetBaseUrl()               {  return _szBaseUrl; }
      void           SetStatus(DWORD dwStatus)  {  _dwStatus |= dwStatus; }
      UINT           GetStatus()                {  return _dwStatus; }
      UINT           GetCommandMode()           {  return _uCommandMode; }
      HWND           GetHWND()                  {  return _hwndForUI; }
      BOOL           IgnoreTrustCheck()         {  return _fIgnoreTrust; }
      BOOL           IgnoreDownloadError()      {  return _fIgnoreDownloadError; }
      char           GetInstallDrive()          {  return _chInsDrive; }
      HRESULT        CheckForContinue();
      BOOL           UseCache()                 {  return  _fUseCache; }
      BOOL           AllowCrossPlatform()       {  return !(_dwInstallOptions & INSTALLOPTIONS_DONTALLOWXPLATFORM); }  
      BOOL           ForceDependencies()        {  return (_dwInstallOptions & INSTALLOPTIONS_FORCEDEPENDENCIES); }
      BOOL           IsAdvpackExtAvailable()    {  return _fSRLiteAvailable; }

   private:
      char           _szBaseUrl[INTERNET_MAX_URL_LENGTH];
      HWND           _hwndForUI;
      IStream       *_pStmLog;
      UINT           _uCommandMode;      
      char           _chInsDrive;
      DWORD          _dwDLRemaining;
      DWORD          _dwInstallRemaining;
      DWORD          _dwDLOld;
      DWORD          _dwInstallOptions;
      DWORD          _dwInstallOld;
      DWORD          _enginestatus;
      DWORD          _dwStatus;
      ULONG          _cRef;
      HANDLE         _hAbort;
      HANDLE         _hContinue;
      IInstallEngineCallback *_pcb;
      CDownloader    *_pDL;
      CInstaller     *_pIns;
      CPatchDownloader *_pPDL;

      BOOL           _fUseCache:1;
      BOOL           _fSteppingMode:1;
      BOOL           _fIgnoreTrust:1;
      BOOL           _fIgnoreDownloadError:1;
      BOOL           _fResetTrust:1;
      BOOL           _fCleanUpDir:1;
    
      BOOL           _fSRLiteAvailable:1;
      CCifFile       *_pCif;
  
      void    _GetTotalSizes(COMPONENT_SIZES *p);
      DWORD   _GetTotalDownloadSize();
      DWORD   _GetActualDownloadSize(BOOL bLogMissing);
      DWORD   _GetTotalDependencySize();
      DWORD   _GetTotalInstallSize();
      BOOL    _IsValidBaseUrl(LPCSTR pszUrl);
};



DWORD WINAPI InitInstaller(LPVOID);
DWORD WINAPI InitDownloader(LPVOID);

extern CRITICAL_SECTION g_cs;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\insfact.h ===
class CInstallEngineFactory : IClassFactory
{
   public:
      CInstallEngineFactory() { cRef = 0; };

      //IUnknown things
      STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);

      //IClassFactory Things
      STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);
      STDMETHODIMP LockServer(BOOL fLock);

   private:
      UINT cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\inspch.cpp ===
#include "inspch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\insengmn.h ===
typedef struct tagOBJECTINFO
{
    void *cf;
    CLSID const* pclsid;
    HRESULT (*pfnCreateInstance)(IUnknown* pUnkOuter, IUnknown** ppunk, const struct tagOBJECTINFO *);

    // for automatic registration, type library searching, etc
    int nObjectType;        // OI_ flag
    LPTSTR pszName;       
    LPTSTR pszFriendlyName; 
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    int nidToolbarBitmap;
} OBJECTINFO;
typedef OBJECTINFO const* LPCOBJECTINFO;

#define VERSION_1 1 // so we don't get confused by too many integers
#define VERSION_0 0

#define OI_NONE          0
#define OI_UNKNOWN       1
#define OI_COCREATEABLE  1
#define OI_AUTOMATION    2
#define OI_CONTROL       3


// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define NAMEOFOBJECT(p)             ((p)->_pObjectInfo->pszName)
#define INTERFACEOFOBJECT(p)      (*((p)->_pObjectInfo->piid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)
#define BITMAPIDOFCONTROL(p)        ((p)->_pObjectInfo->nidToolbarBitmap)

extern OBJECTINFO g_ObjectInfo[];

#ifdef __cplusplus
extern "C" {
#endif

HRESULT PurgeDownloadDirectory(LPCSTR pszDownloadDir);

#ifdef __cplusplus
} // end of extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\inspch.h ===
#include <windows.h>
#include <commctrl.h>
#include <olectl.h>
#include <setupapi.h>
#include <wintrust.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\site.h ===
IDownloadSite *CopyDownloadSite(DOWNLOADSITE *pdls);
DOWNLOADSITE *AllocateDownloadSite(LPCSTR pszUrl, LPCSTR pszName, LPCSTR pszLang, LPCSTR pszRegion);
void DeleteDownloadSite(DOWNLOADSITE *pdls);
void FreeDownloadSite(DOWNLOADSITE *pdls);

class CDownloadSite  : public IDownloadSite
{
   public:
      CDownloadSite(DOWNLOADSITE *pds);
      ~CDownloadSite();

      // IUnknown
      STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
      STDMETHOD_(ULONG,AddRef) (THIS);
      STDMETHOD_(ULONG,Release) (THIS);

      // IDownloadSite
      STDMETHOD(GetData)(THIS_ DOWNLOADSITE **pds);

   private:
      DWORD  m_cRef;
      DOWNLOADSITE *m_pdls;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\makefile.inc ===
clean:
    -del /F /Q $(O)\selfreg_inseng.inf

$(O)\selfreg_inseng.inf: selfreg.inx
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\resource.h ===
#define IDS_DEPENDNAME        1001
#define IDS_DISPLAYNAME       1002
#define IDS_INSTALLENGINE     1003
#define IDS_SECURITYTITLE     1004
#define IDS_SECURITY          1005
#define IDS_DOWNLOADSITEMGR   1006
#define IDS_DEFAULTTITLE      1007
#define IDS_VERSIONCONFLICT   1008
#define IDS_VERSIONCONFLICTNT 1009
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\site.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "download.h"
#include "site.h"
#include "util2.h"

CDownloadSite::CDownloadSite(DOWNLOADSITE *p)
{
   m_cRef = 0;
   m_pdls = p;
   DllAddRef();
}

CDownloadSite::~CDownloadSite()
{
   if(m_pdls)
      FreeDownloadSite(m_pdls);
   DllRelease();
}   

//************ IUnknown implementation ***************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSite::AddRef()                      
{
   return(m_cRef++);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSite::Release()
{
   ULONG temp = --m_cRef;

   if(temp == 0)
      delete this;
   return temp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSite::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if((riid == IID_IUnknown) || (riid == IID_IDownloadSite))
      *ppv = (IDownloadSite *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSite::GetData(DOWNLOADSITE **ppdls)
{
   if(ppdls)
      *ppdls = m_pdls;
   else
      return E_POINTER;

   return NOERROR;
}

// BUGBUG: I have two versions - one allocating using new (HeapAlloc)
//    for internal use, one using CoTaskMem... that I give away.
//    I am using new internally because I suspect it may be faster/less 
//    expensive. but this makes code more complex. Good choice?

// BUGBUG: Allow null url or friendly name?

IDownloadSite *CopyDownloadSite(DOWNLOADSITE *pdls)
{
   DOWNLOADSITE *p;
   IDownloadSite *psite = NULL; 

   p = (DOWNLOADSITE *) CoTaskMemAlloc(sizeof(DOWNLOADSITE));
   if(p)
   {
      p->cbSize = sizeof(DOWNLOADSITE);
      p->pszUrl = COPYANSISTR(pdls->pszUrl);
      p->pszFriendlyName = COPYANSISTR(pdls->pszFriendlyName);
      p->pszLang = COPYANSISTR(pdls->pszLang);
      p->pszRegion = COPYANSISTR(pdls->pszRegion);
      if(!p->pszUrl || !p->pszFriendlyName || !p->pszLang || !p->pszRegion)
      {
         FreeDownloadSite(p);
         p = NULL;
      }
   }
   if(p)
   {
      //allocate the interface wrapper
      CDownloadSite *site = new CDownloadSite(p);
      if(site)
      {
         psite = (IDownloadSite *)site;
         psite->AddRef();
      }
   
   }
   
   return psite;
}


DOWNLOADSITE *AllocateDownloadSite(LPCSTR pszUrl, LPCSTR pszName, LPCSTR pszLang, LPCSTR pszRegion)
{
   DOWNLOADSITE *p = new DOWNLOADSITE;
   if(p)
   {
      p->cbSize = sizeof(DOWNLOADSITE);
      p->pszUrl = CopyAnsiStr(pszUrl);
      p->pszFriendlyName = CopyAnsiStr(pszName);
      p->pszLang = CopyAnsiStr(pszLang);
      p->pszRegion = CopyAnsiStr(pszRegion);
      if(!p->pszUrl || !p->pszFriendlyName || !p->pszLang || !p->pszRegion)
      {
         DeleteDownloadSite(p);
         p = NULL;
      }
   }
   return p;
}

// this version deletes a DOWNLOADSITE allocated from the heap

void DeleteDownloadSite(DOWNLOADSITE *pdls)
{
   if(pdls)
   {
      if(pdls->pszUrl) 
         delete pdls->pszUrl;
      if(pdls->pszFriendlyName)
         delete pdls->pszFriendlyName;
      if(pdls->pszLang) 
         delete pdls->pszLang;
      if(pdls->pszRegion) 
         delete pdls->pszRegion;
      

      delete pdls;
   }
}

// this version deletes a DOWNLOADSITE allocated thru CoTaskMemAlloc

void FreeDownloadSite(DOWNLOADSITE *pdls)
{
   if(pdls)
   {
      if(pdls->pszUrl) 
         CoTaskMemFree(pdls->pszUrl);
      if(pdls->pszFriendlyName)
         CoTaskMemFree(pdls->pszFriendlyName);
      if(pdls->pszLang) 
         CoTaskMemFree(pdls->pszLang);
      if(pdls->pszRegion) 
         CoTaskMemFree(pdls->pszRegion);

      CoTaskMemFree(pdls);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\sitefact.cpp ===
#include "inspch.h"
#include "insengmn.h"
#include "inseng.h"
#include "download.h"
#include "sitemgr.h"
#include "sitefact.h"
#include "util2.h"

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CSiteManagerFactory::QueryInterface(REFIID riid, void **ppv)
{
   if((riid == IID_IClassFactory) || (riid == IID_IUnknown))
   {
      cRef++;
      *ppv = (void *)this;
      return NOERROR;
   }

   *ppv = NULL;
   return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CSiteManagerFactory::AddRef()
{
   return(++cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CSiteManagerFactory::Release()
{
   return(--cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CSiteManagerFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
   CDownloadSiteMgr *pdsm = NULL;
   IUnknown *punk;
   HRESULT hr;

   if(pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;
   
   pdsm = new CDownloadSiteMgr(&punk);
   if(!pdsm)
      return (E_OUTOFMEMORY);

   hr = punk->QueryInterface(riid, ppv);
   if(FAILED(hr))
      delete pdsm;
   else
      DllAddRef();
   
   punk->Release();
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CSiteManagerFactory::LockServer(BOOL fLock)
{
   if(fLock)
      DllAddRef();
   else
      DllRelease();
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\install.cpp ===
#include "inspch.h"
#include "insobj.h"

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

CInstaller::CInstaller(CInstallEngine *p) : CTimeTracker(60000)
{
   _pInsEng = p;
   _hkProg  = NULL;
   _hMutex  = NULL;
   _hStatus = NULL;
   _cRef    = 1;

   DllAddRef();
}

CInstaller::~CInstaller()
{
   DllRelease();
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstaller::AddRef()
{
   return(++_cRef);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CInstaller::Release()
{
   if(!--_cRef)
   {
      delete this;
      return(0);
   }
   return( _cRef );
}

HRESULT CInstaller::Abort()
{
   if(_hMutex)
   {
      WaitForMutex(_hMutex);
      if(_hkProg)
      {
         DWORD dwCancel = 1;
         RegSetValueEx(_hkProg, CANCEL_VALUENAME, 0, REG_DWORD, (BYTE *) &dwCancel, sizeof(dwCancel));
      }
      ReleaseMutex(_hMutex);
   }
   return NOERROR;
}

HRESULT CInstaller::Suspend()
{
   // assume no install going on
   HRESULT hr = S_OK;
   
   // if we have a mutex grab it and check for safe
   if(_hMutex)
   {
      // there is an install, assume it isn't safe to cancel it
      hr = S_FALSE;
      WaitForMutex(_hMutex);
      if(_hkProg)
      {
         DWORD dwSafe = 0; 
         DWORD dwSize = sizeof(dwSafe);
         if(RegQueryValueEx(_hkProg, SAFE_VALUENAME, NULL, NULL, (BYTE *) &dwSafe, &dwSize) == ERROR_SUCCESS)
         {
            if(dwSafe == 1)
               hr = S_OK;
         }
         
      }
   }
   return hr;
}

HRESULT CInstaller::Resume()
{
   // if we have a mutex release it
   if(_hMutex)
      ReleaseMutex(_hMutex);

   return NOERROR;
}



HRESULT CInstaller::DoInstall(LPCSTR pszDir, LPSTR pszCmd, LPSTR pszArgs, LPCSTR pszProg, LPCSTR pszCancel, 
                                    UINT uType, LPDWORD pdwStatus, IMyDownloadCallback *pcb)
{
   char szFileName[MAX_PATH + 128];
   char szBuf[MAX_PATH];
   HANDLE hProc = NULL;
   HMODULE hAdvpack;
   HRESULT hr = S_OK;
   DWORD dwTemp;
   INF_ARGUEMENTS InsArgs;
       
   _uTotalProgress = 0;

   // create progress key if we need to
   if(pszProg && pszCancel)
   {
      lstrcpy(szBuf, REGSTR_PROGRESS_KEY);
      lstrcat(szBuf, pszProg);
      RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, NULL,0, KEY_READ | KEY_WRITE,NULL, &_hkProg, &dwTemp); 
   
      lstrcpy(szBuf, pszCancel);
      lstrcat(szBuf, "Mutex");
      _hMutex = CreateMutex(NULL, FALSE, szBuf); 
  
      lstrcpy(szBuf, pszCancel);
      lstrcat(szBuf, "Event");
      _hStatus = CreateEvent(NULL, FALSE, FALSE, szBuf); 

   }

   // copy the advpack we are using into the temp dir of what we want to launch
   // this insures that we always get a "good" copy of advpack
   hAdvpack = GetModuleHandle("advpack.dll");
   if(hAdvpack)
   {
      if(GetModuleFileName(hAdvpack, szBuf, sizeof(szBuf)))
      {
         lstrcpy(szFileName, pszDir);
         AddPath(szFileName, "advpack.dll");

         CopyFile(szBuf, szFileName, TRUE);

         szBuf[0] = 0;
         szFileName[0] = 0;
      }
   }

   
   switch(uType)
   {
      case InfCommand:
      case InfExCommand:         
         GetStringField(pszCmd, 0, szBuf, sizeof(szBuf)); 
         
         // ParseURLA below is to ensure we only run inf out of our temp dir
         lstrcpy(szFileName, pszDir); 
         AddPath(szFileName, ParseURLA(szBuf));

         GetStringField(pszCmd, 1, szBuf, sizeof(szBuf));
        
         lstrcpy(InsArgs.szInfname, szFileName);
         lstrcpy(InsArgs.szSection, szBuf);
         lstrcpy(InsArgs.szDir, pszDir);
         InsArgs.dwType = uType;
         if(uType == InfCommand)
         {
            InsArgs.dwFlags = RSC_FLAG_INF |  RSC_FLAG_NGCONV;
            
            if(_pInsEng->GetCommandMode() == 0)
               InsArgs.dwFlags |= RSC_FLAG_QUIET;
            
         }
              
         if(uType == InfExCommand)
         {
            // add cab name
            lstrcpy(InsArgs.szCab, ""); 
            InsArgs.dwFlags = AtoL(pszArgs);
         }

         if(_pInsEng->GetStatus() & STOPINSTALL_REBOOTNEEDED)
            InsArgs.dwFlags |= RSC_FLAG_DELAYREGISTEROCX;
              
         wsprintf(szLogBuf, "Launching Inf - inf: %s, section: %s\r\n", szFileName, lstrlen(szBuf) ? szBuf : "Default");
         _pInsEng->WriteToLog(szLogBuf, TRUE);

         hProc = CreateThread(NULL, 0, LaunchInfCommand, &InsArgs, 0, &dwTemp);
               
         hr = E_FAIL;
         if(hProc)
         {
            _WaitAndPumpProgress(hProc, pcb);
            DWORD dwRet;
            if(GetExitCodeThread(hProc, &dwRet))
            {
               hr = dwRet;
               if(SUCCEEDED(hr))
               {
                  if(hr == ERROR_SUCCESS_REBOOT_REQUIRED)
                     *pdwStatus |= STOPINSTALL_REBOOTNEEDED;    
               }
               else
               {
                  wsprintf(szLogBuf, "Inf failed - return code %x\r\n", dwRet);
                  _pInsEng->WriteToLog(szLogBuf, TRUE);
               }
                      
            }
            else
               _pInsEng->WriteToLog("Failed to get exit code\r\n", TRUE);
         }
         else
            _pInsEng->WriteToLog("Create thread failed\r\n", TRUE);
         
         break;

      case WExtractExe:
      case Win32Exe:
      case HRESULTWin32Exe:
         
         // ParseURLA below is to ensure we only run exe out of our temp dir
         wsprintf(szFileName, CMDLINE, pszDir, ParseURLA(pszCmd), pszArgs);

         wsprintf(szLogBuf, "Launching exe: command: %s\r\n", szFileName);
         _pInsEng->WriteToLog(szLogBuf, TRUE);

         hr = LaunchProcess(szFileName, &hProc, pszDir, SW_SHOWNORMAL);
         if(SUCCEEDED(hr))
            _WaitAndPumpProgress(hProc, pcb);
         if(SUCCEEDED(hr))
         {
            // BUGBUG: Trace this path with WEXTRACT > 1140
            if ( (uType == WExtractExe) || (uType == HRESULTWin32Exe) )
            {
               DWORD dwRet;
               hr = E_FAIL;
               if(GetExitCodeProcess(hProc, &dwRet))
               {
                  wsprintf(szLogBuf, "Exe return code: %x\r\n", dwRet);
                  _pInsEng->WriteToLog(szLogBuf, TRUE);
                  hr = (HRESULT) dwRet;
                    
                  if (uType == WExtractExe)
                  {
                     if(SUCCEEDED(hr))
                     {
                        if(hr == ERROR_SUCCESS_REBOOT_REQUIRED)
                           *pdwStatus |= STOPINSTALL_REBOOTNEEDED;    
                     }
                  }
               
               }
               else
                  _pInsEng->WriteToLog("Failed to get exit code\r\n", TRUE);
            }
         }
         else
            _pInsEng->WriteToLog("Create process failed\r\n", TRUE);
                          
         break;

      default:
         // whatever
         hr = E_INVALIDARG;
   }

   if (_hkProg)
   {
       RegCloseKey(_hkProg);
       _hkProg = NULL;
   }

   if (_hMutex)
   {
       CloseHandle(_hMutex);
       _hMutex = NULL;
   }

   if (_hStatus)
   {
       CloseHandle(_hStatus);
       _hStatus = NULL;
   }

   return hr;
}

#define PROGRESS_INTERVAL 1000
#define SEARCHFORCONFLICT_INTERVAL   3


void CInstaller::_WaitAndPumpProgress(HANDLE hProc, IMyDownloadCallback *pcb)
{
   HANDLE pHandles[2] = {hProc, _hStatus};
   DWORD dwStartTick = GetTickCount();
   DWORD dwOldTick = dwStartTick;
   DWORD dwTickChange = 0;
   DWORD dwProgress;
   DWORD dwCurrentTick;
   BOOL fQuit = FALSE;
   DWORD dwRet;
   DWORD dwSearchCount = 0;
   HWND  hLastVersionConflict = NULL;
   HWND  hVersionConflict = NULL;

   while(!fQuit)
   {
      dwRet = MsgWaitForMultipleObjects(_hStatus ? 2 : 1, pHandles, FALSE, 1000, QS_ALLINPUT);
      
      dwCurrentTick = GetTickCount();
      dwTickChange = dwCurrentTick - dwOldTick;
      if(dwOldTick > dwCurrentTick)
         dwTickChange = ~dwTickChange;

      if(dwTickChange > PROGRESS_INTERVAL)
      {
         dwSearchCount++;
         if(dwSearchCount > SEARCHFORCONFLICT_INTERVAL || hLastVersionConflict)
         {
            hVersionConflict = GetVersionConflictHWND();
            if(hVersionConflict)
            {
               if(hVersionConflict != hLastVersionConflict)
               {
                  if(GetForegroundWindow() == _pInsEng->GetHWND())
                     SetForegroundWindow(hVersionConflict);
               
                  BOOL foo = MessageBeep(MB_ICONASTERISK);
               }
            }
            hLastVersionConflict = hVersionConflict;
          
            dwSearchCount = 0;
         }

         // if there is a version conflict, we assume you made no progress during the last time period
         if(!hLastVersionConflict)
         {
            dwProgress = (dwTickChange / 1000) * GetBytesPerSecond();
            dwProgress >>= 10;
            _uTotalProgress += dwProgress;

            pcb->OnProgress(_uTotalProgress, NULL); 
         }
         dwOldTick = dwCurrentTick;
      }

      // Handle Message or done
      if(dwRet == WAIT_OBJECT_0)
      {
         
         
         fQuit = TRUE;
      }
      else if ( (dwRet == WAIT_OBJECT_0 + 1) && (_hStatus != 0))      // update jobexec's status msg
      {
          if (!(fQuit = WaitForMutex(_hMutex)))
          {
              if (_hkProg != NULL)
              {
                  char szBuf[MAX_PATH];
                  DWORD dwSize = sizeof(szBuf);

                  if (RegQueryValueEx(_hkProg, PROGRESS_DISPLAY, NULL, NULL, (LPBYTE) szBuf, &dwSize) == ERROR_SUCCESS)
                     pcb->OnProgress(_uTotalProgress, szBuf); 
              }

              ReleaseMutex(_hMutex);
          }
      }
      else
      {
         MSG msg;
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         {

            // if it's a quit message we're out of here
            if (msg.message == WM_QUIT)
               fQuit = TRUE;
            else
            {
               // otherwise dispatch it
              DispatchMessage(&msg);
            } // end of PeekMessage while loop
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\sitefact.h ===
class CSiteManagerFactory : IClassFactory
{
   public:
      CSiteManagerFactory() { cRef = 0; };

      //IUnknown things
      STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);

      //IClassFactory Things
      STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);
      STDMETHODIMP LockServer(BOOL fLock);

   private:
      UINT cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\sitemgr.h ===
#define MAX_RETRIES             2

// a small class that handles downloading ins and building component list
class CDownloadSiteMgr  : public IMyDownloadCallback, public IDownloadSiteMgr
{
   public:
      CDownloadSiteMgr(IUnknown **punk);
      ~CDownloadSiteMgr();

      // IMyDownloadCallback
      HRESULT OnProgress(ULONG progress, LPCSTR pszStatus);

      // IUnknown
      STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
      STDMETHOD_(ULONG,AddRef) (THIS);
      STDMETHOD_(ULONG,Release) (THIS);

      // IDownloadSiteMgr
      STDMETHOD(Initialize)(THIS_ LPCSTR pszUrl, SITEQUERYPARAMS *pqp);
      STDMETHOD(EnumSites)(THIS_ DWORD dwIndex, IDownloadSite **pds);
      
   private:
      DWORD  m_cRef;
      LPSTR  m_pszUrl;
      SITEQUERYPARAMS *m_pquery;
      DOWNLOADSITE **m_ppdls;
      UINT m_arraysize;
      UINT m_numsites;
      BOOL m_onegoodsite;
      
      HRESULT ParseSiteFile(LPCSTR psz);
      HRESULT AddSite(DOWNLOADSITE *);
      DOWNLOADSITE *ParseAndAllocateDownloadSite(LPSTR psz);
      DWORD TranslateLanguage(LPSTR szLang);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\timetrak.cpp ===
#include "inspch.h"
#include "timetrak.h"

#define NUMBYTESFORUPDATE  200000
#define DECAY_FACTOR       85

CTimeTracker::CTimeTracker(DWORD dwDefaultRate)
{
   m_hasave = FALSE;
   m_defaultrate = dwDefaultRate;
   m_bTiming = FALSE;
   m_dwBytesSoFar = 0;
   m_dwTicksSoFar = 0;
}

CTimeTracker::~CTimeTracker()
{
}

void CTimeTracker::AddEntry(DWORD dwTime, DWORD dwBytes, BOOL bAccumulate)
{
   DWORD dwBPS;

   m_dwBytesSoFar += dwBytes;
   m_dwTicksSoFar += dwTime;
   
   if(m_dwBytesSoFar > NUMBYTESFORUPDATE || !bAccumulate)
   {
      if(m_dwBytesSoFar < 4000000)
         dwBPS = (m_dwBytesSoFar * 1000) / m_dwTicksSoFar;
      else if (m_dwTicksSoFar > 20000)
         dwBPS = m_dwBytesSoFar / (m_dwTicksSoFar / 1000);
      else
         dwBPS = (m_dwBytesSoFar/m_dwTicksSoFar)*1000;

      if(!m_hasave)
      {
         m_ave = dwBPS;
         m_hasave = TRUE;
      }
      else
      {
         m_ave = ((dwBPS * (100 - DECAY_FACTOR)) + (m_ave * DECAY_FACTOR))/100;
      }

      m_dwBytesSoFar = 0;
      m_dwTicksSoFar = 0;
   }
}

DWORD CTimeTracker::GetBytesPerSecond()
{
   if(!m_hasave)
      return m_defaultrate;
   else
      return m_ave;
}

void CTimeTracker::StartClock()
{
   m_dwStartTick = GetTickCount();
   m_bTiming = TRUE;
}

void CTimeTracker::StopClock()
{
   m_bTiming = FALSE;
}

void CTimeTracker::SetBytes(DWORD dwBytes, BOOL bAccumulate)
{
   DWORD dwTickChange;
   DWORD dwCurrentTick;

   if(!m_bTiming)
      return;

   dwCurrentTick = GetTickCount();
   dwTickChange = dwCurrentTick - m_dwStartTick;
   if(m_dwStartTick > dwCurrentTick)
      dwTickChange -= 0xffffffff;
   

   if(dwTickChange != 0)
      AddEntry(dwTickChange, dwBytes, bAccumulate);

   m_dwStartTick = dwCurrentTick;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\timetrak.h ===
class CTimeTracker
{
   public:
      CTimeTracker(DWORD dwDefaultRate);
      ~CTimeTracker();
      
      void StartClock();
      void StopClock();
      void SetBytes(DWORD dwBytes, BOOL bAccumulate);
      DWORD GetBytesPerSecond();

   private:
      DWORD m_dwBytesSoFar;
      DWORD m_dwTicksSoFar;
      DWORD m_dwStartTick;
      DWORD m_defaultrate;
      DWORD m_ave;
      BOOL  m_bTiming;
      UINT  m_hasave;
      void AddEntry(DWORD dwmSec, DWORD dwBytes, BOOL bAccumulate);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\util2.h ===
#ifndef _UTIL2_H_

#include "sdsutils.h"
#include "advpub.h"
#include "util.h"

// TODO: advpext.h needs to move to a public location
#include "..\\..\\iexpress\\advpext\\advpext.h"

#define COPYANSISTR(x) MakeAnsiStrFromAnsi(x)

#define ALLOC_CHUNK_SIZE 1024

#define SEARCHFORCONFLICT_CLASS   32770

// Copied from sage.h
#define ENABLE_AGENT            1
#define DISABLE_AGENT           2
#define GET_AGENT_STATUS        3


extern char szLogBuf[];

void EnableSage(BOOL bRestore);
void EnableScreenSaver(BOOL bRestore);
void EnableDiskCleaner(BOOL bRestore);
BOOL PathIsFileSpec(LPCSTR lpszPath);
BOOL IsNT();

LPWSTR ParseURLW(BSTR str);
LPSTR ParseURLA(LPCSTR str);
LPSTR MakeAnsiStrFromAnsi(LPSTR psz);
LPSTR CopyAnsiStr(LPCSTR); 
HWND GetVersionConflictHWND();
HRESULT CreateTempDir(DWORD dwDownloadSize, DWORD dwExtractSize, 
                    char chInstallDrive, DWORD dwInstallSize, 
                    DWORD dwWindowsDriveSize, 
                    LPSTR pszPath, DWORD cbPathSize, 
                    DWORD dwFlags);
 
void AddTempToLikelyExtractDrive(DWORD dwTempDLSpace, DWORD dwTempEXSpace,
                                 char chInstallDrive, char chDownloadDrive,
                                 DWORD *pdwWinDirReq, DWORD *pdwInsDirReq,
                                 DWORD *pdwDownloadDirReq);
int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2);

BOOL IsEnoughSpace( LPCSTR szPath, DWORD dwInstNeedSize );
HRESULT LaunchProcess(LPCSTR pszCmdLine, HANDLE *hProc, LPCSTR pszDir, UINT uShow);
HRESULT LaunchAndWait(LPSTR pszCommandLine, HANDLE hAbort, HANDLE *hProc, LPSTR pszDir, UINT uShow);
int  VersionCmp(WORD rwVer1[], WORD rwVer2[]);
void ConvertVersionStr(LPSTR pszVer, WORD rwVer[]);
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags);
int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize);
void DeleteFilelist(LPCSTR pszFilelist);
BOOL FNeedGrpConv();

// Function is in extract.cpp
LPSTR FindChar(LPSTR, char);
LPSTR StripQuotes(LPSTR pszStr);

typedef struct 
{
   char  szInfname[MAX_PATH];
   char  szSection[MAX_PATH];
   char  szDir[MAX_PATH];
   char  szCab[MAX_PATH];
   DWORD dwFlags;
   DWORD dwType;
} INF_ARGUEMENTS;

DWORD WINAPI LaunchInfCommand(void *p);
DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize);
DWORD GetIntField(LPSTR szStr, UINT uField, DWORD dwDefault);
LPSTR BuildDependencyString(LPSTR pszName,LPSTR pszOwner);
int StringFromGuid(const CLSID* piid, LPTSTR   pszBuf);
BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPSTR pszSubKey);
DWORD WINAPI CleanUpAllDirs(LPVOID pv);
BOOL UninstallKeyExists(LPCSTR pszUninstallKey);
BOOL SuccessCheck(LPSTR pszSuccessKey);
void SafeAddPath(LPSTR szPath, LPCSTR szName, DWORD dwPathSize );
void ExpandString( LPSTR lpBuf, DWORD dwSize );
VOID IndicateWinsockActivity(VOID);
HRESULT MyTranslateString( LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey,
                              LPSTR pszBuffer, DWORD dwBufferSize);

HRESULT MyTranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                              PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                              PSTR pszBuffer, DWORD dwBufferSize,
                              PDWORD pdwRequiredSize, HINF hInf );

HRESULT WriteTokenizeString(LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey, LPCSTR pszBuffer);
DWORD MyWritePrivateProfileString( LPCSTR pszSec, LPCSTR pszKey, LPCSTR pszData, LPCSTR pszFile);
void CopyCifString(LPCSTR pszSect, LPCSTR pszKey, LPCSTR pszCifSrc, LPCSTR pszCifDest);

HRESULT CreateTempDirOnMaxDrive(LPSTR pszDir, DWORD dwBufSize);

HINSTANCE InitSetupLib(LPCSTR pszInfName, HINF *phinf);
void FreeSetupLib(HINSTANCE hInst, HINF hInf);

HRESULT GetIEPath(LPSTR pszPath, DWORD dwSize);
DWORD MyGetFileSize(LPCSTR pszFilename);

void CleanUpTempDir(LPCSTR pszTemp);

typedef HRESULT (WINAPI *PFNGETFILELIST)(HINF, PDOWNLOAD_FILEINFO*, DWORD*);
typedef HRESULT (WINAPI *PFNDOWNLOADANDPATCHFILES)(HWND, DWORD, DOWNLOAD_FILEINFO*,
                                                   LPCSTR, LPCSTR, PATCH_DOWNLOAD_CALLBACK, LPVOID); 
typedef HRESULT (WINAPI *PFNPROCESSFILESECTION)(HINF, HWND, BOOL, LPCSTR, LPCSTR, PATCH_DOWNLOAD_CALLBACK, LPVOID);

BOOL IsPatchableINF(LPTSTR pszInf);
BOOL InitSRLiteLibs();
BOOL IsCorrectAdvpExt();
void FreeSRLiteLibs();
BOOL IsPatchableIEVersion();

extern PFNGETFILELIST g_pfnGetFileList;
extern PFNDOWNLOADANDPATCHFILES g_pfnDownloadAndPatchFiles;
extern PFNPROCESSFILESECTION g_pfnProcessFileSection;


#define EVENTWAIT_QUIT  0
#define EVENTWAIT_DONE  1

DWORD WaitForEvent(HANDLE hEvent, HWND hwnd);
BOOL WaitForMutex(HANDLE hMutex);

DWORD GetCurrentPlatform();

void DllAddRef(void);
void DllRelease(void);
void * _cdecl malloc(size_t n);
void * _cdecl calloc(size_t n, size_t s);
void * _cdecl realloc(void* p, size_t n);
void   _cdecl free(void* p);

extern char g_szWindowsDir[MAX_PATH];

void GetTimeDateStamp(LPSTR lpLogBuf);

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI DownloadFile(LPCSTR szURL, LPCSTR szFilename, HWND hwnd, BOOL bCheckTrust, BOOL bShowBadUI);

#ifdef __cplusplus
}      // end of extern "C"
#endif

#define _UTIL2_H_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\sitemgr.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "download.h"
#include "advpub.h"
#include "site.h"
#include "sitemgr.h"
#include "util2.h"
#include "util.h"

#define SITEFILENAME  "sites.dat"
#define SITEARRAY_GROWTHFACTOR 100

#define NUM_RETRIES 2

#define SITEQUERYSIZE_V1    8
#define SITEQUERYSIZE_V2   12

CDownloadSiteMgr::CDownloadSiteMgr(IUnknown **punk)
{
   m_cRef = 0;
   m_pszUrl = 0;
 
   m_pquery = NULL;
   m_ppdls = (DOWNLOADSITE **) malloc(SITEARRAY_GROWTHFACTOR * sizeof(DOWNLOADSITE *));
   m_numsites = 0;
   m_arraysize = SITEARRAY_GROWTHFACTOR;
   
   AddRef();
   *punk = (IDownloadSiteMgr *) this;
}

CDownloadSiteMgr::~CDownloadSiteMgr()
{
   if(m_ppdls)
   {
      for(UINT i=0; i < m_numsites; i++)
         DeleteDownloadSite(m_ppdls[i]);

      free(m_ppdls);
   }

   // Delete the query structure
   if(m_pquery)
   {
      if(m_pquery->pszLang)
         delete m_pquery->pszLang;

      delete m_pquery;
   }

   if(m_pszUrl)
      delete m_pszUrl;

   DllRelease();
}   

//************ IUnknown implementation ***************

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSiteMgr::AddRef()                      
{
   return(m_cRef++);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP_(ULONG) CDownloadSiteMgr::Release()
{
   ULONG temp = --m_cRef;

   if(temp == 0)
      delete this;
   return temp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSiteMgr::QueryInterface(REFIID riid, void **ppv)
{
   *ppv = NULL;

   if((riid == IID_IUnknown) || (riid == IID_IDownloadSiteMgr))
      *ppv = (IDownloadSiteMgr *)this;
   
   if(*ppv == NULL)
      return E_NOINTERFACE;
   
   AddRef();
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

STDMETHODIMP CDownloadSiteMgr::Initialize(LPCSTR pszUrl, SITEQUERYPARAMS *psqp)
{
   HRESULT hr = S_OK;
   char szPath[MAX_PATH];
      
   if(!pszUrl)
      return E_INVALIDARG; 

   if(!m_ppdls)
      return E_OUTOFMEMORY;

   m_pszUrl = CopyAnsiStr(pszUrl);
   if(!m_pszUrl)
      return E_OUTOFMEMORY;
    
   if(psqp != NULL)
   {
      m_pquery = new SITEQUERYPARAMS;
      if(!m_pquery)
         return E_OUTOFMEMORY;

      ZeroMemory(m_pquery, sizeof(SITEQUERYPARAMS));
      
      if(psqp->pszLang)
      {   
         m_pquery->pszLang = CopyAnsiStr(psqp->pszLang);
         if(!m_pquery->pszLang)
            return E_OUTOFMEMORY;
      }
      if((psqp->cbSize >= SITEQUERYSIZE_V2) && psqp->pszRegion)
      {
         m_pquery->pszRegion = CopyAnsiStr(psqp->pszRegion);
         if(!m_pquery->pszRegion)
            return E_OUTOFMEMORY;
      }
   }

   CDownloader *pDownloader = new CDownloader();
   if(pDownloader)
   {
      hr = E_FAIL;
      for(int i = 0; (i < NUM_RETRIES) && FAILED(hr) ; i++)
      {
         hr = pDownloader->SetupDownload(m_pszUrl, (IMyDownloadCallback *) this, DOWNLOADFLAGS_USEWRITECACHE, SITEFILENAME);
         if(FAILED(hr))
            break;
         hr = pDownloader->DoDownload(szPath, sizeof(szPath));
      }
      pDownloader->Release();
     
   }
      
   // Parse the file
   if(SUCCEEDED(hr))
   {
      hr = ParseSiteFile(szPath);
   }

   // delete the dir we downloaded to

   if(GetParentDir(szPath))
      DelNode(szPath, 0);
   
   return hr;
}


STDMETHODIMP CDownloadSiteMgr::EnumSites(DWORD dwIndex, IDownloadSite **pds)
{
   HRESULT hr = NOERROR;
   
   if(!pds)
      return E_POINTER;

   *pds = NULL;
   
   if(dwIndex < m_numsites)
   {
      *pds = CopyDownloadSite(m_ppdls[dwIndex]);
      if(! (*pds) )
         hr = E_OUTOFMEMORY;
   }
   else
      hr = E_FAIL;
   
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CDownloadSiteMgr::OnProgress(ULONG progress, LPCSTR pszStatus)
{
   // Not interesting
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

// This probably changes after beta1

HRESULT CDownloadSiteMgr::ParseSiteFile(LPCSTR pszPath)
{
   HANDLE hfile;
   DWORD dwSize;
   DOWNLOADSITE *p;
   LPSTR pBuf, pCurrent, pEnd;

   m_onegoodsite = FALSE;

   hfile = CreateFile(pszPath, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  

   if(hfile == INVALID_HANDLE_VALUE)
      return E_FAIL;

   
   dwSize = GetFileSize(hfile, NULL);
   if(dwSize == DWORD(-1)) {
      CloseHandle(hfile);
      return E_UNEXPECTED;
   }

   pBuf = new char[dwSize + 1];

   if(!pBuf)
   {
      CloseHandle(hfile);
      return E_OUTOFMEMORY;
   }
   // Copy contents of file to our buffer
   
   if(!ReadFile(hfile, pBuf, dwSize, &dwSize, NULL)) {
      delete pBuf;
      CloseHandle(hfile);
      return E_UNEXPECTED;
   }
   
   pCurrent = pBuf;
   pEnd = pBuf + dwSize;
   *pEnd = 0;

   // One pass thru replacing \n or \r with \0
   while(pCurrent <= pEnd)
   {
      if(*pCurrent == '\r' || *pCurrent == '\n')
         *pCurrent = 0;
      pCurrent++;
   }

   pCurrent = pBuf;
   while(1)
   {
      while(pCurrent <= pEnd && *pCurrent == 0)
         pCurrent++;

      // we are now pointing at begginning of line or pCurrent > pBuf
      if(pCurrent > pEnd)
         break;

      p = ParseAndAllocateDownloadSite(pCurrent);
      if(p)
         AddSite(p);
      
      pCurrent += lstrlen(pCurrent);
   }

   delete pBuf;
   CloseHandle(hfile);

   if(!m_onegoodsite)
      return E_UNEXPECTED;
   else
      return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

// BUGBUG: Stack is getting large here - consider writing with
//   only one buffer that is reused. Have to break up the nice Allocate
//   call
DOWNLOADSITE *CDownloadSiteMgr::ParseAndAllocateDownloadSite(LPSTR psz)
{
   char szUrl[1024];
   char szName[256];
   char szlang[256];
   char szregion[256];
   BOOL bQueryTrue = TRUE;
   DOWNLOADSITE *p = NULL;

   GetStringField(psz, 0, szUrl, sizeof(szUrl)); 
   GetStringField(psz,1, szName, sizeof(szName));
   GetStringField(psz, 2, szlang, sizeof(szlang));
   GetStringField(psz, 3, szregion, sizeof(szregion));

   if(szUrl[0] == 0 || szName[0] == 0 || szlang[0] == 0 || szregion[0] == 0)
      return NULL;

   m_onegoodsite = TRUE;
   
   // Hack - Check language against what is in our query params
   //    a) this query should have already been performed on the server
   //    b) or it should be more generic/its own function

   if(m_pquery)
   {
      if(m_pquery->pszLang && (lstrcmpi(m_pquery->pszLang, szlang) != 0))
         bQueryTrue = FALSE;

      // query for region
      if(bQueryTrue && m_pquery->pszRegion && (lstrcmpi(m_pquery->pszRegion, szregion) != 0))
         bQueryTrue = FALSE;
   }

   if(bQueryTrue)
      p = AllocateDownloadSite(szUrl, szName, szlang, szregion);

   return p;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

DWORD CDownloadSiteMgr::TranslateLanguage(LPSTR psz)
{
   return ( (DWORD) AtoL(psz) );
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT CDownloadSiteMgr::AddSite(DOWNLOADSITE *pdls)
{
   if((m_numsites % m_arraysize == 0) && m_numsites != 0)
   {
      m_arraysize += SITEARRAY_GROWTHFACTOR;
      DOWNLOADSITE **pp = (DOWNLOADSITE **) realloc( m_ppdls, m_arraysize * sizeof(DOWNLOADSITE *));
      if(pp)
         m_ppdls = pp;
      else
      {
         m_arraysize -= SITEARRAY_GROWTHFACTOR;
         return E_OUTOFMEMORY;
      }
   }

   if(!m_ppdls)
   {
       return E_OUTOFMEMORY;
   }
   
   m_ppdls[m_numsites++] = pdls;
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\dllmain.cpp ===
#include "pch.h"
#include "migrate.h"

HINSTANCE g_hInstance = NULL;

STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
		// Open log; FALSE means do not delete existing log
		SetupOpenLog(FALSE);
        g_hInstance = (HINSTANCE)hDll;
        break;

    case DLL_PROCESS_DETACH:
        if (g_lpNameBuf)
            LocalFree(g_lpNameBuf);
        if (g_lpWorkingDir)
            LocalFree(g_lpWorkingDir);
        if (g_lpSourceDirs)
            LocalFree(g_lpSourceDirs);

		SetupCloseLog();
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\inseng\utils2.cpp ===
#include "inspch.h"
#include "inseng.h"
#include "resource.h"
#include "insobj.h"
#include "advpub.h"
#include "capi.h"
#include "util.h"
#include "util2.h"
#include <regstr.h>

TCHAR c_gszSetupAPI[] = "setupapi.dll";
TCHAR c_gszAdvpext[]   = "advpext.dll";

// A reusable buffer for logging. Note there is a possible threading
// issue here as two threads may use this at the same time! I am choosing
// not to protect it for performance reasons but be careful!!
char szLogBuf[512];



// NT reboot
//



#define MSDOWNLOAD  "msdownld.tmp"
#define DOWNLDSUB   "download"

// functions
BOOL IfNotExistCreateDir( LPTSTR lpDir, BOOL bHidden, BOOL bRemoveFileIfExist );
BOOL CheckImageHlp_dll();

char g_szWindowsDir[MAX_PATH] = { 0 };

#define MAXRETRIES 100
BOOL GetUniqueFileName(LPCSTR pszRoot, LPCSTR pszPrefix, UINT uStartIndex, LPSTR pszBuffer)
{
   char pszTemp[MAX_PATH];
   char pszTempname[16];
   // we now ignore the uStartIndex parameter, and create something random.
   uStartIndex = GetTickCount() % 0xFFFF9A;
   UINT uEndIndex = uStartIndex + MAXRETRIES;
   LPSTR pszEnd;

   pszBuffer[0] = 0;
   lstrcpy(pszTemp, pszRoot);
   pszEnd = pszTemp + lstrlen(pszTemp);

   do
   {
      wsprintf(pszTempname, "%s%06X.tmp", pszPrefix, uStartIndex);
      AddPath(pszTemp, pszTempname);
      if(GetFileAttributes(pszTemp) == 0xFFFFFFFF)
         break;
      uStartIndex++;
      *pszEnd = 0;
   } while (uStartIndex < uEndIndex);

   if(uStartIndex != uEndIndex)
      lstrcpy(pszBuffer, pszTemp);

   return ( pszBuffer[0] != 0 );
}

#define MIN_DISKSIZE_FOR_EXTRACT 1024 * 100
#define MAX_DRIVES 26

BOOL IsUsableDrive(LPSTR szRoot)
{
   static BYTE bDrives[MAX_DRIVES] = { 0 };
   static UINT uUseRemovable = 0xffffffff;
   BOOL fUsable;
   UINT uType;
   DWORD dwOldErrorMode;

   if(uUseRemovable == 0xffffffff)
   {
      char sztemp[] = "X:\\";
      for(char ch = 'A'; ch <= 'Z'; ch++)
      {
         sztemp[0] = ch;
         if(GetDriveType(sztemp) == DRIVE_FIXED)
         {
            uUseRemovable = FALSE;
            break;
         }
      }
      if(uUseRemovable == 0xffffffff)
         uUseRemovable = TRUE;
   }

   dwOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
   uType = GetDriveType(szRoot);

   // the drive type is OK, if
   // it is fixed or removable AND
   // it is bigger than MIN_DISKSIZE_FOR_EXTRACT AND
   // GetFileAttributes succeeds
   //
   if ( (!bDrives[szRoot[0] - 'A']) &&
        ((uType == DRIVE_REMOVABLE && uUseRemovable) || (uType == DRIVE_FIXED))  &&
        ( GetFileAttributes( szRoot ) != 0xffffffff) &&
        ( GetDriveSize(szRoot) >= MIN_DISKSIZE_FOR_EXTRACT ) )
   {
        fUsable = TRUE;
   }
   else
   {
      bDrives[szRoot[0] - 'A'] = 1;
      fUsable = FALSE;
   }
   SetErrorMode(dwOldErrorMode);
   return fUsable;
}

BOOL IsDirWriteable(LPSTR lpDir)
{
    char szFile[MAX_PATH];
    HANDLE  hFile;
    BOOL    bWriteAccess = FALSE;

    lstrcpy(szFile, lpDir);
    AddPath(szFile, "~!~ie6.~!~");
    hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        bWriteAccess = TRUE;
        CloseHandle(hFile);
        DeleteFile(szFile);
    }
    return bWriteAccess;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

// BUGBUG: Currently we have two problems :
//     1. Always assume cache drive == win drive
//     2. Compression isn't accounted for on stuff going to cache

HRESULT CreateTempDir( DWORD dwDownloadSize,
                     DWORD dwExtractSize,
                     char chInstallDrive, DWORD dwInstallSize,
                     DWORD dwWindowsDriveSize,
                     LPSTR pszBuf,  DWORD dwBufSize, DWORD dwFlag )
{
    char  szRoot[MAX_PATH];
    char  szUnique[MAX_PATH];
    DWORD dwReqSize;
    DWORD dwReqSizeWin = 0;
    DWORD dwReqSizeOther = 0;
    DWORD dwVolFlags;
    DWORD dwCompressFactor;

    if ( !pszBuf || (dwBufSize==0) )
    {
        return ( E_INVALIDARG );
    }

    if(g_szWindowsDir[0] == 0)
    {
       GetWindowsDirectory(g_szWindowsDir, sizeof(g_szWindowsDir));
    }
    // Make sure there is enough install space on drive
    dwReqSizeWin = dwWindowsDriveSize;
    if(chInstallDrive == g_szWindowsDir[0])
       dwReqSizeWin += dwInstallSize;
    else
       dwReqSizeOther = dwInstallSize;

    if(dwReqSizeWin > 0)
    {
       lstrcpyn(szRoot, g_szWindowsDir, 4);
       if(!IsEnoughSpace(szRoot, dwReqSizeWin))
          return E_FAIL;
    }

    if(dwReqSizeOther > 0)
    {
       lstrcpyn(szRoot, g_szWindowsDir, 4);
       szRoot[0] = chInstallDrive;
       if(!IsEnoughSpace(szRoot, dwReqSizeOther))
          return E_FAIL;
    }

    lstrcpy( szRoot, "A:\\" );

    while ( szRoot[0] <= 'Z' )
    {
        UINT uType;

        uType = GetDriveType(szRoot);

        // even the drive type is OK, verify the drive has valid connection
        //
        if ( !IsUsableDrive(szRoot) )
        {
            szRoot[0]++;
            continue;
        }

        if(!IsDirWriteable(szRoot))
        {
            szRoot[0]++;
            continue;
        }

        if(!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolFlags, NULL, 0))
        {
            szRoot[0]++;
            continue;
        }
        if(dwVolFlags & FS_VOL_IS_COMPRESSED)
           dwCompressFactor = 19;
        else
           dwCompressFactor = 10;


        // suitable drive:
        dwReqSize = (dwDownloadSize * dwCompressFactor)/10;
        dwReqSize += dwExtractSize;
        if(g_szWindowsDir[0] == szRoot[0])
           dwReqSize += dwReqSizeWin;
        else if(chInstallDrive == szRoot[0])
           dwReqSize += dwReqSizeOther;

        if ( !IsEnoughSpace( szRoot, dwReqSize  ) )
        {
            szRoot[0]++;
            continue;
        }

        // if our suitable drive happens also to be the windows drive,
        // create msdownld.tmp of of it.
        if(szRoot[0] == g_szWindowsDir[0])
              lstrcpy(szRoot, g_szWindowsDir);

        AddPath( szRoot, MSDOWNLOAD );

        if ( !IfNotExistCreateDir( szRoot, TRUE, TRUE ) )
        {
TryNextDrive:
            szRoot[0]++;
            szRoot[3] = '\0';
            continue;
        }

        // BUGBUG: On NT, it always tries with sequential numbers ASE1.TMP, ASE2.TMP
        // ASE3.TMP, etc. and if there is already a directory by this name
        // it fails the call instead of trying again with next number!
        //
        if ( !GetUniqueFileName(szRoot,"AS", 0, szUnique) )
           goto TryNextDrive ;

        lstrcpy(szRoot, szUnique);

        if ( !IfNotExistCreateDir( szRoot, FALSE, FALSE) )
        {
            goto TryNextDrive;
        }

        // you got the good dir
        AddPath( szRoot, "" );

        if ( (DWORD) lstrlen(szRoot)+1 >  dwBufSize )
        {
            return ( E_INVALIDARG );
        }

        // success
        lstrcpy( pszBuf, szRoot );
        return S_OK;
    }

    // no drive has enough space
    return( E_FAIL );
}

void CleanUpTempDir(LPCSTR szTemp)
{
   char szBuf[MAX_PATH];
   char szWinDir[MAX_PATH];


   lstrcpy(szBuf, szTemp);

   DelNode(szBuf, 0);

   // clean up msdownld.tmp if its not the windows drive
   GetWindowsDirectory(szWinDir, sizeof(szWinDir));
   if(!ANSIStrStrI(szBuf, szWinDir))
   {
      GetParentDir(szBuf);
      DelNode(szBuf, ADN_DEL_IF_EMPTY);
   }
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//
// Checks the install destination dir free disk space
//
BOOL IsEnoughSpace( LPCSTR szPath, DWORD dwInstNeedSize )
{
   char szRoot[4];

   lstrcpyn(szRoot, szPath, 4);
   if( szRoot[0] == 0)
      return FALSE;

   if ( dwInstNeedSize + 1 > GetSpace(szRoot) )
      return FALSE;
   else
      return TRUE;
}


void SafeAddPath(LPSTR szPath, LPCSTR szName, DWORD dwPathSize)
{
    LPSTR szTmp;
    DWORD dwLen = lstrlen(szPath);

    if(dwLen + 1 >= dwPathSize)
       return;

        // Find end of the string
    szTmp = szPath + dwLen;

        // If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';
    *szTmp = 0;

        // Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpyn( szTmp, szName, dwPathSize - lstrlen(szPath) );
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL IfNotExistCreateDir( LPTSTR lpDir, BOOL bHidden, BOOL bRemoveFileIfExist)
{
    DWORD attr;

    attr = GetFileAttributes( lpDir );
    if ((attr != -1) && !(attr & FILE_ATTRIBUTE_DIRECTORY))
    {
        // lpDir does not have a directory attribute
        // If we are allowed to delete the file, try do that.
        if (bRemoveFileIfExist)
        {
            SetFileAttributes(lpDir, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(lpDir);
            attr = GetFileAttributes( lpDir );
        }
    }
    if (attr == -1)
    {
        if ( CreateDirectory( lpDir, NULL ) )
        {
           if(bHidden)
              return (SetFileAttributes( lpDir, FILE_ATTRIBUTE_HIDDEN ) );
           else
              return TRUE;
        }
        else
           return FALSE;
    }

    return (attr & FILE_ATTRIBUTE_DIRECTORY);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
   STARTUPINFO startInfo;
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;

   if(phProc)
      *phProc = NULL;

   // Create process on pszCmd
   ZeroMemory(&startInfo, sizeof(startInfo));
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   startInfo.wShowWindow = (USHORT)uShow;
   fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE,
              NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
   if(!fRet)
      return E_FAIL;

   if(phProc)
      *phProc = processInfo.hProcess;
   else
      CloseHandle(processInfo.hProcess);

   CloseHandle(processInfo.hThread);

   return S_OK;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

HRESULT LaunchAndWait(LPSTR pszCmd, HANDLE hAbort, HANDLE *phProc, LPSTR pszDir, UINT uShow)
{
   HRESULT hr = S_OK;

   hr = LaunchProcess(pszCmd, phProc, pszDir, uShow);

   if(SUCCEEDED(hr))
   {
      HANDLE pHandles[2];
      BOOL fQuit = FALSE;
      pHandles[0] = *phProc;

      if(hAbort)
         pHandles[1] = hAbort;

      DWORD dwRet;

      while(!fQuit)
      {
         dwRet = MsgWaitForMultipleObjects(hAbort ? 2 : 1, pHandles, FALSE, INFINITE, QS_ALLINPUT);
         // Give abort the highest priority
         if(dwRet == WAIT_OBJECT_0)
         {
            fQuit = TRUE;
         }
         else if((dwRet == WAIT_OBJECT_0 + 1) && hAbort)
         {
            // Any abort work?
            hr = E_ABORT;
            fQuit = TRUE;
         }
         else
         {
            MSG msg;
            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {

               // if it's a quit message we're out of here
               if (msg.message == WM_QUIT)
                  fQuit = TRUE;
               else
               {
                  // otherwise dispatch it
                 DispatchMessage(&msg);
               } // end of PeekMessage while loop
            }
         }
      }
   }

   return hr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   DWORD dwTemp1,dwTemp2;

   dwTemp1 = GetIntField(pszVer, 0, 0);
   dwTemp2 = GetIntField(pszVer, 1, 0);

   *pdwVer = (dwTemp1 << 16) + dwTemp2;

   dwTemp1 = GetIntField(pszVer, 2, 0);
   dwTemp2 = GetIntField(pszVer, 3, 0);

   *pdwBuild = (dwTemp1 << 16) + dwTemp2;
}

/*
void ConvertVersionStr(LPSTR pszVer, WORD rwVer[])
{
   LPSTR pszMyVer = MakeAnsiStrFromAnsi(pszVer);
   LPSTR pszEnd = pszMyVer + lstrlen(pszMyVer);
   LPSTR pszTemp = pszMyVer;
   LPSTR pszBegin;

   for(int i = 0; i < NUM_VERSION_ENTRIES; i++)
      rwVer[i] = 0;

   for(i = 0; i < 4 && pszTemp < pszEnd; i++)
   {
      pszBegin = pszTemp;
      while(pszTemp < pszEnd && *pszTemp != ',')
         pszTemp++;

      *pszTemp = 0;
      rwVer[i] = (WORD) AtoL(pszBegin);
      pszTemp++;
   }
   CoTaskMemFree(pszMyVer);
}

*/
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//    -1   Ver1 < Ver2
//     0   Ver1 == Ver2
//     1   Ver1 > Ver2
// Notes:

int VersionCmp(WORD rwVer1[], WORD rwVer2[])
{
/*
   for(int i = 0; i < NUM_VERSION_ENTRIES; i++)
   {
      if(rwVer1[i] < rwVer2[i])
         return -1;
      if(rwVer1[i] > rwVer2[i])
         return 1;
   }
*/
  return 0;

}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags | MB_ICONERROR | MB_TASKMODAL);

    return id;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize)
{

   if(cMaxSize == 0)
      return 0;

   pszBuf[0] = 0;

   return LoadString(g_hInstance, id, pszBuf, cMaxSize);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
   {
      if (*pszStr == '\"')
      {
          // Move past the first "
          pszStr++;

          // Now keep scanning till find the closing ". After that return to scanning
          // for the user-given delimiter 'ch'.
          while( *pszStr != 0 && *pszStr != '\"' )
              pszStr++;

          // Have reached end of string without finding closing ", return now.
          if (*pszStr == 0)
              break;
      }

      pszStr++;
   }

   return pszStr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//    This is a very hacky function that will strip quotes.
//    Note it chages the contents of the buffer passed to it!!
LPSTR StripQuotes(LPSTR pszStr)
{
   if(!pszStr)
      return NULL;

   UINT uEnd = lstrlenA(pszStr);
   if(uEnd > 0 && pszStr[uEnd-1] == '"' && *pszStr == '"')
   {
      pszStr[uEnd-1] = 0;
      pszStr++;
   }

   return pszStr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


DWORD WINAPI LaunchInfCommand(void *p)
{
   HRESULT hr = S_OK;

   INF_ARGUEMENTS *pinfArgs = (INF_ARGUEMENTS *)p;

   if(pinfArgs->dwType == InfExCommand)
   {
      CABINFO cabinfo;
      cabinfo.pszCab = pinfArgs->szCab;
      cabinfo.pszInf = pinfArgs->szInfname;
      cabinfo.pszSection = pinfArgs->szSection;

      lstrcpy(cabinfo.szSrcPath, pinfArgs->szDir);
      cabinfo.dwFlags = pinfArgs->dwFlags;

      hr = ExecuteCab(NULL, &cabinfo, 0);
   }
   else
   {
      hr = RunSetupCommand(NULL, pinfArgs->szInfname,
                   lstrlen(pinfArgs->szSection) ? pinfArgs->szSection : NULL,
                   pinfArgs->szDir, NULL, NULL, pinfArgs->dwFlags, NULL );
   }
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

#define ABOUTTWODAYSTIME  0x000000C9

void CleanupDir(LPSTR lpDir)
{
    char szFile[MAX_PATH];
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    FILETIME currenttime;

    if ( lpDir == NULL  ||  *lpDir == '\0' )
        return;

    lstrcpy( szFile, lpDir );
    if ( szFile[ lstrlen(szFile)-1 ] != '\\' )
        lstrcat( szFile, "\\" );
    lstrcat( szFile, "*.tmp" );
    hFindFile = FindFirstFile( szFile, &fileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
        return;

    do
    {

        if ( fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( fileData.cFileName, "." ) == 0  ||
                 lstrcmp( fileData.cFileName, ".." ) == 0 )
                continue;

            GetSystemTimeAsFileTime(&currenttime);
            if( ( currenttime.dwHighDateTime  >
                   fileData.ftLastWriteTime.dwHighDateTime ) &&
                ( currenttime.dwHighDateTime -
                   fileData.ftLastWriteTime.dwHighDateTime > ABOUTTWODAYSTIME))
            {
               lstrcpy( szFile, lpDir );
               if ( szFile[ lstrlen(szFile)-1 ] != '\\' )
                  lstrcat( szFile, "\\" );
               // delete the sub-dir
               lstrcat( szFile, fileData.cFileName );
               SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL );
               DelNode( szFile, 0 );
            }
        }
        else
           continue;

    } while ( FindNextFile( hFindFile, &fileData ) );

    FindClose( hFindFile  );
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

DWORD WINAPI CleanUpAllDirs(LPVOID pv)
{
   char szDir[MAX_PATH];
   UINT uType;

   DllAddRef();
   if(g_szWindowsDir[0] == 0)
   {
      GetWindowsDirectory(g_szWindowsDir, sizeof(g_szWindowsDir));
   }

   lstrcpy( szDir, "X:\\" );
   for(char chDrive = 'A'; chDrive <= 'Z'; chDrive++)
   {
      szDir[0] = chDrive;

      if (IsUsableDrive(szDir))
      {
         if(chDrive == g_szWindowsDir[0])
            lstrcpy(szDir, g_szWindowsDir);

         AddPath(szDir, MSDOWNLOAD);
         CleanupDir(szDir);
         szDir[3] = 0;
      }
   }
   DllRelease();
   return 0;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL IsCabFile(LPCSTR pszFile)
{

   DWORD dwLen = lstrlenA(pszFile);
   if(dwLen <= 3)
      return FALSE;

   LPCSTR pszExt = pszFile + (dwLen - 4);

   if(lstrcmpiA(pszExt, ".cab") == 0)
   {
      return TRUE;
   }

   return FALSE;
}

typedef HRESULT (WINAPI *WINVERIFYTRUST) (HWND hwnd, GUID *pgActionID, LPVOID pWintrustData);

// BUGBUG: get rid of this once moved to winbase.h!!!
// #define WIN_TRUST_SUBJTYPE_CABINET                               \
//            { 0xd17c5374,                                        \
//              0xa392,                                            \
//              0x11cf,                                            \
//              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
//            }

// PublishedSoftwareNoBad {C6B2E8D0-E005-11cf-A134-00C04FD7BF43}
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI              \
            { 0xc6b2e8d0,                                       \
              0xe005,                                           \
              0x11cf,                                           \
              { 0xa1, 0x34, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x43 } \
            }

#define WINTRUST "wintrust.dll"

// Verion number 5.0
#define AUTHENTICODE2_MS_VERSION 0x00050000
// Build number 1542.32
#define AUTHENTICODE2_LS_VERSION  0x06050020
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//
HRESULT CheckTrustIE3(LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt);
HRESULT CheckTrustIE4(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt);


HRESULT WINAPI CheckTrustEx(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved)
{
   WINVERIFYTRUST pwvt;
   HINSTANCE hinst;
   char szPath[MAX_PATH] = { 0 };
   DWORD   dwVerMS = 0;
   DWORD   dwVerLS = 0;
   HRESULT hr = S_OK;
   static BOOL st_CheckTrust = TRUE ;
   static BOOL st_Auth2Checked = FALSE;


   if (!st_CheckTrust)
        return S_FALSE ;

   if (!CheckImageHlp_dll())
   {
       st_CheckTrust = FALSE;
       return S_FALSE ;
   }

   hinst = LoadLibrary(WINTRUST);
   if(!hinst)
   {
      //
      st_CheckTrust = FALSE ;

      return S_FALSE;
   }

   if (!st_Auth2Checked)
   {
       // If we get here, we know we can load Wintrust.dll
       GetSystemDirectory(szPath, sizeof(szPath));
       AddPath(szPath, "Softpub.dll");
       GetVersionFromFile(szPath, &dwVerMS, &dwVerLS, TRUE);

       // If softpubs version is less then the  authenticode2 version don't call WinverifyTrust.
       if ((dwVerMS < AUTHENTICODE2_MS_VERSION) ||
           ((dwVerMS == AUTHENTICODE2_MS_VERSION) && (dwVerLS < AUTHENTICODE2_LS_VERSION)) )
       {
          hr = S_FALSE;
          st_CheckTrust = FALSE;
       }
       st_Auth2Checked = TRUE;
   }

   if (st_CheckTrust)
   {

      pwvt = (WINVERIFYTRUST) GetProcAddress(hinst, "WinVerifyTrust");
      if(!pwvt)
      {
         FreeLibrary(hinst);
         st_CheckTrust = FALSE ;

         return S_FALSE;
      }
      // If we don't have a URL, use the IE3 methode of CheckTrust.
      hr = TRUST_E_PROVIDER_UNKNOWN;
      if (szURL)
      {
         // The new way of calling into WinVerifyTrust wll return TRUST_E_PROVIDER_UNKNOWN
         // if the new methode is not implemented on the system.
         __try
         {
             hr = CheckTrustIE4(szURL, szFilename, hwndForUI, bShowBadUI, pwvt);
         }
         __except(EXCEPTION_EXECUTE_HANDLER)
         {
             //Corrupted Java.
             hr = TRUST_E_FAIL;             
         }   
         
      }

      if (hr == TRUST_E_PROVIDER_UNKNOWN || hr == E_FAIL)
      {
          hr = CheckTrustIE3(szFilename, hwndForUI, bShowBadUI, pwvt);
          if (hr == S_FALSE)
             st_CheckTrust = FALSE;
      }
   }

   FreeLibrary(hinst);
   return hr;
}


HRESULT CheckTrustIE3(LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt)
{
    HRESULT hr;
    LPWSTR pwszFilename = NULL;

    GUID PublishedSoftware = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID PublishedSoftwareNoBadUI = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI;

    GUID * ActionGUID;

    if(bShowBadUI)
        ActionGUID = &PublishedSoftware;
    else
        ActionGUID = &PublishedSoftwareNoBadUI;

    GUID SubjectPeImage = WIN_TRUST_SUBJTYPE_PE_IMAGE;
    GUID SubjectCAB = WIN_TRUST_SUBJTYPE_CABINET;
    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ActionData;
    WIN_TRUST_SUBJECT_FILE Subject;

    Subject.hFile = INVALID_HANDLE_VALUE;
    pwszFilename = OLESTRFROMANSI(szFilename);
    Subject.lpPath = pwszFilename;

    if (IsCabFile(szFilename))
    {
        ActionData.SubjectType = &SubjectCAB;
    }
    else
    {
        ActionData.SubjectType = &SubjectPeImage;
    }

    ActionData.Subject = &Subject;
    ActionData.hClientToken = NULL;

    hr =  pwvt( hwndForUI, ActionGUID, &ActionData);

    if(hr == E_FAIL)
    {
        // Hopefully, this is a general "trust is screwy" error. We will put
        //   up our own ui to see if we can continue
        // Is this UI OK

        char szTitle[128];
        char szMess[256];

        LoadSz(IDS_SECURITYTITLE, szTitle, 128);
        LoadSz(IDS_SECURITY, szMess, 256);
        if(MessageBox(hwndForUI, szMess, szTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
            hr = S_FALSE;
        }

    }

    if(pwszFilename)
        CoTaskMemFree(pwszFilename);
    return hr;
}


// {D41E4F1D-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_PROVIDER_DOWNLOAD \
{ 0xd41e4f1d, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

typedef HRESULT (WINAPI *COINTERNETCREATESECURITYMANAGER) ( IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

HRESULT CheckTrustIE4(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, WINVERIFYTRUST pwvt)
{
    GUID     guidCor = COR_POLICY_PROVIDER_DOWNLOAD;
    GUID    *pguidActionIDCor = &guidCor;

    LPWSTR pwszURL = NULL;
    GUID guidJava = JAVA_POLICY_PROVIDER_DOWNLOAD;
    GUID    *pguidActionIDJava = &guidJava;

    WINTRUST_DATA            wintrustData;
    WINTRUST_FILE_INFO       fileData;
    JAVA_POLICY_PROVIDER     javaPolicyData;

    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    HINSTANCE hUrlmon = NULL;
    IInternetSecurityManager *pSecMgr = NULL;
    DWORD dwZone;

    hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (hwndForUI == INVALID_HANDLE_VALUE)
            bShowBadUI = FALSE;

        pwszURL = OLESTRFROMANSI(szURL);

        memset(&wintrustData, 0, sizeof(wintrustData));
        memset(&fileData, 0, sizeof(fileData));
        memset(&javaPolicyData, 0, sizeof(javaPolicyData));

        javaPolicyData.cbSize = sizeof(JAVA_POLICY_PROVIDER);
        javaPolicyData.VMBased = FALSE;

        // obsolete: noone pays attention to this
        javaPolicyData.fNoBadUI = !bShowBadUI;

        javaPolicyData.pwszZone = pwszURL;
        javaPolicyData.pZoneManager = NULL;

        // Use a file handle, so that in case trust has to put up UI the path
        // to the local file does not show in hte UI if we actually downloaded the
        // file from a URL.
        fileData.cbStruct = sizeof(WINTRUST_FILE_INFO);
        fileData.pcwszFilePath = pwszURL;
        fileData.hFile = hFile;

        wintrustData.cbStruct = sizeof(WINTRUST_DATA);
        wintrustData.pPolicyCallbackData = &javaPolicyData;
        if (hwndForUI == INVALID_HANDLE_VALUE)
            wintrustData.dwUIChoice = WTD_UI_NONE;
        else if(bShowBadUI)
            wintrustData.dwUIChoice = WTD_UI_ALL;
        else
            wintrustData.dwUIChoice = WTD_UI_NOBAD;

        wintrustData.dwUnionChoice = WTD_CHOICE_FILE;
        wintrustData.pFile = &fileData;


        hr =  pwvt( hwndForUI, pguidActionIDCor, &wintrustData);
        if (hr == TRUST_E_PROVIDER_UNKNOWN)
        {
            hr =  pwvt( hwndForUI, pguidActionIDJava, &wintrustData);
        }

        // BUGBUG: Check with Vatsan about this bugbug.
        // this works around a wvt bug that returns 0x57 (success) when
        // you hit No to an unsigned control
        if (SUCCEEDED(hr) && hr != S_OK)
        {
            hr = TRUST_E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            hUrlmon = LoadLibrary("urlmon.dll");
            if (hUrlmon)
            {
                COINTERNETCREATESECURITYMANAGER pcicsm;

                pcicsm = (COINTERNETCREATESECURITYMANAGER) GetProcAddress(hUrlmon, "CoInternetCreateSecurityManager");
                if (pcicsm)
                    pcicsm(NULL, &pSecMgr, NULL);
            }

            if ((javaPolicyData.pbJavaTrust == NULL) ||
                (!javaPolicyData.pbJavaTrust->fAllActiveXPermissions) ||
                (pSecMgr && SUCCEEDED(pSecMgr->MapUrlToZone(pwszURL, &dwZone, 0)) && dwZone == URLZONE_LOCAL_MACHINE && FAILED(javaPolicyData.pbJavaTrust->hVerify)))
                hr = TRUST_E_FAIL;

            if (hUrlmon)
                FreeLibrary(hUrlmon);
        }

        if (javaPolicyData.pbJavaTrust)
            CoTaskMemFree(javaPolicyData.pbJavaTrust);

        if(pwszURL)
            CoTaskMemFree(pwszURL);

        CloseHandle(hFile);

        if (pSecMgr)
            pSecMgr->Release();
    }
    return hr;
}

HRESULT WINAPI CheckTrust(LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI)
{
    return CheckTrustEx(NULL, szFilename, hwndForUI, bShowBadUI, NULL);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, ',');
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, ',');
   while(pszBegin <= pszEnd && *pszBegin == ' ')
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;

   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);

   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);

   return dwToCopy - 1;
}

DWORD GetIntField(LPSTR szStr, UINT uField, DWORD dwDefault)
{
   char szNumBuf[16];

   if(GetStringField(szStr, uField, szNumBuf, sizeof(szNumBuf)) == 0)
      return dwDefault;
   else
      return AtoL(szNumBuf);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR BuildDependencyString(LPSTR pszName,LPSTR pszOwner)
{
   LPSTR pszRet = NULL;

   if(pszOwner)
   {
       char szBuf[128];
       LoadSz(IDS_DEPENDNAME, szBuf, sizeof(szBuf));
       pszRet = new char[lstrlenA(pszName) + lstrlenA(szBuf) + lstrlenA(pszOwner) + 25];
       if(pszRet)
          wsprintf(pszRet, szBuf, pszName, pszOwner);
   }
   else
   {
      pszRet = new char[lstrlenA(pszName) + 1];
      if(pszRet)
         lstrcpyA(pszRet, pszName);
   }

   return pszRet;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPWSTR ParseURLW(BSTR str)
{
   LPWSTR pwszTemp;

   if(str == NULL || *str == '\0')
      return NULL;

   pwszTemp = str + SysStringLen(str) - 1;
   while(pwszTemp >= str && *pwszTemp != '\\' && *pwszTemp != '/')
      pwszTemp--;

   return pwszTemp + 1;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR ParseURLA(LPCSTR str)
{
   LPSTR pszTemp;

   if(str == NULL || *str == '\0')
      return NULL;

   pszTemp = (LPSTR)str + lstrlen(str) - 1;
   while(pszTemp >= str && *pszTemp != '\\' && *pszTemp != '/')
      pszTemp--;

   return pszTemp + 1;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR MakeAnsiStrFromAnsi(LPSTR psz)
{
   LPSTR pszTmp;

   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) CoTaskMemAlloc(lstrlenA(psz) + 1);
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPSTR CopyAnsiStr(LPCSTR psz)
{
   LPSTR pszTmp;

   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) new char[lstrlenA(psz) + 1];
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

int StringFromGuid(const CLSID* piid, LPTSTR   pszBuf)
{
    return wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
                    piid->Data1, piid->Data2, piid->Data3, piid->Data4[0], piid->Data4[1],
                    piid->Data4[2],piid->Data4[3], piid->Data4[4], piid->Data4[5],
                    piid->Data4[6], piid->Data4[7]);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

LPWSTR MakeWideStrFromAnsi(LPSTR psz, BYTE  bType)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        break;
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

#define UNINSTALL_BRANCH "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"


BOOL UninstallKeyExists(LPCSTR pszUninstallKey)
{
   HKEY hUninstallKey = NULL;
   char szUninstallStr[512];

   if (!pszUninstallKey)    // If the pointer is NULL, assume installed
       return TRUE;

   lstrcpyA(szUninstallStr, UNINSTALL_BRANCH);
   lstrcatA(szUninstallStr, "\\");
   lstrcatA(szUninstallStr, pszUninstallKey);

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szUninstallStr, 0, KEY_READ,
                     &hUninstallKey) == ERROR_SUCCESS)
   {
      RegCloseKey(hUninstallKey);
      return TRUE;
   }
   else
      return FALSE;

}

void AddTempToLikelyExtractDrive(DWORD dwTempDLSpace, DWORD dwTempExSpace,
                                 char chInstallDrive, char chDownloadDrive,
                                 DWORD *pdwWinDirReq, DWORD *pdwInsDirReq,
                                 DWORD *pdwDownloadDirReq)
{
    DWORD dwExNeeded, dwNeeded;
    DWORD dwVolFlags, dwCompressFactor;
    char szRoot[4];
    DWORD dwInsDirNeeded = dwTempDLSpace + dwTempExSpace;
    DWORD dwInstallDriveCompress = 10;

    lstrcpy(szRoot, "A:\\");
    while ( szRoot[0] <= 'Z' )
    {
       if (!IsUsableDrive( szRoot ) )
       {
           szRoot[0]++;
           continue;
       }
       if(!GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolFlags, NULL, 0))
       {
           szRoot[0]++;
           continue;
       }
       if(dwVolFlags & FS_VOL_IS_COMPRESSED)
       {
          dwCompressFactor = 19;
          if(szRoot[0] == chInstallDrive)
             dwInstallDriveCompress = 19;
       }
       else
          dwCompressFactor = 10;
       // Decide how much we need if we extract to this drive
       dwExNeeded = (dwTempDLSpace * dwCompressFactor)/10 + dwTempExSpace;

       dwNeeded = 0;
       // if the install dir, add what is going to install dir
       if(szRoot[0] == chInstallDrive)
          dwNeeded += *pdwInsDirReq;
       // if it is the windows dir, add what goes to win dir
       if(szRoot[0] == g_szWindowsDir[0])
          dwNeeded += *pdwWinDirReq;

       // BUGBUG: compression on this guy?
       if(szRoot[0] == chDownloadDrive)
          dwNeeded += ((*pdwDownloadDirReq * dwCompressFactor)/10);

       dwNeeded += dwExNeeded;
       // if this drive has enough bump Req if appropiate
       if(IsEnoughSpace(szRoot, dwNeeded ))
       {
          if(szRoot[0] == chInstallDrive)
          {
             *pdwInsDirReq += dwExNeeded;
          }
          else if(szRoot[0] == chDownloadDrive)
             *pdwDownloadDirReq += dwExNeeded;
          else if(szRoot[0] == g_szWindowsDir[0])
             *pdwWinDirReq += dwExNeeded;

          return;
       }
       szRoot[0]++;
    }
    // if we get here, NO drive has enough space.
    // Add to install dir here
    *pdwInsDirReq += (dwTempDLSpace * dwCompressFactor)/10 + dwTempExSpace;
}


#define INSTALLCHECK_VALUE 0
#define INSTALLCHECK_DATA  1
#define INSTALLCHECK_NOTSUPPORTED 2
// If you change the string below you also have to tell all clients which use this feature to change.
// The clients are writing there success values under this key.
#define REGSTR_SUCCESS_KEY "Software\\Microsoft\\Active Setup\\Install Check"
BOOL SuccessCheck(LPSTR pszSuccessKey)
{
   HKEY hKey = NULL;
   char szRegKey[512];
   char szRegData[512];
   DWORD dwSize;
   BOOL  bInstalledSuccessfull = FALSE;

   if (!pszSuccessKey)      // If the pointer is NULL, assume installed
       return TRUE;

   if (GetStringField(pszSuccessKey, INSTALLCHECK_NOTSUPPORTED, szRegKey, sizeof(szRegKey)))
       return FALSE;        // This format is not yet supported

   if (GetStringField(pszSuccessKey, INSTALLCHECK_VALUE, szRegKey, sizeof(szRegKey)) == 0)
       return TRUE;        // There is not Registry value to check for. Assume OK

   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, REGSTR_SUCCESS_KEY, 0, KEY_READ,
                     &hKey) == ERROR_SUCCESS)
   {
      dwSize = sizeof(szRegData);
      if (RegQueryValueEx(hKey, szRegKey, NULL, NULL, (LPBYTE)szRegData, &dwSize) == ERROR_SUCCESS)
      {
         bInstalledSuccessfull = TRUE;
         // If a data filed is specified, check if the value data compare
         if (GetStringField(pszSuccessKey, INSTALLCHECK_DATA, szRegKey, sizeof(szRegKey)))
         {
             bInstalledSuccessfull = (lstrcmpi(szRegKey, szRegData) == 0);
         }
      }
      RegCloseKey(hKey);
   }
   return bInstalledSuccessfull;
}


DWORD WaitForEvent(HANDLE hEvent, HWND hwnd)
{
   BOOL fQuit = FALSE;
   BOOL fDone = FALSE;
   DWORD dwRet;
   while(!fQuit && !fDone)
   {
      dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE,
                                        INFINITE, QS_ALLINPUT);
      // Give abort the highest priority
      if(dwRet == WAIT_OBJECT_0)
      {
         fDone = TRUE;
      }
      else
      {
         MSG msg;
         // read all of the messages in this next loop
         // removing each message as we read it
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         {
            if(!hwnd || !IsDialogMessage(hwnd, &msg))
            {
              // if it's a quit message we're out of here
              if (msg.message == WM_QUIT)
                fQuit = TRUE;
              else
              {
                 // otherwise dispatch it
                TranslateMessage(&msg);
                DispatchMessage(&msg);
              }
            } // end of PeekMessage while loop
         }
      }
   }
   return (fQuit ? EVENTWAIT_QUIT : EVENTWAIT_DONE);
}





// If .CIF command switch has #W or #w, expand it to Windows directory. Otherwise, do nothing.
// Input: lpBuf : the original switches
//        dwSize : buffer size
// Outout: lpBuf : expanded switches
//
void ExpandString( LPSTR lpBuf, DWORD dwSize )
{
    LPSTR pTmp, pTmp1;
    char ch;

    if ( !lpBuf || !*lpBuf || !dwSize )
        return;

    pTmp = ANSIStrChr( lpBuf, '#' );
    if ( pTmp )
    {
        pTmp1 = CharNext( pTmp );
        ch = (char)CharUpper((LPSTR) *pTmp1);
        if ( ch == 'W' )
        {
            PSTR pTmpBuf;

            // #W... => <WindowsDir>...
            if ( dwSize < (DWORD)( lstrlen(lpBuf) + lstrlen(g_szWindowsDir) - 1 ) )
                return;  // should never be here

            pTmpBuf = (LPSTR)LocalAlloc( LPTR, dwSize );
            if ( pTmpBuf )
            {
                *pTmp = '\0';
                lstrcpy( pTmpBuf, lpBuf );
                lstrcat( pTmpBuf, g_szWindowsDir );
                lstrcat( pTmpBuf, CharNext(pTmp1) );
                // re-set the output string
                lstrcpy( lpBuf, pTmpBuf );

                LocalFree( pTmpBuf );
            }
        }
        else if ( ch == '#' )
        {
            //  ##... => #...
            MoveMemory( pTmp, pTmp1, lstrlen(pTmp1)+1 );
        }
    }
}


void DeleteFilelist(LPCSTR pszFilelist)
{
   LPSTR pszSections, pszSectionsPreFail, pszTemp;
   DWORD dwSize = ALLOC_CHUNK_SIZE;
   DWORD dwRead;
   // Get a list of all sections
   //
   // BUGBUG: Write this so only one call to GetPrivateProfile exists
   pszSections = (LPSTR) malloc(dwSize);

   // Bail out if no memory
   if(!pszSections)
      return;

   dwRead = GetPrivateProfileStringA(NULL, NULL, "", pszSections, dwSize, pszFilelist);
   while( dwRead >= (dwSize - 2) )
   {
      dwSize += ALLOC_CHUNK_SIZE;
      pszSectionsPreFail = pszSections;
// #pragma prefast(suppress: 308, "Noise - pointer was saved")
      pszSections = (LPSTR) realloc(pszSections, dwSize);
      if(!pszSections)
      {
         free(pszSectionsPreFail);
         dwRead = 0;
         break;
      }
      dwRead = GetPrivateProfileStringA(NULL, NULL, "", pszSections, dwSize, pszFilelist);
   }

   pszTemp = pszSections;
   dwSize = lstrlenA(pszTemp);
   while(dwSize != 0)
   {
      WritePrivateProfileSection(pszTemp, NULL, pszFilelist);

      pszTemp += (dwSize + 1);
      dwSize = lstrlenA(pszTemp);
   }

   free(pszSections);
}


BOOL WaitForMutex(HANDLE hMutex)
{
    BOOL fQuit = FALSE;

    while (MsgWaitForMultipleObjects(1, &hMutex, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (!fQuit  &&  PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
               fQuit = TRUE;
            else
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return fQuit;
}

BOOL IsNT()
{
   static int st_IsNT = 0xffff;

   if(st_IsNT == 0xffff)
   {
      OSVERSIONINFO verinfo;        // Version Check

      verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
      if ( GetVersionEx( &verinfo ) != FALSE )
      {
          if( verinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
             st_IsNT = 0;
          else if ( verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
             st_IsNT = 1;
      }
   }

   return (st_IsNT == 1) ? TRUE : FALSE;

}

HINSTANCE InitSetupLib(LPCSTR pszInfName, HINF *phinf)
{
    HINSTANCE hInst = NULL;
    *phinf = NULL;

    if( IsNT() )
    {
       hInst = LoadLibrary("setupapi.dll");
       OpenINFEngine(  pszInfName, NULL, 0, phinf, NULL );
    }
    else
    {
       hInst = LoadLibrary("w95inf32.dll");
    }
    return hInst;
}

void FreeSetupLib(HINSTANCE hInst, HINF hInf)
{
   if(hInf)
      CloseINFEngine(hInf);
   if(hInst)
      FreeLibrary(hInst);
}

HRESULT MyTranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                              PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                              PSTR pszBuffer, DWORD dwBufferSize,
                              PDWORD pdwRequiredSize, HINF hInf )
{
   HRESULT hr;
   if(IsNT() && hInf)
   {
      hr = TranslateInfStringEx( hInf, pszInfFilename, pszTranslateSection, pszTranslateKey,
                                     		pszBuffer, dwBufferSize,
                                     		pdwRequiredSize, NULL );
   }
   else
   {
      hr = TranslateInfString( pszInfFilename, pszInstallSection, pszTranslateSection, pszTranslateKey,
                                   pszBuffer, dwBufferSize,
                                   pdwRequiredSize, NULL);
   }
   return hr;
}

#define UNUSED_STRING   "xxx"

HRESULT MyTranslateString( LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey,
                            LPSTR pszBuffer, DWORD dwBufferSize)
{
   HRESULT hr = E_FAIL;
   char szTemp[512];

   if(GetPrivateProfileString(pszID, pszTranslateKey, "", pszBuffer, dwBufferSize, pszCif))
   {
      //bad code
      DWORD dwLen = lstrlen(pszBuffer);
      if(dwLen > 2)
      {
         // Cut the last %, and then look up in string section
         if(pszBuffer[0] == '%' && pszBuffer[dwLen - 1] == '%')
         {
            pszBuffer[dwLen - 1] = 0;
            GetPrivateProfileString("Strings", pszBuffer + 1, UNUSED_STRING, szTemp, sizeof(szTemp), pszCif);
            if(lstrcmp(UNUSED_STRING, szTemp) != 0)
               lstrcpyn(pszBuffer, szTemp, dwBufferSize);
            else
               pszBuffer[dwLen - 1] = '%';
         }
      }
      hr = NOERROR;
   }

   return hr;
}

// add the quotes around the string
DWORD MyWritePrivateProfileString( LPCSTR pszSec, LPCSTR pszKey, LPCSTR pszData, LPCSTR pszFile)
{
   LPSTR pszBuf;
   DWORD dwOut = 0;

   pszBuf = (LPSTR)LocalAlloc( LPTR, lstrlen(pszData)+8 );
   if ( !pszBuf )
      return dwOut;

   lstrcpy( pszBuf, "\"" );
   lstrcat( pszBuf, pszData );
   lstrcat( pszBuf, "\"" );

   dwOut = WritePrivateProfileString(pszSec, pszKey, pszBuf, pszFile);

   LocalFree(pszBuf);
   return dwOut;
}

HRESULT WriteTokenizeString(LPCSTR pszCif, LPCSTR pszID, LPCSTR pszTranslateKey, LPCSTR pszBuffer)
{
   HRESULT hr = E_FAIL;
   char szTemp[MAX_PATH];
   LPCSTR pszKeyname, pszSecname;

   pszKeyname = pszTranslateKey;
   pszSecname = pszID;
   if(GetPrivateProfileString(pszID, pszTranslateKey, "", szTemp, sizeof(szTemp), pszCif))
   {
      //bad code
      DWORD dwLen = lstrlen(szTemp);
      if(dwLen > 2)
      {
         // Cut the last %, and then look up in string section
         if(szTemp[0] == '%' && szTemp[dwLen - 1] == '%')
         {
            szTemp[dwLen - 1] = 0;
            pszKeyname = &szTemp[1];
            pszSecname = "strings";
         }
      }
   }

   if (MyWritePrivateProfileString(pszSecname, pszKeyname, pszBuffer, pszCif))
      hr = NOERROR;

   return hr;
}


HWND GetVersionConflictHWND()
{
   char szBuf[256];

   LoadSz(IDS_VERSIONCONFLICT, szBuf, sizeof(szBuf));
   HWND hVersionConflict = FindWindowEx(NULL, NULL, (LPCSTR)
                SEARCHFORCONFLICT_CLASS, szBuf );
   if(!hVersionConflict)
   {
      LoadSz(IDS_VERSIONCONFLICTNT, szBuf, sizeof(szBuf));
      hVersionConflict = FindWindowEx(NULL, NULL, (LPCSTR)
               SEARCHFORCONFLICT_CLASS, szBuf );
   }
   return hVersionConflict;
}

HRESULT WINAPI CheckForVersionConflict()
{
   HWND hVersionConflict = GetVersionConflictHWND();

   if(hVersionConflict)
      BOOL foo = SetForegroundWindow(hVersionConflict);
   return S_OK;
}

int CompareLocales(LPCSTR pcszLoc1, LPCSTR pcszLoc2)
{
   int ret;

   if(pcszLoc1[0] == '*' || pcszLoc2[0] == '*')
      ret = 0;
   else
      ret = lstrcmpi(pcszLoc1, pcszLoc2);

   return ret;
}

HRESULT CreateTempDirOnMaxDrive(LPSTR pszDir, DWORD dwBufSize)
{
    char szRoot[] = "A:\\";
    char szDownloadDrive[] = "?:\\";
    char szDir[MAX_PATH];
    char szUnique[MAX_PATH];
    DWORD dwMaxFree = 0;
    DWORD dwDriveFree;

   if(pszDir)
      pszDir[0] = 0;

        // Check all loacle drives for diskspace and take the one with the most.
   while ( szRoot[0] <= 'Z' )
   {

       // even the drive type is OK, verify the drive has valid connection
       //
       if (!IsUsableDrive( szRoot ) )
       {
           szRoot[0]++;
           continue;
       }


       if(!IsDirWriteable(szRoot))
       {
           szRoot[0]++;
           continue;
       }

       dwDriveFree = GetSpace(szRoot);

       if (dwDriveFree > dwMaxFree)
       {
           dwMaxFree = dwDriveFree;
           szDownloadDrive[0] = szRoot[0];
       }
       szRoot[0]++;

   }
   if(szDownloadDrive[0] == '?')
      return E_FAIL;

   lstrcpy(szDir, szDownloadDrive);

   // if our suitable drive happens also to be the windows drive,
   // create msdownld.tmp of of it.
   if(szDownloadDrive[0] == g_szWindowsDir[0])
      lstrcpy(szDir, g_szWindowsDir);

   AddPath( szDir, MSDOWNLOAD );

   if ( !IfNotExistCreateDir( szDir, TRUE, TRUE) )
      return E_FAIL;

   //
   if ( !GetUniqueFileName(szDir,"AS", 0, szUnique) )
      return E_FAIL;

   lstrcpy(szDir, szUnique);

   if ( !IfNotExistCreateDir( szDir, FALSE, FALSE) )
       return E_FAIL;

   AddPath( szDir, "" );

   if ( (DWORD) lstrlen(szDir)+1 >  dwBufSize )
       return ( E_INVALIDARG );

   // success
   lstrcpy( pszDir, szDir );
   return S_OK;
}


/*
 * enabled or restores Sage
 * bRestore TRUE means restore, otherwise disable
 */
void EnableSage(BOOL bRestore)
{
//MBD 6-22: MUST USE stdcall convention when accessing sage.dll
typedef long (__stdcall *PFNDLL)(int);

    HINSTANCE hSageAPI;
    PFNDLL  pfnSageEnable;
    static int restore = ENABLE_AGENT; //initialize to valid value...

    hSageAPI = LoadLibrary("SAGE.DLL");
    if (hSageAPI != NULL)
    {
        pfnSageEnable = (PFNDLL) GetProcAddress(hSageAPI,"System_Agent_Enable");
        if(pfnSageEnable)
        {
            if(bRestore)
            {
                (pfnSageEnable)(restore);
            }
            else
            {
                if(ENABLE_AGENT == (restore = (pfnSageEnable)(GET_AGENT_STATUS)))
                {
                    (pfnSageEnable)(DISABLE_AGENT);
                }
            }
        }
        FreeLibrary(hSageAPI);
    }
}

void EnableScreenSaver(BOOL bRestore)
{
    static BOOL bScreenSaver = FALSE;
    if (bRestore)
    {
        SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, bScreenSaver, 0 , 0);
        bScreenSaver = FALSE;   // reset the static to be able to disable the screensaver again.
    }
    else
    {
        // Only if the static is false call this again,
        // otherwise we did call this function already.
        if (!bScreenSaver)
        {
            SystemParametersInfo( SPI_GETSCREENSAVEACTIVE, FALSE, &bScreenSaver, 0);
            SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, FALSE, 0 , 0);
        }
    }
}

void EnableDiskCleaner(BOOL bRestore)
{
   static HANDLE hDiskCleaner = NULL;
   if (bRestore)
   {
      if (hDiskCleaner)
      {
         CloseHandle(hDiskCleaner);
         hDiskCleaner = NULL;
      }
   }
   else
   {
      hDiskCleaner = CreateEvent(NULL, FALSE, FALSE, "DisableLowDiskWarning");
   }
}

#if 0
typedef HRESULT (WINAPI *COINTERNETCREATESECURITYMANAGER) ( IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

DWORD IsUrlSaveToDownloadFrom(LPSTR lpszURL)
{
    HRESULT hr;
    BOOL    bOK = FALSE;
    DWORD   dwPolicy = URLPOLICY_QUERY;     // In the default case we do checktrust
    HINSTANCE   hUrlmon;
    COINTERNETCREATESECURITYMANAGER pcicsm;

    hUrlmon = LoadLibrary("urlmon.dll");
    if (hUrlmon)
    {
        pcicsm = (COINTERNETCREATESECURITYMANAGER) GetProcAddress(hUrlmon, "CoInternetCreateSecurityManager");
        if (pcicsm)
        {
            IInternetSecurityManager    *InternetSecurityManager;
            LPWSTR  lpwszURL = NULL;
            DWORD   dwSize;
            hr = pcicsm(NULL, &InternetSecurityManager, NULL);
            if (SUCCEEDED(hr))
            {
                dwSize = sizeof(dwPolicy);
                lpwszURL = MakeWideStrFromAnsi(lpszURL, STR_OLESTR);
                hr = InternetSecurityManager->ProcessUrlAction(lpwszURL,
                                                                URLACTION_DOWNLOAD_SIGNED_ACTIVEX,
                                                               (BYTE*)&dwPolicy, dwSize, NULL, NULL, PUAF_NOUI, NULL);
                wsprintf(szLogBuf, "InternetSecurityManager->ProcessUrlAction on :%s: Policy :%ld:", lpszURL, dwPolicy);
                MessageBox(NULL, szLogBuf, "TEST", MB_OK| MB_SETFOREGROUND);
                if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                {
                    hr = InternetSecurityManager->ProcessUrlAction(lpwszURL,
                                                                    URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX,
                                                                   (BYTE*)&dwPolicy, dwSize, NULL, NULL, PUAF_NOUI, NULL);
                    wsprintf(szLogBuf, "InternetSecurityManager->ProcessUrlAction on :%s: Policy :%ld:", lpszURL, dwPolicy);
                    MessageBox(NULL, szLogBuf, "TEST", MB_OK| MB_SETFOREGROUND);
                }
                if (lpwszURL)
                    CoTaskMemFree(lpwszURL);
                InternetSecurityManager->Release();
            }
        }
        FreeLibrary(hUrlmon);
    }
    return dwPolicy;
}
#endif

BOOL PathIsFileSpec(LPCSTR lpszPath)
{
    for (; *lpszPath; lpszPath = CharNext(lpszPath)) {
        if (*lpszPath == '\\' || *lpszPath == ':')
            return FALSE;
    }
    return TRUE;
}

const char c_gszRegstrPathIExplore[] = REGSTR_PATH_APPPATHS "\\iexplore.exe";

HRESULT GetIEPath(LPSTR pszPath, DWORD dwSize)
{
   HRESULT hr = NOERROR;
   UINT i;
   DWORD dwType;
   HKEY hKey;

   // findout where ie is, append on cif name
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_gszRegstrPathIExplore, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
   {
      if ((RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)pszPath, &dwSize) == ERROR_SUCCESS) &&
           (dwType == REG_SZ))
      {
         GetParentDir(pszPath);
      }
      else
         hr = E_INVALIDARG;

      RegCloseKey(hKey);
   }
   else
      hr = E_FAIL;

   return hr;
}

DWORD MyGetFileSize(LPCSTR pszFilename)
{
    DWORD dwSize;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    dwSize = 0;
    hFindFile = FindFirstFile( pszFilename, &fileData );

    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        if (fileData.nFileSizeHigh == 0)
            dwSize = fileData.nFileSizeLow;
        else
            dwSize = (DWORD)-1;
        FindClose( hFindFile  );
    }
    return dwSize;
}

WORD GetNTProcessorArchitecture(void)
{
    static WORD wNTProcArch = -1 ;
    SYSTEM_INFO System_info;

    // If we have calculated this before just pass that back.
    // else find it now.
    //
    if (wNTProcArch == (WORD)-1)
    {
        GetSystemInfo(&System_info);
        wNTProcArch = System_info.wProcessorArchitecture;
    }

    return wNTProcArch;
}

DWORD GetCurrentPlatform()
{
   static DWORD dwPlatform = 0xffffffff;

   if(dwPlatform != 0xffffffff)
      return dwPlatform;

   OSVERSIONINFO VerInfo;

   VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx(&VerInfo);

   if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
   {
      // Running NT
      if (GetNTProcessorArchitecture() == PROCESSOR_ARCHITECTURE_ALPHA)
      {
         dwPlatform = PLATFORM_NT5ALPHA;
         if (VerInfo.dwMajorVersion == 4)
            dwPlatform = PLATFORM_NT4ALPHA;
      }
      else
      {
         dwPlatform = PLATFORM_NT5;
         if (VerInfo.dwMajorVersion == 4)
            dwPlatform = PLATFORM_NT4;
      }
   }
   else
   {         // Running Windows 9x
      dwPlatform = PLATFORM_WIN98;
      if (VerInfo.dwMinorVersion == 0)
         dwPlatform = PLATFORM_WIN95;
      else if (VerInfo.dwMinorVersion == 90)
        dwPlatform = PLATFORM_MILLEN;
   }
   return dwPlatform;
}

BOOL FNeedGrpConv()
{
   char szSetupIni[MAX_PATH];

   if(GetWindowsDirectory(szSetupIni, sizeof(szSetupIni)))
   {
      AddPath(szSetupIni, "setup.ini");
      return(GetFileAttributes(szSetupIni) != 0xffffffff);
   }

   return FALSE;
}

void CopyCifString(LPCSTR pcszSect, LPCSTR pcszKey, LPCSTR pcszCifSrc, LPCSTR pcszCifDest)
{
    char szField[MAX_PATH];
    char szString[MAX_PATH];
    LPSTR pszPercent;

    if (GetPrivateProfileString(pcszSect, pcszKey, "", szField, sizeof(szField), pcszCifSrc)
        && (szField[0] == '%'))
    {
        pszPercent = ANSIStrChr(&szField[1], '%');
        if (pszPercent)
        {
            *pszPercent = '\0';
            GetPrivateProfileString("Strings", &szField[1], "", szString, sizeof(szString), pcszCifSrc);
            WritePrivateProfileString("Strings", &szField[1], szString, pcszCifDest);
        }
    }
}

//---------------------------------------------------------
// Function to log the Date/Time stamp for each Component.
//---------------------------------------------------------
void GetTimeDateStamp(LPSTR lpLogBuf)
{
    SYSTEMTIME  SystemTime;

    GetLocalTime(&SystemTime);
    wsprintf(lpLogBuf, "Date:%d/%d/%d (M/D/Y) Time:%d:%d:%d",
                SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
	
}


HRESULT WINAPI DownloadFile(LPCSTR szURL, LPCSTR szFilename, HWND hwnd, BOOL bCheckTrust, BOOL bShowBadUI)
{
    HRESULT hr;
    char szTempfile[MAX_PATH];
    char szTemp[MAX_PATH];

    CDownloader *pDL = new CDownloader();
    
    if(!pDL)
        return E_OUTOFMEMORY;
    
    hr = pDL->SetupDownload(szURL, NULL, 0, NULL);
    szTempfile[0] = 0;
    if(SUCCEEDED(hr))
    {
        hr = pDL->DoDownload(szTempfile, sizeof(szTempfile));
    }
    
    pDL->Release();
    
    if(SUCCEEDED(hr))
    {
        if (bCheckTrust)
        {
            hr = ::CheckTrustEx(szURL, szTempfile, bShowBadUI?hwnd:(HWND)INVALID_HANDLE_VALUE, bShowBadUI, NULL);
        }

        if(!CopyFile(szTempfile, szFilename, FALSE))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if(szTempfile[0] != 0)
    {
        GetParentDir(szTempfile);
        CleanUpTempDir(szTempfile);
    }
    return hr;
}


BOOL IsPatchableINF(LPTSTR pszInf)
{
    TCHAR szBuf[MAX_PATH];

    if (GetPrivateProfileInt("DefaultInstall", "Patching", 0, pszInf) ||
        GetPrivateProfileString("DownloadFileSection", NULL, "", szBuf, sizeof(szBuf), pszInf))
        return TRUE;
    else
        return FALSE;
}




PFNGETFILELIST g_pfnGetFileList                     = NULL;
PFNDOWNLOADANDPATCHFILES g_pfnDownloadAndPatchFiles = NULL;
PFNPROCESSFILESECTION g_pfnProcessFileSection       = NULL;

BOOL InitSRLiteLibs()
{
    HINSTANCE hAdvpext = LoadLibrary(c_gszAdvpext);

    if (hAdvpext == NULL)
        return FALSE;
    g_pfnGetFileList           = (PFNGETFILELIST) GetProcAddress(hAdvpext, "GetFileList");
    g_pfnDownloadAndPatchFiles = (PFNDOWNLOADANDPATCHFILES) GetProcAddress(hAdvpext, "DownloadAndPatchFiles");
    g_pfnProcessFileSection    = (PFNPROCESSFILESECTION) GetProcAddress(hAdvpext, "ProcessFileSection");

    if (g_pfnGetFileList == NULL ||
        g_pfnDownloadAndPatchFiles == NULL ||
        g_pfnProcessFileSection == NULL
       )
    {
        FreeLibrary(hAdvpext);
        return FALSE;
    }
    else
        return TRUE;
}

void FreeSRLiteLibs()
{
    HMODULE hMod;

    hMod = GetModuleHandle(c_gszAdvpext);
    if (hMod)
        FreeLibrary(hMod);
}

// For now, we're patching on any IE5 version, so we might
// as well perform a check similar to ie5wzd
BOOL IsPatchableIEVersion()
{
    char szIE[MAX_PATH] = { 0 };
    DWORD   dwMSVer, dwLSVer;

    GetSystemDirectory(szIE, sizeof(szIE));
    AddPath(szIE, "shdocvw.dll");
    GetVersionFromFile(szIE, &dwMSVer, &dwLSVer, TRUE);

    return (dwMSVer >= 0x00060000);
}

BOOL IsCorrectAdvpExt()
{
    DWORD   dwMSVer, dwLSVer;

    GetVersionFromFile(c_gszAdvpext, &dwMSVer, &dwLSVer, TRUE);

    return (dwMSVer >= 0x00050032);
}

BOOL CheckImageHlp_dll()
{
    char szFile[MAX_PATH] = { 0 };
    DWORD   dwMSVer, dwLSVer;

    GetSystemDirectory(szFile, sizeof(szFile));
    AddPath(szFile, "imagehlp.dll");
    GetVersionFromFile(szFile, &dwMSVer, &dwLSVer, TRUE);

    return (!(dwMSVer == 0x00040000) || !(dwLSVer == 0x04C90001));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\migrate.cpp ===
// This is the migration dll for NT5 upgrades.
// As per the Migration Extension Interface of NT5 Setup, this DLL needs to
// implement the folowing six functions:
//        QueryVersion
//        Initialize9x
//         MigrateUser9x     (called once for every user)
//        MigrateSystem9x
//        InitializeNT
//        MigrateUserNT     (called once for every user)
//        MigrateSystemNT
//
// Written : ShabbirS (5/7/99)
// Revision:
//


#include "pch.h"
#include <ole2.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <excppkg.h>
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "sdsutils.h"
#include "advpub.h"
#include "migrate.h"
#include "utils.h"
#include "resource.h"

// Constants:
#define CP_USASCII            1252
#define END_OF_CODEPAGES    -1

// Globals that are passed back to Setup.
//////////////////////////////////////////
// Vendor Info:
VENDORINFO g_VendorInfo = { "Microsoft Corporation", 
                            " ", 
                            "http://www.microsoft.com/support",
                            "Please contact Microsoft Technical Support for assistance with this problem.  "};

// Product ID:
char g_cszProductID[] = "Microsoft Internet Explorer";

// Version number of this Migration Dll
UINT g_uVersion = 3;

// Array of integers specifying the CodePages we use. (Terminated with -1)
int  g_rCodePages[] = {CP_USASCII, END_OF_CODEPAGES};

// Multi-SZ ie double Null terminated list of strings.
char  *g_lpNameBuf = NULL;
DWORD  g_dwNameBufSize = 0;
char  *g_lpWorkingDir = NULL;
char  *g_lpSourceDirs = NULL;
char  *g_lpMediaDir = NULL;

char g_szMigrateInf[MAX_PATH];
char g_szPrivateInf[MAX_PATH];

LONG
CALLBACK
QueryVersion(   OUT LPCSTR *ProductID,
                OUT LPUINT DllVersion,
                OUT LPINT  *CodePageArray, OPTIONAL
                OUT LPCSTR *ExeNameBuf,    OPTIONAL
                OUT PVENDORINFO *VendorInfo
            )
{
    // NOTE: There is timing restriction on the return from this function
    //       So keep this as short and sweet as possible.
    VENDORINFO myVendorInfo;
    LONG lRet = ERROR_SUCCESS;

    AppendString(&g_lpNameBuf, &g_dwNameBufSize, cszRATINGSFILE);
    AppendString(&g_lpNameBuf, &g_dwNameBufSize, cszIEXPLOREFILE);

    // Pass back to Setup the product name.
    *ProductID = g_cszProductID;

    // Pass back to Setup the version number of this DLL.
    *DllVersion = g_uVersion;

    // We will use English messages only but don't specify a code page or 
    // the migration dll won't run on alternate code pages.
    *CodePageArray = NULL;

    // Pass back to Setup the list of files we want detected on this system.
    *ExeNameBuf = g_lpNameBuf;

    // Pass back the VendorInfo.
    if (LoadString(g_hInstance, IDS_COMPANY, myVendorInfo.CompanyName, sizeof(myVendorInfo.CompanyName)) == 0)
        lstrcpy(myVendorInfo.CompanyName, "Microsoft Corporation");

    if (LoadString(g_hInstance, IDS_SUPPORTNUMBER, myVendorInfo.SupportNumber, sizeof(myVendorInfo.SupportNumber)) == 0)
        lstrcpy(myVendorInfo.SupportNumber, " ");

    if (LoadString(g_hInstance, IDS_SUPPORTURL, myVendorInfo.SupportUrl, sizeof(myVendorInfo.SupportUrl)) == 0)
        lstrcpy(myVendorInfo.SupportUrl, "http://www.microsoft.com/support");

    if (LoadString(g_hInstance, IDS_INSTRUCTIONS, myVendorInfo.InstructionsToUser, sizeof(myVendorInfo.InstructionsToUser)) == 0)
        lstrcpy(myVendorInfo.InstructionsToUser, "Please contact Microsoft Technical Support for assistance with this problem.  ");

    *VendorInfo = &myVendorInfo;

#ifdef DEBUG
    char szDebugMsg[MAX_PATH*3];
    wsprintf(szDebugMsg,"IE6:ProductID: %s \r\n", *ProductID);
    SetupLogError(szDebugMsg, LogSevInformation);
#endif

    return lRet;

}

LONG
CALLBACK
Initialize9x(   IN    LPCSTR WorkingDir,
                IN    LPCSTR SourceDirs,
                IN    LPCSTR MediaDirs
            )
{
    // Called by NT Setup if QUeryVersion returned SUCCESS
    // At this point we have been relocated to some specific location
    // on the local drive by the Setup process.

    INT    len;

    // Keep track of our new location (ie. the Working Directory).
    // NT Setup will create the "MIGRATE.INF" file in this dir and use that
    // to exchange info with us.
    // Also we can use this Dir for saving our private stuff. NT Setup will 
    // ensure this folder stays till end of NT Migration. After that it will
    // be cleaned.
    len = lstrlen(WorkingDir) + 1;
    g_lpWorkingDir = (char *) LocalAlloc(LPTR,sizeof(char)*len);

    if (!g_lpWorkingDir)
    {
        return GetLastError();
    }

    CopyMemory(g_lpWorkingDir, WorkingDir, len);


    len = lstrlen(MediaDirs) + 1;
    g_lpMediaDir = (char *) LocalAlloc(LPTR,sizeof(char)*len);

    if (!g_lpMediaDir)
    {
        return GetLastError();
    }

    CopyMemory(g_lpMediaDir, MediaDirs, len);

    // Also keep track of the NT installation files path (ie Sources Dir).
    // NOTE: Right now we don't need it, so skip doing it.

    // Generate the path names to Migrate.inf and the private files
    // (private.inf) that we need
    GenerateFilePaths();
    
    // If NT Setup has succeeded in getting path to Ratings.Pol, it implies
    // Ratings information exists. Enable our private marker to do the right
    // thing in MigrateSystemNT phase.
    if (GetRatingsPathFromMigInf(NULL))
    {    // Put a marker in PRIVATE.INF so that MigrateSystemNT phase knows 
        // that it has to munge the Rating.

        // Private.Inf does not exist at this point so why this check!!!
        // if (GetFileAttributes(g_szPrivateInf) != 0xffffffff)
        WritePrivateProfileString(cszIEPRIVATE, cszRATINGS, "Yes", g_szPrivateInf);
        // Flush the cached entries to disk.
        WritePrivateProfileString(NULL,NULL,NULL,g_szPrivateInf);

#ifdef DEBUG
    SetupLogError("IE6: Created PRIVATE.INF\r\n", LogSevInformation);
#endif
    }

    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x(  IN HWND      ParentWnd,
                IN LPCSTR    UnattendFile,
                IN HKEY      UserRegKey,
                IN LPCSTR    UserName,
                   LPVOID    Reserved
            )
{
    // This function is called by NT Setup for each user.
    // Currently for the Ratings scenario, we don't need any PerUser action.
#ifdef DEBUG
    SetupLogError("IE6: Skipping MigrateUser9x \r\n", LogSevInformation);
#endif
    return ERROR_SUCCESS;

}


LONG
CALLBACK
MigrateSystem9x(    IN HWND      ParentWnd,
                    IN LPCSTR    AnswerFile,
                    LPVOID       Reserved
                )
{
    // This function is called once by NT Setup to let us save System wide info.
    //
    // we are writing the "incompatibility report here if IE5.5 is installed and 
    // the user does not have the full migration pack installed.
    //

    char    szCab[MAX_PATH];
    WORD  wVer[4];
    char szBuf[MAX_PATH];

    // Check if we have the full exception pack which re-installs IE5.5

    // NOTE: g_lpMediaDir is the location where the migration dll was installed/registered
    // This is the same location where the INF is.
    lstrcpy(szCab, g_lpMediaDir);
    AddPath(szCab, "ieexinst.inf");
    if (GetPrivateProfileString("Info", "Version", "", szBuf , MAX_PATH, szCab) != 0) 
    {
        // Convert version
        ConvertVersionString( szBuf, wVer, '.' );

        if ((wVer[0] == 5) && (wVer[1] == 50))
        {
            // We don't have the full exception pack.
            // generate the "incompatibility report"
            // g_szMigrateInf
            lstrcpy(szBuf, g_lpMediaDir);
            GetParentDir(szBuf);

            if (LoadString(g_hInstance, IDS_INCOMPAT_MSG, szCab, sizeof(szCab)))
            {
                WritePrivateProfileString(cszMIGINF_INCOMPAT_MSG, g_cszProductID, szCab, g_szMigrateInf);
                WritePrivateProfileString(g_cszProductID, szBuf, "Report", g_szMigrateInf);
                WritePrivateProfileString(NULL,NULL,NULL,g_szMigrateInf);
            }
        }
    }

    WritePrivateProfileString(cszMIGINF_HANDLED, "HKLM\\Software\\Microsoft\\Active Setup\\ClsidFeature", "Registry", g_szMigrateInf);
    WritePrivateProfileString(cszMIGINF_HANDLED, "HKLM\\Software\\Microsoft\\Active Setup\\FeatureComponentID", "Registry", g_szMigrateInf);
    WritePrivateProfileString(cszMIGINF_HANDLED, "HKLM\\Software\\Microsoft\\Active Setup\\MimeFeature", "Registry", g_szMigrateInf);
    WritePrivateProfileString(NULL,NULL,NULL,g_szMigrateInf);
#ifdef DEBUG
    SetupLogError("IE6: MigrateSystem9x \r\n", LogSevInformation);
#endif
    
    return ERROR_SUCCESS;
}



LONG
CALLBACK 
InitializeNT (
    IN      LPCWSTR WorkingDirectory,
    IN      LPCWSTR SourceDirectories,
            LPVOID  Reserved
    )
{
    INT Length;
    LPCWSTR p;

    //
    // Save our working directory and source directory.  We
    // convert UNICODE to ANSI, and we use the system code page.
    //

    //
    // Compute length of source directories
    //

    p = SourceDirectories;
    while (*p) {
        p = wcschr (p, 0) + 1;
    }
    p++;
    Length = (p - SourceDirectories) / sizeof (WCHAR);

    //
    // Convert the directories from UNICODE to DBCS.  This DLL is
    // compiled in ANSI.
    //

    g_lpWorkingDir = (LPSTR) LocalAlloc(LPTR, MAX_PATH);
    if (!g_lpWorkingDir) {
        return GetLastError();
    }

    WideCharToMultiByte (
        CP_ACP, 
        0, 
        WorkingDirectory, 
        -1,
        g_lpWorkingDir,
        MAX_PATH,
        NULL,
        NULL
        );

    //  Also save the SourceDirectories that points to the Windows
    //  NT media (i.e. e:\i386) and optional directories specified on
    //  the WINNT32 command line. Not used currently, so skip.

    // Now generate the derived file names
    GenerateFilePaths();

#ifdef DEBUG
    SetupLogError("IE6: Done InitializeNT \r\n", LogSevInformation);
#endif

    return ERROR_SUCCESS;
}

LONG
CALLBACK 
MigrateUserNT (
    IN      HINF UnattendInfHandle,
    IN      HKEY UserRegKey,
    IN      LPCWSTR UserName,
            LPVOID Reserved
    )
{
    // No per-user settings for Ratings upgrade.
#ifdef DEBUG
    SetupLogError("IE6: Skipping MigrateUserNT \r\n", LogSevInformation);
#endif
    
    return ERROR_SUCCESS;
}


#define PACKAGE_GUID       "{89820200-ECBD-11cf-8B85-00AA005B4383}"
#define PACKAGE_DIRECTORY    "%windir%\\RegisteredPackages\\"


LONG
CALLBACK 
MigrateSystemNT (
    IN      HINF UnattendInfHandle,
            LPVOID Reserved
    )
{    // NOTE: This phase MUST finish in 60 seconds or will be terminated.
    
    // Check if our PRIVATE.INF exists and perform relevant actions based on its contents.
    CHAR szBuffer[3+10];

    if (GetFileAttributes(g_szPrivateInf) != 0xffffffff)
    {
        GetPrivateProfileString(cszIEPRIVATE, cszRATINGS, "", szBuffer, sizeof(szBuffer), g_szPrivateInf);
        if (lstrcmpi(szBuffer,"Yes")==0)
        {
            UpgradeRatings();
            SetupLogError("IE Migration: Upgraded Ratings info.\r\n", LogSevInformation);
        }
    }
    else
    {
        SetupLogError("IE Migration: No Rating migration. Private.Inf does not exist.\r\n",LogSevInformation);
    }

#if 0
    // Do the W2K IE5.5 migration work here.
    // 1. Copy all files from the IE location to the registered migration pack location
    // 2. Register the migration pack
    SETUP_OS_COMPONENT_DATA ComponentData,cd;
    SETUP_OS_EXCEPTION_DATA ExceptionData,ed;
    GUID MyGuid;
    PWSTR GuidString;
    PSTR  t;
    BOOL  bContinue = FALSE;
    WCHAR szMsg[1024];
    char  szPath[MAX_PATH];
    LPWSTR pszwPath;
    WORD  wVer[4];
    char szBuf[MAX_PATH];
    char szInf[MAX_PATH];
    char szGUID[MAX_PATH];
    char szCab[MAX_PATH];
    char szDir[MAX_PATH];
#ifdef DEBUG
    char sz[1024];
#endif
    HRESULT hr;

    char szCabs[1024];
    LPSTR pCab = NULL;

    // Get the INF which is installed in the W2K folder.
    // This INF tells us the info about the IE exception pack.
    // g_lpWorkingDir contains all fiels and sub folders which are in the same place 
    // as the registerd migration dll. Since we install the files in the same folder, we can use it.
    lstrcpy(szInf, g_lpWorkingDir);
    AddPath(szInf, "ieexinst.inf");
#ifdef DEBUG
    wsprintf(sz, "IE exception INF :%s:\r\n", szInf);
    SetupLogError(sz,LogSevInformation);
#endif
    if (GetFileAttributes(szInf) != (DWORD)-1)
    {
        // Get the GUID
        if (GetPrivateProfileString("Info", "ComponentId", "", szGUID, sizeof(szGUID), szInf) == 0)
            lstrcpy(szGUID, PACKAGE_GUID);
        
        ExpandEnvironmentStrings( PACKAGE_DIRECTORY, szDir, sizeof(szDir));
        if (GetFileAttributes(szDir) == (DWORD)-1)
            CreateDirectory( szDir, NULL );
        AddPath(szDir, szGUID);
        if (GetFileAttributes(szDir) == (DWORD)-1)
            CreateDirectory( szDir, NULL );
        
        // BUGBUG:
        // The extraction of the CAB file(s) should be done after we found out
        // If the user has already a newer exception pack registered.
        // This check is done below. Could not change it anymore, because of
        // time constrains. Found this in the code review
        //
        // Extract all CABs into the package fodler.
#ifdef DEBUG
        wsprintf(sz, "cab folder :%s:\r\n", g_lpWorkingDir);
        SetupLogError(sz,LogSevInformation);
        wsprintf(sz, "extract folder :%s:\r\n", szDir);
        SetupLogError(sz,LogSevInformation);
#endif
        if (GetPrivateProfileSection("Cab.List", szCabs, sizeof(szCabs), szInf) != 0)
        {
            pCab = szCabs;
            while (*pCab != '\0')
            {
                lstrcpy(szCab, g_lpWorkingDir);
                AddPath(szCab, pCab);
#ifdef DEBUG
                wsprintf(sz, "Extract :%s: to :%s:\r\n", szCab, szDir);
                SetupLogError(sz,LogSevInformation);
#endif
                
                hr = ExtractFiles(szCab, szDir, 0, NULL, NULL, 0);
                pCab += (lstrlen(pCab) + 1);
            }
            bContinue = TRUE;
        }
    }

    if (bContinue)
    {
        if (GetPrivateProfileString("Info", "Version", "", szBuf , MAX_PATH, szInf) != 0) 
        {
            // Convert version
            ConvertVersionString( szBuf, wVer, '.' );

            ComponentData.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
            ExceptionData.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
            pszwPath = MakeWideStrFromAnsi(szGUID);
            if (pszwPath)
            {
                IIDFromString( pszwPath, &MyGuid);
                CoTaskMemFree(pszwPath);

                if (SetupQueryRegisteredOsComponent(
                                            &MyGuid,
                                            &ComponentData,
                                            &ExceptionData)) 
                {
                    if ((ComponentData.VersionMajor < wVer[0]) ||
                        ((ComponentData.VersionMajor == wVer[0]) && (ComponentData.VersionMinor <= wVer[1])) )
                    {
                        bContinue = SetupUnRegisterOsComponent(&MyGuid);
                        SetupLogError("IE6: SetupUnRegisterOsComponent.\r\n",LogSevInformation);
                    }
                    // BUGBUG: Missing the below else. Found in code review
                    // else
                    //     bContinue = FALSE;
                }
            }
            else
                bContinue = FALSE;
        }
        else
            bContinue = FALSE;
    }
    if (bContinue)
    {
        SetupLogError("IE6: Preparing SetupRegisterOsComponent.\r\n",LogSevInformation);
        ExpandEnvironmentStrings( PACKAGE_DIRECTORY, szPath, sizeof(szPath));
        AddPath( szPath, szGUID );

        ComponentData.VersionMajor = wVer[0];
        ComponentData.VersionMinor = wVer[1];
        RtlMoveMemory(&ComponentData.ComponentGuid, &MyGuid,sizeof(GUID));

        t = szPath + lstrlen(szPath);
        *t = '\0';
        GetPrivateProfileString("Info", "InfFile", "", szBuf, MAX_PATH, szInf);
        AddPath( szPath, szBuf);

        pszwPath = MakeWideStrFromAnsi(szPath);
        if (pszwPath)
        {
            wcscpy(ExceptionData.ExceptionInfName, pszwPath);
            CoTaskMemFree(pszwPath);
        }

        *t = '\0';
        GetPrivateProfileString("Info", "CatalogFile", "", szBuf, MAX_PATH, szInf);
        AddPath( szPath, szBuf);

        pszwPath = MakeWideStrFromAnsi(szPath);
        if (pszwPath)
        {
            wcscpy(ExceptionData.CatalogFileName, pszwPath);
            CoTaskMemFree(pszwPath);
        }

        LoadString(g_hInstance, IDS_FRIENDLYNAME, szPath, sizeof(szPath));
        pszwPath = MakeWideStrFromAnsi(szPath);
        if (pszwPath)
        {
            wcscpy(ComponentData.FriendlyName, pszwPath);
            CoTaskMemFree(pszwPath);
        }

        wsprintfW(szMsg, L"IE6: ExceptionData\r\n\tInf: %ws\r\n\tCatalog: %ws\r\n",
                 ExceptionData.ExceptionInfName,ExceptionData.CatalogFileName);
        SetupLogErrorW(szMsg,LogSevInformation);

        if (SetupRegisterOsComponent(&ComponentData, &ExceptionData)) 
        {
            SetupLogError("IE6: SetupRegisterOsComponent succeeded.\r\n",LogSevInformation);
#ifdef DEBUG
            cd.SizeOfStruct = sizeof(SETUP_OS_COMPONENT_DATA);
            ed.SizeOfStruct = sizeof(SETUP_OS_EXCEPTION_DATA);
            if (SetupQueryRegisteredOsComponent( &MyGuid, &cd, &ed)) 
            {
                StringFromIID(cd.ComponentGuid, &GuidString);
                wsprintfW(szMsg, L"IE6: Component Data\r\n\tName: %ws\r\n\tGuid: %ws\r\n\tVersionMajor: %d\r\n\tVersionMinor: %d\r\n",
                         cd.FriendlyName,GuidString,cd.VersionMajor,cd.VersionMinor);
                SetupLogErrorW(szMsg,LogSevInformation);

                wsprintfW(szMsg, L"IE6: ExceptionData\r\n\tInf: %ws\r\n\tCatalog: %ws\r\n",
                         ed.ExceptionInfName,ed.CatalogFileName);
                SetupLogErrorW(szMsg,LogSevInformation);

                CoTaskMemFree( GuidString );
            }
#endif
        }
    }
    // In future, check for other settings here and perform necessary upgrade actions.
#endif
#ifdef DEBUG
    SetupLogError("IE6: Done MigrateSystemNT \r\n", LogSevInformation);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\pch.h ===
#include <windows.h>
#include <winbase.h>
#include <setupapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrate.rc
//
#define IDS_FRIENDLYNAME                1
#define IDS_INCOMPAT_MSG                2
#define IDS_COMPANY                     3
#define IDS_SUPPORTNUMBER               4
#define IDS_SUPPORTURL                  5
#define IDS_INSTRUCTIONS                6

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\migrate.h ===
#ifndef _IE_NT5_MIGRATION_MIGRATE_H_
#define _IE_NT5_MIGRATION_MIGRATE_H_


// Constants:
///////////////////////////
#define CP_USASCII            1252
#define END_OF_CODEPAGES    -1

#define REGKEY_RATING  "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"
#define cszRATINGSFILE "ratings.pol"
#define cszIEXPLOREFILE "iexplore.exe"

#define cszMIGRATEINF  "migrate.inf"
#define cszPRIVATEINF  "private.inf"

// MIGRATE.INF section names.
#define cszMIGINF_VERSION          "Version"
#define cszMIGINF_MIGRATION_PATHS  "Migration Paths"
#define cszMIGINF_EXCLUDED_PATHS   "Excluded Paths"
#define cszMIGINF_HANDLED          "Handled"
#define cszMIGINF_MOVED            "Moved"
#define cszMIGINF_INCOMPAT_MSG     "Incompatible Messages"
#define cszMIGINF_NTDISK_SPACE_REQ "NT Disk Space Requirements"

// PRIVATE.INF values:
#define cszIEPRIVATE             "IE Private"
#define cszRATINGS               "Ratings"

typedef struct _VendorInfo {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;


// Global variables:
///////////////////////////

extern HINSTANCE g_hInstance;
// Vendor Info:
extern VENDORINFO g_VendorInfo;

// Product ID:
extern char g_cszProductID[];

// Version number of this Migration Dll
extern UINT g_uVersion;

// Array of integers specifying the CodePages we use. (Terminated with -1)
extern int  g_rCodePages[];

// Multi-SZ ie double Null terminated list of strings.
extern char  *g_lpNameBuf;
extern DWORD  g_dwNameBufSize;
extern char  *g_lpWorkingDir;
extern char  *g_lpSourceDirs;

extern char g_szMigrateInf[];
extern char g_szPrivateInf[];

// Function Prototypes:
////////////////////////////

//BOOL NeedToMigrateIE();


#endif //_IE_NT5_MIGRATION_MIGRATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\utils.h ===
#ifndef _IE_NT5_MIGRATION_UTILS_H_
#define _IE_NT5_MIGRATION_UTILS_H_


// Function Prototypes :
//////////////////////////
BOOL  IsRatingsEnabled();
DWORD CountMultiStringBytes(LPCSTR lpString);
BOOL  AppendString(LPSTR *lpBuffer, DWORD *lpdwSize, LPCSTR lpStr);
void  GenerateFilePaths();
//BOOL  NeedToMigrateIE();
BOOL  GetRatingsPathFromMigInf( LPSTR *lpOutBuffer);

void  MoveRegBranch(HKEY hFrom, HKEY hTo);
BOOL  PathEndsInFile(LPSTR lpPath, LPCSTR szFile);
BOOL  UpgradeRatings();
DWORD GetFixedPath(LPSTR, DWORD, LPCSTR);  
LPWSTR MakeWideStrFromAnsi(LPSTR psz);

#endif //_IE_NT5_MIGRATION_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ntmigrat\utils.cpp ===
#include "pch.h"
#include <ole2.h>
#include "advpub.h"
#include "sdsutils.h"
#include "migrate.h"
#include "utils.h"


BOOL AppendString(LPSTR *lpBuffer, DWORD *lpdwSize, LPCSTR lpStr)
{
    DWORD cbBufferUsed = 0;
    DWORD dwNewSize = 0;
    LPSTR lpTmp = NULL;
    DWORD dwLen = 0;

    // Sanity check
    if (lpStr == NULL || *lpStr == '\0')
        return FALSE;
        
    if (*lpBuffer == NULL)
    {
        // Allocate the buffer.
        *lpdwSize = sizeof(char) * MAX_PATH;
        *lpBuffer = (char *) LocalAlloc(LPTR, *lpdwSize);
        if (*lpBuffer == NULL)
        {
#ifdef DEBUG
            SetupLogError("IE6: AppendString memory failure\r\n",LogSevInformation);
#endif
            return FALSE;
        }
    }

    dwNewSize = lstrlen(lpStr);

    // Get the number of bytes used up, excluding the second terminating NULL (-1)
    cbBufferUsed = CountMultiStringBytes((LPCSTR)*lpBuffer) - 1;

    if ( (*lpdwSize - cbBufferUsed) < (dwNewSize + 2))
    {
        LPSTR lpNewBuffer = NULL;
        DWORD dwTemp = 0;

        // Need to reallocate.
        dwTemp = *lpdwSize + (max((sizeof(char) * MAX_PATH), dwNewSize+2));
        lpNewBuffer = (char *) LocalAlloc(LPTR,dwTemp);

        if ( lpNewBuffer == NULL)
        {
#ifdef DEBUG
            SetupLogError("IE6: AppendString memory failure\r\n",LogSevInformation);
#endif
            return FALSE;
        }
        else
        {   
            // Rearrange the IN pointer to point to the new block.
            // Copy over the old info to the new allocated block.
            //    +1 for the one that we subtracted above.
            CopyMemory(lpNewBuffer, *lpBuffer, cbBufferUsed+1);

            // Free the old buffer.
            LocalFree(*lpBuffer);

            // Point to the new buffer.
            *lpBuffer = (char *) lpNewBuffer;
            *lpdwSize = dwTemp;
        }
    }

    // Append the new string now.
    lpTmp = *lpBuffer + cbBufferUsed;
    lstrcpy(lpTmp,lpStr);

    // Add the second terminating NULL to it now.
    lpTmp += (dwNewSize + 1);
    *lpTmp = '\0';

    return TRUE;
}

// NOTE NOTE: This function is called during the QueryVersion phase. Hence it needs to be small and fast
// So we just do the check for the presence of the "HKLM\S\M\W\CV\Policies\Ratings" key and don't try to 
// verify using MSRating API.

#define REGVAL_KEY   "Key"

BOOL IsRatingsEnabled()
{
    HKEY hKey;
    BOOL bRet = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,REGKEY_RATING,KEY_READ,NULL,&hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        if (RegQueryValueEx(hKey,REGVAL_KEY,NULL,&dwType, NULL, NULL) == ERROR_SUCCESS 
            && dwType == REG_BINARY)
        {
#ifdef DEBUG
            SetupLogError("IE6: Located RATINGS\Key", LogSevInformation);
#endif
            // The Ratings key exists and Password has been set. Means Ratings
            // is enabled.
            bRet = TRUE;
        }
        RegCloseKey(hKey);
    }

    return bRet;
}

// Returns the number of used bytes in a double NULL terminated string, including the two NULLS.
DWORD CountMultiStringBytes (LPCSTR lpString)
{
    DWORD cbBytes;
    LPSTR lpTmp;
    DWORD dwLen;
    
    // Sanity check
    if (lpString == NULL)
        return 0;

    // Get to the double \0 termination of lpBuffer
    lpTmp = (LPSTR)lpString;
    cbBytes = 1;
    while (lpTmp && *lpTmp != '\0')
    {
        dwLen = lstrlen(lpTmp) + 1;
        lpTmp = lpTmp + dwLen;
        cbBytes += dwLen;
    }

    return cbBytes;
}

BOOL PathEndsInFile(LPSTR lpPath, LPCSTR lpFile)
{
    LPSTR pTmp = lpPath;

    // Sanity check
    if (lpPath == NULL || lpFile == NULL)
        return FALSE;
 
#ifdef DEBUG
    char szDebug[MAX_PATH*3];
    wsprintf(szDebug,"IE5 (PathEndsInFile): %s :: %s \r\n", lpPath, lpFile);
    SetupLogError(szDebug,LogSevInformation);
#endif

    // Point pTmp to the terminating NULL
    pTmp = lpPath + lstrlen(lpPath);

    while (*pTmp != '\\' && pTmp != lpPath)
    {
        pTmp = CharPrev(lpPath, pTmp);
    }

    pTmp = CharNext(pTmp);

#ifdef DEBUG
    wsprintf(szDebug,"IE5 (PathEndsInFile): %s :: %s \r\n", pTmp, lpFile);
    SetupLogError(szDebug,LogSevInformation);
#endif

    return (lstrcmpi(pTmp, lpFile) == 0);
}
        

// Helper function to get the path for "Ratings.pol" from the MIGRATE.INF
// The path is returned in a buffer allocated by the function.
// **********************************************************************
// *** NOTE *** : It is the caller function responsibilty to free memory.
// **********************************************************************
// Parameters:
//    lpOutBuffer: Ptr to variable to hold the new string allocated.
//    User can pass in NULL if only interested in existance of Ratings.pol
//    and not the actual path to it.
BOOL GetRatingsPathFromMigInf( LPSTR *lpOutBuffer)
{
    INFCONTEXT ic;
    HINF       hInf;
    BOOL       bFound = FALSE;
    LPSTR      lpBuf = NULL;
    DWORD      dwSize, dwNewSize;

    if (lpOutBuffer)
        *lpOutBuffer = NULL;

    dwSize = MAX_PATH;
    lpBuf = (char *) LocalAlloc(LPTR, sizeof(char)*dwSize);
    if (lpBuf == NULL)
        return FALSE;
                
    // Before calling the migration DLL, Setup sets the CurrentDirectory to
    // the directory assigned to that migration DLL. Hence can use this.
    //hInf = SetupOpenInfFile(cszMIGRATEINF, NULL, INF_STYLE_WIN4, NULL);
    hInf = SetupOpenInfFile(g_szMigrateInf, NULL, INF_STYLE_WIN4, NULL);
    if (hInf)
    {
#ifdef DEBUG
        SetupLogError("IE6: Opened Miginf.inf \r\n", LogSevInformation);
#endif
        if (SetupFindFirstLine(hInf,cszMIGINF_MIGRATION_PATHS,NULL,&ic))
        {
            do 
            {
                dwNewSize = 0;
                if( SetupGetLineTextA(&ic,hInf,NULL,NULL,lpBuf,dwSize,&dwNewSize) == 0 && dwNewSize > dwSize)
                {   // Need more buffer space
                    // Free the old buffer space.
                    LocalFree(lpBuf);

                    // Try and allocate a new buffer.
                    dwSize = dwNewSize;
                    lpBuf = (char *) LocalAlloc(LPTR, sizeof(char)*dwSize);

                    if (lpBuf == NULL)
                    {
                        // Memory Error - break out.
                        break;
                    }

                    if (!SetupGetLineTextA(&ic,hInf,NULL,NULL,lpBuf,dwSize,&dwNewSize))
                    {
                        // The bFound check below takes care of LocalFree(lpBuf);
#ifdef DEBUG
                        SetupLogError("IE6: Error doing SetupGetTextLineA \r\n", LogSevInformation);
#endif
                        break; // Failure can't help it.
                    }
                }

                // So managed to read out the line. Check if it contains .pol
                if (PathEndsInFile(lpBuf,cszRATINGSFILE))
                {
                    if (lpOutBuffer)
                    {
                        *lpOutBuffer = lpBuf;
                    }
                    else
                    {   // User is not interested in Path. Free the block.
                        LocalFree(lpBuf);
                    }
                    bFound = TRUE;
#ifdef DEBUG
                    SetupLogError("IE6: Found Ratings.Pol in Migrate.Inf \r\n", LogSevInformation);
#endif
                }
            }
            while (!bFound && SetupFindNextLine(&ic,&ic));

        }

        SetupCloseInfFile(hInf);
    }

    if (!bFound)
    {
        // Free the local buffer.
        LocalFree(lpBuf);
    }

    return bFound;
}
                

//******************************************************************************
// GenerateFilePaths:
// NOTE NOTE NOTE: The migration DLL remains loaded from the "Initialize9x" phase
// right till the end of the "MigrateSystem9x" phase. And again from "InitializeNT" phase
// right till the end of the "MigrateSystemNT" phase. Hence these paths are usable 
// through out.
//*******************************************************************************
void GenerateFilePaths()
{

    *g_szMigrateInf = '\0';
    *g_szPrivateInf = '\0';

    if (g_lpWorkingDir)
    {
    // generate the path to the Migrate.Inf file
        wsprintf(g_szMigrateInf, "%s\\%s", g_lpWorkingDir, cszMIGRATEINF);
#ifdef DEBUG
        char szDebug[MAX_PATH];
        wsprintf(szDebug,"IE6: g_szMigrateInf: %s \r\n",g_szMigrateInf);

        SetupLogError(szDebug,LogSevInformation);
#endif

    // generate the path to the Private.Inf file
        wsprintf(g_szPrivateInf, "%s\\%s", g_lpWorkingDir, cszPRIVATEINF);
#ifdef DEBUG
        wsprintf(szDebug,"IE6: g_szPrivateInf: %s \r\n",g_szPrivateInf);

        SetupLogError(szDebug,LogSevInformation);
#endif

    }
}

#define IE_KEY        "Software\\Microsoft\\Internet Explorer"
#define VERSION_KEY         "Version"

BOOL NeedToMigrateIE()
{
    BOOL bRet = FALSE;
    char szPath[MAX_PATH];
    DWORD   dwInstalledVer, dwInstalledBuild;

    // Currently, the only thing we are interested in are the Ratings settings.
    if (IsRatingsEnabled())
    {
        // Append the "ratings.pol" filename to the list of files needed.
        // NOTE: AppendString allocates memory for the 1st parameter. User
        // must remember to free it.
        bRet |= AppendString(&g_lpNameBuf, &g_dwNameBufSize, cszRATINGSFILE);
    }

    if (!bRet)
    {
        GetSystemDirectory(szPath, sizeof(szPath));
        AddPath(szPath, "shdocvw.dll");
        GetVersionFromFile(szPath, &dwInstalledVer, &dwInstalledBuild, TRUE);
        // are running with IE5.5 installed.
        bRet = (dwInstalledVer == 0x00050032);
    }
    // Can add other modules that need to be migrated over here.
    // use bRet |= (....) so that you don't stomp previous bRet settings.

    return bRet;
}

void MyDelRegTree(HKEY hRoot, LPSTR szSubKey)
{
    char szName[MAX_PATH];
    DWORD dwIndex;
    DWORD dwNameSize;
    HKEY  hKey;

    dwIndex = 0;
    dwNameSize = sizeof(szName);
    if (RegOpenKeyEx(hRoot, szSubKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        while (RegEnumKey(hKey, dwIndex, szName, dwNameSize) == ERROR_SUCCESS)
        {
            MyDelRegTree(hKey,szName);
    
            // dwIndex++;  DONT INCR. SINCE WE HAVE DELETED A SUBKEY.
            dwNameSize = sizeof(szName);
        }

        RegCloseKey(hKey);

        //Finally delete the named subkey supplied above.
        RegDeleteKey(hRoot, szSubKey);
    }

}



// Recursively Enum values and subkey and copy them over. And then
// delete all subkeys of the Source key.
void MoveRegBranch(HKEY hFromKey, HKEY hToKey)
{
    
    char szName[MAX_PATH];
    char szValue[MAX_PATH];
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwType;
    DWORD dwIndex;

    // Enumerate all the values here and copy them over to the right
    // location. 
    dwIndex = 0;
    dwNameSize = sizeof(szName);
    dwValueSize = sizeof(szValue);
    while (RegEnumValue(hFromKey,dwIndex, szName, &dwNameSize, NULL,
    &dwType, (LPBYTE)szValue, &dwValueSize) == ERROR_SUCCESS)
    {
        RegSetValueEx(hToKey,szName,0,dwType,(LPBYTE)szValue, dwValueSize);

        // Get ready for the next round.
        dwIndex++;
        dwNameSize = sizeof(szName);
        dwValueSize = sizeof(szValue);
    }

    // Next Enum all the subkeys under source and move them over.
    dwIndex = 0;
    dwNameSize = sizeof(szName);
    while (RegEnumKey(hFromKey, dwIndex, szName, dwNameSize) == ERROR_SUCCESS)
    {
        HKEY hFromSubKey = NULL;
        HKEY hToSubKey = NULL;

        // Open this SubKey that we enumerated.
        if (RegOpenKeyEx(hFromKey, szName, 0, KEY_ALL_ACCESS, &hFromSubKey) == ERROR_SUCCESS)
        {
            // Create the destination subkey.
            if (RegCreateKeyEx(hToKey, szName, 0, NULL,REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS, NULL, &hToSubKey, NULL) == ERROR_SUCCESS)
            {
                // Move the subkeys...
                MoveRegBranch(hFromSubKey, hToSubKey);
                RegCloseKey(hToSubKey);
            }
            RegCloseKey(hFromSubKey);
        }

        // Get ready for the next round
        dwIndex++;
        dwNameSize = sizeof(szName);
    }


    // Now Delete all the SubKeys. The above recursive call ensures that
    // the Subkeys are one-level deep and hence deletable.
    dwIndex = 0;
    dwNameSize = sizeof(szName);
    while (RegEnumKey(hFromKey, dwIndex, szName, dwNameSize) == ERROR_SUCCESS)
    {
        RegDeleteKey(hFromKey,szName);

        // dwIndex++;  DONT INCR. SINCE WE HAVE DELETED A SUBKEY.
        dwNameSize = sizeof(szName);
    }
}


#define REGKEY_DEFAULT  ".Default"
#define REGKEY_MIGRATE_HIVE "Software\\Microsoft\\Policies\\Users"
#define REGKEY_MIGRATE_PICSRULES "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings\\PICSRules"
#define REGKEY_RATING_PICSRULES "PICSRules"

BOOL UpgradeRatings()
{
    // Real Ratings locations...
    //     HKLM\S\M\W\CV\Policies\Ratings (called RATING)
    // Open HKLM\software\Microsoft\Policies\Users.. This is where NT Setup puts
    // the migrated Ratings HIVE.
    //  Users [FileNamex] gets copied to RATING [FileNamex] 
    //      NOTE: Need to take care of SYSTEM/SYSTEM32.
    //  Users\.Default branch gets moved to RATING
    //  Users\S\M\W\CV\Policies\Ratings\PICSRules branch gets moved to RATING.

    HKEY  hRealRatings = NULL;
    HKEY  hRealDefault = NULL;
    HKEY  hRealPicsRules = NULL;
    HKEY  hMigratedRoot = NULL;
    BOOL  bRet = FALSE;

    // Open the RegKey to the real location of Ratings.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_RATING, 0, KEY_ALL_ACCESS,
        &hRealRatings) != ERROR_SUCCESS)
        goto Done;
    // Open the RegKey to the real location of .Default
    if (RegCreateKeyEx(hRealRatings, REGKEY_DEFAULT, 0,
        NULL,REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRealDefault, NULL) != ERROR_SUCCESS)
        goto Done;
    // Open the RegKey to the real location of PICSRules
    if (RegCreateKeyEx(hRealRatings, REGKEY_RATING_PICSRULES, 0,
        NULL,REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRealPicsRules, NULL) != ERROR_SUCCESS)
        goto Done;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_MIGRATE_HIVE, 0, KEY_ALL_ACCESS, &hMigratedRoot) == ERROR_SUCCESS)
    {
        HKEY hMigrateSubKey = NULL;
        char szName[MAX_PATH];
        char szValue[MAX_PATH];
        DWORD dwNameSize;
        DWORD dwValueSize;
        DWORD dwType;
        char  szNewPath[MAX_PATH];
        DWORD dwNewPathSize;
        DWORD dwIndex;

        // Enumerate all the values here and copy them over to the right
        // location. Make sure to replace 'System' with 'System32'
        dwIndex = 0;
        dwNameSize = sizeof(szName);
        dwValueSize = sizeof(szValue);
        while (RegEnumValue(hMigratedRoot,dwIndex, szName, &dwNameSize, NULL,
        &dwType, (LPBYTE)szValue, &dwValueSize) == ERROR_SUCCESS)
        {
            // Munge the Value and replace 'System' with System32.
            // Return value includes the terminating NULL char, which is
            // need by the RegSetValueEx API.
            dwNewPathSize = GetFixedPath(szNewPath, MAX_PATH, szValue);

            // Set the correct Ratings setting.
            RegSetValueEx(hRealRatings,szName,0,dwType,(LPBYTE)szNewPath, dwNewPathSize);
            // Get ready for the next round.
            dwIndex++;
            dwNameSize = sizeof(szName);
            dwValueSize = sizeof(szValue);
        }

        // Now grab Users\.Default and move it to the right location.
        if (RegOpenKeyEx(hMigratedRoot, REGKEY_DEFAULT, 0, KEY_ALL_ACCESS, &hMigrateSubKey) == ERROR_SUCCESS)
        {
            MoveRegBranch(hMigrateSubKey,hRealDefault);
            RegCloseKey(hMigrateSubKey);
        }

        // Now grab Users\...\PICSRules and move it to the right location.
        if (RegOpenKeyEx(hMigratedRoot, REGKEY_MIGRATE_PICSRULES, 0, KEY_ALL_ACCESS, &hMigrateSubKey) == ERROR_SUCCESS)
        {
            MoveRegBranch(hMigrateSubKey,hRealPicsRules);
            RegCloseKey(hMigrateSubKey);
        }

        RegCloseKey(hMigratedRoot);

        bRet = TRUE;
    }

    // Now clean the Migrated Hive.
    MyDelRegTree(HKEY_LOCAL_MACHINE, REGKEY_MIGRATE_HIVE);

Done:
    if (hRealRatings)
        RegCloseKey(hRealRatings);
    if (hRealDefault)
        RegCloseKey(hRealDefault);
    if (hRealPicsRules)
        RegCloseKey(hRealPicsRules);

    return bRet;
}


// Returns the size of NewPath including the terminating NULL.
DWORD GetFixedPath(LPSTR lpBuf, DWORD dwSize, LPCSTR lpPath)
{
    char lpLocalCopy[MAX_PATH], szTemp[5];
    char chSave;
    DWORD dwCount = 0;
    LPSTR pTmp, pTmp2;

    if (lpBuf == NULL || lpPath == NULL)
        return 0;

    // Create a local copy to party on.
    lstrcpy(lpLocalCopy, lpPath);

    pTmp = lpLocalCopy;
    *lpBuf = '\0';

    while (*pTmp && dwCount < dwSize)
    {
        pTmp2 = pTmp;
        while(*pTmp2 && *pTmp2 != '\\')
            pTmp2 = CharNext(pTmp2);

        chSave = *pTmp2;
        *pTmp2 = '\0';

        if (lstrcmpi(pTmp,"system")==0)
        {
            dwCount += 8;
            if (dwSize <= dwCount)
            {    //Error
                *lpBuf = '\0';
                return 0;
            }
            lstrcat(lpBuf,"system32");
        }
        else
        {
            dwCount += lstrlen(pTmp);
            if (dwSize <= dwCount)
            {    // Error
                *lpBuf = '\0';
                return 0;
            }
            lstrcat(lpBuf,pTmp);
        }

        // Append the saved character to Output buffer also.
        wsprintf(szTemp,"%c",chSave);
        dwCount += lstrlen(szTemp);
        if (dwSize <= dwCount)
        {    // Error
            *lpBuf = '\0';
            return 0;
        }
        lstrcat(lpBuf, szTemp);

        *pTmp2 = chSave;
        pTmp = CharNext(pTmp2);
    }

    return dwCount;
}

LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) 
        return NULL;

    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\common\inc\excppkg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    excppkg.h

Abstract:

    Header file for migration of exception packages.

Author:

    Andrew Ritz (andrewr) 21-Oct-1999

Revision History:

    Andrew Ritz (andrewr) 21-Oct-1999 : Created It.

--*/


typedef struct _SETUP_OS_COMPONENT_DATA {
    DWORD SizeOfStruct;
    GUID  ComponentGuid;
    WCHAR FriendlyName[64];
    WORD  VersionMajor;
    WORD  VersionMinor;
    WORD  BuildNumber;
    WORD  QFENumber;
    DWORD Reserved[16];
} SETUP_OS_COMPONENT_DATA, *PSETUP_OS_COMPONENT_DATA;

typedef struct _SETUP_OS_EXCEPTION_DATA {
    DWORD SizeOfStruct;
    WCHAR ExceptionInfName[MAX_PATH];
    WCHAR CatalogFileName[MAX_PATH];
    DWORD Reserved[16];
} SETUP_OS_EXCEPTION_DATA, *PSETUP_OS_EXCEPTION_DATA;

BOOL
WINAPI
SetupRegisterOsComponent (
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    );

BOOL
WINAPI
SetupUnRegisterOsComponent (
    IN const LPGUID ComponentGuid
    );

typedef BOOL
(CALLBACK *PSETUPCOMPONENTCALLBACK) (
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    );

BOOL
WINAPI
SetupEnumerateRegisteredOsComponents(
    IN PSETUPCOMPONENTCALLBACK SetupOsComponentCallback,
    IN DWORD_PTR Context
    );

BOOL
WINAPI
SetupQueryRegisteredOsComponent(
    IN  LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    );

BOOL
WINAPI
SetupQueryRegisteredOsComponentsOrder(
     OUT PDWORD   ComponentCount,
     OUT LPGUID    ComponentList OPTIONAL
    );

BOOL
WINAPI
SetupSetRegisteredOsComponentsOrder(
     IN  DWORD    ComponentCount,
     IN  const LPGUID    ComponentList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\common.inc ===
#----- Definition of the common paths -----
!ifndef IEAK_PATH
IEAK_PATH = $(PROJECT_ROOT)\setup\ieak5
!endif

!ifndef IEAK_INC_PATH
IEAK_INC_PATH = $(IEAK_PATH)\inc
!endif

!ifndef IEAK_UTIL_PATH
IEAK_UTIL_PATH  = $(IEAK_PATH)\ieakutil
!endif
IEAK_UTIL_PATHA = $(IEAK_UTIL_PATH)\srca
IEAK_UTIL_PATHW = $(IEAK_UTIL_PATH)\srcw

!ifndef IEAK_UI_PATH
IEAK_UI_PATH = $(IEAK_PATH)\ieakui
!endif

!ifndef IEAK_ENG_PATH
IEAK_ENG_PATH = $(IEAK_PATH)\ieakeng
!endif

!ifndef IEAK_ADMPARSE_PATH
IEAK_ADMPARSE_PATH = $(IEAK_PATH)\parser
!endif

#----- Standard macros setup -----
TARGETPATH = $(_OBJ_DIR)
UMTYPE     = windows


#----- C/C++ compilation settings -----
# (pritobla) should define NASHVILLE so that the version number remains the same whether it's
# built under IE or NT environment
# NOTE: All the binaries that include common.inc will be compiled UNICODE !
C_DEFINES         = $(C_DEFINES) -D_WIN32_DCOM -DNASHVILLE
!ifndef NO_UNICODE
C_DEFINES         = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif
MSC_WARNING_LEVEL = -W4 -WX
COMPILER_WARNINGS = -FI$(IEAK_INC_PATH)\warning.h
USE_STATIC_ATL    = 1
ATL_VER           = 21

# (andrewgu) disable for now, since browser_info story is not clear in the source depot
# !if !$(FREEBUILD)
# BROWSER_INFO      = 1
# !endif


#   _____ Precompiled header settings _____
PRECOMPILED_CXX     = 1
PRECOMPILED_INCLUDE = precomp.h

#   _____ Include search paths _____
INCLUDES = \
    $(IEAK_INC_PATH);  \
    $(IEAK_UTIL_PATH); \
    $(IEAK_ENG_PATH);  \
    $(IEAK_UI_PATH);   \
    $(DS_INC_PATH);    \
    $(SHELL_INC_PATH)

CONDITIONAL_INCLUDES = \
    atlbase.h   \
    atlcom.h    \
    atlconv.h   \
    atlwin.h    \
    statreg.h   \
    statreg.cpp \
    atlimpl.cpp \
    atlsnap.h   \
    dlgs.h      \
    rpcerr.h    \
    rpcmac.h    \
    macname1.h  \
    macpub.h    \
    macapi.h    \
    macname2.h  \
    macwin32.h  \
    macodidl.h  \
    macocidl.h  \
    winwlm.h    \
    thunk.h

#----- Libraries -----
USE_NOLIBS = 1
USE_PDB    = 1

TARGETLIBS = \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SHELL_LIB_PATH)\shlwapip.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\apply.h ===
#ifndef _APPLY_H_
#define _APPLY_H_

BOOL ApplyClearBranding();
BOOL ApplyMigrateOldSettings();
BOOL ApplyWininetSetup();
BOOL ApplyConnectionSettingsDeletion();
BOOL ApplyZonesReset();
BOOL ApplyExtRegInfHKLM();
BOOL ApplyExtRegInfHKCU();
BOOL lcy50_ApplyExtRegInf();
BOOL ApplyCustomHelpVersion();
BOOL ApplyToolbarButtons();
BOOL ApplyRootCert();
BOOL ApplyFavoritesDeletion();
BOOL ApplyFavorites();
BOOL ApplyFavoritesOrdering();
BOOL ApplyQuickLinks();
BOOL ApplyQuickLinksOrdering();
BOOL ApplyConnectionSettings();
BOOL ApplyTrustedPublisherLockdown();
BOOL ApplyLinksDeletion();
BOOL ApplyBrowserRefresh();
BOOL lcy4x_ApplyActiveDesktop();
BOOL lcy4x_ApplyChannels();
BOOL lcy4x_ApplyWebcheck();
BOOL lcy4x_ApplyChannelBar();
BOOL lcy4x_ApplySubscriptions();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\apply.cpp ===
#include "precomp.h"
#include <rashelp.h>
#include "apply.h"

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0500
#include <userenv.h>

// REVIEW: (andrewgu) currently, some utility ProcessXXX apis
// (eg. ProcessActiveSetupSites) will execute unconditionally. i.e. there is no way to turn them
// off. what needs to be done is in respective ApplyXXX apis to check if there is need to perform
// this utility functionality and skip it if this service is not going to be needed.

BOOL ApplyClearBranding()
{
    TCHAR szValue[16];
    BOOL  fResult;

    // in autoconfig or GP context, shouldn't call the Clear function
    if (g_CtxIs(CTX_AUTOCONFIG | CTX_GP))
        return FALSE;

    // take care of MS IE4.x ins's which didn't have the NoClear flag set
    fResult = !InsGetBool(IS_BRANDING, IK_NOCLEAR, FALSE, g_GetIns());
    if (fResult) 
    {
        GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szValue, countof(szValue), g_GetIns());
        fResult = (0 != StrCmpI(szValue, TEXT("MICROSO")));
    }

    return fResult;
}

BOOL ApplyMigrateOldSettings()
{
    return (g_CtxIsCorp() || g_CtxIsIsp() || g_CtxIsIcp());
}

BOOL ApplyWininetSetup()
{
    if (g_CtxIs(CTX_MISC_PERUSERSTUB) || (g_CtxIsGp() && !g_CtxIs(CTX_MISC_CHILDPROCESS)))
        return ApplyConnectionSettings();

    return FALSE;
}

BOOL ApplyConnectionSettingsDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyConnectionSettingsDeletion)

    if (!InsGetBool(IS_CONNECTSET, IK_DELETECONN, FALSE, g_GetIns())) {
        Out(LI0(TEXT("Existing connection settings weren't specified to be deleted!")));
        return FALSE;
    }

    if (!RasIsInstalled()) {
        Out(LI0(TEXT("RAS support is not installed. There are no connection settings to delete!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyZonesReset()
{
    return g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_CHILDPROCESS);
}

BOOL ApplyExtRegInfHKLM()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyExtRegInfHKLM)

    if (InsIsSectionEmpty(IS_EXTREGINF_HKLM, g_GetIns())) {
        Out(LI0(TEXT("There are no local machine *.inf files to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyExtRegInfHKCU()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyExtRegInfHKCU)

    if (InsIsSectionEmpty(IS_EXTREGINF_HKCU, g_GetIns())) {
        Out(LI0(TEXT("There are no current user *.inf files to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy50_ApplyExtRegInf()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ApplyExtRegInf)

    if (ApplyExtRegInfHKLM() || ApplyExtRegInfHKCU() ||
        InsIsSectionEmpty(IS_EXTREGINF, g_GetIns())) {
        Out(LI0(TEXT("There are no legacy *.inf files to process!")));
        return FALSE;
    }

    ASSERT(!g_CtxIsGp());

    return TRUE;
}

BOOL ApplyCustomHelpVersion()
{
    if (!HasFlag(g_GetContext(), CTX_MISC_PERUSERSTUB))
        return FALSE;

    return ApplyClearBranding();
}

BOOL ApplyToolbarButtons()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyToolbarButtons)

    if (InsIsSectionEmpty(IS_BTOOLBARS, g_GetIns())) {
        Out(LI0(TEXT("There are no toolbar buttons to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyRootCert()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyRootCert)

    BOOL fResult;

    if (!HasFlag(g_GetContext(), CTX_ISP)) {
        Out(LI0(TEXT("This feature is for ISPs only!")));
        return FALSE;
    }

    fResult = !InsIsKeyEmpty(IS_ISPSECURITY, IK_ROOTCERT, g_GetIns());
    if (!fResult)
        Out(LI0(TEXT("No ISP Root Cert to add!")));

    return fResult;
}

BOOL ApplyFavoritesDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyFavoritesDeletion)

    DWORD dwFlags;

    dwFlags = InsGetInt(IS_BRANDING, IK_FAVORITES_DELETE, FD_DEFAULT, g_GetIns());
    if (!HasFlag(dwFlags, FD_FOLDERS)) {
        Out(LI0(TEXT("None of the favorites folders were specified to be deleted!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyFavorites()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyFavorites)

    TCHAR szKey[32];
    BOOL  fNewFormat;

    wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, 1);
    fNewFormat = !InsIsKeyEmpty(IS_FAVORITESEX, szKey, g_GetIns());
    if (!fNewFormat) {
        if (InsIsSectionEmpty(IS_FAVORITES, g_GetIns())) {
            Out(LI0(TEXT("There are no favorites to add!")));
            return FALSE;
        }
    }

    return TRUE;
}

BOOL ApplyFavoritesOrdering()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyFavoritesOrdering)

    if (!InsGetBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, g_GetIns())) {
        Out(LI0(TEXT("Favorites will be put into the default position!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyQuickLinks()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyQuickLinks)

    TCHAR szKey[32];

    wnsprintf(szKey, countof(szKey), IK_QUICKLINK_NAME, 1);
    if (InsIsKeyEmpty(IS_URL, szKey, g_GetIns())) {
        Out(LI0(TEXT("There are no quick links to add!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyQuickLinksOrdering()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyQuickLinksOrdering)

    if (!InsGetBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, g_GetIns())) {
        Out(LI0(TEXT("Quick Links will be put into the default position!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyConnectionSettings)

    if (!InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, g_GetIns()) &&
        !(InsKeyExists(IS_URL, IK_DETECTCONFIG, g_GetIns()) || InsKeyExists(IS_URL, IK_USEAUTOCONF, g_GetIns())) &&
        InsIsSectionEmpty(IS_PROXY, g_GetIns())) {
        Out(LI0(TEXT("There are no connection settings to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyTrustedPublisherLockdown()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyTrustedPublisherLockdown)

    // need to check both current location and legacy location here

    if ((S_OK != SHValueExists(HKEY_LOCAL_MACHINE, RK_POLICES_RESTRICTIONS, RV_TPL)) &&
        (!InsKeyExists(IS_SITECERTS, IK_TRUSTPUBLOCK, g_GetIns())))
    {
        Out(LI0(TEXT("This restriction is not set!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyLinksDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyLinksDeletion)

    if (!InsGetBool(IS_OUTLKEXP,    IK_DELETELINKS, FALSE, g_GetIns()) &&
        !InsGetBool(IS_DESKTOPOBJS, IK_DELETELINKS, FALSE, g_GetIns()))
    {
        Out(LI0(TEXT("No links to delete!")));
        return FALSE;
    }

    return TRUE;
}

BOOL ApplyBrowserRefresh()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ApplyBrowserRefresh)

    // do not do global refresh if this is running under the GP context at login time;
    // for child process, apply browser refresh is controlled via cmdline (child process never has GPO flags)

    if (g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_CHILDPROCESS) && !HasFlag(g_GetGPOFlags(), GPO_INFO_FLAG_BACKGROUND))
    {
        Out(LI0(TEXT("Skipping browser refresh at login time!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyActiveDesktop()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplyActiveDesktop)

    BOOL fEnable;

    fEnable = InsGetBool(IS_DESKTOPOBJS, IK_OPTION, FALSE, g_GetIns());
    if (!fEnable || IsOS(OS_NT5)) {
        if (!fEnable)
            Out(LI0(TEXT("No desktop customizations to process!")));
        else
            Out(LI0(TEXT("Skipping desktop customizations on Windows 2000!")));

        return FALSE;
    }

    if (!HasFlag(WhichPlatform(), PLATFORM_INTEGRATED)) {
        Out(LI0(TEXT("Nothing to apply without IE4 Desktop Update!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyChannels()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplyChannels)

    if (InsIsSectionEmpty(IS_CHANNEL_ADD, g_GetIns()) &&
        !InsGetBool(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, g_GetIns()))
    {
        Out(LI0(TEXT("There are no channels to process!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyWebcheck()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplyWebcheck)

    // NOTE: (pritobla) bail out if the infodelivery\modifications key doesn't exist. this is the
    // same logic that is used in ProcessInfodeliveryPolicies() in shell\ext\webcheck\admin.cpp
    // to quickly determine whether there are any channels to process or not.
    if (S_OK != SHKeyExists(g_GetHKCU(), RK_POLICES_MODIFICATIONS)) {
        Out(LI0(TEXT("There is no webcheck processing necessary!")));
        return FALSE;
    }

    return TRUE;
}

BOOL lcy4x_ApplyChannelBar()
{
    return InsGetBool(IS_DESKTOPOBJS, IK_SHOWCHLBAR, FALSE, g_GetIns());
}

BOOL lcy4x_ApplySubscriptions()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ApplySubscriptions)

    if (InsIsSectionEmpty(IS_SUBSCRIPTIONS, g_GetIns())) {
        Out(LI0(TEXT("There are no subscriptions to process!")));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brandad4.cpp ===
#include "precomp.h"
#include <winuserp.h>                           // for GetShellWindow API only

// Private forward decalarations
void    doWallpaperFix(HKEY hKeyDesktopNew);
BOOL    isHtmlFileByExt           (LPCTSTR pszFilename);
BOOL    isNormalWallpaperFileByExt(LPCTSTR pszFilename);
BOOL    getFileTimeByName(LPCTSTR pszFilename, LPFILETIME pft);
HRESULT pepDeleteFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);


HRESULT lcy4x_ProcessActiveDesktop()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessActiveDesktop)

    USES_CONVERSION;

    TCHAR     szWebPath[MAX_PATH], szWallpaperPath[MAX_PATH],
              szValue[MAX_PATH], szAux[MAX_PATH], szAux2[MAX_PATH],
              szInsKey[21];
    LPCTSTR   pszFilename;
    HKEY      hk;
    DWORD_PTR dwAux;
    DWORD     dwValue,
              dwResult;
    int       iNumFiles, iNumFiles2,
              i;
    BOOL      fAux;

    hk = NULL;

    //----- Initialization -----
    CreateWebFolder();
    GetWebPath (szWebPath, countof(szWebPath));
    PathCombine(szWallpaperPath, szWebPath, FOLDER_WALLPAPER);

    // turn on active desktop
    fAux = TRUE;
    SHGetSetActiveDesktop(TRUE, &fAux);

    //----- My Computer, Control Panel -----
    StrCpy(szAux, FILEPREFIX);
    StrCat(szAux, szWebPath);

    GetPrivateProfileString(IS_DESKTOPOBJS, IK_MYCPTRPATH,  TEXT(""), szValue, countof(szValue), g_GetIns());
    if (szValue[0] != TEXT('\0')) {
        StrCpy    (szAux2, szAux);
        PathAppend(szAux2, PathFindFileName(szValue));
        ASSERT(PathFileExists(szAux2));

        SHSetValue(HKEY_LOCAL_MACHINE, RK_MYCOMPUTER, RV_PERSISTMONIKER, REG_SZ, szAux2, (DWORD)StrCbFromSz(szAux2));
    }

    GetPrivateProfileString(IS_DESKTOPOBJS, IK_CPANELPATH,  TEXT(""), szValue, countof(szValue), g_GetIns());
    if (szValue[0] != TEXT('\0')) {
        StrCpy    (szAux2, szAux);
        PathAppend(szAux2, PathFindFileName(szValue));
        ASSERT(PathFileExists(szAux2));

        SHSetValue(HKEY_LOCAL_MACHINE, RK_CONTROLPANEL, RV_PERSISTMONIKER, REG_SZ, szAux2, (DWORD)StrCbFromSz(szAux2));
    }

    //----- Desktop component -----
    GetPrivateProfileString(IS_DESKTOPOBJS, IK_DTOPCOMPURL, TEXT(""), szValue, countof(szValue), g_GetIns());
    if (szValue[0] != TEXT('\0')) {
        IActiveDesktop *piad;
        HRESULT hr;

        fAux = InsGetBool(IS_DESKTOPOBJS, IK_DESKCOMPLOCAL, FALSE, g_GetIns());
        if (fAux) {
            PathCombine(szAux, szWebPath, PathFindFileName(szValue));
            ASSERT(PathFileExists(szAux));
        }
        else
            StrCpy(szAux, szValue);

        hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
            IID_IActiveDesktop, (LPVOID *)&piad);
        if (SUCCEEDED(hr)) {
            ASSERT(piad != NULL);

            piad->AddUrl(NULL, T2CW(szAux), NULL, ADDURL_SILENT);
            piad->ApplyChanges(AD_APPLY_SAVE | AD_APPLY_HTMLGEN);
            piad->Release();
        }
    }

    //----- Wierd stuff (wallpaper path and marking something as dirty) -----
    iNumFiles  = GetPrivateProfileInt(IS_WALLPAPER,       IK_NUMFILES, 0, g_GetIns());
    iNumFiles2 = GetPrivateProfileInt(IS_CUSTOMWALLPAPER, IK_NUMFILES, 0, g_GetIns());

    if (iNumFiles > 0 || iNumFiles2 > 0) {
        DWORD dwType, dwSize;

        // set default wallpaper path in registry
        // REVIEW: (andrewgu) two things really:
        // 1. i don't know if it was written this way or became the way it was over time. but this
        // was the most unefficient way to do anything i've ever seen. and also it was buggy;
        // 2. why the heck do we need to mack with this at all?
        dwResult = SHOpenKeyHKLM(RK_WINDOWS, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
        if (dwResult == ERROR_SUCCESS) {
            szAux[0] = TEXT('\0');
            dwSize   = sizeof(szAux);
            SHQueryValueEx(hk, RV_WALLPAPERDIR, NULL, NULL, (PBYTE)szAux, &dwSize);

            if (szAux[0] != TEXT('\0'))
                StrCpy(szWallpaperPath, szAux);

            else
                RegSetValueEx(hk, RV_WALLPAPERDIR, 0, REG_SZ, (PBYTE)szWallpaperPath, (DWORD)StrCbFromSz(szWallpaperPath));

            SHCloseKey(hk);
        }

        // who knows why this is needed
        dwResult = SHCreateKey(g_GetHKCU(), RK_DT_COMPONENTS, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
        if (dwResult == ERROR_SUCCESS) {
            dwValue = 0;
            dwSize  = sizeof(dwValue);
            RegQueryValueEx(hk, RV_GENERALFLAGS, NULL, &dwType, (LPBYTE)&dwValue, &dwSize);

            dwValue |= RD_DIRTY;
            RegSetValueEx(hk, RV_GENERALFLAGS, 0, dwType, (LPBYTE)&dwValue, dwSize);

            SHCloseKey(hk);
        }
    }

    //----- Wallpaper files -----
    szValue[0] = TEXT('\0');

    if (iNumFiles > 0) {
        wnsprintf(szInsKey, countof(szInsKey), FILE_TEXT, 0);
        GetPrivateProfileString(IS_WALLPAPER, szInsKey, TEXT(""), szValue, countof(szValue), g_GetIns());
    }

    if (szValue[0] != TEXT('\0')) {
        pszFilename = PathFindFileName(szValue);

        PathCombine(szAux,  szWebPath,       pszFilename);
        PathCombine(szAux2, szWallpaperPath, pszFilename);
        CopyFile   (szAux,  szAux2, FALSE);
        ASSERT(PathFileExists(szAux2));

        dwResult = SHCreateKey(g_GetHKCU(), RK_DT_GENERAL, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
        if (dwResult == ERROR_SUCCESS) {
            dwValue = GetPrivateProfileInt(IS_WALLPAPER, IK_COMPONENTPOS, 2, g_GetIns());
            RegSetValueEx(hk, RV_COMPONENTPOS, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

            if (isNormalWallpaperFileByExt(pszFilename)) {
                SHCloseKey(hk);

                dwResult = SHCreateKey(g_GetHKCU(), RK_CP_DESKTOP, KEY_SET_VALUE, &hk);
            }
            else
                doWallpaperFix(hk);
        }

        if (dwResult == ERROR_SUCCESS) {
            RegSetValueEx(hk, RV_WALLPAPER, 0, REG_SZ, (LPBYTE)szAux2, (DWORD)StrCbFromSz(szAux2));
            SHCloseKey(hk);
        }

        // BUGBUG: (pritobla) it would be faster if we just enumerated the HtmlImgs based on
        // iNumFiles and just copied them (see old code) instead of parsing thru the Html file
        // again.
        if (isHtmlFileByExt(pszFilename))
            CopyHtmlImgs(szAux, szWallpaperPath, NULL, NULL);
    }
    ASSERT(hk == NULL);

    //----- Custom wallpaper files -----
    szValue[0] = TEXT('\0');

    if (iNumFiles2 > 0) {
        wnsprintf(szInsKey, countof(szInsKey), FILE_TEXT, 0);
        GetPrivateProfileString(IS_CUSTOMWALLPAPER, szInsKey, TEXT(""), szValue, countof(szValue), g_GetIns());
    }

    if (szValue[0] != TEXT('\0')) {
        LPCTSTR pszRegKey;

        pszFilename = PathFindFileName(szValue);

        PathCombine(szAux,  szWebPath,       pszFilename);
        PathCombine(szAux2, szWallpaperPath, pszFilename);
        CopyFile   (szAux, szAux2, FALSE);
        ASSERT(PathFileExists(szAux2));

        fAux      = isNormalWallpaperFileByExt(pszFilename);
        pszRegKey = fAux ? RK_CP_DESKTOP : RK_DT_GENERAL;

        dwResult = SHCreateKey(g_GetHKCU(), pszRegKey, KEY_DEFAULT_ACCESS, &hk);
        if (dwResult == ERROR_SUCCESS) {
            if (!fAux)
                doWallpaperFix(hk);

            RegSetValueEx(hk, RV_WALLPAPER, 0, REG_SZ, (LPBYTE)szAux2, (DWORD)StrCbFromSz(szAux2));
            SHCloseKey(hk);
        }

        // BUGBUG: (pritobla) it would be faster if we just enumerated the HtmlImgs based on
        // iNumFiles2 and just copied them (see old code) instead of parsing thru the Html file
        // again.
        if (isHtmlFileByExt(pszFilename))
            CopyHtmlImgs(szAux, szWallpaperPath, NULL, NULL);
    }
    ASSERT(hk == NULL);

    //----- Quick Launch files -----
    iNumFiles = GetPrivateProfileInt(IS_QUICKLAUNCH, IK_NUMFILES, 0, g_GetIns());
    if (iNumFiles > 0) {
        TCHAR szQuickLaunchPath[MAX_PATH];

        //_____ Determine Quick Launch folder location _____
        StrCpy(szQuickLaunchPath, GetQuickLaunchPath());

        if (0 == LoadString(g_GetHinst(), IDS_IELNK, szAux, countof(szAux)))
            StrCpy(szAux, TEXT("Launch Internet Explorer Browser"));
        PathAddExtension(szAux, TEXT(".lnk"));

        //_____ Main processing _____
        // NOTE: (pritobla) make sure we don't delete existing IE link created by toolbar.inf if
        // we imported from server
        fAux = InsGetBool(IS_QUICKLAUNCH, IK_KEEPIELNK, FALSE, g_GetIns());
        PathEnumeratePath(szQuickLaunchPath, PEP_SCPE_NOFOLDERS | PEP_CTRL_ENUMPROCFIRST, pepDeleteFilesEnumProc,
            (LPARAM)(fAux ? szAux : NULL));

        for (i = 0; i < iNumFiles; i++) {
            wnsprintf(szInsKey, countof(szInsKey), FILE_TEXT, i);
            GetPrivateProfileString(IS_QUICKLAUNCH, szInsKey, TEXT(""), szValue, countof(szValue), g_GetIns());
            if (szValue[0] == TEXT('\0'))
                continue;

            pszFilename = PathFindFileName(szValue);

            PathCombine(szAux,  szWebPath,         pszFilename);
            PathCombine(szAux2, szQuickLaunchPath, pszFilename);
            CopyFile   (szAux,  szAux2, FALSE);
            ASSERT(PathFileExists(szAux2));
        }
    }

    // refresh desktop
    // NOTE: (pritobla) timeout value of 20 secs is not random; apparently, the shell guys have
    // recommended this value; so don't change it unless you know what you're doing :)
    if (IsOS(OS_NT))
        SendMessageTimeoutW(GetShellWindow(), WM_WININICHANGE, 0, (LPARAM)T2W(REFRESH_DESKTOP), SMTO_NORMAL | SMTO_ABORTIFHUNG, 20000, &dwAux);
    else
        SendMessageTimeoutA(GetShellWindow(), WM_WININICHANGE, 0, (LPARAM)T2A(REFRESH_DESKTOP), SMTO_NORMAL | SMTO_ABORTIFHUNG, 20000, &dwAux);

    return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

BOOL isHtmlFileByExt(LPCTSTR pszFilename)
{
    LPCTSTR pszExt;

    if (pszFilename == NULL || *pszFilename == TEXT('\0'))
        return TRUE;

    pszExt = PathFindExtension(pszFilename);
    return (0 == StrCmpI(pszExt, TEXT(".htm"))  ||
            0 == StrCmpI(pszExt, TEXT(".html")) ||
            0 == StrCmpI(pszExt, TEXT(".htt")));
}

BOOL isNormalWallpaperFileByExt(LPCTSTR pszFilename)
{
    LPCTSTR pszExt;

    if (pszFilename == NULL || *pszFilename == TEXT('\0'))
        return TRUE;

    pszExt = PathFindExtension(pszFilename);

    // check for specific files that can be shown only in ActiveDesktop mode
    // everything else (including *.bmp) are "normal" wallpapers
    return !(isHtmlFileByExt(pszFilename)        ||
             0 == StrCmpI(pszExt, TEXT(".gif"))  ||
             0 == StrCmpI(pszExt, TEXT(".jpg"))  ||
             0 == StrCmpI(pszExt, TEXT(".png")));
}

// NOTE: (a-saship) fix suggested by sankar for the wallpaper to be displayed. this function is
// only called for wallpaper files other than .bmp format.
void doWallpaperFix(HKEY hkNew)
{
    FILETIME ft;
    TCHAR    szTemp[MAX_PATH];
    HKEY     hkOld = NULL;
    DWORD    dwSize;

    if (hkNew == NULL)
        return;

    hkOld = NULL;
    SHOpenKey(g_GetHKCU(), RK_CP_DESKTOP, KEY_READ, &hkOld);
    if (hkOld == NULL)
        return;

    // copy TileWallpaper & WallpaperStyle to new location
    dwSize = sizeof(szTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hkOld, RV_TILEWALLPAPER, NULL, NULL, (LPBYTE)szTemp, &dwSize))
        RegSetValueEx(hkNew, RV_TILEWALLPAPER, 0, REG_SZ, (LPBYTE)szTemp, dwSize);

    dwSize = sizeof(szTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hkOld, RV_WALLPAPERSTYLE, NULL, NULL, (LPBYTE)szTemp, &dwSize))
        RegSetValueEx(hkNew, RV_WALLPAPERSTYLE, 0, REG_SZ, (LPBYTE)szTemp, dwSize);

    // read the Wallpaper and copy it to the new location as BackupWallpaper
    dwSize = sizeof(szTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hkOld, RV_WALLPAPER, NULL, NULL, (LPBYTE)szTemp, &dwSize))
        RegSetValueEx(hkNew, RV_BACKUPWALLPAPER, 0, REG_SZ, (LPBYTE)szTemp, dwSize);

    // set the wallpaper file creation time at the new location
    getFileTimeByName(szTemp, &ft);
    RegSetValueEx(hkNew, RV_WALLPAPERFILETIME, 0, REG_BINARY, (LPBYTE)&ft, sizeof(ft));

    SHCloseKey(hkOld);
}

BOOL getFileTimeByName(LPCTSTR pszFilename, LPFILETIME pft)
{
    HANDLE hFile;
    BOOL   fResult;

    if (pft == NULL)
        return FALSE;
    ZeroMemory(pft, sizeof(*pft));

    hFile = CreateFile(pszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    fResult = GetFileTime(hFile, NULL, NULL, pft);
    CloseHandle(hFile);

    return fResult;
}

HRESULT pepDeleteFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    UNREFERENCED_PARAMETER(prgdwControl);

    ASSERT(pszPath != NULL && pfd != NULL && prgdwControl != NULL && *prgdwControl == NULL);
    ASSERT(!HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY));

    if (0 == StrCmpI(pfd->cFileName, (LPCTSTR)lParam))
        return S_OK;

    DeleteFile(pszPath);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brand.h ===
#ifndef _BRAND_H_
#define _BRAND_H_

// brand.cpp
HRESULT ProcessAutoconfigDownload();
HRESULT ProcessIcwDownload();

HRESULT ProcessClearBranding();
HRESULT ProcessMigrateOldSettings();
HRESULT ProcessExtRegInfSectionHKLM();
HRESULT ProcessExtRegInfSectionHKCU();
HRESULT lcy50_ProcessExtRegInfSection();
HRESULT ProcessGeneral();
HRESULT ProcessCustomHelpVersion();
HRESULT ProcessToolbarButtons();
HRESULT ProcessRootCert();
HRESULT ProcessActiveSetupSites();
HRESULT ProcessLinksDeletion();
HRESULT ProcessOutlookExpress();

void ProcessDeleteToolbarButtons(BOOL fGPOCleanup);

// brandfav.cpp
HRESULT ProcessFavoritesDeletion();
HRESULT ProcessFavorites();
HRESULT ProcessFavoritesOrdering();
HRESULT ProcessQuickLinks();
HRESULT ProcessQuickLinksOrdering();
#define FSWP_KEY       0x00000001
#define FSWP_VALUE     0x00000002
#define FSWP_KEYLDID   0x00000010
#define FSWP_VALUELDID 0x00000020
#define FSWP_DEFAULT   (FSWP_KEY | FSWP_VALUE | FSWP_VALUELDID)
HRESULT formStrWithoutPlaceholders(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns,
    LPTSTR pszBuffer, UINT cchBuffer, DWORD dwFlags = FSWP_DEFAULT);


//brandbar.cpp
HRESULT ProcessExplorerBars();

// brandcs.cpp
HRESULT ProcessWininetSetup();
HRESULT ProcessConnectionSettingsDeletion();
HRESULT ProcessConnectionSettings();
HRESULT lcy50_ProcessConnectionSettings();

// brandaux.cpp
HRESULT ProcessZonesReset();
HRESULT ProcessRatingsPol();
HRESULT ProcessTrustedPublisherLockdown();
HRESULT ProcessCDWelcome();
HRESULT ProcessBrowserRefresh();

// brandchl.cpp
HRESULT lcy4x_ProcessChannels();
HRESULT lcy4x_ProcessSoftwareUpdateChannels();
HRESULT lcy4x_ProcessWebcheck();
HRESULT lcy4x_ProcessChannelBar();
HRESULT lcy4x_ProcessSubscriptions();

void ProcessRemoveAllChannels(BOOL fGPOCleanup);

// brandad4.cpp
HRESULT lcy4x_ProcessActiveDesktop();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brand.cpp ===
#include "precomp.h"
#include <cryptui.h>
#include <rashelp.h>
#include "exports.h"

// External declarations
// BUGBUG: (andrewgu) we should really clean this up. when ras reg stuff goes through the file as
// well, this will go back to where it belongs, i.e. brandcs.cpp.
BOOL raBackup();                                // ra stands for "remote access"

// Private forward decalarations
#define BTOOLBAR_GUID TEXT("{1FBA04EE-3024-11d2-8F1F-0000F87ABD16}")

static HRESULT processExtRegInfSection(LPCTSTR pcszExtRegInfSect);
static HRESULT eriPreHook (LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam = NULL);
static HRESULT eriPostHook(LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam = NULL);

typedef struct
{
    TCHAR   szTarget[MAX_PATH];
    union {
        IShellLinkW*    pShellLinkW;
        IShellLinkA*    pShellLinkA;
    };
    IPersistFile*   pPersistFile;
    BOOL fUnicode;
} LINKINFO, *PLINKINFO;

HRESULT pepDeleteLinksEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);
static HRESULT deleteLinks(LPCTSTR pcszTarget, DWORD dwFolders);
static void deleteLink(DWORD dwFolder, PLINKINFO pLinkInfo);

// Download of cabs in the autoconfig case
HRESULT ProcessAutoconfigDownload()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessAutoconfigDownload)

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      option;
    LPCTSTR pszNew;
    HKEY    hk;
    DWORD   dwSize;
    BOOL    fUpdateAutocfgURL,
            fUpdateCabs;

    Out(LI0(TEXT("Processing download of the cab files...")));
    fUpdateAutocfgURL = TRUE;

    ZeroMemory(&list, sizeof(list));
    list.dwSize        = sizeof(list);
    list.dwOptionCount = 1;
    list.pOptions      = &option;

    ZeroMemory(&option, sizeof(option));
    option.dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    // BUGBUG: (pritobla) assumption here is that PROXY_TYPE_AUTO_PROXY_URL flag is set. what if
    // PROXY_TYPE_AUTO_PROXY_URL is not set but INTERNET_PER_CONN_AUTOCONFIG_URL is and via
    // autodiscovery, wininet calls into us (via InternetInitializeAutoProxyDll)?
    pszNew = NULL;
    dwSize = list.dwSize;
    if (TRUE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwSize))
        pszNew = option.Value.pszValue;

    hk = NULL;
    SHCreateKeyHKLM(RK_IEAK_CABVER, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);

    fUpdateCabs = InsGetBool(IS_BRANDING, IK_AC_DONTMIGRATEVERSIONS, FALSE, g_GetIns());
    if (fUpdateCabs) {
        SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
        SHDeleteEmptyKey(g_GetHKCU(), RK_IEAK);

        Out(LI0(TEXT("Cabs version information will not be migrated. Updating all existing cabs!")));
    }
    else {
        HRESULT hr;

        hr = MoveCabVersionsToHKLM(g_GetIns());
        if (hr != S_OK) {
            fUpdateCabs = !InsGetBool(IS_BRANDING, IK_AC_NOUPDATEONINSCHANGE, FALSE, g_GetIns());
            if (!fUpdateCabs)
                Out(LI0(TEXT("Autoconfig URL is excluded from cabs updating logic!")));

            else
                if (hr == S_FALSE && hk != NULL) {
                    TCHAR szOld[INTERNET_MAX_URL_LENGTH];

                    szOld[0] = TEXT('\0');
                    dwSize   = sizeof(szOld);
                    RegQueryValueEx(hk, RV_LAST_AUTOCNF_URL, 0, NULL, (LPBYTE)szOld, &dwSize);

                    fUpdateCabs = (StrCmpI(pszNew, szOld) != 0);
                    if (fUpdateCabs)
                        Out(LI0(TEXT("Autoconfig URL has changed. Updating all existing cabs!")));

                    else
                        fUpdateAutocfgURL = FALSE;  // identical -> no need to update
                }
                else {
                    ASSERT(FAILED(hr) || hk == NULL);
                    Out(LI0(TEXT("Due to internal failure it's safer to update all existing cabs!")));
                }
        }
    }

    UpdateBrandingCab(fUpdateCabs);
    UpdateDesktopCab (fUpdateCabs);

    if (hk != NULL) {
        if (fUpdateAutocfgURL)
            RegSetValueEx(hk, RV_LAST_AUTOCNF_URL, 0, REG_SZ, (LPBYTE)pszNew, (DWORD)StrCbFromSz(pszNew));

        SHCloseKey(hk);
    }

    if (option.Value.pszValue != NULL)
        GlobalFree(option.Value.pszValue);

    Out(LI0(TEXT("Done.")));
    return S_OK;
}

// Server-based signup optional custom branding cab download
HRESULT ProcessIcwDownload()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessIcwDownload)

    TCHAR   szCustomCab[MAX_PATH],
            szTargetFile[MAX_PATH];
    HRESULT hr;

    Out(LI0(TEXT("Processing optional custom cab file...")));

    hr = S_OK;
    GetPrivateProfileString(IS_CUSTOMBRANDING, IK_BRANDING, TEXT(""), szCustomCab, countof(szCustomCab), g_GetIns());
    if (szCustomCab[0] == TEXT('\0')) {
        Out(LI0(TEXT("There is no custom branding cab!")));
        hr = S_FALSE;
        goto Exit;                              // there is no custom branding cab
    }
    ASSERT(!PathIsFileSpec(szCustomCab));       // should not be a file name only

    CreateCustomBrandingCabUI(TRUE);

    StrCpy(szTargetFile, g_GetTargetPath());
    hr = DownloadSourceFile(szCustomCab, szTargetFile, countof(szTargetFile), FALSE);
    if (FAILED(hr)) {
        Out(LI2(TEXT("! Downloading custom cab \"%s\" failed with %s."), szCustomCab, GetHrSz(hr)));
        goto Cleanup;
    }

    hr = ExtractFilesWrap(szTargetFile, g_GetTargetPath(), 0, NULL, NULL, 0);
    DeleteFile(szTargetFile);
    if (FAILED(hr))
        Out(LI2(TEXT("! Extracting files out of \"%s\" failed with %s."), szTargetFile, GetHrSz(hr)));

Cleanup:
    CreateCustomBrandingCabUI(FALSE);

Exit:
    Out(LI0(TEXT("Done.")));
    return hr;
}


HRESULT ProcessClearBranding()
{
    Clear(NULL, NULL, NULL, 0);
    return S_OK;
}

HRESULT ProcessMigrateOldSettings()
{
    TCHAR szData[MAX_PATH];
    DWORD cbSize, dwType;
    HKEY  hkHklmMain,
          hkHkcuToolbar;

    hkHklmMain        = NULL;
    hkHkcuToolbar     = NULL;

    SHOpenKeyHKLM(RK_IE_MAIN, KEY_QUERY_VALUE, &hkHklmMain);
    
    if (hkHklmMain != NULL)
    {
        dwType = REG_SZ;

        cbSize = sizeof(szData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkHklmMain, RV_WINDOWTITLE, NULL, &dwType, (LPBYTE)&szData, &cbSize))
            SHSetValue(g_GetHKCU(), RK_IE_MAIN, RV_WINDOWTITLE, dwType, szData, cbSize);
        
        SHCreateKey(g_GetHKCU(), RK_TOOLBAR, KEY_SET_VALUE, &hkHkcuToolbar);

        if (hkHkcuToolbar != NULL)
        {
            cbSize = sizeof(szData);
            if (ERROR_SUCCESS == RegQueryValueEx(hkHklmMain, RV_LARGEBITMAP, NULL, &dwType, (LPBYTE)&szData, &cbSize))
                RegSetValueEx(hkHkcuToolbar, RV_LARGEBITMAP, NULL, dwType, (LPBYTE)szData, cbSize);

            cbSize = sizeof(szData);
            if (ERROR_SUCCESS == RegQueryValueEx(hkHklmMain, RV_SMALLBITMAP, NULL, &dwType, (LPBYTE)&szData, &cbSize))
                RegSetValueEx(hkHkcuToolbar, RV_SMALLBITMAP, NULL, dwType, (LPBYTE)szData, cbSize);

            SHCloseKey(hkHkcuToolbar);
        }

        SHCloseKey(hkHklmMain);
    }
    
    return S_OK;
}

// ExtRegInf section

HRESULT ProcessExtRegInfSectionHKLM()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessExtRegInfSectionHKLM)
    
    return processExtRegInfSection(IS_EXTREGINF_HKLM);
}

HRESULT ProcessExtRegInfSectionHKCU()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessExtRegInfSectionHKCU)
    
    return processExtRegInfSection(IS_EXTREGINF_HKCU);
}

HRESULT lcy50_ProcessExtRegInfSection()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ProcessExtRegInfSection)
    
    return processExtRegInfSection(IS_EXTREGINF);
}

HRESULT ProcessGeneral()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGeneral)

    TCHAR szValue[MAX_PATH],
          szTargetFile[MAX_PATH],
          szCompany[MAX_PATH];
    HKEY  hkHklmMain,
          hkHkcuMain,
          hkHkcuHelpMenuUrl,
          hkHkcuToolbar,
          hkHklmUAString;
    DWORD dwFlags,
          dwBrandedFlags;
    BOOL  fCustomize;

    //----- Initialization -----
    // REVIEW: (andrewgu) i can think of several ways to implement this function. this approach
    // seems to resemble the closest to how it would be if CReg2Ins was used.
    hkHklmMain        = NULL;
    hkHkcuMain        = NULL;
    hkHkcuHelpMenuUrl = NULL;
    hkHkcuToolbar     = NULL;
    hkHklmUAString    = NULL;

    SHCreateKeyHKLM(         RK_IE_MAIN,         KEY_SET_VALUE,      &hkHklmMain);
    SHCreateKey(g_GetHKCU(), RK_IE_MAIN,         KEY_SET_VALUE,      &hkHkcuMain);
    SHCreateKey(g_GetHKCU(), RK_HELPMENUURL,     KEY_SET_VALUE,      &hkHkcuHelpMenuUrl);
    SHCreateKey(g_GetHKCU(), RK_TOOLBAR,         KEY_SET_VALUE,      &hkHkcuToolbar);
    SHCreateKeyHKLM(         RK_UA_POSTPLATFORM, KEY_DEFAULT_ACCESS, &hkHklmUAString);

    if (hkHkcuMain        == NULL ||
        hkHkcuHelpMenuUrl == NULL ||
        hkHkcuToolbar     == NULL ||
        hkHklmUAString    == NULL) {
        Out(LI0(TEXT("! Internal failure. Some of the settings may not get applied.")));
    }

    dwFlags        = g_GetFeature(FID_GENERAL)->dwFlags;
    dwBrandedFlags = GetFeatureBranded(FID_GENERAL);
    fCustomize     = FALSE;

    //----- Company Name, Custom Key, Wizard Version -----
    GetPrivateProfileString(IS_BRANDING, IK_COMPANYNAME, TEXT(""), szValue, countof(szValue), g_GetIns());
    StrCpy(szCompany, szValue);                 // szCompany is set here

    if (NULL != hkHklmMain) {
        if (TEXT('\0') != szValue[0]) {
            RegSetValueEx(hkHklmMain, RV_COMPANYNAME, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
            Out(LI1(TEXT("Company name is set to \"%s\"."), szValue));
        }

        GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szValue, countof(szValue), g_GetIns());
        if (TEXT('\0') != szValue[0]) {
            RegSetValueEx(hkHklmMain, RV_CUSTOMKEY,   0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
            Out(LI1(TEXT("Custom key is set to \"%s\"."), szValue));
        }

        GetPrivateProfileString(IS_BRANDING, IK_WIZVERSION,  TEXT(""), szValue, countof(szValue), g_GetIns());
        if (TEXT('\0') != szValue[0]) {
            RegSetValueEx(hkHklmMain, RV_WIZVERSION,  0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
            Out(LI1(TEXT("Wizard version is set to \"%s\"."), szValue));
        }
    }

    //----- Window Title -----
    if ((NULL != hkHkcuMain && !HasFlag(dwFlags, FF_GEN_TITLE)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_TITLE))) {
        InsGetString(IS_BRANDING, IK_WINDOWTITLE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) 
            if (TEXT('\0') != szValue[0]) {
                RegSetValueEx(hkHkcuMain, RV_WINDOWTITLE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                // Note: we need to write to the HKLM so that if the user goes back from
                // IE 5.01 to IE 4.0, the last customization should be reflected.
                if (!IsOS(OS_NT5) && NULL != hkHklmMain)
                    RegSetValueEx(hkHklmMain, RV_WINDOWTITLE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                Out(LI1(TEXT("Browser title is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_TITLE);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuMain, RV_WINDOWTITLE);

                    if (NULL != hkHklmMain)
                        RegDeleteValue(hkHklmMain, RV_WINDOWTITLE);

                    Out(LI0(TEXT("Browser title was deleted.")));
                }
    }

    //----- Home Page -----
    // REVIEW: (andrewgu) if it's not set, what is the deal with iereset.inf. do we need to clear
    // it out of there or perhaps set to some new default.
    if (!HasFlag(dwFlags, FF_GEN_HOMEPAGE) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_HOMEPAGE))) {
        InsGetString(IS_URL, IK_HOMEPAGE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            TCHAR szIEResetInf[MAX_PATH];

            if (TEXT('\0') != szValue[0]) {
                if (NULL != hkHkcuMain)
                    RegSetValueEx(hkHkcuMain, RV_HOMEPAGE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                // for a preference GPO, shouldn't update RV_DEFAULTPAGE in HKLM and also
                // the default START_PAGE_URL in iereset.inf
                if (!g_CtxIs(CTX_MISC_PREFERENCES)) {
                    if (NULL != hkHklmMain)
                        RegSetValueEx(hkHklmMain, RV_DEFAULTPAGE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

                    // update the START_PAGE_URL in %windir%\inf\iereset.inf
                    GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
                    PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
                    if (PathFileExists(szIEResetInf))
                        WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szValue, szIEResetInf);
                }

                SetFeatureBranded(FID_GENERAL, FF_GEN_HOMEPAGE);
                Out(LI1(TEXT("Home page is set to \"%s\"."), szValue));
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    if (NULL != hkHkcuMain)
                        RegDeleteValue(hkHkcuMain, RV_HOMEPAGE);

                    // restore RV_DEFAULTPAGE and START_PAGE_URL to the default MS value
                    GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
                    PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
                    if (PathFileExists(szIEResetInf)) {
                        TCHAR szDefHomePage[MAX_PATH];

                        GetPrivateProfileString(IS_STRINGS, TEXT("MS_START_PAGE_URL"), TEXT(""), szDefHomePage, countof(szDefHomePage), szIEResetInf);
                        WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szDefHomePage, szIEResetInf);

                        if (NULL != hkHklmMain)
                            RegSetValueEx(hkHklmMain, RV_DEFAULTPAGE, 0, REG_SZ, (PBYTE)szDefHomePage, (DWORD)StrCbFromSz(szDefHomePage));

                    }

                    Out(LI0(TEXT("Home page was deleted.")));
                }
        }
    }
    
    //----- Search URL -----
    if ((NULL != hkHkcuMain && !HasFlag(dwFlags, FF_GEN_SEARCHPAGE)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_SEARCHPAGE))) {
        InsGetString(IS_URL, IK_SEARCHPAGE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            DWORD dwVal;

            if (TEXT('\0') != szValue[0]) {
                dwVal = 1;
                RegSetValueEx(hkHkcuMain, RV_SEARCHBAR,         0, REG_SZ,    (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                RegSetValueEx(hkHkcuMain, RV_USE_CUST_SRCH_URL, 0, REG_DWORD, (PBYTE)&dwVal,  (DWORD)sizeof(dwVal));

                Out(LI1(TEXT("Search page is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_SEARCHPAGE);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuMain, RV_SEARCHBAR);
                    RegDeleteValue(hkHkcuMain, RV_USE_CUST_SRCH_URL);

                    Out(LI0(TEXT("Search page was deleted.")));
                }
        }
    }

    //----- Help Page URL -----
    if ((NULL != hkHkcuHelpMenuUrl && !HasFlag(dwFlags, FF_GEN_HELPPAGE)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_HELPPAGE))) {

        InsGetString(IS_URL, IK_HELPPAGE, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            if (TEXT('\0') != szValue[0]) {
                RegSetValueEx(hkHkcuHelpMenuUrl, RV_ONLINESUPPORT, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                Out(LI1(TEXT("Help page URL is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_HELPPAGE);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuHelpMenuUrl, RV_ONLINESUPPORT);
                    Out(LI0(TEXT("Help page URL was deleted.")));
                }
        }
    }
    
    //----- User Agent String -----
    if ((NULL != hkHklmUAString && !HasFlag(dwFlags, FF_GEN_UASTRING)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_UASTRING))) {

        InsGetString(IS_BRANDING, IK_UASTR, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            if (TEXT('\0') != szValue[0]) {
                TCHAR szID[32];                 // BUGBUG: (andrewgu) buffer overrun?

                wnsprintf(szID, countof(szID), TEXT("IEAK%s"), szCompany);
                RegSetValueEx(hkHklmUAString, szValue, 0, REG_SZ, (PBYTE)szID, (DWORD)StrCbFromSz(szID));

                Out(LI1(TEXT("User agent string is set to \"%s\"."), szValue));
                SetFeatureBranded(FID_GENERAL, FF_GEN_UASTRING);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    TCHAR szUAVal[MAX_PATH],
                          szUAData[32];
                    DWORD cchUAVal,
                          cbUAData;
                    int   iUAValue;

                    cchUAVal = countof(szUAVal),
                    cbUAData = sizeof(szUAData);
                    iUAValue = 0;
                    while (ERROR_SUCCESS == RegEnumValue(hkHklmUAString, iUAValue, szUAVal, &cchUAVal, NULL, NULL,
                        (LPBYTE)szUAData, &cbUAData)) {

                        cchUAVal = countof(szUAVal);
                        cbUAData = sizeof(szUAData);

                        if (0 == StrCmpN(szUAData, TEXT("IEAK"), 4)) {
                            RegDeleteValue(hkHklmUAString, szUAVal);
                            Out(LI1(TEXT("Deleted User Agent Key %s."), szUAVal));
                            continue;
                        }

                        iUAValue++;
                    }
                }
        }
    }

    //----- Toolbar Background Bitmap -----
    if ((NULL != hkHkcuToolbar && !HasFlag(dwFlags, FF_GEN_TOOLBARBMP)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_TOOLBARBMP))) {
        InsGetString(IS_BRANDING, IK_TOOLBARBMP, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        if (fCustomize) {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_BACKGROUNDBMP50, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Toolbar background bitmap is set to \"%s\"."), szTargetFile));
                SetFeatureBranded(FID_GENERAL, FF_GEN_TOOLBARBMP);
            }
            else
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP50);
                    RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP);

                    Out(LI0(TEXT("Toolbar background bitmap was deleted.")));
                }
        }
    }

    //----- Static Logos (large and small) -----
    if ((NULL != hkHkcuToolbar && !HasFlag(dwFlags, FF_GEN_STATICLOGO)) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_STATICLOGO))) {

        InsGetString(IS_LARGELOGO, IK_NAME, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // large
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_LARGEBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Large static logo is set to \"%s\"."), szTargetFile));
                // Note: we need to write to the HKLM so that if the user goes back from
                // IE 5.01 to IE 4.0, the last customization should be reflected.
                if (!IsOS(OS_NT5) && hkHklmMain != NULL)
                    RegSetValueEx(hkHklmMain, RV_LARGEBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                SetFeatureBranded(FID_GENERAL, FF_GEN_STATICLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_LARGEBITMAP);

                    if (hkHklmMain != NULL)
                        RegDeleteValue(hkHklmMain, RV_LARGEBITMAP);

                    Out(LI0(TEXT("Large static logo was deleted.")));
                }
            }
        }

        InsGetString(IS_SMALLLOGO, IK_NAME, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // small
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_SMALLBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Small static logo is set to \"%s\"."), szTargetFile));
                // Note: we need to write to the HKLM so that if the user goes back from
                // IE 5.01 to IE 4.0, the last customization should be reflected.
                if (!IsOS(OS_NT5) && hkHklmMain != NULL)
                    RegSetValueEx(hkHklmMain, RV_SMALLBITMAP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                SetFeatureBranded(FID_GENERAL, FF_GEN_STATICLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_SMALLBITMAP);

                    if (hkHklmMain != NULL)
                        RegDeleteValue(hkHklmMain, RV_SMALLBITMAP);

                    Out(LI0(TEXT("Small static logo was deleted.")));
                }
            }
        }
    }

    //----- Animated Logos (large and small) -----
    if ((hkHkcuToolbar != NULL && !HasFlag(dwFlags, FF_GEN_ANIMATEDLOGO) &&
            InsGetBool(IS_ANIMATION, IK_DOANIMATION, FALSE, g_GetIns())) &&
        !(g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && HasFlag(dwBrandedFlags, FF_GEN_ANIMATEDLOGO))) {

        InsGetString(IS_ANIMATION, IK_LARGEBITMAP, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // large
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_BRANDBMP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Large animated logo is set to \"%s\"."), szTargetFile));
                SetFeatureBranded(FID_GENERAL, FF_GEN_ANIMATEDLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_BRANDBMP);
                    Out(LI0(TEXT("Large animated logo was deleted.")));
                }
            }
        }

        InsGetString(IS_ANIMATION, IK_SMALLBITMAP, szValue, countof(szValue), g_GetIns(), NULL, &fCustomize);
        // small
        if (fCustomize)
        {
            if (TEXT('\0') != szValue[0]) {
                PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                ASSERT(PathFileExists(szTargetFile));

                RegSetValueEx(hkHkcuToolbar, RV_SMALLBRANDBMP, 0, REG_SZ, (PBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));

                Out(LI1(TEXT("Small animated logo is set to \"%s\"."), szTargetFile));
                SetFeatureBranded(FID_GENERAL, FF_GEN_ANIMATEDLOGO);
            }
            else
            {
                if (g_CtxIs(CTX_GP)) {
                    RegDeleteValue(hkHkcuToolbar, RV_SMALLBRANDBMP);
                    Out(LI0(TEXT("Small animated logo was deleted.")));
                }
            }
        }
    }

    //----- First Home Page -----
    // Brand the First Home Page only if we're called via BrandIE4
    if (NULL != hkHkcuMain && !HasFlag(dwFlags, FF_GEN_FIRSTHOMEPAGE) &&
        g_CtxIs(CTX_CORP | CTX_ISP | CTX_ICP))
    {
        // A custom first home page url is present if and only if:
        //   1) NoWelcome=1 in the [URL] section AND
        //   2) FirstHomePage=<a non-empty value> in the [URL] section
        InsGetString(IS_URL, IK_FIRSTHOMEPAGE, szValue, countof(szValue), g_GetIns());
        if (*szValue  &&  InsGetBool(IS_URL, IK_NO_WELCOME_URL, FALSE, g_GetIns()))
        {
            RegSetValueEx(hkHkcuMain, RV_FIRSTHOMEPAGE, 0, REG_SZ, (PBYTE)szValue, (DWORD)StrCbFromSz(szValue));

            Out(LI1(TEXT("First Home Page is set to \"%s\"."), szValue));
        }
    }

    SHCloseKey(hkHklmMain);
    SHCloseKey(hkHkcuMain);
    SHCloseKey(hkHkcuHelpMenuUrl);
    SHCloseKey(hkHkcuToolbar);
    SHCloseKey(hkHklmUAString);

    return S_OK;
}

// write customize version in registry to denote ICP, ISP or corp install
HRESULT ProcessCustomHelpVersion()
{
    TCHAR  szHelpStr[MAX_PATH];
    PCTSTR pszCustomVer;

    pszCustomVer = NULL;
    if (HasFlag(g_GetContext(), CTX_CORP))
        pszCustomVer = TEXT("CO");

    else if (HasFlag(g_GetContext(), CTX_ISP))
        pszCustomVer = TEXT("IS");

    else {
        ASSERT(HasFlag(g_GetContext(), CTX_ICP));
        pszCustomVer = TEXT("IC");
    }

    SHSetValue(HKEY_LOCAL_MACHINE, RK_IE, RV_CUSTOMVER, REG_SZ, pszCustomVer, (DWORD)StrCbFromSz(pszCustomVer));

    // set custom string for Help About dialog (default taken from resource)
    if (0 == GetPrivateProfileString(IS_BRANDING, IK_HELPSTR, TEXT(""), szHelpStr, countof(szHelpStr), g_GetIns()))
        LoadString(g_GetHinst(), IDS_HELPSTRING, szHelpStr, countof(szHelpStr));

    SHSetValue(HKEY_LOCAL_MACHINE,
        IsOS(OS_NT) ? RK_NT_WINDOWS: RP_WINDOWS, RV_IEAK_HELPSTR, REG_SZ, szHelpStr, (DWORD)StrCbFromSz(szHelpStr));

    return S_OK;
}

void ProcessDeleteToolbarButtons(BOOL fGPOCleanup)
{
    HKEY hkToolbar;

    if (SHOpenKey(g_GetHKCU(), RK_BTOOLBAR, KEY_DEFAULT_ACCESS, &hkToolbar) == ERROR_SUCCESS)
    {
        DWORD dwIndex = 0;
        DWORD dwSub;
        TCHAR szSubKey[MAX_PATH];

        dwSub = countof(szSubKey);
        while (RegEnumKeyEx(hkToolbar, dwIndex, szSubKey, &dwSub, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) 
        {
            if ((!fGPOCleanup || 
                (SHGetValue(hkToolbar, szSubKey, IEAK_GP_MANDATE, NULL, NULL, NULL) == ERROR_SUCCESS)) &&
                (SHGetValue(hkToolbar, szSubKey, TEXT("ButtonText"), NULL, NULL, NULL) == ERROR_SUCCESS))
            {
                Out(LI1(TEXT("Deleting toolbar button \"%s\"..."), szSubKey));
                SHDeleteKey(hkToolbar, szSubKey);
            }
            else
                dwIndex++;
            dwSub = countof(szSubKey);
        }
        SHCloseKey(hkToolbar);
    }
}

HRESULT ProcessToolbarButtons()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessToolbarButtons)

    TCHAR szCaption[MAX_BTOOLBAR_TEXT_LENGTH + 1],
          szValue[INTERNET_MAX_URL_LENGTH],
          szTargetFile[MAX_PATH],
          szBToolbarTextParam[32],
          szBToolbarIcoParam[32],
          szBToolbarActionParam[32],
          szBToolbarHotIcoParam[32],
//        szBToolbarToolTextParam[32],
          szBToolbarShowParam[32],
          szKey[128];
    DWORD dwIndex,
          dwSize;
    HKEY  hkBToolbar,
          hkSubkey;
    UINT  i;
    BOOL  fReplace, fSkip;

    if (HasFlag(g_GetContext(), (CTX_CORP | CTX_AUTOCONFIG | CTX_GP))) {
        if (InsGetBool(IS_BTOOLBARS, IK_BTDELETE, FALSE, g_GetIns())) {
            Out(LI0(TEXT("Deleting old custom toolbar buttons.")));
            ProcessDeleteToolbarButtons(FALSE);
        }
    }

    hkBToolbar = NULL;
    if (SHCreateKey(g_GetHKCU(), RK_BTOOLBAR, KEY_WRITE | KEY_READ, &hkBToolbar) == ERROR_SUCCESS)
    {
        for (i = 0; i < MAX_BTOOLBARS; i++, dwIndex++)
        {
            wnsprintf(szBToolbarTextParam,     countof(szBToolbarTextParam),     TEXT("%s%i"), IK_BTCAPTION, i);
            wnsprintf(szBToolbarIcoParam,      countof(szBToolbarIcoParam),      TEXT("%s%i"), IK_BTICON,    i);
            wnsprintf(szBToolbarActionParam,   countof(szBToolbarActionParam),   TEXT("%s%i"), IK_BTACTION,  i);
            wnsprintf(szBToolbarHotIcoParam,   countof(szBToolbarHotIcoParam),   TEXT("%s%i"), IK_BTHOTICO,  i);
//          wnsprintf(szBToolbarToolTextParam, countof(szBToolbarToolTextParam), TEXT("%s%i"), IK_BTTOOLTIP, i);
            wnsprintf(szBToolbarShowParam,     countof(szBToolbarShowParam),     TEXT("%s%i"), IK_BTSHOW,    i);
            
            if (!GetPrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, TEXT(""), szCaption, countof(szCaption), g_GetIns()))
                break;
            
            Out(LI1(TEXT("Adding toolbar button \"%s\"..."), szCaption));
            
            dwIndex = 0;
            fReplace = FALSE;
            fSkip = FALSE;

            dwSize = countof(szKey);
            while (RegEnumKeyEx(hkBToolbar, dwIndex, szKey, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                TCHAR szOld[128];
                
                dwSize = sizeof(szOld);
                if (SHGetValue(hkBToolbar, szKey, TEXT("ButtonText"), NULL, 
                    (LPVOID)szOld, &dwSize) == ERROR_SUCCESS)
                {
                    if (StrCmpI(szOld, szCaption) == 0)
                    {
                        // check to see if this is a mandate key

                        if (g_CtxIs(CTX_MISC_PREFERENCES) &&
                            (SHValueExists(hkBToolbar, szKey, IEAK_GP_MANDATE) == S_OK))
                            fSkip = TRUE;
                        else
                            fReplace = TRUE;

                        break;
                    }
                }
                
                dwIndex++;
                dwSize = countof(szKey);
            }
            
            if (fSkip)
                continue;

            if (!fReplace)
            {
                GUID guid;
                
                if (CoCreateGuid(&guid) == NOERROR)
                    CoStringFromGUID(guid, szKey, countof(szKey));
            }

            Out(LI1(TEXT("Using reg key \"%s\"..."), szKey));
            
            if (SHCreateKey(hkBToolbar, szKey, KEY_WRITE, &hkSubkey) == ERROR_SUCCESS)
            {
                LPCTSTR pszValue;

                pszValue = InsGetBool(IS_BTOOLBARS, szBToolbarShowParam, TRUE, g_GetIns()) ? TEXT("Yes") : TEXT("No");

                RegSetValueEx(hkSubkey, TEXT("Default Visible"), 0, REG_SZ, (LPBYTE)pszValue, (DWORD)StrCbFromSz(pszValue));

                Out(LI1(TEXT("Default State is \"%s\","), pszValue));

                RegSetValueEx(hkSubkey, TEXT("ButtonText"), 0, REG_SZ, (LPBYTE)szCaption, (DWORD)StrCbFromSz(szCaption));
                Out(LI1(TEXT("Setting caption to \"%s\","), szCaption));

                RegSetValueEx(hkSubkey, TEXT("CLSID"), 0, REG_SZ, (LPBYTE)BTOOLBAR_GUID, sizeof(BTOOLBAR_GUID));
                
                if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                    ASSERT(PathFileExists(szTargetFile));

                    RegSetValueEx(hkSubkey, TEXT("Icon"), 0, REG_SZ, (LPBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));
                    Out(LI1(TEXT("Setting icon to \"%s\","), PathFindFileName(szTargetFile)));
                }
                
                if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    PathCombine(szTargetFile, g_GetTargetPath(), PathFindFileName(szValue));
                    ASSERT(PathFileExists(szTargetFile));

                    RegSetValueEx(hkSubkey, TEXT("HotIcon"), 0, REG_SZ, (LPBYTE)szTargetFile, (DWORD)StrCbFromSz(szTargetFile));
                    Out(LI1(TEXT("Setting hot icon to \"%s\","), PathFindFileName(szTargetFile)));
                }
                
/*              if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarToolTextParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    RegSetValueEx(hkSubkey, TEXT("ToolTip"), 0, REG_SZ, (LPBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                    Out(LI1(TEXT("Setting tool tip to \"%s\","), szValue));
                }
*/

                // set a special key not to delete if this is not a preference GPO

                if (g_CtxIsGp() && !g_CtxIs(CTX_MISC_PREFERENCES))
                    RegSetValueEx(hkSubkey, IEAK_GP_MANDATE, 0, REG_SZ, (LPBYTE)TEXT(""), StrCbFromCch(2));

                if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, TEXT(""), szValue, countof(szValue), g_GetIns()))
                {
                    RegSetValueEx(hkSubkey, TEXT("Exec"), 0, REG_SZ, (LPBYTE)szValue, (DWORD)StrCbFromSz(szValue));
                    Out(LI1(TEXT("Setting script/action to \"%s\""), szValue));
                }

                SHCloseKey(hkSubkey);
            }
            else
                Out(LI0(TEXT("Could not create reg key")));
        }

        SHCloseKey(hkBToolbar);
    }

    SetFeatureBranded(FID_TOOLBARBUTTONS);
    return S_OK;
}

// ISP Root Cert
HRESULT ProcessRootCert()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRootCert)

    USES_CONVERSION;

    typedef DWORD (WINAPI* CRYPTUIWIZIMPORT) (DWORD, HWND, LPCWSTR, PCCRYPTUI_WIZ_IMPORT_SRC_INFO, HCERTSTORE);

    CRYPTUI_WIZ_IMPORT_SRC_INFO certInfo;
    TCHAR            szValue[MAX_PATH],
                     szTargetFile[MAX_PATH];
    PCTSTR           pszFilename;
    CRYPTUIWIZIMPORT pfnCryptUIWizImport;
    HCERTSTORE       hSystemStore;
    HINSTANCE        hCryptuiLib;
    HRESULT          hr;

    pfnCryptUIWizImport = NULL;
    hr = S_OK;

    GetPrivateProfileString(IS_ISPSECURITY, IK_ROOTCERT, TEXT(""), szValue, countof(szValue), g_GetIns());

    pszFilename = PathFindFileName(szValue);
    Out(LI1(TEXT("Adding root cert \"%s\"..."), pszFilename));
    PathCombine(szTargetFile, g_GetTargetPath(), pszFilename);

    hCryptuiLib = LoadLibrary(TEXT("cryptui.dll"));
    if (hCryptuiLib == NULL) {
        Out(LI0(TEXT("cryptui.dll load lib failed")));
        return E_FAIL;
    }

    pfnCryptUIWizImport = (CRYPTUIWIZIMPORT)GetProcAddress(hCryptuiLib, "CryptUIWizImport");
    if (pfnCryptUIWizImport == NULL) {
        FreeLibrary(hCryptuiLib);
        Out(LI0(TEXT("Could not find entry point CryptUIWizImport")));
        return E_FAIL;
    }

    hSystemStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"ROOT");
    if (hSystemStore != NULL) {
        ZeroMemory(&certInfo, sizeof(certInfo));
        certInfo.dwSize          = sizeof(certInfo);
        certInfo.pwszFileName    = T2CW(szTargetFile);
        certInfo.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;

        if (!pfnCryptUIWizImport(CRYPTUI_WIZ_NO_UI, NULL, NULL, &certInfo, hSystemStore)) {
            Out(LI0(TEXT("Unable to add root cert.")));
            hr = E_FAIL;
        }
        else
            DeleteFile(szTargetFile);

        CertCloseStore(hSystemStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    else {
        Out(LI0(TEXT("Unable to open system store.")));
        hr = E_FAIL;
    }

    FreeLibrary(hCryptuiLib);
    return hr;
}

// Register download URLs as safe for updating IE
HRESULT ProcessActiveSetupSites()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessActiveSetupSites)

    URL_COMPONENTS uc;
    TCHAR  szUrl[INTERNET_MAX_URL_LENGTH],
           szRegKey[MAX_PATH],
           szTitle[MAX_PATH],
           szGuid[128],
           szInsKey[32];
    HKEY   hk;
    LPTSTR pszBuf;
    DWORD  dwUrlLen;
    LONG   lResult;
    int    i;

    W2Tbuf(awchMSIE4GUID, szGuid, countof(szGuid));
    wnsprintf(szRegKey, countof(szRegKey), RK_IE_UPDATE, szGuid);

    lResult = SHCreateKeyHKLM(szRegKey, KEY_SET_VALUE, &hk);
    if (lResult != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lResult);

    for (i = 0; TRUE; i++) {
        wnsprintf(szInsKey, countof(szInsKey), IK_SITENAME, i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szInsKey, TEXT(""), szTitle, countof(szTitle), g_GetIns());

        wnsprintf(szInsKey, countof(szInsKey), IK_SITEURL, i);
        dwUrlLen = GetPrivateProfileString(IS_ACTIVESETUP_SITES, szInsKey, TEXT(""), szUrl, countof(szUrl), g_GetIns());

        if (szTitle[0] == TEXT('\0') || szUrl[0] == TEXT('\0'))
            break;

        //----- Figure out Protocol/Host pair in the URL -----
        ZeroMemory(&uc, sizeof(uc));
        uc.dwStructSize      = sizeof(uc);
        uc.dwSchemeLength    = 1;
        uc.dwHostNameLength  = 1;
        uc.dwUrlPathLength   = 1;

        if (InternetCrackUrl(szUrl, dwUrlLen, 0, &uc)) {
            if (uc.nScheme == INTERNET_SCHEME_FILE) {
                // the below ASSERT explains the case we got here
                ASSERT(uc.lpszHostName     == NULL &&
                       uc.dwHostNameLength == 0);

                if (PathIsUNC(uc.lpszUrlPath)) {
                    // Note. The following code is ported from shlwapi's
                    //       PathSkipRoot which doesn't work here.

                    ASSERT(uc.dwUrlPathLength >= 2);
                    pszBuf = uc.lpszUrlPath;
                    if (StrCmpN(pszBuf, TEXT("\\\\"), 2) == 0) {
                        pszBuf = StrChr(pszBuf + 2, TEXT('\\'));
                        if (pszBuf != NULL)
                            pszBuf = StrPBrk(pszBuf + 1, TEXT("\\/"));
                    }

                    if (pszBuf != NULL) {   // better be safe than sorry
                        *pszBuf = TEXT('\0');
                        uc.dwUrlPathLength = DWORD(pszBuf - uc.lpszUrlPath);
                        ASSERT(PathIsUNCServerShare(uc.lpszUrlPath));
                    }
                }
                else                        // whatever it is,
                    ;                       // use the whole thing
            }
            else if (uc.nScheme == INTERNET_SCHEME_DEFAULT ||
                     uc.nScheme == INTERNET_SCHEME_FTP     ||
                     uc.nScheme == INTERNET_SCHEME_GOPHER  ||
                     uc.nScheme == INTERNET_SCHEME_HTTP    ||
                     uc.nScheme == INTERNET_SCHEME_HTTPS) {
                // the below ASSERT explains the case we got here
                ASSERT(uc.lpszHostName     != NULL &&
                       uc.dwHostNameLength >= 0);

                uc.lpszUrlPath = NULL;      // only need the host
                uc.dwUrlPathLength = 0;
            }
            else                            // wierdo,
                ;                           // use the whole thing

            if (InternetCreateUrl(&uc, 0, szUrl, &dwUrlLen))
                RegSetValueEx(hk, szUrl, 0, REG_SZ, (LPBYTE)TEXT(""), StrCbFromCch(1));
        }
    }

    SHCloseKey(hk);
    return S_OK;
}

// Removes links
HRESULT ProcessLinksDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessLinksDeletion)
    
    // OE
    if (InsGetBool(IS_OUTLKEXP, IK_DELETELINKS, FALSE, g_GetIns()))
        deleteLinks(MSIMN_EXE, DESKTOP_FOLDER | PROGRAMS_FOLDER | QUICKLAUNCH_FOLDER | PROGRAMS_IE_FOLDER);

    // Channel
    if (InsGetBool(IS_DESKTOPOBJS, IK_DELETELINKS, FALSE, g_GetIns()))
    {
        TCHAR szViewChannels[MAX_PATH];

        if (0 == LoadString(g_GetHinst(), IDS_FILE_VIEWCHANNELS, szViewChannels, countof(szViewChannels)))
            StrCpy(szViewChannels, VIEWCHANNELS_SCF);

        deleteLinks(szViewChannels, QUICKLAUNCH_FOLDER);
    }

    return S_OK;
}

// Configure paths to branding files for Outlook Express
HRESULT ProcessOutlookExpress()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessOutlookExpress)

    USES_CONVERSION;

    TCHAR   szTargetFile[MAX_PATH],
            szFile[MAX_PATH];
    LPCTSTR pszFileName;
    HRESULT hr;
    UINT    nLen, nTargetPathLen;
    BOOL    fHTTP, fBrandOE;

    // no OE branding for GP
    // BUGBUG: <oliverl> this should be moved to an apply function along with some stuff below

    if (g_CtxIsGp())
        return S_OK;

    hr = S_OK;

    StrCpy(szTargetFile, g_GetTargetPath());
    nTargetPathLen = StrLen(szTargetFile);

    // initialize fBrandOE to FALSE; it will be set to TRUE if and only if there is atleast one OE setting to brand
    fBrandOE = FALSE;

    // Infopane
    nLen  = GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE, TEXT(""), szFile, countof(szFile), g_GetIns());
    fHTTP = PathIsURL(szFile);
    if (!fHTTP && nLen > 0) {
        pszFileName = PathFindFileName(szFile);

        PathAppend(szTargetFile, pszFileName);
        WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANE, szTargetFile, g_GetIns());
        szTargetFile[nTargetPathLen] = TEXT('\0');

        fBrandOE = TRUE;
    }

    // Infopane bitmap
    if (!fHTTP) {
        nLen = GetPrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP, TEXT(""), szFile, countof(szFile), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szFile);

            PathAppend(szTargetFile, pszFileName);
            WritePrivateProfileString(IS_INTERNETMAIL, IK_INFOPANEBMP, szTargetFile, g_GetIns());
            szTargetFile[nTargetPathLen] = TEXT('\0');

            fBrandOE = TRUE;
        }
    }

    // Welcome message HTML file
    nLen = GetPrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, TEXT(""), szFile, countof(szFile), g_GetIns());
    if (nLen > 0) {
        pszFileName = PathFindFileName(szFile);

        PathAppend(szTargetFile, pszFileName);
        WritePrivateProfileString(IS_INTERNETMAIL, IK_WELCOMEMESSAGE, szTargetFile, g_GetIns());
        szTargetFile[nTargetPathLen] = TEXT('\0');

        fBrandOE = TRUE;
    }

    nLen = GetPrivateProfileString(IS_LDAP, IK_BITMAP, TEXT(""), szFile, countof(szFile), g_GetIns());
    if (nLen > 0) {
        pszFileName = PathFindFileName(szFile);

        PathAppend(szTargetFile, pszFileName);
        WritePrivateProfileString(IS_LDAP, IK_BITMAP, szTargetFile, g_GetIns());

        fBrandOE = TRUE;
    }

    // Note. Need to flush the *.ini file before calling into OE branding DLL.
    //WritePrivateProfileString(NULL, NULL, NULL, g_GetIns());

    //----- Call into OE branding DLL for branding of Outlook Express -----
    // Note. In the ISP mode the actual branding will happen during the signup
    //       process and not here.
    if (!HasFlag(g_GetContext(), CTX_SIGNUP_ALL)) {
        TCHAR     szOEBrandDLL[MAX_PATH];
        HINSTANCE hDLL;
        HKEY      hk;
        DWORD     dwSize;
        LONG      lResult;
        BOOL      fLoadedDLL;

        // apszOESections lists all the sections which contain only OE branding information;
        // if a new section is added or an existing one is deleted, pls update the array.
        LPCTSTR apszOESections[] = {
            IS_IDENTITIES,          // [Identities]
            IS_INTERNETMAIL,        // [Internet_Mail]
            IS_INTERNETNEWS,        // [Internet_News]
            IS_LDAP,                // [LDAP]
            IS_MAILSIG,             // [Mail_Signature]
            IS_SIG,                 // [Signature]
            IS_OUTLKEXP,            // [Outlook_Express]
            IS_OEGLOBAL             // [Outlook_Express_Global]
        };

        // perf: Do a LoadLibrary on msoeacct.dll to brand OE settings only if:
        // (1) fBrandOE is already set to TRUE, or
        // (2) there is atleast one non-empty OE section, or
        // (3) Help_Page is non-empty in the [URL] section

        if (!fBrandOE)
        {
            // set fBrandOE to TRUE if atleast one of the OE sections (apszOESections[]) is non-empty
            for (INT i = 0;  i < countof(apszOESections);  i++)
                if (!InsIsSectionEmpty(apszOESections[i], g_GetIns()))
                {
                    fBrandOE = TRUE;
                    break;
                }
        }

        if (!fBrandOE)
        {
            // set fBrandOE to TRUE if Help_Page is non-empty in the [URL] section
            if (!InsIsKeyEmpty(IS_URL, IK_HELPPAGE, g_GetIns()))
                fBrandOE = TRUE;
        }

        if (!fBrandOE)
        {
            Out(LI0(TEXT("There are no Outlook Express settings to brand!")));
            goto Exit;
        }

        lResult = SHOpenKeyHKLM(RK_OE_ACCOUNTMGR, KEY_QUERY_VALUE, &hk);
        if (lResult != ERROR_SUCCESS)
            goto Exit;

        szOEBrandDLL[0] = TEXT('\0');
        dwSize          = sizeof(szOEBrandDLL);
        SHQueryValueEx(hk, RV_DLLPATH, NULL, NULL, (LPVOID)&szOEBrandDLL, &dwSize);
        SHCloseKey(hk);

        if (szOEBrandDLL[0] == TEXT('\0'))
            goto Exit;

        hDLL = LoadLibrary(szOEBrandDLL);
        fLoadedDLL = (hDLL != NULL);

        if (fLoadedDLL) {
            typedef HRESULT (CALLBACK *PFNCREATEACCT)(LPCSTR, DWORD);

            PFNCREATEACCT pfnCreateAcct;

            pfnCreateAcct = (PFNCREATEACCT)GetProcAddress(hDLL, "CreateAccountsFromFile");
            if (pfnCreateAcct != NULL) {
                hr = pfnCreateAcct(T2CA(g_GetIns()), 0);
                if (SUCCEEDED(hr))
                    Out(LI0(TEXT("OE branding was successful!")));
                else
                    Out(LI1(TEXT("! OE branding failed with %s"), GetHrSz(hr)));
            }
            else
                Out(LI1(TEXT("! Branding API for OE \"CreateAccountsFromFile\" is missing from \"%s\"."), szOEBrandDLL));

            FreeLibrary(hDLL);
        }
        else
            Out(LI1(TEXT("! OE branding dll \"%s\" was not found."), szOEBrandDLL));
    }
    else
        Out(LI0(TEXT("Ins file is set up. Actual OE branding will happen during signup process!")));

Exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

static HRESULT processExtRegInfSection(LPCTSTR pcszExtRegInfSect)
{   MACRO_LI_PrologEx_C(PIF_STD_C, processExtRegInfSection)

    TCHAR     szKeys[512], szValue[MAX_PATH],
              szTargetFile[MAX_PATH],
              szSection[MAX_PATH];
    LPCTSTR   pszCurKey,
              pszInfName;
    LPTSTR    pszValue,
              pszInf, pszSection;
    HINSTANCE hSetupapiDll;
    HRESULT   hr;

    hSetupapiDll = NULL;
    hr           = S_OK;

    // NOTE: (pritobla) load setupapi.dll so that if there is more than one inf to process, we can
    // avoid multiple loads and unloads.
    hSetupapiDll = LoadLibrary(TEXT("setupapi.dll"));

    GetPrivateProfileString(pcszExtRegInfSect, NULL, TEXT(""), szKeys, countof(szKeys), g_GetIns());
    for (pszCurKey = szKeys; *pszCurKey != TEXT('\0'); pszCurKey += StrLen(pszCurKey) + 1) {

        GetPrivateProfileString(pcszExtRegInfSect, pszCurKey, TEXT(""), szValue, countof(szValue), g_GetIns());
        if (*szValue == TEXT('\0'))
            continue;

        pszValue = szValue;

        //----- Inf file -----
        pszInf = StrGetNextField(&pszValue, TEXT(","), 0);
        if (pszInf != NULL && *pszInf != TEXT('\0')) {
            StrRemoveWhitespace(pszInf);

            if (*pszInf == TEXT('*')) {         // skip this, read the inf name again
                pszInf = StrGetNextField(&pszValue, TEXT(","), 0);
                if (pszInf != NULL && *pszInf != TEXT('\0'))
                    StrRemoveWhitespace(pszInf);
            }
        }

        if (pszInf == NULL || *pszInf == TEXT('\0')) {
            Out(LI1(TEXT("! Format of key \"%s\" is corrupt."), pszCurKey));
            hr = S_FALSE;
            continue;
        }

        //----- Section to execute -----
        pszSection = StrGetNextField(&pszValue, TEXT(","), 0);
        if (pszSection != NULL && *pszSection != TEXT('\0'))
            StrRemoveWhitespace(pszSection);

        if (pszSection == NULL || *pszSection == TEXT('\0'))
            pszSection = TEXT("DefaultInstall");

        StrCpy(szSection, pszSection);

        // run only the HKCU settings in the *.inf file for the per user stuff
        ASSERT(szSection[0] != TEXT('\0'));
        if (HasFlag(g_GetContext(), CTX_MISC_PERUSERSTUB))
            StrCat(szSection, TEXT(".HKCU"));

        //----- Execute *.inf file -----
        pszInfName = PathFindFileName(pszInf);
        PathCombine(szTargetFile, g_GetTargetPath(), pszInfName);
        PathAddExtension(szTargetFile, TEXT(".inf"));

        if (!PathFileExists(szTargetFile)) {
            Out(LI1(TEXT("! File \"%s\" doesn't exist."), pszInfName));
            hr = S_FALSE;
            continue;
        }

        // preprocessing hook
        if (S_OK != eriPreHook(szTargetFile, szSection, (LPARAM)pcszExtRegInfSect))
            continue;

        // BUGBUG: (pritobla) we should avoid writing to target files. if  needed, the creator of
        // the inf file can use custom ldid's.
        WritePrivateProfileString(IS_STRINGS, IK_49100, GetIEPath(), szTargetFile);
        WritePrivateProfileString(NULL, NULL, NULL, szTargetFile);

        // if HKCU section specific settings not found, revert back to the original section.
        if (HasFlag(g_GetContext(), CTX_MISC_PERUSERSTUB) &&
            InsIsSectionEmpty(szSection, szTargetFile)) {
            LPTSTR pszPerUser;                  // there is no specific HKCU section

            pszPerUser  = StrRChr(szSection, NULL, TEXT('.'));
            ASSERT(pszPerUser != NULL);
            *pszPerUser = TEXT('\0');
        }

        hr = RunSetupCommandWrap(NULL, szTargetFile, szSection, g_GetTargetPath(), NULL, NULL,
            RSC_FLAG_INF | RSC_FLAG_QUIET, 0);
        if (FAILED(hr)) {
            Out(LI3(TEXT("! Execution of section [%s] in \"%s\" failed with %s."), szSection, pszInfName, GetHrSz(hr)));
            hr = S_FALSE;
            continue;
        }
        Out(LI1(TEXT("\"%s\" processed successfully."), pszInf));

        // postprocessing hook
        eriPostHook(szTargetFile, szSection, (LPARAM)pcszExtRegInfSect);
    }

    if (hSetupapiDll != NULL)
        FreeLibrary(hSetupapiDll);

    // set adms as being done in the registry so we don't apply same preferences again

    TCHAR szAdmGuid[128];

    if (g_CtxIs(CTX_GP) &&
        InsGetString(IS_BRANDING, IK_GPE_ADM_GUID, szAdmGuid, countof(szAdmGuid), g_GetIns()))
    {
        TCHAR szKey[MAX_PATH];
        HKEY  hkAdm = NULL;

        PathCombine(szKey, RK_IEAK_GPOS, g_GetGPOGuid());
        PathAppend(szKey, RK_IEAK_ADM);
        PathAppend(szKey, szAdmGuid);
        PathAppend(szKey, g_CtxIs(CTX_MISC_CHILDPROCESS) ? IS_EXTREGINF_HKCU : IS_EXTREGINF_HKLM);
        SHCreateKey(g_GetHKCU(), szKey, KEY_DEFAULT_ACCESS, &hkAdm);
        SHCloseKey(hkAdm);
    }
        
    return hr;
}

static HRESULT eriPreHook(LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam /*= NULL*/)
{
    UNREFERENCED_PARAMETER(pszSection);

    LPCTSTR pszInfName;

    ASSERT(PathFileExists(pszInf) && pszSection != NULL && *pszSection != TEXT('\0'));
    pszInfName = PathFindFileName(pszInf);

    if (0 == StrCmpI(pszInfName, TEXT("ie4chnls.inf")))
    {
        // NOTE: (oliverl) this is done for compatibility with ie4 style channels. this inf should
        // only be run by ie4 branding dll since ie5 branding dll processes channels from ins.
        Out(LI1(TEXT("Skipping legacy inf \"%s\"..."), pszInfName));
        return S_FALSE;
    }

    else if (0 == StrCmpI(pszInfName, CONNECT_INF)) {
    // BUGBUG: (andrewgu, pritobla) a cool suggestion by pritvi. we can delay load the main ras
    // dll and in the failure hooks fall back to that crappy win95 gold thing we have to do. right
    // now this is expansive and is a perf regression. pritvi will make investigation to do this
    // ala imagehlp.dll.
        LPRASDEVINFOW prdiW;
        DWORD         cDevices;
        BOOL          fSkip,
                      fRasApisLoaded;

        prdiW          = NULL;
        fSkip          = !RasIsInstalled();
        fRasApisLoaded = FALSE;

        if (!fSkip) {
            fRasApisLoaded = (RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) && NULL != g_pfnRasSetEntryPropertiesA);
            fSkip          = !fRasApisLoaded;
        }

        if (!fSkip) {
            RasEnumDevicesExW(&prdiW, NULL, &cDevices);
            fSkip = (0 == cDevices);
        }

        if (NULL != prdiW)
            CoTaskMemFree(prdiW);

        if (fRasApisLoaded)
            RasPrepareApis(RPA_UNLOAD, FALSE);

        if (fSkip) {
            Out(LI1(TEXT("Skipping \"%s\" due to RAS configuration on the system..."), pszInfName));
            return S_FALSE;
        }

        if ((g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_PREFERENCES)) &&
            FF_DISABLE == GetFeatureBranded(FID_CS_MAIN))
            raBackup();
    }
    else if (0 == StrCmpI(pszInfName, TEXT("desktop.inf")) ||
             0 == StrCmpI(pszInfName, TEXT("toolbar.inf")))
    {
        if (IsOS(OS_NT5))
        {
            Out(LI1(TEXT("Skipping inf \"%s\" on Windows 2000..."), pszInfName));
            return S_FALSE;
        }
    }
    else if (0 == StrCmpI(pszInfName, TEXT("seczones.inf")))
    {
        if (g_CtxIsGp())
        {
            if (g_CtxIs(CTX_MISC_PREFERENCES) &&
                FF_DISABLE != GetFeatureBranded(g_CtxIs(CTX_MISC_CHILDPROCESS) ?
                                                FID_ZONES_HKCU :
                                                FID_ZONES_HKLM))
                return S_FALSE;
        }
        else
        {
            ASSERT(g_CtxIs(CTX_CORP | CTX_AUTOCONFIG | CTX_W2K_UNATTEND));

            ASSERT(lParam != NULL);

            // delete ZONES and ZONESMAP keys before applying them

            if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hklm")))
            {
                SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONES);
                SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONEMAP);
            }
            else if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hkcu")))
            {
                SHDeleteKey(g_GetHKCU(), REG_KEY_ZONES);
                SHDeleteKey(g_GetHKCU(), REG_KEY_ZONEMAP);
            }
            else    // legacy ExtRegInf section
            {
                if (!InsIsSectionEmpty(IS_IEAKADDREG_HKLM, pszInf))
                {
                    SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONES);
                    SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONEMAP);
                }

                if (!InsIsSectionEmpty(IS_IEAKADDREG_HKCU, pszInf))
                {
                    SHDeleteKey(g_GetHKCU(), REG_KEY_ZONES);
                    SHDeleteKey(g_GetHKCU(), REG_KEY_ZONEMAP);
                }
            }
        }
    }
    else if (0 == StrCmpI(pszInfName, TEXT("ratings.inf")))
    {
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && FF_DISABLE != GetFeatureBranded(FID_RATINGS))
            return S_FALSE;
    }
    else if (0 == StrCmpI(pszInfName, TEXT("authcode.inf")))
    {
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && FF_DISABLE != GetFeatureBranded(FID_AUTHCODE))
            return S_FALSE;
    }
    else if (0 == StrCmpI(pszInfName, TEXT("programs.inf")))
    {
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && FF_DISABLE != GetFeatureBranded(FID_PROGRAMS))
            return S_FALSE;
    }
    else if (0 == StrCmpI(pszInfName, TEXT("sitecert.inf")))
    {
        // do nothing
    }
    else
    {
        // check to see if our adms have been applied before since they're always treated as
        // preferences(only adms have these extra legacy sections)

        // only ADM inf's have IS_DEFAULTINSTALL_HKCU and/or IS_DEFAULTINSTALL_HKLM sections
        if (g_CtxIs(CTX_GP) &&
            (!InsIsSectionEmpty(IS_DEFAULTINSTALL_HKCU, pszInf) ||
             !InsIsSectionEmpty(IS_DEFAULTINSTALL_HKLM, pszInf)))
        {
            TCHAR szAdmGuid[128];
            TCHAR szKey[MAX_PATH];

            InsGetString(IS_BRANDING, IK_GPE_ADM_GUID, szAdmGuid, countof(szAdmGuid), g_GetIns());
            PathCombine(szKey, RK_IEAK_GPOS, g_GetGPOGuid());
            PathAppend(szKey, RK_IEAK_ADM);
            PathAppend(szKey, szAdmGuid);
            PathAppend(szKey, g_CtxIs(CTX_MISC_CHILDPROCESS) ? IS_EXTREGINF_HKCU : IS_EXTREGINF_HKLM);
            if (SHKeyExists(g_GetHKCU(), szKey) == S_OK)
                return S_FALSE;
        }
    }

    return S_OK;
}

static HRESULT eriPostHook(LPCTSTR pszInf, LPCTSTR pszSection, LPARAM lParam /*= NULL*/)
{
    UNREFERENCED_PARAMETER(pszSection);

    LPCTSTR pszInfName;
    HRESULT hr;

    ASSERT(PathFileExists(pszInf) && pszSection != NULL && *pszSection != TEXT('\0'));
    pszInfName = PathFindFileName(pszInf);
    hr         = S_OK;

    if (0 == StrCmpI(pszInfName, TEXT("ratings.inf")))
    {
        hr = ProcessRatingsPol();
        if (SUCCEEDED(hr))
            SetFeatureBranded(FID_RATINGS);
    }
    else if (0 == StrCmpI(pszInfName, TEXT("seczones.inf")))
    {
        ASSERT(lParam != NULL);
        if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hklm")))
            SetFeatureBranded(FID_ZONES_HKLM);
        else if (PathIsExtension((LPCTSTR)lParam, TEXT(".Hkcu")))
            SetFeatureBranded(FID_ZONES_HKCU);
    }
    else if (0 == StrCmpI(pszInfName, TEXT("authcode.inf")))
        SetFeatureBranded(FID_AUTHCODE);

    else if (0 == StrCmpI(pszInfName, TEXT("programs.inf")))
        SetFeatureBranded(FID_PROGRAMS);

    return hr;
}

// Removes links for the specified Target file from the specified Links path
static HRESULT deleteLinks(LPCTSTR pcszTarget, DWORD dwFolders)
{   MACRO_LI_PrologEx_C(PIF_STD_C, deleteLinks)

    HRESULT hr = S_OK;
    IShellLinkW* pShellLinkW = NULL;
    IShellLinkA* pShellLinkA = NULL;
    IPersistFile* pPersistFile = NULL;
    BOOL fUnicode = TRUE;
    LINKINFO linkInfo;

    if (pcszTarget == NULL || *pcszTarget == TEXT('\0') || dwFolders == 0)
        return E_INVALIDARG;

    // get the interfaces we need for cracking open shortcuts
    // Get a pointer to the IPersistFile interface.
    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        Out(LI1(TEXT("! Internal Error : %s."), GetHrSz(hr)));
        goto Exit;
    }

    // Get a pointer to the IShellLink interface
    hr = pPersistFile->QueryInterface(IID_IShellLinkW, (void**)&pShellLinkW);
    if (FAILED(hr))
    {
        fUnicode = FALSE;

        hr = pPersistFile->QueryInterface(IID_IShellLinkA, (void**)&pShellLinkA);
        if (FAILED(hr))
        {
            Out(LI1(TEXT("! Internal Error : %s."), GetHrSz(hr)));
            goto Exit;
        }
    }

    StrCpy(linkInfo.szTarget, pcszTarget);
    linkInfo.pPersistFile = pPersistFile;
    linkInfo.fUnicode = fUnicode;

    if (fUnicode)
        linkInfo.pShellLinkW = pShellLinkW;
    else
        linkInfo.pShellLinkA = pShellLinkA;

    if (HasFlag(dwFolders, DESKTOP_FOLDER))
        deleteLink(DESKTOP_FOLDER, &linkInfo);
    if (HasFlag(dwFolders, PROGRAMS_FOLDER))
        deleteLink(PROGRAMS_FOLDER, &linkInfo);
    if (HasFlag(dwFolders, QUICKLAUNCH_FOLDER))
        deleteLink(QUICKLAUNCH_FOLDER, &linkInfo);
    if (HasFlag(dwFolders, PROGRAMS_IE_FOLDER))
        deleteLink(PROGRAMS_IE_FOLDER, &linkInfo);
        
Exit:
    if (pPersistFile != NULL)
        pPersistFile->Release();

    if (pShellLinkW != NULL)
        pShellLinkW->Release();

    if (pShellLinkA != NULL)
        pShellLinkA->Release();

    return hr;
}

static void deleteLink(DWORD dwFolder, PLINKINFO pLinkInfo)
{   MACRO_LI_PrologEx_C(PIF_STD_C, deleteLink)

    HRESULT         hr = S_OK;
    int             nFolder;
    TCHAR           szPath[MAX_PATH];

    if (pLinkInfo == NULL || *(pLinkInfo->szTarget) == TEXT('\0'))
        return;

    if (dwFolder == QUICKLAUNCH_FOLDER)
        GetQuickLaunchPath(szPath, countof(szPath));        
    else
    {
        if (dwFolder == DESKTOP_FOLDER)
            nFolder = CSIDL_DESKTOPDIRECTORY;
        else if (dwFolder == PROGRAMS_FOLDER || dwFolder == PROGRAMS_IE_FOLDER)
            nFolder = CSIDL_PROGRAMS;
        else
            return;

        hr = SHGetFolderPathSimple(nFolder, szPath);
        if (FAILED(hr))
        {
            Out(LI2(TEXT("! SHGetFolderPath for Link %d failed with %s"), dwFolder, GetHrSz(hr)));
            return;
        }

        if (dwFolder == PROGRAMS_IE_FOLDER)
            PathAppend(szPath, TEXT("Internet Explorer"));
    }
    
    ASSERT(szPath[0] != TEXT('\0'));
    
    PathEnumeratePath(szPath, PEP_SCPE_NOFOLDERS, pepDeleteLinksEnumProc, (LPARAM)pLinkInfo);
}

HRESULT pepDeleteLinksEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    PLINKINFO pLinkInfo = (PLINKINFO) lParam;
    BOOL fDelete = FALSE;

    USES_CONVERSION;
    
    UNREFERENCED_PARAMETER(prgdwControl);

    if (pLinkInfo == NULL || pLinkInfo->pPersistFile == NULL)
        return E_INVALIDARG;

    if (pLinkInfo->fUnicode)
    {
        WCHAR wszTarget[MAX_PATH];
        WIN32_FIND_DATAW fdW;

        if (pLinkInfo->pShellLinkW == NULL)
            return E_INVALIDARG;

        fdW.dwFileAttributes = pfd->dwFileAttributes;
        fdW.ftCreationTime   = pfd->ftCreationTime;
        fdW.ftLastAccessTime = pfd->ftLastAccessTime;
        fdW.ftLastWriteTime  = pfd->ftLastWriteTime;
        fdW.nFileSizeHigh    = pfd->nFileSizeHigh;
        fdW.nFileSizeLow     = pfd->nFileSizeLow;
        fdW.dwReserved0      = pfd->dwReserved0;
        fdW.dwReserved1      = pfd->dwReserved1;
        T2Wbuf(pfd->cFileName, fdW.cFileName, countof(fdW.cFileName));
        T2Wbuf(pfd->cAlternateFileName, fdW.cAlternateFileName, countof(fdW.cAlternateFileName));

        // Load the shell link and get the path to the link target.
        if (SUCCEEDED(pLinkInfo->pPersistFile->Load(pszPath, STGM_READ)) &&
            SUCCEEDED(pLinkInfo->pShellLinkW->GetPath(wszTarget, MAX_PATH, &fdW, SLGP_SHORTPATH)))
        {
            if (StrCmpIW(fdW.cFileName, T2W(pLinkInfo->szTarget)) == 0)
                fDelete = TRUE;
        }
    }
    else
    {
        CHAR aszTarget[MAX_PATH];
        WIN32_FIND_DATAA fdA;

        if (pLinkInfo->pShellLinkA == NULL)
            return E_INVALIDARG;

        fdA.dwFileAttributes = pfd->dwFileAttributes;
        fdA.ftCreationTime   = pfd->ftCreationTime;
        fdA.ftLastAccessTime = pfd->ftLastAccessTime;
        fdA.ftLastWriteTime  = pfd->ftLastWriteTime;
        fdA.nFileSizeHigh    = pfd->nFileSizeHigh;
        fdA.nFileSizeLow     = pfd->nFileSizeLow;
        fdA.dwReserved0      = pfd->dwReserved0;
        fdA.dwReserved1      = pfd->dwReserved1;
        T2Abuf(pfd->cFileName, fdA.cFileName, countof(fdA.cFileName));
        T2Abuf(pfd->cAlternateFileName, fdA.cAlternateFileName, countof(fdA.cAlternateFileName));

        // Load the shell link and get the path to the link target.
        if (SUCCEEDED(pLinkInfo->pPersistFile->Load(pszPath, STGM_READ)) &&
            SUCCEEDED(pLinkInfo->pShellLinkA->GetPath(aszTarget, MAX_PATH, &fdA, SLGP_SHORTPATH)))
        {
            if (StrCmpIA(fdA.cFileName, T2A(pLinkInfo->szTarget)) == 0)
                fDelete = TRUE;
        }
    }

    // also delete if the filename and the target name match (this case is for files that are not link files.. ex: .scf)
    if (fDelete || StrCmpI(pfd->cFileName, pLinkInfo->szTarget) == 0)
    {
        Out(LI1(TEXT("Deleting Link File: %s"), pszPath));

        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(pszPath);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brandchl.cpp ===
#include "precomp.h"
#include <chanmgr.h>
#include <intshcut.h>                           // for IUniformResourceLocator only

// Private forward decalarations
WORD s_rgwSubGroupIDs[] = {
    0, IDS_SCHED_AUTO, IDS_SCHED_DAILY, IDS_SCHED_WEEKLY, IDS_SCHED_MONTHLY
};

#define CHLBAR_GUID TEXT("131A6951-7F78-11D0-A979-00C04FD705A2")

#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif

// private forward declarations

static HRESULT pepDeleteChanEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL */);
static void processAddChannel(LPWSTR pwszTitle, LPWSTR pwszUrl, LPWSTR pwszPreloadUrl, 
                              LPWSTR pwszLogo, LPWSTR pwszWideLogo, LPWSTR pwszIcon, 
                              BOOL fOffline, BOOL fCategory);

void ProcessRemoveAllChannels(BOOL fGPOCleanup)
{
    TCHAR szChannelFolder[MAX_PATH];

    USES_CONVERSION;

    GetChannelsPath(szChannelFolder, countof(szChannelFolder));
    
    // BUGBUG: <oliverl> we really should preserve the desktop.ini in the channels folder here
    //         however webcheck never did and we don't want the code churn right now

    if (ISNONNULL(szChannelFolder) && !fGPOCleanup)
        PathRemovePath(szChannelFolder, ADN_DONT_DEL_DIR);
    else
    {
        if (ISNULL(szChannelFolder))
            GetFavoritesPath(szChannelFolder, countof(szChannelFolder));
        
        if (ISNONNULL(szChannelFolder))
            PathEnumeratePath(szChannelFolder, PEP_SCPE_NOFILES, pepDeleteChanEnumProc, (LPARAM)fGPOCleanup);
    }
}

// Channels the whole mess, can be one of the following:
// one channel, or category with many channels, or many channels, or many categories and channels
HRESULT lcy4x_ProcessChannels()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessChannels)

    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH],
            szBuf[MAX_PATH + countof(FILEPREFIX)],
            szLogo[MAX_PATH + countof(FILEPREFIX)],
            szWideLogo[MAX_PATH + countof(FILEPREFIX)],
            szIcon[MAX_PATH + countof(FILEPREFIX)],
            szPreloadUrl[MAX_PATH + countof(FILEPREFIX)],
            szTitle[MAX_PATH],
            szEntry[32],
            szIndex[17],
            szCustomKey[16];
    LPCTSTR pszWebPath,
            pszPrefix, pszFormat,
            pszFileName;
    LPTSTR  pszTitle;
    HKEY    hk;
    HRESULT hr;
    DWORD   dwVal;
    LONG    lResult;
    UINT    nCategoryLen,
            nTitleLen, nUrlLen, nLen;
    int     i,
            iMode;
    BOOL    fCategory, 
            fOffline = FALSE;

    USES_CONVERSION;

    CreateWebFolder();
    GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szCustomKey, countof(szCustomKey), g_GetIns());

    // BUGBUG: (andrewgu) Is this needed at all?
    wnsprintf(szEntry, countof(szEntry), TEXT("Channel%s"), szCustomKey);
    SHDeleteValue(g_GetHKCU(), RK_COMPLETED_MODIFICATIONS, szEntry);

    if (InsGetBool(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, g_GetIns())) 
    {
       Out(LI0(TEXT("Deleting regular old channels...\r\n")));
       ProcessRemoveAllChannels(FALSE);
    }

    pszWebPath = GetWebPath();

    hr    = S_OK;
    dwVal = 1;

    fCategory    = InsGetBool(IS_CHANNEL_ADD, IK_CATEGORY, FALSE, g_GetIns());
    pszTitle     = szTitle;
    nCategoryLen = 0;
    if (fCategory) {
        nCategoryLen = GetPrivateProfileString(IS_CHANNEL_ADD, IK_CAT_TITLE, TEXT(""), szTitle, sizeof(szTitle), g_GetIns());
        ASSERT(nCategoryLen > 0);

        PathAddBackslash(szTitle);
        pszTitle = &szTitle[++nCategoryLen];
    }

    //----- Initialize the mode -----
    // NOTE: (andrewgu) These are the possible modes:
    // 0 - not clear or has not been determined yet;
    // 1 - there will be only one channel (no channel tag indeces);
    // 2 - there will be one category (no category indeces) and mulitple channels;
    // 3 - interim state to process the single category, mentioned in mode 2.
    // 4 - (new) mulitple channels with or without categories;
    // 5 - (new) mulitple categories, processed after all channels in mode 4.

    iMode = 0;
    if (fCategory) {
        iMode = 2;

#ifdef _DEBUG                                   // confirm the mode
        StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], TEXT("0"));
        ASSERT(!InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns()));
#endif
    }
    else /* if (!fCategory) */
        if (!InsIsKeyEmpty(IS_CHANNEL_ADD, IK_CHL_TITLE, g_GetIns()))
            iMode = 1;

        else { /* if (blah == 0) */
            StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], TEXT("0"));
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns())) {
                Out(LI0(TEXT("There are no channels to add!")));
                goto Exit;                      // there are no channels at all
            }

            iMode = 4;
        }
    Out(LI1(TEXT("Initial processing mode is %i."), iMode));

    //----- Channel bar size processing -----
    // NOTE: (andrewgu) the following block is a fix for bug 63410 in IE 4.01 db.
    DWORD dwChannelBarSize,
          dwSize;

    lResult = SHCreateKey(g_GetHKCU(), RK_IE_DESKTOP, KEY_QUERY_VALUE | KEY_SET_VALUE, &hk);
    if (lResult == ERROR_SUCCESS) {
        dwChannelBarSize = 13;                  // if registry call fails
        dwSize = sizeof(dwChannelBarSize);
        RegQueryValueEx(hk, RV_CHLBAR_SIZE, NULL, NULL, (LPBYTE)&dwChannelBarSize, &dwSize);

        dwChannelBarSize++;
        RegSetValueEx(hk, RV_CHLBAR_SIZE, 0, REG_DWORD, (LPBYTE)&dwChannelBarSize, dwSize);
        SHCloseKey(hk);
    }

    //----- Main processing loop -----
    for (i = 0; i < MAX_CHAN; i++) 
    {
        ASSERT(iMode > 0);
        if (iMode == 1) {
            szIndex[0] = TEXT('\0');

            if (i > 0)
                break;                          // only one channel is allowed
        }
        else if (iMode == 2) {
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

            StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], szIndex);
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns())) {
                iMode = 3;
                szIndex[0] = TEXT('\0');
            }
        }
        else if (iMode == 3)
            break;                              // there can be only one category

        else if (iMode == 4) {
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

            StrCpy(szEntry, IK_CHL_TITLE); StrCpy(&szEntry[countof(IK_CHL_TITLE) - 1], szIndex);
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns())) {
                iMode =  5;
                i     = -1;
                continue;
            }

        }
        else if (iMode == 5) {
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

            StrCpy(szEntry, IK_CAT_TITLE); StrCpy(&szEntry[countof(IK_CAT_TITLE) - 1], szIndex);
            if (InsIsKeyEmpty(IS_CHANNEL_ADD, szEntry, g_GetIns()))
                break;                          // the end
        }

        MACRO_LI_Offset(1);
        Out(LI1(TEXT("\r\nMain processing loop with mode %d."), iMode));

        // Note. This is kind of hacky, but mode 5. is the only one when index in the *.ins is not
        // equal to the index that will be used in the registry.
        if (iMode == 5)
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i + MAX_CHAN);
        if (iMode == 5)
            wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i);

        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            Out(LI0(TEXT("Adding channel with the following attributes:")));
            pszPrefix = FILEPREFIX;
        }
        else {
            ASSERT(iMode == 3 || iMode == 5);
            Out(LI0(TEXT("Adding category with the following attributes:")));
            pszPrefix = NULL;
        }

        { MACRO_LI_Offset(1);                   // need a new scope

        // Title
        pszFormat = NULL;
        nLen      = 0;

        if (iMode == 1 || iMode == 2 || iMode == 4) {
            pszFormat = IK_CHL_TITLE;
            nLen      = countof(IK_CHL_TITLE) - 1;
        }
        else if (iMode == 5) {
            pszFormat = IK_CAT_TITLE;
            nLen      = countof(IK_CAT_TITLE) - 1;
        }
        else
            ASSERT(iMode == 3);

        if (iMode != 3) 
        {
            StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
            nLen       = MAX_PATH - (fCategory ? nCategoryLen + 1: 0);
            nTitleLen  = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), pszTitle, nLen, g_GetIns());
            nTitleLen += fCategory ? nCategoryLen + 1 : 0;
        }
        else { /* if (iMode == 3) */
            ASSERT(fCategory);

            pszTitle  = szTitle;                  // change to category name
            szTitle[--nCategoryLen] = TEXT('\0'); // properly zero-terminate
            nTitleLen = nCategoryLen;
        }
        Out(LI1(TEXT("Title          - \"%s\","), pszTitle));

        // URL
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            pszFormat = IK_CHL_URL;
            nLen      = countof(IK_CHL_URL) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_URL;
            nLen      = countof(IK_CAT_URL) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nUrlLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szUrl, countof(szUrl), g_GetIns());
        if (iMode == 3 || iMode == 5) 
        {
            ASSERT(nUrlLen > 0 && nUrlLen < MAX_PATH);
            pszFileName = PathFindFileName(szUrl);
           
            PathCombine(szBuf, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szBuf));

            StrCpy(szUrl, szBuf);
            nUrlLen = StrLen(szUrl);
        }
        Out(LI1(TEXT("URL            - \"%s\","), szUrl));

        // Preload URL
        *szPreloadUrl = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            StrCpy(szEntry, IK_CHL_PRELOADURL); StrCpy(&szEntry[countof(IK_CHL_PRELOADURL) - 1], szIndex);
            nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
            if (nLen > 0) {
                pszFileName = PathFindFileName(szBuf);

                PathCombine(szPreloadUrl, pszWebPath, pszFileName);
                ASSERT(PathFileExists(szPreloadUrl));

                nLen = StrPrepend(szPreloadUrl, countof(szPreloadUrl), pszPrefix);
                Out(LI1(TEXT("Preload URL    - \"%s\","), szPreloadUrl));
            }
            else
                Out(LI0(TEXT("- Without a Preload URL,")));
        }

        // Logo
        *szLogo = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            pszFormat = IK_CHL_LOGO;
            nLen      = countof(IK_CHL_LOGO) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_LOGO;
            nLen      = countof(IK_CAT_LOGO) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) 
        {
            pszFileName = PathFindFileName(szBuf);
            
            PathCombine(szLogo, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szLogo));

            nLen = StrPrepend(szLogo, countof(szLogo), pszPrefix);
            Out(LI1(TEXT("Logo file      - \"%s\","), szLogo));
        }
        else
            Out(LI0(TEXT("- Without a Logo file,")));

        // Wide Logo
        *szWideLogo = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4)
        {
            pszFormat = IK_CHL_WIDELOGO;
            nLen      = countof(IK_CHL_WIDELOGO) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_WIDELOGO;
            nLen      = countof(IK_CAT_WIDELOGO) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) 
        {
            pszFileName = PathFindFileName(szBuf);

            PathCombine(szWideLogo, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szWideLogo));

            nLen = StrPrepend(szWideLogo, countof(szWideLogo), pszPrefix);
            Out(LI1(TEXT("Wide Logo file - \"%s\","), szWideLogo));
        }
        else
            Out(LI0(TEXT("- Without a Wide Logo file,")));

        // Icon
        *szIcon = TEXT('\0');
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            pszFormat = IK_CHL_ICON;
            nLen      = countof(IK_CHL_ICON) - 1;
        }
        else 
        { /* if (iMode == 3 || iMode == 5) */
            pszFormat = IK_CAT_ICON;
            nLen      = countof(IK_CAT_ICON) - 1;
        }

        StrCpy(szEntry, pszFormat); StrCpy(&szEntry[nLen], szIndex);
        nLen = GetPrivateProfileString(IS_CHANNEL_ADD, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) 
        {
            pszFileName = PathFindFileName(szBuf);

            PathCombine(szIcon, pszWebPath, pszFileName);
            ASSERT(PathFileExists(szIcon));

            nLen = StrPrepend(szIcon, countof(szIcon), pszPrefix);

            if (iMode == 1 || iMode == 2 || iMode == 4)
                Out(LI1(TEXT("Icon file      - \"%s\","), szIcon));
            else /* if (iMode == 3 || iMode == 5) */
                Out(LI1(TEXT("Icon file      - \"%s\"."), szIcon));
        }
        else
            if (iMode == 1 || iMode == 2 || iMode == 4)
                Out(LI0(TEXT("- Without an Icon file,")));
            else /* if (iMode == 3 || iMode == 5) */
                Out(LI0(TEXT("- Without an Icon file.")));

        // Make available offline flag (will be made available offline right away)
        if (iMode == 1 || iMode == 2 || iMode == 4) 
        {
            StrCpy(szEntry, IK_CHL_OFFLINE); StrCpy(&szEntry[countof(IK_CHL_OFFLINE) - 1], szIndex);

            fOffline = InsGetBool(IS_CHANNEL_ADD, szEntry, FALSE, g_GetIns());
            if (fOffline) 
                Out(LI0(TEXT("Avaliable offline.")));
            else
                Out(LI0(TEXT("NOT made avaliable offline.")));
        }

        // Subscription state(this is only for legacy IE4 format)

        if (iMode == 1 || iMode == 2 || iMode == 4) {
            int iIndex;

            iIndex = GetPrivateProfileInt(IS_CHANNEL_ADD, IK_CHL_SBN_INDEX, 0, g_GetIns());
            if (iIndex > 0) {
                TCHAR szGroup[80];
                TCHAR szKey[MAX_PATH];
                HKEY  hkSbn;

                nLen = LoadString(g_GetHinst(), s_rgwSubGroupIDs[iIndex], szGroup, countof(szGroup));
                wnsprintf(szKey, countof(szKey), RK_SUBSCRIPTION_ADD, szCustomKey, szIndex);

                lResult = SHCreateKey(g_GetHKCU(), szKey, KEY_SET_VALUE, &hkSbn);
                if (lResult == ERROR_SUCCESS) {
                    RegSetValueEx(hkSbn, RV_URL,              0, REG_SZ,    (LPBYTE)szUrl,   StrCbFromCch(nUrlLen+1));
                    RegSetValueEx(hkSbn, RV_TITLE,            0, REG_SZ,    (LPBYTE)szTitle, StrCbFromCch(nTitleLen+1));
                    RegSetValueEx(hkSbn, RV_SUBSCRIPTIONTYPE, 0, REG_DWORD, (LPBYTE)&dwVal,  sizeof(dwVal));
                    RegSetValueEx(hkSbn, RV_SCHEDULEGROUP,    0, REG_SZ,    (LPBYTE)szGroup, StrCbFromCch(nLen+1));
                    SHCloseKey(hkSbn);

                    Out(LI1(TEXT("Subscription is based on \"%s\" schedule..."), szGroup));
                }
            }
        }

        // add this channel/category

        processAddChannel(T2W(pszTitle), T2W(szUrl), T2W(szPreloadUrl), T2W(szLogo), 
            T2W(szWideLogo), T2W(szIcon), fOffline, !(iMode == 1 || iMode == 2 || iMode == 4));
        

        }  // end offset scope

        Out(LI0(TEXT("Done.")));
    }

Exit:
    if (SUCCEEDED(hr))
        SetFeatureBranded(FID_LCY4X_CHANNELS);
    return hr;
}

HRESULT lcy4x_ProcessSoftwareUpdateChannels()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessSoftwareUpdateChannels)

    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH],
            szBuf[MAX_PATH + countof(FILEPREFIX)],
            szSourceFile[MAX_PATH + countof(FILEPREFIX)], szTargetFile[MAX_PATH + countof(FILEPREFIX)],
            szKey[MAX_PATH],
            szTitle[MAX_PATH],
            szEntry[32],
            szIndex[17],
            szCustomKey[16];
    LPCTSTR pszTargetPath,
            pszWebPath,
            pszFileName;
    HKEY    hk;
    HRESULT hr;
    DWORD   dwVal;
    LONG    lResult;
    UINT    nTitleLen, nUrlLen, nLen;
    int     i, iNumChannels,
            iIndex;

    CreateWebFolder();

    pszTargetPath = g_GetTargetPath();
    pszWebPath    = GetWebPath();
    GetPrivateProfileString(IS_BRANDING, IK_CUSTOMKEY, TEXT(""), szCustomKey, countof(szCustomKey), g_GetIns());

    hr = S_OK;

    if (InsGetBool(IS_SOFTWAREUPDATES, IK_DELETECHANNELS, FALSE, g_GetIns())) {
        wnsprintf(szKey, countof(szKey), RK_CHANNEL_DEL TEXT("\\IEAKCleanUp"), szCustomKey);
        dwVal = 1;
        SHSetValue(g_GetHKCU(), szKey, RV_CHANNELGUIDE, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal));
        Out(LI0(TEXT("Deleting old software updates channels...\r\n")));
    }

    dwVal = 0;
    iNumChannels = GetPrivateProfileInt(IS_SOFTWAREUPDATES, IK_NUMFILES, 0, g_GetIns());
    for (i = 0; i < iNumChannels; i++) {
        MACRO_LI_Offset(1);
        if (i > 0)
            Out(LI0(TEXT("\r\n")));
        Out(LI0(TEXT("Adding software update channel with the following attributes:")));

        // Note. Needed to make sure that channels and software updates don't step on each other toes.
        wnsprintf(szIndex, countof(szIndex), TEXT("%u"), i + 2*MAX_CHAN);
        wnsprintf(szKey, countof(szKey), RK_CHANNEL_ADD, szCustomKey, szIndex);

        lResult = SHCreateKey(g_GetHKCU(), szKey, KEY_SET_VALUE, &hk);
        if (lResult != ERROR_SUCCESS) {
            hr = S_FALSE;                       // at least one failed
            continue;
        }

        // Title
        wnsprintf(szEntry, countof(szEntry), IK_TITLE_FMT, i);
        nTitleLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szTitle, countof(szTitle), g_GetIns());
        RegSetValueEx(hk, RV_TITLE, 0, REG_SZ, (LPBYTE)szTitle, StrCbFromCch(nTitleLen+1));
        Out(LI1(TEXT("Title          - \"%s\","), szTitle));

        // URL
        wnsprintf(szEntry, countof(szEntry), IK_URL_FMT, i);
        nUrlLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szUrl, countof(szUrl), g_GetIns());
        RegSetValueEx(hk, RV_URL, 0, REG_SZ, (LPBYTE)szUrl, StrCbFromCch(nUrlLen+1));
        Out(LI1(TEXT("URL            - \"%s\","), szUrl));

        // Preload URL
        wnsprintf(szEntry, countof(szEntry), IK_PRELOADURL_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_PRELOADURL, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Preload URL    - \"%s\","), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without a Preload URL,")));

        // Logo
        wnsprintf(szEntry, countof(szEntry), IK_LOGO_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_LOGO, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Logo file      - \"%s\","), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without a Logo file,")));

        // Wide Logo
        wnsprintf(szEntry, countof(szEntry), IK_WIDELOGO_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_LOGO, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Wide Logo file - \"%s\","), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without a Wide Logo file,")));

        // Icon
        wnsprintf(szEntry, countof(szEntry), IK_ICON_FMT, i);
        nLen = GetPrivateProfileString(IS_SOFTWAREUPDATES, szEntry, TEXT(""), szBuf, countof(szBuf), g_GetIns());
        if (nLen > 0) {
            pszFileName = PathFindFileName(szBuf);
            PathCombine(szSourceFile, pszTargetPath, pszFileName);
            ASSERT(PathFileExists(szSourceFile));

            PathCombine(szTargetFile, pszWebPath, pszFileName);
            ASSERT(!PathFileExists(szTargetFile));

            MoveFile(szSourceFile, szTargetFile);
            nLen = StrPrepend(szTargetFile, countof(szTargetFile), FILEPREFIX);
            RegSetValueEx(hk, RV_ICON, 0, REG_SZ, (LPBYTE)szTargetFile, StrCbFromCch(nLen+1));
            Out(LI1(TEXT("Icon file      - \"%s\"."), szTargetFile));
        }
        else
            Out(LI0(TEXT("- Without an Icon file.")));

        // Subscription state
        iIndex = GetPrivateProfileInt(IS_SOFTWAREUPDATES, IK_SBN_INDEX, 0, g_GetIns());
        if (iIndex > 0) {
            TCHAR szGroup[80];
            HKEY  hkSbn;

            nLen = LoadString(g_GetHinst(), s_rgwSubGroupIDs[iIndex], szGroup, countof(szGroup));
            wnsprintf(szKey, countof(szKey), RK_SUBSCRIPTION_ADD, szKey, szIndex);

            lResult = SHCreateKey(g_GetHKCU(), szKey, KEY_SET_VALUE, &hkSbn);
            if (lResult == ERROR_SUCCESS) {
                RegSetValueEx(hkSbn, RV_URL,              0, REG_SZ,    (LPBYTE)szUrl,   StrCbFromCch(nUrlLen+1));
                RegSetValueEx(hkSbn, RV_TITLE,            0, REG_SZ,    (LPBYTE)szTitle, StrCbFromCch(nTitleLen+1));
                RegSetValueEx(hkSbn, RV_SUBSCRIPTIONTYPE, 0, REG_DWORD, (LPBYTE)&dwVal,  sizeof(dwVal));
                RegSetValueEx(hkSbn, RV_SCHEDULEGROUP,    0, REG_SZ,    (LPBYTE)szGroup, StrCbFromCch(nLen+1));
                SHCloseKey(hkSbn);

                Out(LI1(TEXT("Subscription is based on \"%s\" schedule..."), szGroup));
            }
        }

        // the most important one
        RegSetValueEx(hk, RV_SOFTWARE, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal));
        SHCloseKey(hk);

        Out(LI0(TEXT("Done.")));
    }

    if (iNumChannels == 0)
        Out(LI0(TEXT("There are no software update channels to add!")));

    return hr;
}


// Execute actual processing of channels by calling Webcheck DllInstall
HRESULT lcy4x_ProcessWebcheck()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessWebcheck)

    typedef HRESULT (WINAPI *DLLINSTALL)(BOOL, LPCWSTR);

    DLLINSTALL pfnDllInstall;
    HINSTANCE  hWebcheckDll;
    HRESULT    hr;

    hWebcheckDll = NULL;
    hr           = E_FAIL;

    hWebcheckDll = LoadLibrary(TEXT("webcheck.dll"));
    if (hWebcheckDll == NULL) {
        Out(LI0(TEXT("! \"webcheck.dll\" could not be loaded.")));
        goto Exit;
    }

    pfnDllInstall = (DLLINSTALL)GetProcAddress(hWebcheckDll, "DllInstall");
    if (pfnDllInstall == NULL) {
        Out(LI0(TEXT("! \"DllInstall\" in webcheck.dll was not found.")));
        goto Exit;
    }

    hr = pfnDllInstall(TRUE, L"policy");
    Out(LI1(TEXT("\"DllInstall\" in webcheck.dll returned %s."), GetHrSz(hr)));

Exit:
    if (hWebcheckDll != NULL)
        FreeLibrary(hWebcheckDll);

    return S_OK;
}

// Show channel bar on the desktop (used for NT mainly)
HRESULT lcy4x_ProcessChannelBar()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessChannelBar)

    HRESULT hr;
    BOOL    fActiveDesktop;

    hr = E_FAIL;

    fActiveDesktop = FALSE;
    SHGetSetActiveDesktop(FALSE, &fActiveDesktop);

    if (!(fActiveDesktop && HasFlag(WhichPlatform(), PLATFORM_INTEGRATED))) {
        SHSetValue(g_GetHKCU(), RK_IE_MAIN, RV_SHOWCHANNELBAND, REG_SZ, TEXT("yes"), StrCbFromCch(4));
        Out(LI0(TEXT("Channel bar on the desktop in now enabled!")));
    }
    else {
        TCHAR szSubkey[MAX_PATH],
              szGuid[128];
        HKEY  hk, hkSubkey;
        DWORD dwSize,
              dwSubkey;
        BOOL  fFound;

        fFound = FALSE;

        if (ERROR_SUCCESS != SHOpenKey(g_GetHKCU(), RK_DT_COMPONENTS, KEY_ENUMERATE_SUB_KEYS, &hk)) {
            Out(LI0(TEXT("! Internal failure.")));
            goto Exit;
        }

        for (dwSubkey = 0, dwSize = countof(szSubkey);
             ERROR_SUCCESS == RegEnumKeyEx(hk, dwSubkey, szSubkey, &dwSize, NULL, NULL, NULL, NULL);
             dwSubkey++,   dwSize = countof(szSubkey)) {

            if (ERROR_SUCCESS != SHOpenKey(hk, szSubkey, KEY_READ | KEY_SET_VALUE, &hkSubkey))
                continue;

            dwSize = sizeof(szGuid);
            if (ERROR_SUCCESS == RegQueryValueEx(hkSubkey, RV_SOURCE, NULL, NULL, (LPBYTE)szGuid, &dwSize))
                if (0 == StrCmpI(szGuid, CHLBAR_GUID)) {
                    DWORD dwFlags;

                    dwFlags = 0;
                    dwSize  = sizeof(dwFlags);
                    RegQueryValueEx(hkSubkey, RV_FLAGS, NULL, NULL, (LPBYTE)&dwFlags, &dwSize);

                    dwFlags |= RD_CHLBAR_ENABLE;
                    RegSetValueEx(hkSubkey, RV_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, dwSize);

                    fFound = TRUE;
                    break;
                }

            SHCloseKey(hkSubkey);
        }

        SHCloseKey(hk);

        if (fFound)
            Out(LI0(TEXT("Channel bar on the desktop in now enabled!")));
        else
            Out(LI0(TEXT("! Channel bar is not found in the list of Active Desktop components.")));
            
    }

    hr = S_OK;

Exit:
    return hr;
}

HRESULT lcy4x_ProcessSubscriptions()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy4x_ProcessSubscriptions)

    const PROPSPEC c_PropSub = { PRSPEC_PROPID, PID_INTSITE_SUBSCRIPTION};

    IUniformResourceLocator *purl;
    IPropertySetStorage     *ppss;
    IPropertyStorage        *pps;
    PROPVARIANT             pvGuid;
    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH],
            szBuf[1024],
            szSchedKey[MAX_PATH];
    WCHAR   wszGuid[128];
    LPTSTR  pszGuid;
    HRESULT hr;

    ppss = NULL;
    pps  = NULL;

    GetPrivateProfileString(IS_SUBSCRIPTIONS, NULL, NULL, szBuf, countof(szBuf), g_GetIns());
    for (pszGuid = szBuf; *pszGuid != TEXT('\0'); pszGuid += StrLen(pszGuid) + 1) {
        wnsprintf(szSchedKey, countof(szSchedKey), RK_SCHEDITEMS, pszGuid);
        if (S_OK != SHKeyExists(g_GetHKCU(), szSchedKey))
            continue;

        GetPrivateProfileString(IS_SUBSCRIPTIONS, pszGuid, TEXT(""), szUrl, countof(szUrl), g_GetIns());
        if (szUrl[0] == TEXT('\0'))
            continue;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                IID_IUniformResourceLocator, (LPVOID *)&purl);

        if (SUCCEEDED(hr)) {
            ASSERT(purl != NULL);
            hr = purl->SetURL(szUrl, 0);
        }

        if (SUCCEEDED(hr)) {
            hr = purl->QueryInterface(IID_IPropertySetStorage, (LPVOID *)&ppss);
            purl->Release();
        }

        if (SUCCEEDED(hr)) {
            ASSERT(ppss != NULL);
            hr = ppss->Open(FMTID_InternetSite, STGM_READWRITE, &pps);
            ppss->Release();
        }

        if (SUCCEEDED(hr)) {
            T2Wbuf(pszGuid, wszGuid, countof(wszGuid));

            pvGuid.vt      = VT_LPWSTR;
            pvGuid.pwszVal = wszGuid;

            ASSERT(pps != NULL);
            hr = pps->WriteMultiple(1, &c_PropSub, &pvGuid, 0);
            pps->Commit(STGC_DEFAULT);
            pps->Release();
        }
    }

    return S_OK;
}

// private helper functions
static HRESULT pepDeleteChanEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL */)
{
    TCHAR szDesktopIni[MAX_PATH];

    UNREFERENCED_PARAMETER(prgdwControl);
    UNREFERENCED_PARAMETER(pfd);

    PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

    // only remove the path if this is a channel and we're deleting channels or if this
    // is a GP created channel and we're cleaning. lParam is flag to determine whether or
    // not we're cleaning GP channels(TRUE if we are)

    if ((!InsIsSectionEmpty(CHANNEL_SECT, szDesktopIni) || 
        !InsIsKeyEmpty(SHELLCLASSINFO, WIDELOGO, szDesktopIni)) &&
        (!(BOOL)lParam || !InsIsKeyEmpty(IS_BRANDING, IEAK_GP_MANDATE, szDesktopIni)))
        PathRemovePath(pszPath);

    return S_OK;
}


static void processAddChannel(LPWSTR pwszTitle, LPWSTR pwszUrl, LPWSTR pwszPreloadUrl, 
                              LPWSTR pwszLogo, LPWSTR pwszWideLogo, LPWSTR pwszIcon, 
                              BOOL fOffline, BOOL fCategory)
{
    IChannelMgr *pChannelMgr = NULL;
    HRESULT hr;
    
    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, (void**)&pChannelMgr);
    if (SUCCEEDED(hr))
    {
        // See if channel already exists - do nothing if it does (62976)
        // this takes care of preference channels in group policy as well
        IEnumChannels *pEnumChannels = NULL;
        if (SUCCEEDED(pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS, pwszUrl, &pEnumChannels)))
        {
            CHANNELENUMINFO Bogus={0};
            ULONG cFetched=0;
            
            if ((S_OK == pEnumChannels->Next(1, &Bogus, &cFetched)) && cFetched)
            {
                // Oops. It exists. Skip all this goo.
                hr = E_FAIL;
            }
        }
        SAFERELEASE(pEnumChannels);
    }
    if (SUCCEEDED(hr))
    {
        if (fCategory)
        {
            // create a category 
            CHANNELCATEGORYINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = pwszUrl;
            csi.pszTitle = pwszTitle;
            csi.pszLogo  = ISNONNULL(pwszLogo) ? T2W(pwszLogo) : NULL;
            csi.pszIcon  = ISNONNULL(pwszIcon) ? T2W(pwszIcon) : NULL;
            csi.pszWideLogo = ISNONNULL(pwszWideLogo) ? T2W(pwszWideLogo) : NULL;
            hr = pChannelMgr->AddCategory(&csi);
        }
        else 
        {
            // tell wininet if there's preload content
            if (ISNONNULL(pwszPreloadUrl))
            {
                SHSetValue(g_GetHKCU(), RK_INETSETTINGS TEXT("\\Cache\\Preload"), pwszUrl,
                    REG_SZ, (LPBYTE)pwszPreloadUrl, (DWORD)StrCbFromSzW(pwszPreloadUrl));
            }
            // create a channel (use URL instead of Title if code page doesn't match)
            CHANNELSHORTCUTINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = pwszUrl;
            csi.pszTitle = pwszTitle;
            csi.pszLogo  = ISNONNULL(pwszLogo) ? T2W(pwszLogo) : NULL;
            csi.pszIcon  = ISNONNULL(pwszIcon) ? T2W(pwszIcon) : NULL;
            csi.pszWideLogo = ISNONNULL(pwszWideLogo) ? T2W(pwszWideLogo) : NULL;
            hr = pChannelMgr->AddChannelShortcut(&csi);
        }

        // mark this channel/category if it's from a mandate GPO
        
        if (g_CtxIsGp() && !g_CtxIs(CTX_MISC_PREFERENCES))
        {
            static TCHAR s_szChannelIni[MAX_PATH];
            static LPTSTR pszChan = NULL;
            static DWORD s_dwMaxChanLen;

            if (pszChan == NULL)
            {
                GetChannelsPath(s_szChannelIni, countof(s_szChannelIni));
                if (ISNULL(s_szChannelIni))
                    GetFavoritesPath(s_szChannelIni, countof(s_szChannelIni));
                if (ISNONNULL(s_szChannelIni))
                {
                    pszChan = PathAddBackslash(s_szChannelIni);
                    s_dwMaxChanLen = countof(s_szChannelIni) - StrLen(s_szChannelIni);
                }
            }
            
            if (pszChan != NULL)
            {
                DWORD dwAttrib;

                PathRemoveBackslashW(pwszTitle);
                wnsprintf(pszChan, s_dwMaxChanLen, TEXT("%s\\desktop.ini"), W2CT(pwszTitle));
                dwAttrib = GetFileAttributes(s_szChannelIni);
                SetFileAttributes(s_szChannelIni, FILE_ATTRIBUTE_NORMAL);
                InsWriteBool(IS_BRANDING, IEAK_GP_MANDATE, TRUE, s_szChannelIni);
                InsFlushChanges(s_szChannelIni);
                SetFileAttributes(s_szChannelIni, dwAttrib);
            }
        }
    }
    SAFERELEASE(pChannelMgr);
    
    if (fOffline)
    {
        ISubscriptionMgr2 *pSubMgr2 = NULL;
        hr = CoCreateInstance(CLSID_SubscriptionMgr, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_ISubscriptionMgr2, 
            (void**)&pSubMgr2);
        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONINFO si;
            
            ZeroMemory(&si, sizeof(si));
            si.cbSize       = sizeof(SUBSCRIPTIONINFO);
            si.fUpdateFlags = SUBSINFO_SCHEDULE;
            si.schedule     = SUBSSCHED_MANUAL;

            hr = pSubMgr2->CreateSubscription(NULL, 
                pwszUrl, 
                pwszTitle, 
                CREATESUBS_NOUI,
                SUBSTYPE_CHANNEL, 
                &si);
            
            if (SUCCEEDED(hr))
            {
                ISubscriptionItem *pSubItem = NULL;
                
                hr = pSubMgr2->GetItemFromURL(pwszUrl, &pSubItem);
                if (SUCCEEDED(hr))
                {
                    SUBSCRIPTIONCOOKIE cookie;
                    
                    hr = pSubItem->GetCookie(&cookie);
                    if (SUCCEEDED(hr))
                        pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &cookie);
                }
            }
            
            pSubMgr2->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brandaux.cpp ===
#include "precomp.h"

// Private forward decalarations
#define WM_DO_UPDATEALL (WM_USER + 338)

#define TRUSTED_PUB_FLAG    0x00040000

LPCTSTR rtgGetRatingsFile(LPTSTR pszFile = NULL, UINT cch = 0);
void broadcastSettingsChange(LPVOID lpVoid);

// NOTE: (andrewgu) i haven't touched these functions. i merely ported them and moved them around.
BOOL rtgIsRatingsInRegistry();
void rtgRegMoveRatings();

BOOL IsInGUIModeSetup();


HRESULT ProcessZonesReset()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessZonesReset)

    HINSTANCE hUrlmonDLL;

    Out(LI0(TEXT("\r\nProcessing reset of zones settings...")));

    // Don't write to HKCU if in GUI-mode setup
    if (IsInGUIModeSetup())
    {
        Out(LI0(TEXT("\r\nIn GUI mode setup, skipping urlmon HKCU settings")));
        goto quit;
    }

    if ((hUrlmonDLL = LoadLibrary(TEXT("urlmon.dll"))) != NULL)
    {
        HRESULT hr;

        hr = RegInstall(hUrlmonDLL, "IEAKReg.HKCU", NULL);
        Out(LI1(TEXT("\"RegInstall\" on \"IEAKReg.HKCU\" in \"urlmon.dll\" returned %s."), GetHrSz(hr)));

        FreeLibrary(hUrlmonDLL);
    }
    else
        Out(LI0(TEXT("! \"urlmon.dll\" could not be loaded.")));

quit:
    Out(LI0(TEXT("Done.")));

    return S_OK;
}

HRESULT ProcessRatingsPol()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRatingsPol)

    LPCTSTR pszRatingsFile;
    HKEY    hk;
    LONG    lResult;

    if (rtgIsRatingsInRegistry())
        return S_OK;

    pszRatingsFile = rtgGetRatingsFile();
    SetFileAttributes(pszRatingsFile, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(pszRatingsFile);

    rtgRegMoveRatings();

    lResult = SHCreateKeyHKLM(RK_IEAKPOLICYDATA, KEY_SET_VALUE, &hk);
    if (lResult == ERROR_SUCCESS) {
        SHDeleteValue(hk, RK_USERS, RV_KEY);

        RegSaveKey (hk, pszRatingsFile, NULL);
        SHCloseKey (hk);
        SHDeleteKey(HKEY_LOCAL_MACHINE, RK_IEAKPOLICYDATA);
    }

    return S_OK;
}

// NOTE: (pritobla) if TrustedPublisherLockdown restriction is set via inetres.inf and in order
// for this restriction to work, we have to call regsvr32 /i:"S 10 TRUE" initpki.dll
HRESULT ProcessTrustedPublisherLockdown()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessTrustedPublisherLockdown)

    DWORD      dwVal, dwSize, dwState;

    ASSERT(SHValueExists(HKEY_LOCAL_MACHINE, RK_POLICES_RESTRICTIONS, RV_TPL));
    dwVal    = 0;
    dwSize   = sizeof(dwVal);
    SHGetValue(HKEY_LOCAL_MACHINE, RK_POLICES_RESTRICTIONS, RV_TPL, NULL, &dwVal, &dwSize);

    // check the new location, if either location is set then we need to set trusted publisher
    // lockdown

    dwVal = InsGetBool(IS_SITECERTS, IK_TRUSTPUBLOCK, FALSE, g_GetIns()) ? 1 : dwVal;

    dwSize = sizeof(dwState);

    if (SHGetValue(g_GetHKCU(), REG_KEY_SOFTPUB, REG_VAL_STATE, NULL, &dwState, &dwSize) == ERROR_SUCCESS)
    {
        Out(LI1(TEXT("Trusted publisher lockdown will be %s!"), dwVal ? TEXT("set") : TEXT("cleared")));
        
        if (dwVal)
            dwState |= TRUSTED_PUB_FLAG;
        else
            dwState &= ~TRUSTED_PUB_FLAG;

        SHSetValue(g_GetHKCU(), REG_KEY_SOFTPUB, REG_VAL_STATE, REG_DWORD, &dwState, sizeof(dwState));
    }

    return S_OK;
}

// NOTE: (andrewgu) i haven't touched this function. i merely moved it around.
HRESULT ProcessCDWelcome()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessCDWelcome)

    TCHAR szPath[MAX_PATH];
    HKEY hk;

    GetWindowsDirectory(szPath, countof(szPath));
    PathAppend(szPath, TEXT("welc.exe"));

    if (PathFileExists(szPath))
    {
        TCHAR szDestPath[MAX_PATH];

        Out(LI0(TEXT("Welcome exe found in windows dir.")));
        GetIEPath(szDestPath, countof(szDestPath));
        PathAppend(szDestPath, TEXT("welcome.exe"));

        if (!PathFileExists(szDestPath))
        {
            HKEY hkCurVer;

            CopyFile(szPath, szDestPath, FALSE);

            if (SHOpenKeyHKLM(REGSTR_PATH_SETUP, KEY_READ | KEY_WRITE, &hkCurVer) == ERROR_SUCCESS)
            {
                RegSetValueEx(hkCurVer, TEXT("DeleteWelcome"), 0, REG_SZ, (LPBYTE)szDestPath, (DWORD)StrCbFromSz(szDestPath));
                SHCloseKey(hkCurVer);
            }
            Out(LI0(TEXT("Copying welcome exe to ie dir.")));
        }

        DeleteFile(szPath);
    }

    if (ERROR_SUCCESS == SHOpenKeyHKLM(REGSTR_PATH_SETUP, KEY_READ | KEY_WRITE, &hk)) {
        if (ERROR_SUCCESS == RegQueryValueEx(hk, TEXT("IEFromCD"), NULL, NULL, NULL, NULL)) {
            HKEY hkTips;

            RegDeleteValue(hk, TEXT("IEFromCD"));

            // (pritobla)
            // the logic in loadwc.exe (if in non-integrated mode) and in explorer.exe (if in integrated mode)
            // which determines if the welcome screen should be shown or not is as follows:
            //   if the ShowIE4 reg value *doesn't exist* OR if the value is non-zero,
            //   show the welcome screen; otherwise, don't show

            // so, if ie has been installed from a custom CD build, check if ShowIE4 reg value is 0.
            // if yes, set it to 1 so that welcome.exe is run which in turn will show the start.htm and also,
            // set CDForcedOn to 1 so that isk3ro.exe will set ShowIE4 back to 0.

            if (SHOpenKey(g_GetHKCU(), REG_KEY_TIPS, KEY_READ | KEY_WRITE, &hkTips) == ERROR_SUCCESS)
            {
                DWORD dwVal, dwSize;

                // NOTE: (pritobla) It's important to initialize dwVal to 0 because on OSR2.5, ShowIE4 (REG_VAL_SHOWIE4)
                // is of binary type and is set to 00 (single byte).  If dwVal is not initialized to 0, then only the
                // low order byte would be set to 0.  The remaining bytes would be garbage which would make the entire DWORD
                // a non-zero value.
                dwVal  = 0;
                dwSize = sizeof(dwVal);
                if (RegQueryValueEx(hkTips, REG_VAL_SHOWIE4, NULL, NULL, (LPBYTE) &dwVal, &dwSize) == ERROR_SUCCESS  &&
                    dwVal == 0)
                {
                    dwVal = 1;
                    RegSetValueEx(hkTips, REG_VAL_SHOWIE4, 0, REG_DWORD, (CONST BYTE *)&dwVal, sizeof(dwVal));

                    RegSetValueEx(hk, TEXT("CDForcedOn"), 0, REG_SZ, (LPBYTE)TEXT("1"), StrCbFromCch(2));
                }

                SHCloseKey(hkTips);
            }
        }

        SHCloseKey(hk);
    }

    return S_OK;
}

HRESULT ProcessBrowserRefresh()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessBrowserRefresh)

    static const CHAR *s_pszIEHiddenA = "Internet Explorer_Hidden";

    CHAR      szClassNameA[32];
    HWND      hwnd;
    HANDLE    hThread = NULL;
    DWORD     dwThread;

    hwnd = GetTopWindow(GetDesktopWindow());
    while (hwnd != NULL) {
        GetClassNameA(hwnd, szClassNameA, sizeof(szClassNameA));

        if (!StrCmpIA(szClassNameA, s_pszIEHiddenA)) {
            PostMessage(hwnd, WM_DO_UPDATEALL, 0, FALSE);
            Out(LI0(TEXT("Posted update request to the hidden browser window!")));
        }

        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
    }

    Out(LI0(TEXT("Broadcasting \"Windows settings change\" to all top level windows...")));

    if (g_CtxIs(CTX_AUTOCONFIG))
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) broadcastSettingsChange, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails or it is not in AutoConfig mode
        broadcastSettingsChange(NULL);
    else
        CloseHandle(hThread);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

LPCTSTR rtgGetRatingsFile(LPTSTR pszFile /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, rtgGetRatingsFile)

    static TCHAR s_szFile[MAX_PATH];
    static DWORD s_dwSize;

    if (pszFile != NULL)
        *pszFile = TEXT('\0');

    if (s_szFile[0] == TEXT('\0')) {
        s_dwSize = GetSystemDirectory(s_szFile, countof(s_szFile));
        PathAppend(s_szFile, RATINGS_POL);
        s_dwSize += 1 + countof(RATINGS_POL)-1;

        Out(LI1(TEXT("Ratings file location is \"%s\"."), s_szFile));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszFile == NULL || cch <= (UINT)s_dwSize)
        return s_szFile;

    StrCpy(pszFile, s_szFile);
    return pszFile;
}

BOOL rtgIsRatingsInRegistry()
{
    HKEY hkUpdate, hkLogon, hkRatings;
    BOOL fRet = TRUE;
    DWORD dwUpMode, dwType, dwProfiles;
    DWORD K4 = 4;

    if ((GetVersion() & 0x80000000) == 0)
        return TRUE;

    if (SHOpenKeyHKLM(REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\Update"), KEY_QUERY_VALUE, &hkUpdate) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkUpdate, TEXT("UpdateMode"), 0, &dwType, (LPBYTE)&dwUpMode, &K4) != ERROR_SUCCESS)
            fRet = FALSE;
        else
            fRet &= dwUpMode;
        SHCloseKey(hkUpdate);
        if (!fRet)
            return fRet;
    }
    else
        return FALSE;

    if (SHOpenKeyHKLM(REGSTR_PATH_NETWORK_USERSETTINGS TEXT("\\Logon"), KEY_QUERY_VALUE, &hkLogon) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkLogon, TEXT("UserProfiles"), 0, &dwType, (LPBYTE)&dwProfiles, &K4) != ERROR_SUCCESS)
            fRet = FALSE;
        else
            fRet &= dwProfiles;
        SHCloseKey(hkLogon);
        if (!fRet)
            return fRet;
    }
    else
        return FALSE;

    if (SHOpenKeyHKLM(RK_RATINGS, KEY_QUERY_VALUE, &hkRatings) == ERROR_SUCCESS)
    {
        HKEY hkRatDef;
        if (SHOpenKey(hkRatings, TEXT(".Default"), KEY_QUERY_VALUE, &hkRatDef) != ERROR_SUCCESS)
            fRet = FALSE;
        else
            SHCloseKey(hkRatDef);
        SHCloseKey(hkRatings);
    }
    else
        return FALSE;

    return fRet;
}

void rtgRegMoveRatings()
{
    TCHAR szData[MAX_PATH], szValue[MAX_PATH];
    HKEY  hkSrc = NULL, hkDest = NULL, hkSrcDef = NULL, hkDestDef = NULL;  
    DWORD dwType;
    DWORD dwiVal = 0;
    DWORD sData  = sizeof(szData);
    DWORD sValue = countof(szValue);

    if (SHOpenKeyHKLM(RK_RATINGS, KEY_DEFAULT_ACCESS, &hkSrc) != ERROR_SUCCESS)
        goto Exit;

    if (SHCreateKeyHKLM(RK_IEAKPOLICYDATA_USERS, KEY_DEFAULT_ACCESS, &hkDest) != ERROR_SUCCESS)
        goto Exit;

    while (RegEnumValue(hkSrc, dwiVal++, szValue, &sValue, NULL, &dwType, (LPBYTE)szData, &sData) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkDest, szValue, 0, dwType, (LPBYTE)szData, sData);
        sData  = sizeof(szData);
        sValue = countof(szValue);
    }

    if (SHOpenKey(hkSrc, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkSrcDef) != ERROR_SUCCESS)
        goto Exit;
    
    if (SHCreateKey(hkDest, TEXT(".Default"), KEY_DEFAULT_ACCESS, &hkDestDef) != ERROR_SUCCESS)
        goto Exit;

    SHCopyKey(hkSrcDef, hkDestDef);

    SHCloseKey(hkSrcDef);
    SHCloseKey(hkDestDef);

    if (SHOpenKey(hkSrc, TEXT("PICSRules"), KEY_DEFAULT_ACCESS, &hkSrcDef) != ERROR_SUCCESS)
        goto Exit;

    if (SHCreateKey(hkDest, REG_KEY_RATINGS TEXT("\\PICSRules"), KEY_DEFAULT_ACCESS, &hkDestDef) != ERROR_SUCCESS)
        goto Exit;

    SHCopyKey(hkSrcDef, hkDestDef);

Exit:
    SHCloseKey(hkSrc);
    SHCloseKey(hkDest);
    SHCloseKey(hkSrcDef);
    SHCloseKey(hkDestDef);
}

void broadcastSettingsChange(LPVOID lpVoid)
{
    DWORD_PTR dwResult;

    UNREFERENCED_PARAMETER(lpVoid);

    // NOTE: (pritobla) timeout value of 20 secs is not random; apparently, the shell guys have
    // recommended this value; so don't change it unless you know what you're doing :)
    SendMessageTimeout(HWND_BROADCAST, WM_WININICHANGE, 0, NULL, SMTO_ABORTIFHUNG | SMTO_NORMAL, 20000, &dwResult);
}


// Helper to determine if we're currently loaded during GUI mode setup
BOOL IsInGUIModeSetup()
{
    HKEY hKeySetup = NULL;
    DWORD dwSystemSetupInProgress = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("System\\Setup"),
                                      0,
                                      KEY_READ,
                                      &hKeySetup))
    {
        DWORD dwSize = sizeof(dwSystemSetupInProgress);

        if (ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                              TEXT("SystemSetupInProgress"),
                                              NULL,
                                              NULL,
                                              (LPBYTE) &dwSystemSetupInProgress,
                                              &dwSize))
        {
            dwSystemSetupInProgress = 0;
        }
        else
        {
            dwSize = sizeof(dwSystemSetupInProgress);
            if (dwSystemSetupInProgress &&
                ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                  TEXT("UpgradeInProgress"),
                                                  NULL,
                                                  NULL,
                                                  (LPBYTE) &dwSystemSetupInProgress,
                                                  &dwSize))
            {
                dwSystemSetupInProgress = 0;
            }
        }

        RegCloseKey(hKeySetup);
    }
    return dwSystemSetupInProgress ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brandcs.cpp ===
#include "precomp.h"
#include <rashelp.h>

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#include <winineti.h>

// Private forward decalarations
PCTSTR getPhonebookFile(PTSTR pszPhonebook = NULL, UINT cchPhonebook = 0);
PCTSTR getConnectToInternetFile(PTSTR pszFile = NULL, UINT cchFile = 0);

//----- ClearConnectionSettings() and ProcessConnectionSettingsDeletion() helpers -----
BOOL    deleteConnection (PCTSTR pszPhonebook, PCTSTR pszName);
BOOL    rasDeleteEnumProc(PCWSTR pszNameW, LPARAM lParam);

// cnl stands for "connection names list"
BOOL    cnlAppendNameToList(PCTSTR  pszName, HKEY   hkCached = NULL);
HRESULT cnlIsNameInList    (PCTSTR  pszName, PTSTR  pszList  = NULL, HKEY hkCached = NULL);
BOOL    cnlGetList         (PTSTR *ppszList, PDWORD pcchList = NULL, HKEY hkCached = NULL);

// lb stands for "lan backup"
BOOL    lbBackup ();
BOOL    lbRestore();
void    lbCopySzToBlobW(PBYTE *ppBlob, PCWSTR pszStrW);

// ra stands for "remote access"
BOOL    raBackup();
BOOL    raRestore();


//----- ProcessConnectionSettings() and lcy50_ProcessConnectionSettings() helpers -----
HRESULT importRasSettings           (PCWSTR pszNameW, PBYTE *ppBlob, LPRASDEVINFOW prdiW, UINT cDevices);
HRESULT importRasCredentialsSettings(PCWSTR pszNameW, PBYTE *ppBlob);
HRESULT importWininetSettings       (PCWSTR pszNameW, PBYTE *ppBlob);

void setSzFromBlobA(PBYTE *ppBlob, UNALIGNED CHAR  **ppszStrA);
void setSzFromBlobW(PBYTE *ppBlob, UNALIGNED WCHAR **ppszStrW);

HRESULT insProcessAutoconfig(PCTSTR pszName);
HRESULT insProcessProxy     (PCTSTR pszName);

//----- Miscellaneous -----
DWORD getWininetFlagsSetting(PCTSTR pszName = NULL);
BOOL  mergeProxyBypass      (PCTSTR pszName, PCTSTR pszProxyBypass, PTSTR pszResult, UINT cchResult);
void  trimProxyBypass       (PTSTR pszProxyBypass);

TCHAR g_szConnectoidName[RAS_MaxEntryName + 1];

void ClearConnectionSettings(DWORD dwFlags /*= FF_ENABLE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ClearConnectionSettings)

    UNREFERENCED_PARAMETER(dwFlags);

    PTSTR  pszList;
    PCTSTR pszPhonebook,
           pszCur;
    BOOL   fRasApisLoaded,
           fResult,
           fImpersonate;

    fImpersonate = FALSE;
    if (g_CtxIsGp())
        fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

    Out(LI0(TEXT("Clearing connection settings...")));
    pszList        = NULL;
    fRasApisLoaded = FALSE;

    pszPhonebook = getPhonebookFile();
    if (NULL == pszPhonebook)
        goto Exit;

    fResult = cnlGetList(&pszList);
    if (!fResult || NULL == pszList)
        goto Exit;

    fRasApisLoaded = (RasPrepareApis(RPA_RASDELETEENTRYA) && NULL != g_pfnRasDeleteEntryA);
    if (!fRasApisLoaded)
        goto Exit;

    for (pszCur = pszList; NULL != pszCur && TEXT('\0') != *pszCur; pszCur += StrLen(pszCur)+1) {
        fResult = deleteConnection(pszPhonebook, pszCur);
        if (fResult)
            Out(LI1(TEXT("Connection \"%s\" was deleted successfully."), pszCur));
        else
            Out(LI1(TEXT("! Deleting connection \"%s\" failed."), pszCur));
    }

Exit:
// removed per bug 28282--lanbackup has performance problems and is really not 
// accomplishing much anyway--we don't do this for other features, why shoudl we do it for 
// connection settings?
//  lbRestore();

    Out(LI0(TEXT("\r\n")));
    raRestore();

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    if (NULL != pszList)
        CoTaskMemFree((PVOID)pszList);

    Out(LI0(TEXT("Done.")));
    if (fImpersonate)
        RevertToSelf();
}


HRESULT ProcessWininetSetup()
{
    BOOL fResult = FALSE;

    if (g_CtxIsGp()) {
        ASSERT(!g_CtxIs(CTX_MISC_CHILDPROCESS));
        ASSERT(NULL != g_GetUserToken() && IsOS(OS_NT5));

        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

        fResult = ImpersonateLoggedOnUser(g_GetUserToken());
    }

    getWininetFlagsSetting();

    if (g_CtxIsGp() && fResult)
        RevertToSelf();

    return S_OK;
}

HRESULT ProcessConnectionSettingsDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessConnectionSettingsDeletion)

    HRESULT hr;

    hr = (TRUE == RasEnumEntriesCallback(NULL, rasDeleteEnumProc, 0, RWM_RUNTIME)) ? S_OK : E_FAIL;
    if (FAILED(hr))
        Out(LI0(TEXT("! Enumeration of RAS connections failed with E_FAIL.")));

    return hr;
}

HRESULT ProcessConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessConnectionSettings)

    USES_CONVERSION;

    LPRASDEVINFOW prdiW;
    TCHAR   szTargetFile[MAX_PATH],
            szApplyToName[RAS_MaxEntryName + 1];
    PCWSTR  pszCurNameW;
    PWSTR   pszNameW;
    PBYTE   pBuf, pCur;
    HANDLE  hFile;
    HRESULT hr;
    DWORD   dwVersion,
            cbBuffer, cbFile,
            dwAux,
            cDevices;
    BOOL    fRasApisLoaded,
            fSkipBlob;

    prdiW          = NULL;
    pszNameW       = NULL;
    pBuf           = NULL;
    hFile          = NULL;
    hr             = E_FAIL;
    cDevices       = 0;
    fRasApisLoaded = FALSE;

    //----- Global settings processing -----
    HKEY  hkHkcu, hkHkcc;
    BOOL  fAux;

    hkHkcu = NULL;
    hkHkcc = NULL;

    dwAux = 0;
    if (InsKeyExists(IS_CONNECTSET, IK_ENABLEAUTODIAL, g_GetIns()))
        dwAux |= 1;

    if (InsKeyExists(IS_CONNECTSET, IK_NONETAUTODIAL,  g_GetIns()))
        dwAux |= 2;

    if (0 < dwAux) {
        SHOpenKey(g_GetHKCU(), RK_INETSETTINGS, KEY_SET_VALUE, &hkHkcu);

        // NOTE: (andrewgu) according to darrenmi no need to do hkcc work on w2k shell.
        if (!IsOS(OS_NT5))
            SHOpenKeyHKCC(RK_INETSETTINGS, KEY_SET_VALUE, &hkHkcc);
    }

    if (HasFlag(dwAux, 1)) {
        fAux = InsGetBool(IS_CONNECTSET, IK_ENABLEAUTODIAL, FALSE, g_GetIns());

        if (NULL != hkHkcu)
            RegSetValueEx(hkHkcu, RV_ENABLEAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
        if (NULL != hkHkcc)
            RegSetValueEx(hkHkcc, RV_ENABLEAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
    }

    if (HasFlag(dwAux, 2)) {
        fAux = InsGetBool(IS_CONNECTSET, IK_NONETAUTODIAL, FALSE, g_GetIns());

        if (NULL != hkHkcu)
            RegSetValueEx(hkHkcu, RV_NONETAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
        if (NULL != hkHkcc)
            RegSetValueEx(hkHkcc, RV_NONETAUTODIAL, 0, REG_DWORD, (LPBYTE)&fAux, sizeof(fAux));
    }

    SHCloseKey(hkHkcu);
    SHCloseKey(hkHkcc);

    // removed per bug 28282--lanbackup has performance problems and is really not 
    // accomplishing much anyway--we don't do this for other features, why shoudl we do it for 
    // connection settings?


    //----- Backup LAN settings (in GP context) -----
   // if ((g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_PREFERENCES)) &&
   //    InsIsKeyEmpty(IS_CONNECTSET, IK_APPLYTONAME, g_GetIns()) &&
   //   FF_DISABLE == GetFeatureBranded(FID_CS_MAIN)) {

	//ASSERT(S_OK != SHValueExists(g_GetHKCU(), RK_BRND_CS, RV_LANBACKUP));
        
        //lbBackup();
        
    //}

    //----- Process version information -----
    if (!InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, g_GetIns())) {
        hr = S_FALSE;
        goto PartTwo;
    }

    dwAux = 0;

    PathCombine(szTargetFile, g_GetTargetPath(), CS_DAT);
    if (PathFileExists(szTargetFile))
        dwAux = CS_VERSION_5X;

    if (0 == dwAux) {
        PathCombine(szTargetFile, g_GetTargetPath(), CONNECT_SET);
        if (PathFileExists(szTargetFile))
            dwAux = CS_VERSION_50;

        else {
            Out(LI0(TEXT("Connection settings file(s) is absent!")));
            goto PartTwo;
        }
    }
    ASSERT(0 != dwAux);

    hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        Out(LI0(TEXT("! Connections settings file(s) can't be opened.")));
        hr = STG_E_ACCESSDENIED;
        goto PartTwo;
    }

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    if (ReadFile(hFile, &dwVersion, sizeof(dwVersion), &cbFile, NULL) != TRUE)
    {
        Out(LI0(TEXT("! Error reading version information in connection settings file(s).")));
        goto PartTwo;
    }

    if (CS_VERSION_50 == dwVersion) {
        if (CS_VERSION_50 != dwAux) {
            Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
            goto PartTwo;
        }

        CloseFile(hFile);
        hFile = NULL;

        hr = lcy50_ProcessConnectionSettings();
        goto PartTwo;
    }
    else if (CS_VERSION_5X <= dwVersion && CS_VERSION_5X_MAX >= dwVersion) {
        if (CS_VERSION_5X != dwAux) {
            Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
            goto PartTwo;
        }
    }
    else {
        Out(LI0(TEXT("! Version information in connection settings file(s) is corrupted.")));
        goto PartTwo;
    }

    Out(LI1(TEXT("Connection settings file is \"%s\"."), CS_DAT));
    Out(LI1(TEXT("The version of connection settings file is 0x%lX.\r\n"), dwVersion));

    //----- Read CS file into internal memory buffer -----
    cbBuffer = GetFileSize(hFile, NULL);
    if (cbBuffer == 0xFFFFFFFF) {
        Out(LI0(TEXT("! Internal processing error.")));
        goto PartTwo;
    }
    cbBuffer -= sizeof(dwVersion);

    pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
    if (pBuf == NULL) {
        Out(LI0(TEXT("! Internal processing ran out of memory.")));
        hr = E_OUTOFMEMORY;
        goto PartTwo;
    }
    ZeroMemory(pBuf, cbBuffer);

    ReadFile (hFile, pBuf, cbBuffer, &cbFile, NULL);
    CloseFile(hFile);
    hFile = NULL;

    pCur = pBuf;

    //----- Get information about RAS devices on the local system -----
    if (!RasIsInstalled())
        Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!\r\n")));

    else {
        fRasApisLoaded = (RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) && g_pfnRasSetEntryPropertiesA != NULL);
        if (!fRasApisLoaded)
            Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed.\r\n")));
    }

    if (fRasApisLoaded) {
        RasEnumDevicesExW(&prdiW, NULL, &cDevices);
        if (cDevices == 0)
            Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
    }

    //----- Main loop -----
    pszCurNameW = L"";
    hr          = S_OK;
    fSkipBlob   = FALSE;

    while (pCur < pBuf + cbBuffer) {

        //_____ Determine connection name _____
        if (*((PDWORD)pCur) == CS_STRUCT_HEADER) {
            pCur += 2*sizeof(DWORD);
            setSzFromBlobW(&pCur, &pszNameW);
        }

        //_____ Special case no RAS or no RAS devices _____
        // NOTE: (andrewgu) in this case it makes sense to process wininet settings for LAN only.
        if (!fRasApisLoaded || cDevices == 0) {
            if (pszNameW != NULL || *((PDWORD)pCur) != CS_STRUCT_WININET) {
                pCur += *((PDWORD)(pCur + sizeof(DWORD)));
                continue;
            }

            ASSERT(pszNameW == NULL && *((PDWORD)pCur) == CS_STRUCT_WININET);
        }

        //_____ Main processing _____
        if (pszCurNameW != pszNameW) {
            fSkipBlob = FALSE;

            if (TEXT('\0') != *pszCurNameW)     // tricky: empty string is an invalid name
                Out(LI0(TEXT("Done.")));        // if not that, there were connections before

            if (NULL != pszNameW) {
                PCTSTR pszName;

                pszName = W2CT(pszNameW);
                Out(LI1(TEXT("Proccessing settings for \"%s\" connection..."), pszName));

                //- - - GP context - - -
                if (g_CtxIs(CTX_GP))
                    // policies gpo special processing:
                    // builds a list of all connection settings names branded in the current gpo
                    // list and stores it in HKCU\RK_BRND_CS, RV_NAMESLIST.
                    if (!g_CtxIs(CTX_MISC_PREFERENCES))
                        cnlAppendNameToList(pszName);

                    // preferences gpo special processing
                    else { /* g_CtxIs(CTX_MISC_PREFERENCES) */
                        fSkipBlob = (S_OK == cnlIsNameInList(pszName));
                        if (fSkipBlob)
                            Out(LI0(TEXT("Connection with this name has been enforced through policies!\r\n")));
                    }
            }
            else {
                Out(LI0(TEXT("Proccessing settings for LAN connection...")));

                // ASSUMPTION: (andrewgu) if connection settings marked branded in the registry -
                // LAN settings have already been enforced. (note, that technically it may not be
                // true - if there is no cs.dat and *.ins customized ras connection through
                // IK_APPLYTONAME)
                fSkipBlob = (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) && FF_DISABLE != GetFeatureBranded(FID_CS_MAIN);
                if (fSkipBlob)
                    Out(LI0(TEXT("These settings have been enforced through policies!\r\n")));
            }

            pszCurNameW = pszNameW;
        }

        if (fSkipBlob) {
            pCur += *((PDWORD)(pCur + sizeof(DWORD)));
            continue;
        }

        switch (*((PDWORD)pCur)) {
        case CS_STRUCT_RAS:
            hr = importRasSettings(pszNameW, &pCur, prdiW, cDevices);
            break;

        case CS_STRUCT_RAS_CREADENTIALS:
            hr = importRasCredentialsSettings(pszNameW, &pCur);
            break;

        case CS_STRUCT_WININET:
            hr = importWininetSettings(pszNameW, &pCur);
            break;

        default:
            pCur += *((PDWORD)(pCur + sizeof(DWORD)));
            hr    = S_FALSE;
        }

        if (hr == E_UNEXPECTED) {
            Out(LI0(TEXT("! The settings file is corrupted beyond recovery.")));
            goto PartTwo;
        }
    }
    Out(LI0(TEXT("Done.")));                    // to indicate end for the last connection
    // HaitaoLi: #16682[WinSE]:Connection settings lost with IE Maintenance GPO even 
    // when "Do not customize Connection Settings" is checked
    // I moved the following line from within the Exit block to here. Otherwise If
    // GPO has "Do not customize connection settings" checked, but the .ins file
    // has any connnection settings (e.g. proxy) customized, then we call
    // SetFeatureBranded() and mark the connection settings as branded.
    // So the next time branding is run, it will clear all the connection settings,
    // including dial-up settings.
    SetFeatureBranded(FID_CS_MAIN);

PartTwo:
    //_____ Ins proxy and autoconfig information _____
    { MACRO_LI_Offset(1);                       // need a new scope

    InsGetString(IS_CONNECTSET, IK_APPLYTONAME, szApplyToName, countof(szApplyToName), g_GetIns());
    if (szApplyToName[0] == TEXT('\0') && g_szConnectoidName[0] != TEXT('\0'))
        StrCpy(szApplyToName, g_szConnectoidName);

    Out(LI0(TEXT("\r\n")));
    if (szApplyToName[0] == TEXT('\0'))
        Out(LI0(TEXT("Settings from the *.ins file will be applied to LAN connection!")));
    else
        Out(LI1(TEXT("Settings from the *.ins file will be applied to \"%s\" connection!"), szApplyToName));

    }                                           // end offset scope

    // ASSUMPTION: (andrewgu) if connection settings marked branded in the registry - LAN
    // settings have already been enforced. (note, that technically it may not be true - if there
    // is no cs.dat and *.ins customized ras connection through IK_APPLYTONAME)
    if ((g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) &&
        FF_DISABLE != GetFeatureBranded(FID_CS_MAIN)) {

        ASSERT(TEXT('\0') == szApplyToName[0]);
        Out(LI0(TEXT("These settings have been enforced through policies!\r\n")));
    }
    else {
        HRESULT hrAutoconfig, hrProxy;

        Out(LI0(TEXT("\r\n")));
        hrAutoconfig = insProcessAutoconfig(szApplyToName);

        Out(LI0(TEXT("\r\n")));
        hrProxy = insProcessProxy(szApplyToName);

        if (S_OK != hr)
            if (S_OK == hrAutoconfig || S_OK == hrProxy)
                hr = S_FALSE;                   // partial success

            else
                hr = E_FAIL;                    // nothing really worked
    }

    if (SUCCEEDED(hr)) {
        // NOTE: (andrewgu) ie5 b#81989. this whole thing is a mess. first of all when i ported
        // getConnectToInternetFile from icw i found something like 3 bugs in the code, plus the
        // code in general does the wrong thing on win9x. i talked to oliverl a bit, and we
        // decided that what's below is the best course of action at this point.
        // it's self-explanatory.
        if (!((g_CtxIs(CTX_ISP) && g_CtxIs(CTX_SIGNUP_ALL)) || g_CtxIs(CTX_ICW))) {
            BOOL fImpersonate = FALSE;

            if (g_CtxIsGp())
                fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

            getConnectToInternetFile(szTargetFile);
            if (TEXT('\0') != szTargetFile[0] && PathFileExists(szTargetFile)) {
                SetFileAttributes(szTargetFile, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szTargetFile);
            }

            if (fImpersonate)
                RevertToSelf();
            dwAux = 1;
            SHSetValue(g_GetHKCU(), RK_ICW, RV_COMPLETED, REG_DWORD, (LPBYTE)&dwAux, sizeof(dwAux));

            Out(LI0(TEXT("Notified ICW that connection to the Internet is configured.")));
        }

    }

    //_____ Flush wininet, so settings take effect on next access _____
    if (!HasFlag(g_GetContext(), CTX_AUTOCONFIG))
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    if (prdiW != NULL) {
        CoTaskMemFree(prdiW);
        prdiW = NULL;
    }

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    if (pBuf != NULL) {
        CoTaskMemFree(pBuf);
        pBuf = NULL;
    }

    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
        CloseFile(hFile);
        hFile = NULL;
    }

    return hr;
}

HRESULT lcy50_ProcessConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ProcessConnectionSettings)

    USES_CONVERSION;

    TCHAR  szTargetFile[MAX_PATH];
    HANDLE hFile;
    PBYTE  pBuf, pCur;
    DWORD  cbBuffer, cbAux,
           dwResult,
           cDevices;
    UINT   i;

    Out(LI0(TEXT("Connection settings are in IE5 format...")));

    hFile    = NULL;
    pBuf     = NULL;
    cbBuffer = 0;
    cbAux    = 0;
    cDevices = 0;

    //----- Connect.ras processing -----
    Out(LI1(TEXT("Processing RAS connections information from \"%s\"."), CONNECT_RAS));

    PathCombine(szTargetFile, g_GetTargetPath(), CONNECT_RAS);
    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        LPRASDEVINFOA prdiA;
        LPRASENTRYA   preA;
        TCHAR szName[RAS_MaxEntryName + 1],
              szScript[MAX_PATH],
              szDeviceName[RAS_MaxDeviceName + 1],
              szKey[16];
        CHAR  szNameA[RAS_MaxEntryName + 1];
        PSTR  pszScriptA;
        DWORD cbRasEntry;
        UINT  j;
        BOOL  fRasApisLoaded;

        prdiA          = NULL;
        hFile          = NULL;
        fRasApisLoaded = FALSE;

        if (!RasIsInstalled()) {
            Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!")));
            goto RasExit;
        }

        //_____ Read Connect.ras into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto RasExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbBuffer = GetFileSize(hFile, NULL);
        if (cbBuffer == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto RasExit;
        }

        pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
        if (pBuf == NULL) {
            Out(LI0(TEXT("! Internal processing ran out of memory.")));
            goto RasExit;
        }
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        if (*((PDWORD)pBuf) != CS_VERSION_50) {
            Out(LI0(TEXT("! The version information in this file is corrupted.")));
            goto RasExit;
        }

        //_____ Preload RAS dlls _____
        if (!RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) || g_pfnRasSetEntryPropertiesA == NULL) {
            Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }
        fRasApisLoaded = TRUE;

        //_____ Get information about RAS devices on the local system _____
        RasEnumDevicesExA(&prdiA, NULL, &cDevices);
        if (cDevices == 0) {
            Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }

        //_____ Parse through RAS connections information _____
        for (i = cbAux = 0, pCur = pBuf + sizeof(DWORD); TRUE; i++, pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (i > 0)
                Out(LI0(TEXT("\r\n")));

            wnsprintf(szKey, countof(szKey), IK_CONNECTNAME, i);
            InsGetString(IS_CONNECTSET, szKey, szName, countof(szName), g_GetIns());
            if (szName[0] == TEXT('\0')) {
                Out(LI2(TEXT("[%s], \"%s\" doesn't exist. There are no more RAS connections!"), IS_CONNECTSET, szKey));
                break;
            }

            wnsprintf(szKey, countof(szKey), IK_CONNECTSIZE, i);
            cbAux = InsGetInt(IS_CONNECTSET, szKey, 0, g_GetIns());
            if (cbAux == 0) {
                Out(LI0(TEXT("! The ins file is corrupt. No more RAS connections can be processed.")));
                break;
            }

            //- - - Main processing - - -
            Out(LI1(TEXT("Processing RAS connection \"%s\"..."), szName));

            preA = (LPRASENTRYA)pCur;

            // NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYA structure are
            // different on the server and client machines. there is nothing bad with server
            // structure being smaller than the client structure (all RAS apis are
            // backward-compatible). it's bad though when server structure is bigger than client
            // can handle, hence the trancation.
            // (something else to have in mind) this truncation should not affect alternate phone
            // numbers support on winnt. for more special cases also check out NOTE: below.
            if (preA->dwSize > sizeof(RASENTRYA))
                preA->dwSize = sizeof(RASENTRYA);

            // preA->szScript
            if (preA->szScript[0] != '\0') {
                pszScriptA = preA->szScript;
                if (preA->szScript[0] == '[')
                    pszScriptA = &preA->szScript[1];

                A2Tbuf(pszScriptA, szScript, countof(szScript));
                StrCpy(PathFindFileName(szTargetFile), PathFindFileName(szScript));
                if (PathFileExists(szTargetFile))
                    T2Abuf(szTargetFile, preA->szScript, MAX_PATH);

                else
                    preA->szScript[0] = '\0';
            }

            // preA->szDeviceName
            for (j = 0; j < cDevices; j++)
                if (0 == StrCmpIA(preA->szDeviceType, prdiA[j].szDeviceType)) {
                    StrCpyA(preA->szDeviceName, prdiA[j].szDeviceName);
                    break;
                }
            if (j >= cDevices)
                StrCpyA(preA->szDeviceName, prdiA[0].szDeviceName);

            A2Tbuf(preA->szDeviceName, szDeviceName, countof(szDeviceName));
            Out(LI1(TEXT("Set the device name to \"%s\"."), szDeviceName));

            // NOTE: (andrewgu) on win9x if there are alternate phone numbers (i.e. the package
            // installed on win9x machine was generated on winnt machine), cbAux will be larger
            // than preA->dwSize. this will fail with ERROR_INVALID_PARAMETER on win9x. hence on
            // this platform cbAux is reset so api has a chance of succeeding.
            cbRasEntry = cbAux;
            if (IsOS(OS_WINDOWS)) {
                preA->dwAlternateOffset = 0;
                cbRasEntry = preA->dwSize;
            }

            //BUGBUG: this is casting a dword result to an hresult!  that gethrsz is never going to return anything useful. 
            T2Abuf(szName, szNameA, countof(szNameA));
            dwResult = g_pfnRasSetEntryPropertiesA(NULL, szNameA, preA, cbRasEntry, NULL, 0);
            if (dwResult != ERROR_SUCCESS) {
                Out(LI1(TEXT("! Creating this RAS connection failed with %s."), GetHrSz(dwResult)));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
RasExit:
        if (fRasApisLoaded)
            RasPrepareApis(RPA_UNLOAD, FALSE);

        if (prdiA != NULL)
            CoTaskMemFree(prdiA);

        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }
    }

    //----- Connect.set processing -----
    Out(LI1(TEXT("\r\nProcessing Wininet.dll connections information from \"%s\"."), CONNECT_SET));
    StrCpy(PathFindFileName(szTargetFile), CONNECT_SET);

    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        INTERNET_PER_CONN_OPTION_LISTA listA;
        INTERNET_PER_CONN_OPTIONA      rgOptionsA[7];
        PBYTE pAux;

        //_____ Read Connect.set into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto WininetExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbAux = GetFileSize(hFile, NULL);
        if (cbAux == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto WininetExit;
        }

        if (cbAux > cbBuffer) {
            pBuf = (PBYTE)CoTaskMemRealloc(pBuf, cbAux);
            if (pBuf == NULL) {
                Out(LI0(TEXT("! Internal processing ran out of memory.")));
                goto WininetExit;
            }
        }
        cbBuffer = cbAux;
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        ASSERT(*((PDWORD)pBuf) == CS_VERSION_50);

        //_____ Parse through Wininet.dll connections information _____
        for (pCur = pBuf + sizeof(DWORD), cbAux = 0; pCur < (pBuf + cbBuffer); pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (pCur > (pBuf + sizeof(DWORD)))
                Out(LI0(TEXT("\r\n")));

            //- - - Main processing - - -
            pAux = pCur;

            cbAux = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            ZeroMemory(&listA, sizeof(listA));
            listA.dwSize   = sizeof(listA);     // listA.dwSize
            listA.pOptions = rgOptionsA;        // listA.pOptions

            // listA.pszConnection
            if (*pAux == NULL) {
                listA.pszConnection = NULL;
                pAux += sizeof(DWORD);
            }
            else {
                listA.pszConnection = (PSTR)pAux;
                pAux += StrCbFromSzA(listA.pszConnection);
            }

            // skip all but LAN settings if no RAS devices
            if (cDevices == 0 && listA.pszConnection != NULL)
                continue;

            if (listA.pszConnection == NULL)
                Out(LI0(TEXT("Proccessing Wininet.dll settings for LAN connection...")));
            else
                Out(LI1(TEXT("Proccessing Wininet.dll settings for \"%s\" connection..."),
                    A2CT(listA.pszConnection)));

            // listA.dwOptionCount
            listA.dwOptionCount = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            // listA.pOptions
            for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
                listA.pOptions[i].dwOption = *((PDWORD)pAux);
                pAux += sizeof(DWORD);

                switch (listA.pOptions[i].dwOption) {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    setSzFromBlobA(&pAux, &listA.pOptions[i].Value.pszValue);
                    break;

                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                default:                        // everything else is also DWORD
                    listA.pOptions[i].Value.dwValue = *((PDWORD)pAux);
                    pAux += sizeof(DWORD);
                    break;
                }
            }
            ASSERT(pAux == pCur + cbAux);

            if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP))) {
                ASSERT(listA.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

                if (HasFlag(listA.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
                    DWORD dwFlags;

                    dwFlags  = getWininetFlagsSetting(A2CT(listA.pszConnection));
                    dwFlags |= listA.pOptions[0].Value.dwValue;
                    listA.pOptions[0].Value.dwValue = dwFlags;
                }
                else {
                    Out(LI0(TEXT("No customizations!"))); // nothing to do since had only proxy
                    continue;                             // stuff to begin with. and now even
                }                                         // that is not there.
            }

            //- - - Merge new LAN's ProxyBypass settings with the existing ones - - -
            // NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
            // ins file as well, it makes no sense to do this here because what's in the ins
            // should overwrite what's in the imported connections settings.

            //- - - Call into Wininet.dll - - -
            if (FALSE == InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listA, listA.dwSize)) {
                Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
WininetExit:
        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }

        if (pBuf != NULL) {
            CoTaskMemFree(pBuf);
            pBuf = NULL;
        }
    }

    ASSERT(hFile == NULL);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

PCTSTR getPhonebookFile(PTSTR pszPhonebook /*= NULL*/, UINT cchPhonebook /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, getPhonebookFile)

    static TCHAR s_szFile[MAX_PATH];
    static UINT  s_cchFile;

    if (NULL != pszPhonebook)
        *pszPhonebook = TEXT('\0');

    if (!IsOS(OS_NT5))
        return NULL;

    if (TEXT('\0') == s_szFile[0]) {
        HRESULT hr;

        hr = SHGetFolderPathSimple(CSIDL_APPDATA, s_szFile);
        if (FAILED(hr))
            return NULL;

        PathAppend(s_szFile, TEXT("Microsoft\\Network\\Connections\\Pbk\\rasphone.pbk"));
        if (!PathFileExists(s_szFile))
            return NULL;

        s_cchFile = StrLen(s_szFile);
        Out(LI1(TEXT("Default phone book file is \"%s\"."), s_szFile));
    }
    else
        ASSERT(0 < s_cchFile);

    if (NULL == pszPhonebook || cchPhonebook <= s_cchFile)
        return s_szFile;

    StrCpy(pszPhonebook, s_szFile);
    return pszPhonebook;
}

// NOTE: (andrewgu) this code is stolen from \getconn\icwconn1\desktop.cpp. it should always
// repeat the functionality of GetDesktopDirectory no matter how many bugs.
PCTSTR getConnectToInternetFile(PTSTR pszFile /*= NULL*/, UINT cchFile /*= 0*/)
{
    TCHAR szFile[MAX_PATH],
          szAux [MAX_PATH];

    if (NULL == pszFile)
        return NULL;
    *pszFile = TEXT('\0');

    szFile[0] = TEXT('\0');

    if (IsOS(OS_NT5))
        SHGetFolderPathSimple(CSIDL_DESKTOPDIRECTORY, szFile);

    else if (IsOS(OS_NT))
        SHGetFolderPathSimple(CSIDL_COMMON_DESKTOPDIRECTORY, szFile);

    else {
        FARPROC pfnDllGetVersion;
        HMODULE hShell32Dll;

        pfnDllGetVersion = NULL;

        hShell32Dll = LoadLibrary(TEXT("shell32.dll"));
        if (NULL != hShell32Dll) {
            pfnDllGetVersion = GetProcAddress(hShell32Dll, "DllGetVersion");

            FreeLibrary(hShell32Dll);
        }

        if (NULL != pfnDllGetVersion) {
            TCHAR szFolder[MAX_PATH];

            szFolder[0] = TEXT('\0');
            GetWindowsDirectory(szFolder, countof(szFolder));
            if (TEXT('\0') != szFolder[0]) {
                PathAppend(szFolder, FOLDER_ALLUSERS);

                szAux[0] = TEXT('\0');
                LoadString(g_GetHinst(), IDS_FOLDER_DESKTOP, szAux, countof(szAux));
                if (TEXT('\0') != szAux[0]) {
                    PathAppend(szFolder, szAux);

                    StrCpy(szFile, szFolder);
                }
            }
        }
        else
            SHGetFolderPathSimple(CSIDL_DESKTOPDIRECTORY, szFile);
    }

    if (TEXT('\0') == szFile[0])
        return NULL;

    szAux[0] = TEXT('\0');
    LoadString(g_GetHinst(), IDS_ICW_CONNECTTOINTERNET, szAux, countof(szAux));
    if (TEXT('\0') == szAux[0])
        return NULL;

    PathAddExtension(szAux, TEXT(".lnk"));
    PathAppend(szFile, szAux);

    if (0 < cchFile && cchFile <= (UINT)StrLen(szFile))
        return NULL;

    StrCpy(pszFile, szFile);
    return pszFile;
}


BOOL deleteConnection(PCTSTR pszPhonebook, PCTSTR pszName)
{
    USES_CONVERSION;

    TCHAR szAux[MAX_PATH];
    DWORD cbAux;

    ASSERT(NULL != pszName);

    // delete ras stuff
    if (IsOS(OS_NT)) {
        if (!RasPrepareApis(RPA_RASDELETEENTRYW) || NULL == g_pfnRasDeleteEntryW)
            return FALSE;

        g_pfnRasDeleteEntryW(T2CW(pszPhonebook), T2CW(pszName));
    }
    else {
        if (!RasPrepareApis(RPA_RASDELETEENTRYA) || NULL == g_pfnRasDeleteEntryA)
            return FALSE;

        g_pfnRasDeleteEntryA(T2CA(pszPhonebook), T2CA(pszName));
    }
    RasPrepareApis(RPA_UNLOAD, FALSE);

    // delete wininet stream and advanced wininet stuff
    wnsprintf(szAux, countof(szAux), RK_REMOTEACCESS_PROFILES TEXT("\\%s"), pszName);
    SHDeleteValue(g_GetHKCU(), RK_CONNECTIONS, pszName);
    SHDeleteKey  (g_GetHKCU(), szAux);

    // only do this if deleted connection was set as the default
    // NOTE: (andrewgu) according to darrenmi... we don't even have to do this. ie will handle the
    // situation when default connection name is bogus and will properly fall back to the first
    // one in the phone book;
    szAux[0] = TEXT('\0');
    cbAux    = sizeof(szAux);
    SHGetValue(g_GetHKCU(), RK_REMOTEACCESS, RV_INTERNETPROFILE, NULL, szAux, &cbAux);
    if (0 == StrCmpI(pszName, szAux))
        SHDeleteValue(g_GetHKCU(), RK_REMOTEACCESS, RV_INTERNETPROFILE);

    return TRUE;
}

BOOL rasDeleteEnumProc(PCWSTR pszNameW, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);

    USES_CONVERSION;

    PCTSTR pszName;
    BOOL   fResult;

    if (NULL == pszNameW)
        return TRUE;                            // nothing to do for LAN

    pszName = W2CT(pszNameW);
    fResult = deleteConnection(NULL, pszName);
    if (fResult)
        Out(LI1(TEXT("Connection \"%s\" was deleted successfully."), pszName));
    else
        Out(LI1(TEXT("! Deleting connection \"%s\" failed."), pszName));

    return TRUE;
}


BOOL cnlAppendNameToList(PCTSTR pszName, HKEY hkCached /*= NULL*/)
{
    PTSTR pszList;
    DWORD cchList, cchName,
          dwResult;
    BOOL  fOwnHk,
          fResult;

    ASSERT(NULL != pszName && TEXT('\0') != *pszName);
    fOwnHk  = FALSE;
    fResult = FALSE;
    pszList = NULL;

    if (NULL == hkCached) {
        dwResult = SHCreateKey(g_GetHKCU(), RK_BRND_CS, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkCached);
        if (ERROR_SUCCESS != dwResult)
            goto Exit;

        fOwnHk = TRUE;
    }

    fResult = cnlGetList(&pszList, &cchList, hkCached);
    if (!fResult)
        goto Exit;

    if (NULL == pszList)                        // the value is not there yet
        cchList = 1;                            // need this for double zero-termination

    else
        if (S_OK == cnlIsNameInList(pszName, pszList)) {
            fResult = TRUE;                     // this name is already in the list
            goto Exit;
        }

    cchName  = StrLen(pszName)+1;
    cchList += cchName;
    pszList  = (PTSTR)CoTaskMemRealloc(pszList, StrCbFromCch(cchList));
    if (NULL == pszList)
        goto Exit;

    ASSERT(cchList-1 >= cchName);
    StrCpy(pszList + cchList-1 - cchName, pszName);
    *(pszList + cchList-1) = TEXT('\0');        // double-zero terminate
    fResult = (ERROR_SUCCESS == RegSetValueEx(hkCached, RV_NAMESLIST, 0, REG_MULTI_SZ, (PBYTE)pszList, StrCbFromCch(cchList)));

Exit:
    if (NULL != pszList)
        CoTaskMemFree(pszList);

    if (fOwnHk)
        SHCloseKey(hkCached);

    return fResult;
}

HRESULT cnlIsNameInList(PCTSTR pszName, PTSTR pszList /*= NULL*/, HKEY hkCached /*= NULL*/)
{
    PCTSTR  pszCur;
    HRESULT hr;
    BOOL    fOwnList;

    ASSERT(NULL != pszName && TEXT('\0') != *pszName);

    fOwnList = (NULL == pszList);
    if (fOwnList) {
        if (!cnlGetList(&pszList, NULL, hkCached))
            return E_FAIL;

        if (NULL == pszList)                    // shortcut:
            return S_FALSE;                     // the value is not there yet
    }

    for (pszCur = pszList; NULL != pszCur && TEXT('\0') != *pszCur; pszCur += StrLen(pszCur)+1)
        if (0 == StrCmpI(pszName, pszCur))
            break;
    hr = (NULL != pszCur && TEXT('\0') != *pszCur) ? S_OK : S_FALSE;

    if (fOwnList && NULL != pszList)
        CoTaskMemFree(pszList);

    return hr;
}

BOOL cnlGetList(PTSTR *ppszList, PDWORD pcchList /*= NULL*/, HKEY hkCached /*= NULL*/)
{
    DWORD cbList,
          dwType, dwResult;
    BOOL  fOwnHk,
          fResult;

    ASSERT(NULL != ppszList);

    *ppszList = NULL;
    if (NULL != pcchList)
        *pcchList = 0;

    fResult = FALSE;
    fOwnHk  = FALSE;

    if (NULL == hkCached) {
        dwResult = SHOpenKey(g_GetHKCU(), RK_BRND_CS, KEY_QUERY_VALUE, &hkCached);
        if (ERROR_SUCCESS != dwResult) {
            fResult = (ERROR_FILE_NOT_FOUND == dwResult);
            goto Exit;
        }

        fOwnHk = TRUE;
    }

    cbList   = 0;
    dwResult = SHQueryValueEx(hkCached, RV_NAMESLIST, NULL, &dwType, NULL, &cbList);
    if (ERROR_SUCCESS != dwResult) {
        fResult = (ERROR_FILE_NOT_FOUND == dwResult);
        goto Exit;
    }
    ASSERT(REG_MULTI_SZ == dwType);

    *ppszList = (PTSTR)CoTaskMemAlloc(cbList);
    if (NULL == *ppszList)
        goto Exit;

    dwResult = SHQueryValueEx(hkCached, RV_NAMESLIST, NULL, NULL, (PBYTE)*ppszList, &cbList);
    ASSERT(ERROR_SUCCESS == dwResult);

    if (NULL != pcchList)
        *pcchList = StrCchFromCb(cbList);

    fResult = TRUE;

Exit:
    if (!fResult && NULL != *ppszList) {
        CoTaskMemFree(*ppszList);
        *ppszList = NULL;
    }

    if (fOwnHk)
        SHCloseKey(hkCached);

    return fResult;
}


BOOL lbBackup()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lbBackup)

    INTERNET_PER_CONN_OPTION_LISTW listW;
    INTERNET_PER_CONN_OPTIONW      rgOptionsW[7];
    PCWSTR pszAuxW;
    PBYTE  pBlob, pCur;
    DWORD  cbBlob;
    UINT   i;

    Out(LI0(TEXT("Creating a backup copy of LAN settings...")));
    pBlob = NULL;

    ZeroMemory(&listW, sizeof(listW));
    listW.dwSize = sizeof(listW);

    ZeroMemory(rgOptionsW, sizeof(rgOptionsW));
    listW.dwOptionCount = countof(rgOptionsW);
    listW.pOptions      = rgOptionsW;

    listW.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    listW.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    listW.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    listW.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    listW.pOptions[4].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
    listW.pOptions[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    listW.pOptions[6].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;

    cbBlob = listW.dwSize;
    if (FALSE == InternetQueryOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listW, &cbBlob))
        goto Exit;

    //----- Figure out the size of the blob -----
    // size of INTERNET_PER_CONN_OPTION_LIST header
    cbBlob = sizeof(DWORD);                     // listW.dwOptionCount

    // size of INTERNET_PER_CONN_xxx - all of listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        cbBlob += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszAuxW  = listW.pOptions[i].Value.pszValue;
            cbBlob += (DWORD)((NULL != pszAuxW) ? StrCbFromSzW(pszAuxW) : sizeof(DWORD));
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            cbBlob += sizeof(DWORD);
            break;

        default:                        // everything else is also DWORD
            cbBlob += sizeof(DWORD);
        }
    }

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (NULL == pBlob)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    //----- Copy information into the blob -----
    pCur = pBlob;

    // INTERNET_PER_CONN_OPTION_LISTW header
    *((PDWORD)pCur) = listW.dwOptionCount;      // listW.dwOptionCount
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_xxx - all of listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        *((PDWORD)pCur) = listW.pOptions[i].dwOption;
        pCur += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            lbCopySzToBlobW(&pCur, listW.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            *((PDWORD)pCur) = listW.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;

        default:                        // everything else is also DWORD
            *((PDWORD)pCur) = listW.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    SHSetValue(g_GetHKCU(), RK_BRND_CS, RV_LANBACKUP, REG_BINARY, pBlob, cbBlob);

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    if (NULL != listW.pOptions[1].Value.pszValue) // INTERNET_PER_CONN_PROXY_SERVER
        GlobalFree(listW.pOptions[1].Value.pszValue);

    if (NULL != listW.pOptions[2].Value.pszValue) // INTERNET_PER_CONN_PROXY_BYPASS
        GlobalFree(listW.pOptions[2].Value.pszValue);

    if (NULL != listW.pOptions[3].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_URL
        GlobalFree(listW.pOptions[3].Value.pszValue);

    if (NULL != listW.pOptions[5].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL
        GlobalFree(listW.pOptions[5].Value.pszValue);

    Out(LI0(TEXT("Done.\r\n")));
    return TRUE;
}

BOOL lbRestore()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lbRestore)

    INTERNET_PER_CONN_OPTION_LISTW listW;
    INTERNET_PER_CONN_OPTIONW      rgOptionsW[7];
    PBYTE pBlob, pCur;
    HKEY  hk;
    DWORD cbBlob,
          dwResult;
    UINT  i;
    BOOL  fResult;

    Out(LI0(TEXT("Re-setting LAN settings from a backup copy...")));
    pBlob   = NULL;
    fResult = FALSE;

    hk       = NULL;
    dwResult = SHOpenKey(g_GetHKCU(), RK_BRND_CS, KEY_QUERY_VALUE, &hk);
    if (ERROR_SUCCESS != dwResult) {
        fResult = (ERROR_FILE_NOT_FOUND == dwResult);
        goto Exit;
    }

    cbBlob   = 0;
    dwResult = RegQueryValueEx(hk, RV_LANBACKUP, NULL, NULL, NULL, &cbBlob);
    if (ERROR_SUCCESS != dwResult)
        goto Exit;

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (NULL == pBlob)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    dwResult = RegQueryValueEx(hk, RV_LANBACKUP, NULL, NULL, pBlob, &cbBlob);
    ASSERT(ERROR_SUCCESS == dwResult);

    pCur = pBlob;

    //----- Main processing -----
    ZeroMemory(&listW, sizeof(listW));
    listW.dwSize   = sizeof(listW);             // listW.dwSize
    listW.pOptions = rgOptionsW;                // listW.pOptions

    // listW.dwOptionCount
    listW.dwOptionCount = *((PDWORD)pCur);
    pCur += sizeof(DWORD);

    // listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        listW.pOptions[i].dwOption = *((PDWORD)pCur);
        pCur += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            setSzFromBlobW(&pCur, &listW.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
            pCur += sizeof(DWORD);
            break;

        default:                                // everything else is also DWORD
            listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
            pCur += sizeof(DWORD);
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    fResult = InternetSetOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listW, listW.dwSize);

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    SHCloseKey(hk);

    Out(LI0(TEXT("Done.")));
    return fResult;
}

inline void lbCopySzToBlobW(PBYTE *ppBlob, PCWSTR pszStrW)
{
    ASSERT(NULL != ppBlob && NULL != *ppBlob);

    if (NULL == pszStrW) {
        *((PDWORD)(*ppBlob)) = (DWORD)NULL;
        *ppBlob += sizeof(DWORD);
    }
    else {
        StrCpyW((PWSTR)(*ppBlob), pszStrW);
        *ppBlob += StrCbFromSzW(pszStrW);
    }
}


BOOL raBackup()
{   MACRO_LI_PrologEx_C(PIF_STD_C, raBackup)

    HRESULT hr;
    BOOL    fResult;

    Out(LI0(TEXT("Creating a backup copy of Dial-Up settings...")));
    fResult = TRUE;

    hr = SHCopyValue(g_GetHKCU(), RK_INETSETTINGS, g_GetHKCU(), RK_BRND_CS, RV_ENABLESECURITYCHECK);
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_INETSETTINGS, g_GetHKCU(), RK_BRND_CS, RV_ENABLEAUTODIAL);
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_INETSETTINGS, g_GetHKCU(), RK_BRND_CS, RV_NONETAUTODIAL);
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    Out(LI0(TEXT("Done.")));
    return fResult;
}

BOOL raRestore()
{   MACRO_LI_PrologEx_C(PIF_STD_C, raRestore)

    HRESULT hr;
    BOOL    fResult;

    // NOTE: (andrewgu) oliverl wanted me to note that we don't need to do anything about HKCC
    // stuff as per darrenmi win2000 shell doesn't care much for it.
    Out(LI0(TEXT("Re-setting Dial-Up settings from a backup copy...")));
    fResult = TRUE;

    hr = SHCopyValue(g_GetHKCU(), RK_BRND_CS, g_GetHKCU(), RK_INETSETTINGS, RV_ENABLESECURITYCHECK);
    if (STG_E_FILENOTFOUND == hr) {
        SHDeleteValue(g_GetHKCU(), RK_INETSETTINGS, RV_ENABLESECURITYCHECK);
        hr = S_OK;
    }
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_BRND_CS, g_GetHKCU(), RK_INETSETTINGS, RV_ENABLEAUTODIAL);
    if (STG_E_FILENOTFOUND == hr) {
        SHDeleteValue(g_GetHKCU(), RK_INETSETTINGS, RV_ENABLEAUTODIAL);
        hr = S_OK;
    }
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    hr = SHCopyValue(g_GetHKCU(), RK_BRND_CS, g_GetHKCU(), RK_INETSETTINGS, RV_NONETAUTODIAL);
    if (STG_E_FILENOTFOUND == hr) {
        SHDeleteValue(g_GetHKCU(), RK_INETSETTINGS, RV_NONETAUTODIAL);
        hr = S_OK;
    }
    fResult = fResult ? SUCCEEDED(hr) : FALSE;

    Out(LI0(TEXT("Done.")));
    return fResult;
}


HRESULT importRasSettings(PCWSTR pszNameW, PBYTE *ppBlob, LPRASDEVINFOW prdiW, UINT cDevices)
{   MACRO_LI_PrologEx_C(PIF_STD_C, importRasSettings)

    USES_CONVERSION;

    LPRASENTRYW preW;
    TCHAR   szTargetScript[MAX_PATH];
    PWSTR   pszScriptW;
    PBYTE   pCur;
    HRESULT hr;
    DWORD   dwSize, cbRasEntry,
            dwResult;
    UINT    i;
    BOOL    fImpersonate;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL && prdiW != NULL && cDevices >= 1);

    //----- Validate the header -----
    pCur = *ppBlob;
    if (*((PDWORD)pCur) != CS_STRUCT_RAS)
        return E_UNEXPECTED;
    pCur += sizeof(DWORD);

    fImpersonate = FALSE;
    if (g_CtxIsGp())
        fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

    Out(LI0(TEXT("Processing RAS settings...")));
    hr = E_FAIL;

    dwSize = *((PDWORD)pCur);
    pCur  += sizeof(DWORD);

    //----- Main processing -----
    preW = (LPRASENTRYW)pCur;

    // NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYW structure are
    // different on the server and client machines. there is nothing bad with server structure
    // being smaller than the client structure (all RAS apis are backward-compatible). it's bad
    // though when server structure is bigger than client can handle, hence the trancation.
    // (something else to have in mind) this truncation should not affect alternate phone numbers
    // support on winnt.
    if (preW->dwSize > sizeof(RASENTRYW))
        preW->dwSize = sizeof(RASENTRYW);

    // preW->szScript
    if (preW->szScript[0] != L'\0') {
        pszScriptW = preW->szScript;
        if (preW->szScript[0] == L'[')
            pszScriptW = &preW->szScript[1];

        PathCombine(szTargetScript, g_GetTargetPath(), PathFindFileName(W2CT(pszScriptW)));
        if (PathFileExists(szTargetScript))
            StrCpyW(preW->szScript, T2CW(szTargetScript));
        else
            preW->szScript[0] = L'\0';
    }

    // preW->szDeviceName
    for (i = 0; i < cDevices; i++) {
        if (0 == StrCmpIW(preW->szDeviceType, prdiW[i].szDeviceType)) {
            StrCpyW(preW->szDeviceName, prdiW[i].szDeviceName);
            break;
        }
    }
    if (i >= cDevices)
        StrCpyW(preW->szDeviceName, prdiW[0].szDeviceName);

    Out(LI1(TEXT("Set the device name to \"%s\"."), W2CT(preW->szDeviceName)));

    //----- Call into the RAS dll -----
    cbRasEntry = dwSize - 2*sizeof(DWORD);
    dwResult   = RasSetEntryPropertiesWrap(getPhonebookFile(), pszNameW, preW, cbRasEntry);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI1(TEXT("! Creating this RAS connection failed with %s."), GetHrSz(dwResult)));
        goto Exit;
    }

    hr = S_OK;

Exit:
    *ppBlob += dwSize;

    Out(LI0(TEXT("Done.")));
    if (fImpersonate)
        RevertToSelf();

    return hr;
}

HRESULT importRasCredentialsSettings(PCWSTR pszNameW, PBYTE *ppBlob)
{   MACRO_LI_PrologEx_C(PIF_STD_C, importRasCredentialsSettings)

    USES_CONVERSION;

    RASDIALPARAMSW rdpW;
    PWSTR   pszAuxW;
    PBYTE   pCur;
    HRESULT hr;
    DWORD   dwSize,
            dwResult;
    BOOL    fDeletePassword,
            fImpersonate;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL);

    //----- Validate the header -----
    pCur = *ppBlob;
    if (*((PDWORD)pCur) != CS_STRUCT_RAS_CREADENTIALS)
        return E_UNEXPECTED;
    pCur += sizeof(DWORD);

    fImpersonate = FALSE;
    if (g_CtxIsGp())
        fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

    Out(LI0(TEXT("Processing RAS credentials settings...")));
    hr              = E_FAIL;
    fDeletePassword = FALSE;

    dwSize = *((PDWORD)pCur);
    pCur  += sizeof(DWORD);

    //----- Main processing -----
    ZeroMemory(&rdpW, sizeof(rdpW));
    rdpW.dwSize = sizeof(rdpW);

    StrCpyW(rdpW.szEntryName, pszNameW);

    setSzFromBlobW(&pCur, &pszAuxW);
    if (NULL != pszAuxW)
        StrCpyW(rdpW.szUserName, pszAuxW);

    setSzFromBlobW(&pCur, &pszAuxW);
    if (NULL != pszAuxW)
        StrCpyW(rdpW.szPassword, pszAuxW);

    setSzFromBlobW(&pCur, &pszAuxW);
    if (NULL != pszAuxW)
        StrCpyW(rdpW.szDomain, pszAuxW);

    if (rdpW.szPassword[0] == L'\0')
        fDeletePassword = TRUE;

    if (rdpW.szDomain[0] == L'\0') {
        rdpW.szDomain[0]  = L' ';
        ASSERT(rdpW.szDomain[1] == L'\0');
    }

    //----- Call into the RAS dll -----
    dwResult = RasSetEntryDialParamsWrap(getPhonebookFile(), &rdpW, fDeletePassword);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI1(TEXT("! Setting RAS credentials for this connection failed with %s."), GetHrSz(dwResult)));
        goto Exit;
    }

    hr = S_OK;

Exit:
    Out(LI0(TEXT("Done.")));
    *ppBlob += dwSize;
    if (fImpersonate)
        RevertToSelf();

    return hr;
}

HRESULT importWininetSettings(PCWSTR pszNameW, PBYTE *ppBlob)
{   MACRO_LI_PrologEx_C(PIF_STD_C, importWininetSettings)

    USES_CONVERSION;

    INTERNET_PER_CONN_OPTION_LISTW listW;
    INTERNET_PER_CONN_OPTIONW      rgOptionsW[7];
    PBYTE   pCur;
    HRESULT hr;
    DWORD   dwSize;
    UINT    i;

    ASSERT(ppBlob != NULL && *ppBlob != NULL);

    //----- Validate the header -----
    pCur = *ppBlob;
    if (*((PDWORD)pCur) != CS_STRUCT_WININET)
        return E_UNEXPECTED;
    pCur += sizeof(DWORD);

    Out(LI0(TEXT("Processing Wininet.dll settings...")));
    hr = E_FAIL;

    dwSize = *((PDWORD)pCur);
    pCur  += sizeof(DWORD);

    //----- Main processing -----
    ZeroMemory(&listW, sizeof(listW));
    listW.dwSize   = sizeof(listW);             // listW.dwSize
    listW.pOptions = rgOptionsW;                // listW.pOptions

    // listW.pszConnection
    listW.pszConnection = (PWSTR)pszNameW;

    // listW.dwOptionCount
    listW.dwOptionCount = *((PDWORD)pCur);
    pCur += sizeof(DWORD);

    // listW.pOptions
    for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
        listW.pOptions[i].dwOption = *((PDWORD)pCur);
        pCur += sizeof(DWORD);

        switch (listW.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            setSzFromBlobW(&pCur, &listW.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == *ppBlob + dwSize);

    if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP))) {
        ASSERT(listW.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

        if (HasFlag(listW.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
            DWORD dwFlags;

            dwFlags  = getWininetFlagsSetting(W2CT(listW.pszConnection));
            dwFlags |= listW.pOptions[0].Value.dwValue;
            listW.pOptions[0].Value.dwValue = dwFlags;
        }
        else {
            hr = S_OK;                            // nothing to do since had only proxy stuff to
            Out(LI0(TEXT("No customizations!"))); // begin with. and now even that is not there
            goto Exit;
        }
    }

    //----- Merge new LAN's ProxyBypass settings with the existing ones -----
    // NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
    // ins file as well, it makes no sense to do this here because what's in the ins
    // should overwrite what's in the imported connections settings.

    //----- Call into Wininet.dll -----
    if (FALSE == InternetSetOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listW, listW.dwSize)) {
        Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
        goto Exit;
    }

    hr = S_OK;

Exit:
    Out(LI0(TEXT("Done.")));
    *ppBlob += dwSize;
    return hr;
}


inline void setSzFromBlobA(PBYTE *ppBlob, UNALIGNED CHAR **ppszStrA)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL && ppszStrA != NULL);

    if ((**ppBlob) == NULL) {
        (*ppszStrA) = NULL;
        (*ppBlob)  += sizeof(DWORD);
    }
    else {
        (*ppszStrA) = (PSTR)(*ppBlob);
        (*ppBlob)  += StrCbFromSzA(*ppszStrA);
    }
}

inline void setSzFromBlobW(PBYTE *ppBlob, UNALIGNED WCHAR **ppszStrW)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL && ppszStrW != NULL);

    if ((**ppBlob) == NULL) {
        (*ppszStrW) = NULL;
        (*ppBlob)  += sizeof(DWORD);
    }
    else {
        (*ppszStrW) = (PWSTR)(*ppBlob);
        (*ppBlob)  += StrCbFromSzUAW(*ppszStrW);
    }
}


HRESULT insProcessAutoconfig(PCTSTR pszName)
{   MACRO_LI_PrologEx_C(PIF_STD_C, insProcessAutoconfig)

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      rgOptions[4];
    TCHAR   szAutoConfigURL[INTERNET_MAX_URL_LENGTH],
            szAutoProxyURL [INTERNET_MAX_URL_LENGTH];
    HRESULT hr;
    DWORD   dwTime;
    int     iDetectConfig,
            iAutoConfig;

    Out(LI0(TEXT("Processing autoconfig settings from the ins file...")));

    szAutoConfigURL[0] = TEXT('\0');
    szAutoProxyURL [0] = TEXT('\0');
    hr                 = S_OK;
    dwTime             = 0;
    iDetectConfig      = InsGetInt(IS_URL, IK_DETECTCONFIG, -1, g_GetIns());
    iAutoConfig        = InsGetInt(IS_URL, IK_USEAUTOCONF,  -1, g_GetIns());

    if (iDetectConfig == -1 && iAutoConfig == -1) {
        Out(LI0(TEXT("Autoconfiguration settings are not customized!")));
        hr = S_FALSE;
        goto Exit;
    }

    if (iAutoConfig == (int)TRUE) {
        if (InsGetBool(IS_URL, IK_LOCALAUTOCONFIG, FALSE, g_GetIns())) {
            StrCpy(szAutoConfigURL, FILEPREFIX);
            StrCat(szAutoConfigURL, g_GetIns());
        }
        else
            InsGetString(IS_URL, IK_AUTOCONFURL, szAutoConfigURL, countof(szAutoConfigURL), g_GetIns());

        InsGetString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL, countof(szAutoProxyURL), g_GetIns());
        dwTime = InsGetInt(IS_URL, IK_AUTOCONFTIME, 0, g_GetIns());
    }

    ZeroMemory(&list, sizeof(list));
    list.dwSize = sizeof(list);

    list.pszConnection = NULL;
    if (pszName != NULL && *pszName != TEXT('\0'))
        list.pszConnection = (PTSTR)pszName;

    list.pOptions = rgOptions;

    ZeroMemory(rgOptions, sizeof(rgOptions));

    if (iAutoConfig == -1) {
        ASSERT(iDetectConfig == (int)FALSE || iDetectConfig == (int)TRUE);
        list.dwOptionCount = 1;

        rgOptions[0].dwOption      = INTERNET_PER_CONN_FLAGS;
        rgOptions[0].Value.dwValue = getWininetFlagsSetting();
        SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_AUTO_DETECT, FALSE);
        SetFlag(&rgOptions[0].Value.dwValue, ((iDetectConfig == (int)TRUE) ? PROXY_TYPE_AUTO_DETECT : 0));
        Out(LI1(TEXT("\"Flags\" is set to 0x%lX."), rgOptions[0].Value.dwValue));
    }
    else {
        list.dwOptionCount = countof(rgOptions);

        rgOptions[0].dwOption      = INTERNET_PER_CONN_FLAGS;
        rgOptions[0].Value.dwValue = getWininetFlagsSetting();
        SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_AUTO_PROXY_URL, FALSE);
        SetFlag(&rgOptions[0].Value.dwValue, ((iAutoConfig == (int)TRUE) ? PROXY_TYPE_AUTO_PROXY_URL : 0));
        if (iDetectConfig != -1) {
            ASSERT(iDetectConfig == (int)FALSE || iDetectConfig == (int)TRUE);

            SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_AUTO_DETECT, FALSE);
            SetFlag(&rgOptions[0].Value.dwValue, ((iDetectConfig == (int)TRUE) ? PROXY_TYPE_AUTO_DETECT : 0));
        }
        Out(LI1(TEXT("\"Flags\" is set to 0x%lX."), rgOptions[0].Value.dwValue));

        rgOptions[1].dwOption       = INTERNET_PER_CONN_AUTOCONFIG_URL;
        rgOptions[1].Value.pszValue = szAutoConfigURL;

        rgOptions[2].dwOption       = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
        rgOptions[2].Value.pszValue = szAutoProxyURL;

        if (szAutoConfigURL[0] == TEXT('\0') && szAutoProxyURL[0] != TEXT('\0')) {
            rgOptions[1].Value.pszValue = szAutoProxyURL;
            rgOptions[2].Value.pszValue = TEXT("");
        }
        Out(LI1(TEXT("\"Autoconfig URL\" is set to \"%s\"."), rgOptions[1].Value.pszValue));
        Out(LI1(TEXT("\"Autoproxy URL\" is set to \"%s\"."),  rgOptions[2].Value.pszValue));

        rgOptions[3].dwOption      = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
        rgOptions[3].Value.dwValue = dwTime;
        Out(LI1(TEXT("\"Autoconfig reload delay\" is set to %u minutes."), rgOptions[3].Value.dwValue));
    }

    if (FALSE == InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, list.dwSize)) {
        Out(LI0(TEXT("! Internal failure.")));
        hr = E_FAIL;
    }

Exit:
    Out(LI0(TEXT("Done.")));
    return hr;
}

HRESULT insProcessProxy(PCTSTR pszName)
{   MACRO_LI_PrologEx_C(PIF_STD_C, insProcessProxy)

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      rgOptions[3];
    TCHAR   szProxy[MAX_PATH], szHttpProxy[MAX_PATH],
            szProxyBypass[MAX_STRING];
    TCHAR   *pszProxy = NULL;
    HRESULT hr;
    int     iUseProxy;
    BOOL    fUseSameProxy = FALSE;

    Out(LI0(TEXT("Processing proxy settings from the ins file...")));
    hr = S_OK;

    iUseProxy = InsGetInt(IS_PROXY, IK_PROXYENABLE, -1, g_GetIns());
    if (iUseProxy == -1) {
        Out(LI0(TEXT("Proxy settings are not customized!")));
        hr = S_FALSE;
        goto Exit;
    }
    ASSERT(iUseProxy == (int)FALSE || iUseProxy == (int)TRUE);

    InsGetString(IS_PROXY, IK_HTTPPROXY, szHttpProxy, countof(szHttpProxy), g_GetIns());

    fUseSameProxy = InsGetBool(IS_PROXY, IK_SAMEPROXY, FALSE, g_GetIns());
    if (fUseSameProxy)
    {
        StrCpy(szProxy , szHttpProxy);
        pszProxy = szProxy;
    }
    else {
        TCHAR szSecureProxy[MAX_PATH],
              szFtpProxy   [MAX_PATH],
              szGopherProxy[MAX_PATH],
              szSocksProxy [MAX_PATH];

        pszProxy = (TCHAR*)CoTaskMemAlloc(StrCbFromCch(5*(MAX_PATH+1) + 64));
        if (pszProxy == NULL)
        {
            Out(LI0(TEXT("! Internal processing ran out of memory.")));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pszProxy, StrCbFromCch(5*(MAX_PATH+1) + 64));
        InsGetString(IS_PROXY, IK_SECPROXY,    szSecureProxy, countof(szSecureProxy), g_GetIns());
        InsGetString(IS_PROXY, IK_FTPPROXY,    szFtpProxy,    countof(szFtpProxy),    g_GetIns());
        InsGetString(IS_PROXY, IK_GOPHERPROXY, szGopherProxy, countof(szGopherProxy), g_GetIns());
        InsGetString(IS_PROXY, IK_SOCKSPROXY,  szSocksProxy,  countof(szSocksProxy),  g_GetIns());

        pszProxy[0] = TEXT('\0');
        if (szHttpProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("http="));
            StrCat(pszProxy, szHttpProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szSecureProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("https="));
            StrCat(pszProxy, szSecureProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szFtpProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("ftp="));
            StrCat(pszProxy, szFtpProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szGopherProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("gopher="));
            StrCat(pszProxy, szGopherProxy);
            StrCat(pszProxy, TEXT(";"));
        }

        if (szSocksProxy[0] != TEXT('\0')) {
            StrCat(pszProxy, TEXT("socks="));
            StrCat(pszProxy, szSocksProxy);
        }

        if (pszProxy[StrLen(pszProxy) - 1] == TEXT(';'))
            pszProxy[StrLen(pszProxy) - 1]  = TEXT('\0');
    }

    InsGetString(IS_PROXY, IK_PROXYOVERRIDE, szProxyBypass, countof(szProxyBypass), g_GetIns());

    ZeroMemory(&list, sizeof(list));
    list.dwSize = sizeof(list);

    list.pszConnection = NULL;
    if (pszName != NULL && *pszName != TEXT('\0'))
        list.pszConnection = (PTSTR)pszName;

    if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP)))
        if (szProxyBypass[0] != TEXT('\0')) {
            TCHAR szMerged[MAX_STRING];

            mergeProxyBypass(pszName, szProxyBypass, szMerged, countof(szMerged));
            if (szMerged[0] != TEXT('\0'))
                StrCpy(szProxyBypass, szMerged);
        }

    list.dwOptionCount = countof(rgOptions);
    list.pOptions      = rgOptions;

    ZeroMemory(&rgOptions, sizeof(rgOptions));
    rgOptions[0].dwOption       = INTERNET_PER_CONN_FLAGS;
    rgOptions[0].Value.dwValue  = getWininetFlagsSetting(pszName);
    SetFlag(&rgOptions[0].Value.dwValue, PROXY_TYPE_PROXY, FALSE);
    SetFlag(&rgOptions[0].Value.dwValue, ((BOOL)iUseProxy ? PROXY_TYPE_PROXY : 0));
    Out(LI1(TEXT("\"Flags\" is set to 0x%lX."), rgOptions[0].Value.dwValue));

    rgOptions[1].dwOption       = INTERNET_PER_CONN_PROXY_SERVER;
    rgOptions[1].Value.pszValue = pszProxy;
    Out(LI1(TEXT("\"ProxyServer\" is set to \"%s\"."), rgOptions[1].Value.pszValue));

    rgOptions[2].dwOption       = INTERNET_PER_CONN_PROXY_BYPASS;
    rgOptions[2].Value.pszValue = szProxyBypass;
    Out(LI1(TEXT("\"ProxyBypass\" is set to \"%s\"."), rgOptions[2].Value.pszValue));

    if (FALSE == InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, list.dwSize)) {
        Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
        hr = E_FAIL;
    }

Exit:
    if (!fUseSameProxy && (pszProxy != NULL))
        CoTaskMemFree(pszProxy);
    Out(LI0(TEXT("Done.")));
    return hr;
}


DWORD getWininetFlagsSetting(PCTSTR pszName /*= NULL*/)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      option;
    DWORD dwResult,
          dwSize;

    dwResult = 0;

    ZeroMemory(&list, sizeof(list));
    list.dwSize        = sizeof(list);
    list.pszConnection = (PTSTR)pszName;
    list.dwOptionCount = 1;
    list.pOptions      = &option;

    ZeroMemory(&option, sizeof(option));
    option.dwOption = INTERNET_PER_CONN_FLAGS;

    dwSize = list.dwSize;
    if (TRUE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwSize))
        dwResult = option.Value.dwValue;

    return dwResult;
}

BOOL mergeProxyBypass(PCTSTR pszName, PCTSTR pszProxyBypass, PTSTR pszResult, UINT cchResult)
{   MACRO_LI_PrologEx_C(PIF_STD_C, mergeProxyBypass)

    static const TCHAR s_szLocal[] = LOCALPROXY;

    INTERNET_PER_CONN_OPTION_LIST list;
    INTERNET_PER_CONN_OPTION      option;
    TCHAR szBuf[MAX_STRING];
    PTSTR pszNew, pszOld,
          pszCur, pszNext,
          pszToken, pszAux;
    DWORD dwSize;
    UINT  nLen, nTokenLen;
    BOOL  fResult,
          fHasLocal;

    if (pszResult == NULL)
        return FALSE;
    *pszResult = TEXT('\0');

    fResult = FALSE;

    ASSERT(StrLen(pszProxyBypass) < countof(szBuf));
    szBuf[0] = TEXT('\0');
    StrCpy(szBuf, pszProxyBypass);
    pszNew   = szBuf;

    // REVIEW: (andrewgu) which one takes precedence: pszNew or pszOld?
    Out(LI1(TEXT("New \"ProxyBypass\" settings are \"%s\"."), pszNew));
    trimProxyBypass(pszNew);

    ZeroMemory(&list, sizeof(list));
    list.dwSize = sizeof(list);

    list.pszConnection = NULL;
    if (pszName != NULL && *pszName != TEXT('\0'))
        list.pszConnection = (PTSTR)pszName;

    list.dwOptionCount = 1;
    list.pOptions      = &option;

    ZeroMemory(&option, sizeof(option));
    option.dwOption = INTERNET_PER_CONN_PROXY_BYPASS;

    pszOld = NULL;
    dwSize = list.dwSize;
    if (FALSE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwSize)) {
        Out(LI0(TEXT("! Retrieving existing \"ProxyBypass\" settings failed.")));
        goto Exit;
    }

    pszOld = option.Value.pszValue;
    Out(LI1(TEXT("Existing \"ProxyBypass\" settings are \"%s\"."), (NULL != pszOld) ? pszOld : TEXT("")));

    if (pszOld == NULL || *pszOld == TEXT('\0'))
        goto SetOutParams;

    trimProxyBypass(pszOld);

    // make sure that at least the old setting will fit in the out-param
    if (cchResult != 0 && (UINT)StrLen(pszOld) >= cchResult) {
        ASSERT(FALSE);
        goto Exit;
    }

    //----- Deal with <local> -----
    Out(LI0(TEXT("Merging existing and new \"ProxyBypass\" settings...")));

    // NOTE: (andrewgu) This processing is needed based on the perception that <local> has to be
    // at the end (the very last token)
    fHasLocal = FALSE;

    pszAux = StrStrI(pszOld, s_szLocal);
    if (pszAux != NULL) {
        // remove <local>, including trailing ';' if any
        nLen = countof(s_szLocal)-1;
        if (*(pszAux + nLen) == TEXT(';'))
            nLen++;
        StrCpy(pszAux, pszAux + nLen);

        fHasLocal = TRUE;
    }

    pszAux = StrStrI(pszNew, s_szLocal);
    if (pszAux != NULL) {
        // remove <local>, including trailing ';' if any
        nLen = countof(s_szLocal)-1;
        if (*(pszAux + nLen) == TEXT(';'))
            nLen++;
        StrCpy(pszAux, pszAux + nLen);

        fHasLocal = TRUE;
    }

    //----- Main Loop -----
    for (pszCur = pszNew; pszCur != NULL && *pszCur != TEXT('\0'); pszCur = pszNext) {

        //_____ Form token in pszNew (zero terminated) pointed to by pszCur _____
        pszNext = StrChr(pszCur, TEXT(';'));
        if (pszNext != NULL) {
            *pszNext  = TEXT('\0');
            nTokenLen = UINT(pszNext - pszCur);

            pszNext++;
            ASSERT(*pszNext != TEXT(';'));      // due to trimProxyBypass
        }
        else
            nTokenLen = StrLen(pszCur);

        //_____ Find this token in pszOld _____
        ASSERT(*pszCur != TEXT('\0'));          // a little involved, but true

        pszToken = StrStrI(pszOld, pszCur);
        if (pszToken != NULL) {
            ASSERT(nTokenLen <= (UINT)StrLen(pszToken));
            pszAux = pszToken + nTokenLen;

            if ((pszToken == pszOld || *(pszToken - 1) == TEXT(';')) &&
                (*pszAux == TEXT(';') || *pszAux == TEXT('\0'))) {

                if (*pszAux == TEXT(';'))
                    // copy the tail on top of pszToken
                    StrCpy(pszToken, pszToken + nTokenLen+1);

                else /* if (*pszAux == TEXT('\0')) */
                    // simply zero terminate
                    if (pszToken > pszOld) {
                        ASSERT(*(pszToken-1) == TEXT(';'));
                        *(pszToken-1) = TEXT('\0');
                    }
                    else 
                        *pszToken = TEXT('\0');
            }
        }

        //_____ Restore separator in pszNew _____
        if (pszNext != NULL) {
            pszAux = pszCur + nTokenLen;
            ASSERT(pszAux == pszNext - 1);      // due to trimProxyBypass
            ASSERT(*pszAux == TEXT('\0'));
            *pszAux = TEXT(';');
        }

        if (*pszOld == TEXT('\0'))
            break;
    }

    //----- Endgame -----
    pszAux = NULL;
    nLen   = StrLen(pszNew);
    nLen  += (*pszOld != TEXT('\0')) ? (1 + StrLen(pszOld)) : 0;
    nLen  += (UINT)(fHasLocal               ?   countof(s_szLocal) : 0);

    // if the combined setting won't fit, fall back and return the old setting
    if (cchResult != 0 && nLen >= cchResult) {
        ASSERT(FALSE);
        pszNew = pszOld;                        // repoint pszNew
        goto SetOutParams;
    }

    if (nLen >= countof(szBuf)) {
        pszAux = (PTSTR)CoTaskMemAlloc(nLen + 1);
        if (pszAux != NULL) {
            ZeroMemory(pszAux, nLen + 1);
            StrCpy(pszAux, pszNew);
            pszNew = pszAux;                    // repoint pszNew
        }
    }

    if (*pszOld != TEXT('\0')) {
        StrCat(pszNew, TEXT(";"));
        StrCat(pszNew, pszOld);
    }

    if (fHasLocal) {
        StrCat(pszNew, TEXT(";"));
        StrCat(pszNew, s_szLocal);
    }

SetOutParams:
    if (cchResult != 0 && (UINT)StrLen(pszNew) >= cchResult)
        goto Exit;

    StrCpy(pszResult, pszNew);
    Out(LI1(TEXT("The final \"ProxyBypass\" settings are \"%s\"."), pszResult));

    fResult = TRUE;

Exit:
    if (pszNew != szBuf && pszNew != pszOld)    // pszNew has been CoTaskMemAlloc'ed
        CoTaskMemFree(pszNew);

    if (pszOld != NULL)
        GlobalFree(pszOld);

    return fResult;
}

void trimProxyBypass(PTSTR pszProxyBypass)
{
    PTSTR pszOld, pszNew, pszToken;

    ASSERT(pszProxyBypass != NULL);

    for (pszToken = pszNew = pszOld  = pszProxyBypass;
         pszNew  != NULL && *pszNew != TEXT('\0');
         pszToken = pszNew) {

        pszNew = StrChr(pszToken, TEXT(';'));
        if (pszNew != NULL) {
            *pszNew  = TEXT('\0');
            pszNew  += 1 + StrSpn(pszNew + 1, TEXT(";"));
        }

        StrRemoveWhitespace(pszToken);
        if (*pszToken == TEXT('\0'))
            continue;
        ASSERT(pszToken >= pszOld);

        if (pszOld > pszProxyBypass) {
            ASSERT(*pszOld == TEXT('\0'));
            *pszOld++ = TEXT(';');
        }

        StrCpy(pszOld, pszToken);
        pszOld += StrLen(pszToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brandfav.h ===
#ifndef _BRANDFAV_H_
#define _BRANDFAV_H_

//----- Favorites ordering -----
// stolen from shell\inc\shguidp.h
DEFINE_GUID(CLSID_OrderListExport, 0xf3368374, 0xcf19, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
DEFINE_GUID(IID_IOrderList,        0x8bfcb27d, 0xcf1a, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// stolen from shell\inc\shellp.h
//
// IOrderList - for ordering info in favorites/channels
//
// Typical usage is: GetOrderList, AllocOrderItem, insert into correct
// position, SetOrderList, and then FreeOrderList.
//
typedef struct {
    LPITEMIDLIST pidl;                          // IDlist for this item
    int          nOrder;                        // Ordinal indicating user preference
    DWORD        lParam;                        // store custom order info.
} ORDERITEM, * PORDERITEM;

// Values for SortOrderList
#define OI_SORTBYNAME    0
#define OI_SORTBYORDINAL 1
#define OI_MERGEBYNAME   2

#undef  INTERFACE
#define INTERFACE  IOrderList
DECLARE_INTERFACE_(IOrderList, IUnknown)
{
    // IUnknown
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IOrderList
    STDMETHOD(GetOrderList)  (THIS_ HDPA *phdpa) PURE;
    STDMETHOD(SetOrderList)  (THIS_ HDPA hdpa, IShellFolder *psf) PURE;
    STDMETHOD(FreeOrderList) (THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList) (THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM *ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem) (THIS_ PORDERITEM poi) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\clear.h ===
#ifndef _CLEAR_H_
#define _CLEAR_H_

void ClearZonesHklm(DWORD dwFlags = FF_ENABLE);
void ClearRatings(DWORD dwFlags = FF_ENABLE);
void ClearAuthenticode(DWORD dwFlags = FF_ENABLE);
void ClearGeneral(DWORD dwFlags = FF_ENABLE);
void ClearChannels(DWORD dwFlags = FF_ENABLE);
void ClearToolbarButtons(DWORD dwFlags = FF_ENABLE);

// brandfav.cpp
void ClearFavorites(DWORD dwFlags = FF_ENABLE);

// brandcs.cpp
void ClearConnectionSettings(DWORD dwFlags = FF_ENABLE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\brandfav.cpp ===
#include "precomp.h"
#include <intshcut.h>
#include <shlobjp.h>                            // for SHChangeDWORDAsIDList only
#include <comctrlp.h>                           // for the DPA stuff only
#include "favs.h"

#include <initguid.h>
#include "brandfav.h"

// Private forward decalarations
#define MAX_QUICKLINKS 50

static IShellFolder *s_psfDesktop = NULL;

#define FD_REMOVE_POLICY_CREATED  0x00010000

#define DFEP_DELETEORDERSTREAM    0x00000001
#define DFEP_DELETEOFFLINECONTENT 0x00000002
#define DFEP_DELETEEMPTYFOLDER    0x00000004

typedef struct {
    ISubscriptionMgr2 *psm;
    DWORD dwInsFlags;
    DWORD dwEnumFlags;
} DFEPSTRUCT, *PDFEPSTRUCT;

HRESULT processFavoritesOrdering(BOOL fQL);

HRESULT pepSpecialFoldersEnumProc (LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);
HRESULT pepDeleteFavoritesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);

HRESULT deleteFavoriteOfflineContent(LPCTSTR pszFavorite, IUnknown *punk = NULL, ISubscriptionMgr2 *psm = NULL);

HRESULT deleteFavoriteFolder(LPCTSTR pszFolder);
HRESULT pepIsFolderEmptyEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);

BOOL isFileAttributeIncluded(UINT nFlags, DWORD dwFileAttributes);
UINT isSpecialFolderIncluded(UINT nFlags, LPCTSTR pszPath); // 0 - nothing, 1 - FD_FOLDER, 2 - FD_EMPTY_FOLDERS

HRESULT replacePlaceholders(LPCTSTR pszSrc, LPCTSTR pszIns, LPTSTR pszBuffer, PUINT pcchBuffer, BOOL fLookupLDID = FALSE);

DWORD   getFavItems        (LPCTSTR pcszSection, LPCTSTR pcszFmt, LPTSTR *ppszFavItems);
HRESULT orderFavorites     (LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPTSTR pszFavItems, DWORD cFavs);
HRESULT orderFavoriteFolder(LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPCTSTR pcszFavItems, DWORD cFavs);
DWORD   getFolderSection   (LPCTSTR pcszFolderName, LPTSTR pszSection, LPTSTR *ppszFolderItems, LPDWORD pdwNItems);


void ClearFavoritesThread()
{
    DFEPSTRUCT dfep;
    PCTSTR     pszFavorites;
    HRESULT    hr;


    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }

    //----- Initialization -----
    Out(LI0(TEXT("Clearing favorites...")));
    ZeroMemory(&dfep, sizeof(dfep));

    dfep.dwInsFlags = FD_FAVORITES |
        FD_CHANNELS      | FD_SOFTWAREUPDATES  |
        FD_QUICKLINKS    | FD_EMPTY_QUICKLINKS |
        FD_REMOVE_HIDDEN | FD_REMOVE_SYSTEM    |
        FD_REMOVE_POLICY_CREATED;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&dfep.psm);
    if (SUCCEEDED(hr))
        dfep.dwEnumFlags |= DFEP_DELETEOFFLINECONTENT;

    else
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));

    { MACRO_LI_Offset(1);                       // need a new scope

    Out(LI0(TEXT("Determining paths to special folders...")));
    pszFavorites = GetFavoritesPath();
    if (NULL == pszFavorites) {
        Out(LI0(TEXT("! The path to the <Favorites> folder could not be determined.")));
        goto Exit;
    }

    GetChannelsPath();
    GetSoftwareUpdatesPath();
    GetLinksPath();
    Out(LI0(TEXT("Done.\r\n")));

    }                                           // end of offset scope

    //----- Main processing -----
    hr = PathEnumeratePath(pszFavorites,
        PEP_SCPE_NOFOLDERS | PEP_CTRL_USECONTROL,
        pepDeleteFavoritesEnumProc, (LPARAM)&dfep);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Enumeration of favorites in <Favorites> folder failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

    // cleanup favorites subfolders with regard to special ones
    hr = PathEnumeratePath(pszFavorites,
        PEP_SCPE_NOFILES | PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL | PEP_CTRL_USECONTROL,
        pepSpecialFoldersEnumProc, (LPARAM)&dfep);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Enumeration of special folders failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

Exit:
    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    Out(LI0(TEXT("Done.")));

}

void ClearFavorites(DWORD dwFlags /*= FF_ENABLE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ClearFavorites)

    UNREFERENCED_PARAMETER(dwFlags);

    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for clearing favorites...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClearFavoritesThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, clearing favorites on this thread...\r\n")));
        ClearFavoritesThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }
}

void DeleteFavoritesThread()
{
    DFEPSTRUCT dfep;
    LPCTSTR    pszFavorites;
    HRESULT    hrResult, hr;

    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }

    //----- Initialization -----
    hrResult = E_FAIL;
    ZeroMemory(&dfep, sizeof(dfep));

    dfep.dwInsFlags = GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, g_GetIns());
    if (HasFlag(dfep.dwInsFlags, FD_REMOVE_IEAK_CREATED))
        Out(LI0(TEXT("Only the favorites and quick links created by the IEAK will be deleted!")));

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&dfep.psm);
    if (SUCCEEDED(hr))
        dfep.dwEnumFlags |= DFEP_DELETEOFFLINECONTENT;

    else
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));

    { MACRO_LI_Offset(1);                       // need a new scope

    Out(LI0(TEXT("Determining paths to special folders...")));
    pszFavorites = GetFavoritesPath();
    if (pszFavorites == NULL) {
        Out(LI0(TEXT("! The path to the <Favorites> folder could not be determined.")));
        goto Exit;
    }

    GetChannelsPath();
    GetSoftwareUpdatesPath();
    GetLinksPath();
    Out(LI0(TEXT("Done.\r\n")));

    }                                           // end of offset scope

    //----- Main processing -----
    if (HasFlag(dfep.dwInsFlags, FD_FAVORITES)) {
        dfep.dwEnumFlags |= DFEP_DELETEEMPTYFOLDER;

        if (HasFlag(dfep.dwInsFlags, FD_EMPTY_FAVORITES)) {
            // go at it at full steam
            hrResult = PathEnumeratePath(pszFavorites,
                PEP_CTRL_USECONTROL,
                pepDeleteFavoritesEnumProc, (LPARAM)&dfep);
            if (FAILED(hrResult)) {
                Out(LI1(TEXT("! Enumeration of favorites failed with %s."), GetHrSz(hrResult)));
                goto Exit;
            }

            deleteFavoriteFolder(pszFavorites);

            SHDeleteKey(g_GetHKCU(), RK_FAVORDER);
            Out(LI0(TEXT("The entire <Favorites> folder removed!")));
        }
        else {
            Out(LI0(TEXT("The <Favorites> folder is being cleaned with regard to special folders...")));

            // cleanup up favorites in the Favorites folder
            hrResult = PathEnumeratePath(pszFavorites,
                PEP_SCPE_NOFOLDERS | PEP_CTRL_USECONTROL,
                pepDeleteFavoritesEnumProc, (LPARAM)&dfep);
            if (FAILED(hrResult)) {
                Out(LI1(TEXT("! Enumeration of favorites in <Favorites> folder failed with %s."), GetHrSz(hrResult)));
                goto Exit;
            }

            SHDeleteValue(g_GetHKCU(), RK_FAVORDER, RV_ORDER);

            // cleanup favorites subfolders with regard to special ones
            hrResult = PathEnumeratePath(pszFavorites,
                PEP_SCPE_NOFILES | PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL | PEP_CTRL_USECONTROL,
                pepSpecialFoldersEnumProc, (LPARAM)&dfep);
            if (FAILED(hrResult)) {
                Out(LI1(TEXT("! Enumeration of special folders failed with %s."), GetHrSz(hrResult)));
                goto Exit;
            }

            Out(LI0(TEXT("<Favorites> folder emptied.")));
        }
    }
    else {
        Out(LI0(TEXT("Processing special folders only...")));

        // cleanup only special favorites subfolders
        hrResult = PathEnumeratePath(pszFavorites,
            PEP_SCPE_NOFILES | PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL | PEP_CTRL_USECONTROL,
            pepSpecialFoldersEnumProc, (LPARAM)&dfep);
        if (FAILED(hrResult))
            Out(LI1(TEXT("! Enumeration of special folders failed with %s."), GetHrSz(hrResult)));
    }

Exit:
    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    if (dfep.psm != NULL)
        dfep.psm->Release();
}

HRESULT ProcessFavoritesDeletion()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessFavoritesDeletion)

    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for deleting favorites...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DeleteFavoritesThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, deleting favorites on this thread...\r\n")));
        DeleteFavoritesThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }

    return S_OK;

}

void ProcessFavoritesThread()
{
    IUnknown  *punk;
    ISubscriptionMgr2 *pSubMgr2;
    CFavorite fav;
    TCHAR     szAux[2*MAX_PATH + 1],
              szKey[32];
    HRESULT   hr;
    BOOL      fNewFormat,
              fContinueOnFailure, fTotalSuccess;

    hr                 = S_OK;
    punk               = NULL;
    pSubMgr2           = NULL;
    fContinueOnFailure = TRUE;
    fTotalSuccess      = TRUE;

    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }

    wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, 1);
    fNewFormat = !InsIsKeyEmpty(IS_FAVORITESEX, szKey, g_GetIns());

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)&punk);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of InternetShortcut object failed with %s."), GetHrSz(hr)));
        if (SUCCEEDED(hrComInit))
            CoUninitialize();
        return;
    }

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *) &pSubMgr2);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));
        hr = S_OK;                              // don't treat this as an error
    }

    if (fNewFormat) {
        Out(LI0(TEXT("Using [FavoritesEx] section...\r\n")));

        // for corp, mark the favorites created so that they can be deleted without deleting user created ones
        fav.m_fMarkIeakCreated = g_CtxIs(CTX_CORP | CTX_AUTOCONFIG | CTX_GP);

        for (UINT i = 1; TRUE; i++) {
            MACRO_LI_Offset(1);
            if (i > 1)
                Out(LI0(TEXT("\r\n")));

            // processing title
            wnsprintf(szKey, countof(szKey), IK_TITLE_FMT, i);
            Out(LI1(TEXT("Preprocessing \"%s\" title key..."), szKey));

            hr = formStrWithoutPlaceholders(IS_FAVORITESEX, szKey, g_GetIns(),
                fav.m_szTitle, countof(fav.m_szTitle), FSWP_VALUE);
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure) {
                    fTotalSuccess = FALSE;
                    continue;
                }
                else
                    break;
            }

            ASSERT(fav.m_szTitle[0] == TEXT('\0'));
            if (fav.m_szTitle[1] == TEXT('\0')) {
                Out(LI0(TEXT("This key doesn't exist indicating that there are no more favorites.")));
                break;
            }

            StrCpy(fav.m_szTitle, &fav.m_szTitle[1]);

            // processing URL
            wnsprintf(szKey, countof(szKey), IK_URL_FMT, i);
            Out(LI1(TEXT("Preprocessing \"%s\" URL key..."), szKey));

            hr = formStrWithoutPlaceholders(IS_FAVORITESEX, szKey, g_GetIns(),
                fav.m_szUrl, countof(fav.m_szUrl), FSWP_VALUE | FSWP_VALUELDID);
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure) {
                    fTotalSuccess = FALSE;
                    continue;
                }
                else
                    break;
            }

            ASSERT(fav.m_szUrl[0] == TEXT('\0') && fav.m_szUrl[1] != TEXT('\0'));
            StrCpy(fav.m_szUrl, &fav.m_szUrl[1]);

            // processing icon file (no need to process with formStrWithoutPlaceholders)
            wnsprintf(szKey, countof(szKey), IK_ICON_FMT, i);
            GetPrivateProfileString(IS_FAVORITESEX, szKey, TEXT(""), szAux, countof(szAux), g_GetIns());
            if (szAux[0] != TEXT('\0'))
                PathCombine(fav.m_szIcon, g_GetTargetPath(), PathFindFileName(szAux));
            else
                fav.m_szIcon[0] = TEXT('\0');

            // get the offline flag
            wnsprintf(szKey, countof(szKey), IK_OFFLINE_FMT, i);
            fav.m_fOffline = InsGetBool(IS_FAVORITESEX, szKey, FALSE, g_GetIns());

            // actually adding this favorite
            Out(LI0(TEXT("Adding this favorite:")));
            hr = fav.Create(punk, pSubMgr2, NULL, g_GetIns());
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure)
                    fTotalSuccess = FALSE;
                else
                    break;
            }

            Out(LI0(TEXT("Done.")));
        }
    }
    else { /* favorites in the legacy format */
        LPCTSTR pszPreTitle;
        LPTSTR  pszBuffer;
        HANDLE  hIns;
        DWORD   dwInsSize;

        Out(LI0(TEXT("Using [Favorites] section...\r\n")));

        fav.m_fMarkIeakCreated = FALSE;

        hIns = CreateFile(g_GetIns(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hIns == INVALID_HANDLE_VALUE) {
            hr = STG_E_FILENOTFOUND;
            goto Exit;
        }
        dwInsSize = GetFileSize(hIns, NULL);
        ASSERT(dwInsSize != 0xFFFFFFFF);
        CloseHandle(hIns);

        pszBuffer = (LPTSTR)CoTaskMemAlloc(dwInsSize);
        if (pszBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pszBuffer, dwInsSize);

        GetPrivateProfileString(IS_FAVORITES, NULL, TEXT(""), pszBuffer, (UINT)dwInsSize, g_GetIns());
        ASSERT(*pszBuffer != TEXT('\0'));

        for (pszPreTitle = pszBuffer; *pszPreTitle != TEXT('\0'); pszPreTitle += StrLen(pszPreTitle) + 1) {
            MACRO_LI_Offset(1);
            if (pszPreTitle != pszBuffer)
                Out(LI0(TEXT("\r\n")));

            // processing title and URL
            Out(LI1(TEXT("Preprocessing \"%s\" favorite key..."), pszPreTitle));
            hr = formStrWithoutPlaceholders(IS_FAVORITES, pszPreTitle, g_GetIns(), szAux, countof(szAux));
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure) {
                    fTotalSuccess = FALSE;
                    continue;
                }
                else
                    break;
            }

            if (szAux[0] == TEXT('\0')) {
                StrCpy(fav.m_szTitle, pszPreTitle);
                StrCpy(fav.m_szUrl,   &szAux[1]);
            }
            else {
                StrCpy(fav.m_szTitle, szAux);
                StrCpy(fav.m_szUrl,   &szAux[StrLen(szAux) + 1]);
            }

            fav.m_fOffline = FALSE;

            // actually adding this favorite
            Out(LI0(TEXT("Adding this favorite:")));
            hr = fav.Create(punk, NULL, NULL, g_GetIns());
            if (FAILED(hr)) {
                Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

                if (fContinueOnFailure)
                    fTotalSuccess = FALSE;
                else
                    break;
            }

            Out(LI0(TEXT("Done.")));
        }

        CoTaskMemFree(pszBuffer);
    }

Exit:
    if (punk != NULL)
        punk->Release();

    if (pSubMgr2 != NULL)
        pSubMgr2->Release();

    if (fContinueOnFailure) {
        if (!fTotalSuccess)
            hr = S_FALSE;                       // at least one failed
        else
            ASSERT(SUCCEEDED(hr));
    }

    if (SUCCEEDED(hr))
        SetFeatureBranded(FID_FAV_MAIN);

    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();


}


HRESULT ProcessFavorites()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessFavorites)

    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for processing favorites...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ProcessFavoritesThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, processing favorites on this thread...\r\n")));
        ProcessFavoritesThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }

    return S_OK;
}


HRESULT ProcessFavoritesOrdering()
{
    return processFavoritesOrdering(FALSE);
}

void ProcessQuickLinksThread()
{
    IUnknown  *punk;
    ISubscriptionMgr2 *pSubMgr2;
    CFavorite fav;
    TCHAR     szAux[2*MAX_PATH + 1],
              szLinks[32],
              szKey[32];
    HRESULT   hr;
    int       i;
    BOOL      fContinueOnFailure,
              fTotalSuccess;

    HRESULT hrComInit;
    hrComInit = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hrComInit))
        Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hrComInit)));
    else
    {
        Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hrComInit)));
    }


    LoadString(g_GetHinst(), IDS_FOLDER_LINKS, szLinks, countof(szLinks));

    hr                 = S_OK;
    punk               = NULL;
    pSubMgr2           = NULL;
    fContinueOnFailure = TRUE;
    fTotalSuccess      = TRUE;

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)&punk);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of InternetShortcut object failed with %s."), GetHrSz(hr)));
        if (SUCCEEDED(hrComInit))
            CoUninitialize();
        return;
    }

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *) &pSubMgr2);
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Creation of SubscriptionMgr object failed with %s."), GetHrSz(hr)));
        hr = S_OK;          // don't treat this as an error
    }

    // for corp, mark the quick links created so that they can be deleted without deleting user created ones
    fav.m_fMarkIeakCreated = HasFlag(g_GetContext(), CTX_CORP | CTX_AUTOCONFIG | CTX_GP);

    for (i = 1; i <= MAX_QUICKLINKS; i++) {
        MACRO_LI_Offset(1);
        if (i > 1)
            Out(LI0(TEXT("\r\n")));

        // processing title
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_NAME, i);
        Out(LI1(TEXT("Preprocessing \"%s\" quick link title key..."), szKey));

        hr = formStrWithoutPlaceholders(IS_URL, szKey, g_GetIns(), szAux, countof(szAux), FSWP_VALUE);
        if (FAILED(hr)) {
            Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

            if (fContinueOnFailure) {
                fTotalSuccess = FALSE;
                continue;
            }
            else
                break;
        }

        ASSERT(szAux[0] == TEXT('\0'));
        if (szAux[1] == TEXT('\0')) {
            Out(LI0(TEXT("This key doesn't exist indicating that there are no more quick links.")));
            break;
        }

        fav.m_szTitle[0] = TEXT('\0');
        PathCombine(fav.m_szTitle, szLinks, &szAux[1]);

        // processing URL
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_URL, i);
        Out(LI1(TEXT("Preprocessing \"%s\" quick link URL key..."), szKey));

        hr = formStrWithoutPlaceholders(IS_URL, szKey, g_GetIns(),
            fav.m_szUrl, countof(fav.m_szUrl), FSWP_VALUE | FSWP_VALUELDID);
        if (FAILED(hr)) {
            Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

            if (fContinueOnFailure) {
                fTotalSuccess = FALSE;
                continue;
            }
            else
                break;
        }

        ASSERT(fav.m_szUrl[0] == TEXT('\0') && fav.m_szUrl[1] != TEXT('\0'));
        StrCpy(fav.m_szUrl, &fav.m_szUrl[1]);

        // processing icon file (no need to process with formStrWithoutPlaceholders)
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_ICON, i);
        GetPrivateProfileString(IS_URL, szKey, TEXT(""), szAux, countof(szAux), g_GetIns());
        if (szAux[0] != TEXT('\0'))
            PathCombine(fav.m_szIcon, g_GetTargetPath(), PathFindFileName(szAux));
        else
            fav.m_szIcon[0] = TEXT('\0');

        // get the offline flag
        wnsprintf(szKey, countof(szKey), IK_QUICKLINK_OFFLINE, i);
        fav.m_fOffline = InsGetBool(IS_URL, szKey, FALSE, g_GetIns());

        // actually adding this favorite
        Out(LI0(TEXT("Adding this quick link:")));
        hr = fav.Create(punk, pSubMgr2, NULL, g_GetIns());
        if (FAILED(hr)) {
            Out(LI1(TEXT("Failed with %s."), GetHrSz(hr)));

            if (fContinueOnFailure)
                fTotalSuccess = FALSE;
            else
                break;
        }

        Out(LI0(TEXT("Done.")));
    }

    if (punk != NULL)
        punk->Release();

    if (pSubMgr2 != NULL)
        pSubMgr2->Release();

    if (fContinueOnFailure) {
        if (!fTotalSuccess)
            hr = S_FALSE;                       // at least one failed
        else
            ASSERT(SUCCEEDED(hr));
    }

    //free com
    if (SUCCEEDED(hrComInit))
        CoUninitialize();
}

HRESULT ProcessQuickLinks()
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessQuickLinks)


    //because isubscriptionmgr2 fails to work in a multithreaded com environment, we're having to do 
    //any dealings with it on a separate thread.  

    Out(LI0(TEXT("Creating separate thread for processing quick links...\r\n")));
    DWORD     dwThread;

    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ProcessQuickLinksThread, NULL, 0, &dwThread);

    if (hThread == NULL)        // if CreateThread fails, call it on this thread and hope for the best
    {
        Out(LI0(TEXT("CreateThread failed, processing quick links on this thread...\r\n")));
        ProcessQuickLinksThread();
    }
    else
    {
        // Wait until the thread is terminated
        // this seems unfortunate, but is necessary because otherwise other favorites processing threads could clobber this one.
        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
        {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (hThread != NULL) CloseHandle(hThread);
    }

    return S_OK;
}

HRESULT ProcessQuickLinksOrdering()
{
    return processFavoritesOrdering(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

HRESULT processFavoritesOrdering(BOOL fQL)
{   MACRO_LI_PrologEx_C(PIF_STD_C, processFavoritesOrdering)

    IShellFolder *psfFavorites;
    LPITEMIDLIST pidlFavorites;
    LPTSTR  pszFavItems;
    HRESULT hr;
    DWORD   cFavs;

    psfFavorites  = NULL;
    pidlFavorites = NULL;
    pszFavItems   = NULL;
    hr            = S_OK;

    // figure out if there are any eligible favorites/links at all
    cFavs = getFavItems(!fQL ? IS_FAVORITESEX : IS_URL, !fQL ? IK_TITLE_FMT : IK_QUICKLINK_NAME, &pszFavItems);
    if (cFavs == 0) {
        Out(LI1(TEXT("There are no %s to process!"), !fQL ? TEXT("favorites") : TEXT("links")));
        goto Exit;
    }

    // get the IShellFolder for the desktop folder
    // NOTE: (andrewgu) this should be the only place we ever aquire s_psfDesktop, otherwise since
    // we release and set it to NULL at the end of the function, there is a potential for a memory
    // leak.
    if (NULL == s_psfDesktop) {
        hr = SHGetDesktopFolder(&s_psfDesktop);
        if (FAILED(hr)) {
            Out(LI1(TEXT("! SHGetDesktopFolder failed with %s"), GetHrSz(hr)));
            goto Exit;
        }
    }

    if (!fQL)
    {
        // get the pidl to the favorites folder
        hr = SHGetFolderLocationSimple(CSIDL_FAVORITES, &pidlFavorites);
        if (FAILED(hr))
        {
            Out(LI1(TEXT("! SHGetSpecialFolderLocation for CSIDL_FAVORITES failed with %s"), GetHrSz(hr)));
            goto Exit;
        }
    }
    else
    {
        TCHAR szLinksFolder[32];
        TCHAR szFavFolder[MAX_PATH], szFullPath[MAX_PATH];
        ULONG ucch;

        if (LoadString(g_GetHinst(), IDS_FOLDER_LINKS, szLinksFolder, countof(szLinksFolder)) == 0)
        {
            Out(LI0(TEXT("! LoadString failed to get the name of the links folder")));
            goto Exit;
        }

        if (GetFavoritesPath(szFavFolder, countof(szFavFolder)) == NULL)
        {
            Out(LI0(TEXT("! The path to the <Favorites> folder could not be determined.")));
            goto Exit;
        }

        PathCombine(szFullPath, szFavFolder, szLinksFolder);

        // get the pidl to the links folder
        hr = s_psfDesktop->ParseDisplayName(NULL, NULL, T2W(szFullPath), &ucch, &pidlFavorites, NULL);
        if (FAILED(hr))
        {
            Out(LI1(TEXT("! Getting the pidl to the links folder failed with %s"), GetHrSz(hr)));
            goto Exit;
        }
    }

    // get the IShellFolder for the favorites folder
    hr = s_psfDesktop->BindToObject(pidlFavorites, NULL, IID_IShellFolder, (LPVOID *) &psfFavorites);
    if (FAILED(hr))
    {
        Out(LI2(TEXT("! BindToObject on the %s pidl failed with %s"), !fQL ? TEXT("favorites") : TEXT("links"), GetHrSz(hr)));
        goto Exit;
    }

    hr = orderFavorites(pidlFavorites, psfFavorites, pszFavItems, cFavs);
    if (FAILED(hr))
    {
        Out(LI2(TEXT("! Ordering %s failed with %s"), !fQL ? TEXT("favorites") : TEXT("links"), GetHrSz(hr)));
        goto Exit;
    }

Exit:
    if (pszFavItems != NULL)
        CoTaskMemFree(pszFavItems);

    if (psfFavorites != NULL)
        psfFavorites->Release();

    if (s_psfDesktop != NULL) {
        s_psfDesktop->Release();
        s_psfDesktop = NULL;
    }

    if (pidlFavorites != NULL)
        CoTaskMemFree(pidlFavorites);

    return hr;
}

HRESULT pepSpecialFoldersEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    DFEPSTRUCT  dfep;
    PDFEPSTRUCT pdfep;
    TCHAR       szFolder[MAX_PATH];
    HRESULT     hr;
    UINT        nSpecialFolder;

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL && prgdwControl != NULL);

    // empty in-params, so out-params are zero if not set specifically
    ASSERT(HasFlag((*prgdwControl)[PEP_ENUM_INPOS_FLAGS], PEP_SCPE_NOFILES));
    ASSERT(HasFlag((*prgdwControl)[PEP_ENUM_INPOS_FLAGS], PEP_CTRL_ENUMPROCFIRST));
    ZeroMemory((*prgdwControl), sizeof(DWORD) * PEP_ENUM_OUTPOS_LAST);

    //----- Initialization -----
    pdfep = (const PDFEPSTRUCT)lParam;

    ZeroMemory(&dfep, sizeof(dfep));
    dfep.psm         = pdfep->psm;
    dfep.dwInsFlags  = pdfep->dwInsFlags;
    dfep.dwEnumFlags = pdfep->dwEnumFlags;

    //----- Main processing -----
    ASSERT(HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY));

    // skip based on the file attributes
    if (isFileAttributeIncluded(pdfep->dwInsFlags, pfd->dwFileAttributes))
        return S_OK;

    // skip based on special folder flags
    nSpecialFolder = isSpecialFolderIncluded(pdfep->dwInsFlags, pszPath);

    if (HasFlag(pdfep->dwInsFlags, FD_FAVORITES)) {
        if (1 == nSpecialFolder) {
            Out(LI1(TEXT("Special folder <%s> excluded from removing."), pfd->cFileName));

            (*prgdwControl)[PEP_ENUM_OUTPOS_SECONDCALL] = PEP_CTRL_NOSECONDCALL;
            return S_OK;
        }

        SetFlag(&dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER, (0 == nSpecialFolder));
    }
    else {
        if (0 == nSpecialFolder) {
            (*prgdwControl)[PEP_ENUM_OUTPOS_SECONDCALL] = PEP_CTRL_NOSECONDCALL;
            return S_OK;
        }

        SetFlag(&dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER, (2 == nSpecialFolder));
    }

    // remove everything unbeneath
    hr = PathEnumeratePath(pszPath,
        PEP_CTRL_USECONTROL,
        pepDeleteFavoritesEnumProc, (LPARAM)&dfep);

    // deal with the folder itself
    if (SUCCEEDED(hr)) {
        if (HasFlag(dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
            deleteFavoriteFolder(pszPath);

        if (HasFlag(pdfep->dwInsFlags, FD_FAVORITES)) {
            if (!HasFlag(dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
                Out(LI1(TEXT("Special folder <%s> emptied."), pfd->cFileName));
        }
        else
            if (!HasFlag(dfep.dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
                Out(LI1(TEXT("Special folder <%s> emptied."), pfd->cFileName));

            else
                Out(LI1(TEXT("The entire <%s> folder is removed."), pfd->cFileName));
    }

    PathCombine(szFolder, RK_FAVORDER, pfd->cFileName);
    SHDeleteKey(g_GetHKCU(), szFolder);

    return hr;
}

HRESULT pepDeleteFavoritesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    IUnknown    *punk;
    PDFEPSTRUCT pdfep;
    HRESULT     hrResult;

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL && prgdwControl != NULL);

    // empty in-params, so out-params are zero if not set specifically
    ASSERT(!HasFlag((*prgdwControl)[PEP_ENUM_INPOS_FLAGS], PEP_CTRL_ENUMPROCFIRST));
    ZeroMemory((*prgdwControl), sizeof(DWORD) * PEP_ENUM_OUTPOS_LAST);

    pdfep    = (const PDFEPSTRUCT)lParam;
    punk     = NULL;
    hrResult = S_OK;

    //----- Remove folder (potentially, with desktop.ini inside) -----
    if (HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        // order stream
        if (HasFlag(pdfep->dwEnumFlags, DFEP_DELETEORDERSTREAM)) {
            TCHAR szFolders[MAX_PATH];
            int   iFavoritesLen;

            iFavoritesLen = StrLen(GetFavoritesPath());
            if (iFavoritesLen >= StrLen(pszPath))
                StrCpy(szFolders, RK_FAVORDER);

            else {
                ASSERT(pszPath[iFavoritesLen] == TEXT('\\'));
                PathCombine(szFolders, RK_FAVORDER, (pszPath + iFavoritesLen+1));
            }

            SHDeleteKey(g_GetHKCU(), szFolders);
        }

        // folder itself
        if (HasFlag(pdfep->dwEnumFlags, DFEP_DELETEEMPTYFOLDER))
            deleteFavoriteFolder(pszPath);

        return hrResult;
    }

    //----- Process individual favorite file -----
    ASSERT(!HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY));

    // skip special file "desktop.ini"
    if (StrCmpI(pfd->cFileName, DESKTOP_INI) == 0 && HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
        goto Exit;


    // skip based on the file attributes
    if (isFileAttributeIncluded(pdfep->dwInsFlags, pfd->dwFileAttributes))
        goto NoFolder;

    // skip based on inside-favorite flags
    if (HasFlag(pdfep->dwInsFlags, (FD_REMOVE_IEAK_CREATED | FD_REMOVE_POLICY_CREATED))) {
        HRESULT hr;
        DWORD   dwFlags;
        BOOL    fRemove;

        hr = CreateInternetShortcut(pszPath, IID_IUnknown, (LPVOID *)&punk);
        if (FAILED(hr))
            goto NoFolder;

        dwFlags = GetFavoriteIeakFlags(pszPath, punk);
        if (0 == dwFlags)
            goto NoFolder;

        // only admin-created favorites beyound this point
        fRemove = (HasFlag(dwFlags, 1) && HasFlag(pdfep->dwInsFlags, FD_REMOVE_IEAK_CREATED));

        if (!fRemove)
            fRemove = (HasFlag(dwFlags, 2) && HasFlag(pdfep->dwInsFlags, FD_REMOVE_POLICY_CREATED));

        if (!fRemove) {
            ASSERT(FALSE);
            goto NoFolder;
        }
    }

    // delete offline content
    if (HasFlag(pdfep->dwEnumFlags, DFEP_DELETEOFFLINECONTENT))
        deleteFavoriteOfflineContent(pszPath, punk, pdfep->psm);

    SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(pszPath);

    goto Exit;

NoFolder:
    (*prgdwControl)[PEP_ENUM_OUTPOS_SECONDCALL] = PEP_CTRL_NOSECONDCALL;

Exit:
    if (punk != NULL)
        punk->Release();

    return hrResult;
}


HRESULT deleteFavoriteOfflineContent(LPCTSTR pszFavorite, IUnknown *punk /*= NULL*/, ISubscriptionMgr2 *psm /*= NULL*/)
{
    IUniformResourceLocator *purl;
    BSTR    bstrUrl;
    LPTSTR  pszUrl;
    HRESULT hr;
    BOOL    fOwnSubMgr;

    ASSERT(pszFavorite != NULL && *pszFavorite != TEXT('\0'));

    //----- Get IUniformResourceLocator on internet shortcut object -----
    if (punk != NULL)
        hr = punk->QueryInterface(IID_IUniformResourceLocator, (LPVOID *)&purl);

    else
        hr = CreateInternetShortcut(pszFavorite, IID_IUniformResourceLocator, (LPVOID *)&purl);

    if (FAILED(hr))
        return hr;

    //----- Get URL -----
    hr = purl->GetURL(&pszUrl);
    purl->Release();

    if (FAILED(hr))
        return hr;

    //----- Delete subscription -----
    fOwnSubMgr = FALSE;
    if (psm == NULL) {
        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&psm);
        if (FAILED(hr))
            return hr;

        fOwnSubMgr = TRUE;
    }

    bstrUrl = T2BSTR(pszUrl);
    hr      = psm->DeleteSubscription(bstrUrl, NULL);
    SysFreeString(bstrUrl);

    if (fOwnSubMgr)
        psm->Release();

    return hr;
}


HRESULT deleteFavoriteFolder(LPCTSTR pszFolder)
{
    TCHAR   szDesktopIni[MAX_PATH];
    HRESULT hr;
    BOOL    fEmpty;

    ASSERT(pszFolder != NULL && *pszFolder != TEXT('\0'));

    fEmpty = TRUE;
    hr     = PathEnumeratePath(pszFolder,
        PEP_CTRL_ENUMPROCFIRST | PEP_CTRL_NOSECONDCALL,
        pepIsFolderEmptyEnumProc, (LPARAM)&fEmpty);
    if (FAILED(hr))
        return hr;

    if (!fEmpty)
        return S_FALSE;

    PathCombine(szDesktopIni, pszFolder, DESKTOP_INI);
    if (PathFileExists(szDesktopIni)) {
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szDesktopIni);
    }

    return (0 != RemoveDirectory(pszFolder)) ? S_OK : E_FAIL;
}

HRESULT pepIsFolderEmptyEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL*/)
{
    PBOOL pfEmpty;

    ASSERT(pszPath != NULL && pfd != NULL && lParam != NULL && prgdwControl != NULL);
    UNREFERENCED_PARAMETER(pszPath);
    UNREFERENCED_PARAMETER(prgdwControl);

    pfEmpty  = (PBOOL)lParam;
    *pfEmpty = FALSE;

    if (HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        return S_FALSE;

    if (StrCmpI(pfd->cFileName, DESKTOP_INI) != 0 || !HasFlag(pfd->dwFileAttributes, FILE_ATTRIBUTE_HIDDEN))
        return S_FALSE;

    *pfEmpty = TRUE;
    return S_OK;
}


BOOL isFileAttributeIncluded(UINT nFlags, DWORD dwFileAttributes)
{
    static DWORD s_rgdwMapAttributes[] = {
        FD_REMOVE_HIDDEN,   FILE_ATTRIBUTE_HIDDEN,
        FD_REMOVE_SYSTEM,   FILE_ATTRIBUTE_SYSTEM,
        FD_REMOVE_READONLY, FILE_ATTRIBUTE_READONLY
    };
    DWORD dwAux;
    UINT  i;

    for (dwAux = 0, i = 0; i < countof(s_rgdwMapAttributes); i += 2)
        if (!HasFlag(s_rgdwMapAttributes[i], nFlags))
            dwAux |= s_rgdwMapAttributes[i+1];

    return HasFlag(dwAux, dwFileAttributes);
}

UINT isSpecialFolderIncluded(UINT nFlags, LPCTSTR pszPath)
{
    static MAPDW2PSZ s_mpFolders[] = {
        { FD_CHANNELS        | FD_EMPTY_CHANNELS,        NULL },
        { FD_SOFTWAREUPDATES | FD_EMPTY_SOFTWAREUPDATES, NULL },
        { FD_QUICKLINKS      | FD_EMPTY_QUICKLINKS,      NULL }
    };
    UINT i,
         nResult;

    if (s_mpFolders[0].psz == NULL) {
        s_mpFolders[0].psz = GetChannelsPath();
        s_mpFolders[1].psz = GetSoftwareUpdatesPath();
        s_mpFolders[2].psz = GetLinksPath();
    }

    nResult = 0;

    for (i = 0; i < countof(s_mpFolders); i++)
        if (StrCmpI(s_mpFolders[i].psz, pszPath) == 0 &&
            HasFlag(nFlags, (s_mpFolders[i].dw & FD_FOLDERS))) {
            nResult = 1;

            if (HasFlag(nFlags, (s_mpFolders[i].dw & FD_EMPTY_FOLDERS)))
                nResult = 2;

            break;
        }

    return nResult;
}


HRESULT formStrWithoutPlaceholders(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns,
    LPTSTR pszBuffer, UINT cchBuffer,
    DWORD dwFlags /*= FSWP_DEFAULT */)
{
    TCHAR   szResult[2*MAX_PATH + 1], szAux[MAX_PATH];
    HRESULT hr;
    DWORD   dwLen;
    UINT    nResultSize, nAuxSize;

    if (pszSection == NULL || pszKey == NULL || pszIns == NULL)
        return E_INVALIDARG;

    if (pszBuffer == NULL)
        return E_INVALIDARG;
    if (cchBuffer > 0 && cchBuffer < 3)
        return E_OUTOFMEMORY;
    ZeroMemory(pszBuffer, StrCbFromCch(3));     // triple zero terminate

    if (dwFlags == 0)
        dwFlags = FSWP_DEFAULT;
    if (((dwFlags & FSWP_KEY) == 0) && ((dwFlags & FSWP_VALUE) == 0))
        return E_INVALIDARG;

    szResult[0] = TEXT('\0');
    nResultSize = 1;
    if ((dwFlags & FSWP_KEY) != 0) {
        nResultSize = countof(szResult);
        hr = replacePlaceholders(pszKey, pszIns, szResult, &nResultSize, (dwFlags & FSWP_KEYLDID) != 0);
        if (FAILED(hr))
            return hr;

        if (hr == S_OK)                         // include last TEXT('\0')
            nResultSize++;

        else {
            ASSERT(hr == S_FALSE);

            szResult[0] = TEXT('\0');
            nResultSize = 1;
        }
    }

    szResult[nResultSize] = TEXT('\0');
    if ((dwFlags & FSWP_VALUE) != 0) {
        dwLen = GetPrivateProfileString(pszSection, pszKey, TEXT(""), szAux, countof(szAux), pszIns);
        if (dwLen > 0) {
            nAuxSize = countof(szResult) - nResultSize;
            hr = replacePlaceholders(szAux, pszIns, &szResult[nResultSize], &nAuxSize, (dwFlags & FSWP_VALUELDID) != 0);
            if (FAILED(hr))
                return hr;

            nResultSize += nAuxSize;
        }
    }

    nResultSize++;
    if (cchBuffer > 0 && cchBuffer <= nResultSize)
        return E_OUTOFMEMORY;

    ASSERT(szResult[nResultSize - 1] == TEXT('\0'));
    szResult[nResultSize] = TEXT('\0');         // double zero terminate
    CopyMemory(pszBuffer, szResult, StrCbFromCch(nResultSize + 1));

    return S_OK;
}

HRESULT replacePlaceholders(LPCTSTR pszSrc, LPCTSTR pszIns, LPTSTR pszBuffer, PUINT pcchBuffer, BOOL fLookupLDID /*= FALSE*/)
{
    static const TCHAR s_szStrings[] = TEXT("Strings");

    TCHAR   szResult[2 * MAX_PATH],
            szAux1[MAX_PATH], szAux2[MAX_PATH];
    LPCTSTR pszAux;
    HRESULT hr;
    DWORD   dwLen;
    UINT    nLeftPos, nRightPos, nTokenLen,
            nDestPos;

    if (pszSrc == NULL)
        return E_INVALIDARG;

    if (pszBuffer == NULL || pcchBuffer == NULL)
        return E_INVALIDARG;
    *pszBuffer = TEXT('\0');

    hr       = S_FALSE;
    nDestPos = 0;
    nLeftPos = (UINT)-1;
    for (pszAux = pszSrc; *pszAux != TEXT('\0'); pszAux = CharNext(pszAux)) {
        if (*pszAux != TEXT('%')) {
            szResult[nDestPos++] = *pszAux;

#ifndef _UNICODE
            if (IsDBCSLeadByte(*pszAux))
                szResult[nDestPos++] = *(pszAux + 1);   // copy the trail byte as well
#endif
            continue;
        }
        else {
#ifndef _UNICODE
            ASSERT(!IsDBCSLeadByte(*pszAux));
#endif
            if (*(pszAux + 1) == TEXT('%')) {   // "%%" is just '%' in the string
                if (nLeftPos != (UINT)-1)
                    // REVIEW: (andrewgu) "%%" are not allowed inside tokens. this also means that
                    // tokens can't be like %foo%%bar%, where the intention is for foo and bar to
                    // be tokens.
                    return E_UNEXPECTED;

                szResult[nDestPos++] = *pszAux;
                pszAux++;
                continue;
            }
        }

        nRightPos = UINT(pszAux - pszSrc);      // initialized, but not necessarily used as such
        if (nLeftPos == (UINT)-1) {
            nLeftPos = nRightPos;
            continue;
        }

        // "%%" is invalid here
        ASSERT(nLeftPos < nRightPos - 1);
        nTokenLen = nRightPos-nLeftPos - 1;

        hr = S_OK;
        StrCpyN(szAux1, pszSrc + nLeftPos+1, nTokenLen + 1);
        dwLen = GetPrivateProfileString(s_szStrings, szAux1, TEXT(""), szAux2, countof(szAux2), pszIns);
        if (dwLen == 0)                         // there is no such string
            return !fLookupLDID ? E_FAIL : E_NOTIMPL;

        ASSERT(nDestPos >= nTokenLen);
        StrCpyN(&szResult[nDestPos - nTokenLen], szAux2, countof(szResult) - (nDestPos-nTokenLen));
        nDestPos += dwLen - nTokenLen;

        nLeftPos = (UINT)-1;
    }
    if (nLeftPos != (UINT)-1)                   // mismatched '%'
        return E_UNEXPECTED;

    if (*pcchBuffer > 0 && *pcchBuffer <= nDestPos)
        return E_OUTOFMEMORY;

    szResult[nDestPos] = TEXT('\0');            // make sure zero terminated
    StrCpy(pszBuffer, szResult);
    *pcchBuffer = nDestPos;

    return hr;
}


// Get the favorites titles
// For example, if .ins contains the following lines:
//    [FavoritesEx]
//    Title1=Name1.url
//    Url1=...
//    Title2=Foo\Name2.url
//    Url2=...
//    Title3=Bar\Name3.url
//    Url3=...
// then *ppszFavItems would point to:
//    Name1.url\0
//    Foo\Name2.url\0
//    Bar\Name3.url\0
//    \0
// and the return value would be 3 (no. of items)
DWORD getFavItems(LPCTSTR pcszSection, LPCTSTR pcszFmt, LPTSTR *ppszFavItems)
{
    TCHAR   szTitle[MAX_PATH + 2],
            szKey[32];
    LPTSTR  pszTitle, pszPtr,
            pszAux;
    HRESULT hr;
    DWORD   dwNItems,
            dwSize, dwLen;
    UINT    nTitleLen;
    BOOL    fContinueOnFailure;

    if (ppszFavItems == NULL)
        return 0;

    fContinueOnFailure = TRUE;
    dwNItems           = 0;
    pszTitle           = &szTitle[1];           // always points to the real title
    dwLen              = 0;

    dwSize        = 1024;                       // initially, allocate buffer of size 1K
    *ppszFavItems = (LPTSTR)CoTaskMemAlloc(StrCbFromCch(dwSize));
    if (ppszFavItems == NULL)
        goto Exit;
    ZeroMemory(*ppszFavItems, StrCbFromCch(dwSize));

    for (dwNItems = 0; TRUE; dwNItems++) {
        pszPtr = *ppszFavItems + dwLen;

        // read in the current title; decode it
        wnsprintf(szKey, countof(szKey), pcszFmt, dwNItems + 1);
        hr = formStrWithoutPlaceholders(pcszSection, szKey, g_GetIns(), szTitle, countof(szTitle), FSWP_VALUE);
        if (FAILED(hr))
            if (fContinueOnFailure)
                continue;

            else {
                dwNItems = 0;
                goto Exit;
            }
        ASSERT(szTitle[0] == TEXT('\0'));
        if (*pszTitle == TEXT('\0'))
            break;

        DecodeTitle(pszTitle, g_GetIns());
        nTitleLen = StrLen(pszTitle) + 1;       // include terminating TEXT('\0')

        // increase return buffer (if necessary)
        if (dwLen + nTitleLen > dwSize - 1) {
            dwSize += 1024;
            pszAux  = (LPTSTR)CoTaskMemRealloc(*ppszFavItems, StrCbFromCch(dwSize));
            if (pszAux == NULL) {
                dwNItems = 0;
                goto Exit;
            }
            ZeroMemory(pszAux + dwSize - 1024, StrCbFromCch(1024));

            *ppszFavItems = pszAux;
            pszPtr        = *ppszFavItems + dwLen;
        }

        // copy current title to the buffer
        StrCpyN(pszPtr, pszTitle, nTitleLen);
        dwLen += nTitleLen;
    }
    *(*ppszFavItems + dwLen) = TEXT('\0');      // double zero terminate

Exit:
    if (dwNItems == 0 && *ppszFavItems != NULL) {
        CoTaskMemFree(*ppszFavItems);
        *ppszFavItems = NULL;
    }

    return dwNItems;
}

// Order Favorites (recursively)
HRESULT orderFavorites(LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPTSTR pszFavItems, DWORD cFavs)
{   MACRO_LI_PrologEx_C(PIF_STD_C, orderFavorites)

    HRESULT hr = S_OK;

    // first, order the current favorite folder.
    // then do a depth first traversal and order each sub folder recursively

    // order the current favorite folder.
    hr = orderFavoriteFolder(pidlFavFolder, psfFavFolder, pszFavItems, cFavs);
    if (FAILED(hr))
        goto Exit;

    while (*pszFavItems)
    {
        LPTSTR pszSubFolderItems;
        DWORD dwLen;

        if ((pszSubFolderItems = StrChr(pszFavItems, TEXT('\\'))) != NULL)      // a sub folder is specified
        {
            TCHAR szFolderName[MAX_PATH];
            DWORD dwNItems;
            WCHAR *pwszFullPath = NULL,
                  wszFullPath[MAX_PATH];
            ULONG ucch;
            LPITEMIDLIST pidlFavSubFolder = NULL;
            IShellFolder *psfFavSubFolder = NULL;
            STRRET str;

            StrCpyN(szFolderName, pszFavItems, (int)(pszSubFolderItems - pszFavItems + 1));

            // retrieve the section that corresponds to szFolderName from pszFavItems
            dwLen = getFolderSection(szFolderName, pszFavItems, &pszSubFolderItems, &dwNItems);

            // get the display name for the current FavFolder
            hr = s_psfDesktop->GetDisplayNameOf(pidlFavFolder, SHGDN_FORPARSING, &str);
            if (FAILED(hr))
                goto Cleanup;

            hr = StrRetToStrW(&str, pidlFavFolder, &pwszFullPath);
            if (FAILED(hr))
                goto Cleanup;

            StrCpyW(wszFullPath, pwszFullPath);
            CoTaskMemFree(pwszFullPath);
            pwszFullPath = NULL;

            // get the full pidl for the current SubFolder
            PathAppendW(wszFullPath, T2CW(szFolderName));
            hr = s_psfDesktop->ParseDisplayName(NULL, NULL, wszFullPath, &ucch, &pidlFavSubFolder, NULL);
            if (FAILED(hr))
                goto Cleanup;

            // get the IShellFolder for the current SubFolder
            hr = s_psfDesktop->BindToObject(pidlFavSubFolder, NULL, IID_IShellFolder, (LPVOID *) &psfFavSubFolder);
            if (FAILED(hr))
                goto Cleanup;

            // recursively process this sub folder
            hr = orderFavorites(pidlFavSubFolder, psfFavSubFolder, pszSubFolderItems, dwNItems);
            if (FAILED(hr))
                goto Cleanup;

            Out(LI1(TEXT("%s folder has been ordered successfully!"), szFolderName));

Cleanup:
            if (psfFavSubFolder != NULL)
                psfFavSubFolder->Release();

            if (pidlFavSubFolder != NULL)
                CoTaskMemFree(pidlFavSubFolder);

            if (pwszFullPath != NULL)
                CoTaskMemFree(pwszFullPath);

            if (FAILED(hr))
                goto Exit;
        }
        else
            dwLen = StrLen(pszFavItems) + 1;

        pszFavItems += dwLen;
    }

Exit:
    return hr;
}


HRESULT orderFavoriteFolder(LPITEMIDLIST pidlFavFolder, IShellFolder *psfFavFolder, LPCTSTR pcszFavItems, DWORD cFavs)
{
    HRESULT hr;
    IPersistFolder *pPF = NULL;
    IOrderList *pOL = NULL;
    HDPA hdpa = NULL;
    INT iInsertPos = 0;
    TCHAR szFavSubFolder[MAX_PATH] = TEXT("");
    DWORD dwIndex;
    SHChangeDWORDAsIDList dwidl;

    // Get the IOrderList for the FavFolder
    hr = CoCreateInstance(CLSID_OrderListExport, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFolder, (LPVOID *) &pPF);
    if (FAILED(hr))
        goto Exit;

    hr = pPF->Initialize(pidlFavFolder);
    if (FAILED(hr))
        goto Exit;

    hr = pPF->QueryInterface(IID_IOrderList, (LPVOID *) &pOL);
    if (FAILED(hr))
        goto Exit;

    hr = pOL->GetOrderList(&hdpa);
    if (hdpa == NULL)
    {
        // create a DPA list if there wasn't one already
        if ((hdpa = DPA_Create(2)) == NULL)
            goto Exit;
    }
    else
    {
        PORDERITEM poi;

        // by default, when the favorites are added, they are sorted by name
        // and the nOrder is set to -5.

        // if nOrder in the first item is negative, then nOrder in all the items will be negative
        poi = (PORDERITEM) DPA_GetPtr(hdpa, 0);
        if (poi != NULL  &&  poi->nOrder < 0)
        {
            INT i;

            // fix up the nOrder with its positive index value
            poi->nOrder = 0;
            for (i = 1;  (poi = (PORDERITEM) DPA_GetPtr(hdpa, i)) != NULL;  i++)
            {
                ASSERT(poi->nOrder < 0);
                poi->nOrder = i;
            }
        }
    }

    for (dwIndex = 0;  dwIndex < cFavs;  dwIndex++, pcszFavItems += StrLen(pcszFavItems) + 1)
    {
        LPCTSTR pcszItem;
        WCHAR wszFavItem[MAX_PATH];
        ULONG ucch;
        LPITEMIDLIST pidlFavItem = NULL;
        PORDERITEM poi;
        INT iCurrPos = -1;
        INT i;

        if ((pcszItem = StrChr(pcszFavItems, TEXT('\\'))) != NULL)
        {
            // a sub folder is specified

            // check if we have already processed this folder
            if (StrCmpNI(szFavSubFolder, pcszFavItems, (int)(pcszItem - pcszFavItems)) == 0)
                continue;

            // we haven't processed it; save the sub folder name in szFavSubFolder
            StrCpyN(szFavSubFolder, pcszFavItems, (int)(pcszItem - pcszFavItems + 1));
            pcszItem = szFavSubFolder;
        }
        else
            // this is a favorite item
            pcszItem = pcszFavItems;

        // get the pidl for the current FavItem
        T2Wbuf(pcszItem, wszFavItem, countof(wszFavItem));
        hr = psfFavFolder->ParseDisplayName(NULL, NULL, wszFavItem, &ucch, &pidlFavItem, NULL);
        if (FAILED(hr))
            goto Cleanup;

        // find out if the current FavItem exists in the DPA list
        i = 0;
        while ((poi = (PORDERITEM)DPA_GetPtr(hdpa, i++)) != NULL)
            if (psfFavFolder->CompareIDs(0, pidlFavItem, poi->pidl) == 0)
            {
                // match found; we should insert this item at iInsertPos
                iCurrPos = poi->nOrder;
                break;
            }

        if (iCurrPos == -1)             // item not found
        {
            // allocate an order item to insert
            hr = pOL->AllocOrderItem(&poi, pidlFavItem);
            if (FAILED(hr))
                goto Exit;

            // append it to the DPA list
            if ((iCurrPos = DPA_AppendPtr(hdpa, (LPVOID) poi)) >= 0)
                poi->nOrder = iCurrPos;
            else
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        // reorder the DPA list.
        // the current FavItem is at iCurrPos; we should move it to iInsertPos.
        if (iCurrPos != iInsertPos)
        {
            int i = 0;
            while ((poi = (PORDERITEM) DPA_GetPtr(hdpa, i++)) != NULL)
            {
                if (poi->nOrder == iCurrPos  &&  iCurrPos >= iInsertPos)
                    poi->nOrder = iInsertPos;
                else if (poi->nOrder >= iInsertPos  &&  poi->nOrder < iCurrPos)
                    poi->nOrder++;
            }
        }

        iInsertPos++;

Cleanup:
        if (pidlFavItem != NULL)
            CoTaskMemFree(pidlFavItem);

        if (FAILED(hr))
            goto Exit;
    }

    // sort the DPA list by name
    // the reason why we should sort by name (from lamadio):
    //   "The incoming list of filenames is sorted by name. Then we merge, so the order list needs to be sorted by name.
    //    It's for faster startup."
    pOL->SortOrderList(hdpa, OI_SORTBYNAME);

    // save the DPA list
    hr = pOL->SetOrderList(hdpa, psfFavFolder);
    if (FAILED(hr))
        goto Exit;

    // Notify everyone that the order has changed
    dwidl.cb = sizeof(dwidl) - sizeof(dwidl.cbZero);
    dwidl.dwItem1 = SHCNEE_ORDERCHANGED;
    dwidl.dwItem2 = 0;
    dwidl.cbZero = 0;

    SHChangeNotify(SHCNE_EXTENDED_EVENT, 0, (LPCITEMIDLIST) &dwidl, pidlFavFolder);

Exit:
    if (hdpa != NULL)
        pOL->FreeOrderList(hdpa);

    if (pOL != NULL)
        pOL->Release();

    if (pPF != NULL)
        pPF->Release();

    return hr;
}

// Get the favorite items that contain pcszFolderName as prefix
// For example, if pcszFolderName is "Foo" and if pszSection points to:
//    Foo\Name1.url\0
//    Foo\Name2.url\0
//    Bar\Name3.url\0
//    etc.
// then *ppszFolderItems would point to:
//    Name1.url\0
//    Name2.url\0
//    \0
// and *pdwNItems would contain 2 (no. of items).
//
// Note that manipulations are done in place within the buffer that's pointed to by pszSection;
// no new buffer is allocated for *ppszFolderItems.
// The return value is the length (in chars) of the lines that got modified.  In this example,
// the length returned = (StrLen("Foo\Name1.url") + 1) + (StrLen("Foo\Name2.url") + 1).
DWORD getFolderSection(LPCTSTR pcszFolderName, LPTSTR pszSection, LPTSTR *ppszFolderItems, LPDWORD pdwNItems)
{
    DWORD dwLen = 0;
    DWORD dwFolderLength;
    LPTSTR pszCurr;

    *ppszFolderItems = pszSection;
    *pdwNItems = 0;

    pszCurr = pszSection;
    dwFolderLength = StrLen(pcszFolderName);
    while ((StrCmpNI(pszSection, pcszFolderName, dwFolderLength) == 0) &&
           (pszSection[dwFolderLength] == TEXT('\\')))   // should succeed the first time
    {
        DWORD dwTmp = StrLen(pszSection) + 1;

        // remove the FolderName prefix and copy the remaining name to position pszCurr
        StrCpy(pszCurr, pszSection + StrLen(pcszFolderName) + 1);
        pszCurr += StrLen(pszCurr) + 1;

        // increment the no. of items
        (*pdwNItems)++;

        dwLen += dwTmp;
        pszSection += dwTmp;
    }

    *pszCurr = TEXT('\0');              // double nul terminate

    return dwLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\clear.cpp ===
#include "precomp.h"
#include "brand.h"

void ClearZonesHklm(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);
    //17073[WinSERaid]: W2K GPO: IE Security Zone GPO settings may not apply to the client correctly
    //In theory we should delete HKLM, "...\Internet Settings\ZoneMap" key, but to minimize the changes, 
    //only delete "ZoneMap\Domains"
    SHDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_ZONEMAP TEXT("\\Domains"));
}

void ClearRatings(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    SHDeleteKey(HKEY_LOCAL_MACHINE, RK_RATINGS);
}

void ClearAuthenticode(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    SHDeleteKey(g_GetHKCU(), REG_KEY_AUTHENTICODE);
}

void ClearGeneral(DWORD dwFlags /*= FF_ENABLE*/)
{
    HKEY  hkHklmMain,
          hkHkcuMain,
          hkHkcuHelpMenuUrl,
          hkHkcuToolbar,
          hkHklmUAString;

    if (FF_ENABLE == dwFlags)
        dwFlags = FF_GEN_ALL;

    hkHklmMain        = NULL;
    hkHkcuMain        = NULL;
    hkHkcuHelpMenuUrl = NULL;
    hkHkcuToolbar     = NULL;
    hkHklmUAString    = NULL;

    SHOpenKeyHKLM(         RK_IE_MAIN,         KEY_SET_VALUE,      &hkHklmMain);
    SHOpenKey(g_GetHKCU(), RK_IE_MAIN,         KEY_SET_VALUE,      &hkHkcuMain);
    SHOpenKey(g_GetHKCU(), RK_HELPMENUURL,     KEY_SET_VALUE,      &hkHkcuHelpMenuUrl);
    SHOpenKey(g_GetHKCU(), RK_TOOLBAR,         KEY_SET_VALUE,      &hkHkcuToolbar);
    SHOpenKeyHKLM(         RK_UA_POSTPLATFORM, KEY_DEFAULT_ACCESS, &hkHklmUAString);

    if (HasFlag(dwFlags, FF_GEN_TITLE)) {
        if (NULL != hkHkcuMain)
            RegDeleteValue(hkHkcuMain, RV_WINDOWTITLE);

        if (NULL != hkHklmMain)
            RegDeleteValue(hkHklmMain, RV_WINDOWTITLE);
    }

    if (HasFlag(dwFlags, FF_GEN_HOMEPAGE)) {
        TCHAR szIEResetInf[MAX_PATH];

        if (NULL != hkHkcuMain)
            RegDeleteValue(hkHkcuMain, RV_HOMEPAGE);

        // restore RV_DEFAULTPAGE and START_PAGE_URL to the default MS value
        GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
        PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
        if (PathFileExists(szIEResetInf))
        {
            TCHAR szDefHomePage[MAX_PATH];

            GetPrivateProfileString(IS_STRINGS, TEXT("MS_START_PAGE_URL"), TEXT(""), szDefHomePage, countof(szDefHomePage), szIEResetInf);
            WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szDefHomePage, szIEResetInf);

            if (hkHklmMain != NULL)
                RegSetValueEx(hkHklmMain, RV_DEFAULTPAGE, 0, REG_SZ, (PBYTE)szDefHomePage, (DWORD)StrCbFromSz(szDefHomePage));
        }
    }

    if (HasFlag(dwFlags, FF_GEN_SEARCHPAGE))
        if (NULL != hkHkcuMain) {
            RegDeleteValue(hkHkcuMain, RV_SEARCHBAR);
            RegDeleteValue(hkHkcuMain, RV_USE_CUST_SRCH_URL);
        }

    if (HasFlag(dwFlags, FF_GEN_HELPPAGE))
        if (NULL != hkHkcuHelpMenuUrl)
            RegDeleteValue(hkHkcuHelpMenuUrl, RV_ONLINESUPPORT);

    if (HasFlag(dwFlags, FF_GEN_UASTRING))
        if (NULL != hkHklmUAString) {
            TCHAR szUAVal[MAX_PATH];
            TCHAR szUAData[32];
            DWORD sUAVal = countof(szUAVal);
            DWORD sUAData = sizeof(szUAData);
            int iUAValue = 0;
            
            while (RegEnumValue(hkHklmUAString, iUAValue, szUAVal, &sUAVal, NULL, NULL, (LPBYTE)szUAData, &sUAData) == ERROR_SUCCESS)
            {
                sUAVal  = countof(szUAVal);
                sUAData = sizeof(szUAData);
            
                if (StrCmpN(szUAData, TEXT("IEAK"), 4) == 0)
                {
                    Out(LI1(TEXT("Deleting User Agent Key %s"), szUAVal));
                    RegDeleteValue(hkHklmUAString, szUAVal);
                    continue;
                }
            
                iUAValue++;
            }
    }

    if (HasFlag(dwFlags, FF_GEN_TOOLBARBMP))
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP50);
            RegDeleteValue(hkHkcuToolbar, RV_BACKGROUNDBMP);
            RegDeleteValue(hkHkcuToolbar, RV_BITMAPMODE);
        }

    if (HasFlag(dwFlags, FF_GEN_TBICONTHEME))
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_TOOLBARTHEME);
            TCHAR szEntry[MAX_PATH];
            StrCpy(szEntry, RV_TOOLBARICON);
            for (DWORD i=0; i<8; i++)
            {
                szEntry[countof(RV_TOOLBARICON)-2] = TEXT('0')+(TCHAR)i;
                RegDeleteValue(hkHkcuToolbar, szEntry);
            }
        }

    if (HasFlag(dwFlags, FF_GEN_STATICLOGO)) {
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_LARGEBITMAP);
            RegDeleteValue(hkHkcuToolbar, RV_SMALLBITMAP);
        }

        if (NULL != hkHklmMain) {
            RegDeleteValue(hkHklmMain, RV_LARGEBITMAP);
            RegDeleteValue(hkHklmMain, RV_SMALLBITMAP);
        }
    }

    if (HasFlag(dwFlags, FF_GEN_ANIMATEDLOGO))
        if (NULL != hkHkcuToolbar) {
            RegDeleteValue(hkHkcuToolbar, RV_BRANDBMP);
            RegDeleteValue(hkHkcuToolbar, RV_SMALLBRANDBMP);
        }

    SHCloseKey(hkHklmMain);
    SHCloseKey(hkHkcuMain);
    SHCloseKey(hkHkcuHelpMenuUrl);
    SHCloseKey(hkHkcuToolbar);
    SHCloseKey(hkHklmUAString);
}

void ClearChannels(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    ProcessRemoveAllChannels(TRUE);
}

void ClearToolbarButtons(DWORD dwFlags /*= FF_ENABLE*/)
{
    UNREFERENCED_PARAMETER(dwFlags);

    ProcessDeleteToolbarButtons(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\cmdline.cpp ===
#include "precomp.h"
#include "globalsw.h"

HRESULT getCommandValuePairs(PCTSTR pszCmdLine, PTSTR pszResult, UINT cchResult);
HRESULT getFeatureCodePairs (PCTSTR pszCmdLine, PBYTE pbResult,  UINT cbResult);

BOOL    getCommand(PCTSTR pszMark, PCTSTR *ppszEnd);
BOOL    getValue  (PCTSTR pszMark, PCTSTR *ppszEnd);

PCTSTR  skipChars(PCTSTR pszStart, BOOL fWhitespace);
BOOL    isWhitespace (TCHAR ch);
BOOL    isCommandMark(TCHAR ch);
BOOL    isValueMark  (TCHAR ch);


HRESULT GetCmdLineSwitches(PCTSTR pszCmdLine, PCMDLINESWITCHES pcls)
{
    static PCTSTR s_rgpszCommands[] = {
        TEXT("mode"),
        TEXT("ins"),
        TEXT("target"),
        TEXT("peruser"),
        TEXT("flags"),
        TEXT("disable")
    };

    static MAPDW2PSZ s_mpContexts[] = {
        { CTX_GENERIC,      TEXT("generic")    },
        { CTX_CORP,         TEXT("corp")       },
        { CTX_ISP,          TEXT("isp")        },
        { CTX_ICP,          TEXT("icp")        },
        { CTX_AUTOCONFIG,   TEXT("autoconfig") },
        { CTX_ICW,          TEXT("icw")        },
        { CTX_W2K_UNATTEND, TEXT("win2000")    },
        { CTX_INF_AND_OE,   NULL               },
        { CTX_BRANDME,      NULL               },
        { CTX_GP,           TEXT("gp")         }
    };

    static MAPDW2PSZ s_mpSignupModes[] = {
        { CTX_SIGNUP_ICW,    TEXT("icw")    },
        { CTX_SIGNUP_KIOSK,  TEXT("kiosk")  },
        { CTX_SIGNUP_CUSTOM, TEXT("custom") }
    };

    CMDLINESWITCHES cls;
    TCHAR   szBuffer [3 * MAX_PATH];
    BYTE    rgbBuffer[StrCbFromCch(MAX_PATH)];
    PTSTR   pszLeft, pszRight,
            pszAux;
    PDWORD  pdwFlags;
    HRESULT hr;
    UINT    i,
            cchAux,
            cchAux2;

    //----- Initialization -----
    if (pcls == NULL)
        return E_INVALIDARG;

    ZeroMemory(pcls, sizeof(CMDLINESWITCHES));
    pcls->dwContext = CTX_UNINITIALIZED;
    for (i = 0; i < countof(pcls->rgdwFlags); i++)
        pcls->rgdwFlags[i] = FF_INVALID;
    pcls->rgdwFlags[FID_WININETSETUP    ] = FF_ENABLE;
    pcls->rgdwFlags[FID_ACTIVESETUPSITES] = FF_ENABLE;
    pcls->rgdwFlags[FID_REFRESHBROWSER  ] = FF_ENABLE;

    if (pszCmdLine == NULL || *pszCmdLine == TEXT('\0'))
        return S_FALSE;                         // return initialized structure

    ZeroMemory(&cls, sizeof(cls));
    cls.dwContext = CTX_UNINITIALIZED;
    for (i = 0; i < countof(cls.rgdwFlags); i++)
        cls.rgdwFlags[i] = FF_INVALID;
    cls.rgdwFlags[FID_WININETSETUP    ] = FF_ENABLE;
    cls.rgdwFlags[FID_ACTIVESETUPSITES] = FF_ENABLE;
    cls.rgdwFlags[FID_REFRESHBROWSER  ] = FF_ENABLE;

    hr = getCommandValuePairs(pszCmdLine, szBuffer, countof(szBuffer));
    if (FAILED(hr))
        return hr;

    //----- Enumerate swithches pairs -----
    for (pszLeft = szBuffer; TEXT('\0') != *pszLeft; pszLeft = pszRight + cchAux2) {
        cchAux   = StrLen(pszLeft);
        pszRight = pszLeft + cchAux+1;
        cchAux2 = StrLen(pszRight)+1;
        ASSERT(TEXT('\0') == *pszRight || !isWhitespace(*pszRight));

        //_____ Look up current command _____
        for (i = 0; i < countof(s_rgpszCommands); i++)
            if (0 == StrCmpNI(pszLeft, s_rgpszCommands[i], min(cchAux, (UINT)StrLen(s_rgpszCommands[i]))))
                break;
        if (i >= countof(s_rgpszCommands))
            continue;

        //_____ Process recognized commands _____
        switch (*s_rgpszCommands[i]) {

        //- - - Context command - - -
        case TEXT('m'):
            pszAux = StrChrI(pszRight, TEXT(','));
            if (NULL != pszAux) {
                *pszAux = TEXT('\0');
                pszAux++;

                StrRemoveWhitespace(pszRight);
                StrRemoveWhitespace(pszAux);
            }

            cchAux = StrLen(pszRight);
            for (i = 0; i < countof(s_mpContexts); i++)
                if (NULL != s_mpContexts[i].psz &&
                    0 == StrCmpNI(pszRight, s_mpContexts[i].psz, min(cchAux, (UINT)StrLen(s_mpContexts[i].psz))))
                    break;
            if (i >= countof(s_mpContexts) || CTX_UNINITIALIZED != cls.dwContext)
                break;

            cls.dwContext = s_mpContexts[i].dw;
            if (HasFlag(cls.dwContext, CTX_ISP) && NULL != pszAux) {
                cchAux = StrLen(pszAux);
                for (i = 0; i < countof(s_mpSignupModes); i++)
                    if (NULL != s_mpSignupModes[i].psz &&
                        0 == StrCmpNI(pszAux, s_mpSignupModes[i].psz, min(cchAux, (UINT)StrLen(s_mpSignupModes[i].psz))))
                        break;
                if (i >= countof(s_mpSignupModes))
                    break;

                cls.dwContext |= s_mpSignupModes[i].dw;
            }
            break;

        //- - - .ins file and target folder path commands - - -
        case TEXT('i'):
        case TEXT('t'):
            pszAux = (TEXT('i') == *s_rgpszCommands[i]) ? cls.szIns : cls.szTargetPath;

            PathUnquoteSpaces(pszRight);
            PathRemoveBlanks (pszRight);
            StrCpy(pszAux, pszRight);
            break;

        //- - - PerUser command - - -
        case TEXT('p'):
            cls.fPerUser = TRUE;
            break;

        //- - - Feature flags command - - -
        case TEXT('f'):
            hr = getFeatureCodePairs(pszRight, rgbBuffer, sizeof(rgbBuffer));
            if (FAILED(hr)) {
                hr = S_FALSE;                   // partial success
                break;
            }

            for (pszLeft = (PTSTR)rgbBuffer; TEXT('\0') != *pszLeft; pszLeft = (PTSTR)(pdwFlags+1)) 
            {
                // flags are stored on aligned offsets
                pdwFlags = (PDWORD)(pszLeft + ((StrLen(pszLeft)+1 + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1)));

                for (i = 0; i < countof(g_mpFeatures); i++)
                {
                    if (NULL != g_mpFeatures[i].psz &&
                        0 == StrCmpI(pszLeft, g_mpFeatures[i].psz))
                        break;
                }
                if (i >= countof(g_mpFeatures))
                    break;

                cls.rgdwFlags[g_mpFeatures[i].dw] = *pdwFlags;
            }
            break;

        //- - - Disable command - - -
        case TEXT('d'):
            cls.fDisable = TRUE;
            break;
        }
    }

    ASSERT(SUCCEEDED(hr));
    CopyMemory(pcls, &cls, sizeof(cls));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

HRESULT getCommandValuePairs(PCTSTR pszCmdLine, PTSTR pszResult, UINT cchResult)
{
    TCHAR   szBuffer[3 * MAX_PATH];
    PCTSTR  pszCur, pszAux, pszEnd;
    HRESULT hr;
    UINT    cchBuffer;
    BOOL    fResult;

    if (pszCmdLine == NULL || *pszCmdLine == TEXT('\0'))
        return E_INVALIDARG;

    if (pszResult == NULL)
        return E_INVALIDARG;
    *pszResult = TEXT('\0');

    hr        = S_OK;
    cchBuffer = 0;

    //----- Find first pair -----
    BOOL fSwitch;

    pszCur  = skipChars(pszCmdLine, TRUE);
    fSwitch = TRUE;
    for (; TEXT('\0') != pszCur; fSwitch = !fSwitch, pszCur = skipChars(pszCur, fSwitch))
        if (isCommandMark(*pszCur))
            break;

    if (TEXT('\0') == *pszCur)
        return S_FALSE;                         // nothing there, partial success

    //----- Enumerate pairs -----
    for (; NULL != pszCur && TEXT('\0') != *pszCur; pszCur = pszEnd) {
        ASSERT(isCommandMark(*pszCur));
        fResult = getCommand(pszCur, &pszEnd);

        if (!fResult) {
            if (isValueMark(*pszEnd))
                getValue(pszEnd, &pszEnd);

            hr = S_FALSE;                       // partial success
        }
        else
            if (isValueMark(*pszEnd)) {
                pszAux  = pszEnd;
                fResult = getValue(pszAux, &pszEnd);

                if (!fResult)
                    hr = S_FALSE;               // partial success

                else {
                    // copy pair to the out buffer
                    StrCpyN(&szBuffer[cchBuffer], pszCur + 1, (int)(pszAux - pszCur));
                    StrRemoveWhitespace(&szBuffer[cchBuffer]);
                    cchBuffer += StrLen(&szBuffer[cchBuffer]) + 1;

                    StrCpyN(&szBuffer[cchBuffer], pszAux + 1, (int)(pszEnd - pszAux));
                    StrRemoveWhitespace(&szBuffer[cchBuffer]);
                    cchBuffer += StrLen(&szBuffer[cchBuffer]) + 1;
                }
            }
            else {
                ASSERT(TEXT('\0') == *pszEnd || isCommandMark(*pszEnd));

                // copy pair to the out buffer
                StrCpyN(&szBuffer[cchBuffer], pszCur + 1, (int)(pszEnd - pszCur));
                StrRemoveWhitespace(&szBuffer[cchBuffer]);
                cchBuffer += StrLen(&szBuffer[cchBuffer]) + 1;

                // no value
                szBuffer[cchBuffer] = TEXT('\0');
                cchBuffer++;
            }

        ASSERT(NULL == pszEnd || TEXT('\0') == *pszEnd || isCommandMark(*pszEnd));
    }

    // add empty command to indicate the end
    szBuffer[cchBuffer] = TEXT('\0');
    cchBuffer++;

    //----- Set out-parameters -----
    if (cchResult != 0 && cchBuffer > cchResult)
        hr = E_OUTOFMEMORY;

    else
        CopyMemory(pszResult, szBuffer, StrCbFromCch(cchBuffer));

    return hr;
}

HRESULT getFeatureCodePairs(PCTSTR pszCmdLine, PBYTE pbResult, UINT cbResult)
{
    BYTE    rgbBuffer[StrCbFromCch(MAX_PATH)];
    PCTSTR  pszCur, pszAux, pszEnd;
    HRESULT hr;
    UINT    cbBuffer;
    DWORD   dwCode;

    if (pszCmdLine == NULL || *pszCmdLine == TEXT('\0'))
        return E_INVALIDARG;

    if (pbResult == NULL)
        return E_INVALIDARG;
    *(PTSTR)pbResult = TEXT('\0');

    hr        = S_OK;
    cbBuffer  = 0;

    for (pszCur = pszCmdLine; TEXT('\0') != *pszCur; pszCur = pszEnd) {
        //----- Isolate token -----
        pszEnd = StrChr(pszCur, TEXT(','));
        if (pszEnd == NULL) {
            pszEnd = pszCur + StrLen(pszCur);
            ASSERT(*pszEnd == TEXT('\0'));
        }

        //----- Split token at the '=' character -----
        for (pszAux = pszCur; TEXT('=') != *pszAux && pszAux < (pszEnd - 1); pszAux++)
            ;
        if (TEXT('=') != *pszAux)
            continue;

        _int32 iCode;

        StrToIntEx(pszAux + 1, STIF_SUPPORT_HEX, &iCode);
        dwCode = (DWORD)iCode;

        //----- Copy pair to the out buffer -----
        StrCpyN((PTSTR)&rgbBuffer[cbBuffer], pszCur, (int)(pszAux - pszCur + 1));
        StrRemoveWhitespace((PTSTR)&rgbBuffer[cbBuffer]);
        cbBuffer += (UINT)StrCbFromSz((PTSTR)&rgbBuffer[cbBuffer]);
        // flags are stored on aligned offsets
        cbBuffer = (cbBuffer + (sizeof(DWORD)-1)) & ~(sizeof(DWORD)-1);

        *(PDWORD)&rgbBuffer[cbBuffer] = dwCode;
        cbBuffer  += sizeof(DWORD);

        if (*pszEnd == TEXT(','))
            pszEnd++;
    }

    // add empty feature id to indicate the end
    *(PTSTR)&rgbBuffer[cbBuffer] = TEXT('\0');
    cbBuffer += StrCbFromCch(1);

    //----- Set out-parameters -----
    if (cbResult != 0 && cbBuffer > cbResult)
        hr = E_OUTOFMEMORY;

    else
        CopyMemory(pbResult, rgbBuffer, cbBuffer);

    return hr;
}


BOOL getCommand(PCTSTR pszMark, PCTSTR *ppszEnd)
{
    PCTSTR pszCur;
    BOOL   fValid,
           fResult;

    ASSERT(pszMark != NULL && ppszEnd != NULL);
    *ppszEnd = NULL;

    if (TEXT('\0') == *pszMark)
        return FALSE;
    ASSERT(isCommandMark(*pszMark));

    pszCur  = pszMark + 1;
    fValid  = FALSE;
    fResult = TRUE;

    for (pszCur = skipChars(pszCur, TRUE); TEXT('\0') != *pszCur; pszCur = skipChars(pszCur, TRUE), fValid = TRUE) {
        if (isCommandMark(*pszCur))
            break;

        for (; TEXT('\0') != *pszCur && !isWhitespace(*pszCur); pszCur++)
            if (isValueMark(*pszCur))
                break;

        if (isValueMark(*pszCur))
            break;
    }
    ASSERT(TEXT('\0') == *pszCur || isCommandMark(*pszCur) || isValueMark(*pszCur));

    if (TEXT('\0') == *pszCur) {
        if (!fValid)
            fResult = FALSE;                    // whitespace only after the mark
    }
    else if (isCommandMark(*pszCur)) {
        if (!fValid)
            fResult = FALSE;                    // no separating whitespace
    }
    else {
        ASSERT(isValueMark(*pszCur));
        ASSERT(pszCur > pszMark);

        if (!fValid && isWhitespace(*(pszCur - 1)))
            fResult = FALSE;                    // no command between mark and ':'
    }

    *ppszEnd = pszCur;
    return fResult;
}

BOOL getValue(PCTSTR pszMark, PCTSTR *ppszEnd)
{
    PCTSTR pszCur;
    BOOL   fValid,
           fResult;

    ASSERT(pszMark != NULL && ppszEnd != NULL);
    *ppszEnd = NULL;

    if (TEXT('\0') == *pszMark)
        return FALSE;
    ASSERT(isValueMark(*pszMark));

    pszCur  = pszMark + 1;
    fValid  = FALSE;
    fResult = TRUE;

    for (pszCur = skipChars(pszCur, TRUE); TEXT('\0') != *pszCur; pszCur = skipChars(pszCur, TRUE), fValid = TRUE) {
        if (isCommandMark(*pszCur))
            break;

        if (TEXT('"') == *pszCur)
            pszCur = StrChr(pszCur + 1, TEXT('"'));

        if (NULL != pszCur)
            pszCur = skipChars(pszCur + 1, FALSE);

        else {
            fResult = FALSE;                    // no closing '"'
            break;
        }
    }
    ASSERT(NULL == pszCur || TEXT('\0') == *pszCur || isCommandMark(*pszCur));

    if (fResult) {
        if (TEXT('\0') == *pszCur) {
            if (!fValid)
                fResult = FALSE;                // whitespace only after the mark
        }
        else {
            ASSERT(isCommandMark(*pszCur));

            if (!fValid)
                fResult = FALSE;                // no separating whitespace
        }
    }

    *ppszEnd = pszCur;
    return fResult;
}


PCTSTR skipChars(PCTSTR pszStart, BOOL fWhitespace)
{
    if (pszStart == NULL)
        return NULL;

    while (*pszStart != TEXT('\0') && isWhitespace(*pszStart) == fWhitespace)
        pszStart++;

    return pszStart;
}

BOOL isWhitespace(TCHAR ch)
{
    return (NULL != StrChr(TEXT(" \t\r\n"), ch));
}

BOOL isCommandMark(TCHAR ch)
{
    return (NULL != StrChr(TEXT("/-"), ch));
}

BOOL isValueMark(TCHAR ch)
{
    return (TEXT(':') == ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\cabver.h ===
#ifndef _CABVER_H_
#define _CABVER_H_

struct SCabVersion
{
// Constructors
public:
    SCabVersion(LPCTSTR pszVer = NULL)
        { Init(pszVer); }

// Attributes
public:
    WORD cv_w1;                                 // most sig version number
    WORD cv_w2;
    WORD cv_w3;
    WORD cv_w4;                                 // least sig version number

// Operations
public:
    BOOL Init(LPCTSTR pszVer = NULL)
    {
        LPCTSTR pszToken, pszDelim;
        int     iAux;
        BOOL    fOK;

        cv_w1 = cv_w2 = cv_w3 = cv_w4 = 0;
        if (pszVer == NULL || *pszVer == TEXT('\0'))
            return TRUE;

        fOK = FALSE;

        pszToken = pszVer;
        pszDelim = StrChr(pszToken, TEXT('.'));
        if (pszDelim == NULL)
            return fOK;

        if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
            cv_w1 = (WORD)iAux;

            pszToken = pszDelim + 1;
            pszDelim = StrChr(pszToken, TEXT('.'));
            if (pszDelim == NULL)
                return fOK;

            if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
                cv_w2 = (WORD)iAux;

                pszToken = pszDelim + 1;
                pszDelim = StrChr(pszToken, TEXT('.'));
                if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
                    cv_w3 = (WORD)iAux;

                    if (pszDelim != NULL) {
                        pszToken = pszDelim + 1;
                        if (*pszToken == TEXT('\0'))
                            fOK = TRUE;

                        else
                            if (StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iAux)) {
                                cv_w4 = (WORD)iAux;

                                fOK = TRUE;
                            }
                    }
                    else
                        fOK = TRUE;
                }
            }
        }

        return fOK;
    }

    int Compare(const SCabVersion& cv) const
    {
        int i;

        i = compareItem(cv_w1, cv.cv_w1);
        if (i == 0) {
            i = compareItem(cv_w2, cv.cv_w2);
            if (i == 0) {
                i = compareItem(cv_w3, cv.cv_w3);
                if (i == 0)
                    i = compareItem(cv_w4, cv.cv_w4);
            }
        }

        return i;
    }

    BOOL operator==(const SCabVersion& cv) const
        { return (Compare(cv) == 0); }

    BOOL operator!=(const SCabVersion& cv) const
        { return (Compare(cv) != 0); }

    BOOL operator< (const SCabVersion& cv) const
        { return (Compare(cv) <  0); }

    BOOL operator> (const SCabVersion& cv) const
        { return (Compare(cv) >  0); }

    BOOL operator<=(const SCabVersion& cv) const
        { return (Compare(cv) <= 0); }

    BOOL operator>=(const SCabVersion& cv) const
        { return (Compare(cv) >= 0); }

// Implementation
protected:
    // implementation helper routines
    static int compareItem(WORD w1, WORD w2)
    {
        if (w1 > w2)
            return 1;
        if (w1 < w2)
            return -1;

        return 0;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\defines.h ===
#define FOLDER_ALLUSERS TEXT("All Users")

#define RP_IEAK         RP_MS   TEXT("\\Ieak")
#define RP_IEAK_GPOS    RP_IEAK TEXT("\\GroupPolicy")
#define RP_IEAK_BRANDED RP_IEAK TEXT("\\BrandedFeatures")

//#define RK_IEAK    RP_IEAK
#define   RV_ISPSIGN TEXT("ISP Signup Required")

#define RK_IEAK_GPOS               RP_IEAK_GPOS
#define RK_IEAK_EXTERNAL           TEXT("External")
#define RK_IEAK_ADM                TEXT("Advanced")

#define RK_IEAK_BRANDED            RP_IEAK_BRANDED
#define RV_BF_ZONES_HKCU           TEXT("Zones.Hkcu")
#define RV_BF_ZONES_HKLM           TEXT("Zones.Hklm")
#define RV_BF_RATINGS              TEXT("Ratings")
#define RV_BF_AUTHCODE             TEXT("Authcode")
#define RV_BF_PROGRAMS             TEXT("Programs")
#define RV_BF_TITLE                TEXT("Title")
#define RV_BF_HOMEPAGE             TEXT("HomePage")
#define RV_BF_SEARCHPAGE           TEXT("SearchPage")
#define RV_BF_HELPPAGE             TEXT("HelpPage")
#define RV_BF_UASTRING             TEXT("UAString")
#define RV_BF_TOOLBARBMP           TEXT("ToolbarBitmap")
#define RV_BF_TBICONTHEME          TEXT("TBIconTheme")
#define RV_BF_STATICLOGO           TEXT("StaticLogo")
#define RV_BF_ANIMATEDLOGO         TEXT("AnimatedLogo")
#define RV_BF_TOOLBARBUTTONS       TEXT("ToolbarButtons")
#define RV_BF_FAVORITES            TEXT("Favorites")
#define RV_BF_CHANNELS             TEXT("Channels")
#define RV_BF_CONNECTIONSETTINGS   TEXT("ConnectionSettings")

#define RK_BRND_CS                 RP_IEAK_BRANDED TEXT("\\ConnectionSettings")
#define RV_NAMESLIST               TEXT("NamesList")
#define RV_LANBACKUP               TEXT("LanBackup")

#define RK_IEAK_CABVER             RP_IEAK TEXT("\\CabVersions")
#define RV_LAST_AUTOCNF_URL        TEXT("LastAutoConfigURL")
#define RV_DATE                    TEXT("Date")

#define RK_FAVORDER                RP_WINDOWS TEXT("\\Explorer\\MenuOrder\\Favorites")
#define RV_ORDER                   TEXT("Order")

#define RK_CONNECTIONS             RP_INETSET TEXT("\\Connections")

#define RK_AS_INSTALLEDCOMPONENTS  RP_MS TEXT("\\Active Setup\\Installed Components")
#define RK_IE_UPDATE               TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\%s\\AuthorizedCDFPrefix")
#define RK_COMPLETED_MODIFICATIONS RP_IE_POLICIES TEXT("\\Infodelivery\\CompletedModifications")

#define IK_GPO_GUID        TEXT("GP")
// use this string for marking GP mandated settings
#define IEAK_GP_MANDATE    TEXT("IeakPolicy")

#define IS_BRANDINGW       L"Branding"
#define IK_IEAK_CREATEDW   L"IeakCreated"
#define IK_IEAK_CREATED    TEXT("IEAKCreated")

// links deletion stuff
#define MSIMN_EXE          TEXT("msimn.exe")
#define VIEWCHANNELS_SCF   TEXT("view channels.scf")

#define DESKTOP_FOLDER     0x00000001
#define PROGRAMS_FOLDER    0x00000002
#define QUICKLAUNCH_FOLDER 0x00000004
#define PROGRAMS_IE_FOLDER 0x00000008
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\exports.h ===
#ifndef _EXPORTS_H_
#define _EXPORTS_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL CALLBACK DllMain(HANDLE hModule, DWORD fdwReason, LPVOID);

void CALLBACK BrandInternetExplorer(HWND, HINSTANCE, LPCSTR pszCmdLineA, int);

BOOL CALLBACK BrandICW (LPCSTR pszInsA, LPCSTR, DWORD);
BOOL CALLBACK BrandICW2(LPCSTR pszInsA, LPCSTR, DWORD, LPCSTR pszConnectoidA);

BOOL CALLBACK BrandMe(LPCSTR pszInsA, LPCSTR);
BOOL CALLBACK BrandIntra(LPCSTR pszInsA);

void CALLBACK BrandIE4(HWND, HINSTANCE, LPCSTR pszCmdLineA, int);
BOOL CALLBACK _InternetInitializeAutoProxyDll(DWORD, LPCSTR pszInsA, LPCSTR, LPVOID, DWORD_PTR);
void CALLBACK BrandInfAndOutlookExpress(LPCSTR pszInsA);

BOOL CALLBACK BrandCleanInstallStubs(HWND, HINSTANCE, LPCSTR pszCompanyA, int);
void CALLBACK Clear(HWND, HINSTANCE, LPCSTR, int);
void CALLBACK CloseRASConnections(HWND, HINSTANCE, LPCSTR, int);

#ifdef __cplusplus
}
#endif

#endif /* _EXPORTS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\dllmap.cpp ===
#include "precomp.h"

// DelayLoadFailureHook() is defined in ieakutil.lib
// for more info, read the Notes section in ieak5\ieakutil\dload.cpp
PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

// We need a notify hook so that we can tell if we loaded wininet
STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli);
PfnDliHook __pfnDliNotifyHook = DelayloadNotifyHook;


//
// For every API that's imported from a delay loaded DLL, define a handler
//
// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES() and g_DllEntries[]
//            should be sorted by name.

//----- advpack.dll -----
static HRESULT WINAPI DelNode(PCSTR pszFileOrDirName, DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(pszFileOrDirName);
    UNREFERENCED_PARAMETER(dwFlags);

    return E_UNEXPECTED;
}

static HRESULT WINAPI ExtractFiles(PCSTR pszCabName, PCSTR pszExpandDir, DWORD dwFlags, PCSTR pszFileList,
    PVOID pvReserved, DWORD dwReserved)
{
    UNREFERENCED_PARAMETER(pszCabName);
    UNREFERENCED_PARAMETER(pszExpandDir);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pszFileList);
    UNREFERENCED_PARAMETER(pvReserved);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_UNEXPECTED;
}

static HRESULT WINAPI GetVersionFromFile(PSTR pszFilename, PDWORD pdwMSVer, PDWORD pdwLSVer, BOOL fVersion)
{
    UNREFERENCED_PARAMETER(pszFilename);
    UNREFERENCED_PARAMETER(fVersion);

    if (pdwMSVer != NULL)
        *pdwMSVer = 0;

    if (pdwLSVer != NULL)
        *pdwLSVer = 0;

    return E_UNEXPECTED;
}

static HRESULT WINAPI RegInstall(HMODULE hm, LPCSTR pszSection, LPCSTRTABLE pstTable)
{
    UNREFERENCED_PARAMETER(hm);
    UNREFERENCED_PARAMETER(pszSection);
    UNREFERENCED_PARAMETER(pstTable);

    return E_UNEXPECTED;
}

static HRESULT WINAPI RunSetupCommand(HWND hWnd, PCSTR pszCmdName, PCSTR pszInfSection, PCSTR pszDir,
    PCSTR pszTitle, HANDLE *phExe, DWORD dwFlags, LPVOID pvReserved)
{
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(pszCmdName);
    UNREFERENCED_PARAMETER(pszInfSection);
    UNREFERENCED_PARAMETER(pszDir);
    UNREFERENCED_PARAMETER(pszTitle);
    UNREFERENCED_PARAMETER(phExe);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pvReserved);

    return E_UNEXPECTED;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(advpack)
{
    DLPENTRY(DelNode)
    DLPENTRY(ExtractFiles)
    DLPENTRY(GetVersionFromFile)
    DLPENTRY(RegInstall)
    DLPENTRY(RunSetupCommand)
};

DEFINE_PROCNAME_MAP(advpack)


//----- crypt32.dll -----
#define _CRYPT32_
#include <wincrypt.h>

static WINCRYPT32API BOOL WINAPI CertCloseStore(IN HCERTSTORE hCertStore, DWORD dwFlags)
{
    UNREFERENCED_PARAMETER(hCertStore);
    UNREFERENCED_PARAMETER(dwFlags);

    return FALSE;
}

static WINCRYPT32API HCERTSTORE WINAPI CertOpenStore(IN PCSTR pszStoreProvider, IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv, IN DWORD dwFlags, IN const void *pvParam)
{
    UNREFERENCED_PARAMETER(pszStoreProvider);
    UNREFERENCED_PARAMETER(dwEncodingType);
    UNREFERENCED_PARAMETER(hCryptProv);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pvParam);

    return NULL;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(crypt32)
{
    DLPENTRY(CertCloseStore)
    DLPENTRY(CertOpenStore)
};

DEFINE_PROCNAME_MAP(crypt32)


//----- inseng.dll -----
static HRESULT WINAPI CheckTrustEx(PCSTR pszUrl, PCSTR pszFilename, HWND hwndForUI, BOOL fShowBadUI, DWORD dwReserved)
{
    UNREFERENCED_PARAMETER(pszUrl);
    UNREFERENCED_PARAMETER(pszFilename);
    UNREFERENCED_PARAMETER(hwndForUI);
    UNREFERENCED_PARAMETER(fShowBadUI);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_UNEXPECTED;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(inseng)
{
    DLPENTRY(CheckTrustEx)
};

DEFINE_PROCNAME_MAP(inseng)


//----- shfolder.dll -----
#define _SHFOLDER_
#include <shfolder.h>

static HRESULT SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, PSTR pszPath)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(csidl);
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL != pszPath)
        *pszPath = '\0';

    return E_UNEXPECTED;
}

static HRESULT SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, PWSTR pszPath)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(csidl);
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL != pszPath)
        *pszPath = L'\0';

    return E_UNEXPECTED;
}


// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(shfolder)
{
    DLPENTRY(SHGetFolderPathA)
    DLPENTRY(SHGetFolderPathW)
};

DEFINE_PROCNAME_MAP(shfolder)


//----- userenv.dll -----
#define _USERENV_
#include <userenv.h>

static USERENVAPI BOOL WINAPI CreateEnvironmentBlock(LPVOID *lpEnvironment, HANDLE hToken, BOOL bInherit)
{
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(bInherit);

    *lpEnvironment = NULL;

    return FALSE;
}

static USERENVAPI BOOL WINAPI DestroyEnvironmentBlock(LPVOID lpEnvironment)
{
    UNREFERENCED_PARAMETER(lpEnvironment);

    return FALSE;
}

// IMPORTANT: The entries in DEFINE_PROCNAME_ENTRIES should be sorted by name
DEFINE_PROCNAME_ENTRIES(userenv)
{
    DLPENTRY(CreateEnvironmentBlock)
    DLPENTRY(DestroyEnvironmentBlock)
};

DEFINE_PROCNAME_MAP(userenv)

//----- define g_DllMap -----
// IMPORTANT: The entries in g_DllEntries should be sorted by name
const DLOAD_DLL_ENTRY g_DllEntries[] = {
    DLDENTRYP(advpack)
    DLDENTRYP(crypt32)
    DLDENTRYP(inseng)
    DLDENTRYP(shfolder)
    DLDENTRYP(userenv)
};

const DLOAD_DLL_MAP g_DllMap = {
    countof(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\download.cpp ===
#include "precomp.h"
#include "cabver.h"

// Private forward decalarations
#define ACF_ALWAYSUPDATECAB 0x0001              // ACF is for AutoConfingFlags

HRESULT updateCabFile(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns, BOOL fForceUpdate, LPCTSTR pszTargetPath);
HRESULT internetDownloadFile(LPCTSTR pszURL, LPCTSTR pszTargetPath);


BOOL UpdateBrandingCab(BOOL fForceUpdate)
{
    return SUCCEEDED(updateCabFile(IS_CUSTOMBRANDING, IK_BRANDING, g_GetIns(), fForceUpdate, g_GetTargetPath()));
}

BOOL UpdateDesktopCab(BOOL fForceUpdate)
{
    TCHAR   szTargetPath[MAX_PATH],
            szMyCptrPath[MAX_PATH], szCPanelPath[MAX_PATH],
            szAux[MAX_PATH];
    HRESULT hr;
    DWORD   dwMyCptrAttribs, dwCPanelAttribs;

    if (!CreateWebFolder())
        return FALSE;
    GetWebPath(szTargetPath, countof(szTargetPath));

    // BUGBUG: Because of bug #62123, on NT, the ExtractFiles() API in urlmon.dll fails to extract
    // if the target file has SYSTEM + HIDDEN attribs set; in our case, the files are the mycomp
    // and controlp htt files. A hacky solution is to reset the attribs of these to NORMAL before
    // extracting the cab and set them back to their original attribs after they have been
    // extracted. Only do this if we're running on NT4.  For NT5, we don't want to overwrite the
    // existing ones

    dwMyCptrAttribs = 0xFFFFFFFF; // these are placed outside to prevent compiler warning
    dwCPanelAttribs = 0xFFFFFFFF; // about uninitialized vars  

    if (!IsOS(OS_NT5)) {
        //----- My Computer htt file handling -----
        szMyCptrPath[0] = TEXT('\0');

        GetPrivateProfileString(IS_DESKTOPOBJS, IK_MYCPTRPATH, TEXT(""), szAux, countof(szAux), g_GetIns());
        if (szAux[0] != TEXT('\0')) {
            PathCombine(szMyCptrPath, szTargetPath, PathFindFileName(szAux));
            ASSERT(szMyCptrPath[0] != TEXT('\0'));
            
            dwMyCptrAttribs = GetFileAttributes(szMyCptrPath);
            if (dwMyCptrAttribs != 0xFFFFFFFF) {
                ASSERT(PathFileExists(szMyCptrPath));
                SetFileAttributes(szMyCptrPath, FILE_ATTRIBUTE_NORMAL);
            }
        }

        //----- Control Panel htt file handling -----
        szCPanelPath[0] = TEXT('\0');
        
        GetPrivateProfileString(IS_DESKTOPOBJS, IK_CPANELPATH, TEXT(""), szAux, countof(szAux), g_GetIns());
        if (szAux[0] != TEXT('\0')) {
            PathCombine(szCPanelPath, szTargetPath, PathFindFileName(szAux));
            ASSERT(szCPanelPath[0] != TEXT('\0'));
            
            dwCPanelAttribs = GetFileAttributes(szCPanelPath);
            if (dwCPanelAttribs != 0xFFFFFFFF) {
                ASSERT(PathFileExists(szCPanelPath));
                SetFileAttributes(szCPanelPath, FILE_ATTRIBUTE_NORMAL);
            }
        }
    }

    hr = updateCabFile(IS_CUSTOMDESKTOP, IK_DESKTOP, g_GetIns(), fForceUpdate, szTargetPath);

    if (!IsOS(OS_NT5)) {
        // restore the attributes (see BUGBUG above)
        if (szMyCptrPath[0] != TEXT('\0') && dwMyCptrAttribs != 0xFFFFFFFF)
            SetFileAttributes(szMyCptrPath, dwMyCptrAttribs);
        
        if (szCPanelPath[0] != TEXT('\0') &&  dwCPanelAttribs != 0xFFFFFFFF)
            SetFileAttributes(szCPanelPath, dwCPanelAttribs);
    }

    return SUCCEEDED(hr);
}

HRESULT DownloadSourceFile(LPCTSTR pszURL, LPTSTR pszTargetPath, UINT cchTargetPath, BOOL fCheckTrust /*= TRUE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, DownloadSourceFile)

    TCHAR   szTargetFile[MAX_PATH];
    HRESULT hr;
    BOOL    fCopyPossible;

    if (pszURL == NULL)
        return E_INVALIDARG;

    if (!PathIsValidPath(pszTargetPath, PIVP_FOLDER_ONLY))
        return STG_E_PATHNOTFOUND;

    PathCombine(szTargetFile, pszTargetPath, PathFindFileName(pszURL));
    if ((UINT)StrLen(szTargetFile) >= cchTargetPath)
        return E_OUTOFMEMORY;

    if (PathIsFileSpec(pszURL) && PathFileExists(szTargetFile)) {
        Out(LI1(TEXT("\"%s\" is already present!"), szTargetFile));
        StrCpy(pszTargetPath, szTargetFile);
        return S_OK;
    }

    fCopyPossible = !PathIsURL(pszURL);
    if (!fCopyPossible) {
        URL_COMPONENTS uc;

        ZeroMemory(&uc, sizeof(uc));
        uc.dwStructSize     = sizeof(uc);
        uc.dwSchemeLength   = 1;
        uc.dwHostNameLength = 1;
        uc.dwUrlPathLength  = 1;

        // REVIEW: (andrewgu) consider adding support for decoding escape sequencies with dwFlags
        // parameter.
        if (InternetCrackUrl(pszURL, 0, 0, &uc))
            if (uc.nScheme == INTERNET_SCHEME_FILE) {
                // the below ASSERT explains the case we got here
                ASSERT(uc.lpszHostName == NULL && uc.dwHostNameLength == 0);

                pszURL = uc.lpszUrlPath;
                fCopyPossible = TRUE;
            }
    }

    if (!fCopyPossible) {
        hr = internetDownloadFile(pszURL, pszTargetPath);
        if (FAILED(hr)) {
            Out(LI1(TEXT("! Download failed with %s."), GetHrSz(hr)));
            return hr;
        }
    }
    else {
        hr = PathFileExists(pszURL) ? S_OK : E_FAIL;
        if (FAILED(hr))
            Out(LI1(TEXT("! File \"%s\" doesn't exist."), pszURL));
        else {
            hr = CopyFile(pszURL, szTargetFile, FALSE) ? S_OK : E_FAIL;
            if (FAILED(hr))
                Out(LI1(TEXT("! File \"%s\" can NOT be copied."), pszURL));
        }
    }

    if (SUCCEEDED(hr) && fCheckTrust) {
        hr = CheckTrustExWrap(pszURL, szTargetFile, NULL, TRUE, 0);
        if (FAILED(hr)) {
            DeleteFile(szTargetFile);
            Out(LI2(TEXT("! Check trust operation on \"%s\" failed with %s."), szTargetFile, GetHrSz(hr)));
            return hr;
        }
    }

    if (SUCCEEDED(hr)) {
        Out(LI1(TEXT("\"%s\" downloaded successfully!"), szTargetFile));
        StrCpy(pszTargetPath, szTargetFile);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

HRESULT updateCabFile(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszIns, BOOL fForceUpdate, LPCTSTR pszTargetPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, updateCabFile)

    TCHAR szInsLine[INTERNET_MAX_URL_LENGTH + 50],
          szKeyName[128];
    HKEY  hk;
    DWORD dwSize;
    LONG  lResult;

    //----- Initialization -----
    if (pszSection == NULL || pszKey == NULL || pszIns == NULL)
        return E_INVALIDARG;

    if (!PathIsValidPath(pszTargetPath, PIVP_FOLDER_ONLY))
        return STG_E_PATHNOTFOUND;

    // initialize szInsLine
    Out(LI0(TEXT("\r\nVersion checking and updating cab file...")));

    GetPrivateProfileString(pszSection, pszKey, TEXT(""), szInsLine, countof(szInsLine), pszIns);
    if (szInsLine[0] == TEXT('\0'))
        GetPrivateProfileString(IS_CUSTOMVER, pszKey, TEXT(""), szInsLine, countof(szInsLine), pszIns);
    if (szInsLine[0] == TEXT('\0')) {
        Out(LI1(TEXT("Required update information for \"%s\" cab was not found!"), pszKey));
        return E_FAIL;
    }

    // initialize szKeyName, hk
    wnsprintf(szKeyName, countof(szKeyName), RK_IEAK_CABVER TEXT("\\%s"), pszKey);
    hk = NULL;

    //----- Parse szInsLine on tokens -----
    LPTSTR pszToken, pszDelim,
           pszNewCabFileURL, pszNewVer;
    UINT   nFlags;
    int    iTimeout;

    pszNewCabFileURL = NULL;
    pszNewVer        = NULL;
    iTimeout         = 0;
    nFlags           = 0;

    pszToken = szInsLine;
    pszDelim = StrChr(pszToken, TEXT(','));
    if (pszDelim != NULL)
        *pszDelim = TEXT('\0');

    // pszNewCabFileURL
    pszNewCabFileURL = pszToken;
    StrRemoveWhitespace(pszNewCabFileURL);

    if (pszDelim != NULL) {
        pszToken = pszDelim + 1;
        pszDelim = StrChr(pszToken, TEXT(','));
        if (pszDelim != NULL)
            *pszDelim = TEXT('\0');

        // pszNewVer
        pszNewVer = pszToken;
        StrRemoveWhitespace(pszNewVer);

        if (!fForceUpdate && pszDelim != NULL) {
            pszToken = pszDelim + 1;
            pszDelim = StrChr(pszToken, TEXT(','));
            if (pszDelim != NULL)
                *pszDelim = TEXT('\0');

            // iTimeout
            StrRemoveWhitespace(pszToken);
            if (*pszToken != TEXT('\0') && StrToIntEx(pszToken, STIF_SUPPORT_HEX, &iTimeout))
                if (pszDelim != NULL) {
                    pszToken = pszDelim + 1;

                    // nFlags
                    StrRemoveWhitespace(pszToken);
                    if (*pszToken != TEXT('\0'))
                        StrToIntEx(pszToken, STIF_SUPPORT_HEX, (LPINT)&nFlags);
                }
        }
    }

    ASSERT(pszNewCabFileURL != NULL);
    if (*pszNewCabFileURL == TEXT('\0')) {
        Out(LI1(TEXT("! Parsing error in line \"%s\"."), szInsLine));
        return E_FAIL;
    }

    //----- Determine if updating is needed -----
    SYSTEMTIME st;
    BOOL       fUpdate;

    GetLocalTime(&st);

    fUpdate = (fForceUpdate || pszNewVer == NULL || iTimeout == 0 || HasFlag(nFlags, ACF_ALWAYSUPDATECAB));
    if (fUpdate) {
        if (fForceUpdate)
            Out(LI1(TEXT("Update of \"%s\" cab is forced from outside."), pszKey));
        else if (pszNewVer == NULL)
            Out(LI1(TEXT("No version information for \"%s\" cab."), pszKey));
        else if (iTimeout == 0)
            Out(LI1(TEXT("Timeout on \"%s\" cab is set to zero."), pszKey));
        else /* if (HasFlag(nFlags, ACF_ALWAYSUPDATECAB)) */
            Out(LI1(TEXT("Update options for \"%s\" cab include flag \"always update\"."), pszKey));
    }
    else { /* if (!fUpdate) */
        lResult = SHOpenKeyHKLM(szKeyName, KEY_QUERY_VALUE, &hk);
        fUpdate = (lResult != ERROR_SUCCESS);

        // cab url
        if (!fUpdate) {
            TCHAR szOldCabFileURL[INTERNET_MAX_URL_LENGTH];

            ASSERT(hk != NULL);

            szOldCabFileURL[0] = TEXT('\0');
            dwSize             = sizeof(szOldCabFileURL);
            RegQueryValueEx(hk, RV_URL, NULL, NULL, (LPBYTE)&szOldCabFileURL, &dwSize);

            fUpdate = (szOldCabFileURL[0] == TEXT('\0') || StrCmpI(szOldCabFileURL, pszNewCabFileURL) != 0);
            if (fUpdate)
                Out(LI1(TEXT("Download URL for \"%s\" cab has changed."), pszKey));
        }

        // version
        if (!fUpdate) {
            SCabVersion cvOld, cvNew;
            TCHAR       szOldVer[40];

            szOldVer[0] = TEXT('\0');
            dwSize      = sizeof(szOldVer);
            RegQueryValueEx(hk, RV_VERSION, NULL, NULL, (LPBYTE)&szOldVer, &dwSize);

            fUpdate = (cvOld.Init(szOldVer) && cvNew.Init(pszNewVer)) ? (cvOld < cvNew) : TRUE;
            if (fUpdate)
                Out(LI1(TEXT("New version of \"%s\" cab is available."), pszKey));
        }

        // date
        if (!fUpdate && iTimeout > 0) {
            SCabVersion cvAux;
            TCHAR       szOldDate[32];
            int         iTimeDiff;

            szOldDate[0] = TEXT('\0');
            dwSize       = sizeof(szOldDate);
            RegQueryValueEx(hk, RV_DATE, NULL, NULL, (LPBYTE)&szOldDate, &dwSize);

            if (cvAux.Init(szOldDate)) {
                iTimeDiff = (st.wYear - cvAux.cv_w1) * 365 + (st.wMonth - cvAux.cv_w2) * 30 + (st.wDay - cvAux.cv_w3);

                fUpdate = (iTimeDiff >= iTimeout);
                if (fUpdate)
                    Out(LI1(TEXT("Existing version of \"%s\" cab has become outdated."), pszKey));
            }
        }

        SHCloseKey(hk);
    }

    if (!fUpdate) {
        Out(LI1(TEXT("No update is needed for \"%s\" cab!"), pszKey));
        return S_FALSE;
    }

    //----- Download and extract cab -----
    CNewCursor cursor(IDC_WAIT);                // turn cursor into a hourglass

    TCHAR   szTargetFile[MAX_PATH];
    HRESULT hr;

    StrCpy(szTargetFile, pszTargetPath);
    hr = DownloadSourceFile(pszNewCabFileURL, szTargetFile, countof(szTargetFile));
    if (FAILED(hr)) {
        if (g_CtxIs(CTX_W2K_UNATTEND)) {
            TCHAR szCabFile[MAX_PATH];

            // check if the cab file is in the same directory as the INS file

            // initialize the full path to the cab file -- path to the ins + cab name
            StrCpy(szCabFile, pszIns);
            PathRemoveFileSpec(szCabFile);
            PathAppend(szCabFile, PathFindFileName(pszNewCabFileURL));

            // reinitialize szTargetFile just in case it was munged by DownloadSourceFile
            StrCpy(szTargetFile, pszTargetPath);

            // call DownloadSourceFile again but turn off checktrust because the cab is not downloaded
            Out(LI0(TEXT("Check if the cab is present in the same folder as the INS file...")));
            hr = DownloadSourceFile(szCabFile, szTargetFile, countof(szTargetFile), FALSE);
        }

        if (FAILED(hr)) {
            Out(LI3(TEXT("! Downloading \"%s\" to \"%s\" failed with %s."), pszNewCabFileURL, pszTargetPath, GetHrSz(hr)));
            return hr;
        }
    }

    hr = ExtractFilesWrap(szTargetFile, pszTargetPath, 0, NULL, NULL, 0);
    DeleteFile(szTargetFile);
    if (FAILED(hr)) {
        Out(LI2(TEXT("! Extracting files out of \"%s\" failed with %s."), szTargetFile, GetHrSz(hr)));
        return hr;
    }

    //----- Update registry information -----
    TCHAR szDate[40];

    ASSERT(hk == NULL);
    lResult = SHCreateKeyHKLM(szKeyName, KEY_SET_VALUE, &hk);
    if (lResult == ERROR_SUCCESS) {
        dwSize = (DWORD)StrCbFromSz(pszNewCabFileURL);
        RegSetValueEx(hk, RV_URL, 0, REG_SZ, (LPBYTE)pszNewCabFileURL, dwSize);

        if (pszNewVer != NULL) {
            dwSize = (DWORD)StrCbFromSz(pszNewVer);
            RegSetValueEx(hk, RV_VERSION, 0, REG_SZ, (LPBYTE)pszNewVer, dwSize);
        }

        dwSize = wnsprintf(szDate, countof(szDate), TEXT("%d.%d.%d"), st.wYear, st.wMonth, st.wDay);
        dwSize = StrCbFromCch(dwSize+1);
        RegSetValueEx(hk, RV_DATE, 0, REG_SZ, (LPBYTE)szDate, dwSize);

        SHCloseKey(hk);
    }

    Out(LI0(TEXT("Done.")));
    return S_OK;
}

HRESULT internetDownloadFile(LPCTSTR pszURL, LPCTSTR pszTargetPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, internetDownloadFile)

    static const TCHAR c_szUnknownInternetError[] = TEXT("<unknown internet error>");

    TCHAR     szAux[4096],
              szTargetFile[MAX_PATH],
              szError[MAX_PATH];
    LPCTSTR   pszDescription,
              pszFilename;
    HINTERNET hInternet,
              hinetFile;
    HRESULT   hr;
    DWORD     dwTotalSize, dwRead,
              dwAux, dwSize, dwError;
    BOOL      fResult;

    ASSERT(PathIsURL(pszURL));
    ASSERT(PathIsValidPath(pszTargetPath, PIVP_FOLDER_ONLY));

    hInternet = InternetOpen(TEXT("IE Branding DLL"), INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY, NULL, NULL, 0);
    if (hInternet == NULL) {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    Out(LI1(TEXT("Downloading \"%s\"..."), pszURL));
    hinetFile = NULL;
    hr        = S_OK;

    hinetFile = InternetOpenUrl(hInternet, pszURL, TEXT("Accept: */*\r\n"), (DWORD)-1,
        INTERNET_FLAG_EXISTING_CONNECT | INTERNET_FLAG_NEED_FILE, 0);
    if (hinetFile == NULL) {
        dwError = GetLastError();
        hr      = HRESULT_FROM_WIN32(dwError);

        if (dwError == ERROR_INTERNET_EXTENDED_ERROR) {
            dwSize  = countof(szError);
            fResult = InternetGetLastResponseInfo(&dwError, szError, &dwSize);
            hr      = HRESULT_FROM_WIN32(dwError);

            pszDescription = fResult ? szError : c_szUnknownInternetError;
            Out(LI1(TEXT("! Download failed because of \"%s\"."), pszDescription));
        }
        else
            Out(LI1(TEXT("! Download failed with %s."), GetHrSz(hr)));

        goto Exit;
    }

    dwSize  = sizeof(dwAux);
    fResult = InternetQueryOption(hinetFile, INTERNET_OPTION_HANDLE_TYPE, &dwAux, &dwSize);
    ASSERT(fResult);
    if (fResult && dwAux == INTERNET_HANDLE_TYPE_HTTP_REQUEST) {
        dwSize  = sizeof(dwAux);
        fResult = HttpQueryInfo(hinetFile, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwAux, &dwSize, NULL);
        ASSERT(fResult);
        if (fResult && dwAux != 200) {
            Out(LI1(TEXT("! Download failed with HTTP error %lu."), dwAux));
            hr = STG_E_FILENOTFOUND;
            goto Exit;
        }
    }

    for (dwTotalSize = 0; TRUE; dwTotalSize += dwRead) {
        fResult = InternetReadFile(hinetFile, szAux, sizeof(szAux), &dwRead);
        if (!fResult) {
            dwError = GetLastError();
            hr      = HRESULT_FROM_WIN32(dwError);

            if (dwError == ERROR_INTERNET_EXTENDED_ERROR) {
                dwSize  = countof(szError);
                fResult = InternetGetLastResponseInfo(&dwError, szError, &dwSize);
                hr      = HRESULT_FROM_WIN32(dwError);

                pszDescription = fResult ? szError : c_szUnknownInternetError;
                Out(LI2(TEXT("! After downloading 0x%lX bytes error \"%s\" occured."), dwTotalSize, pszDescription));
            }
            else
                Out(LI2(TEXT("! After downloading 0x%lX bytes of error %s occured."), dwTotalSize, GetHrSz(hr)));

            goto Exit;
        }

        if (dwRead == 0)
            break;
    }
    Out(LI1(TEXT("Downloaded 0x%lX bytes."), dwTotalSize));

    dwSize  = countof(szAux);
    fResult = InternetQueryOption(hinetFile, INTERNET_OPTION_DATAFILE_NAME, szAux, &dwSize);
    if (!fResult) {
        Out(LI1(TEXT("! Download failed with %s."), GetHrSz(HRESULT_FROM_WIN32(GetLastError()))));
        goto Exit;
    }

    pszFilename = PathFindFileName(pszURL);
    ASSERT(StrLen(pszFilename) < MAX_PATH);
    ASSERT(PathIsValidFile(pszFilename));
    PathCombine(szTargetFile, pszTargetPath, pszFilename);
    CopyFile(szAux, szTargetFile, FALSE);
    Out(LI0(TEXT("Done.")));

Exit:
    if (hinetFile != NULL)
        InternetCloseHandle(hinetFile);

    if (hInternet != NULL)
        InternetCloseHandle(hInternet);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\exports.cpp ===
#include "precomp.h"
#include <rashelp.h>
#include "ieaksie.h"
#include "exports.h"
#include "globalsw.h"

#include "tchar.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0500
#include <userenv.h>

#include "RSoP.h"

#define RAS_MAX_TIMEOUT 60                      // 1 minute

static BOOL s_rgfLevels[6] = { TRUE, TRUE, TRUE, TRUE, TRUE, TRUE };
MACRO_LI_InitializeEx(LIF_DEFAULT | LIF_DUPLICATEINODS, s_rgfLevels, countof(s_rgfLevels));


DWORD ProcessGroupPolicyInternal(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                                                 PGROUP_POLICY_OBJECT pDeletedGPOList,
                                                                 PGROUP_POLICY_OBJECT pChangedGPOList,
                                                                 ASYNCCOMPLETIONHANDLE pHandle,
                                                                 PBOOL pfAbort,
                                                                 PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
                                                                 BOOL bRSoP = FALSE);

static BOOL   g_SetupLog  (BOOL fInit = TRUE, PCTSTR pszLogFolder = NULL, BOOL bRSoP = FALSE);
static PCTSTR getLogFolder(PTSTR pszFolder = NULL, UINT cchFolder = 0, HANDLE hToken = NULL);
BOOL IsIE5Ins(LPCSTR pszInsA, BOOL fNeedLog = FALSE);

extern TCHAR g_szConnectoidName[RAS_MaxEntryName + 1];

HMODULE g_hmodWininet = NULL;


//
// we use this function to see if we have loaded wininet.dll due to a delayload thunk so that we 
// can free it at dll detach and therefore it will cleanup all of its crud
//
STDAPI_(FARPROC) DelayloadNotifyHook(UINT iReason, PDelayLoadInfo pdli)
{
    if (iReason == dliNoteEndProcessing)
    {
        if (pdli        &&
            pdli->szDll &&
            (StrCmpIA("wininet.dll", pdli->szDll) == 0))
        {
            // wininet was loaded!!
            g_hmodWininet = pdli->hmodCur;
        }
    }

    return NULL;
}


BOOL CALLBACK DllMain(HANDLE hModule, DWORD fdwReason, PVOID fProcessUnload)
{
    if (DLL_PROCESS_ATTACH == fdwReason) {
        g_SetHinst((HINSTANCE)hModule);

        g_hBaseDllHandle        = g_GetHinst();
        DisableThreadLibraryCalls(g_GetHinst());
    }
    else if (DLL_PROCESS_DETACH == fdwReason)
    {
        if (g_CtxIsGp())
        {
            SHCloseKey(g_hHKCU);
        }

        if (fProcessUnload == NULL)
        {
            // we are being unloaded because of a free library,
            // so see if we need to free wininet
            if (IsOS(OS_NT) && g_hmodWininet)
            {
                // we need to free wininet if it was loaded because of a delayload thunk. 
                //
                // (a) we can only safely do this on NT since on win9x calling FreeLibrary during
                //     process detach can cause a crash (depending on what msvcrt you are using).
                //
                // (b) we only really need to free this module from winlogon.exe's process context 
                //     because when we apply group policy in winlogon, MUST finally free wininet 
                //     so that it will clean up all of its reg key and file handles.
                FreeLibrary(g_hmodWininet);
            }
        }
    }

    return TRUE;
}


void CALLBACK BrandInternetExplorer(HWND, HINSTANCE, LPCSTR pszCmdLineA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandInternetExplorer)

    USES_CONVERSION;

    PCFEATUREINFO pfi;
    PCTSTR  pszCmdLine;
    HRESULT hr;
    UINT    i;

    g_SetupLog(TRUE, getLogFolder());
    MACRO_InitializeDependacies();
    Out(LI0(TEXT("\r\n")));

    Out(LI0(TEXT("Branding Internet Explorer...")));
    if (NULL != pszCmdLineA && IsBadStringPtrA(pszCmdLineA, StrCbFromCchA(3*MAX_PATH))) {
        Out(LI0(TEXT("! Command line is invalid.")));
        goto Exit;
    }
    
    pszCmdLine = A2CT(pszCmdLineA);
    Out(LI1(TEXT("Command line is \"%s\"."), (NULL != pszCmdLine) ? pszCmdLine : TEXT("<empty>")));

    hr = g_SetGlobals(pszCmdLine);

    if (FAILED(hr)) {
        Out(LI1(TEXT("! Setup of the branding process failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

    if (!IsIE5Ins(T2CA(g_GetIns())))
        goto Exit;

    // BUGBUG: <oliverl> this is a really ugly hack to fix bug 84062 in IE5 database.  
    // Basically what we're doing here is figuring out if this is the external process
    // with only zones reset which doesn't require an ins file.

    pfi = g_GetFeature(FID_ZONES_HKCU);
    
    if (!g_CtxIs(CTX_GP) || !g_CtxIs(CTX_MISC_CHILDPROCESS) ||
        HasFlag(pfi->dwFlags, FF_DISABLE))
    {
        if (!g_IsValidGlobalsSetup()) {
            Out(LI0(TEXT("! Setup of the branding process is invalid.")));
            goto Exit;
        }
    }

    // NOTE: (andrewgu) if *NOT* running in GP or Win2k unattend install context, check if
    // NoExternalBranding restriction is set. this used to include Autoconfig as well, but was
    // taken out to fix ie5.5 b#83568.
    if (!g_CtxIs(CTX_GP | CTX_W2K_UNATTEND) &&
        SHGetRestriction(RP_IE_POLICIESW, RK_RESTRICTIONSW, RV_NO_EXTERNAL_BRANDINGW)) {

        Out(LI0(TEXT("! NoExternalBranding restriction is set. Branding will not be applied.")));
        goto Exit;
    }

    // NOTE: (andrewgu) at this point it can be assumed that all the globals are setup and all
    // necessary files downloaded and move on to the actual branding.
    {   MACRO_LI_Offset(-1);
        Out(LI0(TEXT("\r\n")));
        g_LogGlobalsInfo();
    }

    //----- Download additional customization files -----
    if (g_CtxIs(CTX_AUTOCONFIG | CTX_ICW | CTX_W2K_UNATTEND)) {
        Out(LI0(TEXT("\r\nDownloading additional customization files...")));

        if (g_CtxIs(CTX_AUTOCONFIG | CTX_W2K_UNATTEND))
            hr = ProcessAutoconfigDownload();

        else {
            ASSERT(g_CtxIs(CTX_ICW));
            hr = ProcessIcwDownload();
        }

        if (SUCCEEDED(hr))
            Out(LI0(TEXT("Done.")));

        else {
            Out(LI1(TEXT("Warning! Download failed with %s"), GetHrSz(hr)));
            Out(LI0(TEXT("All customizations requiring additional files will fail!")));
        }
    }

    //----- Main processing loop -----
    hr = S_OK;

    for (i = FID_FIRST; i < FID_LAST; i++) {
        pfi = g_GetFeature(i);
        ASSERT(NULL != pfi);

        if (HasFlag(pfi->dwFlags, FF_DISABLE))
            continue;

        if (NULL == pfi->pfnProcess)
            continue;

        // HACK: <oliverl> we cannot skip favs, qls, channels, general and connection settings
        // and toolbar buttons since their preference/mandate concept is per item and we can't
        // hack GetFeatureBranded because clear logic depends on that returning the right value
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES) && 
            (FF_DISABLE != GetFeatureBranded(i)) &&
            !((i == FID_TOOLBARBUTTONS) || (i == FID_FAV_MAIN) || (i == FID_QL_MAIN) ||
              (i == FID_LCY4X_CHANNELS) || (i == FID_GENERAL)  || (i == FID_CS_MAIN)))
            continue;

        if (NULL != pfi->pszDescription) {
            MACRO_LI_Offset(1);
            Out(LI1(TEXT("\r\n%s"), pfi->pszDescription));
        }

        if (NULL == pfi->pfnApply || pfi->pfnApply())
            hr = pfi->pfnProcess();

        if (NULL != pfi->pszDescription) {
            MACRO_LI_Offset(1);
            Out(LI0(TEXT("Done.")));
        }

        /* if (E_UNEXPECTED == hr) {
            Out(LI0(TEXT("! Due to fatal error in the processing of the last feature, branding will be terminated.")));
            break;
        } */
    }

Exit:
    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}


BOOL CALLBACK BrandICW(LPCSTR pszInsA, LPCSTR, DWORD)
{
    CHAR szCmdLineA[2*MAX_PATH];

    if (!IsIE5Ins(pszInsA,TRUE))
        return TRUE;

    wsprintfA(szCmdLineA, "/mode:icw /ins:\"%s\"", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);

    SHDeleteValue(HKEY_LOCAL_MACHINE, RK_IEAK, RV_ISPSIGN);
    SHDeleteValue(g_GetHKCU(), RK_IEAK, RV_ISPSIGN);

    return TRUE;
}

// new wrapper for BrandICW with extra paramter for connectoid name so we can set the
// LAN settings for the connectoid
BOOL CALLBACK BrandICW2(LPCSTR pszInsA, LPCSTR, DWORD, LPCSTR pszConnectoidA)
{
    USES_CONVERSION;

    LPCTSTR pszIns;

    if (!IsIE5Ins(pszInsA,TRUE))
        return TRUE;

    // BUGBUG: (pritobla) we should avoid writing to target files.  if the ins file is on a
    // read-only media, we would fail..

    // NOTE: (andrewgu) save the connectioid name that was passed in, so connection settings
    // processing code can pick it up.
    pszIns = A2CT(pszInsA);
    InsWriteString (IS_CONNECTSET, IK_APPLYTONAME, A2CT(pszConnectoidA), pszIns);
    InsFlushChanges(pszIns);

    return BrandICW(pszInsA, NULL, 0);
}

BOOL CALLBACK BrandMe(LPCSTR pszInsA, LPCSTR)
{
    return BrandICW(pszInsA, NULL, 0);
}

BOOL CALLBACK BrandIntra(LPCSTR pszInsA)
{
    CHAR szCmdLineA[20 + MAX_PATH];

    wsprintfA(szCmdLineA, "/mode:win2000 /ins:\"%s\"", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);

    return TRUE;
}

void CALLBACK BrandIE4(HWND, HINSTANCE, LPCSTR pszCmdLineA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandIE4)

    USES_CONVERSION;

    CHAR    szCmdLineA[MAX_PATH];
    HRESULT hr;
    BOOL    fNoClear,
            fDefAddon;

    g_SetupLog(TRUE, getLogFolder());

    if (0 != StrCmpIA(pszCmdLineA, T2CA(FOLDER_CUSTOM)) &&
        0 != StrCmpIA(pszCmdLineA, T2CA(FOLDER_SIGNUP)) &&
        0 != StrCmpIA(pszCmdLineA, "SIGNUP")) //this is because in turkish i!=I 
    {
        Out(LI1(TEXT("! Command line \"%s\" is invalid."), A2CT(pszCmdLineA)));
        goto Exit;
    }

    // BUGBUG: (pritobla) checking the restriction should be moved into BrandInternetExplorer
    // Can't move it currently because we do other procesing here.
    if (SHGetRestriction(RP_IE_POLICIESW, RK_RESTRICTIONSW, RV_NO_EXTERNAL_BRANDINGW)) {
        Out(LI0(TEXT("! NoExternalBranding restriction is set. Branding will not be applied.")));
        goto Exit;
    }

    wsprintfA(szCmdLineA, "/mode:%s /peruser", (FALSE == ChrCmpIA('c', *pszCmdLineA)) ? "corp" : "isp");

    // BUGBUG: (andrewgu) this is very wrong! we should not be initializing globals here!
    hr = g_SetGlobals(A2CT(szCmdLineA));
    if (FAILED(hr)) {
        Out(LI1(TEXT("! Setup of the branding process failed with %s."), GetHrSz(hr)));
        goto Exit;
    }

    if (!g_IsValidGlobalsSetup()) {
        Out(LI0(TEXT("! Setup of the branding process is invalid.")));
        goto Exit;
    }

    if (!IsIE5Ins(T2CA(g_GetIns())))
        goto Exit;

    //----- Main processing -----
    // NOTE: (andrewgu) at this point it can be assumed that all the globals are setup and all
    // necessary files downloaded and move on to the actual branding.
    fNoClear  = InsGetBool(IS_BRANDING, TEXT("NoClear"), FALSE, g_GetIns());
    fDefAddon = InsGetBool(IS_BRANDING, IK_DEF_ADDON,    FALSE, g_GetIns());

    Out(LI1(TEXT("NoClear flag is%s specified."), fNoClear ? TEXT("") : TEXT(" not")));

    // if NoClear is not set or use default menu text and URL for Windows Update is specified,
    // delete the custom reg values
    if (!fNoClear || fDefAddon) {
        if (fNoClear  &&  fDefAddon)
            Out(LI0(TEXT("Use default Windows Update menu text and URL flag is specified.")));

        SHDeleteValue(g_GetHKCU(), RK_IE_POLICIES, RV_HELP_MENU_TEXT);
        SHDeleteValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3);

        Out(LI0(TEXT("Deleted reg values for custom Windows Update menu text and URL.")));
    }

    // process Tools->Windows Update menu text and URL customization only if one of
    // fDefAddon or fNoAddon or fCustAddon is TRUE
    if (!fDefAddon) {
        TCHAR szAddOnURL[INTERNET_MAX_URL_LENGTH],
              szMenuText[128];
        BOOL  fSetReg = FALSE,
              fNoAddon,
              fCustAddon;

        fNoAddon   = InsGetBool(IS_BRANDING, IK_NO_ADDON,   FALSE, g_GetIns());
        fCustAddon = InsGetBool(IS_BRANDING, IK_CUST_ADDON, FALSE, g_GetIns());

        if (fNoAddon) {
            Out(LI0(TEXT("Flag to remove Windows Update from Tools menu is specified.")));

            *szMenuText = TEXT('\0');
            *szAddOnURL = TEXT('\0');
            fSetReg = TRUE;
        }
        else if (fCustAddon) {
            Out(LI0(TEXT("Use custom Windows Update text and URL flag is specified.")));

            GetPrivateProfileString(IS_BRANDING, IK_HELP_MENU_TEXT, TEXT(""), szMenuText, countof(szMenuText), g_GetIns());
            GetPrivateProfileString(IS_BRANDING, IK_ADDONURL,       TEXT(""), szAddOnURL, countof(szAddOnURL), g_GetIns());
            if (TEXT('\0') != szMenuText[0] && TEXT('\0') != szAddOnURL[0]) {
                Out(LI1(TEXT("Custom Windows Update menu text = \"%s\""), szMenuText));
                Out(LI1(TEXT("Custom Windows Update URL       = \"%s\""), szAddOnURL));
                fSetReg = TRUE;
            }
            else
                Out(LI0(TEXT("One of custom Windows Update menu text or URL is not specified;")
                        TEXT(" so customization will not be applied.")));
        }

        if (fSetReg) {
            // if the menu text is an empty string, the browser will remove the item from the Tools menu;
            // otherwise, it will use string we set
            SHSetValue(g_GetHKCU(), RK_IE_POLICIES, RV_HELP_MENU_TEXT, REG_SZ, (CONST BYTE *) szMenuText, (DWORD)StrCbFromSz(szMenuText));

            // Note. The association of the value name "3" with the addon URL comes from homepage.inf.
            // So we have a dependency with homepage.inf.
            if (*szAddOnURL)
                SHSetValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3, REG_SZ, (CONST BYTE *) szAddOnURL, (DWORD)StrCbFromSz(szAddOnURL));
            else
                SHDeleteValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3);
        }
    }

    switch (*pszCmdLineA) {
    case 'c':
    case 'C':
        {
            MACRO_LI_Offset(-1);                // need a new scope
            Out(LI0(TEXT("\r\n")));
            BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);
        }
        break;

    case 's':
    case 'S':
        if (HasFlag(g_GetContext(), CTX_SIGNUP_ALL) && IsNTAdmin()) {
            DWORD dwAux, dwSize;

            dwAux  = 1;
            dwSize = sizeof(dwAux);
            SHSetValue(HKEY_LOCAL_MACHINE, RK_IEAK, RV_ISPSIGN, REG_DWORD, (LPBYTE)&dwAux, dwSize);
            SHSetValue(g_GetHKCU(), RK_IEAK, RV_ISPSIGN, REG_DWORD, (LPBYTE)&dwAux, dwSize);

            dwAux = 0;
            SHSetValue(g_GetHKCU(), RK_ICW, RV_COMPLETED, REG_DWORD, (LPBYTE)&dwAux, dwSize);
        }

        {
            MACRO_LI_Offset(-1);                // need a new scope
            Out(LI0(TEXT("\r\n")));
            BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);
        }

        // launch IE to complete the sign up process after the branding is complete
        if (HasFlag(g_GetContext(), CTX_SIGNUP_ALL) && IsNTAdmin()) {
            TCHAR szIExplorePath[MAX_PATH];
            DWORD dwType = REG_SZ,
                  dwSize;

            // check for automatic signup
            dwSize = countof(szIExplorePath);
            *szIExplorePath = TEXT('\0'); // using szIExplorePath as a temporary variable...
            SHGetValue(g_GetHKCU(), RK_IEAK, RV_NOAUTOSIGNUP, &dwType, (LPBYTE)szIExplorePath, &dwSize);
            if (StrCmp(szIExplorePath, TEXT("1")) != 0) // if do autosignup
            {
                dwSize = countof(szIExplorePath);
                if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\IEXPLORE.EXE"),
                               TEXT(""), NULL, (LPVOID)szIExplorePath, &dwSize) == ERROR_SUCCESS) {
                    SHELLEXECUTEINFO shInfo;

                    ZeroMemory(&shInfo, sizeof(shInfo));
                    shInfo.cbSize = sizeof(shInfo);
                    shInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
                    shInfo.hwnd   = GetDesktopWindow();
                    shInfo.lpVerb = TEXT("open");
                    shInfo.lpFile = szIExplorePath;
                    shInfo.nShow  = SW_SHOWNORMAL;

                    ShellExecuteEx(&shInfo);
                    if (shInfo.hProcess != NULL)
                        CloseHandle(shInfo.hProcess);
                }
            }
        }
        break;

    default:
        ASSERT(FALSE);
    }

Exit:
    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}

//Qfe 3430: When parsing ins file, with reference to pac file, wininet needs to 
//know the connectoid name in order to set the pac file correctly. Currently there
//is no way for wininet to pass the connectoid name to branding dll. To workaround
//this, we use the AUTO_PROXY_EXTERN_STRUC to pass the connectoid name in lpszScriptBuffer
//variable. 
typedef struct 
{
    DWORD dwStructSize;
    LPSTR lpszScriptBuffer;
    DWORD dwScriptBufferSize;
}  AUTO_PROXY_EXTERN_STRUC, *LPAUTO_PROXY_EXTERN_STRUC;

BOOL CALLBACK _InternetInitializeAutoProxyDll(DWORD, LPCSTR pszInsA, LPCSTR, LPVOID, DWORD_PTR lpExtraStruct)
{
    static BOOL fRunning; /*= FALSE;*/
    CHAR szCmdLineA[2*MAX_PATH];

    if (fRunning)
        return TRUE;
    fRunning = TRUE;

    USES_CONVERSION;
    
    if(lpExtraStruct && ((LPAUTO_PROXY_EXTERN_STRUC)lpExtraStruct)->lpszScriptBuffer)
    {
        LPCSTR pszConnectoidA = ((LPAUTO_PROXY_EXTERN_STRUC)lpExtraStruct)->lpszScriptBuffer;
        StrCpy(g_szConnectoidName, A2CT(pszConnectoidA));
    }

    wsprintfA(szCmdLineA, "/mode:autoconfig /ins:\"%s\"", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);

    fRunning = FALSE;
    return TRUE;
}

void CALLBACK BrandInfAndOutlookExpress(LPCSTR pszInsA)
{
    CHAR szCmdLineA[2*MAX_PATH];

    wsprintfA(szCmdLineA, "/mode:generic /ins:\"%s\" /flags:erim=0,eriu=0,oe=0 /disable", pszInsA);
    BrandInternetExplorer(NULL, NULL, szCmdLineA, 0);
}

BOOL CALLBACK BrandCleanInstallStubs(HWND, HINSTANCE, LPCSTR pszCompanyA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandCleanInstallStubs)

    USES_CONVERSION;

    TCHAR   szBrandStubGuid[MAX_PATH];
    LPCTSTR pszCompany;
    HKEY    hklm, hkcu;
    LONG    lResult;

    g_SetupLog(TRUE, getLogFolder());

    pszCompany = A2CT(pszCompanyA);
    if (pszCompany == NULL)
        pszCompany = TEXT("");

    if (*pszCompany == TEXT('>'))
        StrCpy(szBrandStubGuid, pszCompany);
    else
        wnsprintf(szBrandStubGuid, countof(szBrandStubGuid), TEXT(">%s%s"), BRANDING_GUID_STR, pszCompany);
        
    Out(LI1(TEXT("\r\nCleaning install stubs; Company GUID is \"%s\"..."), szBrandStubGuid));

    if (*pszCompany != TEXT('\0') && *pszCompany != TEXT(' ')) {
        HKEY hk;

        lResult = SHCreateKeyHKLM(RK_UNINSTALL_BRANDING, KEY_SET_VALUE, &hk);
        if (lResult == ERROR_SUCCESS) {
            RegSetValueEx(hk, RV_QUIET,      0, REG_SZ, (LPBYTE)RD_RUNDLL, sizeof(RD_RUNDLL));
            RegSetValueEx(hk, RV_REQUIRE_IE, 0, REG_SZ, (LPBYTE)RD_IE_VER, sizeof(RD_IE_VER));

            SHCloseKey(hk);
        }
    }
    else {
        SHDeleteKey(HKEY_LOCAL_MACHINE, RK_UNINSTALL_BRANDING);

        SHDeleteValue(HKEY_LOCAL_MACHINE, RK_IEAK, RV_ISPSIGN);
        SHDeleteValue(g_GetHKCU(),  RK_IEAK, RV_ISPSIGN);

        // if the previous version of IE is 3.0 or lower, delete the CUSTOM and SIGNUP folders under the IE install dir
        if (BackToIE3orLower())
        {
            TCHAR szPath[MAX_PATH];

            if (GetIEPath(szPath, countof(szPath)) != NULL)
            {
                LPTSTR pszPtr = PathAddBackslash(szPath);

                SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
                SHDeleteKey(HKEY_LOCAL_MACHINE, RK_IEAK_CABVER);

                StrCpy(pszPtr, TEXT("CUSTOM"));
                PathRemovePath(szPath);
                Out(LI1(TEXT("Deleted folder \"%s\"..."), szPath));

                StrCpy(pszPtr, TEXT("SIGNUP"));
                PathRemovePath(szPath);
                Out(LI1(TEXT("Deleted folder \"%s\"..."), szPath));
            }
        }

        Clear(NULL, NULL, NULL, 0);

        // clear out the "Windows Update" menu customizations
        // NOTE: this can't be merged into Clear() because during
        // install time, these customizations are set before Clear()
        // is called.
        SHDeleteValue(g_GetHKCU(), RK_IE_POLICIES, RV_HELP_MENU_TEXT);
        SHDeleteValue(HKEY_LOCAL_MACHINE, RK_HELPMENUURL, RV_3);
    }

    lResult = SHOpenKeyHKLM(RK_AS_INSTALLEDCOMPONENTS, KEY_ALL_ACCESS, &hklm);
    if (lResult == ERROR_SUCCESS) 
    {
        TCHAR szSubkey[MAX_PATH];
        DWORD dwSize,
              dwSubkey;

        hkcu = NULL;                            // if the next line fails
        SHOpenKey(g_GetHKCU(), RK_AS_INSTALLEDCOMPONENTS, KEY_ALL_ACCESS, &hkcu);

        dwSubkey = 0;
        dwSize   = countof(szSubkey);
        while (RegEnumKeyEx(hklm, dwSubkey, szSubkey, &dwSize, NULL, NULL, 0, NULL) == ERROR_SUCCESS) 
        {
            TCHAR szCompId[MAX_PATH];

            if (StrCmpI(szBrandStubGuid, szSubkey) != 0)
            {
                // look for the BRANDING.CAB ComponentID value under the key if we didn't just add
                // this guid
                
                dwSize = sizeof(szCompId);
                
                if ((SHGetValue(hklm, szSubkey, TEXT("ComponentID"), NULL, (LPBYTE)szCompId, 
                    &dwSize) == ERROR_SUCCESS) && (StrCmpI(szCompId, TEXT("BRANDING.CAB")) == 0))
                {
                    Out(LI1(TEXT("Deleting install stub key \"%s\"..."), szSubkey));
                    
                    SHDeleteKey(hklm, szSubkey);
                    if (hkcu != NULL)
                        SHDeleteKey(hkcu, szSubkey);
                    
                    dwSize = countof(szSubkey);
                    continue;                   // maintain the index properly
                }
            }
            dwSize = countof(szSubkey);
            dwSubkey++;
        }
        SHCloseKey(hklm);

        if (hkcu != NULL)
            SHCloseKey(hkcu);
    }

    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);

    return TRUE;
}

void CALLBACK Clear(HWND, HINSTANCE, LPCSTR, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, Clear)

    HKEY  hk;
    TCHAR szIEResetInf[MAX_PATH];

    g_SetupLog(TRUE, getLogFolder());

    Out(LI0(TEXT("\r\nRemoving customizations...")));
    MACRO_InitializeDependacies();

    if (SHOpenKeyHKLM(RK_IE_MAIN, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_COMPANYNAME);
        RegDeleteValue(hk, RV_WINDOWTITLE);
        RegDeleteValue(hk, RV_CUSTOMKEY);
        RegDeleteValue(hk, RV_SMALLBITMAP);
        RegDeleteValue(hk, RV_LARGEBITMAP);

        SHCloseKey(hk);
    }

    if (SHOpenKey(g_GetHKCU(), RK_IE_MAIN, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_SEARCHBAR);
        RegDeleteValue(hk, RV_USE_CUST_SRCH_URL);
        RegDeleteValue(hk, RV_WINDOWTITLE);

        SHCloseKey(hk);
    }

    if (SHOpenKey(g_GetHKCU(), RK_HELPMENUURL, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_ONLINESUPPORT);
        SHCloseKey(hk);
    }

    if (SHOpenKey(g_GetHKCU(), RK_TOOLBAR, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        RegDeleteValue(hk, RV_BRANDBMP);
        RegDeleteValue(hk, RV_SMALLBRANDBMP);
        RegDeleteValue(hk, RV_BACKGROUNDBMP);
        RegDeleteValue(hk, RV_BACKGROUNDBMP50);
        RegDeleteValue(hk, RV_SMALLBITMAP);
        RegDeleteValue(hk, RV_LARGEBITMAP);

        SHCloseKey(hk);
    }

    if (SHOpenKeyHKLM(RK_UA_POSTPLATFORM, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS)
    {
        TCHAR szUAVal[MAX_PATH];
        TCHAR szUAData[32];
        DWORD sUAVal = countof(szUAVal);
        DWORD sUAData = sizeof(szUAData);
        int iUAValue = 0;

        while (RegEnumValue(hk, iUAValue, szUAVal, &sUAVal, NULL, NULL, (LPBYTE)szUAData, &sUAData) == ERROR_SUCCESS)
        {
            Out(LI2(TEXT("Checking User Agent Key %s = %s"), szUAVal, szUAData));

            sUAVal  = countof(szUAVal);
            sUAData = sizeof(szUAData);

            if (StrCmpN(szUAData, TEXT("IEAK"), 4) == 0)
            {
                Out(LI1(TEXT("Deleting User Agent Key %s"), szUAVal));
                RegDeleteValue(hk, szUAVal);
                continue;
            }

            iUAValue++;
        }

        SHCloseKey(hk);
    }

    // restore RV_DEFAULTPAGE and START_PAGE_URL to the default MS value
    GetWindowsDirectory(szIEResetInf, countof(szIEResetInf));
    PathAppend(szIEResetInf, TEXT("inf\\iereset.inf"));
    if (PathFileExists(szIEResetInf))
    {
        TCHAR szDefHomePage[MAX_PATH];

        GetPrivateProfileString(IS_STRINGS, TEXT("MS_START_PAGE_URL"), TEXT(""), szDefHomePage, countof(szDefHomePage), szIEResetInf);
        WritePrivateProfileString(IS_STRINGS, TEXT("START_PAGE_URL"), szDefHomePage, szIEResetInf);

        SHSetValue(HKEY_LOCAL_MACHINE, RK_IE_MAIN, RV_DEFAULTPAGE, REG_SZ, (LPCVOID)szDefHomePage, (DWORD)StrCbFromSz(szDefHomePage));
    }

    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}

void CALLBACK CloseRASConnections(HWND, HINSTANCE, LPCTSTR, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, CloseRASConnections)

    USES_CONVERSION;

    RASCONNSTATUSA rcsA;
    LPRASCONNA     prcA;
    DWORD cEntries,
          dwResult;
    UINT  i, iRetries;
    BOOL  fRasApisLoaded;

    g_SetupLog(TRUE, getLogFolder());

    Out(LI0(TEXT("Closing RAS connections...")));
    prcA           = NULL;
    fRasApisLoaded = FALSE;

    if (!RasIsInstalled()) {
        Out(LI0(TEXT("RAS support is not installed. There are no active RAS connections!")));
        goto Exit;
    }

    if (!RasPrepareApis(RPA_RASHANGUPA | RPA_RASGETCONNECTSTATUSA) ||
        (g_pfnRasHangupA == NULL || g_pfnRasGetConnectStatusA == NULL)) {
        Out(LI0(TEXT("! Required RAS APIs failed to load.")));
        goto Exit;
    }
    fRasApisLoaded = TRUE;

    dwResult = RasEnumConnectionsExA(&prcA, NULL, &cEntries);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI1(TEXT("! Enumeration of RAS connections failed with %s."), GetHrSz(dwResult)));
        goto Exit;
    }

    for (i = 0;  i < cEntries;  i++) {
        if (i > 0)
            Out(LI0(TEXT("\r\n")));
        Out(LI1(TEXT("Closing \"%s\" connection..."), A2CT((prcA + i)->szEntryName)));

        dwResult = g_pfnRasHangupA((prcA + i)->hrasconn);
        if (dwResult != ERROR_SUCCESS) {
            Out(LI1(TEXT("! Operation failed with %s."), GetHrSz(dwResult)));
            continue;
        }

        for (iRetries = 0; iRetries < RAS_MAX_TIMEOUT; iRetries++) {
            ZeroMemory(&rcsA, sizeof(rcsA));
            rcsA.dwSize = sizeof(rcsA);
            dwResult   = g_pfnRasGetConnectStatusA((prcA + i)->hrasconn, &rcsA);
            if (dwResult != ERROR_SUCCESS)
                break;

            TimerSleep(1000);                   // 1 second
        }
        if (iRetries >= RAS_MAX_TIMEOUT)
            Out(LI0(TEXT("! Operation timed out.")));
    }

Exit:
    if (prcA != NULL)
        CoTaskMemFree(prcA);

    if (fRasApisLoaded)
        RasPrepareApis(RPA_UNLOAD, FALSE);

    Out(LI0(TEXT("Done.")));
    g_SetupLog(FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

#define BRNDLOG_INI TEXT("brndlog.ini")
#define RSOPLOG_INI TEXT("rsoplog.ini")
#define BRNDLOG_TXT TEXT("brndlog.txt")
#define RSOPLOG_TXT TEXT("rsoplog.txt")
#define DOT_BAK     TEXT(".bak")

#define IS_SETTINGS TEXT("Settings")
#define IK_FILE     TEXT("LogFile")
#define IK_LOGFLAGS TEXT("LogFlags")
#define IK_DOLOG    TEXT("DoLog")
#define IK_BACKUP   TEXT("BackupFiles")
#define IK_FLUSH    TEXT("FlushEveryWrite")
#define IK_APPEND   TEXT("AppendToLog")


static BOOL g_SetupLog(BOOL fInit /*= TRUE*/, PCTSTR pszLogFolder /*= NULL*/, BOOL bRSoP /*= FALSE*/)
{
    static UINT s_cRef; /*= 0*/

    if (fInit) {
        TCHAR szIni[MAX_PATH],
              szLog[MAX_PATH], szBak[MAX_PATH], szAux[MAX_PATH], szExt[5],
              szFlags[17];
        DWORD dwFlags;
        UINT  nBackups,
              i;
        BOOL  fDoLog,
              fAppend;

        // refcount g_hfileLog
        if (NULL != g_hfileLog) {
            ASSERT(0 < s_cRef);
            s_cRef++;

            return TRUE;
        }
        ASSERT(0 == s_cRef);

        // determine the locaion of the log settings file
        if (NULL != pszLogFolder){
            ASSERT(PathIsValidPath(pszLogFolder));

            StrCpy(szIni, pszLogFolder);
        }
        else {
            ASSERT(NULL != g_GetHinst());

            GetModuleFileName(g_GetHinst(), szIni, countof(szIni));
            PathRemoveFileSpec(szIni);
        }
        PathAppend(szIni, bRSoP ? RSOPLOG_INI : BRNDLOG_INI);

        // log file name or even log file path
                InsGetString(IS_SETTINGS, IK_FILE, szLog, countof(szLog), szIni);
                if (TEXT('\0') == szLog[0])
                        StrCpy(szLog, bRSoP ? RSOPLOG_TXT : BRNDLOG_TXT);

        if (PathIsFileSpec(szLog))
            if (NULL != pszLogFolder) {
                PathCombine(szAux, pszLogFolder, szLog);
                StrCpy(szLog, szAux);
            }
            else {
                GetWindowsDirectory(szAux, countof(szAux));
                PathAppend(szAux, szLog);
                StrCpy(szLog, szAux);
            }

        // logging flags
        dwFlags = LIF_NONE;

        InsGetString(IS_SETTINGS, IK_LOGFLAGS, szFlags, countof(szFlags), szIni);
        if (TEXT('\0') != szFlags[0]) {
            StrToIntEx(szFlags, STIF_SUPPORT_HEX, (PINT)&dwFlags);
            if (-1 == (int)dwFlags)
                dwFlags = LIF_NONE;
        }

        if (LIF_NONE == dwFlags) {
            dwFlags = LIF_DATETIME | LIF_APPENDCRLF;
            DEBUG_CODE(dwFlags |= LIF_FILE | LIF_FUNCTION | LIF_CLASS | LIF_LINE);
        }
        MACRO_LI_SetFlags(dwFlags);

        // append to the existing log?
        fAppend = InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni);

        // backup settings
        // Note. if (fAppend), the default is to clear all the backups.
        StrCpy(szBak, szLog);

        if (fAppend)
            nBackups = 0;

        else {
            nBackups = 1;                       // default in retail: 1
            DEBUG_CODE(nBackups = 10);          // default in debug: 10
        }

        nBackups = InsGetInt(IS_SETTINGS, IK_BACKUP, nBackups, szIni);
        for (i = nBackups; i < 10; i++) {
            if (0 == i)
                StrCpy(szExt, DOT_BAK);
            else
                wnsprintf(szExt, countof(szExt), TEXT(".%03u"), i);

            PathRenameExtension(szBak, szExt);
            if (!PathFileExists(szBak))
                break;
            DeleteFile(szBak);
        }

        // create a log for the call in progress?
        fDoLog = InsGetBool(IS_SETTINGS, IK_DOLOG, TRUE, szIni);
        g_fFlushEveryWrite = FALSE;

        if (fDoLog) {
            if (!fAppend && 0 < nBackups) {
                StrCpy(szAux, szLog);
                StrCpy(szBak, szLog);

                for (i = nBackups; 0 < i; i--) {
                    // source file
                    if (1 == i)
                        StrCpy(szAux, szLog);

                    else {
                        if (2 == i)
                            StrCpy(szExt, DOT_BAK);
                        else
                            wnsprintf(szExt, countof(szExt), TEXT(".%03u"), i-2);

                        PathRenameExtension(szAux, szExt);
                        if (!PathFileExists(szAux))
                            continue;
                    }

                    // target file
                    if (1 == i)
                        StrCpy(szExt, DOT_BAK);
                    else
                        wnsprintf(szExt, countof(szExt), TEXT(".%03u"), i-1);

                    PathRenameExtension(szBak, szExt);

                    // push log down the chain
                    CopyFile(szAux, szBak, FALSE);
                }
            }

            // flush current log on every write (i.e. every log output)?
            DEBUG_CODE(g_fFlushEveryWrite = TRUE);
            g_fFlushEveryWrite = InsGetBool(IS_SETTINGS, IK_FLUSH, g_fFlushEveryWrite, szIni);

            g_hfileLog = CreateFile(szLog,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
            if (INVALID_HANDLE_VALUE == g_hfileLog)
                g_hfileLog = NULL;

            else {
                s_cRef++;                       // increment g_hfileLog ref count

                if (fAppend) {
                    SetFilePointer(g_hfileLog, 0, NULL, FILE_END);
                    Out(LI0(TEXT("\r\n\r\n")));
                }
            }
        }
    }
    else { /* if (!fInit) */
        if (1 == s_cRef && NULL != g_hfileLog) {
            CloseHandle(g_hfileLog);
            g_hfileLog = NULL;
        }

        if (0 < s_cRef)
            s_cRef--;
    }

    return TRUE;
}

PCTSTR getLogFolder(PTSTR pszFolder /*= NULL*/, UINT cchFolder /*= 0*/, HANDLE hToken /* = NULL */)
{
    static TCHAR s_szPath[MAX_PATH];
    static UINT  s_cchPath;

    if (NULL != pszFolder)
        *pszFolder = TEXT('\0');

    if (!IsOS(OS_NT))
        return NULL;

    if (TEXT('\0') == s_szPath[0]) {
                HRESULT hr;

                hr = SHGetFolderPathSimple(CSIDL_APPDATA | CSIDL_FLAG_CREATE, s_szPath);
                if (FAILED(hr))
                                return NULL;

                // need to make sure app data path is owned by user in the GP context

                if (g_CtxIsGp() && (hToken != NULL))
                                SetUserFileOwner(hToken, s_szPath);

                PathAppend(s_szPath, TEXT("Microsoft"));
                if (!PathFileExists(s_szPath)) {
                                CreateDirectory  (s_szPath, NULL);
                                SetFileAttributes(s_szPath, FILE_ATTRIBUTE_SYSTEM);
                }
                PathAppend(s_szPath, TEXT("Internet Explorer"));

                PathCreatePath(s_szPath);
                if (!PathFileExists(s_szPath))
                                return NULL;

                s_cchPath = StrLen(s_szPath);
    }
    else
        ASSERT(0 < s_cchPath);

    if (NULL == pszFolder || cchFolder <= s_cchPath)
        return s_szPath;

    StrCpy(pszFolder, s_szPath);
    return pszFolder;
}

// NOTE: (genede) Added 1/26/2001 to block branding of INS files created prior to IE 5.0 Gold.
// While the Wizard creates a [Branding] | Wizard_Version key that can be used to determine 
// this, neither the Profile Manger nor the IEM did so, so their INS files must always be
// branded.  To allow IEAK 7 to be able to block all INS files made prior to IE 6, IE 6 bug db 
// #25076 was opened, requiring the addition of a version entry to Profile Manager and IEM
// created INS files.  This bug was fixed on 2/23/2001.
BOOL IsIE5Ins(LPCSTR pszInsA, BOOL fNeedLog /*= FALSE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, IsIE5Ins)

    USES_CONVERSION;

    TCHAR szWizVer[MAX_PATH];
    DWORD dwVer,
          dwBuild;

    // If [Branding] | Wizard_Version exists, the INS was created by the Wizard.
    if (InsKeyExists(IS_BRANDING, IK_WIZVERSION, A2CT(pszInsA))) {
        InsGetString(IS_BRANDING, IK_WIZVERSION, szWizVer, countof(szWizVer), A2CT(pszInsA));
        ConvertVersionStrToDwords(szWizVer, &dwVer, &dwBuild);
        // If the version is < 5, don't brand.
        if (5 > HIWORD(dwVer)) {
            // Open a log if one has not already been opened.
            if (fNeedLog)
                g_SetupLog(TRUE, getLogFolder());

            Out(LI0(TEXT("! Branding of INS files created by IEAK Wizard 4.x and earlier is not supported.")));

            // Close a log if one was opened.
            if (fNeedLog)
                g_SetupLog(FALSE);

            return FALSE;
        }
    }

    // The INS was created by ProfMgr or IEM, or by Wiz ver 5.0 or greater, so brand.
    return TRUE;
}

//----------------------------------------------------------------------------------------
// NT5 client processing

#define RK_IEAKCSE   REGSTR_PATH_NT_CURRENTVERSION TEXT("\\Winlogon\\GPExtensions\\{A2E30F80-D7DE-11d2-BBDE-00C04F86AE3B}")

static void    brandExternalHKCUStuff(LPCTSTR pcszInsFile);
static BOOL    constructCmdLine(LPTSTR pszCmdLine, DWORD cchLen, LPCTSTR pcszInsFile, BOOL fExternal);
static void    displayStatusMessage(PFNSTATUSMESSAGECALLBACK pStatusCallback);
static HRESULT pepCopyFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl = NULL);
PFNPATHENUMPATHPROC GetPepCopyFilesEnumProc() {return pepCopyFilesEnumProc;}

STDAPI DllRegisterServer(void)
{   MACRO_LI_PrologEx_C(PIF_STD_C, DllRegisterServer)
    HKEY hKey;
    LONG lResult = S_OK;
    TCHAR szName[MAX_PATH];

    g_SetupLog(TRUE, getLogFolder());

    if (IsOS(OS_NT5))
    {
        lResult = SHCreateKeyHKLM(RK_IEAKCSE, KEY_WRITE, &hKey);
        
        if (lResult == ERROR_SUCCESS)
        {
            DWORD dwVal;

            if (IsOS(OS_WHISTLERORGREATER))
            {
                RegSetValueEx(hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicyEx"),
                                (StrLen(TEXT("ProcessGroupPolicyEx")) + 1) * sizeof(TCHAR));
                RegSetValueEx(hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("GenerateGroupPolicy"),
                                (StrLen(TEXT("GenerateGroupPolicy")) + 1) * sizeof(TCHAR));
            }

            // ushaji said this chould stay registered in Whistler
            RegSetValueEx(hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicy"),
                                    (StrLen(TEXT("ProcessGroupPolicy")) + 1) * sizeof(TCHAR));

            RegSetValueEx(hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("iedkcs32.dll"),
                    (StrLen(TEXT("iedkcs32.dll")) + 1) * sizeof(TCHAR));

            LoadString(g_GetHinst(), IDS_NAME, szName, countof(szName));

            RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE) szName,
                    (DWORD)StrCbFromSz(szName));

            // do not process on slow link by default

            dwVal = 1;
            RegSetValueEx(hKey, TEXT("NoSlowLink"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            // process in background by default

            dwVal = 0;
            RegSetValueEx(hKey, TEXT("NoBackgroundPolicy"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            // do not process if no GPO changes by default

            dwVal = 1;
            RegSetValueEx(hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            // do not process machine policy changes by default

            dwVal = 1;
            RegSetValueEx(hKey, TEXT("NoMachinePolicy"), 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal)); 
            
            RegCloseKey (hKey);
            
            Out(LI0(TEXT("DllRegisterServer keys added successfully!")));
        }
    }

    Out(LI0(TEXT("DllRegisterServer finished.")));
    g_SetupLog(FALSE);

    return lResult;
}

STDAPI DllUnregisterServer(void)
{   MACRO_LI_PrologEx_C(PIF_STD_C, DllUnregisterServer)

    g_SetupLog(TRUE, getLogFolder());

    if (IsOS(OS_NT5))
        SHDeleteKey(HKEY_LOCAL_MACHINE, RK_IEAKCSE);

    Out(LI0(TEXT("DllUnregisterServer finished!")));
    g_SetupLog(FALSE);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ProcessGroupPolicy(
    DWORD                    dwFlags,
    HANDLE                   hToken,
    HKEY                     hKeyRoot,
    PGROUP_POLICY_OBJECT     pDeletedGPOList,
    PGROUP_POLICY_OBJECT     pChangedGPOList,
    ASYNCCOMPLETIONHANDLE    pHandle,
    PBOOL                    pfAbort,
    PFNSTATUSMESSAGECALLBACK pfnStatusCallback
)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGroupPolicy)

        return ProcessGroupPolicyInternal(dwFlags, hToken, hKeyRoot, pDeletedGPOList,
                                                                                pChangedGPOList, pHandle, pfAbort,
                                                                                pfnStatusCallback, FALSE);
}


///////////////////////////////////////////////////////////////////////////////
DWORD ProcessGroupPolicyInternal(
    DWORD                    dwFlags,
    HANDLE                   hToken,
    HKEY                     hKeyRoot,
    PGROUP_POLICY_OBJECT     pDeletedGPOList,
    PGROUP_POLICY_OBJECT     pChangedGPOList,
    ASYNCCOMPLETIONHANDLE    pHandle,
    PBOOL                    pfAbort,
    PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
    BOOL                     bRSoP /*= FALSE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGroupPolicyInternal)

    TCHAR szIni[MAX_PATH];
    DWORD dwRet;
    BOOL  fDeleteIni;

    UNREFERENCED_PARAMETER(pHandle);
    UNREFERENCED_PARAMETER(hKeyRoot);
    UNREFERENCED_PARAMETER(pDeletedGPOList);
    UNREFERENCED_PARAMETER(bRSoP);

    szIni[0]   = TEXT('\0');
    dwRet      = ERROR_SUCCESS;
    fDeleteIni = TRUE;

    __try
    {
        USES_CONVERSION;

        PGROUP_POLICY_OBJECT pCurGPO;
        TCHAR szCustomDir[MAX_PATH],
              szTempDir[MAX_PATH],
              szInsFile[MAX_PATH];
        HKEY  hkGP = NULL;

        // get our user appdata path
        // BUGBUG: <oliverl> we are currently relying on the fact that g_GetUserToken is not
        // initialized here because when we pass in the NULL it currently gets the local appdata
        // path always due to per process shell folder cache.  This might change in the next
        // rev though if extension order has changed.  We need to do this because of possible
        // folder redirection of appdata to a UNC path which would bust us since we don't 
        // impersonate user everywhere we reference appdata files

        getLogFolder(szCustomDir, countof(szCustomDir), hToken);
        if (TEXT('\0') == szCustomDir[0])
            return ERROR_OVERRIDE_NOCHANGES;

        // set log to append, backup what's there
        g_SetupLog(TRUE, szCustomDir);
        PathCombine(szIni, szCustomDir, BRNDLOG_INI);

        fDeleteIni = !PathFileExists(szIni);
        if (!fDeleteIni && InsKeyExists(IS_SETTINGS, IK_APPEND, szIni))
            InsWriteBool(IS_SETTINGS, TEXT("Was") IK_APPEND,
                InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni), szIni);

        InsWriteBool(IS_SETTINGS, IK_APPEND, TRUE, szIni);

        PathAppend(szCustomDir, TEXT("Custom Settings"));
        MACRO_InitializeDependacies();
        Out(LI0(TEXT("\r\n")));

        Out(LI0(TEXT("Processing Group Policy...")));

        g_SetUserToken(hToken);
        g_SetGPOFlags(dwFlags);
        if (!g_SetHKCU())
            Out(LI0(TEXT("! Failed to acquire HKCU. Some of the settings may not get applied.")));

        /*
        if (dwFlags & GPO_INFO_FLAG_SLOWLINK)
            OutputDebugString (TEXT("IEDKCS32:  Policy is being applied across a slow link.\r\n"));

        if (dwFlags & GPO_INFO_FLAG_VERBOSE)
            OutputDebugString (TEXT("IEDKCS32:  Verbose policy logging is requested (to the eventlog).\r\n"));
        */

        // get a handle to the GPO tracking key up front since we use it so much in the
        // processing below

        if (SHCreateKey(g_GetHKCU(), RK_IEAK_GPOS, KEY_DEFAULT_ACCESS, &hkGP) != ERROR_SUCCESS)
        {
            OutD(LI0(TEXT("! Failed to create GP tracking key. Aborting ...")));
            dwRet =  ERROR_OVERRIDE_NOCHANGES; 
            goto End;
        }

        // Processing deleted GPO list

        for (pCurGPO = pDeletedGPOList; (pCurGPO != NULL); pCurGPO = pCurGPO->pNext)
        {
            if ( *pfAbort )
            {
                OutD(LI0(TEXT("! Aborting further processing due to abort message.")));
                dwRet =  ERROR_OVERRIDE_NOCHANGES; 
                goto End;
            }

            OutD(LI1(TEXT("Deleting GPO: \"%s\"."), pCurGPO->lpDisplayName));
            OutD(LI1(TEXT("Guid is \"%s\"."), pCurGPO->szGPOName));
            SHDeleteKey(hkGP, pCurGPO->szGPOName);
        }

        //
        // Process list of changed GPOs
        //
        if (ISNONNULL(szCustomDir))
        {
            LPTSTR  pszNum;
            LPTSTR  pszFile;
            TCHAR   szExternalCmdLine[MAX_PATH * 2] = TEXT("");
            LPCTSTR pcszGPOGuidArray[256];
            DWORD   dwIndex;
            BOOL    fResetZones, fImpersonate;

            StrCpy(szTempDir, szCustomDir);
            StrCat(szTempDir, TEXT(".tmp"));

            PathCreatePath(szTempDir);
            PathAppend(szTempDir, TEXT("Custom"));

            pszNum = szTempDir + StrLen(szTempDir);

            // need to impersonate the user when we go over the wire in case admin has
            // disabled/removed read access to GPO for authenticated users group

            fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

            if (!fImpersonate)
            {
                OutD(LI0(TEXT("! Aborting further processing due to user impersonation failure.")));
                dwRet = ERROR_OVERRIDE_NOCHANGES;
                goto End;
            }
            // pass 1: copy all the files to a temp dir and check to make sure everything
            // is in synch

            Out(LI0(TEXT("Starting Internet Explorer group policy processing part 1 (copying files) ...")));
            for (pCurGPO = pChangedGPOList, dwIndex = 0; 
                 (pCurGPO != NULL) && (dwIndex < countof(pcszGPOGuidArray)); 
                 pCurGPO = pCurGPO->pNext)
            {
                TCHAR szBaseDir[MAX_PATH];
                
                if (*pfAbort)
                {
                    OutD(LI0(TEXT("! Aborting further processing due to abort message.")));
                    break;
                }

                OutD(LI1(TEXT("Processing GPO: \"%s\"."), pCurGPO->lpDisplayName));
                OutD(LI1(TEXT("File path is \"%s\"."), pCurGPO->lpFileSysPath));
                PathCombine(szBaseDir, pCurGPO->lpFileSysPath, TEXT("Microsoft\\Ieak\\install.ins"));
                
                if (PathFileExists(szBaseDir))
                {
                    TCHAR szNum[8];
                    TCHAR szFeatureDir[MAX_PATH];
                    BOOL  fResult;

                    PathRemoveFileSpec(szBaseDir);
                    
                    wnsprintf(szNum, countof(szNum), TEXT("%d"), dwIndex);
                    StrCpy(pszNum, szNum);

                    fResult = CreateDirectory(szTempDir, NULL) && CopyFileToDirEx(szBaseDir, szTempDir);

                    // branding files

                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_BRANDING_SUBDIR);
                        
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES, 
                                pepCopyFilesEnumProc, (LPARAM)szTempDir));
                    }

                    // desktop files

                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_DESKTOP_SUBDIR);
                        
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES,
                                pepCopyFilesEnumProc, (LPARAM)szTempDir));
                    }

                    if (!fResult)
                    {
                        Out(LI0(TEXT("! Error copying files. No further processing will be done.")));
                        break;
                    }

                    // check to see if cookie is there before doing anything
                    if (PathFileExistsInDir(IEAK_GPE_COOKIE_FILE, szTempDir))
                        break;

                    pcszGPOGuidArray[dwIndex] = pCurGPO->szGPOName;
                    dwIndex++;
                }
            }

            PathRemoveFileSpec(szTempDir);
                
            Out(LI0(TEXT("Done.\r\n")));

            if (fImpersonate)
                RevertToSelf();

            if (pCurGPO != NULL)
            {
                OutD(LI0(TEXT("! Aborting further processing because GPO replication is incomplete")));
                PathRemovePath(szTempDir);

                dwRet = ERROR_OVERRIDE_NOCHANGES;
                goto End;
            }

            // move all our files to the real custom dir
            if (PathFileExists(szCustomDir))
                PathRemovePath(szCustomDir);

            if (!MoveFileEx(szTempDir, szCustomDir, MOVEFILE_REPLACE_EXISTING))
            {
                Out(LI0(TEXT("! Error copying files. No further processing will be done.")));
                dwRet = ERROR_OVERRIDE_NOCHANGES;
                goto End;
            }

            PathCombine(szInsFile, szCustomDir, TEXT("Custom"));
            pszFile = szInsFile + StrLen(szInsFile);

            // begin clear code
            PCFEATUREINFO pfi;
            DWORD dwBranded;
            UINT  i;
            BOOL  fCrlf;

            Out(LI0(TEXT("Clearing policies set by a previous list of GPOs...")));
            fCrlf = FALSE;
            for (i = FID_FIRST; i < FID_LAST; i++) {
                pfi = g_GetFeature(i);
                ASSERT(NULL != pfi);

                if (NULL == pfi->pfnClear)
                    continue;

                dwBranded = GetFeatureBranded(i);
                if (FF_DISABLE != dwBranded) {
                    if (fCrlf)
                        Out(LI0(TEXT("\r\n")));

                    pfi->pfnClear(dwBranded);
                    fCrlf = TRUE;
                }
            }
            Out(LI0(TEXT("Done.\r\n")));

            fResetZones = (GetFeatureBranded(FID_ZONES_HKCU) != FF_DISABLE);

            SHDeleteKey(g_GetHKCU(), RK_IEAK_BRANDED);
            // end clear code

            // if fResetZones is TRUE set the first char to 'z' to indicate that
            // HKCU zones has to be reset to the default levels in the external branding
            szExternalCmdLine[0] = (fResetZones ? TEXT('z') : TEXT(';'));

            Out(LI0(TEXT("Starting Internet Explorer group policy processing part 2 ...")));

            for (dwIndex=0; ; dwIndex++)
            {
                TCHAR  szCmdLine[MAX_PATH*2 + 32];
                CHAR   szCmdLineA[MAX_PATH*2 + 32];
                TCHAR  szCurrentFile[16];
                TCHAR  szInsKey[MAX_PATH];

                if ( *pfAbort )
                {
                    OutD(LI0(TEXT("! Aborting further processing due to abort message.")));

                    dwRet = ERROR_OVERRIDE_NOCHANGES;
                    goto End;
                }
                
                wnsprintf(szCurrentFile, countof(szCurrentFile), TEXT("%d\\INSTALL.INS"), dwIndex);
                StrCpy(pszFile, szCurrentFile);

                if (!PathFileExists(szInsFile))
                    break;

                if (!IsIE5Ins(T2CA(szInsFile)))
                    break;
                
                // check to see if this is a preference GPO which has already been applied
                // we must be careful about which globals we use since context is in an
                // uninitialized state before we call BrandInternetExplorer

                if (InsKeyExists(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsFile))
                {
                    TCHAR szCheckKey[MAX_PATH];
                    TCHAR szInsGuid[128];

                    // we'll check by checking all the way to the external key, if any keys
                    // before that don't exist(never seen the GPO or ins file) we'll fail
                    // as well

                    InsGetString(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsGuid, countof(szInsGuid), szInsFile);
                    PathCombine(szInsKey, pcszGPOGuidArray[dwIndex], szInsGuid);
                    PathCombine(szCheckKey, szInsKey, RK_IEAK_EXTERNAL);
                    if (SHKeyExists(hkGP, szCheckKey) == S_OK)
                    {
                        OutD(LI0(TEXT("! Skipping preference GPO.")));
                        continue;
                    }
                }
                    
                // always set the GPO guid because adms will need this for both preference
                // and mandate GPOs

                g_SetGPOGuid(pcszGPOGuidArray[dwIndex]);
                    
                constructCmdLine(szCmdLine, countof(szCmdLine), szInsFile, FALSE);

                BrandInternetExplorer(NULL, NULL, T2Abux(szCmdLine, szCmdLineA), 0);

                // set our guid in the registry if this is a preference GPO

                if (g_CtxIs(CTX_MISC_PREFERENCES))
                {
                    HKEY hkIns;

                    // make sure the external key is deleted so we can track whether or not
                    // external branding succeeded

                    if (SHCreateKey(hkGP, szInsKey, KEY_DEFAULT_ACCESS, &hkIns) == ERROR_SUCCESS)
                    {
                        SHDeleteKey(hkIns, RK_IEAK_EXTERNAL);
                        SHCloseKey(hkIns);
                    }
                }

                if (constructCmdLine(NULL, 0, szInsFile, TRUE))
                {
                    TCHAR szIndex[8];

                    wnsprintf(szIndex, countof(szIndex), TEXT("%d"), dwIndex);
                    if (ISNONNULL(&szExternalCmdLine[1]))
                        StrCat(szExternalCmdLine, TEXT(","));
                    else
                    {
                        if (!(g_GetGPOFlags() & GPO_INFO_FLAG_BACKGROUND))
                            szExternalCmdLine[1] = TEXT('*');
                    }
                    StrCat(szExternalCmdLine, szIndex);

                    // write out the GPO guid so the external process can read it and mark it
                    // in the registy

                    InsWriteString(IS_BRANDING, IK_GPO_GUID, pcszGPOGuidArray[dwIndex], szInsFile);
                }
                else if (g_CtxIs(CTX_MISC_PREFERENCES))
                {
                    TCHAR szExternalKey[MAX_PATH];
                    HKEY  hkExternal = NULL;

                    // set the external key as finished
                    
                    PathCombine(szExternalKey, szInsKey, RK_IEAK_EXTERNAL);
                    SHCreateKey(hkGP, szExternalKey, KEY_DEFAULT_ACCESS, &hkExternal);
                    SHCloseKey(hkExternal);
                }
            }

            // flush wininet's thread token so they will get the system HKCU back
            InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

            if (fResetZones || ISNONNULL(&szExternalCmdLine[1]))
            {
                // we need to pass in the target path since we're not using the true app
                // data path

                StrCat(szExternalCmdLine, TEXT("<"));
                StrCat(szExternalCmdLine, szCustomDir);
                // need to do external branding 
                brandExternalHKCUStuff(szExternalCmdLine);

                SetFilePointer(g_hfileLog, 0, NULL, FILE_END);
            }
        }

End:
        SHCloseKey(hkGP);
        displayStatusMessage(pfnStatusCallback);
        Out(LI0(TEXT("Done processing group policy.")));
    }
    __except(TRUE)
    {
        // might want to use except structures eventually to log out better info
#ifdef _DEBUG
        // REVIEW: (andrewgu) this Out, along with LI0 should still be safe. no double GPF should
        // happen.
        Out(LI1(TEXT("!! Exception caught in ProcessGroupPolicyInternal, RSoP is %s."),
                                bRSoP ? _T("enabled") : _T("disabled")));  
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBeep(MB_ICONEXCLAMATION);
#endif
        dwRet = ERROR_OVERRIDE_NOCHANGES;
    }

    g_SetupLog(FALSE);

    // restore what was backed up (if necessary)
    if (TEXT('\0') != szIni[0] && PathFileExists(szIni))
        if (fDeleteIni)
            DeleteFile(szIni);

        else
            if (!InsKeyExists(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni))
                InsDeleteKey(IS_SETTINGS, IK_APPEND, szIni);

            else {
                InsWriteBool(IS_SETTINGS, IK_APPEND,
                    InsGetBool(IS_SETTINGS, TEXT("Was") IK_APPEND, FALSE, szIni), szIni);
                InsDeleteKey(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni);
            }

    return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
// ProcessGroupPolicyEx
// Added 29 Aug 2000 for RSoP Enabling, logging mode - see RSoP.h & .cpp.
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ProcessGroupPolicyEx(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                     PGROUP_POLICY_OBJECT pDeletedGPOList,
PGROUP_POLICY_OBJECT  pChangedGPOList,
ASYNCCOMPLETIONHANDLE pHandle, BOOL *pbAbort,
PFNSTATUSMESSAGECALLBACK pStatusCallback,
IWbemServices *pWbemServices,
HRESULT *pRsopStatus)
{
        DWORD dwRet = ERROR_SUCCESS;
        HRESULT hr = E_FAIL;

        TCHAR szIni[MAX_PATH];
        szIni[0] = TEXT('\0');
        BOOL fDeleteIni = TRUE;
        __try
        {
                MACRO_LI_PrologEx_C(PIF_STD_C, ProcessGroupPolicyEx)

                // first, process group policy through our standard function
                dwRet = ProcessGroupPolicyInternal(dwFlags, hToken, hKeyRoot, pDeletedGPOList,
                                                                                        pChangedGPOList, pHandle, pbAbort,
                                                                                        pStatusCallback,
                                                                                        (NULL == pWbemServices) ? FALSE : TRUE);

                // If ProcessGroupPolicy only completes partially with a partial error, rsop logging
                // should still occur.  TODO: keep track of the sections of policy that were
                // successfully applied, and only log those sections to RSoP.
                if (NULL != pWbemServices)
                {
                        dwRet = ERROR_SUCCESS;
                        TCHAR szCustomDir[MAX_PATH];
                        if (ERROR_SUCCESS == dwRet)
                        {
                                // get our user appdata path (i.e. C:\\Documents and Settins\\User\\Application Data\\Microsoft\\Internet Explorer
                                // BUGBUG: <oliverl> we are currently relying on the fact that g_GetUserToken is not
                                // initialized here because when we pass in the NULL it currently gets the local appdata
                                // path always due to per process shell folder cache.  This might change in the next
                                // rev though if extension order has changed.  We need to do this because of possible
                                // folder redirection of appdata to a UNC path which would bust us since we don't 
                                // impersonate user everywhere we reference appdata files

                                getLogFolder(szCustomDir, countof(szCustomDir), hToken);
                                if (TEXT('\0') == szCustomDir[0])
                                        dwRet = ERROR_OVERRIDE_NOCHANGES;
                        }

                        if (ERROR_SUCCESS == dwRet && *pbAbort)
                        {
                                Out(LI0(TEXT("Aborting further processing in ProcessGroupPolicyEx due to abort message.")));
                                dwRet =  ERROR_OVERRIDE_NOCHANGES; 
                        }

                        if (ERROR_SUCCESS == dwRet)
                        {
                                // set log to append, backup what's there
                                g_SetupLog(TRUE, szCustomDir, TRUE);
                                Out(LI0(TEXT("Processing Group Policy RSoP (logging mode) ...")));

                                // determine if we need to delete the brndlog.ini log file when we're done
                                PathCombine(szIni, szCustomDir, RSOPLOG_INI);
                                fDeleteIni = !PathFileExists(szIni);
                                if (!fDeleteIni && InsKeyExists(IS_SETTINGS, IK_APPEND, szIni))
                                {
                                        InsWriteBool(IS_SETTINGS, TEXT("Was") IK_APPEND,
                                                                                        InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni), szIni);
                                }
                                InsWriteBool(IS_SETTINGS, IK_APPEND, TRUE, szIni);
                        }

                        // RSoP logging enabled
                        if (ERROR_SUCCESS == dwRet)
                        {
                                // Create the RSoPUpdate class and start logging to WMI
                                CRSoPUpdate RSoPUpdate(pWbemServices, szCustomDir);
                                hr = RSoPUpdate.Log(dwFlags, hToken, hKeyRoot, pDeletedGPOList,
                                                                                        pChangedGPOList, pHandle);
                                if (FAILED(hr))
                                {
                                        //TODO: what do we return here?
                                }
                        }

                        Out(LI0(TEXT("Done logging group policy RSoP.")));
                }

                displayStatusMessage(pStatusCallback);
        }
        __except(TRUE)
        {
                        // might want to use except structures eventually to log out better info
#ifdef _DEBUG
                        // REVIEW: (andrewgu) this Out, along with LI0 should still be safe. no double GPF should
                        // happen.
                        Out(LI0(TEXT("!! Exception caught in ProcessGroupPolicyEx.")));  
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
#endif
                        dwRet = ERROR_OVERRIDE_NOCHANGES;
        }

        g_SetupLog(FALSE);

        // restore what was backed up (if necessary)
        if (TEXT('\0') != szIni[0] && PathFileExists(szIni))
        {
                if (fDeleteIni)
                        DeleteFile(szIni);
                else
                {
                        if (!InsKeyExists(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni))
                                InsDeleteKey(IS_SETTINGS, IK_APPEND, szIni);
                        else
                        {
                                InsWriteBool(IS_SETTINGS, IK_APPEND,
                                                                                InsGetBool(IS_SETTINGS, TEXT("Was") IK_APPEND, FALSE, szIni), szIni);
                                InsDeleteKey(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni);
                        }
                }
        }

        *pRsopStatus = hr;
        return dwRet;
}

///////////////////////////////////////////////////////////////////////////////
// ProcessGroupPolicyEx
// Added 29 Aug 2000 for RSoP Enabling, planning mode - see RSoP.h & .cpp.
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI GenerateGroupPolicy(DWORD dwFlags, BOOL *pbAbort, WCHAR *wszSite,
                                                                 PRSOP_TARGET pComputerTarget,
                                                                 PRSOP_TARGET pUserTarget)
{
        DWORD dwRet = ERROR_SUCCESS;

        TCHAR szIni[MAX_PATH];
        szIni[0] = TEXT('\0');
        BOOL fDeleteIni = TRUE;
        __try
        {
                MACRO_LI_PrologEx_C(PIF_STD_C, GenerateGroupPolicy)

                if (NULL != pUserTarget && NULL != pUserTarget->pWbemServices)
                {
                        TCHAR szCustomDir[MAX_PATH];
                        if (ERROR_SUCCESS == dwRet)
                        {
                                // get our user appdata path (i.e. C:\\Documents and Settins\\User\\Application Data\\Microsoft\\Internet Explorer
                                // BUGBUG: <oliverl> we are currently relying on the fact that g_GetUserToken is not
                                // initialized here because when we pass in the NULL it currently gets the local appdata
                                // path always due to per process shell folder cache.  This might change in the next
                                // rev though if extension order has changed.  We need to do this because of possible
                                // folder redirection of appdata to a UNC path which would bust us since we don't 
                                // impersonate user everywhere we reference appdata files

                                // TODO: no hToken passed in, can we use NULL instead?
                                getLogFolder(szCustomDir, countof(szCustomDir), NULL);
                                if (TEXT('\0') == szCustomDir[0])
                                        dwRet = ERROR_OVERRIDE_NOCHANGES;
                        }

                        if (ERROR_SUCCESS == dwRet && *pbAbort)
                        {
                                Out(LI0(TEXT("Aborting further processing in GenerateGroupPolicy due to abort message.")));
                                dwRet =  ERROR_OVERRIDE_NOCHANGES; 
                        }

                        if (ERROR_SUCCESS == dwRet)
                        {
                                // set log to append, backup what's there
                                g_SetupLog(TRUE, szCustomDir, TRUE);
                                Out(LI0(TEXT("Generating Group Policy RSoP (planning) ...")));
                                PathCombine(szIni, szCustomDir, RSOPLOG_INI);

                                // determine if we need to delete the brndlog.ini log file when we're done
                                fDeleteIni = !PathFileExists(szIni);
                                if (!fDeleteIni && InsKeyExists(IS_SETTINGS, IK_APPEND, szIni))
                                {
                                        InsWriteBool(IS_SETTINGS, TEXT("Was") IK_APPEND,
                                                                                        InsGetBool(IS_SETTINGS, IK_APPEND, FALSE, szIni), szIni);
                                }
                                InsWriteBool(IS_SETTINGS, IK_APPEND, TRUE, szIni);

                        }

                        // Create the RSoPUpdate class and start writing planning data to WMI
                        if (ERROR_SUCCESS == dwRet)
                        {
                                CRSoPUpdate RSoPUpdate(pUserTarget->pWbemServices, szCustomDir);
                                HRESULT hr = RSoPUpdate.Plan(dwFlags, wszSite, pComputerTarget,
                                                                                        pUserTarget);
                                if (FAILED(hr))
                                {
                                        //TODO: what do we return here?
                                }
                        }

                        if (ERROR_SUCCESS != dwRet)
                        {
                                Out(LI0(TEXT("Done writing planning information for group policy RSoP.")));
                        }
                }
        }
        __except(TRUE)
        {
                        // might want to use except structures eventually to log out better info
#ifdef _DEBUG
                        // REVIEW: (andrewgu) this Out, along with LI0 should still be safe. no double GPF should
                        // happen.
                        Out(LI0(TEXT("!! Exception caught in GenerateGroupPolicy.")));  
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
                        MessageBeep(MB_ICONEXCLAMATION);
#endif
                        dwRet = ERROR_OVERRIDE_NOCHANGES;
        }

        g_SetupLog(FALSE);

        // restore what was backed up (if necessary)
        if (TEXT('\0') != szIni[0] && PathFileExists(szIni))
        {
                if (fDeleteIni)
                        DeleteFile(szIni);
                else
                {
                        if (!InsKeyExists(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni))
                                InsDeleteKey(IS_SETTINGS, IK_APPEND, szIni);
                        else
                        {
                                InsWriteBool(IS_SETTINGS, IK_APPEND,
                                                                                InsGetBool(IS_SETTINGS, TEXT("Was") IK_APPEND, FALSE, szIni), szIni);
                                InsDeleteKey(IS_SETTINGS, TEXT("Was") IK_APPEND, szIni);
                        }
                }
        }

        return dwRet;
}


// used for branding external features which have no concept of true HKCU in GP

void CALLBACK BrandExternal(HWND, HINSTANCE, LPCSTR pszCmdLineA, int)
{   MACRO_LI_PrologEx_C(PIF_STD_C, BrandExternal)

    LPTSTR pszComma, pszNum, pszEnd, pszPath;
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szInsFile[MAX_PATH];

    USES_CONVERSION;

    if ((pszCmdLineA == NULL) || ISNULL(pszCmdLineA))
        return;

    A2Tbuf(pszCmdLineA, szCmdLine, countof(szCmdLine));

    pszPath = StrChr(szCmdLine, TEXT('<'));

    if (pszPath != NULL) 
    {
        BOOL fSkipRefresh,
             fResetZones;
        
        *pszPath = TEXT('\0');
        pszPath++;
        StrCpy(szInsFile, pszPath);
        PathAppend(szInsFile, TEXT("Custom"));
        pszEnd = szInsFile + StrLen(szInsFile);

        pszComma = szCmdLine;
        
        fResetZones = (*pszComma++ == TEXT('z'));
        
        fSkipRefresh = FALSE;
        if (*pszComma == TEXT('*'))
        {
            pszComma++;
            fSkipRefresh = TRUE;
        }
        
        do
        {
            TCHAR szFile[32];
            TCHAR szInsGuid[128];
            TCHAR szGPOGuid[128];
            CHAR szCurrentCmdLineA[MAX_PATH*2];
            
            pszNum = pszComma;
            pszComma = StrChr(pszNum, TEXT(','));
            
            if (pszComma != NULL)
                *pszComma++ = TEXT('\0');
            
            ASSERT(fResetZones || ISNONNULL(pszNum));
            
            // if only fResetZones is TRUE, we still have to pass an INS to BrandInternetExplorer.
            // any valid INS can be passed -- pick the one in Custom0 folder because it's guaranteed
            // to be there
            wnsprintf(szFile, countof(szFile), TEXT("%s\\install.ins"), ISNONNULL(pszNum) ? pszNum : TEXT("0"));
            StrCpy(pszEnd, szFile);
            wsprintfA(szCurrentCmdLineA, "/mode:gp /ins:\"%s\" /disable /flags:", T2CA(szInsFile));
            
            // BUGBUG: (andrewgu) we should clean this up!
            if (ISNONNULL(pszNum))
                StrCatA(szCurrentCmdLineA, "eriu=0,favo=0,qlo=0,chl=0,chlb=0");
            
            if (fResetZones)
            {
                if (ISNONNULL(pszNum))
                    StrCatA(szCurrentCmdLineA, ",");
                StrCatA(szCurrentCmdLineA, "znu=0");
            }
            
            if (fSkipRefresh)
                StrCatA(szCurrentCmdLineA, ",ref=1");
            
            InsGetString(IS_BRANDING, IK_GPO_GUID, szGPOGuid, countof(szGPOGuid), szInsFile);
            g_SetGPOGuid(szGPOGuid);
            
            if (!IsIE5Ins(T2CA(szInsFile),TRUE))
                continue;

            BrandInternetExplorer(NULL, NULL, szCurrentCmdLineA, 0);
            
            // set the external key for success for this ins if it's a preference GPO
            if (InsGetString(IS_BRANDING, IK_GPE_ONETIME_GUID, szInsGuid, countof(szInsGuid), g_GetIns()))
            {
                TCHAR szKey[MAX_PATH];
                HKEY  hkExternal = NULL;
                
                PathCombine(szKey, RK_IEAK_GPOS, szGPOGuid);
                PathAppend(szKey, szInsGuid);
                PathAppend(szKey, RK_IEAK_EXTERNAL);
                SHCreateKey(g_GetHKCU(), szKey, KEY_DEFAULT_ACCESS, &hkExternal);
                SHCloseKey(hkExternal);
            }
            
            if (fResetZones)
                fResetZones = FALSE;
        } while (pszComma != NULL);
    }
}



static void brandExternalHKCUStuff(LPCTSTR pcszCmdLine)
{
    typedef HANDLE (WINAPI *CREATEJOBOBJECT)(LPSECURITY_ATTRIBUTES, LPCTSTR);
    typedef BOOL (WINAPI *ASSIGNPROCESSTOJOBOBJECT)(HANDLE, HANDLE);
    typedef BOOL (WINAPI *TERMINATEJOBOBJECT)(HANDLE, UINT);
    typedef BOOL (WINAPI *CREATEPROCESSASUSERA)(HANDLE, LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES,
        LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);

    HINSTANCE hKernel32 = NULL;
    HINSTANCE hAdvapi32 = NULL;
    CREATEJOBOBJECT lpfnCreateJobObject = NULL;
    ASSIGNPROCESSTOJOBOBJECT lpfnAssignProcessToJobObject = NULL;
    TERMINATEJOBOBJECT lpfnTerminateJobObject = NULL;
    CREATEPROCESSASUSERA lpfnCreateProcessAsUserA = NULL;

    CHAR  szCmdA[MAX_PATH * 2];
    LPVOID lpEnvironment = NULL;
    HANDLE hJob;
    STARTUPINFOA siA;
    PROCESS_INFORMATION pi;

    USES_CONVERSION;    


    // get all the function ptrs we need

    hKernel32 = LoadLibrary(TEXT("kernel32.dll"));
    hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));

    if ((hKernel32 == NULL) || (hAdvapi32 == NULL))
        goto exit;

    lpfnCreateJobObject = (CREATEJOBOBJECT)GetProcAddress(hKernel32, "CreateJobObjectW");
    lpfnAssignProcessToJobObject = (ASSIGNPROCESSTOJOBOBJECT)GetProcAddress(hKernel32, "AssignProcessToJobObject");
    lpfnTerminateJobObject = (TERMINATEJOBOBJECT)GetProcAddress(hKernel32, "TerminateJobObject");
    
    lpfnCreateProcessAsUserA = (CREATEPROCESSASUSERA)GetProcAddress(hAdvapi32, "CreateProcessAsUserA");

    if ((lpfnCreateJobObject == NULL) || (lpfnAssignProcessToJobObject == NULL) ||
        (lpfnTerminateJobObject == NULL) || (lpfnCreateProcessAsUserA == NULL))
        goto exit;

    // create a job object

    if ((hJob = lpfnCreateJobObject(NULL, TEXT("IEAKJOB"))) != NULL)
    {
        ASSERT(GetLastError() != ERROR_ALREADY_EXISTS);

        // get user environment state

        if (!CreateEnvironmentBlock(&lpEnvironment, g_GetUserToken(), FALSE))
        {
            OutD(LI0(TEXT("! Failed to get user environment. Some of the settings may not get applied.")));
            lpEnvironment = NULL;
        }

        // initialize process startup info

        ZeroMemory (&siA, sizeof(siA));
        siA.cb = sizeof(STARTUPINFOA);
        siA.wShowWindow = SW_SHOWMINIMIZED;
        siA.lpDesktop = "";

        // create the process suspended in the context of the current user

        wsprintfA(szCmdA, "rundll32 iedkcs32.dll,BrandExternal %s", T2CA(pcszCmdLine));

        if (!lpfnCreateProcessAsUserA(g_GetUserToken(), NULL, szCmdA, NULL, NULL, FALSE, 
                CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT, lpEnvironment, NULL, &siA, &pi))
            OutD(LI0(TEXT("! Failed to create user process for externals. Some of the settings may not get applied.")));

        else
        {

            // associate the process with the job so it gets cleaned up nicely
            if (!lpfnAssignProcessToJobObject(hJob, pi.hProcess))
            {
                OutD(LI0(TEXT("! Failed to associate user process to job. Some of the settings may not get applied.")));
                TerminateProcess(pi.hProcess, ERROR_ACCESS_DENIED);
            }
            else
            {
                DWORD dwRes = 0;

                USES_CONVERSION;

                // start the process and wait on it (give a timeout of 2 min. so the user will
                // be logged on eventually if we hang for some reason)
                OutD(LI1(TEXT("Branding externals with command line \"%s\"."), A2CT(szCmdA)));
                ResumeThread(pi.hThread);

                while (1)
                {
                    MSG msg;

                    dwRes = MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, 120000, QS_ALLINPUT);

                    if ((dwRes == WAIT_OBJECT_0) || (dwRes == WAIT_TIMEOUT))
                        break;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                if (dwRes == WAIT_TIMEOUT)
                {
                    lpfnTerminateJobObject(hJob, STATUS_TIMEOUT);
                    OutD(LI0(TEXT("! External process timed out.")));
                }
            }

            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }

        if (lpEnvironment != NULL)
            DestroyEnvironmentBlock(lpEnvironment);

        CloseHandle(hJob);
    }

exit:
    if (hKernel32 != NULL)
        FreeLibrary(hKernel32);

    if (hAdvapi32 != NULL)
        FreeLibrary(hAdvapi32);
}

static BOOL constructCmdLine(LPTSTR pszCmdLine, DWORD cchLen, LPCTSTR pcszInsFile, BOOL fExternal)
{
    BOOL fRun = FALSE;

    // index into global features array of external features which require a separate
    // process(for HKCU)

    static DWORD s_adwExternalFeatures[] = {
        FID_EXTREGINF_HKCU,
        FID_FAV_ORDER,
        FID_QL_ORDER,
        FID_LCY4X_CHANNELS,
        FID_LCY4X_CHANNELBAR
    };

    USES_CONVERSION;

    if (!fExternal)
        wnsprintf(pszCmdLine, cchLen, TEXT("BrandInternetExplorer /mode:gp /ins:\"%s\" /flags:"),
            pcszInsFile);

    for (int i = 0; i < countof(s_adwExternalFeatures); i++)
    {
        PCFEATUREINFO pfi;

        pfi = g_GetFeature(s_adwExternalFeatures[i]);

        if (!fExternal)
        {
            TCHAR szBuf[16];

            fRun = TRUE;
            
            wnsprintf(szBuf, countof(szBuf), TEXT("%s=%d,"), g_mpFeatures[s_adwExternalFeatures[i]].psz, FF_DISABLE);
            StrCat(pszCmdLine, szBuf);
        }
        else if (pfi->pfnApply)
        {
            if (pfi->pfnApply())
                fRun = TRUE;
        }
    }

    if (!fExternal)
        pszCmdLine[StrLen(pszCmdLine)-1] = TEXT('\0');

    return fRun;
}

static void displayStatusMessage(PFNSTATUSMESSAGECALLBACK pfnStatusCallback)
{
    TCHAR   szMessage [MAX_PATH];

    if (pfnStatusCallback == NULL)
        return;

    LoadString(g_GetHinst(), IDS_STATUSMSG, szMessage, countof(szMessage));
    pfnStatusCallback(TRUE, szMessage);
}

static HRESULT pepCopyFilesEnumProc(LPCTSTR pszPath, PWIN32_FIND_DATA pfd, LPARAM lParam, PDWORD *prgdwControl /*= NULL */)
{
    UNREFERENCED_PARAMETER(prgdwControl);
    UNREFERENCED_PARAMETER(pfd);

    // BUGBUG: <oliverl> we should reevaluate this function and make sure we're stopping the
    //         recursion as soon as we fail.  Not doing right now because of code churn

    if (!CopyFileToDirEx(pszPath, (LPCTSTR)lParam))
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <w95wraps.h>
#include <windows.h>
#include <wininet.h>                            // has to come before shlobj.h
#include <urlmon.h>

// NOTE: (andrewgu) this is needed so that shfolder can be dynamically linked. otherwise it
// doesn't compile giving error C2491.
#define _SHFOLDER_
#include <shlobj.h>

#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <advpub.h>
#include <regstr.h>
#include <webcheck.h>

#include "brand.h"
#include <iedkbrnd.h>
#include <ieakutil.h>
#include "defines.h"
#include "globalsr.h"
#include "utils.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\globalsw.h ===
#ifndef _GLOBALSW_H_
#define _GLOBALSW_H_
#include "globalsr.h"

extern TCHAR  g_szModule[];
extern HANDLE g_hBaseDllHandle;

HRESULT g_SetGlobals(PCTSTR pszCmdLine);
HRESULT g_SetGlobals(PCMDLINESWITCHES pcls);

void g_SetHinst(HINSTANCE hInst);

BOOL g_SetHKCU();
void g_SetUserToken(HANDLE hUserToken);
void g_SetGPOFlags(DWORD dwFlags);
void g_SetGPOGuid(LPCTSTR pcszGPOGuid);

BOOL g_IsValidContext();
BOOL g_IsValidIns();
BOOL g_IsValidTargetPath();

BOOL g_IsValidGlobalsSetup();
void g_LogGlobalsInfo();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\favs.h ===
#ifndef __FAVS_H_
#define __FAVS_H_

class CFavorite {
// Constructors
public:
    CFavorite()
        { m_szTitle[0] = m_szUrl[0] = m_szIcon[0] = TEXT('\0'); m_fOffline = FALSE; }

// Operations
public:
    HRESULT Create(IUnknown *punk, ISubscriptionMgr2 *pSubMgr2, LPCTSTR pszPath, LPCTSTR pszIns);

// Properties
public:
    static BOOL m_fMarkIeakCreated;

    TCHAR m_szTitle[MAX_PATH];
    TCHAR m_szUrl  [INTERNET_MAX_URL_LENGTH];
    TCHAR m_szIcon [MAX_PATH];
    BOOL  m_fOffline;

// Implementation
protected:
    virtual BOOL findFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFoundFile = NULL, UINT cchFoundFile = 0);
    virtual BOOL createUniqueFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFile, UINT cchFile = 0);
    virtual void finishSave(LPCTSTR pszTitle, LPCTSTR pszFile);
};


HRESULT CreateInternetShortcut(LPCTSTR pszFavorite, REFIID riid, PVOID *ppv);
DWORD   GetFavoriteIeakFlags(LPCTSTR pszFavorite, IUnknown *punk = NULL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\globalsr.h ===
#ifndef _GLOBALSR_H_
#define _GLOBALSR_H_

// Context values
// NOTE: (andrewgu) <Important in code reviews>
// if you change these values ALWAYS update CTX_XXX_ALL to reflect the new result. otherwise
// g_IsValidContext() may break, and no branding will happen. also if you update these values
// g_XXX() may well be affected (all of them) so don't forget to do the right thing.
#define CTX_UNINITIALIZED      0xFFFFFFFF       // uninitialized

// main entry points
#define CTX_GENERIC            0x00000001       // generic
#define CTX_CORP               0x00000002       // BrandIE4, custom
#define CTX_ISP                0x00000004       // BrandIE4, signup; [IS_BRANDING],IK_TYPE = 1
#define CTX_ICP                0x00000008       // BrandIE4, signup; [IS_BRANDING],IK_TYPE = 0
#define CTX_AUTOCONFIG         0x00000010       // InternetInitializeAutoProxyDll
#define CTX_ICW                0x00000020       // BrandICW, BrandICW2
#define CTX_W2K_UNATTEND       0x00000040       // BrandIntra
#define CTX_INF_AND_OE         0x00000080       // BrandInfAndOutlookExpress
#define CTX_BRANDME            0x00000100       // BrandMe - why it's needed
#define CTX_GP                 0x00000200       // ProcessGroupPolicy
#define CTX_ADMIN_ALL          0x00000252       // (CTX_CORP | CTX_AUTOCONFIG | CTX_W2K_UNATTEND | CTX_GP)
#define CTX_ENTRYPOINT_ALL     0x000003FF       // combination of all above

// signup information
#define CTX_SIGNUP_ICW         0x00010000       // only when CTX_ISP is set
#define CTX_SIGNUP_KIOSK       0x00020000       // only when CTX_ISP is set
#define CTX_SIGNUP_CUSTOM      0x00040000       // only when CTX_ISP is set (aka Serverless)
#define CTX_SIGNUP_NOSIGNUP                     // fake, use !CTX_SIGNUP_ALL
#define CTX_SIGNUP_ALL         0x00070000       // combination of all above

// location of the branding files (in most cases extracted from branding.cab)
#define CTX_FOLDER_INDEPENDENT 0x00100000       // ins file and target folder are independent
#define CTX_FOLDER_CUSTOM      0x00200000       // <ie folder>\custom
#define CTX_FOLDER_SIGNUP      0x00400000       // <ie folder>\signup
#define CTX_FOLDER_INSFOLDER   0x00800000       // folder where ins file lives
#define CTX_FOLDER_ALL         0x00F00000       // combination of all above

// miscellaneous information
#define CTX_MISC_PERUSERSTUB   0x01000000       // run from PerUser stubs
#define CTX_MISC_PREFERENCES   0x02000000       // Prefereneces ins is being processed
#define CTX_MISC_CHILDPROCESS  0x04000000       // running in a child process
#define CTX_MISC_ALL           0x07000000       // combination of all above

// access helpers
#define g_CtxIs(dwFlag)     (HasFlag(g_GetContext(), dwFlag))
#define g_CtxIsCorp()       (g_CtxIs(CTX_CORP))
#define g_CtxIsIsp()        (g_CtxIs(CTX_ISP))
#define g_CtxIsIcp()        (g_CtxIs(CTX_ICP))
#define g_CtxIsAutoconfig() (g_CtxIs(CTX_AUTOCONFIG))
#define g_CtxIsGp()         (g_CtxIs(CTX_GP))


// Feature IDs
#define FID_FIRST                  0
#define FID_CLEARBRANDING          0
#define FID_MIGRATEOLDSETTINGS     1
#define FID_WININETSETUP           2
#define FID_CS_DELETE              3
#define FID_ZONES_HKCU             4
#define FID_ZONES_HKLM             5
#define FID_RATINGS                6
#define FID_AUTHCODE               7
#define FID_PROGRAMS               8
#define FID_EXTREGINF_HKLM         9
#define FID_EXTREGINF_HKCU        10
#define FID_LCY50_EXTREGINF       11
#define FID_GENERAL               12
#define FID_CUSTOMHELPVER         13
#define FID_TOOLBARBUTTONS        14
#define FID_ROOTCERT              15
#define FID_FAV_DELETE            16
#define FID_FAV_MAIN              17
#define FID_FAV_ORDER             18
#define FID_QL_MAIN               19
#define FID_QL_ORDER              20
#define FID_CS_MAIN               21
#define FID_TPL                   23
#define FID_CD_WELCOME            24
#define FID_ACTIVESETUPSITES      25
#define FID_LINKS_DELETE          26
#define FID_OUTLOOKEXPRESS        27
#define FID_LCY4X_ACTIVEDESKTOP   28
#define FID_LCY4X_CHANNELS        29
#define FID_LCY4X_SOFTWAREUPDATES 30
#define FID_LCY4X_WEBCHECK        31
#define FID_LCY4X_CHANNELBAR      32
#define FID_LCY4X_SUBSCRIPTIONS   33
#define FID_REFRESHBROWSER        34
#define FID_LAST                  35

#define FF_INVALID          0xFFFFFFFF
#define FF_ENABLE           0x00000000
#define FF_DISABLE          0x00000001

#define FF_GEN_TITLE         0x00000010
#define FF_GEN_HOMEPAGE      0x00000020
#define FF_GEN_SEARCHPAGE    0x00000040
#define FF_GEN_HELPPAGE      0x00000080
#define FF_GEN_UASTRING      0x00000100
#define FF_GEN_TOOLBARBMP    0x00000200
#define FF_GEN_STATICLOGO    0x00000400
#define FF_GEN_ANIMATEDLOGO  0x00000800
#define FF_GEN_FIRSTHOMEPAGE 0x00001000
#define FF_GEN_TBICONTHEME   0x00002000
#define FF_GEN_ALL           0x00003FF0


// Feature structure
typedef void    (* PFNCLEARFEATURE)(DWORD dwFlags = FF_ENABLE);
typedef BOOL    (* PFNAPPLYFEATURE)();
typedef HRESULT (* PFNPROCESSFEATURE)();

typedef struct tagFEATUREINFO {
    UINT              nID;
    PCTSTR            pszDescription;
    PFNCLEARFEATURE   pfnClear;
    PFNAPPLYFEATURE   pfnApply;
    PFNPROCESSFEATURE pfnProcess;
    PCTSTR            pszInsFlags;
    DWORD             dwFlags;
} FEATUREINFO, *PFEATUREINFO;
typedef const FEATUREINFO *PCFEATUREINFO;


// Read-only access to globals
extern HANDLE g_hfileLog;
extern BOOL   g_fFlushEveryWrite;

HINSTANCE     g_GetHinst();
DWORD         g_GetContext();
PCTSTR        g_GetIns();
PCTSTR        g_GetTargetPath();
HKEY          g_GetHKCU();
HANDLE        g_GetUserToken();
DWORD         g_GetGPOFlags();
LPCTSTR       g_GetGPOGuid();
PCFEATUREINFO g_GetFeature(UINT nID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\favs.cpp ===
#include "precomp.h"
#include <intshcut.h>
#include <shlobjp.h>                            // for IID_INamedPropertyBag only
#include "favs.h"

/////////////////////////////////////////////////////////////////////////////
// CFavorite operations

BOOL CFavorite::m_fMarkIeakCreated = FALSE;

HRESULT CFavorite::Create(IUnknown *punk, ISubscriptionMgr2 *pSubMgr2, LPCTSTR pszPath, LPCTSTR pszIns)
{   MACRO_LI_PrologEx(PIF_STD, CFavorite, Create)

    IUniformResourceLocator *purl;
    IPersistFile            *ppf;
    //INamedPropertyBag       *pnpb;

    TCHAR   szPath[MAX_PATH], szFile[MAX_PATH], szTitle[MAX_PATH],
            szAux[MAX_PATH];
    LPTSTR  pszFileName;
    LPCWSTR pwszFile;
    HRESULT hr;
    DWORD   dwFlags;
    BOOL    fOwnUnknown;

    Out(LI0(TEXT("Determining favorites attributes...")));
    if (m_szTitle[0] == TEXT('\0') || m_szUrl[0] == TEXT('\0'))
        return E_INVALIDARG;

    ASSERT(pszIns != NULL && *pszIns != TEXT('\0'));

    if (pszPath == NULL || !PathIsDirectory(pszPath)) {
        GetFavoritesPath(szPath, countof(szPath));
        if (szPath[0] == TEXT('\0'))
            return STG_E_PATHNOTFOUND;

        ASSERT(PathIsDirectory(szPath));
    }
    else
        StrCpy(szPath, pszPath);

    purl = NULL;
    ppf  = NULL;
    //pnpb = NULL;

    // figure out what the title will be and put it into szTitle
    StrCpy(szAux, m_szTitle);
    DecodeTitle(szAux, pszIns);
    PathRemoveExtension(szAux);

    pszFileName = PathFindFileName(szAux);
    StrCpy(szTitle, pszFileName);               // szTitle has the final title

    // create folders hierarchy (if neccesary), setup szPath
    if (pszFileName > &szAux[0]) {
        ASSERT(!PathIsFileSpec(szAux));

        *(pszFileName - 1) = TEXT('\0');        // replace '\\' with '\0'

        PathAppend(szPath, szAux);
        if (!PathCreatePath(szPath))
            return STG_E_PATHNOTFOUND;
    }

    // figure out what the name of the file will be and put it into szFile
    if (findFile(szPath, szTitle, szFile, countof(szFile))) {

        // NOTE: (andrewgu) special case for favorites coming from a preferences gpo.
        if (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) {
            dwFlags = GetFavoriteIeakFlags(szFile);
            if (HasFlag(dwFlags, 2))
                return E_ACCESSDENIED;
        }
    }
    else
        if (!createUniqueFile(szPath, szTitle, szFile, countof(szFile)))
            return E_FAIL;

    // everything is figured out, lets create this favorite
    fOwnUnknown = FALSE;
    if (punk == NULL) {
        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)&punk);
        if (FAILED(hr))
            return E_UNEXPECTED;

        fOwnUnknown = TRUE;
    }

    // save the url
    hr = punk->QueryInterface(IID_IUniformResourceLocator, (LPVOID *)&purl);
    if (FAILED(hr))
        goto Exit;

    hr = purl->SetURL(m_szUrl, 0);
    if (FAILED(hr))
        goto Exit;

    hr = purl->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto Exit;

    /***
    // BUGBUG: pritobla: there's seems to be some problem with WritePropertyNPB;
    // for the first url created, some junk appears instead of the [Branding] section;
    // should track this down.  But for now, I'm going with WritePrivateProfile function.

    hr = purl->QueryInterface(IID_INamedPropertyBag, (LPVOID *)&pnpb);
    if (FAILED(hr))
        goto Exit;

    // IMPORTANT: WritePropertyNPB/RemovePropertyNPB should be called *before* ppf->Save.
    if (m_fMarkIeakCreated)
    {
        BSTR        bstr;
        PROPVARIANT var = { 0 };

        bstr = SysAllocString(L"1");

        var.vt = VT_BSTR;
        var.bstrVal = bstr;

        pnpb->WritePropertyNPB(L"Branding", L"IEAKCreated", &var);

        SysFreeString(bstr);
    }
    else
        pnpb->RemovePropertyNPB(L"Branding", L"IEAKCreated");
    ***/

    pwszFile = T2CW(szFile);
    hr = ppf->Save(pwszFile, TRUE);
    if (SUCCEEDED(hr)) {
        ppf->SaveCompleted(pwszFile);

        finishSave(szTitle, szFile);

        // BUGBUG: (pritobla) see comments above regarding WritePropertyNPB. when that's fixed,
        // calling InsXxx functions should be deleted.
        if (m_fMarkIeakCreated) {
            dwFlags = 1;
            if (g_CtxIs(CTX_GP) && !g_CtxIs(CTX_MISC_PREFERENCES))
                dwFlags |= 2;

            InsWriteInt(IS_BRANDING, IK_IEAK_CREATED, dwFlags, szFile);
        }
        else
            InsDeleteSection(IS_BRANDING, szFile);
        InsFlushChanges(szFile);

        Out(LI1(TEXT("Title     - \"%s\","), m_szTitle));
        Out(LI1(TEXT("URL       - \"%s\","), m_szUrl));
        if (m_szIcon[0] != TEXT('\0'))
            Out(LI1(TEXT("Icon file - \"%s\","), m_szIcon));
        else
            Out(LI0(TEXT("with a default icon,")));
        Out(LI1(TEXT("%smarked IEAK created,"), m_fMarkIeakCreated ? TEXT("") : TEXT("not ")));

        if (pSubMgr2 != NULL)
        {
            PCWSTR pwszUrl;

            pwszUrl = T2CW(m_szUrl);

            if (m_fOffline)                     // make this favorite available offline
            {
                SUBSCRIPTIONINFO si;
                DWORD dwFlags;

                dwFlags = CREATESUBS_ADDTOFAVORITES | CREATESUBS_FROMFAVORITES | CREATESUBS_NOUI;

                ZeroMemory(&si, sizeof(si));
                si.cbSize       = sizeof(SUBSCRIPTIONINFO);
                si.fUpdateFlags = SUBSINFO_SCHEDULE;
                si.schedule     = SUBSSCHED_MANUAL;

                hr = pSubMgr2->CreateSubscription(NULL, pwszUrl, T2CW(szTitle), dwFlags, SUBSTYPE_URL, &si);
                if (SUCCEEDED(hr))
                {
                    ISubscriptionItem *pSubItem = NULL;

                    hr = pSubMgr2->GetItemFromURL(pwszUrl, &pSubItem);
                    if (SUCCEEDED(hr))
                    {
                        SUBSCRIPTIONCOOKIE sc;

                        hr = pSubItem->GetCookie(&sc);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwState;

                            hr = pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &sc);

                            // NOTE: a better way of finding out if the sync is complete or not is to implement
                            // IOleCommandTarget::Exec(), register the interface GUID to webcheck and delete it
                            // after we are done.  When the sync is complete, webcheck would call IOleCommandTarget::Exec()
                            // notify that it is done.
CheckStatus:
                            dwState = 0;
                            hr = pSubMgr2->GetSubscriptionRunState(1, &sc, &dwState);
                            if (SUCCEEDED(hr))
                            {
                                if (dwState  &&  !(dwState & RS_COMPLETED))
                                {
                                    MSG msg;

                                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                                    {
                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                    }

                                    goto CheckStatus;
                                }
                            }
                        }
                    }

                    if (pSubItem != NULL)
                        pSubItem->Release();
                }
            }
            else
                pSubMgr2->DeleteSubscription(pwszUrl, NULL);

            if (SUCCEEDED(hr))
                Out(LI1(TEXT("%smade available offline"), m_fOffline ? TEXT("") : TEXT("not ")));
            else
            {
                Out(LI1(TEXT("! Making available offline failed with %s."), GetHrSz(hr)));
                hr = S_OK;          // don't care if make available offline fails
            }
        }
    }

Exit:
    if (fOwnUnknown)
        punk->Release();

    //if (pnpb != NULL)
    //    pnpb->Release();

    if (ppf != NULL)
        ppf->Release();

    if (purl != NULL)
        purl->Release();

    Out(LI0(TEXT("Done.")));
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFavorite implementation helper routines

BOOL CFavorite::findFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFoundFile /*= NULL*/, UINT cchFoundFile /*= 0*/)
{
    TCHAR szName[MAX_PATH];
    BOOL  fExists;

    if (pszFoundFile != NULL)
        *pszFoundFile = TEXT('\0');

    if (pszPath == NULL || *pszPath == TEXT('\0')) {
        pszPath = GetFavoritesPath();
        if (pszPath == NULL)
            return FALSE;
    }

    if (pszTitle == NULL || *pszTitle == TEXT('\0'))
        return FALSE;
    ASSERT(PathIsFileSpec(pszTitle));

    PathCombine(szName, pszPath, pszTitle);
    // NOTE: Shouldn't use PathAddExtension because if title contains ".foobar", then the call would fail
    // PathAddExtension(szName, TEXT(".url"));
    StrCat(szName, TEXT(".url"));

    fExists = PathFileExists(szName);
    if (fExists && pszFoundFile != NULL) {
        if (cchFoundFile == 0)
            cchFoundFile = MAX_PATH;

        if (cchFoundFile > (UINT)StrLen(szName))
            StrCpy(pszFoundFile, szName);
    }

    return fExists;
}

BOOL CFavorite::createUniqueFile(LPCTSTR pszPath, LPCTSTR pszTitle, LPTSTR pszFile, UINT cchFile /*= 0*/)
{
    TCHAR szFile[MAX_PATH];

    if (pszFile == NULL)
        return FALSE;
    *pszFile = TEXT('\0');

    if (pszPath == NULL || *pszPath == TEXT('\0')) {
        pszPath = GetFavoritesPath();
        if (pszPath == NULL)
            return FALSE;
    }

    if (pszTitle == NULL || *pszTitle == TEXT('\0'))
        return FALSE;
    ASSERT(PathIsFileSpec(pszTitle));

    PathCombine(szFile, pszPath, pszTitle);
    // NOTE: Shouldn't use PathRenameExtension because if title contains ".foobar", then it would be replaced with ".url"
    // PathRenameExtension(szName, TEXT(".url"));
    StrCat(szFile, DOT_URL);

    if (cchFile == 0)
        cchFile = MAX_PATH;

    if (cchFile > (UINT)StrLen(szFile))
        StrCpy(pszFile, szFile);

    return TRUE;
}

void CFavorite::finishSave(LPCTSTR pszTitle, LPCTSTR pszFile)
{
    UNREFERENCED_PARAMETER(pszTitle);

    if (m_szIcon[0] != TEXT('\0')) {
        WritePrivateProfileString(IS_INTERNETSHORTCUT, IK_ICONINDEX, TEXT("0"), pszFile);
        WritePrivateProfileString(IS_INTERNETSHORTCUT, IK_ICONFILE,  m_szIcon,  pszFile);
    }
}


HRESULT CreateInternetShortcut(LPCTSTR pszFavorite, REFIID riid, PVOID *ppv)
{
    USES_CONVERSION;

    IPersistFile *ppf;
    HRESULT hr;

    ASSERT(pszFavorite != NULL && *pszFavorite != TEXT('\0'));

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto Exit;

    hr = ppf->Load(T2COLE(pszFavorite), STGM_READ | STGM_SHARE_DENY_WRITE);
    if (FAILED(hr))
        goto Exit;

    hr = ppf->QueryInterface(riid, ppv);

Exit:
    if (ppf != NULL)
        ppf->Release();

    return hr;
}

DWORD GetFavoriteIeakFlags(LPCTSTR pszFavorite, IUnknown *punk /*= NULL*/)
{
    INamedPropertyBag *pnpb;
    PROPVARIANT var;
    HRESULT     hr;

    ASSERT(NULL != pszFavorite && TEXT('\0') != *pszFavorite);

    //----- Get INamedPropertyBag on internet shortcut object -----
    if (NULL != punk)
        hr = punk->QueryInterface(IID_INamedPropertyBag, (LPVOID *)&pnpb);
    else
        hr = CreateInternetShortcut(pszFavorite, IID_INamedPropertyBag, (LPVOID *)&pnpb);

    if (FAILED(hr))
        return 0;

    //----- Get special IEAK flags -----
    ZeroMemory(&var, sizeof(var));
    var.vt = VT_UI4;

    hr = pnpb->ReadPropertyNPB(IS_BRANDINGW, IK_IEAK_CREATEDW, &var);
    pnpb->Release();

    return (S_OK == hr) ? var.ulVal : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\globals.cpp ===
#include "precomp.h"
#include "globalsw.h"
#include "clear.h"
#include "apply.h"

#define TYPE_ICP  0
#define TYPE_ISP  1
#define TYPE_CORP 2
#define TYPE_ALL (TYPE_ICP | TYPE_ISP | TYPE_CORP)


// NOTE: (pritobla) g_hBaseDllHandle is used by DelayLoadFailureHook() -- defined in ieakutil.lib
// for more info, read the NOTES in ieak5\ieakutil\dload.cpp
TCHAR     g_szModule[]       = TEXT("iedkcs32.dll");
HINSTANCE g_hInst            = NULL;
HANDLE    g_hBaseDllHandle   = NULL;

TCHAR     g_szIns       [MAX_PATH];
TCHAR     g_szTargetPath[MAX_PATH];
DWORD     g_dwContext        = CTX_UNINITIALIZED;

HANDLE    g_hfileLog         = NULL;
BOOL      g_fFlushEveryWrite = FALSE;

TCHAR     g_szGPOGuid   [MAX_PATH];
HANDLE    g_hUserToken       = NULL;
DWORD     g_dwGPOFlags       = 0;

static FEATUREINFO s_rgfiList[FID_LAST] = {
    //----- Clear previous branding, Prepare to brand features -----
    {
        FID_CLEARBRANDING,
        TEXT("About to clear previous branding..."),
        NULL,                                   // no clear function
        ApplyClearBranding,
        ProcessClearBranding,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_MIGRATEOLDSETTINGS,
        TEXT("Processing migration of old settings..."),
        NULL,                                   // no clear function
        ApplyMigrateOldSettings,
        ProcessMigrateOldSettings,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_WININETSETUP,
        TEXT("Processing wininet setup..."),
        NULL,                                   // no clear function
        ApplyWininetSetup,
        ProcessWininetSetup,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_CS_DELETE,
        TEXT("Processing deletion of connection settings..."),
        NULL,                                   // no clear function
        ApplyConnectionSettingsDeletion,
        ProcessConnectionSettingsDeletion,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_ZONES_HKCU,
        TEXT("Processing zones HKCU settings..."),
        NULL,                                   // no clear function
        ApplyZonesReset,
        ProcessZonesReset,
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_ZONES_HKLM,
        NULL,
        ClearZonesHklm,                         // clear HKLM zones setting
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_RATINGS,
        TEXT("Processing ratings settings..."),
        ClearRatings,
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_AUTHCODE,
        TEXT("Processing authenticode settings..."),
        ClearAuthenticode,
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },
    {
        FID_PROGRAMS,
        NULL,
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        NULL,                                   // no process function
        NULL,                                   // no .ins key
        FF_DISABLE                              // disabled by default
    },

    //----- Main features branding -----
    {
        FID_EXTREGINF_HKLM,
        TEXT("Processing local machine policies and restrictions..."),
        NULL,                                   // no clear function
        ApplyExtRegInfHKLM,
        ProcessExtRegInfSectionHKLM,
        IK_FF_EXTREGINF,
        FF_ENABLE
    },
    {
        FID_EXTREGINF_HKCU,
        TEXT("Processing current user policies and restrictions..."),
        NULL,                                   // no clear function
        ApplyExtRegInfHKCU,
        ProcessExtRegInfSectionHKCU,
        IK_FF_EXTREGINF,
        FF_ENABLE
    },
    {
        FID_LCY50_EXTREGINF,
        TEXT("Processing legacy policies and restrictions..."),
        NULL,                                   // no clear function
        lcy50_ApplyExtRegInf,
        lcy50_ProcessExtRegInfSection,
        IK_FF_EXTREGINF,
        FF_ENABLE
    },
    {
        FID_GENERAL,
        TEXT("Processing general customizations..."),
        ClearGeneral,
        NULL,                                   // no apply function
        ProcessGeneral,
        IK_FF_GENERAL,
        FF_ENABLE
    },
    {
        FID_CUSTOMHELPVER,
        TEXT("Processing Help->About customization..."),
        NULL,                                   // no clear function
        ApplyCustomHelpVersion,
        ProcessCustomHelpVersion,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_TOOLBARBUTTONS,
        TEXT("Processing browser toolbar buttons..."),
        ClearToolbarButtons,
        ApplyToolbarButtons,
        ProcessToolbarButtons,
        IK_FF_TOOLBARBUTTONS,
        FF_ENABLE
    },
    {
        FID_ROOTCERT,
        TEXT("Processing root certificates..."),
        NULL,                                   // no clear function
        ApplyRootCert,
        ProcessRootCert,
        IK_FF_ROOTCERT,
        FF_ENABLE
    },

    //----- Favorites, Quick Links, and Connection Settings -----
    {
        FID_FAV_DELETE,
        TEXT("Processing deletion of favorites and/or quick links..."),
        NULL,                                   // no clear function
        ApplyFavoritesDeletion,
        ProcessFavoritesDeletion,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_FAV_MAIN,
        TEXT("Processing favorites..."),
        ClearFavorites,
        ApplyFavorites,
        ProcessFavorites,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_FAV_ORDER,
        TEXT("Processing ordering of favorites..."),
        NULL,                                   // no clear function
        ApplyFavoritesOrdering,
        ProcessFavoritesOrdering,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_QL_MAIN,
        TEXT("Processing quick links..."),
        NULL,                                   // no clear function
        ApplyQuickLinks,
        ProcessQuickLinks,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_QL_ORDER,
        TEXT("Processing ordering of quick links..."),
        NULL,                                   // no clear function
        ApplyQuickLinksOrdering,
        ProcessQuickLinksOrdering,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_CS_MAIN,
        TEXT("Processing connection settings..."),
        ClearConnectionSettings,
        ApplyConnectionSettings,
        ProcessConnectionSettings,
        NULL,                                   // no .ins key
        FF_ENABLE
    },

    //----- Miscellaneous -----
    {
        FID_TPL,
        TEXT("Processing TrustedPublisherLockdown restriction..."),
        NULL,                                   // no clear function
        ApplyTrustedPublisherLockdown,
        ProcessTrustedPublisherLockdown,
        IK_FF_TPL,
        FF_ENABLE
    },
    {
        FID_CD_WELCOME,
        NULL,
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        ProcessCDWelcome,
        IK_FF_CD_WELCOME,
        FF_ENABLE
    },
    {
        FID_ACTIVESETUPSITES,
        TEXT("Registering download URLs as safe for updating IE..."),
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        ProcessActiveSetupSites,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_LINKS_DELETE,
        TEXT("Deleting links..."),
        NULL,                                   // no clear function
        ApplyLinksDeletion,
        ProcessLinksDeletion,
        NULL,
        FF_ENABLE
    },

    //----- External components (Outlook Express et al.) -----
    {
        FID_OUTLOOKEXPRESS,
        TEXT("Branding Outlook Express..."),
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        ProcessOutlookExpress,
        IK_FF_OUTLOOKEXPRESS,
        FF_ENABLE
    },
    
    //----- Legacy support -----
    {
        FID_LCY4X_ACTIVEDESKTOP,
        TEXT("Processing active desktop customizations..."),
        NULL,                                   // no clear function
        lcy4x_ApplyActiveDesktop,
        lcy4x_ProcessActiveDesktop,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_LCY4X_CHANNELS,
        TEXT("Processing channels and their categories (if any)..."),
        ClearChannels,
        lcy4x_ApplyChannels,
        lcy4x_ProcessChannels,
        IK_FF_CHANNELS,
        FF_ENABLE
    },
    {
        FID_LCY4X_SOFTWAREUPDATES,
        TEXT("Processing software update channels..."),
        NULL,                                   // no clear function
        NULL,                                   // no apply function
        lcy4x_ProcessSoftwareUpdateChannels,
        IK_FF_SOFTWAREUPDATES,
        FF_ENABLE
    },
    {
        FID_LCY4X_WEBCHECK,
        TEXT("Actual processing of channels by calling webcheck.dll \"DllInstall\" API..."),
        NULL,                                   // no clear function
        lcy4x_ApplyWebcheck,
        lcy4x_ProcessWebcheck,
        NULL,                                   // no .ins key
        FF_ENABLE
    },
    {
        FID_LCY4X_CHANNELBAR,
        TEXT("Showing channel bar on the desktop..."),
        NULL,                                   // no clear function
        lcy4x_ApplyChannelBar,
        lcy4x_ProcessChannelBar,
        IK_FF_CHANNELBAR,
        FF_ENABLE
    },
    {
        FID_LCY4X_SUBSCRIPTIONS,
        TEXT("Processing subscriptions..."),
        NULL,                                   // no clear function
        lcy4x_ApplySubscriptions,
        lcy4x_ProcessSubscriptions,
        IK_FF_SUBSCRIPTIONS,
        FF_ENABLE
    },

    //----- Commit new settings -----
    {
        FID_REFRESHBROWSER,
        TEXT("Refreshing browser settings..."),
        NULL,                                   // no clear function
        ApplyBrowserRefresh,
        ProcessBrowserRefresh,
        NULL,                                   // no .ins key
        FF_ENABLE
    }
};

DWORD ctxInitFromIns(PCTSTR pszIns);

DWORD ctxGetFolderFromTargetPath(PCTSTR pszTargetPath, DWORD dwContext = CTX_UNINITIALIZED, PCTSTR pszIns = NULL);
DWORD ctxGetFolderFromEntryPoint(DWORD dwContext, PCTSTR pszIns);
DWORD ctxGetFolderFromIns       (DWORD dwContext = CTX_UNINITIALIZED, PCTSTR pszIns = NULL);


HRESULT g_SetGlobals(PCTSTR pszCmdLine)
{
    CMDLINESWITCHES cls;
    HRESULT hr;

    hr = GetCmdLineSwitches(pszCmdLine, &cls);
    if (FAILED(hr))
        return hr;

    return g_SetGlobals(&cls);
}

HRESULT g_SetGlobals(PCMDLINESWITCHES pcls)
{
    CMDLINESWITCHES cls;
    PCTSTR  pszIE;
    HRESULT hr;
    DWORD   dwAux;
    UINT    i;
    BOOL    fSetIns,
            fSetTargetPath;

    if (pcls == NULL)
        return E_INVALIDARG;
    CopyMemory(&cls, pcls, sizeof(cls));

    pszIE          = GetIEPath();
    hr             = S_OK;
    fSetIns        = FALSE;
    fSetTargetPath = FALSE;

    //----- Validate .ins and targer folder path -----
    // NOTE: (andrewgu) past this section if these two strings are not empty they are valid. also,
    // .ins file is validated to exist, while target folder path doesn't have to exist to be valid.
    
    // BUGBUG: <oliverl> this is a really ugly hack to fix bug 84062 in IE5 database.  
    // Basically what we're doing here is figuring out if this is the external process
    // with only zones reset which doesn't require an ins file.  
    
    if (!HasFlag(pcls->dwContext, CTX_GP) ||
        (g_GetUserToken() != NULL) ||
        (pcls->rgdwFlags[FID_ZONES_HKCU] == 0xFFFFFFFF) ||
        HasFlag(pcls->rgdwFlags[FID_ZONES_HKCU], FF_DISABLE))
    {
        if (TEXT('\0') != cls.szIns[0] && !PathIsValidPath(cls.szIns, PIVP_FILE_ONLY)) {
            hr = E_INVALIDARG;
            goto Fail;
        }
    }
    
    if (TEXT('\0') != cls.szTargetPath[0] && !PathIsValidPath(cls.szTargetPath)) {
        hr = E_INVALIDARG;
        goto Fail;
    }

    //----- Context -----
    // RULE 1: (andrewgu) if context is uninitialized or is one of the values that can be
    // specified through the .ins file, go to the .ins file and figure out the final context
    // value. this means that whatever is in the .ins file can and will overwrite what's specified
    // in the command line.
    if (CTX_UNINITIALIZED == cls.dwContext ||
        HasFlag(cls.dwContext, (CTX_GENERIC | CTX_CORP | CTX_ISP | CTX_ICP))) {

        // RULE 2: (andrewgu) if .ins file is not specified try to assume smart defaults, which
        // is, first if target folder path is specified generate the .ins file by appending
        // install.ins to it. if target folder path is not specified, assume that it's
        // either <ie folder>\signup or <ie folder>\custom (based on whether or not CTX_CORP is
        // set) and proceed with the same algorithm to create the .ins file.
        dwAux = 0;
        if (TEXT('\0') == cls.szIns[0]) {
            if (TEXT('\0') == cls.szTargetPath[0]) {
                if (CTX_UNINITIALIZED == cls.dwContext || HasFlag(cls.dwContext, CTX_GENERIC)) {
                    hr = E_FAIL;
                    goto Fail;
                }

                if (NULL == pszIE) {
                    hr = E_UNEXPECTED;
                    goto Fail;
                }

                PathCombine(cls.szTargetPath, pszIE,
                    !HasFlag(cls.dwContext, CTX_CORP) ? FOLDER_SIGNUP : FOLDER_CUSTOM);

                if (!PathIsValidPath(cls.szTargetPath, PIVP_FOLDER_ONLY)) {
                    hr = STG_E_PATHNOTFOUND;
                    goto Fail;
                }
                fSetTargetPath = TRUE;

                SetFlag(&dwAux,
                    !HasFlag(cls.dwContext, CTX_CORP) ? CTX_FOLDER_SIGNUP : CTX_FOLDER_CUSTOM);
            }

            PathCombine(cls.szIns, cls.szTargetPath, INSTALL_INS);
            if (!PathIsValidPath(cls.szIns, PIVP_FILE_ONLY)) {
                hr = STG_E_FILENOTFOUND;
                goto Fail;                      // no .ins file
            }

            fSetIns = TRUE;
            SetFlag(&dwAux, CTX_FOLDER_INSFOLDER);
        }

        // read in entrypoint (and signup mode, if applicable)
        if (InsKeyExists(IS_BRANDING, IK_TYPE, cls.szIns)) {
            cls.dwContext = ctxInitFromIns(cls.szIns);
            SetFlag(&cls.dwContext, dwAux);
            hr = S_FALSE;
        }
    }

    // RULE 3: (andrewgu) there is actually a whole bunch of rules on how entry point info in the
    // context, .ins file and target folder relate to each other. especially, in cases when only
    // one of .ins file and target folder path is provided. this logic is encupsulated in the
    // helper apis which are pretty self-explanatory. another point is that this relationship is
    // conveyed via CTX_FOLDER_XXX flags in the context.
    if (!fSetTargetPath) {
        if (TEXT('\0') != cls.szTargetPath[0]) {
            dwAux = ctxGetFolderFromTargetPath(cls.szTargetPath, cls.dwContext, cls.szIns);
            if (CTX_UNINITIALIZED == dwAux)
                goto Fail;                      // internal failure
            SetFlag(&cls.dwContext, dwAux);
        }
        else {
            dwAux = ctxGetFolderFromEntryPoint(cls.dwContext, cls.szIns);
            if (CTX_UNINITIALIZED == dwAux)
                goto Fail;                      // not enough info
            SetFlag(&cls.dwContext, dwAux);

            dwAux = ctxGetFolderFromIns(cls.dwContext, cls.szIns);
            if (CTX_UNINITIALIZED != dwAux)
                SetFlag(&cls.dwContext, dwAux);
        }
    }
    else { /* fSetTargetPath */
        ASSERT(TEXT('\0') != cls.szTargetPath[0]);
        ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_INSFOLDER));

        if (HasFlag(cls.dwContext, CTX_CORP)) {
            if (HasFlag(cls.dwContext, CTX_FOLDER_SIGNUP)) {
                hr = E_UNEXPECTED;
                goto Fail;                      // bad combination
            }

            ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM));
        }
        else if (HasFlag(cls.dwContext, (CTX_ISP | CTX_ICP))) {
            if (HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM)) {
                hr = E_UNEXPECTED;
                goto Fail;                      // bad combination
            }

            ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_SIGNUP));
        }
    }

    //----- PerUser flag -----
    if (cls.fPerUser)
        cls.dwContext |= CTX_MISC_PERUSERSTUB;

    //----- .ins file -----
    // RULE 4: (andrewgu) after all context initialization is complete and if .ins file is still
    // empty, this is how it's is finally initialized. note, that target folder path may or may
    // not be used in the process.
    if (TEXT('\0') == cls.szIns[0]) {
        ASSERT(!fSetTargetPath && !fSetIns);
        ASSERT(!HasFlag(cls.dwContext, CTX_FOLDER_INDEPENDENT));

        if (TEXT('\0') != cls.szTargetPath[0]) {
            ASSERT(HasFlag(cls.dwContext, CTX_FOLDER_INSFOLDER));
            PathCombine(cls.szIns, cls.szTargetPath, INSTALL_INS);
        }
        else {
            ASSERT(HasFlag(cls.dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)));

            if (NULL == pszIE)
                goto Fail;                      // can't set .ins file

            PathCombine(cls.szIns, pszIE,
                HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM) ? FOLDER_CUSTOM : FOLDER_SIGNUP);
            PathAppend (cls.szIns, INSTALL_INS);
        }

        hr = S_FALSE;
    }

    //----- Target folder path -----
    // RULE 5: (andrewgu) after all context initialization is complete and if target folder path
    // is still empty, this is how it's is finally initialized. note, that .ins file may or may
    // not be used in the process.
    if (TEXT('\0') == cls.szTargetPath[0]) {
        ASSERT(!fSetTargetPath && !fSetIns);
        ASSERT(!HasFlag(cls.dwContext, CTX_FOLDER_INDEPENDENT));

        if (TEXT('\0') != cls.szIns[0] && HasFlag(cls.dwContext, CTX_FOLDER_INSFOLDER)) {
            StrCpy(cls.szTargetPath, cls.szIns);
            PathRemoveFileSpec(cls.szTargetPath);
        }
        else {
            ASSERT(HasFlag(cls.dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)));

            if (NULL == pszIE)
                goto Fail;                      // can't set .ins file

            PathCombine(cls.szTargetPath, pszIE,
                HasFlag(cls.dwContext, CTX_FOLDER_CUSTOM) ? FOLDER_CUSTOM : FOLDER_SIGNUP);
        }

        hr = S_FALSE;
    }

    //----- Features flags -----
    for (i = 0; i < countof(cls.rgdwFlags); i++) {
        if (0xFFFFFFFF == cls.rgdwFlags[i])
            s_rgfiList[i].dwFlags = (cls.fDisable ? FF_DISABLE : FF_ENABLE);

        else
            s_rgfiList[i].dwFlags = cls.rgdwFlags[i];

        // REVIEW: (andrewgu) i can't estimate how much of a perf hit this is.
        if (FF_ENABLE == s_rgfiList[i].dwFlags && NULL != s_rgfiList[i].pszInsFlags)
            s_rgfiList[i].dwFlags = GetPrivateProfileInt(IS_FF, s_rgfiList[i].pszInsFlags, FF_ENABLE, cls.szIns);
    }

    //----- Tying-everything-together processing -----
    // NOTE: (andrewgu) technically, we can do away with this section and with the settings set
    // here as they all can be derived from some other information. it is still benificial to have
    // these as they increase readability and high-level understanding of the code.
    if (HasFlag(cls.dwContext, CTX_GP) && InsKeyExists(IS_BRANDING, IK_GPE_ONETIME_GUID, cls.szIns))
        SetFlag(&cls.dwContext, CTX_MISC_PREFERENCES);

    if (HasFlag(cls.dwContext, CTX_GP) && NULL == g_GetUserToken())
        SetFlag(&cls.dwContext, CTX_MISC_CHILDPROCESS);

    //----- Set globals -----
    g_dwContext = cls.dwContext;
    StrCpy(g_szIns,        cls.szIns);
    StrCpy(g_szTargetPath, cls.szTargetPath);

    return hr;

Fail:
    if (SUCCEEDED(hr))
        hr = E_FAIL;

    g_dwContext       = CTX_UNINITIALIZED;
    g_szIns[0]        = TEXT('\0');
    g_szTargetPath[0] = TEXT('\0');

    for (i = 0; i < countof(s_rgfiList); i++)
        s_rgfiList[i].dwFlags = FF_DISABLE;

    return hr;
}


void g_SetHinst(HINSTANCE hInst)
{
    g_hInst = hInst;
}

BOOL g_SetHKCU()
{
    typedef LONG (APIENTRY* REGOPENCURRENTUSER)(REGSAM samDesired, PHKEY phkResult);

    REGOPENCURRENTUSER pfnRegOpenCurrentUser;
    HINSTANCE          hAdvapi32Dll;
    BOOL               fResult;

    if (!g_CtxIsGp())
        return FALSE;
    ASSERT(NULL != g_GetUserToken() && IsOS(OS_NT5));

    fResult = ImpersonateLoggedOnUser(g_GetUserToken());
    if (!fResult)
        return FALSE;

    hAdvapi32Dll = LoadLibrary(TEXT("advapi32.dll"));
    if (NULL != hAdvapi32Dll) {
        pfnRegOpenCurrentUser = (REGOPENCURRENTUSER)GetProcAddress(hAdvapi32Dll, "RegOpenCurrentUser");
        if (NULL != pfnRegOpenCurrentUser)
            pfnRegOpenCurrentUser(GENERIC_ALL, &g_hHKCU);

        FreeLibrary(hAdvapi32Dll);
    }

    RevertToSelf();
    return TRUE;
}

void g_SetUserToken(HANDLE hUserToken)
{
    g_hUserToken = hUserToken;
}

void g_SetGPOFlags(DWORD dwFlags)
{
    g_dwGPOFlags = dwFlags;
}

void g_SetGPOGuid(LPCTSTR pcszGPOGuid)
{
    StrCpy(g_szGPOGuid, pcszGPOGuid);
}

HINSTANCE g_GetHinst()
{
    return g_hInst;
}

DWORD g_GetContext()
{
    return g_dwContext;
}

PCTSTR g_GetIns()
{
    return g_szIns;
}

PCTSTR g_GetTargetPath()
{
    return g_szTargetPath;
}

HKEY g_GetHKCU()
{
    return g_hHKCU;
}

HANDLE g_GetUserToken()
{
    return g_hUserToken;
}

DWORD g_GetGPOFlags()
{
    return g_dwGPOFlags;
}

LPCTSTR g_GetGPOGuid()
{
    return g_szGPOGuid;
}

BOOL g_IsValidContext()
{
    BOOL fResult;

    fResult = TRUE;
    if (g_GetContext() == CTX_UNINITIALIZED)
        fResult = FALSE;

    // ASSUMPTIONS: (andrewgu) below are restrictions on each of the CTX_XXX groups.

    // CTX_ENTRYPOINT_ALL: one and only one has to be set
    if (fResult && 1 != GetFlagsNumber(g_GetContext() & CTX_ENTRYPOINT_ALL))
        fResult = FALSE;

    // CTX_SIGNUP_ALL: if set there is only one
    if (fResult && 1 < GetFlagsNumber(g_GetContext() & CTX_SIGNUP_ALL))
        fResult = FALSE;

    // CTX_FOLDER_ALL: either one or two have to be set
    // NOTE: (andrewgu) looking forward i don't see this as something we'll use a lot because in
    // a sense this is redundant information and can easily be derived from elsewhere. plus it's
    // not all that important.
    if (fResult)
        if (2 < GetFlagsNumber(g_GetContext() & CTX_FOLDER_ALL))
            fResult = FALSE;

        else if (2 == GetFlagsNumber(g_GetContext() & CTX_FOLDER_ALL)) {
            if (!HasFlag(g_GetContext(), CTX_FOLDER_INSFOLDER) ||
                !HasFlag(g_GetContext(), (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)))
                fResult = FALSE;
        }
        else
            if (1 != GetFlagsNumber(g_GetContext() & CTX_FOLDER_ALL))
                fResult = FALSE;

    if (!fResult)
        Out(LI0(TEXT("! Fatal internal failure (assumptions about context are incorrect).")));

    return fResult;
}

BOOL g_IsValidIns()
{
    if (!PathIsValidPath(g_GetIns(), PIVP_FILE_ONLY)) {
        Out(LI0(TEXT("! Fatal internal failure (ins file is either invalid or doesn't exist).")));
        return FALSE;
    }

    return TRUE;
}

BOOL g_IsValidTargetPath()
{
    // NOTE: (andrewgu) these are the only cases when we create the target folder ourselves:
    // 1. w2k unattended has it's custom wierd download of the cab file. if it uses that way for
    // getting down the customization files, the folder may not be there yet;
    // 2. a rare case when autoconfig url is provided for a RAS connection, when this connection
    // was setup either by the user or through CTX_ISP before hand.
    if (g_CtxIs(CTX_AUTOCONFIG | CTX_W2K_UNATTEND))
        if (!PathFileExists(g_GetTargetPath()))
            if (PathCreatePath(g_GetTargetPath()))
                Out(LI0(TEXT("Target folder was created successfully!\r\n")));

    if (!PathIsValidPath(g_GetTargetPath(), PIVP_FOLDER_ONLY)) {
        Out(LI0(TEXT("Warning! Target folder is either invalid or doesn't exist.")));
        Out(LI0(TEXT("All customizations requiring additional files will fail!")));
    }

    return TRUE;
}


PCFEATUREINFO g_GetFeature(UINT nID)
{
    if (nID < FID_FIRST || nID >= FID_LAST)
        return NULL;

    return &s_rgfiList[nID];
}


BOOL g_IsValidGlobalsSetup()
{
    // if we're in group policy, then the GPO guid must be nonnull

    return (g_IsValidContext() && g_IsValidIns() && g_IsValidTargetPath() && 
        (!g_CtxIs(CTX_GP) || ISNONNULL(g_szGPOGuid)));
}

void g_LogGlobalsInfo()
{   MACRO_LI_PrologEx_C(PIF_STD_C, g_LogGlobalsInfo)

    static MAPDW2PSZ s_mpFlags[] = {
        { CTX_GENERIC,           TEXT("<generic>")                                  },
        { CTX_CORP,              TEXT("Corporations")                               },
        { CTX_ISP,               TEXT("Internet Service Providers")                 },
        { CTX_ICP,               TEXT("Internet Content Providers")                 },
        { CTX_AUTOCONFIG,        TEXT("Autoconfiguration")                          },
        { CTX_ICW,               TEXT("Internet Connection Wizard")                 },
        { CTX_W2K_UNATTEND,      TEXT("Windows 2000 unattended install")            },
        { CTX_INF_AND_OE,        TEXT("Policies, Restrictions and Outlook Express") },
        { CTX_BRANDME,           TEXT("BrandMe")                                    },
        { CTX_GP,                TEXT("Group Policy")                               },

        { CTX_SIGNUP_ICW,        TEXT("\"Internet Connection Wizard\" type signup") },
        { CTX_SIGNUP_KIOSK,      TEXT("\"Kiosk\" mode signup")                      },
        { CTX_SIGNUP_CUSTOM,     TEXT("\"Custom method\" mode signup")              },

        { CTX_MISC_PERUSERSTUB,  TEXT("running from per-user stub")                 },
        { CTX_MISC_PREFERENCES,  TEXT("preference settings")                        },
        { CTX_MISC_CHILDPROCESS, TEXT("spawned in a child process")                 }
    };

    TCHAR szText[MAX_PATH];
    UINT  i;

    Out(LI0(TEXT("Global branding settings are:")));
    { MACRO_LI_Offset(1);                       // need a new scope

    szText[0] = TEXT('\0');
    for (i = 0; i < countof(s_mpFlags); i++)
        if (HasFlag(s_mpFlags[i].dw, g_GetContext())) {
            if (szText[0] != TEXT('\0'))
                StrCat(szText, TEXT(", "));

            StrCat(szText, s_mpFlags[i].psz);
        }
    Out(LI2(TEXT("Context is (0x%08lX) \"%s\";"), g_GetContext(), szText));

    if ((g_GetContext() & CTX_ENTRYPOINT_ALL) == CTX_AUTOCONFIG) {
        INTERNET_PER_CONN_OPTION_LIST list;
        INTERNET_PER_CONN_OPTION      option;
        PTSTR pszUrl, pszAux;
        DWORD cbList;

        ZeroMemory(&list, sizeof(list));
        list.dwSize        = sizeof(list);
        list.dwOptionCount = 1;
        list.pOptions      = &option;

        ZeroMemory(&option, sizeof(option));
        option.dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

        pszAux = NULL;
        cbList = list.dwSize;
        if (TRUE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &cbList))
            pszAux = option.Value.pszValue;
        pszUrl = pszAux;

        if (pszUrl != NULL && *pszUrl != TEXT('\0')) {
            URL_COMPONENTS uc;

            ZeroMemory(&uc, sizeof(uc));
            uc.dwStructSize    = sizeof(uc);
            uc.dwUrlPathLength = 1;

            if (InternetCrackUrl(pszUrl, 0, 0, &uc))
                if (uc.nScheme == INTERNET_SCHEME_FILE) {
                    // pszUrl should point to \\foo\bar\bar.ins
                    // the below ASSERT explains the case we got here
                    ASSERT(uc.lpszUrlPath != NULL && uc.dwUrlPathLength > 0);
                    pszUrl = uc.lpszUrlPath;
                }

            Out(LI1(TEXT("Autoconfig file is       \"%s\";"), pszUrl));
        }

        if (pszAux != NULL)
            GlobalFree(pszAux);
    }

    Out(LI1(TEXT("Settings file is        \"%s\";"), g_GetIns()));
    Out(LI1(TEXT("Target folder path is   \"%s\"."), g_GetTargetPath()));
    }                                           // end of offset scope

    Out(LI0(TEXT("Done.")));
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

DWORD ctxInitFromIns(PCTSTR pszIns)
{
    DWORD dwResult;
    int   iAux;

    ASSERT(PathIsValidPath(pszIns, PIVP_FILE_ONLY));
    dwResult = CTX_UNINITIALIZED;

    //----- CTX_ISP vs CTX_ICP -----
    // NOTE: (andrewgu) gotta love these hacks! notice how default is TYPE_ICP but if value is
    // messed up we default to TYPE_ISP. this whole thing was introduced because of Netcom IE401.
    iAux  = GetPrivateProfileInt(IS_BRANDING, IK_TYPE, TYPE_ICP, pszIns);
    iAux &= TYPE_ALL;
    if (1 < GetFlagsNumber(iAux))
        iAux = TYPE_ISP;

    if (TYPE_ICP == iAux)
        dwResult = CTX_ICP;

    else if (TYPE_ISP == iAux)
        dwResult = CTX_ISP;

    else if (TYPE_CORP == iAux)
        dwResult = CTX_CORP;

    else
        ASSERT(FALSE);                          // bad usage - wrong assumption!

    if (TYPE_ISP != iAux)
        return dwResult;

    //----- CTX_SIGNUP_XXX (if any) -----
    // NOTE: (andrewgu) this implementation is not very robust. if more than one is present it
    // becomes order dependant.
    iAux = -1;

    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_USEICW, -1, pszIns);
        if (iAux != -1)
            SetFlag(&dwResult, CTX_SIGNUP_ICW);
    }

    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_SERVERKIOSK, -1, pszIns);
        if (iAux != -1)
            SetFlag(&dwResult, CTX_SIGNUP_KIOSK);
    }

    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_SERVERLESS, -1, pszIns);
        if (iAux != -1)
            SetFlag(&dwResult, CTX_SIGNUP_CUSTOM);
    }

#ifdef _DEBUG
    if (iAux == -1) {
        iAux = GetPrivateProfileInt(IS_BRANDING, IK_NODIAL, -1, pszIns);
        ASSERT(iAux != -1);
    }
#endif

    return dwResult;
}


DWORD ctxGetFolderFromTargetPath(PCTSTR pszTargetPath, DWORD dwContext /*= CTX_UNINITIALIZED*/, PCTSTR pszIns /*= NULL*/)
{
    TCHAR  szAux[MAX_PATH];
    PCTSTR pszIE,
           pszAux;
    DWORD  dwResult;

    ASSERT(pszTargetPath != NULL && *pszTargetPath != TEXT('\0') && pszIns != NULL);
    pszIE    = GetIEPath();
    dwResult = CTX_UNINITIALIZED;

    if (NULL != pszIE && PathIsPrefix(pszIE, pszTargetPath)) {
        pszAux = &pszTargetPath[StrLen(pszIE)];
        if (TEXT('\\') == *pszAux) {
            if (0 == StrStrI(pszAux + 1, FOLDER_SIGNUP)) {
                if (HasFlag(dwContext, (CTX_CORP | CTX_AUTOCONFIG | CTX_W2K_UNATTEND)))
                    return dwResult;            // bad combination

                dwResult = CTX_FOLDER_SIGNUP;
            }
            else if (0 == StrStrI(pszAux + 1, FOLDER_CUSTOM)) {
                if (HasFlag(dwContext, (CTX_ISP | CTX_ICP | CTX_ICW | CTX_BRANDME)))
                    return dwResult;            // bad combination

                dwResult = CTX_FOLDER_CUSTOM;
            }
        }
    }

    if (TEXT('\0') != *pszIns) {
        StrCpy(szAux, pszIns);
        PathRemoveFileSpec(szAux);

        dwResult = (0 == StrCmpI(szAux, pszTargetPath)) ? CTX_FOLDER_INSFOLDER : CTX_FOLDER_INDEPENDENT;
    }
    else
        // NOTE: (andrewgu) this is a little confusing. this means "even though .ins file is empty
        // now, when the time comes to set it, it'll be set based on the target folder path." the
        // name will be fixed to install.ins.
        dwResult = CTX_FOLDER_INSFOLDER;

    return dwResult;
}

DWORD ctxGetFolderFromEntryPoint(DWORD dwContext, PCTSTR pszIns /*= NULL*/)
{
    DWORD dwResult;

    dwResult = CTX_UNINITIALIZED;

    switch (dwContext & CTX_ENTRYPOINT_ALL) {
    case CTX_GENERIC:
    case CTX_INF_AND_OE:
    case CTX_GP:
        if (TEXT('\0') == pszIns)
            return dwResult;
        ASSERT(PathIsValidPath(pszIns, PIVP_FILE_ONLY));

        dwResult = CTX_FOLDER_INSFOLDER;
        break;

    case CTX_CORP:
    case CTX_AUTOCONFIG:
    case CTX_W2K_UNATTEND:
        dwResult = CTX_FOLDER_CUSTOM;
        break;

    case CTX_ISP:
    case CTX_ICP:
    case CTX_ICW:
    case CTX_BRANDME:
        dwResult = CTX_FOLDER_SIGNUP;
        break;
    }

    return dwResult;
}

DWORD ctxGetFolderFromIns(DWORD dwContext /*= CTX_UNINITIALIZED*/, PCTSTR pszIns /*= NULL*/)
{
    TCHAR  szAux[MAX_PATH], szAux2[MAX_PATH];
    PCTSTR pszIE;
    DWORD  dwResult;

    ASSERT(NULL != pszIns);
    dwResult = CTX_UNINITIALIZED;

    if (TEXT('\0') != *pszIns) 
    {
        ASSERT(PathIsValidPath(pszIns, PIVP_FILE_ONLY));
        pszIE = GetIEPath();
        if (NULL == pszIE)
            return dwResult;

        StrCpy(szAux, pszIns);
        PathRemoveFileSpec(szAux);

        if (!HasFlag(dwContext, CTX_FOLDER_INSFOLDER)) 
        {
            ASSERT(HasFlag(dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)));

            PathCombine(szAux2, pszIE, HasFlag(dwContext, CTX_FOLDER_CUSTOM) ? FOLDER_CUSTOM : FOLDER_SIGNUP);
            if (0 == StrCmpI(szAux, szAux2))
                dwResult = CTX_FOLDER_INSFOLDER;
        }
        else
            if (!HasFlag(dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP))) 
            {
                PCTSTR pszFolder;

                pszFolder = PathFindFileName(pszIns);  
                int iCompLen;
                if (pszFolder-1 <= pszIns)  //pathfindfilename failed to find a filename
                    iCompLen = StrLen(pszIns);
                else
                    iCompLen = (int)(pszFolder-1 - pszIns);
                if (0 == StrCmpNI(pszIE, pszIns, iCompLen))
                    if (0 == StrCmpI(pszFolder, FOLDER_SIGNUP))
                        dwResult = CTX_FOLDER_SIGNUP;

                    else if (0 == StrCmpI(pszFolder, FOLDER_CUSTOM))
                        dwResult = CTX_FOLDER_CUSTOM;
            }
    }
    else { /* TEXT('\0') == *pszIns */
        // NOTE: (andrewgu) this is a little confusing. this means "even though .ins file is empty
        // now, when the time comes to set it, it'll be set based on the target folder path." this
        // is despite the fact that even target folder path itself may be empty at the moment, but
        // based on the context information it'll be possible to determine its value.
        if (!HasFlag(dwContext, (CTX_FOLDER_CUSTOM | CTX_FOLDER_SIGNUP)))
            return dwResult;

        dwResult = CTX_FOLDER_INSFOLDER;
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\reghash.h ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#define HASH_TABLE_SIZE 97                  // # buckets in hash table
#define STARCOMMAND     TEXT("**Command")   // A special valuename created to keep the commands
//
// List of data values for key registry value in precedence order,
// entries at the beginning of list have higher precedence.
//

typedef struct _REGDATAENTRY {
    BOOL                      bDeleted;        // Is this a deleted value ?
    BOOL                      bAdmPolicy;      // Is this generated by an Adm policy ?
    DWORD                     dwValueType;
    DWORD                     dwDataLen;
    BYTE  *                   pData;
    WCHAR *                   pwszGPO;         // Gpo that set this data
    WCHAR *                   pwszSOM;         // SDOU that the above Gpo is linked to
    WCHAR *                   pwszCommand;     // The actual command that caused the change in data value
    struct _REGDATAENTRY *    pNext;
} REGDATAENTRY, *LPREGDATAENTRY;


//
// List of registry value names under a common registry key
//

typedef struct _REGVALUEENTRY {
    WCHAR *                   pwszValueName;    // Registry value name
    REGDATAENTRY *            pDataList;
    struct _REGVALUEENTRY *   pNext;

} REGVALUEENTRY, *LPREGVALUEENTRY;



//
// List of registry keys that map to same hash bucket
//

typedef struct _REGKEYENTRY {
	BOOL					bHKCU;
    WCHAR *                 pwszKeyName;        // Registry key name
    REGVALUEENTRY *         pValueList;
    struct _REGKEYENTRY *   pNext;
} REGKEYENTRY, *LPREGKEYENTRY;


//
// Hash table for looking up registry keys
//

typedef struct _REGHASHTABLE {
    REGKEYENTRY *   aHashTable[HASH_TABLE_SIZE];
    HRESULT         hrError;
} REGHASHTABLE, *LPREGHASHTABLE;


//
// Registry operation types for deleting and
// adding values.
//

typedef enum _REGOPERATION {
    REG_DELETEVALUE = 0,
    REG_DELETEALLVALUES,
    REG_DELETEKEY,
    REG_ADDVALUE,
    REG_SOFTADDVALUE,
    REG_INTERNAL_DELETESINGLEKEY
} REGOPERATION;

//
// Public methods of hash table: alloc, free and addentry
//

#ifdef __cplusplus
extern "C" {
#endif

REGHASHTABLE * AllocHashTable();

void FreeHashTable( REGHASHTABLE *pHashTable );

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
					  BOOL bHKCU,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand, 
                      BOOL bCreateCommand);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\resource.h ===
#define IDD_DISPLAY 101

#define IDC_STATIC   -1
#define IDC_ANIM   1001

// the ids are out of order because of the localization requirements
#define IDS_SCHED_AUTO             3004
#define IDS_SCHED_DAILY            3005
#define IDS_SCHED_WEEKLY           3006
#define IDS_SCHED_MONTHLY          3007

#define IDS_FOLDER_LINKS           3008
#define IDS_FOLDER_QUICKLAUNCH     3009
#define IDS_FOLDER_CHANNELS        3020
#define IDS_FOLDER_SOFTWAREUPDATES 3021
#define IDS_FOLDER_DESKTOP         3022

#define IDS_IELNK                  3011
#define IDS_HELPSTRING             3012
#define IDS_STATUSMSG              3013
#define IDS_NAME                   3014

#define IDS_ICW_CONNECTTOINTERNET  3031
#define IDS_REG_BARPARENT          3032

#define IDS_FILE_VIEWCHANNELS      3041
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\reghash.cpp ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "precomp.h"

#include "reghash.h"

REGKEYENTRY * AllocRegKeyEntry( BOOL bHKCU, WCHAR *pwszKeyName );
void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry );
REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName );
void FreeValueEntry( REGVALUEENTRY *pValueEntry );
REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand);
                               
void FreeDataEntry( REGDATAENTRY *pDataEntry );
BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
					BOOL bHKCU,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand);
REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable,
								BOOL bHKCU,
								WCHAR *pwszKeyName,
								BOOL bCreate );
REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
								BOOL bHKCU,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate );
BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand);


////////////////////////////////////////////////////////////////////////
// Hash Table for registry policies
// ----------------------------------
//
// This hash table is used to log rsop data for registry policies. 
// A hash table entry is created for each registry entry. The registry entry
// name itself is used to calculate the hash table.
//
// Each Registry entry has a link to each of the values modified by policy.
// These values are in a link list and sorted by the valueNames.
//
// Each Value has the list of Data that are being set on the Values. This 
// sorted by the order of execution. The topmost value will contain the final value.
// The Data entries have fields that mark the value as deleted and the Command 
// associated with the action. To look for the possible commands look in the
// ParseRegistryFile.
// 
// Additionally, in the hash table 2 special case values exist.
//  a.   **Command Value. The Data under this value will contain all the commands 
//                     that are executed under this key.
//
//  b.  An ""(Empty ValueName) This valuename represents the modifications happening
//      to the key itself. For example a key can deleted or added..
//
// Note:
//      The szCommand that is passed in has to be non NULL but can be an empty string.
// There is a dependency on it in AddDataEntry and in logger.cpp. There is an Assert 
// for this in AddRegHashEntry
// 
////////////////////////////////////////////////////////////////////////



//*************************************************************
//
//  AllocHashTable
//
//  Purpose:    Allocates a new hash table
//
//  Returns:    Pointer to hash table
//
//*************************************************************

REGHASHTABLE * AllocHashTable()
{
    DWORD i;

    REGHASHTABLE *pHashTable = (REGHASHTABLE *) LocalAlloc (LPTR, sizeof(REGHASHTABLE));

    if ( pHashTable == NULL ) {
        OutD(LI0(TEXT("AllocHashTable: Failed to alloc hashtable.")));
        return NULL;
    }

    for ( i=0; i<HASH_TABLE_SIZE; i++) {
        pHashTable->aHashTable[i] = 0;
    }

    pHashTable->hrError = S_OK;

    return pHashTable;
}



//*************************************************************
//
//  FreeHashTable
//
//  Purpose:    Deletes a hash table
//
//  Parameters: pHashTable   -  Hash table to delete
//
//*************************************************************

void FreeHashTable( REGHASHTABLE *pHashTable )
{

    DWORD i;

    if ( pHashTable == NULL )
        return;

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {
        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];

        while ( pKeyEntry ) {
            REGKEYENTRY *pNext = pKeyEntry->pNext;
            FreeRegKeyEntry( pKeyEntry );
            pKeyEntry = pNext;
        }
    }
}


//*************************************************************
//
//  AllocRegKey
//
//  Purpose:    Allocates a new registry key entry
//
//  Returns:    Pointer to registr key entry
//
//*************************************************************

REGKEYENTRY * AllocRegKeyEntry( BOOL bHKCU, WCHAR *pwszKeyName )
{
	REGKEYENTRY *pKeyEntry = (REGKEYENTRY *) LocalAlloc (LPTR, sizeof(REGKEYENTRY));
	if ( pKeyEntry == NULL ) {
		OutD(LI0(TEXT("AllocRegKeyEntry: Failed to alloc key entry.")));
		return NULL;
	}

	pKeyEntry->pwszKeyName = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszKeyName) + 1 ) * sizeof(WCHAR));

	if ( pKeyEntry->pwszKeyName == NULL ) {
		OutD(LI0(TEXT("AllocRegKeyEntry: Failed to alloc key name.")));
		LocalFree( pKeyEntry );
		return NULL;
	}

	lstrcpy( pKeyEntry->pwszKeyName, pwszKeyName );

	pKeyEntry->bHKCU = bHKCU;

	return pKeyEntry;
}


//*************************************************************
//
//  FreeRegKeyEntry
//
//  Purpose:    Deletes a registry key entry
//
//  Parameters: pKeyEntry   -  Entry to delete
//
//*************************************************************

void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry )
{
    REGVALUEENTRY *pValueEntry = NULL;

    if ( pKeyEntry == NULL )
        return;

    LocalFree( pKeyEntry->pwszKeyName );

    pValueEntry = pKeyEntry->pValueList;
    while ( pValueEntry ) {
        REGVALUEENTRY *pNext = pValueEntry->pNext;
        FreeValueEntry( pValueEntry );
        pValueEntry = pNext;
    }

    LocalFree( pKeyEntry );
}


//*************************************************************
//
//  AllocValueEntry
//
//  Purpose:    Allocates a new value entry
//
//  Returns:    Pointer to value entry
//
//*************************************************************

REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName )
{
    REGVALUEENTRY *pValueEntry = (REGVALUEENTRY *) LocalAlloc (LPTR, sizeof(REGVALUEENTRY));
    if ( pValueEntry == NULL ) {
        OutD(LI0(TEXT("AllocValueEntry: Failed to alloc value entry.")));
        return NULL;
    }

    pValueEntry->pwszValueName = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszValueName) + 1 ) * sizeof(WCHAR));

    if ( pValueEntry->pwszValueName == NULL ) {
        OutD(LI0(TEXT("AllocValueEntry: Failed to alloc key name.")));
        LocalFree( pValueEntry );
        return NULL;
    }

    lstrcpy( pValueEntry->pwszValueName, pwszValueName );

    return pValueEntry;
}


//*************************************************************
//
//  FreeValueEntry
//
//  Purpose:    Deletes a value entry
//
//  Parameters: pValueEntry   -  Entry to delete
//
//*************************************************************

void FreeValueEntry( REGVALUEENTRY *pValueEntry )
{
    REGDATAENTRY *pDataEntry = NULL;

    if ( pValueEntry == NULL )
        return;

    LocalFree( pValueEntry->pwszValueName );

    pDataEntry = pValueEntry->pDataList;
    while ( pDataEntry ) {
        REGDATAENTRY *pNext = pDataEntry->pNext;
        FreeDataEntry( pDataEntry );
        pDataEntry = pNext;
    }

    LocalFree( pValueEntry );
}



//*************************************************************
//
//  AllocDataEntry
//
//  Purpose:    Allocates a new data entry
//
//  Returns:    Pointer to data entry
//
//*************************************************************

REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand)
{
	UNREFERENCED_PARAMETER(pwszGPO);
	UNREFERENCED_PARAMETER(pwszSOM);

    BOOL bResult = FALSE;

    REGDATAENTRY *pDataEntry = (REGDATAENTRY *) LocalAlloc (LPTR, sizeof(REGDATAENTRY));
    if ( pDataEntry == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc data entry.")));
        return NULL;
    }

    if ( opnType == REG_ADDVALUE )
        pDataEntry->bDeleted = FALSE;
    else
        pDataEntry->bDeleted = TRUE;

    pDataEntry->bAdmPolicy = FALSE;
    pDataEntry->dwValueType = dwType;
    pDataEntry->dwDataLen = dwLen;

    if ( pData ) {
        pDataEntry->pData = (BYTE *) LocalAlloc (LPTR, dwLen);
        if ( pDataEntry->pData == NULL ) {
            OutD(LI0(TEXT("AllocDataEntry: Failed to alloc data.")));
            goto Exit;
        }

        CopyMemory( pDataEntry->pData, pData, dwLen );
    }

/*    pDataEntry->pwszGPO = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszGPO) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszGPO == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc Gpo name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszGPO, pwszGPO );

    pDataEntry->pwszSOM = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszSOM) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszSOM == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszSOM, pwszSOM );
*/
	pDataEntry->pwszGPO = NULL;
	pDataEntry->pwszSOM = NULL;

    pDataEntry->pwszCommand = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszCommand) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszCommand == NULL ) {
        OutD(LI0(TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszCommand, pwszCommand );

    bResult = TRUE;

Exit:

    if ( !bResult ) {
        LocalFree( pDataEntry->pData );
        LocalFree( pDataEntry->pwszGPO );
        LocalFree( pDataEntry->pwszSOM );
        if (pDataEntry->pwszCommand)
            LocalFree(pDataEntry->pwszCommand);
        LocalFree( pDataEntry);
        return NULL;
    }

    return pDataEntry;

}


//*************************************************************
//
//  FreeDataEntry
//
//  Purpose:    Deletes a data entry
//
//  Parameters: pDataEntry   -  Entry to delete
//
//*************************************************************

void FreeDataEntry( REGDATAENTRY *pDataEntry )
{
    if ( pDataEntry )
	{
        LocalFree( pDataEntry->pData );

		if (NULL != pDataEntry->pwszGPO)
			LocalFree( pDataEntry->pwszGPO );
		if (NULL != pDataEntry->pwszSOM)
	        LocalFree( pDataEntry->pwszSOM );
        LocalFree( pDataEntry);
    }
}



//*************************************************************
//
//  Hash
//
//  Purpose:    Maps a key name to a hash bucket
//
//  Parameters: pwszName   -  Key name
//
//  Returns:    Hash bucket
//
//*************************************************************

DWORD Hash( WCHAR *pwszName )
{
    DWORD dwLen = lstrlen( pwszName );
    DWORD dwHashValue = 0;

    for ( ; dwLen>0; pwszName++ ) {
        dwHashValue = toupper(*pwszName) + 31 * dwHashValue;
        dwLen--;
    }

    return dwHashValue % HASH_TABLE_SIZE;
}


//*************************************************************
//
//  AddRegHashEntry
//
//  Purpose:    Adds a registry key to the hash table
//
//  Parameters: pwszName   -  Key name
//
//*************************************************************

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
					  BOOL bHKCU,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand,
                      BOOL   bCreateCommand)
{
	REGVALUEENTRY *pValueEntry = NULL;
    BOOL bResult = FALSE;
	REGKEYENTRY *pKeyEntry=NULL;


	switch (opnType) {

	case REG_DELETEKEY:
		bResult = DeleteRegTree( pHashTable, bHKCU, pwszKeyName, pwszGPO, pwszSOM, szCommand );
		break;
    
	case REG_INTERNAL_DELETESINGLEKEY:
	case REG_DELETEALLVALUES:

		pKeyEntry = FindRegKeyEntry( pHashTable, bHKCU, pwszKeyName, FALSE );
		if ( pKeyEntry == NULL ) {

			//
			// Delete all values is similar to policy being disabled and
			// so do nothing. 
			//

			if (opnType == REG_DELETEALLVALUES)
				break;
			else
				// no command entry in this case.
				return TRUE;
		}

		pValueEntry = pKeyEntry->pValueList;
		while ( pValueEntry ) {

			if (lstrcmp(pValueEntry->pwszValueName, TEXT("")) != 0) {

				if (lstrcmpi(pValueEntry->pwszValueName, STARCOMMAND) != 0) {
            

					//
					// Mark the value as deleted
					//
                
					bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
											pwszGPO, pwszSOM, szCommand );
					if ( !bResult )
						return FALSE;
				}
			}
			else {

				//
				// Mark the key as deleted
				//
            
				if (opnType == REG_INTERNAL_DELETESINGLEKEY) {
					bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
											pwszGPO, pwszSOM, szCommand );
					if ( !bResult )
						return FALSE;
				}                        
			}
        
			pValueEntry = pValueEntry->pNext;
		}

		break;
    
	case REG_ADDVALUE:
	case REG_SOFTADDVALUE:

		//
		// We have to make a value with no name to represent the creation of key itself..
		//

		pValueEntry = FindValueEntry( pHashTable, bHKCU, pwszKeyName, TEXT(""), TRUE );
		if ( pValueEntry == NULL )
			return FALSE;

		bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
								pwszGPO, pwszSOM, szCommand );


		if (!bResult)
			return FALSE;
        
		if ((!pwszValueName) || (!(*pwszValueName)) || 
				(dwDataLen == 0) || (dwType == REG_NONE)) 
			break;                                

	// fall through

	case REG_DELETEVALUE:
		pValueEntry = FindValueEntry( pHashTable, bHKCU, pwszKeyName,
									  pwszValueName, TRUE );
		if ( pValueEntry == NULL )
			return FALSE;


		//
		// In case of SOFTADDVALUE the final decision to add the value is made in
		// AddDataEntry
		//
    
		bResult = AddDataEntry( pValueEntry, opnType, dwType, dwDataLen, pData,
								pwszGPO, pwszSOM, szCommand );

	break;
	default:
		break;
	}


	//
	// If everything succeeded, then log the command if
	// bCreateCommand is true. This is done creating or adding
	// to a value called **Command. This means that this value is not
	// Settable by adm file..
	//

	if ((bResult) && (bCreateCommand) && (opnType != REG_INTERNAL_DELETESINGLEKEY) && (*szCommand != TEXT('\0'))) {
		pValueEntry = FindValueEntry( pHashTable, bHKCU, pwszKeyName, STARCOMMAND, TRUE );
                                  
		if ( pValueEntry == NULL )
			return FALSE;

		bResult = AddDataEntry( pValueEntry, REG_ADDVALUE, 0, 
								sizeof(TCHAR)*(lstrlen(szCommand)+1), (BYTE *)szCommand,
								pwszGPO, pwszSOM, szCommand);    
	}

	return bResult;
}


//*************************************************************
//
//  DeleteRegTree
//
//  Purpose:    Deletes a key and all its subkeys
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to delete
//              pwszGPO      -   Gpo
//              pwszSOM      -   Sdou that the Gpo is linked to
//
//*************************************************************

BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
					BOOL bHKCU,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand)
{
    DWORD i=0;
    DWORD dwKeyLen = lstrlen( pwszKeyName );

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {

        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
        while ( pKeyEntry ) {

            BOOL bAdd = FALSE;
            DWORD dwKeyLen2  = lstrlen(pKeyEntry->pwszKeyName);

            if ( dwKeyLen2 >= dwKeyLen
				&& CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   pKeyEntry->pwszKeyName, dwKeyLen,
                                   pwszKeyName, dwKeyLen ) == CSTR_EQUAL
				&& bHKCU == pKeyEntry->bHKCU) {

                //
                // It's a prefix if length and strings match, or if one
                // string is bigger and there is a '\' at the right place.
                //

                if ( dwKeyLen2 > dwKeyLen ) {

                    if ( pKeyEntry->pwszKeyName[dwKeyLen] == L'\\' ) 
                        bAdd = TRUE;
                } else
                    bAdd = TRUE;

                if ( bAdd ) {
                    BOOL bResult = AddRegHashEntry( pHashTable,
                                                    REG_INTERNAL_DELETESINGLEKEY,
													bHKCU, pKeyEntry->pwszKeyName,
                                                    NULL, 0, 0, NULL,
                                                    pwszGPO, pwszSOM, szCommand, FALSE );
                    if ( !bResult )
                        return FALSE;
                }

            }   // if dwKeyLen2 >= dwKeyLen

            pKeyEntry = pKeyEntry->pNext;

        }   // while

    }   // for

    return TRUE;
}


//*************************************************************
//
//  FindRegKeyEntry
//
//  Purpose:    Looks up a reg key entry in hash table
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to find
//              bCreate      -   Should key be created if not found ?
//
//*************************************************************

REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable, BOOL bHKCU,
								WCHAR *pwszKeyName, BOOL bCreate )
{
    DWORD dwHashValue = Hash( pwszKeyName );

    REGKEYENTRY *pCurPtr = pHashTable->aHashTable[dwHashValue];
    REGKEYENTRY *pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszKeyName, -1,
                                     pCurPtr->pwszKeyName, -1 );

        if ( iResult == CSTR_EQUAL && bHKCU == pCurPtr->bHKCU) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( bHKCU, pwszKeyName );
                if ( pKeyEntry == NULL )
                    return 0;

                pKeyEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pHashTable->aHashTable[dwHashValue] = pKeyEntry;
                else
                    pTrailPtr->pNext = pKeyEntry;

                return pKeyEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {
        REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( bHKCU, pwszKeyName );
        if ( pKeyEntry == NULL )
            return 0;

        pKeyEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pHashTable->aHashTable[dwHashValue] = pKeyEntry;
        else
            pTrailPtr->pNext = pKeyEntry;

        return pKeyEntry;
    }

    return NULL;
}


//*************************************************************
//
//  FindValueEntry
//
//  Purpose:    Looks up a value entry in hash table
//
//  Parameters: pHashTable    -   Hash table
//              pwszKeyName   -   Key name to find
//              pwszValueName -   Value name to find
//              bCreate       -   Should key be created if not found ?
//
//*************************************************************

REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
								BOOL bHKCU,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate )
{
    REGVALUEENTRY *pCurPtr = NULL;
    REGVALUEENTRY *pTrailPtr = NULL;

    REGKEYENTRY *pKeyEntry = FindRegKeyEntry( pHashTable, bHKCU, pwszKeyName, bCreate );
    if ( pKeyEntry == NULL )
        return NULL;

    pCurPtr = pKeyEntry->pValueList;
    pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszValueName, -1,
                                     pCurPtr->pwszValueName, -1 );

        if ( iResult  == CSTR_EQUAL ) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
                if ( pValueEntry == NULL )
                    return 0;

                pValueEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pKeyEntry->pValueList = pValueEntry;
                else
                    pTrailPtr->pNext = pValueEntry;

                return pValueEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {

        REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
        if ( pValueEntry == NULL )
            return 0;

        pValueEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pKeyEntry->pValueList = pValueEntry;
        else
            pTrailPtr->pNext = pValueEntry;

        return pValueEntry;
    }

    return NULL;
}



//*************************************************************
//
//  AddDataEntry
//
//  Purpose:    Adds a data entry to a value entry struct
//
//  Parameters: pValueEntry   - Value entry
//              opnType       - Operation type
//              dwType        - Type of registry data
//              dwLen         - Length of registry data
//              pData         - Data
//              pwszGPO       - Gpo that set this value
//              pwszSOM       - Sdou that the Gpo is linked to
//
//*************************************************************

BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand)
{
    REGDATAENTRY *pDataEntry = NULL; 

    if (opnType == REG_SOFTADDVALUE) {

        //
        // if the data list is null or if the first value (highest precedence value is deleted)
        // then add it to the list
        //
        
        if ((pValueEntry->pDataList == NULL) || (pValueEntry->pDataList->pNext->bDeleted))         
            opnType = REG_ADDVALUE;
        else
            return TRUE;
            // return without adding the value.
    }


    pDataEntry = AllocDataEntry( opnType, dwType, dwLen, pData,
									pwszGPO, pwszSOM, pwszCommand );
    if ( pDataEntry == NULL )
        return FALSE;
    
    //
    // Prepend to data list because entries at beginning of list have higher precedence
    //

    pDataEntry->pNext = pValueEntry->pDataList;
    pValueEntry->pDataList = pDataEntry;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\rsop.h ===
// Interface for RSoPUpdate class

#ifndef __IEAK_BRANDING_RSOP_H__
#define __IEAK_BRANDING_RSOP_H__

#include <userenv.h>

#include <setupapi.h>
#include "wbemcli.h"
#include <ras.h>
#include "reghash.h"

#include "SComPtr.h"



// defines
#define MAX_GUID_LENGTH 40

typedef struct _ADMFILEINFO {
    WCHAR *               pwszFile;            // Adm file path
    WCHAR *               pwszGPO;             // Gpo that the adm file is in
    FILETIME              ftWrite;             // Last write time of Adm file
    struct _ADMFILEINFO * pNext;               // Singly linked list pointer
} ADMFILEINFO;


///////////////////////////////////////////////////////////////////////////////
// Flags for GetWBEMObject
#define OPENRSOPOBJ_OPENEXISTING		0x00000000
#define OPENRSOPOBJ_NEVERCREATE			0x00000001
#define OPENRSOPOBJ_ALWAYSCREATE		0x00000010

///////////////////////////////////////////////////////////////////////////////
class CRSoPGPO
{
public:
	CRSoPGPO(ComPtr<IWbemServices> pWbemServices, LPCTSTR szINSFile);
	virtual ~CRSoPGPO();

// operations
public:
	HRESULT LogPolicyInstance(LPWSTR wszGPO, LPWSTR wszSOM,
								DWORD dwPrecedence);

private:
	// Text file functions
	BOOL GetInsString(LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue,
						DWORD dwValueLen, BOOL &bEnabled);
	BOOL GetInsBool(LPCTSTR szSection, LPCTSTR szKey, BOOL bDefault, BOOL *pbEnabled = NULL);
	UINT GetInsInt(LPCTSTR szSection, LPCTSTR szKey, INT nDefault, BOOL *pbEnabled = NULL);
	BOOL GetINFStringField(PINFCONTEXT pinfContext, LPCTSTR szFileName,
							 LPCTSTR szSection, DWORD dwFieldIndex,
							 LPCTSTR szFieldSearchText, LPTSTR szBuffer,
							 DWORD dwBufferLen, BOOL &bFindNextLine);
	HRESULT StoreStringArrayFromIniFile(LPCTSTR szSection, LPCTSTR szKeyFormat,
										ULONG nArrayInitialSize, ULONG nArrayIncSize,
										LPCTSTR szFile, BSTR bstrPropName,
										ComPtr<IWbemClassObject> pWbemObj);


	// Property putting & getting
	HRESULT PutWbemInstanceProperty(BSTR bstrPropName, _variant_t vtPropValue);
	HRESULT PutWbemInstancePropertyEx(BSTR bstrPropName, _variant_t vtPropValue,
																		ComPtr<IWbemClassObject> pWbemClass);
	HRESULT PutWbemInstance(ComPtr<IWbemClassObject> pWbemObj,
													BSTR bstrClassName, BSTR *pbstrObjPath);

	// Object creation, deletion, retrieval
	HRESULT CreateAssociation(BSTR bstrAssocClass, BSTR bstrProp2Name,
														BSTR bstrProp2ObjPath);
	HRESULT CreateRSOPObject(BSTR bstrClass,
							IWbemClassObject **ppResultObj,
							BOOL bTopObj = FALSE);


	// -------------------- Methods which write data to WMI
	// Precedence Mode
	HRESULT StorePrecedenceModeData();

	// Browser UI settings
	HRESULT StoreDisplayedText();
	HRESULT StoreBitmapData();

			// toolbar buttons
	HRESULT StoreToolbarButtons(BSTR **ppaTBBtnObjPaths, long &nTBBtnCount);
	HRESULT CreateToolbarButtonObjects(BSTR **ppaTBBtnObjPaths,
										long &nTBBtnCount);

	// Connection settings
	HRESULT StoreConnectionSettings(BSTR *bstrConnSettingsObjPath,
									BSTR **ppaDUSObjects, long &nDUSCount,
									BSTR **ppaDUCObjects, long &nDUCCount,
									BSTR **ppaWSObjects, long &nWSCount);
	HRESULT StoreAutoBrowserConfigSettings(ComPtr<IWbemClassObject> pCSObj);
	HRESULT StoreProxySettings(ComPtr<IWbemClassObject> pCSObj);
	HRESULT ProcessAdvancedConnSettings(ComPtr<IWbemClassObject> pCSObj,
										BSTR **ppaDUSObjects, long &nDUSCount,
										BSTR **ppaDUCObjects, long &nDUCCount,
										BSTR **ppaWSObjects, long &nWSCount);
	HRESULT ProcessRasCS(PCWSTR pszNameW, PBYTE *ppBlob, LPRASDEVINFOW prdiW,
						UINT cDevices, ComPtr<IWbemClassObject> pCSObj,
						BSTR *pbstrConnDialUpSettingsObjPath);
	HRESULT ProcessRasCredentialsCS(PCWSTR pszNameW, PBYTE *ppBlob,
									ComPtr<IWbemClassObject> pCSObj,
									BSTR *pbstrConnDialUpCredObjPath);
	HRESULT ProcessWininetCS(PCWSTR pszNameW, PBYTE *ppBlob,
							ComPtr<IWbemClassObject> pCSObj,
							BSTR *pbstrConnWinINetSettingsObjPath);

	// URL settings
	HRESULT StoreCustomURLs();

			// favorites & links
	HRESULT StoreFavoritesAndLinks(BSTR **ppaFavObjPaths,
									long &nFavCount,
									BSTR **ppaLinkObjPaths,
									long &nLinkCount);
	HRESULT CreateFavoriteObjects(BSTR **ppaFavObjPaths, long &nFavCount);
	HRESULT CreateLinkObjects(BSTR **ppaLinkObjPaths, long &nLinkCount);

			// channels & categories
	HRESULT StoreChannelsAndCategories(BSTR **ppaCatObjPaths,
										long &nCatCount,
										BSTR **ppaChnObjPaths,
										long &nChnCount);
	HRESULT CreateCategoryObjects(BSTR **ppaCatObjPaths, long &nCatCount);
	HRESULT CreateChannelObjects(BSTR **ppaChnObjPaths, long &nChnCount);

	// Security settings
	HRESULT StoreSecZonesAndContentRatings();
	HRESULT StoreZoneSettings(LPCTSTR szRSOPZoneFile);
	HRESULT StorePrivacySettings(LPCTSTR szRSOPZoneFile);
	HRESULT StoreRatingsSettings(LPCTSTR szRSOPRatingsFile);
	HRESULT StoreAuthenticodeSettings();
	HRESULT StoreCertificates();

	// Program settings
	HRESULT StoreProgramSettings(BSTR *pbstrProgramSettingsObjPath);

	// Advanced settings
	HRESULT StoreADMSettings(LPWSTR wszGPO, LPWSTR wszSOM);
	BOOL LogRegistryRsopData(REGHASHTABLE *pHashTable, LPWSTR wszGPOID, LPWSTR wszSOMID);
	BOOL LogAdmRsopData(ADMFILEINFO *pAdmFileCache);

// attributes
private:
	// Keep copies of RSOP_PolicySetting key info to use as foreign keys in other
	// classes
	DWORD m_dwPrecedence;
	_bstr_t m_bstrID;

// implementation
private:
	ComPtr<IWbemServices> m_pWbemServices;
	TCHAR m_szINSFile[MAX_PATH];

	// MOF class-specific info
	ComPtr<IWbemClassObject> m_pIEAKPSObj;
	BSTR m_bstrIEAKPSObjPath;
};

///////////////////////////////////////////////////////////////////////////////
class CRSoPUpdate
{
public:
	CRSoPUpdate(ComPtr<IWbemServices> pWbemServices, LPCTSTR szCustomDir);
	virtual ~CRSoPUpdate();

// operations
public:
	HRESULT Log(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
				PGROUP_POLICY_OBJECT pDeletedGPOList,
				PGROUP_POLICY_OBJECT  pChangedGPOList,
				ASYNCCOMPLETIONHANDLE pHandle);
	HRESULT Plan(DWORD dwFlags, WCHAR *wszSite,
					PRSOP_TARGET pComputerTarget, PRSOP_TARGET pUserTarget);

// attributes
// implementation
private:
	HRESULT DeleteIEAKDataFromNamespace();
	HRESULT DeleteObjects(BSTR bstrClass);

	ComPtr<IWbemServices> m_pWbemServices;
	TCHAR m_szCustomDir[MAX_PATH];
};



#endif //__IEAK_BRANDING_RSOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\rsop.cpp ===
#include "precomp.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"

#include <atlbase.h>

#include "btoolbar.h"
#include "ieaksie.h"

extern PFNPATHENUMPATHPROC GetPepCopyFilesEnumProc();

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
// Extra Logging function
#define LI4(pszFormat, arg1, arg2, arg3, arg4)                              \
    g_li.Log(__LINE__, pszFormat, arg1, arg2, arg3, arg4)                   \

#define IK_PATH          TEXT("Path")

///////////////////////////////////////////////////////////////////////////////
// References to variables & functions


///////////////////////////////////////////////////////////////////////////////
// CRSoPGPO CLASS
///////////////////////////////////////////////////////////////////////////////
CRSoPGPO::CRSoPGPO(ComPtr<IWbemServices> pWbemServices, LPCTSTR szINSFile):
    m_pWbemServices(pWbemServices),
    m_pIEAKPSObj(NULL),
    m_dwPrecedence(0),
    m_bstrIEAKPSObjPath(NULL)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CRSoPGPO)
    __try
    {
        StrCpy(m_szINSFile, szINSFile);
    }
    __except(TRUE)
    {
    }
}

CRSoPGPO::~CRSoPGPO()
{
    __try
    {
        if (NULL != m_bstrIEAKPSObjPath)
            SysFreeString(m_bstrIEAKPSObjPath);
    }
    __except(TRUE)
    {
    }
}

///////////////////////////////////////////////////////////
BOOL CRSoPGPO::GetInsString(LPCTSTR szSection, LPCTSTR szKey,
                            LPTSTR szValue, DWORD dwValueLen,
                            BOOL &bEnabled)
{
    BOOL bRet = FALSE;
    __try
    {
        bEnabled = FALSE;
        bRet = InsGetString(szSection, szKey, szValue, dwValueLen, m_szINSFile,
                            NULL, &bEnabled);
        OutD(LI3(TEXT("Value read from INS >> %s >> %s = %s."),
                                    szSection, szKey, szValue));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetInsString.")));
    }
    return bRet;
}

///////////////////////////////////////////////////////////
BOOL CRSoPGPO::GetInsBool(LPCTSTR szSection, LPCTSTR szKey, BOOL bDefault,
                          BOOL *pbEnabled /*= NULL*/)
{
    BOOL bRet = FALSE;
    __try
    {
        BOOL bEnabled = FALSE;
        if (NULL != pbEnabled)
            bEnabled = InsKeyExists(szSection, szKey, m_szINSFile);
        else
            bEnabled = TRUE;

        if (bEnabled)
        {
            bRet = InsGetBool(szSection, szKey, bDefault, m_szINSFile);
            OutD(LI3(TEXT("Value read from INS >> %s >> %s = %d."),
                                        szSection, szKey, bRet));
        }

        if (NULL != pbEnabled)
            *pbEnabled = bEnabled;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetInsBool.")));
    }
    return bRet;
}

///////////////////////////////////////////////////////////
UINT CRSoPGPO::GetInsInt(LPCTSTR szSection, LPCTSTR szKey, INT nDefault,
                         BOOL *pbEnabled /*= NULL*/)
{
    UINT nRet = FALSE;
    __try
    {
        BOOL bEnabled = FALSE;
        if (NULL != pbEnabled)
            bEnabled = InsKeyExists(szSection, szKey, m_szINSFile);
        else
            bEnabled = TRUE;

        if (bEnabled)
        {
            nRet = InsGetInt(szSection, szKey, nDefault, m_szINSFile);
            OutD(LI3(TEXT("Value read from INS >> %s >> %s = %ld."),
                                        szSection, szKey, nRet));
        }

        if (NULL != pbEnabled)
            *pbEnabled = bEnabled;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetInsInt.")));
    }
    return nRet;
}

///////////////////////////////////////////////////////////
BOOL CRSoPGPO::GetINFStringField(PINFCONTEXT pinfContext, LPCTSTR szFileName,
                                 LPCTSTR szSection, DWORD dwFieldIndex,
                                 LPCTSTR szFieldSearchText, LPTSTR szBuffer,
                                 DWORD dwBufferLen, BOOL &bFindNextLine)
{
    BOOL bRet = FALSE;
    __try
    {
        TCHAR szLineBuffer[512];
        DWORD dwRequiredSize = 0;
        if (SetupGetLineText(pinfContext, NULL, NULL, NULL, szLineBuffer,
                                                countof(szLineBuffer), &dwRequiredSize))
        {
            // If the search text is not found in this line, the line is not the one
            // the caller was expecting.  Don't return the next line in the context
            // because the current line hasn't been processed yet.
            if (NULL == szFieldSearchText || NULL != StrStr(szLineBuffer, szFieldSearchText))
            {
                if ((DWORD)-1 == dwFieldIndex) // -1 means get the whole line
                {
                    StrCpyN(szBuffer, szLineBuffer, dwBufferLen - 1);
                    szBuffer[dwBufferLen - 1] = _T('\0');

                    OutD(LI4(TEXT("Line read from %s >> [%s] >> %s = %s."),
                                                szFileName, szSection, szFieldSearchText, szBuffer));

                    bRet = TRUE;

                    if (bFindNextLine)
                        bFindNextLine = SetupFindNextLine(pinfContext, pinfContext) ? TRUE : FALSE;
                }
                else
                {
                    dwRequiredSize = 0;
                    if (SetupGetStringField(pinfContext, dwFieldIndex, szBuffer, dwBufferLen,
                                            &dwRequiredSize))
                    {
                        OutD(LI4(TEXT("Value read from %s >> [%s] >> %s = %s."),
                                    szFileName, szSection, szFieldSearchText, szBuffer));
                        bRet = TRUE;

                        // This is the expected line and the value was retrieved, move on to
                        // the next line.
                        if (bFindNextLine)
                            bFindNextLine = SetupFindNextLine(pinfContext, pinfContext) ? TRUE : FALSE;
                    }
                    else
                        OutD(LI1(TEXT("SetupGetStringField failed, requiring size of %lu"), dwRequiredSize));
                }
            }
            else
            {
                // do nothing - this isn't the line the caller was expecting
            }
        }
        else
            OutD(LI1(TEXT("SetupGetLineText failed, requiring size of %lu"), dwRequiredSize));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in GetINFStringField.")));
    }

    return bRet;
}


///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::PutWbemInstanceProperty(BSTR bstrPropName, _variant_t vtPropValue)
{
    HRESULT hr = NOERROR;
    __try
    {
        hr = m_pIEAKPSObj->Put(bstrPropName, 0, &vtPropValue, 0);
        if (FAILED(hr))
            OutD(LI2(TEXT("Error %lx setting the class instance value for property: '%s'."), hr, bstrPropName));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in PutWbemInstanceProperty.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::PutWbemInstancePropertyEx(BSTR bstrPropName, _variant_t vtPropValue,
                                            ComPtr<IWbemClassObject> pWbemClass)
{
    HRESULT hr = NOERROR;
    __try
    {
        hr = pWbemClass->Put(bstrPropName, 0, &vtPropValue, 0);
        if (FAILED(hr))
            OutD(LI2(TEXT("Error %lx setting the class instance (ex) value for property: '%s'."), hr, bstrPropName));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in PutWbemInstancePropertyEx.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::PutWbemInstance(ComPtr<IWbemClassObject> pWbemObj,
                                  BSTR bstrClassName, BSTR *pbstrObjPath)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, PutWbemInstance)
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI1(TEXT("\r\nAbout to call WBEM PutInstance for '%s'."), bstrClassName));

        // Commit all  properties by calling PutInstance, semisynchronously
        ComPtr<IWbemCallResult> pCallResult = NULL;
        hr = m_pWbemServices->PutInstance(pWbemObj,
                                            WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pCallResult);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pCallResult);

            HRESULT hrGetStatus = pCallResult->GetCallStatus(5000L, &hr); // timeout in milliseconds
            if (SUCCEEDED(hr) && SUCCEEDED(hrGetStatus))
            {
                hr = pCallResult->GetResultString(10000L, pbstrObjPath); // timeout in milliseconds
                if (SUCCEEDED(hr) && NULL != *pbstrObjPath)
                    OutD(LI2(TEXT("Path of newly created '%s' object is {%s}."), bstrClassName, *pbstrObjPath));
                else
                {
                    if (NULL == *pbstrObjPath)
                        Out(LI0(TEXT("Error getting ResultString from WBEM PutInstance, returned string NULL")));
                    else
                        Out(LI1(TEXT("Error %lx getting ResultString from WBEM PutInstance."), hr));
                    
                }
            }
            else
                OutD(LI1(TEXT("Error %lx getting status of WBEM PutInstance."), hr));
        }
        else
            OutD(LI1(TEXT("Error %lx putting WBEM instance."), hr));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in PutWbemInstance.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateRSOPObject(BSTR bstrClass,
                                   IWbemClassObject **ppResultObj,
                                   BOOL bTopObj /*= FALSE*/)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CreateRSOPObject)

    HRESULT hr = NOERROR;
    __try
    {
        // If we were called from GenerateGroupPolicy, or if called from ProcessGroupPolicyEx
        // and no IEAK object already exists, create the GUID ID of the GPO.
        if (bTopObj)
        {
            // For the IEAK "id" property, which is the key, this must be unique.  However,
            // since there is only one of each top object per GPO (each GPO has a different
            // precedence number) per namespace, the class name guarantees uniqueness.
            
            // CSE's need to  determine their own key which needs to be unique for every
            // instance of their  policy instance, i.e. they may have a better key generation
            // algorithm say by concatenating some of their specific properties (see registry
            // RSoP implementation).
            m_bstrID = L"IEAK";
        }

        ComPtr<IWbemClassObject> pClass = NULL;
        _bstr_t btClass = bstrClass;
        hr = m_pWbemServices->GetObject(btClass, 0L, NULL, (IWbemClassObject**)&pClass, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pClass->SpawnInstance(0, ppResultObj);
            if (FAILED(hr) || NULL == *ppResultObj)
            {
                if (SUCCEEDED(hr))
                    hr = WBEM_E_NOT_FOUND; // how can we succeed and return no objects?
                Out(LI2(TEXT("Error %lx spawning instance of %s class."), hr, bstrClass));
            }
        }
        else
            Out(LI2(TEXT("Error %lx opening %s class."), hr, bstrClass));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateRSOPObject.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateAssociation(BSTR bstrAssocClass, BSTR bstrProp2Name,
                                    BSTR bstrProp2ObjPath)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CreateAssociation)
    HRESULT hr = NOERROR;
    __try
    {
        if (SysStringLen(bstrProp2ObjPath))
        {
            ComPtr<IWbemClassObject> pAssocObj = NULL;
            hr = CreateRSOPObject(bstrAssocClass, &pAssocObj);
            if (SUCCEEDED(hr))
            {
                // Put policySetting object path in the association
                _variant_t vtRef = m_bstrIEAKPSObjPath;
                hr = PutWbemInstancePropertyEx(L"policySetting", vtRef, pAssocObj);

                // Put 2nd property's object path and put it in the association
                vtRef = bstrProp2ObjPath; 
                hr = PutWbemInstancePropertyEx(bstrProp2Name, vtRef, pAssocObj);

                //
                // Commit all above properties by calling PutInstance
                //
                hr = m_pWbemServices->PutInstance(pAssocObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
                if (SUCCEEDED(hr))
                    OutD(LI1(TEXT("Successfully stored '%s' information in CIMOM database."), bstrAssocClass));
                else
                    OutD(LI2(TEXT("Error %lx putting WBEM instance of '%s' class."), hr, bstrAssocClass));
            }
        }
        else 
            OutD(LI1(TEXT("Unable to create association for '%s' class, object path is null."), bstrAssocClass));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateAssociation.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StorePrecedenceModeData()
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // preferenceMode
        if (InsKeyExists(IS_BRANDING, IK_GPE_ONETIME_GUID, m_szINSFile))
            hr = PutWbemInstanceProperty(L"preferenceMode", true);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreDisplayedText.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreDisplayedText()
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // titleBarText
        TCHAR szValue[MAX_PATH];
        BOOL bEnabled;
        GetInsString(IS_BRANDING, IK_WINDOWTITLE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"titleBarText", szValue);

        //------------------------------------------------
        // titleBarCustomText
        GetInsString(IS_BRANDING, TEXT("Window_Title_CN"), szValue, countof(szValue), bEnabled); 
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"titleBarCustomText", szValue);

        //------------------------------------------------
        // userAgentText
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_BRANDING, IK_UASTR, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"userAgentText", szValue);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreDisplayedText.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreBitmapData()
{
    HRESULT hr = NOERROR;
    __try
    {
        //TODO: do paths need to be combined with another path to take
        // relative paths into account?
        //------------------------------------------------
        // toolbarBackgroundBitmapPath
        TCHAR szValue[MAX_PATH];
        BOOL bEnabled;
        GetInsString(IS_BRANDING, IK_TOOLBARBMP, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"toolbarBackgroundBitmapPath", szValue);


        //------------------------------------------------
        // customizeAnimatedBitmaps
        BOOL bValue = GetInsBool(IS_ANIMATION, IK_DOANIMATION, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"customizeAnimatedBitmaps", bValue ? true : false);

        //------------------------------------------------
        // largeAnimatedBitmapPath & largeAnimatedBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_ANIMATION, TEXT("Big_Path"), szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"largeAnimatedBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"largeAnimatedBitmapName", PathFindFileName(szValue));
        }

        //------------------------------------------------
        // smallAnimatedBitmapPath & smallAnimatedBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_ANIMATION, TEXT("Small_Path"), szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"smallAnimatedBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"smallAnimatedBitmapName", PathFindFileName(szValue));
        }

        //------------------------------------------------
        // customizeLogoBitmaps
        if (InsKeyExists(IS_LARGELOGO, IK_PATH, m_szINSFile) ||
            InsKeyExists(IS_SMALLLOGO, IK_PATH, m_szINSFile))
        {
            // No tri-state on this.  Disabled state has to be NULL!
            hr = PutWbemInstanceProperty(L"customizeLogoBitmaps", true);
        }
        
        //------------------------------------------------
        // largeCustomLogoBitmapPath & largeCustomLogoBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_LARGELOGO, IK_PATH, szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"largeCustomLogoBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"largeCustomLogoBitmapName", PathFindFileName(szValue));
        }

        //------------------------------------------------
        // smallCustomLogoBitmapPath & smallCustomLogoBitmapName
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_SMALLLOGO, IK_PATH, szValue, countof(szValue), bEnabled);
        if (bEnabled)
        {
            hr = PutWbemInstanceProperty(L"smallCustomLogoBitmapPath", szValue);
            hr = PutWbemInstanceProperty(L"smallCustomLogoBitmapName", PathFindFileName(szValue));
        }
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreBitmapData.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateToolbarButtonObjects(BSTR **ppaTBBtnObjPaths,
                                             long &nTBBtnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateToolbarButtonObjects function.")));

        ULONG nTBBtnArraySize = MAX_BTOOLBARS;
        _bstr_t bstrClass = L"RSOP_IEToolbarButton";

        //------------------------------------------------
        // following code taken from btoolbar.cpp in the brandll directory
        BSTR *paTBBtnObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nTBBtnArraySize);
        if (NULL != paTBBtnObjects)
        {
            ZeroMemory(paTBBtnObjects, sizeof(BSTR) * nTBBtnArraySize);

            ULONG nButton;
            BSTR *pCurTBBtnObj;
            nTBBtnCount = 0;
            for (nButton=0, pCurTBBtnObj = paTBBtnObjects; nButton < nTBBtnArraySize;
                    nButton++, pCurTBBtnObj += 1)
            {
                TCHAR szBToolbarTextParam[32];
                TCHAR szBToolbarIcoParam[32];
                TCHAR szBToolbarActionParam[32];
                TCHAR szBToolbarHotIcoParam[32];
                TCHAR szBToolbarShowParam[32];
                BTOOLBAR ToolBarInfo;

                wnsprintf(szBToolbarTextParam, ARRAYSIZE(szBToolbarTextParam), TEXT("%s%i"), IK_BTCAPTION, nButton);
                wnsprintf(szBToolbarIcoParam, ARRAYSIZE(szBToolbarIcoParam), TEXT("%s%i"), IK_BTICON, nButton);
                wnsprintf(szBToolbarActionParam, ARRAYSIZE(szBToolbarActionParam), TEXT("%s%i"), IK_BTACTION, nButton);
                wnsprintf(szBToolbarHotIcoParam, ARRAYSIZE(szBToolbarHotIcoParam), TEXT("%s%i"), IK_BTHOTICO, nButton);
                wnsprintf(szBToolbarShowParam, ARRAYSIZE(szBToolbarShowParam), TEXT("%s%i"), IK_BTSHOW, nButton);

                if ( !GetPrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, TEXT(""),
                            ToolBarInfo.szCaption, ARRAYSIZE(ToolBarInfo.szCaption), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pTBBtnObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pTBBtnObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pTBBtnObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pTBBtnObj);

                    //------------------------------------------------
                    // buttonOrder
                    hr = PutWbemInstancePropertyEx(L"buttonOrder", (long)nButton + 1, pTBBtnObj);

                    //------------------------------------------------
                    // caption
                    hr = PutWbemInstancePropertyEx(L"caption", ToolBarInfo.szCaption, pTBBtnObj);

                    //------------------------------------------------
                    // actionPath
                    GetPrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, TEXT(""),
                                        ToolBarInfo.szAction, ARRAYSIZE(ToolBarInfo.szAction), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"actionPath", ToolBarInfo.szAction, pTBBtnObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, TEXT(""),
                                        ToolBarInfo.szIcon, ARRAYSIZE(ToolBarInfo.szIcon), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", ToolBarInfo.szIcon, pTBBtnObj);

                    //------------------------------------------------
                    // hotIconPath
                    GetPrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, TEXT(""),
                                        ToolBarInfo.szHotIcon, ARRAYSIZE(ToolBarInfo.szHotIcon), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"hotIconPath", ToolBarInfo.szHotIcon, pTBBtnObj);

                    //------------------------------------------------
                    // showOnToolbarByDefault
                    ToolBarInfo.fShow = (BOOL)GetPrivateProfileInt(IS_BTOOLBARS, szBToolbarShowParam, 1, m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"showOnToolbarByDefault",
                                                    ToolBarInfo.fShow ? true : false, pTBBtnObj);


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pTBBtnObj, bstrClass, pCurTBBtnObj);
                    nTBBtnCount++;
                }
            }

            // toolbarButtons
            if (nTBBtnCount > 0)
                hr = PutWbemInstanceProperty(L"toolbarButtons", (long)nTBBtnCount);
        }

        *ppaTBBtnObjPaths = paTBBtnObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateToolbarButtonObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateToolbarButtonObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreToolbarButtons(BSTR **ppaTBBtnObjPaths,
                                      long &nTBBtnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // deleteExistingToolbarButtons
        // No tri-state on this.  Disabled state has to be NULL!
        BOOL bValue = GetInsBool(IS_BTOOLBARS, IK_BTDELETE, FALSE);
        if (bValue)
            hr = PutWbemInstanceProperty(L"deleteExistingToolbarButtons", true);

        CreateToolbarButtonObjects(ppaTBBtnObjPaths, nTBBtnCount);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreToolbarButtons.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreCustomURLs()
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // homePageURL
        TCHAR szValue[MAX_PATH];
        BOOL bEnabled;
        GetInsString(IS_URL, IK_HOMEPAGE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"homePageURL", szValue);

        //------------------------------------------------
        // searchBarURL
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_URL, IK_SEARCHPAGE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"searchBarURL", szValue);

        //------------------------------------------------
        // onlineHelpPageURL
        ZeroMemory(szValue, sizeof(szValue));
        GetInsString(IS_URL, IK_HELPPAGE, szValue, countof(szValue), bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"onlineHelpPageURL", szValue);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreCustomURLs.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateFavoriteObjects(BSTR **ppaFavObjPaths,
                                        long &nFavCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateFavoriteObjects function.")));

        ULONG nFavArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IEFavoriteItem";

        //------------------------------------------------
        // Process each favorite item in the INS file
        // following code taken from brandfav.cpp in the brandll directory
        BSTR *paFavObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nFavArraySize);
        if (NULL != paFavObjects)
        {
            ZeroMemory(paFavObjects, sizeof(BSTR) * nFavArraySize);

            ULONG nFav;
            BSTR *pCurFavObj;
            nFavCount = 0;
            for (nFav=1, pCurFavObj = paFavObjects; nFav <= nFavArraySize;
                    nFav++, pCurFavObj = paFavObjects + nFavCount)
            {
                TCHAR szTitle[32];
                TCHAR szURL[32];
                TCHAR szIconFile[32];
                TCHAR szOffline[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szURLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szIconFileVal[MAX_PATH];
                BOOL bOffline = FALSE;

                wnsprintf(szTitle, countof(szTitle), IK_TITLE_FMT, nFav);
                wnsprintf(szURL, countof(szURL), IK_URL_FMT, nFav);
                wnsprintf(szIconFile, countof(szIconFile), IK_ICON_FMT, nFav);
                wnsprintf(szOffline, countof(szOffline), IK_OFFLINE_FMT, nFav);

                if ( !GetPrivateProfileString(IS_FAVORITESEX, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pFavObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pFavObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pFavObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pFavObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nFav, pFavObj);

                    //------------------------------------------------
                    // name
                    hr = PutWbemInstancePropertyEx(L"name", szTitleVal, pFavObj);

                    //------------------------------------------------
                    // shortName

                    //------------------------------------------------
                    // url
                    GetPrivateProfileString(IS_FAVORITESEX, szURL, TEXT(""),
                                        szURLVal, ARRAYSIZE(szURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"url", szURLVal, pFavObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_FAVORITESEX, szIconFile, TEXT(""),
                                        szIconFileVal, ARRAYSIZE(szIconFileVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconFileVal, pFavObj);

                    //------------------------------------------------
                    // makeAvailableOffline
                    bOffline = InsGetBool(IS_FAVORITESEX, szOffline, FALSE, m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"makeAvailableOffline", bOffline ? true : false, pFavObj);

                    //------------------------------------------------
                    // folderItem
                    hr = PutWbemInstancePropertyEx(L"folderItem", false, pFavObj); // no folder items  yet

                    //------------------------------------------------
                    // parentPath


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pFavObj, bstrClass, pCurFavObj);
                    nFavCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nFavCount == (long)nFavArraySize)
                    {
                        paFavObjects = (BSTR*)CoTaskMemRealloc(paFavObjects, sizeof(BSTR) * (nFavArraySize + 5));
                        if (NULL != paFavObjects)
                            nFavArraySize += 5;
                    }
                }
            }

            // customFavorites
            if (nFavCount > 0)
                hr = PutWbemInstanceProperty(L"customFavorites", (long)nFavCount);
        }

        *ppaFavObjPaths = paFavObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateFavoriteObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateFavoriteObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateLinkObjects(BSTR **ppaLinkObjPaths,
                                    long &nLinkCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateLinkObjects function.")));

        ULONG nLinkArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IELinkItem";

        //------------------------------------------------
        // Process each link item in the INS file
        // following code taken from brandfav.cpp in the brandll directory
        BSTR *paLinkObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nLinkArraySize);
        if (NULL != paLinkObjects)
        {
            ZeroMemory(paLinkObjects, sizeof(BSTR) * nLinkArraySize);

            ULONG nLink;
            BSTR *pCurLinkObj;
            nLinkCount = 0;
            for (nLink=1, pCurLinkObj = paLinkObjects; nLink <= nLinkArraySize;
                    nLink++, pCurLinkObj = paLinkObjects + nLinkCount)
            {
                TCHAR szTitle[32];
                TCHAR szURL[32];
                TCHAR szIconFile[32];
                TCHAR szOffline[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szURLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szIconFileVal[MAX_PATH];
                BOOL bOffline = FALSE;

                wnsprintf(szTitle, countof(szTitle), IK_QUICKLINK_NAME, nLink);
                wnsprintf(szURL, countof(szURL), IK_QUICKLINK_URL, nLink);
                wnsprintf(szIconFile, countof(szIconFile), IK_QUICKLINK_ICON, nLink);
                wnsprintf(szOffline, countof(szOffline), IK_QUICKLINK_OFFLINE, nLink);

                if ( !GetPrivateProfileString(IS_URL, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pLinkObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pLinkObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pLinkObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pLinkObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nLink, pLinkObj);

                    //------------------------------------------------
                    // name
                    hr = PutWbemInstancePropertyEx(L"name", szTitleVal, pLinkObj);

                    //------------------------------------------------
                    // url
                    GetPrivateProfileString(IS_URL, szURL, TEXT(""),
                                        szURLVal, ARRAYSIZE(szURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"url", szURLVal, pLinkObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_URL, szIconFile, TEXT(""),
                                        szIconFileVal, ARRAYSIZE(szIconFileVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconFileVal, pLinkObj);

                    //------------------------------------------------
                    // makeAvailableOffline
                    bOffline = InsGetBool(IS_URL, szOffline, FALSE, m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"makeAvailableOffline", bOffline ? true : false, pLinkObj);


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pLinkObj, bstrClass, pCurLinkObj);
                    nLinkCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nLinkCount == (long)nLinkArraySize)
                    {
                        paLinkObjects = (BSTR*)CoTaskMemRealloc(paLinkObjects, sizeof(BSTR) * (nLinkArraySize + 5));
                        if (NULL != paLinkObjects)
                            nLinkArraySize += 5;
                    }
                }
            }

            // customLinks
            if (nLinkCount > 0)
                hr = PutWbemInstanceProperty(L"customLinks", (long)nLinkCount);
        }

        *ppaLinkObjPaths = paLinkObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateLinkObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateLinkObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreFavoritesAndLinks(BSTR **ppaFavObjPaths,
                                         long &nFavCount,
                                         BSTR **ppaLinkObjPaths,
                                         long &nLinkCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // placeFavoritesAtTopOfList
        BOOL bEnabled;
        BOOL bValue = GetInsBool(IS_BRANDING, IK_FAVORITES_ONTOP, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"placeFavoritesAtTopOfList", bValue ? true : false);

        //------------------------------------------------
        // deleteExistingFavorites
        DWORD dwValue = GetInsInt(IS_BRANDING, IK_FAVORITES_DELETE, FD_DEFAULT);
        if (FD_DEFAULT != dwValue)
            hr = PutWbemInstanceProperty(L"deleteExistingFavorites", true);

        //------------------------------------------------
        // deleteAdminCreatedFavoritesOnly
        hr = PutWbemInstanceProperty(L"deleteAdminCreatedFavoritesOnly",
                                        HasFlag(dwValue, FD_REMOVE_IEAK_CREATED));

        //------------------------------------------------
        // customFavorites
        bValue = GetInsBool(IS_BRANDING, IK_NOFAVORITES, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"customFavorites", (long)0);

        //------------------------------------------------
        // customLinks
        bValue = GetInsBool(IS_BRANDING, IK_NOLINKS, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"customLinks", (long)0);

        CreateFavoriteObjects(ppaFavObjPaths, nFavCount);
        CreateLinkObjects(ppaLinkObjPaths, nLinkCount);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreFavoritesAndLinks.")));
    }

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateCategoryObjects(BSTR **ppaCatObjPaths,
                                        long &nCatCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateCategoryObjects function.")));

        ULONG nCatArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IECategoryItem";

        //------------------------------------------------
        // Process each category item in the INS file
        // following code taken from brandchl.cpp in the brandll directory
        BSTR *paCatObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nCatArraySize);
        if (NULL != paCatObjects)
        {
            ZeroMemory(paCatObjects, sizeof(BSTR) * nCatArraySize);

            ULONG nCat;
            BSTR *pCurCatObj;
            nCatCount = 0;
            for (nCat=0, pCurCatObj = paCatObjects; nCat < nCatArraySize;
                    nCat++, pCurCatObj = paCatObjects + nCatCount)
            {
                TCHAR szTitle[32];
                TCHAR szHTML[32];
                TCHAR szBmpPath[32];
                TCHAR szIconPath[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szHTMLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szBmpPathVal[MAX_PATH];
                TCHAR szIconPathVal[MAX_PATH];

                wnsprintf(szTitle, countof(szTitle), TEXT("%s%u"), IK_CAT_TITLE, nCat);
                wnsprintf(szHTML, countof(szHTML), TEXT("%s%u"), CATHTML, nCat);
                wnsprintf(szBmpPath, countof(szBmpPath), TEXT("%s%u"), CATBMP, nCat);
                wnsprintf(szIconPath, countof(szIconPath), TEXT("%s%u"), CATICON, nCat);


                if ( !GetPrivateProfileString(IS_CHANNEL_ADD, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pCatObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pCatObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pCatObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pCatObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nCat + 1, pCatObj);

                    //------------------------------------------------
                    // title
                    hr = PutWbemInstancePropertyEx(L"title", szTitleVal, pCatObj);

                    //------------------------------------------------
                    // categoryHTMLPage
                    GetPrivateProfileString(IS_CHANNEL_ADD, szHTML, TEXT(""),
                                        szHTMLVal, ARRAYSIZE(szHTMLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"categoryHTMLPage", szHTMLVal, pCatObj);

                    //------------------------------------------------
                    // narrowImagePath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szBmpPath, TEXT(""),
                                        szBmpPathVal, ARRAYSIZE(szBmpPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"narrowImagePath", szBmpPathVal, pCatObj);

                    //------------------------------------------------
                    // narrowImageName
                    hr = PutWbemInstancePropertyEx(L"narrowImageName", PathFindFileName(szBmpPathVal), pCatObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szIconPath, TEXT(""),
                                        szIconPathVal, ARRAYSIZE(szIconPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconPathVal, pCatObj);

                    //------------------------------------------------
                    // iconName
                    hr = PutWbemInstancePropertyEx(L"iconName", PathFindFileName(szIconPathVal), pCatObj);


                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pCatObj, bstrClass, pCurCatObj);
                    nCatCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nCatCount == (long)nCatArraySize)
                    {
                        paCatObjects = (BSTR*)CoTaskMemRealloc(paCatObjects, sizeof(BSTR) * (nCatArraySize + 5));
                        if (NULL != paCatObjects)
                            nCatArraySize += 5;
                    }
                }
            }

            // categories
            if (nCatCount > 0)
                hr = PutWbemInstanceProperty(L"categories", (long)nCatCount);
        }

        *ppaCatObjPaths = paCatObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateCategoryObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateCategoryObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::CreateChannelObjects(BSTR **ppaChnObjPaths,
                                       long &nChnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered CreateChannelObjects function.")));

        ULONG nChnArraySize = 10;
        _bstr_t bstrClass = L"RSOP_IEChannelItem";

        //------------------------------------------------
        // Process each channel item in the INS file
        // following code taken from brandchl.cpp in the brandll directory
        BSTR *paChnObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nChnArraySize);
        if (NULL != paChnObjects)
        {
            ZeroMemory(paChnObjects, sizeof(BSTR) * nChnArraySize);

            ULONG nChn;
            BSTR *pCurChnObj;
            nChnCount = 0;
            for (nChn=0, pCurChnObj = paChnObjects; nChn < nChnArraySize;
                    nChn++, pCurChnObj = paChnObjects + nChnCount )
            {
                TCHAR szTitle[32];
                TCHAR szURL[32];
                TCHAR szPreloadURL[32];
                TCHAR szBmpPath[32];
                TCHAR szIconPath[32];
                TCHAR szAvailOffline[32];

                TCHAR szTitleVal[MAX_PATH];
                TCHAR szURLVal[INTERNET_MAX_URL_LENGTH];
                TCHAR szPreloadURLVal[MAX_PATH];
                TCHAR szBmpPathVal[MAX_PATH];
                TCHAR szIconPathVal[MAX_PATH];
                BOOL bOffline = FALSE;

                wnsprintf(szTitle, countof(szTitle), TEXT("%s%u"), IK_CHL_TITLE, nChn);
                wnsprintf(szURL, countof(szURL), TEXT("%s%u"), IK_CHL_URL, nChn);
                wnsprintf(szPreloadURL, countof(szPreloadURL), TEXT("%s%u"), IK_CHL_PRELOADURL, nChn);
                wnsprintf(szBmpPath, countof(szBmpPath), TEXT("%s%u"), CHBMP, nChn);
                wnsprintf(szIconPath, countof(szIconPath), TEXT("%s%u"), CHICON, nChn);
                wnsprintf(szAvailOffline, countof(szAvailOffline), TEXT("%s%u"), IK_CHL_OFFLINE, nChn);

                if ( !GetPrivateProfileString(IS_CHANNEL_ADD, szTitle, TEXT(""),
                            szTitleVal, ARRAYSIZE(szTitleVal), m_szINSFile) )
                {
                    break;
                }

                ComPtr<IWbemClassObject> pChnObj = NULL;
                hr = CreateRSOPObject(bstrClass, &pChnObj);
                if (SUCCEEDED(hr))
                {
                    // Write foreign keys from our stored precedence & id fields
                    OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                    hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pChnObj);

                    OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                    hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pChnObj);

                    //------------------------------------------------
                    // order
                    hr = PutWbemInstancePropertyEx(L"order", (long)nChn + 1, pChnObj);

                    //------------------------------------------------
                    // title
                    hr = PutWbemInstancePropertyEx(L"title", szTitleVal, pChnObj);

                    //------------------------------------------------
                    // channelDefinitionURL
                    GetPrivateProfileString(IS_CHANNEL_ADD, szURL, TEXT(""),
                                        szURLVal, ARRAYSIZE(szURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"channelDefinitionURL", szURLVal, pChnObj);

                    //------------------------------------------------
                    // channelDefinitionFilePath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szPreloadURL, TEXT(""),
                                        szPreloadURLVal, ARRAYSIZE(szPreloadURLVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"channelDefinitionFilePath", szPreloadURLVal, pChnObj);

                    //------------------------------------------------
                    // narrowImagePath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szBmpPath, TEXT(""),
                                        szBmpPathVal, ARRAYSIZE(szBmpPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"narrowImagePath", szBmpPathVal, pChnObj);

                    //------------------------------------------------
                    // narrowImageName
                    hr = PutWbemInstancePropertyEx(L"narrowImageName", PathFindFileName(szBmpPathVal), pChnObj);

                    //------------------------------------------------
                    // iconPath
                    GetPrivateProfileString(IS_CHANNEL_ADD, szIconPath, TEXT(""),
                                        szIconPathVal, ARRAYSIZE(szIconPathVal), m_szINSFile);
                    hr = PutWbemInstancePropertyEx(L"iconPath", szIconPathVal, pChnObj);

                    //------------------------------------------------
                    // iconName
                    hr = PutWbemInstancePropertyEx(L"iconName", PathFindFileName(szIconPathVal), pChnObj);

                    //------------------------------------------------
                    // makeAvailableOffline
                    bOffline = GetInsBool(IS_CHANNEL_ADD, szAvailOffline, FALSE);
                    hr = PutWbemInstancePropertyEx(L"makeAvailableOffline", bOffline ? true : false, pChnObj);

                    //
                    // Commit all above properties by calling PutInstance, semisynchronously
                    //
                    hr = PutWbemInstance(pChnObj, bstrClass, pCurChnObj);
                    nChnCount++;

                    // Grow the array of obj paths if we've outgrown the current array
                    if (nChnCount == (long)nChnArraySize)
                    {
                        paChnObjects = (BSTR*)CoTaskMemRealloc(paChnObjects, sizeof(BSTR) * (nChnArraySize + 5));
                        if (NULL != paChnObjects)
                            nChnArraySize += 5;
                    }
                }
            }

            // channels
            if (nChnCount > 0)
                hr = PutWbemInstanceProperty(L"channels", (long)nChnCount);
        }

        *ppaChnObjPaths = paChnObjects;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in CreateChannelObjects.")));
    }

    OutD(LI0(TEXT("Exiting CreateChannelObjects function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreChannelsAndCategories(BSTR **ppaCatObjPaths,
                                             long &nCatCount,
                                             BSTR **ppaChnObjPaths,
                                             long &nChnCount)
{
    HRESULT hr = NOERROR;
    __try
    {
        //------------------------------------------------
        // deleteExistingChannels
        BOOL bEnabled;
        BOOL bValue = GetInsBool(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"deleteExistingChannels", bValue ? true : false);

        //------------------------------------------------
        // enableDesktopChannelBarByDefault
        bValue = GetInsBool(IS_DESKTOPOBJS, IK_SHOWCHLBAR, FALSE, &bEnabled);
        if (bEnabled)
            hr = PutWbemInstanceProperty(L"enableDesktopChannelBarByDefault", bValue ? true : false);

        hr = CreateCategoryObjects(ppaCatObjPaths, nCatCount);
        hr = CreateChannelObjects(ppaChnObjPaths, nChnCount);
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreChannelsAndCategories.")));
    }

  return hr;
}

//static const TCHAR c_szSzType[]     = TEXT("%s,\"%s\",%s,,\"%s\"");
//static const TCHAR c_szDwordType[]  = TEXT("%s,\"%s\",%s,0x10001");
//static const TCHAR c_szBinaryType[] = TEXT("%s,\"%s\",%s,1");

#define IS_PROGRAMS_INF        TEXT("PROGRAMS.INF")

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreProgramSettings(BSTR *pbstrProgramSettingsObjPath)
{
    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI0(TEXT("\r\nEntered StoreProgramSettings function.")));

        //------------------------------------------------
        // importProgramSettings
        BOOL bImportSettings = !InsIsKeyEmpty(IS_EXTREGINF, IK_PROGRAMS, m_szINSFile);
        OutD(LI1(TEXT("Value read from INS >> ExtRegInf >> Programs = %s."),
                    bImportSettings ? _T("Valid Settings") : _T("Empty")));

        if (bImportSettings)
            hr = PutWbemInstanceProperty(L"importProgramSettings", true);

        if (bImportSettings) // only create the program settings class if they are marked to be imported
        {
            //
            // Create & populate RSOP_IEProgramSettings
            //
            _bstr_t bstrClass = L"RSOP_IEProgramSettings";
            ComPtr<IWbemClassObject> pPSObj = NULL;
            hr = CreateRSOPObject(bstrClass, &pPSObj);
            if (SUCCEEDED(hr))
            {
                // Write foreign keys from our stored precedence & id fields
                OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
                hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pPSObj);

                OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
                hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pPSObj);

                // Get the path of the programs.inf file
                TCHAR szINFFile[MAX_PATH];
                StrCpy(szINFFile, m_szINSFile);
                PathRemoveFileSpec(szINFFile);
                StrCat(szINFFile, TEXT("\\programs.inf"));
                OutD(LI1(TEXT("Reading from %s"), szINFFile));

                // Get the AddReg.Hklm section for the majority of the strings we'll need.
                UINT nErrLine = 0;
                HINF hInfPrograms = SetupOpenInfFile(szINFFile, NULL, INF_STYLE_WIN4, &nErrLine);
                if (INVALID_HANDLE_VALUE != hInfPrograms)
                {
                    INFCONTEXT infContext;
                    BOOL bFound = TRUE;
                    BOOL bFindNextLine = TRUE;
                    // AddReg.Hklm section
                    if (SetupFindFirstLine(hInfPrograms, IS_IEAKADDREG_HKLM, NULL, &infContext))
                    {
                        //------------------------------------------------
                        // calendarProgram

                        TCHAR szValue[MAX_PATH];
                        bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                        IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Calendar"),
                                                        szValue, sizeof(szValue), bFindNextLine);
                        if (bFound)
                            hr = PutWbemInstancePropertyEx(L"calendarProgram", szValue, pPSObj);

                        //------------------------------------------------
                        // contactListProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Contacts"),
                                                            szValue, sizeof(szValue), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"contactListProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // internetCallProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Internet Call"),
                                                            szValue, sizeof(szValue), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"internetCallProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // emailProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\Mail"),
                                                            szValue, sizeof(szValue), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"emailProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // newsgroupsProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, 5, TEXT("Software\\Clients\\News"),
                                                            szValue, sizeof(szValue), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"newsgroupsProgram", szValue, pPSObj);
                        }

                        //------------------------------------------------
                        // htmlEditorHKLMRegData
                        _bstr_t bstrPropVal = L"";
                        while (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKLM, (DWORD)-1, NULL,
                                                            szValue, sizeof(szValue), bFindNextLine);
                            if (bFound)
                            {
                                if (bstrPropVal.length() > 0)
                                    bstrPropVal += L"\r\n";
                                bstrPropVal += szValue;
                            }

                            if (!bFound || !bFindNextLine)
                            {
                                if (bstrPropVal.length() > 0)
                                    hr = PutWbemInstancePropertyEx(L"htmlEditorHKLMRegData", bstrPropVal, pPSObj);
                                break;
                            }
                        }
                    }
                    else
                    {
                        // No lines found under this section, so don't bother looking for any more
                    }

                    // AddReg.Hkcu section
                    if (SetupFindFirstLine(hInfPrograms, IS_IEAKADDREG_HKCU, NULL, &infContext))
                    {
                        //------------------------------------------------
                        // checkIfIEIsDefaultBrowser
                        TCHAR szValue[MAX_PATH];
                        bFindNextLine = TRUE;
                        bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                        IS_IEAKADDREG_HKCU, 5, TEXT("Check_Associations"),
                                                        szValue, sizeof(szValue), bFindNextLine);
                        if (bFound)
                        {
                            hr = PutWbemInstancePropertyEx(L"checkIfIEIsDefaultBrowser",
                                                        StrCmp(TEXT("yes"), szValue) ? false : true, pPSObj);
                        }

                        //------------------------------------------------
                        // htmlEditorProgram
                        if (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFindNextLine = FALSE; // this line must be stored twice
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF, IS_IEAKADDREG_HKCU, 5,
                                                            RK_HTMLEDIT TEXT(",Description"), szValue,
                                                            sizeof(szValue), bFindNextLine);
                            if (bFound)
                                hr = PutWbemInstancePropertyEx(L"htmlEditorProgram", szValue, pPSObj);

                            bFindNextLine = TRUE;
                        }

                        //------------------------------------------------
                        // htmlEditorHKCURegData
                        _bstr_t bstrPropVal = L"";
                        while (bFindNextLine)
                        {
                            ZeroMemory(szValue, sizeof(szValue));
                            bFound = GetINFStringField(&infContext, IS_PROGRAMS_INF,
                                                            IS_IEAKADDREG_HKCU, (DWORD)-1, NULL,
                                                            szValue, sizeof(szValue), bFindNextLine);
                            if (bFound)
                            {
                                if (bstrPropVal.length() > 0)
                                    bstrPropVal += L"\r\n";
                                bstrPropVal += szValue;
                            }

                            if (!bFound || !bFindNextLine)
                            {
                                if (bstrPropVal.length() > 0)
                                    hr = PutWbemInstancePropertyEx(L"htmlEditorHKCURegData", bstrPropVal, pPSObj);
                                break;
                            }
                        }
                    }
                    else
                    {
                        // No lines found under this section, so don't bother looking for any more
                    }

                    SetupCloseInfFile(hInfPrograms);
                }
                else
                {
                    // Programs.INF file not found - fill out an empty object
                }

                //
                // Commit all above properties by calling PutInstance, semisynchronously
                //
                hr = PutWbemInstance(pPSObj, bstrClass, pbstrProgramSettingsObjPath);
            }
        }
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StoreProgramSettings.")));
    }

    OutD(LI0(TEXT("Exiting StoreProgramSettings function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
//  LogPolicyInstance()
//
//  Purpose:    Logs an instance of IEAK RSoP policy. Will be called from
//                            ProcessGroupPolicyEx and GenerateGroupPolicy to log Rsop data
//                            for the IEAK RSoP CSE.
//
//  Parameters: wszGPO - GPO ID obtained from PGROUP_POLICY_OBJECT->lpDSPath
//              wszSOM - SOM ID obtained from PGROUP_POLICY_OBJECT->lpLink
//              dwPrecedence - Precedence order for this policy instance
//
//  Returns:    HRESULT
///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::LogPolicyInstance(LPWSTR wszGPO, LPWSTR wszSOM,
                                    DWORD dwPrecedence)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, LogPolicyInstance)

    HRESULT hr = NOERROR;
    __try
    {
        OutD(LI1(TEXT("Entered LogPolicyInstance, m_pWbemServices is %lx."), m_pWbemServices));

        // get or create the class instance for the main IEAK RSoP class(es)
        _bstr_t bstrClass = L"RSOP_IEAKPolicySetting";
        hr = CreateRSOPObject(bstrClass, &m_pIEAKPSObj, TRUE);

        // First log CSE-specific properties - parent class,
        // i.e. RSOP_PolicyObject properties. For GPOID and SOMID fields,  
        // use the data in the fields PGROUP_POLICY_OBJECT->lpDSPath and 
        // PGROUP_POLICY_OBJECT->lpLink fields respectively. Also, the LDAP://CN=Machine
        // or LDAP:// needs to be removed from the prefix of lpDSPath and lpLink
        // to get the canonical values. Code for StripPrefix, StripLinkPrefix is given
        // below.

        // Precedence is determined by CSE to indicate winning Vs. losing policies
        if (SUCCEEDED(hr))
        {
            m_dwPrecedence = dwPrecedence;
            OutD(LI1(TEXT("Storing property 'precedence' in RSOP_IEAKPolicySetting, value = %lx"), dwPrecedence));
            hr = PutWbemInstanceProperty(L"precedence", (long)dwPrecedence);

            OutD(LI1(TEXT("Storing property 'GPOID' in RSOP_IEAKPolicySetting, value = %s"), wszGPO));
            hr = PutWbemInstanceProperty(L"GPOID", wszGPO);

            OutD(LI1(TEXT("Storing property 'SOMID' in RSOP_IEAKPolicySetting, value = %s"), wszSOM));
            hr = PutWbemInstanceProperty(L"SOMID", wszSOM);

            OutD(LI1(TEXT("Storing property 'id' in RSOP_IEAKPolicySetting, value = %s"), (BSTR)m_bstrID));
            hr = PutWbemInstanceProperty(L"id", m_bstrID);

            // ----- Now log IEAK-custom settings to WMI
            // Precedence Mode settings
            hr = StorePrecedenceModeData();

            // Browser UI settings
            hr = StoreDisplayedText();
            hr = StoreBitmapData();

            BSTR *paTBBtnObjects = NULL;
            long nTBBtnCount = 0;
            hr = StoreToolbarButtons(&paTBBtnObjects, nTBBtnCount);

            // Connection settings
            BSTR bstrConnSettingsObjPath = NULL;

            BSTR *paDUSObjects = NULL;
            BSTR *paDUCObjects = NULL;
            BSTR *paWSObjects = NULL;
            long nDUSCount = 0;
            long nDUCCount = 0;
            long nWSCount = 0;

            hr = StoreConnectionSettings(&bstrConnSettingsObjPath,
                                        &paDUSObjects, nDUSCount,
                                        &paDUCObjects, nDUCCount,
                                        &paWSObjects, nWSCount);

            // URL settings
            hr = StoreCustomURLs();

                    // favorites & links
            BSTR *paFavObjects = NULL;
            BSTR *paLinkObjects = NULL;
            long nFavCount = 0;
            long nLinkCount = 0;
            hr = StoreFavoritesAndLinks(&paFavObjects, nFavCount,
                                        &paLinkObjects, nLinkCount);

                    // channels & categories
//            BSTR *paCatObjects = NULL;
//            BSTR *paChnObjects = NULL;
//            long nCatCount = 0;
//            long nChnCount = 0;
//            hr = StoreChannelsAndCategories(&paCatObjects, nCatCount,
//                                            &paChnObjects, nChnCount);

            // Security settings
            hr = StoreSecZonesAndContentRatings();
            hr = StoreAuthenticodeSettings();

            // Program settings
            BSTR bstrProgramSettingsObjPath = NULL;
            hr = StoreProgramSettings(&bstrProgramSettingsObjPath);

            // Advanced settings
            hr = StoreADMSettings(wszGPO, wszSOM);
            // -----

            //
            // Commit all above properties by calling PutInstance - semisynchronously
            //
            hr = PutWbemInstance(m_pIEAKPSObj, bstrClass, &m_bstrIEAKPSObjPath);
            if (FAILED(hr))
                Out(LI2(TEXT("Error %lx saving %s instance data."), hr, (BSTR)bstrClass));


            //
            // Now create the association classes to connect the main RSOP_IEAKPolicySetting
            // class with all other classes such as connection settings, toolbar bitmaps, etc.
            //

            // Connection settings associations
            if (NULL != bstrConnSettingsObjPath)
            {
                if (SysStringLen(bstrConnSettingsObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionSettingsLink", L"connectionSettings",
                                                                    bstrConnSettingsObjPath);
                    SysFreeString(bstrConnSettingsObjPath);
                }
            }

            // Dial-up Settings associations
            BSTR *pbstrObjPath;
            long nItem;
            for (nItem = 0, pbstrObjPath = paDUSObjects; nItem < nDUSCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionDialUpSettingsLink", L"dialUpSettings",
                                            *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paDUSObjects);

            // Dial-up Credentials associations
            for (nItem = 0, pbstrObjPath = paDUCObjects; nItem < nDUCCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionDialUpCredentialsLink", L"dialUpCredentials",
                                            *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paDUCObjects);

            // WinINet associations
            for (nItem = 0, pbstrObjPath = paWSObjects; nItem < nWSCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEConnectionWinINetSettingsLink", L"winINetSettings",
                                            *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paWSObjects);
            

            // Toolbar button associations
            for (nItem = 0, pbstrObjPath = paTBBtnObjects; nItem < nTBBtnCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEToolbarButtonLink", L"toolbarButton",
                                                                    *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paTBBtnObjects);

            // Favorites associations
            for (nItem = 0, pbstrObjPath = paFavObjects; nItem < nFavCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IEFavoriteItemLink", L"favoriteItem",
                                                                    *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paFavObjects);

            // Links associations
            for (nItem = 0, pbstrObjPath = paLinkObjects; nItem < nLinkCount;
                    nItem++, pbstrObjPath += 1)
            {
                if (SysStringLen(*pbstrObjPath))
                {
                    hr = CreateAssociation(L"RSOP_IELinkItemLink", L"linkItem",
                                                                    *pbstrObjPath);
                    SysFreeString(*pbstrObjPath);
                }
            }
            CoTaskMemFree(paLinkObjects);

            // Categories associations
//            for (nItem = 0, pbstrObjPath = paCatObjects; nItem < nCatCount;
//                    nItem++, pbstrObjPath += sizeof(BSTR))
//            {
//                hr = CreateAssociation(L"RSOP_IECategoryItemLink", L"categoryItem",
//                                                                *pbstrObjPath);
//                SysFreeString(*pbstrObjPath);
//            }
//            CoTaskMemFree(paCatObjects);

            // Channels associations
//            for (nItem = 0, pbstrObjPath = paChnObjects; nItem < nChnCount;
//                    nItem++, pbstrObjPath += sizeof(BSTR))
//            {
//                hr = CreateAssociation(L"RSOP_IEChannelItemLink", L"channelItem",
//                                                                *pbstrObjPath);
//                SysFreeString(*pbstrObjPath);
//            }
//            CoTaskMemFree(paChnObjects);

            // Program Settings association
            if (NULL != bstrProgramSettingsObjPath)
            {
                hr = CreateAssociation(L"RSOP_IEImportedProgramSettings", L"programSettings",
                                                                bstrProgramSettingsObjPath);
                SysFreeString(bstrProgramSettingsObjPath);
            }

            m_pIEAKPSObj = NULL;
        }
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in LogPolicyInstance.")));
    }

    OutD(LI1(TEXT("Exited LogPolicyInstance with result of %lx."), hr));
    return hr;
}

///////////////////////////////////////////////////////////
//  StripGPOPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to GPO
//
//  Parameters: wszPath     - DS path to GPO
//
//  Returns:    Pointer to suffix
///////////////////////////////////////////////////////////
WCHAR *StripGPOPrefix(WCHAR *wszPath)
{
    WCHAR *wszPathSuffix = NULL;
    __try
    {
        WCHAR wszMachPrefix[] = L"LDAP://CN=Machine,";
        INT iMachPrefixLen = (INT)wcslen(wszMachPrefix);
        WCHAR wszUserPrefix[] = L"LDAP://CN=User,";
        INT iUserPrefixLen = (INT)wcslen(wszUserPrefix);

        //
        // Strip out prefix to get the canonical path to GPO
        //

        if (CSTR_EQUAL == CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                        wszPath, iUserPrefixLen, wszUserPrefix,
                                        iUserPrefixLen))
        {
          wszPathSuffix = wszPath + iUserPrefixLen;
        }
        else if (CSTR_EQUAL == CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                                wszPath, iMachPrefixLen, wszMachPrefix,
                                                iMachPrefixLen))
        {
          wszPathSuffix = wszPath + iMachPrefixLen;
        }
        else
            wszPathSuffix = wszPath;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StripGPOPrefix.")));
    }
    return wszPathSuffix;
}

///////////////////////////////////////////////////////////
//
//  StripSOMPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to SOM
//              object
//
//  Parameters: wszPath - path to SOM to strip
//
//  Returns:    Pointer to suffix
//
///////////////////////////////////////////////////////////
WCHAR *StripSOMPrefix(WCHAR *wszPath)
{
    WCHAR *wszPathSuffix = NULL;
    __try
    {
        WCHAR wszPrefix[] = L"LDAP://";
        INT iPrefixLen = (INT)wcslen(wszPrefix);

        // Strip out prefix to get the canonical path to SOM
        if (wcslen(wszPath) > (DWORD)iPrefixLen)
        {
            if (CSTR_EQUAL == CompareStringW(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                            wszPath, iPrefixLen, wszPrefix, iPrefixLen))
            {
                wszPathSuffix = wszPath + iPrefixLen;
            }
            else
                wszPathSuffix = wszPath;
        }
        else
            wszPathSuffix = wszPath;
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StripSOMPrefix.")));
    }

    return wszPathSuffix;
}

///////////////////////////////////////////////////////////////////////////////
// CRSoPUpdate CLASS
///////////////////////////////////////////////////////////////////////////////
CRSoPUpdate::CRSoPUpdate(ComPtr<IWbemServices> pWbemServices, LPCTSTR szCustomDir):
    m_pWbemServices(pWbemServices)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, CRSoPUpdate)
    __try
    {
        StrCpy(m_szCustomDir, szCustomDir);
    }
    __except(TRUE)
    {
    }
}

CRSoPUpdate::~CRSoPUpdate()
{
}

///////////////////////////////////////////////////////////////////////////////
// Example extension line:
//        [{A2E30F80-D7DE-11D2-BBDE-00C04F86AE3B}{FC715823-C5FB-11D1-9EEF-00A0C90347FF}]
///////////////////////////////////////////////////////////////////////////////
BOOL DoesGPOHaveIEAKSettings(PGROUP_POLICY_OBJECT pGPO)
{
    BOOL bRet = FALSE;
    __try
    {
        if (NULL != pGPO->lpExtensions)
        {
            // Look for IEAK CSE GUID at first of line ('[').
            // If present, this GPO has IEAK settings
            if (NULL != StrStrI(pGPO->lpExtensions, _T("[{A2E30F80-D7DE-11D2-BBDE-00C04F86AE3B}")))
            {
                bRet = TRUE;
                OutD(LI0(TEXT("Changed IEAK settings detected in this GPO.")));
            }
            else
                OutD(LI1(TEXT("No changed IEAK settings detected in this GPO (see extension list as follows) = \r\n%s\r\n."),
                        pGPO->lpExtensions));
        }
        else
            OutD(LI0(TEXT("No extensions for this GPO.")));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in StripSOMPrefix.")));
    }
    return bRet;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::DeleteObjects(BSTR bstrTempClass)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, DeleteObjects)

    HRESULT hr = NOERROR;
    __try
    {
        // Make sure SysAllocString is called on the string or we'll get errors.
        _bstr_t bstrClass = bstrTempClass;
        ComPtr<IEnumWbemClassObject> pObjEnum = NULL;
        hr = m_pWbemServices->CreateInstanceEnum(bstrClass,
                                                WBEM_FLAG_FORWARD_ONLY,
                                                NULL, &pObjEnum);
        if (SUCCEEDED(hr))
        {
            hr = WBEM_S_NO_ERROR;

            // Final Next wil return WBEM_S_FALSE
            while (WBEM_S_NO_ERROR == hr)
            {
                ULONG nObjReturned;
                ComPtr<IWbemClassObject> pObj;
                hr = pObjEnum->Next(5000L, 1, (IWbemClassObject**)&pObj, &nObjReturned);
                if (WBEM_S_NO_ERROR == hr)
                {
                    // output to debugger the object's path
                    _variant_t vtRelPath;
                    _bstr_t bstrRelPath;
                    hr = pObj->Get(L"__relpath", 0L, &vtRelPath, NULL, NULL);
                    if (SUCCEEDED(hr) && VT_BSTR == vtRelPath.vt)
                    {
                        bstrRelPath = vtRelPath;
                        OutD(LI1(TEXT("About to delete %s."), (BSTR)bstrRelPath));

                        HRESULT hrDel = m_pWbemServices->DeleteInstance((BSTR)bstrRelPath, 0L, NULL, NULL);
                        if (FAILED(hrDel))
                            Out(LI2(TEXT("Error %lx deleting %s."), hr, (BSTR)bstrRelPath));
                    }
                    else
                        Out(LI2(TEXT("Error %lx getting __relpath from %s."), hr, bstrClass));
                }      // If Enum Succeeded
                else if (FAILED(hr))
                    Out(LI2(TEXT("Error %lx getting next WBEM object of class %s."), hr, bstrClass));
            }      // While Enum returning objects
        }
        else
            Out(LI2(TEXT("Error %lx querying WBEM object %s."), hr, bstrClass));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in DeleteObjects.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::DeleteIEAKDataFromNamespace()
{
    MACRO_LI_PrologEx_C(PIF_STD_C, DeleteIEAKDataFromNamespace)

    HRESULT hr = NOERROR;
    __try
    {
        // ----- Delete all IEAK-generated instances from namespace
        // Browser UI settings
        hr = DeleteObjects(L"RSOP_IEToolbarButton");
        hr = DeleteObjects(L"RSOP_IEToolbarButtonLink");


        // Connection settings
        hr = DeleteObjects(L"RSOP_IEConnectionSettings");
        hr = DeleteObjects(L"RSOP_IEConnectionSettingsLink");

        hr = DeleteObjects(L"RSOP_IEConnectionDialUpSettings");
        hr = DeleteObjects(L"RSOP_IEConnectionDialUpSettingsLink");

        hr = DeleteObjects(L"RSOP_IEConnectionDialUpCredentials");
        hr = DeleteObjects(L"RSOP_IEConnectionDialUpCredentialsLink");

        hr = DeleteObjects(L"RSOP_IEConnectionWinINetSettings");
        hr = DeleteObjects(L"RSOP_IEConnectionWinINetSettingsLink");


        // URL settings

                // favorites & links
        hr = DeleteObjects(L"RSOP_IEFavoriteItem");
        hr = DeleteObjects(L"RSOP_IEFavoriteItemLink");

        hr = DeleteObjects(L"RSOP_IELinkItem");
        hr = DeleteObjects(L"RSOP_IELinkItemLink");

        // Security settings
        hr = DeleteObjects(L"RSOP_IESecurityZoneSettings");
        hr = DeleteObjects(L"RSOP_IEPrivacySettings");
        hr = DeleteObjects(L"RSOP_IESecurityContentRatings");

        hr = DeleteObjects(L"RSOP_IEAuthenticodeCertificate");


        // Program settings
        hr = DeleteObjects(L"RSOP_IEProgramSettings");
        hr = DeleteObjects(L"RSOP_IEImportedProgramSettings");


        // Advanced settings
        // TODO: Instances of each object class and its associations should eventually
        // be deleted only when processing occurs for those settings.
        hr = DeleteObjects(L"RSOP_IEAdministrativeTemplateFile");
        hr = DeleteObjects(L"RSOP_IERegistryPolicySetting");
        // -----


        //
        // Now delete the main root policy setting object
        //
        hr = DeleteObjects(L"RSOP_IEAKPolicySetting");
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in DeleteIEAKDataFromNamespace.")));
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::Log(DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                             PGROUP_POLICY_OBJECT pDeletedGPOList,
                                             PGROUP_POLICY_OBJECT  pChangedGPOList,
                                             ASYNCCOMPLETIONHANDLE pHandle)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, Log)

    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(hToken);
    UNREFERENCED_PARAMETER(hKeyRoot);
    UNREFERENCED_PARAMETER(pDeletedGPOList);
    UNREFERENCED_PARAMETER(pHandle);

    HRESULT hr = NOERROR;

    __try
    {
        // Deleted GPOs
        // Don't do anything with the deleted GPOList.  We'll just delete all instances
        // and write the new one out to CIMOM.

        // only need to delete all instances of the classes once, not per GPO
        BOOL bExistingDataDeleted = FALSE;

        // Changed GPOs
        Out(LI0(TEXT("Starting Internet Explorer RSoP group policy looping through changed GPOs ...")));

        // Find out how many GPOs are in our list
        PGROUP_POLICY_OBJECT pCurGPO = NULL;
        DWORD dwTotalGPOs = 0;
        for (pCurGPO = pChangedGPOList; pCurGPO != NULL; pCurGPO = pCurGPO->pNext)
            dwTotalGPOs++;


        // Prepare the variables that will store the path to the local copy of the
        // GPO directories.
        PathAppend(m_szCustomDir, TEXT("Custom Settings"));

        TCHAR szTempDir[MAX_PATH];
        StrCpy(szTempDir, m_szCustomDir);

        PathAppend(szTempDir, TEXT("Custom"));
        LPTSTR pszNum = szTempDir + StrLen(szTempDir);


        // Loop through all changed GPOs in the list
        DWORD dwIndex = 0;
        for (pCurGPO = pChangedGPOList, dwIndex = 0; 
                pCurGPO != NULL, dwIndex < dwTotalGPOs; pCurGPO = pCurGPO->pNext)
        {
            // If the IEAK CSE guid is in the lpExtensions for this GPO, process it.
            OutD(LI1(TEXT("GPO - lpDisplayName: \"%s\"."), pCurGPO->lpDisplayName));
            OutD(LI1(TEXT("GPO - szGPOName: \"%s\"."), pCurGPO->szGPOName));
            OutD(LI1(TEXT("File path is \"%s\"."), pCurGPO->lpFileSysPath));

            if (DoesGPOHaveIEAKSettings(pCurGPO))
            {
                if (!bExistingDataDeleted)
                {
                    DeleteIEAKDataFromNamespace();
                    bExistingDataDeleted = TRUE;
                }

                // Store file system portion of GPO and the WBEM class instance in a
                // new RSoP GPO object,  TODO: this had better be a copy of the actual
                // data, just in case the data is modified mid-stream (check for planning mode)

                // Because the GPO directory was already copied to a local directory for
                // normal GP processing, and since we should make a copy anyway, we'll just
                // use the copy already on our local machine (AppData directory).  We can
                // therefore ignore the pCurGPO->lpFileSysPath.

                TCHAR szNum[8];
                wnsprintf(szNum, countof(szNum), TEXT("%d"), dwIndex);
                StrCpy(pszNum, szNum);

                TCHAR szINSFile[MAX_PATH] = _T("");
                PathCombine(szINSFile, szTempDir, _T("install.ins"));
                OutD(LI1(TEXT("GPO file path is %s."), szINSFile));

                CRSoPGPO GPO(m_pWbemServices, szINSFile);

                // Convert directory service portion of GPO and the path to the Active
                // Directory site, domain, or organization unit to which this GPO is linked.
                // If the GPO is linked to the local GPO, this member is "Local". 
                _bstr_t bstrGPODSPath = pCurGPO->lpDSPath;
                LPWSTR wszStrippedGPO = StripGPOPrefix(bstrGPODSPath);

                _bstr_t bstrGPOLink = pCurGPO->lpLink;
                LPWSTR wszStrippedSOM = StripSOMPrefix(bstrGPOLink);

                // GPOs are passed in the order in which they are to be processed.  The last
                // one processed is precedence 1, 2nd to last is precedence 2, etc.
                GPO.LogPolicyInstance(wszStrippedGPO, wszStrippedSOM, dwTotalGPOs - dwIndex);

                dwIndex++;
            }
        }

        Out(LI0(TEXT("Finished Internet Explorer RSoP group policy looping through GPOs ...")));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in Log.")));
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT CRSoPUpdate::Plan(DWORD dwFlags, WCHAR *wszSite,
                          PRSOP_TARGET pComputerTarget, PRSOP_TARGET pUserTarget)
{
    MACRO_LI_PrologEx_C(PIF_STD_C, Plan)

    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(wszSite);
    UNREFERENCED_PARAMETER(pComputerTarget);

    HRESULT hr = NOERROR;

    __try
    {
        // Changed GPOs
        Out(LI0(TEXT("Starting Internet Explorer RSoP group policy looping through changed GPOs ...")));

        // Find out how many GPOs are in our list
        PGROUP_POLICY_OBJECT pCurGPO = NULL;
        DWORD dwTotalGPOs = 0;
        for (pCurGPO = pUserTarget->pGPOList; pCurGPO != NULL; pCurGPO = pCurGPO->pNext)
            dwTotalGPOs++;

        // Prepare the variables that will store the path to the local copy of the
        // GPO directories.
        PathAppend(m_szCustomDir, TEXT("Custom Settings.gpp")); // gpp is for group policy planning

        TCHAR szTempDir[MAX_PATH];
        StrCpy(szTempDir, m_szCustomDir);
        PathCreatePath(szTempDir);

        PathAppend(szTempDir, TEXT("Custom"));
        LPTSTR pszNum = szTempDir + StrLen(szTempDir);

        // need to impersonate the user when we go over the wire in case admin has
        // disabled/removed read access to GPO for authenticated users group

        // TODO: either delete impersonation code, or figure out how to get a valid
        // value for hToken;
//        g_SetUserToken(hToken);
        BOOL fImpersonate = FALSE; //ImpersonateLoggedOnUser(g_GetUserToken());
//        if (!fImpersonate)
//        {
//            OutD(LI0(TEXT("! Aborting further processing due to user impersonation failure.")));
//            hr = E_ACCESSDENIED;
//        }

        // pass 1: copy all the files to a temp dir and check to make sure everything
        // is in synch
        if (SUCCEEDED(hr))
        {
            // Loop through all changed GPOs in the list
            DWORD dwIndex = 0;
            for (pCurGPO = pUserTarget->pGPOList, dwIndex = 0; 
                    pCurGPO != NULL, dwIndex < dwTotalGPOs; pCurGPO = pCurGPO->pNext)
            {
                TCHAR szBaseDir[MAX_PATH];
                PathCombine(szBaseDir, pCurGPO->lpFileSysPath, TEXT("Microsoft\\Ieak\\install.ins"));

                if (PathFileExists(szBaseDir))
                {
                    PathRemoveFileSpec(szBaseDir);
                    
                    TCHAR szNum[8];
                    wnsprintf(szNum, countof(szNum), TEXT("%d"), dwIndex);
                    StrCpy(pszNum, szNum);

                    BOOL fResult = CreateDirectory(szTempDir, NULL) && CopyFileToDirEx(szBaseDir, szTempDir);

                    // branding files
                    TCHAR szFeatureDir[MAX_PATH];
                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_BRANDING_SUBDIR);
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES, 
                                GetPepCopyFilesEnumProc(), (LPARAM)szTempDir));
                    }

                    // desktop files
                    if (fResult)
                    {
                        PathCombine(szFeatureDir, szBaseDir, IEAK_GPE_DESKTOP_SUBDIR);
                        
                        if (PathFileExists(szFeatureDir))
                            fResult = SUCCEEDED(PathEnumeratePath(szFeatureDir, PEP_SCPE_NOFILES,
                                GetPepCopyFilesEnumProc(), (LPARAM)szTempDir));
                    }

                    if (!fResult)
                    {
                        Out(LI0(TEXT("! Error copying files. No further processing will be done.")));
                        break;
                    }

                    // check to see if cookie is there before doing anything
                    if (PathFileExistsInDir(IEAK_GPE_COOKIE_FILE, szTempDir))
                        break;

                    dwIndex++;
                }
            }
        }

        PathRemoveFileSpec(szTempDir);

        Out(LI0(TEXT("Finished copying directories.\r\n")));

        if (fImpersonate)
            RevertToSelf();

        if (pCurGPO != NULL)
        {
            OutD(LI0(TEXT("! Aborting further processing because GPO replication is incomplete")));
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            TCHAR szINSFile[MAX_PATH];
            PathCombine(szINSFile, m_szCustomDir, TEXT("Custom"));
            LPTSTR pszFile = szINSFile + StrLen(szINSFile);

            // Loop through all changed GPOs in the list
            DWORD dwIndex = 0;
            for (pCurGPO = pUserTarget->pGPOList, dwIndex = 0; 
                    pCurGPO != NULL, dwIndex < dwTotalGPOs; pCurGPO = pCurGPO->pNext)
            {
                // If the IEAK CSE guid is in the lpExtensions for this GPO, process it.
                OutD(LI1(TEXT("GPO - lpDisplayName: \"%s\"."), pCurGPO->lpDisplayName));
                OutD(LI1(TEXT("GPO - szGPOName: \"%s\"."), pCurGPO->szGPOName));
                OutD(LI1(TEXT("File path is \"%s\"."), pCurGPO->lpFileSysPath));

                if (DoesGPOHaveIEAKSettings(pCurGPO))
                {
                    // Store file system portion of GPO and the WBEM class instance in a
                    // new RSoP GPO object,  TODO: this had better be a copy of the actual
                    // data, just in case the data is modified mid-stream (check for planning mode)

                    // Because the GPO directory was already copied to a local directory for
                    // normal GP processing, and since we should make a copy anyway, we'll just
                    // use the copy already on our local machine (AppData directory).  We can
                    // therefore ignore the pCurGPO->lpFileSysPath.

                    TCHAR szCurrentFile[16];
                    wnsprintf(szCurrentFile, countof(szCurrentFile), TEXT("%d\\INSTALL.INS"), dwIndex);
                    StrCpy(pszFile, szCurrentFile);

                    OutD(LI1(TEXT("GPO file path is %s."), szINSFile));

                    CRSoPGPO GPO(m_pWbemServices, szINSFile);

                    // Convert directory service portion of GPO and the path to the Active
                    // Directory site, domain, or organization unit to which this GPO is linked.
                    // If the GPO is linked to the local GPO, this member is "Local". 
                    _bstr_t bstrGPODSPath = pCurGPO->lpDSPath;
                    LPWSTR wszStrippedGPO = StripGPOPrefix(bstrGPODSPath);

                    _bstr_t bstrGPOLink = pCurGPO->lpLink;
                    LPWSTR wszStrippedSOM = StripSOMPrefix(bstrGPOLink);

                    // GPOs are passed in the order in which they are to be processed.  The last
                    // one processed is precedence 1, 2nd to last is precedence 2, etc.
                    GPO.LogPolicyInstance(wszStrippedGPO, wszStrippedSOM, dwTotalGPOs - dwIndex);

                    dwIndex++;
                }
            }
        }

        PathRemovePath(szTempDir);

        Out(LI0(TEXT("Finished Internet Explorer RSoP group policy looping through GPOs ...")));
    }
    __except(TRUE)
    {
        OutD(LI0(TEXT("Exception in Plan.")));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\rsopcs.cpp ===
#include "precomp.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"

#include <rashelp.h>

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#include <winineti.h>

#include <tchar.h>


// Private forward decalarations
extern void setSzFromBlobA(PBYTE *ppBlob, UNALIGNED CHAR  **ppszStrA);
extern void setSzFromBlobW(PBYTE *ppBlob, UNALIGNED WCHAR **ppszStrW);

//----- Miscellaneous -----
extern DWORD getWininetFlagsSetting(PCTSTR pszName = NULL);

//TODO: UNCOMMENT   TCHAR g_szConnectoidName[RAS_MaxEntryName + 1];

///////////////////////////////////////////////////////////
SAFEARRAY *CreateSafeArray(VARTYPE vtType, long nElements, long nDimensions = 1)
{
	SAFEARRAYBOUND *prgsabound = NULL;
	SAFEARRAY *psa = NULL;
	__try
	{
		//TODO: support multiple dimensions
		nDimensions = 1;

		prgsabound = (SAFEARRAYBOUND *)CoTaskMemAlloc(sizeof(SAFEARRAYBOUND) * nDimensions);
		prgsabound[0].lLbound = 0;
		prgsabound[0].cElements = nElements;
		psa = ::SafeArrayCreate(vtType, nDimensions, prgsabound);

		CoTaskMemFree(prgsabound);
	}
	__except(TRUE)
	{
		if (NULL != prgsabound)
			CoTaskMemFree((LPVOID)prgsabound);
		throw;
	}
	return psa;
}


///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreConnectionSettings(BSTR *pbstrConnSettingsObjPath,
										  BSTR **ppaDUSObjects, long &nDUSCount,
										  BSTR **ppaDUCObjects, long &nDUCCount,
										  BSTR **ppaWSObjects, long &nWSCount)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreConnectionSettings)
	HRESULT hr = E_FAIL;
	__try
	{
		OutD(LI0(TEXT("\r\nEntered StoreConnectionSettings function.")));

		//
		// Create & populate RSOP_IEConnectionSettings
		//
		_bstr_t bstrClass = L"RSOP_IEConnectionSettings";
		ComPtr<IWbemClassObject> pCSObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pCSObj);
		if (SUCCEEDED(hr))
		{
			hr = StoreProxySettings(pCSObj); // also writes foreign key fields
			hr = StoreAutoBrowserConfigSettings(pCSObj);

			//------------------------------------------------
			// importCurrentConnSettings
			// No tri-state on this.  Disabled state has to be NULL!
			BOOL bValue = GetInsBool(IS_CONNECTSET, IK_OPTION, FALSE);
			if (bValue)
				hr = PutWbemInstancePropertyEx(L"importCurrentConnSettings", true, pCSObj);

			//------------------------------------------------
			// deleteExistingConnSettings
			// No tri-state on this.  Disabled state has to be NULL!
			bValue = GetInsBool(IS_CONNECTSET, IK_DELETECONN, FALSE);
			if (bValue)
				hr = PutWbemInstancePropertyEx(L"deleteExistingConnSettings", true, pCSObj);

			//
			// Advanced settings from cs.dat
			//
			hr = ProcessAdvancedConnSettings(pCSObj,
											ppaDUSObjects, nDUSCount,
											ppaDUCObjects, nDUCCount,
											ppaWSObjects, nWSCount);
			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			hr = PutWbemInstance(pCSObj, bstrClass, pbstrConnSettingsObjPath);
		}

	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreConnectionSettings.")));
	}

	OutD(LI0(TEXT("Exiting StoreConnectionSettings function.\r\n")));
  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreAutoBrowserConfigSettings(ComPtr<IWbemClassObject> pCSObj)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreAutoBrowserConfigSettings)
	HRESULT hr = E_FAIL;
	__try
	{
		//------------------------------------------------
		// autoConfigURL
	    TCHAR szValue[MAX_PATH];
		BOOL bEnabled;
		GetInsString(IS_URL, IK_AUTOCONFURL, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoConfigURL", szValue, pCSObj);

		//------------------------------------------------
		// autoConfigUseLocal
		BOOL bValue = GetInsBool(IS_URL, IK_LOCALAUTOCONFIG, FALSE, &bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoConfigUseLocal", bValue ? true : false, pCSObj);

		//------------------------------------------------
		// autoProxyURL
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_URL, IK_AUTOCONFURLJS, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoProxyURL", szValue, pCSObj);

		//------------------------------------------------
		// autoConfigTime
	    long nValue = GetInsInt(IS_URL, IK_AUTOCONFTIME, 0, &bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"autoConfigTime", nValue, pCSObj);

		//------------------------------------------------
		// autoDetectConfigSettings
		// No tri-state on this.  Disabled state has to be NULL!
		nValue = GetInsInt(IS_URL, IK_DETECTCONFIG, -1);
		if (TRUE == nValue)
			hr = PutWbemInstancePropertyEx(L"autoDetectConfigSettings", true, pCSObj);

		//------------------------------------------------
		// autoConfigEnable
		// No tri-state on this.  Disabled state has to be NULL!
		nValue = GetInsInt(IS_URL, IK_USEAUTOCONF,  -1);
		if (TRUE == nValue)
			hr = PutWbemInstancePropertyEx(L"autoConfigEnable", true, pCSObj);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreAutoBrowserConfigSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreProxySettings(ComPtr<IWbemClassObject> pCSObj)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreProxySettings)
	HRESULT hr = E_FAIL;
	__try
	{
		OutD(LI0(TEXT("\r\nEntered StoreProxySettings function.")));

		// Write foreign keys from our stored precedence & id fields
		OutD(LI1(TEXT("Storing property 'rsopPrecedence' in RSOP_IEConnectionSettings, value = %lx"),
									m_dwPrecedence));
		hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pCSObj);

		OutD(LI1(TEXT("Storing property 'rsopID' in RSOP_IEConnectionSettings, value = %s"),
									m_bstrID));
		hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pCSObj);

		//------------------------------------------------
		// enableProxy
		// No tri-state on this.  Disabled state has to be NULL!
		BOOL bValue = GetInsBool(IS_PROXY, IK_PROXYENABLE, TRUE);
		if (TRUE == bValue)
			hr = PutWbemInstancePropertyEx(L"enableProxy", true, pCSObj);

		//------------------------------------------------
		// useSameProxy
		BOOL bEnabled;
		bValue = GetInsBool(IS_PROXY, IK_SAMEPROXY, FALSE, &bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"useSameProxy", bValue ? true : false, pCSObj);

		//------------------------------------------------
		// httpProxyServer
		TCHAR szValue[MAX_PATH];
		GetInsString(IS_PROXY, IK_HTTPPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"httpProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// proxyOverride
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_PROXYOVERRIDE, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"proxyOverride", szValue, pCSObj);

		//------------------------------------------------
		// ftpProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_FTPPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"ftpProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// gopherProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_GOPHERPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"gopherProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// secureProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_SECPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"secureProxyServer", szValue, pCSObj);

		//------------------------------------------------
		// socksProxyServer
		ZeroMemory(szValue, sizeof(szValue));
		GetInsString(IS_PROXY, IK_SOCKSPROXY, szValue, countof(szValue), bEnabled);
		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"socksProxyServer", szValue, pCSObj);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreProxySettings.")));
	}

	OutD(LI0(TEXT("Exiting StoreProxySettings function.\r\n")));
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessAdvancedConnSettings(ComPtr<IWbemClassObject> pCSObj,
											  BSTR **ppaDUSObjects, long &nDUSCount,
											  BSTR **ppaDUCObjects, long &nDUCCount,
											  BSTR **ppaWSObjects, long &nWSCount)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessAdvancedConnSettings)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		LPRASDEVINFOW prdiW;
		TCHAR   szTargetFile[MAX_PATH],
				szApplyToName[RAS_MaxEntryName + 1];
		PCWSTR  pszCurNameW;
		PWSTR   pszNameW;
		PBYTE   pBuf, pCur;
		HANDLE  hFile;
		HRESULT hr;
		DWORD   dwVersion,
				cbBuffer, cbFile,
				cDevices;
		ULONG nNameArraySize = 0;
		BSTR *paNames = NULL;

		prdiW          = NULL;
		pszNameW       = NULL;
		pBuf           = NULL;
		hFile          = NULL;
		hr             = E_FAIL;
		cDevices       = 0;

		ULONG nDUSArraySize = 3;
		ULONG nDUCArraySize = 3;
		ULONG nWSArraySize = 4; // one extra for lan settings

		BSTR *paDUSObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nDUSArraySize);
		BSTR *paDUCObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nDUCArraySize);
		BSTR *paWSObjects = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nWSArraySize);

		ULONG nDUSObj = 0;
		ULONG nDUCObj = 0;
		ULONG nWSObj = 0;
		BSTR *pCurDUSObj = paDUSObjects;
		BSTR *pCurDUCObj = paDUCObjects;
		BSTR *pCurWSObj = paWSObjects;

		//----- Global settings processing -----

		//------------------------------------------------
		// dialupState
		long nDialupState = 0;
		BOOL bEnabled;
		if (GetInsBool(IS_CONNECTSET, IK_NONETAUTODIAL, FALSE, &bEnabled))
			nDialupState = 1;
		else if (GetInsBool(IS_CONNECTSET, IK_ENABLEAUTODIAL, FALSE, &bEnabled))
			nDialupState = 2;

		if (bEnabled)
			hr = PutWbemInstancePropertyEx(L"dialupState", nDialupState, pCSObj);


		DWORD dwAux = 0;
		BOOL fSkipBlob = FALSE;
		BOOL fRasApisLoaded = FALSE;

		//----- Process version information -----
		if (!InsGetBool(IS_CONNECTSET, IK_OPTION, FALSE, m_szINSFile)) {
			hr = S_FALSE;
			goto PartTwo;
		}

		// Locate the path for the cs.dat file
		TCHAR szTargetDir[MAX_PATH];
		StrCpy(szTargetDir, m_szINSFile);
		PathRemoveFileSpec(szTargetDir);
		PathCombine(szTargetFile, szTargetDir, CS_DAT);
		if (PathFileExists(szTargetFile))
			dwAux = CS_VERSION_5X;

		if (0 == dwAux) {
			PathCombine(szTargetFile, szTargetDir, CONNECT_SET);
			if (PathFileExists(szTargetFile))
				dwAux = CS_VERSION_50;

			else {
				Out(LI0(TEXT("Connection settings file(s) is absent!")));
				goto PartTwo;
			}
		}
		ASSERT(0 != dwAux);

		hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			Out(LI0(TEXT("! Connections settings file(s) can't be opened.")));
			hr = STG_E_ACCESSDENIED;
			goto PartTwo;
		}

		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
		ReadFile(hFile, &dwVersion, sizeof(dwVersion), &cbFile, NULL);

		if (CS_VERSION_50 == dwVersion) {
			if (CS_VERSION_50 != dwAux) {
				Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
				goto PartTwo;
			}

			CloseFile(hFile);
			hFile = NULL;

			// TODO: convert this to RSoP
			OutD(LI0(TEXT("Would have called lcy50_ProcessConnectionSettings.")));
	//UNCOMMENT        hr = lcy50_ProcessConnectionSettings();
			goto PartTwo;
		}
		else if (CS_VERSION_5X <= dwVersion && CS_VERSION_5X_MAX >= dwVersion) {
			if (CS_VERSION_5X != dwAux) {
				Out(LI0(TEXT("! Version of connections settings file(s) is mismatched.")));
				goto PartTwo;
			}
		}
		else {
			Out(LI0(TEXT("! Version information in connection settings file(s) is corrupted.")));
			goto PartTwo;
		}

		Out(LI1(TEXT("Connection settings file is \"%s\"."), CS_DAT));
		Out(LI1(TEXT("The version of connection settings file is 0x%lX.\r\n"), dwVersion));

		//----- Read CS file into internal memory buffer -----
		cbBuffer = GetFileSize(hFile, NULL);
		if (cbBuffer == 0xFFFFFFFF) {
			Out(LI0(TEXT("! Internal processing error.")));
			goto PartTwo;
		}
		cbBuffer -= sizeof(dwVersion);

		pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
		if (pBuf == NULL) {
			Out(LI0(TEXT("! Internal processing ran out of memory.")));
			hr = E_OUTOFMEMORY;
			goto PartTwo;
		}
		ZeroMemory(pBuf, cbBuffer);

		ReadFile (hFile, pBuf, cbBuffer, &cbFile, NULL);
		CloseFile(hFile);
		hFile = NULL;

		pCur = pBuf;

		//----- Get information about RAS devices on the local system -----
		if (!RasIsInstalled())
			Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!\r\n")));

		else {
			fRasApisLoaded = (RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) && g_pfnRasSetEntryPropertiesA != NULL);
			if (!fRasApisLoaded)
				Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed.\r\n")));
		}

		if (fRasApisLoaded) {
			RasEnumDevicesExW(&prdiW, NULL, &cDevices);
			if (cDevices == 0)
				Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
		}


		nNameArraySize = 5;
		paNames = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nNameArraySize);
		if (NULL != paNames)
		{
			ZeroMemory(paNames, sizeof(BSTR) * nNameArraySize);
			long nNameCount = 0;
			BOOL bNewConn = FALSE;

			//----- Main loop -----
			pszCurNameW = L"";
			hr = S_OK;

			if (NULL != paDUSObjects && NULL != paDUCObjects && NULL != paWSObjects)
			{
				ZeroMemory(paDUSObjects, sizeof(BSTR) * nDUSArraySize);
				ZeroMemory(paDUCObjects, sizeof(BSTR) * nDUCArraySize);
				ZeroMemory(paWSObjects, sizeof(BSTR) * nWSArraySize);

				nDUSCount = 0;
				nDUCCount = 0;
				nWSCount = 0;

				while (pCur < pBuf + cbBuffer && nDUSObj < nDUSArraySize &&
						nDUCObj < nDUCArraySize && nWSObj < nWSArraySize)
				{
					//_____ Determine connection name _____
					if (*((PDWORD)pCur) == CS_STRUCT_HEADER) {
						if (bNewConn)
						{
							bNewConn = FALSE;

							// Grow the names array if we've outgrown the current array
							if (nNameCount == (long)nNameArraySize)
							{
								paNames = (BSTR*)CoTaskMemRealloc(paNames, sizeof(BSTR) * (nNameArraySize + 5));
								if (NULL != paNames)
									nNameArraySize += 5;
							}

							// Add this name to the WMI array of connection name strings
							paNames[nNameCount] = SysAllocString(pszNameW);
							nNameCount++;
						}

						pCur += 2*sizeof(DWORD);
						setSzFromBlobW(&pCur, &pszNameW);
					}

					//_____ Special case no RAS or no RAS devices _____
					// NOTE: (andrewgu) in this case it makes sense to process wininet settings for LAN only.
					if (!fRasApisLoaded || cDevices == 0) {
						if (pszNameW != NULL || *((PDWORD)pCur) != CS_STRUCT_WININET) {
							pCur += *((PDWORD)(pCur + sizeof(DWORD)));
							continue;
						}

						ASSERT(pszNameW == NULL && *((PDWORD)pCur) == CS_STRUCT_WININET);
					}

					//_____ Main processing _____
					if (pszCurNameW != pszNameW) {
						fSkipBlob = FALSE;

						if (TEXT('\0') != *pszCurNameW)     // tricky: empty string is an invalid name
							Out(LI0(TEXT("Done.")));        // if not that, there were connections before

						if (NULL != pszNameW) {
							PCTSTR pszName;

							pszName = W2CT(pszNameW);
							Out(LI1(TEXT("Proccessing settings for \"%s\" connection..."), pszName));
						}
						else {
							Out(LI0(TEXT("Proccessing settings for LAN connection...")));

							// ASSUMPTION: (andrewgu) if connection settings marked branded in the registry -
							// LAN settings have already been enforced. (note, that technically it may not be
							// true - if there is no cs.dat and *.ins customized ras connection through
							// IK_APPLYTONAME)
							fSkipBlob = (g_CtxIs(CTX_GP) && g_CtxIs(CTX_MISC_PREFERENCES)) && FF_DISABLE != GetFeatureBranded(FID_CS_MAIN);
							if (fSkipBlob)
								Out(LI0(TEXT("These settings have been enforced through policies!\r\n")));
						}

						pszCurNameW = pszNameW;
					}

					if (fSkipBlob) {
						pCur += *((PDWORD)(pCur + sizeof(DWORD)));
						continue;
					}

					switch (*((PDWORD)pCur)) {
					case CS_STRUCT_RAS:
						bNewConn = TRUE;
						hr = ProcessRasCS(pszNameW, &pCur, prdiW, cDevices, pCSObj, pCurDUSObj);
						if (SUCCEEDED(hr))
						{
							nDUSCount++;

							// Grow the array of obj paths if we've outgrown the current array
							if (nDUSCount == (long)nDUSArraySize)
							{
								paDUSObjects = (BSTR*)CoTaskMemRealloc(paDUSObjects, sizeof(BSTR) * (nDUSArraySize + 3));
								if (NULL != paDUSObjects)
									nDUSArraySize += 3;
							}

							nDUSObj++;
							pCurDUSObj = paDUSObjects + nDUSCount;
						}
						else
							Out(LI1(TEXT("ProcessRasCS returned error: %lx"), hr));
						break;

					case CS_STRUCT_RAS_CREADENTIALS:
						bNewConn = TRUE;
						hr = ProcessRasCredentialsCS(pszNameW, &pCur, pCSObj, pCurDUCObj);
						if (SUCCEEDED(hr))
						{
							nDUCCount++;

							// Grow the array of obj paths if we've outgrown the current array
							if (nDUCCount == (long)nDUCArraySize)
							{
								paDUCObjects = (BSTR*)CoTaskMemRealloc(paDUCObjects, sizeof(BSTR) * (nDUCArraySize + 3));
								if (NULL != paDUCObjects)
									nDUCArraySize += 3;
							}

							nDUCObj++;
							pCurDUCObj = paDUCObjects + nDUCCount;
						}
						else
							Out(LI1(TEXT("ProcessRasCredentialsCS returned error: %lx"), hr));
						break;

					case CS_STRUCT_WININET:
						bNewConn = TRUE;
						hr = ProcessWininetCS(pszNameW, &pCur, pCSObj, pCurWSObj);
						if (SUCCEEDED(hr))
						{
							nWSCount++;

							// Grow the array of obj paths if we've outgrown the current array
							if (nWSCount == (long)nWSArraySize)
							{
								paWSObjects = (BSTR*)CoTaskMemRealloc(paWSObjects, sizeof(BSTR) * (nWSArraySize + 3));
								if (NULL != paWSObjects)
									nWSArraySize += 3;
							}

							nWSObj++;
							pCurWSObj = paWSObjects + nWSCount;
						}
						else
							Out(LI1(TEXT("ProcessWininetCS returned error: %lx"), hr));
						break;

					default:
						pCur += *((PDWORD)(pCur + sizeof(DWORD)));
						hr    = S_FALSE;
					}

					if (hr == E_UNEXPECTED) {
						Out(LI0(TEXT("! The settings file is corrupted beyond recovery.")));
						goto PartTwo;
					}
				}
			}
			else
			{
				paDUSObjects = NULL;
				paDUCObjects = NULL;
				paWSObjects = NULL;
			}

			// Create a SAFEARRAY from our array of bstr connection names
			SAFEARRAY *psa = CreateSafeArray(VT_BSTR, nNameCount);
			for (long nName = 0; nName < nNameCount; nName++) 
				SafeArrayPutElement(psa, &nName, paNames[nName]);

			if (nNameCount > 1)
			{
				VARIANT vtData;
				vtData.vt = VT_BSTR | VT_ARRAY;
				vtData.parray = psa;
				//------------------------------------------------
				// dialUpConnections
				hr = PutWbemInstancePropertyEx(L"dialUpConnections", vtData, pCSObj);
			}


			// free up the connection names array
			for (nName = 0; nName < nNameCount; nName++) 
				SysFreeString(paNames[nName]);
			SafeArrayDestroy(psa);
			CoTaskMemFree(paNames);

			*ppaDUSObjects = paDUSObjects;
			*ppaDUCObjects = paDUCObjects;
			*ppaWSObjects = paWSObjects;
		}

		Out(LI0(TEXT("Done.")));                    // to indicate end for the last connection

	PartTwo:
		//_____ Ins proxy and autoconfig information _____
		{ MACRO_LI_Offset(1);                       // need a new scope

		InsGetString(IS_CONNECTSET, IK_APPLYTONAME, szApplyToName, countof(szApplyToName), m_szINSFile);
	//TODO: UNCOMMENT       if (szApplyToName[0] == TEXT('\0') && g_szConnectoidName[0] != TEXT('\0'))
	//TODO: UNCOMMENT           StrCpy(szApplyToName, g_szConnectoidName);

		Out(LI0(TEXT("\r\n")));
		if (szApplyToName[0] == TEXT('\0'))
			Out(LI0(TEXT("Settings from the *.ins file will be applied to LAN connection!")));
		else
			Out(LI1(TEXT("Settings from the *.ins file will be applied to \"%s\" connection!"), szApplyToName));

		}                                           // end offset scope

		if (prdiW != NULL) {
			CoTaskMemFree(prdiW);
			prdiW = NULL;
		}

		if (fRasApisLoaded)
			RasPrepareApis(RPA_UNLOAD, FALSE);

		if (pBuf != NULL) {
			CoTaskMemFree(pBuf);
			pBuf = NULL;
		}

		if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
			CloseFile(hFile);
			hFile = NULL;
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessAdvancedConnSettings.")));
	}

	OutD(LI0(TEXT("Exiting ProcessAdvancedConnSettings function.\r\n")));
	return hr;
}

/*HRESULT lcy50_ProcessConnectionSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, lcy50_ProcessConnectionSettings)

    USES_CONVERSION;

    TCHAR  szTargetFile[MAX_PATH];
    HANDLE hFile;
    PBYTE  pBuf, pCur;
    DWORD  cbBuffer, cbAux,
           dwResult,
           cDevices;
    UINT   i;

    Out(LI0(TEXT("Connection settings are in IE5 format...")));

    hFile    = NULL;
    pBuf     = NULL;
    cbBuffer = 0;
    cbAux    = 0;
    cDevices = 0;

    //----- Connect.ras processing -----
    Out(LI1(TEXT("Processing RAS connections information from \"%s\"."), CONNECT_RAS));

		TCHAR szTargetDir[MAX_PATH];
    PathCombine(szTargetDir, m_szINSFile, TEXT("BRANDING\\cs"));
    PathCombine(szTargetFile, szTargetDir, CONNECT_RAS);
    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        LPRASDEVINFOA prdiA;
        LPRASENTRYA   preA;
        TCHAR szName[RAS_MaxEntryName + 1],
              szScript[MAX_PATH],
              szDeviceName[RAS_MaxDeviceName + 1],
              szKey[16];
        CHAR  szNameA[RAS_MaxEntryName + 1];
        PSTR  pszScriptA;
        DWORD cbRasEntry;
        UINT  j;
        BOOL  fRasApisLoaded;

        prdiA          = NULL;
        hFile          = NULL;
        fRasApisLoaded = FALSE;

        if (!RasIsInstalled()) {
            Out(LI0(TEXT("RAS support is not installed. Only LAN settings will be processed!")));
            goto RasExit;
        }

        //_____ Read Connect.ras into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto RasExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbBuffer = GetFileSize(hFile, NULL);
        if (cbBuffer == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto RasExit;
        }

        pBuf = (PBYTE)CoTaskMemAlloc(cbBuffer);
        if (pBuf == NULL) {
            Out(LI0(TEXT("! Internal processing ran out of memory.")));
            goto RasExit;
        }
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        if (*((PDWORD)pBuf) != CS_VERSION_50) {
            Out(LI0(TEXT("! The version information in this file is corrupted.")));
            goto RasExit;
        }

        //_____ Preload RAS dlls _____
        if (!RasPrepareApis(RPA_RASSETENTRYPROPERTIESA) || g_pfnRasSetEntryPropertiesA == NULL) {
            Out(LI0(TEXT("! Required RAS APIs failed to load. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }
        fRasApisLoaded = TRUE;

        //_____ Get information about RAS devices on the local system _____
        RasEnumDevicesExA(&prdiA, NULL, &cDevices);
        if (cDevices == 0) {
            Out(LI0(TEXT("There are no RAS devices to connect to. Only LAN settings will be processed!\r\n")));
            goto RasExit;
        }

        //_____ Parse through RAS connections information _____
        for (i = cbAux = 0, pCur = pBuf + sizeof(DWORD); TRUE; i++, pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (i > 0)
                Out(LI0(TEXT("\r\n")));

            wnsprintf(szKey, countof(szKey), IK_CONNECTNAME, i);
            InsGetString(IS_CONNECTSET, szKey, szName, countof(szName), g_GetIns());
            if (szName[0] == TEXT('\0')) {
                Out(LI2(TEXT("[%s], \"%s\" doesn't exist. There are no more RAS connections!"), IS_CONNECTSET, szKey));
                break;
            }

            wnsprintf(szKey, countof(szKey), IK_CONNECTSIZE, i);
            cbAux = InsGetInt(IS_CONNECTSET, szKey, 0, g_GetIns());
            if (cbAux == 0) {
                Out(LI0(TEXT("! The ins file is corrupt. No more RAS connections can be processed.")));
                break;
            }

            //- - - Main processing - - -
            Out(LI1(TEXT("Processing RAS connection \"%s\"..."), szName));

            preA = (LPRASENTRYA)pCur;

            // NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYA structure are
            // different on the server and client machines. there is nothing bad with server
            // structure being smaller than the client structure (all RAS apis are
            // backward-compatible). it's bad though when server structure is bigger than client
            // can handle, hence the trancation.
            // (something else to have in mind) this truncation should not affect alternate phone
            // numbers support on winnt. for more special cases also check out NOTE: below.
            if (preA->dwSize > sizeof(RASENTRYA))
                preA->dwSize = sizeof(RASENTRYA);

            // preA->szScript
            if (preA->szScript[0] != '\0') {
                pszScriptA = preA->szScript;
                if (preA->szScript[0] == '[')
                    pszScriptA = &preA->szScript[1];

                A2Tbuf(pszScriptA, szScript, countof(szScript));
                StrCpy(PathFindFileName(szTargetFile), PathFindFileName(szScript));
                if (PathFileExists(szTargetFile))
                    T2Abuf(szTargetFile, preA->szScript, MAX_PATH);

                else
                    preA->szScript[0] = '\0';
            }

            // preA->szDeviceName
            for (j = 0; j < cDevices; j++)
                if (0 == StrCmpIA(preA->szDeviceType, prdiA[j].szDeviceType)) {
                    StrCpyA(preA->szDeviceName, prdiA[j].szDeviceName);
                    break;
                }
            if (j >= cDevices)
                StrCpyA(preA->szDeviceName, prdiA[0].szDeviceName);

            A2Tbuf(preA->szDeviceName, szDeviceName, countof(szDeviceName));
            Out(LI1(TEXT("Set the device name to \"%s\"."), szDeviceName));

            // NOTE: (andrewgu) on win9x if there are alternate phone numbers (i.e. the package
            // installed on win9x machine was generated on winnt machine), cbAux will be larger
            // than preA->dwSize. this will fail with ERROR_INVALID_PARAMETER on win9x. hence on
            // this platform cbAux is reset so api has a chance of succeeding.
            cbRasEntry = cbAux;
            if (IsOS(OS_WINDOWS)) {
                preA->dwAlternateOffset = 0;
                cbRasEntry = preA->dwSize;
            }

            T2Abuf(szName, szNameA, countof(szNameA));
            dwResult = g_pfnRasSetEntryPropertiesA(NULL, szNameA, preA, cbRasEntry, NULL, 0);
            if (dwResult != ERROR_SUCCESS) {
                Out(LI1(TEXT("! Creating this RAS connection failed with %s."), GetHrSz(dwResult)));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
RasExit:
        if (fRasApisLoaded)
            RasPrepareApis(RPA_UNLOAD, FALSE);

        if (prdiA != NULL)
            CoTaskMemFree(prdiA);

        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }
    }

    //----- Connect.set processing -----
    Out(LI1(TEXT("\r\nProcessing Wininet.dll connections information from \"%s\"."), CONNECT_SET));
    StrCpy(PathFindFileName(szTargetFile), CONNECT_SET);

    if (!PathFileExists(szTargetFile))
        Out(LI0(TEXT("This file doesn't exist!")));

    else {
        INTERNET_PER_CONN_OPTION_LISTA listA;
        INTERNET_PER_CONN_OPTIONA      rgOptionsA[7];
        PBYTE pAux;

        //_____ Read Connect.set into internal memory buffer _____
        hFile = CreateFile(szTargetFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Out(LI0(TEXT("! This file can't be opened.")));
            goto WininetExit;
        }

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        cbAux = GetFileSize(hFile, NULL);
        if (cbAux == 0xFFFFFFFF) {
            Out(LI0(TEXT("! Internal processing error.")));
            goto WininetExit;
        }

        if (cbAux > cbBuffer) {
            pBuf = (PBYTE)CoTaskMemRealloc(pBuf, cbAux);
            if (pBuf == NULL) {
                Out(LI0(TEXT("! Internal processing ran out of memory.")));
                goto WininetExit;
            }
        }
        cbBuffer = cbAux;
        ZeroMemory(pBuf, cbBuffer);

        ReadFile(hFile, pBuf, cbBuffer, &cbAux, NULL);
        ASSERT(*((PDWORD)pBuf) == CS_VERSION_50);

        //_____ Parse through Wininet.dll connections information _____
        for (pCur = pBuf + sizeof(DWORD), cbAux = 0; pCur < (pBuf + cbBuffer); pCur += cbAux) {

            //- - - Initialization - - -
            MACRO_LI_Offset(1);
            if (pCur > (pBuf + sizeof(DWORD)))
                Out(LI0(TEXT("\r\n")));

            //- - - Main processing - - -
            pAux = pCur;

            cbAux = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            ZeroMemory(&listA, sizeof(listA));
            listA.dwSize   = sizeof(listA);     // listA.dwSize
            listA.pOptions = rgOptionsA;        // listA.pOptions

            // listA.pszConnection
            if (*pAux == NULL) {
                listA.pszConnection = NULL;
                pAux += sizeof(DWORD);
            }
            else {
                listA.pszConnection = (PSTR)pAux;
                pAux += StrCbFromSzA(listA.pszConnection);
            }

            // skip all but LAN settings if no RAS devices
            if (cDevices == 0 && listA.pszConnection != NULL)
                continue;

            if (listA.pszConnection == NULL)
                Out(LI0(TEXT("Proccessing Wininet.dll settings for LAN connection...")));
            else
                Out(LI1(TEXT("Proccessing Wininet.dll settings for \"%s\" connection..."),
                    A2CT(listA.pszConnection)));

            // listA.dwOptionCount
            listA.dwOptionCount = *((PDWORD)pAux);
            pAux += sizeof(DWORD);

            // listA.pOptions
            for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
                listA.pOptions[i].dwOption = *((PDWORD)pAux);
                pAux += sizeof(DWORD);

                switch (listA.pOptions[i].dwOption) {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    setSzFromBlobA(&pAux, &listA.pOptions[i].Value.pszValue);
                    break;

                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                default:                        // everything else is also DWORD
                    listA.pOptions[i].Value.dwValue = *((PDWORD)pAux);
                    pAux += sizeof(DWORD);
                    break;
                }
            }
            ASSERT(pAux == pCur + cbAux);

            if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP))) {
                ASSERT(listA.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

                if (HasFlag(listA.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
                    DWORD dwFlags;

                    dwFlags  = getWininetFlagsSetting(A2CT(listA.pszConnection));
                    dwFlags |= listA.pOptions[0].Value.dwValue;
                    listA.pOptions[0].Value.dwValue = dwFlags;
                }
                else {
                    Out(LI0(TEXT("No customizations!"))); // nothing to do since had only proxy
                    continue;                             // stuff to begin with. and now even
                }                                         // that is not there.
            }

            //- - - Merge new LAN's ProxyBypass settings with the existing ones - - -
            // NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
            // ins file as well, it makes no sense to do this here because what's in the ins
            // should overwrite what's in the imported connections settings.

            //- - - Call into Wininet.dll - - -
            if (FALSE == InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listA, listA.dwSize)) {
                Out(LI0(TEXT("! Processing of this Wininet.dll connection settings failed.")));
                continue;
            }

            Out(LI0(TEXT("Done.")));
        }
        Out(LI0(TEXT("Done.")));

        //_____ Cleanup _____
WininetExit:
        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
            CloseFile(hFile);
            hFile = NULL;
        }

        if (pBuf != NULL) {
            CoTaskMemFree(pBuf);
            pBuf = NULL;
        }
    }

    ASSERT(hFile == NULL);
    return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessRasCS(PCWSTR pszNameW, PBYTE *ppBlob,
							   LPRASDEVINFOW prdiW, UINT cDevices,
							   ComPtr<IWbemClassObject> pCSObj,
							   BSTR *pbstrConnDialUpSettingsObjPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRasCS)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		LPRASENTRYW preW;
		TCHAR   szTargetScript[MAX_PATH];
		PWSTR   pszScriptW;
		PBYTE   pCur;
		DWORD   dwSize, cbRasEntry;
		UINT    i;
		BOOL    fImpersonate;

		ASSERT(RasIsInstalled());
		ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL && prdiW != NULL && cDevices >= 1);

		//----- Validate the header -----
		pCur = *ppBlob;
		if (*((PDWORD)pCur) != CS_STRUCT_RAS)
			return E_UNEXPECTED;
		pCur += sizeof(DWORD);

		fImpersonate = FALSE;
		if (g_CtxIsGp())
			fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

		Out(LI0(TEXT("Processing RAS settings...")));

		dwSize = *((PDWORD)pCur);
		pCur  += sizeof(DWORD);

		//----- Main processing -----
		preW = (LPRASENTRYW)pCur;

		// NOTE: (andrewgu) the is a remote possibility that sizes of RASENTRYW structure are
		// different on the server and client machines. there is nothing bad with server structure
		// being smaller than the client structure (all RAS apis are backward-compatible). it's bad
		// though when server structure is bigger than client can handle, hence the trancation.
		// (something else to have in mind) this truncation should not affect alternate phone numbers
		// support on winnt.
		if (preW->dwSize > sizeof(RASENTRYW))
			preW->dwSize = sizeof(RASENTRYW);

		// preW->szScript
		if (preW->szScript[0] != L'\0') {
			pszScriptW = preW->szScript;
			if (preW->szScript[0] == L'[')
				pszScriptW = &preW->szScript[1];

					TCHAR szTargetDir[MAX_PATH];
					StrCpy(szTargetDir, m_szINSFile);
					PathCombine(szTargetScript, g_GetTargetPath(), PathFindFileName(W2CT(pszScriptW)));
			if (PathFileExists(szTargetScript))
				StrCpyW(preW->szScript, T2CW(szTargetScript));
			else
				preW->szScript[0] = L'\0';
		}

		// preW->szDeviceName
		for (i = 0; i < cDevices; i++) {
			if (0 == StrCmpIW(preW->szDeviceType, prdiW->szDeviceType)) {
				StrCpyW(preW->szDeviceName, prdiW->szDeviceName);
				break;
			}
		}
		if (i >= cDevices)
			StrCpyW(preW->szDeviceName, prdiW[0].szDeviceName);

		Out(LI1(TEXT("Set the device name to \"%s\"."), W2CT(preW->szDeviceName)));

		cbRasEntry = dwSize - 2*sizeof(DWORD);

		//
		// Create & populate RSOP_IEConnectionSettings
		//
		_bstr_t bstrClass = L"RSOP_IEConnectionDialUpSettings";
		ComPtr<IWbemClassObject> pDUSObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pDUSObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
										(BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pDUSObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
										(BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pDUSObj);

			//------------------------------------------------
			// connectionName
			hr = PutWbemInstancePropertyEx(L"connectionName", pszNameW, pDUSObj);

			//------------------------------------------------
			// rasEntryData
			SAFEARRAY *psa = CreateSafeArray(VT_UI1, cbRasEntry);
			void HUGEP *pData = NULL;
			hr = SafeArrayAccessData(psa, &pData);
			if (SUCCEEDED(hr))
			{
				memcpy(pData, preW, cbRasEntry);
				SafeArrayUnaccessData(psa);

				VARIANT vtData;
				vtData.vt = VT_UI1 | VT_ARRAY;
				vtData.parray = psa;
				hr = PutWbemInstancePropertyEx(L"rasEntryData", vtData, pDUSObj);
				SafeArrayDestroy(psa);
			}

			//------------------------------------------------
			// rasEntryDataSize
			hr = PutWbemInstancePropertyEx(L"rasEntryDataSize", (long)cbRasEntry, pDUSObj);

			//------------------------------------------------
			// options
			hr = PutWbemInstancePropertyEx(L"options", (long)preW->dwfOptions, pDUSObj);

			// Location/phone number
			hr = PutWbemInstancePropertyEx(L"countryID", (long)preW->dwCountryID, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"countryCode", (long)preW->dwCountryCode, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"areaCode", preW->szAreaCode, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"localPhoneNumber", preW->szLocalPhoneNumber, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"alternateOffset", (long)preW->dwAlternateOffset, pDUSObj);

			// PPP/Ip
			TCHAR szIPAddr[16];
			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddr.a, preW->ipaddr.b,
							preW->ipaddr.c, preW->ipaddr.d);
			hr = PutWbemInstancePropertyEx(L"ipAddress", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrDns.a,
							preW->ipaddrDns.b, preW->ipaddrDns.c, preW->ipaddrDns.d);
			hr = PutWbemInstancePropertyEx(L"ipDNSAddress", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrDnsAlt.a,
							preW->ipaddrDnsAlt.b, preW->ipaddrDnsAlt.c, preW->ipaddrDnsAlt.d);
			hr = PutWbemInstancePropertyEx(L"ipDNSAddressAlternate", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrWins.a,
							preW->ipaddrWins.b, preW->ipaddrWins.c, preW->ipaddrWins.d);
			hr = PutWbemInstancePropertyEx(L"ipWINSAddress", szIPAddr, pDUSObj);

			_stprintf(szIPAddr, _T("%d.%d.%d.%d"), preW->ipaddrWinsAlt.a,
							preW->ipaddrWinsAlt.b, preW->ipaddrWinsAlt.c, preW->ipaddrWinsAlt.d);
			hr = PutWbemInstancePropertyEx(L"ipWINSAddressAlternate", szIPAddr, pDUSObj);

			// Framing
			hr = PutWbemInstancePropertyEx(L"frameSize", (long)preW->dwFrameSize, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"netProtocols", (long)preW->dwfNetProtocols, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"framingProtocol", (long)preW->dwFramingProtocol, pDUSObj);

			// Scripting
			hr = PutWbemInstancePropertyEx(L"scriptFile", preW->szScript, pDUSObj);

		  // AutoDial
			hr = PutWbemInstancePropertyEx(L"autodialDll", preW->szAutodialDll, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"autodialFunction", preW->szAutodialFunc, pDUSObj);

		  // Device
			hr = PutWbemInstancePropertyEx(L"deviceType", preW->szDeviceType, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"deviceName", preW->szDeviceName, pDUSObj);

		  // X.25
			hr = PutWbemInstancePropertyEx(L"x25PadType", preW->szX25PadType, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"x25Address", preW->szX25Address, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"x25Facilities", preW->szX25Facilities, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"x25UserData", preW->szX25UserData, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"channels", (long)preW->dwChannels, pDUSObj);

		  // Reserved
			hr = PutWbemInstancePropertyEx(L"reserved1", (long)preW->dwReserved1, pDUSObj);
			hr = PutWbemInstancePropertyEx(L"reserved2", (long)preW->dwReserved2, pDUSObj);

			// We don't need to worry about dwAlternateOffset here.  It doesn't affect
			// the size of the structure.
			//
			// RASENTRY structure:
			// 
			// VERSION						ANSI size		UNICODE size
			// -------------			---------		------------
			// WINVER <	 401			1768				3468
			// WINVER >= 401			1796				3496
			// WINVER >= 500			2088				4048
			// WINVER >= 501			2096				4056
			DWORD nWinVerAtLeast = 1;
#ifdef UNICODE
			if (4056 == cbRasEntry)
				nWinVerAtLeast = 0x501;
			else if (4048 == cbRasEntry)
				nWinVerAtLeast = 0x500;
			else if (3496 == cbRasEntry)
				nWinVerAtLeast = 0x401;
			else if (3468 == cbRasEntry)
				nWinVerAtLeast = 0x1;
#else
			if (2096 == cbRasEntry)
				nWinVerAtLeast = 0x501;
			else if (2088 == cbRasEntry)
				nWinVerAtLeast = 0x500;
			else if (1796 == cbRasEntry)
				nWinVerAtLeast = 0x401;
			else if (1768 == cbRasEntry)
				nWinVerAtLeast = 0x1;
#endif

			//
			// #if (WINVER >= 0x401)
			//
			if (nWinVerAtLeast >= 0x401)
			{
				// Multilink
				hr = PutWbemInstancePropertyEx(L"subEntries", (long)preW->dwSubEntries, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"dialMode", (long)preW->dwDialMode, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"dialExtraPercent", (long)preW->dwDialExtraPercent, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"dialExtraSampleSeconds", (long)preW->dwDialExtraSampleSeconds, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"hangUpExtraPercent", (long)preW->dwHangUpExtraPercent, pDUSObj);
				hr = PutWbemInstancePropertyEx(L"hangUpExtraSampleSeconds", (long)preW->dwHangUpExtraSampleSeconds, pDUSObj);

				// Idle timeout
				hr = PutWbemInstancePropertyEx(L"idleDisconnectSeconds", (long)preW->dwIdleDisconnectSeconds, pDUSObj);
			}

			//
			// #if (WINVER >= 0x500)
			//
			if (nWinVerAtLeast >= 0x500)
			{
			  // Entry Type
				hr = PutWbemInstancePropertyEx(L"type", (long)preW->dwType, pDUSObj);

				// Encryption type
				hr = PutWbemInstancePropertyEx(L"encryptionType", (long)preW->dwEncryptionType, pDUSObj);

				// CustomAuthKey to be used for EAP
				hr = PutWbemInstancePropertyEx(L"customAuthenticationKey", (long)preW->dwCustomAuthKey, pDUSObj);

				// Guid of the connection
				WCHAR wszGuid[MAX_GUID_LENGTH];
				StringFromGUID2(preW->guidId, wszGuid, MAX_GUID_LENGTH);
				hr = PutWbemInstancePropertyEx(L"guidID", wszGuid, pDUSObj);

				// Custom Dial Dll
				hr = PutWbemInstancePropertyEx(L"customDialDll", preW->szCustomDialDll, pDUSObj);

				// DwVpnStrategy
				hr = PutWbemInstancePropertyEx(L"vpnStrategy", (long)preW->dwVpnStrategy, pDUSObj);
			}

			//
			// #if (WINVER >= 0x501)
			//
			if (nWinVerAtLeast >= 0x501)
			{
				// More RASEO_* options
				hr = PutWbemInstancePropertyEx(L"options2", (long)preW->dwfOptions2, pDUSObj);

				// For future use
				hr = PutWbemInstancePropertyEx(L"options3", (long)preW->dwfOptions3, pDUSObj);
			}

			// Store the windows version is of the machine where the structure
			// was originally from (we think).
			hr = PutWbemInstancePropertyEx(L"windowsVersion", (long)nWinVerAtLeast, pDUSObj);

			//alternatePhoneNumbers - ignored for now (see brandcs.cpp  - search on dwAlternateOffset
//				hr = PutWbemInstancePropertyEx(L"alternatePhoneNumbers", NULL, pDUSObj);


			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			hr = PutWbemInstance(pDUSObj, bstrClass, pbstrConnDialUpSettingsObjPath);
		}

		*ppBlob += dwSize;

		Out(LI0(TEXT("Done.")));
		if (fImpersonate)
			RevertToSelf();
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessRasCS.")));
	}

	OutD(LI0(TEXT("Exiting ProcessRasCS function.\r\n")));
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessRasCredentialsCS(PCWSTR pszNameW, PBYTE *ppBlob,
										  ComPtr<IWbemClassObject> pCSObj,
										  BSTR *pbstrConnDialUpCredObjPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessRasCredentialsCS)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		ASSERT(RasIsInstalled());
		ASSERT(pszNameW != NULL && ppBlob != NULL && *ppBlob != NULL);

		//----- Validate the header -----
		PBYTE pCur = *ppBlob;
		if (*((PDWORD)pCur) != CS_STRUCT_RAS_CREADENTIALS)
			return E_UNEXPECTED;
		pCur += sizeof(DWORD);

		BOOL fImpersonate = ImpersonateLoggedOnUser(g_GetUserToken());

		Out(LI0(TEXT("Processing RAS credentials settings...")));
		BOOL fDeletePassword = FALSE;

		DWORD dwSize = *((PDWORD)pCur);
		pCur  += sizeof(DWORD);

		//----- Main processing -----
		RASDIALPARAMSW rdpW;
		ZeroMemory(&rdpW, sizeof(rdpW));
		rdpW.dwSize = sizeof(rdpW);

		StrCpyW(rdpW.szEntryName, pszNameW);

		PWSTR pszAuxW;
		setSzFromBlobW(&pCur, &pszAuxW);
		if (NULL != pszAuxW)
			StrCpyW(rdpW.szUserName, pszAuxW);

		setSzFromBlobW(&pCur, &pszAuxW);
		if (NULL != pszAuxW)
			StrCpyW(rdpW.szPassword, pszAuxW);

		setSzFromBlobW(&pCur, &pszAuxW);
		if (NULL != pszAuxW)
			StrCpyW(rdpW.szDomain, pszAuxW);

		if (rdpW.szPassword[0] == L'\0')
			fDeletePassword = TRUE;

		if (rdpW.szDomain[0] == L'\0') {
			rdpW.szDomain[0]  = L' ';
			ASSERT(rdpW.szDomain[1] == L'\0');
		}

		hr = S_OK;

		_bstr_t bstrClass = L"RSOP_IEConnectionDialUpCredentials";
		ComPtr<IWbemClassObject> pDUCObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pDUCObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
										(BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pDUCObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
										(BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pDUCObj);

			//------------------------------------------------
			// connectionName
			hr = PutWbemInstancePropertyEx(L"connectionName", pszNameW, pDUCObj);

			//------------------------------------------------
			// rasDialParamsData
			SAFEARRAY *psa = CreateSafeArray(VT_UI1, rdpW.dwSize);
			void HUGEP *pData = NULL;
			hr = SafeArrayAccessData(psa, &pData);
			if (SUCCEEDED(hr))
			{
				memcpy(pData, &rdpW, rdpW.dwSize);
				SafeArrayUnaccessData(psa);

				VARIANT vtData;
				vtData.vt = VT_UI1 | VT_ARRAY;
				vtData.parray = psa;
				hr = PutWbemInstancePropertyEx(L"rasDialParamsData", vtData, pDUCObj);
				SafeArrayDestroy(psa);
			}

			//------------------------------------------------
			// rasDialParamsDataSize
			hr = PutWbemInstancePropertyEx(L"rasDialParamsDataSize", (long)rdpW.dwSize, pDUCObj);

			//------------------------------------------------
			// entryName
			hr = PutWbemInstancePropertyEx(L"entryName", rdpW.szEntryName, pDUCObj);

			//------------------------------------------------
			// phoneNumber
			hr = PutWbemInstancePropertyEx(L"phoneNumber", rdpW.szPhoneNumber, pDUCObj);

			//------------------------------------------------
			// callbackNumber
			hr = PutWbemInstancePropertyEx(L"callbackNumber", rdpW.szCallbackNumber, pDUCObj);

			//------------------------------------------------
			// userName
			hr = PutWbemInstancePropertyEx(L"userName", rdpW.szUserName, pDUCObj);

			//------------------------------------------------
			// password
			hr = PutWbemInstancePropertyEx(L"password", rdpW.szPassword, pDUCObj);

			//------------------------------------------------
			// domain
			hr = PutWbemInstancePropertyEx(L"domain", rdpW.szDomain, pDUCObj);

			// RASDIALPARAMS structure:
			// 
			// VERSION						ANSI size		UNICODE size
			// -------------			---------		------------
			// WINVER <	 401			1052				2096
			// WINVER >= 401			1060				2104
			DWORD nWinVerAtLeast = 1;
#ifdef UNICODE
			if (2104 == rdpW.dwSize)
				nWinVerAtLeast = 0x401;
			else if (2096 == rdpW.dwSize)
				nWinVerAtLeast = 0x1;
#else
			if (1060 == rdpW.dwSize)
				nWinVerAtLeast = 0x401;
			else if (1052 == rdpW.dwSize)
				nWinVerAtLeast = 0x1;
#endif

			//
			// #if (WINVER >= 0x401)
			//
			if (nWinVerAtLeast >= 0x401)
			{
				//------------------------------------------------
				// subEntry
				hr = PutWbemInstancePropertyEx(L"subEntry", (long)rdpW.dwSubEntry, pDUCObj);

				//------------------------------------------------
				// callbackID
				hr = PutWbemInstancePropertyEx(L"callbackID", (long)rdpW.dwCallbackId, pDUCObj);
			}

			// Store the windows version is of the machine where the structure
			// was originally from (we think).
			hr = PutWbemInstancePropertyEx(L"windowsVersion", (long)nWinVerAtLeast, pDUCObj);


			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			hr = PutWbemInstance(pDUCObj, bstrClass, pbstrConnDialUpCredObjPath);
		}

		Out(LI0(TEXT("Done.")));
		*ppBlob += dwSize;
		if (fImpersonate)
			RevertToSelf();
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessRasCredentialsCS.")));
	}

	OutD(LI0(TEXT("Exiting ProcessRasCredentialsCS function.\r\n")));
	return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CRSoPGPO::ProcessWininetCS(PCWSTR pszNameW, PBYTE *ppBlob,
								   ComPtr<IWbemClassObject> pCSObj,
								   BSTR *pbstrConnWinINetSettingsObjPath)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ProcessWininetCS)

    USES_CONVERSION;

	HRESULT hr = E_FAIL;
	__try
	{
		ASSERT(ppBlob != NULL && *ppBlob != NULL);

		//----- Validate the header -----
		PBYTE pCur = *ppBlob;
		if (*((PDWORD)pCur) != CS_STRUCT_WININET)
			hr = E_UNEXPECTED;
		else
		{
			pCur += sizeof(DWORD);

			Out(LI0(TEXT("Processing Wininet.dll settings...")));

			DWORD dwSize = *((PDWORD)pCur);
			pCur  += sizeof(DWORD);

			//----- Main processing -----
			INTERNET_PER_CONN_OPTION_LISTW listW;
			ZeroMemory(&listW, sizeof(listW));
			listW.dwSize   = sizeof(listW);             // listW.dwSize

			INTERNET_PER_CONN_OPTIONW rgOptionsW[7];
			listW.pOptions = rgOptionsW;                // listW.pOptions

			// listW.pszConnection
			listW.pszConnection = (PWSTR)pszNameW;

			// listW.dwOptionCount
			listW.dwOptionCount = *((PDWORD)pCur);
			pCur += sizeof(DWORD);

			// listW.pOptions
			UINT i;
			for (i = 0; i < min(listW.dwOptionCount, countof(rgOptionsW)); i++) {
				listW.pOptions[i].dwOption = *((PDWORD)pCur);
				pCur += sizeof(DWORD);

				switch (listW.pOptions[i].dwOption) {
				case INTERNET_PER_CONN_PROXY_SERVER:
				case INTERNET_PER_CONN_PROXY_BYPASS:
				case INTERNET_PER_CONN_AUTOCONFIG_URL:
				case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
					setSzFromBlobW(&pCur, &listW.pOptions[i].Value.pszValue);
					break;

				case INTERNET_PER_CONN_FLAGS:
				case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
				case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
				default:                        // everything else is also DWORD
					listW.pOptions[i].Value.dwValue = *((PDWORD)pCur);
					pCur += sizeof(DWORD);
					break;
				}
			}
			ASSERT(pCur == *ppBlob + dwSize);

			_bstr_t bstrClass = L"RSOP_IEConnectionWinINetSettings";
			ComPtr<IWbemClassObject> pWSObj = NULL;

			if (HasFlag(g_GetContext(), (CTX_ISP | CTX_ICP)))
			{
				ASSERT(listW.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

				if (HasFlag(listW.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY))
				{
					DWORD dwFlags = getWininetFlagsSetting(W2CT(listW.pszConnection));
					dwFlags |= listW.pOptions[0].Value.dwValue;
					listW.pOptions[0].Value.dwValue = dwFlags;
				}
				else
				{
					hr = S_OK;                            // nothing to do since had only proxy stuff to
					Out(LI0(TEXT("No customizations!"))); // begin with. and now even that is not there
					goto Exit;
				}
			}

			//----- Merge new LAN's ProxyBypass settings with the existing ones -----
			// NOTE: (andrewgu) since ieakeng.dll will always save the proxy information into the
			// ins file as well, it makes no sense to do this here because what's in the ins
			// should overwrite what's in the imported connections settings.

			hr = S_OK;

			hr = CreateRSOPObject(bstrClass, &pWSObj);
			if (SUCCEEDED(hr))
			{
				// Write foreign keys from our stored precedence & id fields
				OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
											(BSTR)bstrClass, m_dwPrecedence));
				hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pWSObj);

				OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
											(BSTR)bstrClass, (BSTR)m_bstrID));
				hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pWSObj);

				//------------------------------------------------
				// connectionName
				OutD(LI1(TEXT("WinINet connection name = %s"), NULL == pszNameW ? _T("{local LAN settings}") : pszNameW));
				hr = PutWbemInstancePropertyEx(L"connectionName", NULL == pszNameW ? L"" : pszNameW, pWSObj);

				//------------------------------------------------
				// internetPerConnOptionListData
				SAFEARRAY *psa = CreateSafeArray(VT_UI1, listW.dwSize);
				void HUGEP *pData = NULL;
				hr = SafeArrayAccessData(psa, &pData);
				if (SUCCEEDED(hr))
				{
					memcpy(pData, &listW, listW.dwSize);
					SafeArrayUnaccessData(psa);

					VARIANT vtData;
					vtData.vt = VT_UI1 | VT_ARRAY;
					vtData.parray = psa;
					hr = PutWbemInstancePropertyEx(L"internetPerConnOptionListData", vtData, pWSObj);
				SafeArrayDestroy(psa);
				}

				//------------------------------------------------
				// internetPerConnOptionListDataSize
				hr = PutWbemInstancePropertyEx(L"internetPerConnOptionListDataSize", (long)listW.dwSize, pWSObj);


				//
				// Commit all above properties by calling PutInstance, semisynchronously
				//
				hr = PutWbemInstance(pWSObj, bstrClass, pbstrConnWinINetSettingsObjPath);
			}

		Exit:
			Out(LI0(TEXT("Done.")));
			*ppBlob += dwSize;
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ProcessWininetCS.")));
	}

	OutD(LI0(TEXT("Exiting ProcessWininetCS function.\r\n")));
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\rsopsec.cpp ===
#include "precomp.h"

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"

#include <tchar.h>
#include <wincrypt.h>


#define g_dwMsgAndCertEncodingType  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, _bstr_t &xbstrWbemTime);


extern SAFEARRAY *CreateSafeArray(VARTYPE vtType, long nElements, long nDimensions = 1);

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreStringArrayFromIniFile(LPCTSTR szSection, LPCTSTR szKeyFormat,
											  ULONG nArrayInitialSize, ULONG nArrayIncSize,
											  LPCTSTR szFile, BSTR bstrPropName,
											  ComPtr<IWbemClassObject> pWbemObj)
{
	HRESULT hr = NOERROR;
	__try
	{
		ULONG nStrArraySize = nArrayInitialSize;
		BSTR *paStrs = (BSTR*)CoTaskMemAlloc(sizeof(BSTR) * nStrArraySize);
		if (NULL != paStrs)
		{
			ZeroMemory(paStrs, sizeof(BSTR) * nStrArraySize);
			long nStrCount = 0;

			TCHAR szKey[32];
			for (int nItem = 0; ; nItem++)
			{
				wnsprintf(szKey, countof(szKey), szKeyFormat, nItem);

				TCHAR szValue[MAX_PATH];
				if (!GetPrivateProfileString(szSection, szKey, TEXT(""), szValue, ARRAYSIZE(szValue), szFile))
					break;

				// Grow the strings array if we've outgrown the current array
				if (nStrCount == (long)nStrArraySize)
				{
					paStrs = (BSTR*)CoTaskMemRealloc(paStrs, sizeof(BSTR) * (nStrArraySize + nArrayIncSize));
					if (NULL != paStrs)
						nStrArraySize += nArrayIncSize;
				}

				// Add this string to the WMI array of strings
				paStrs[nStrCount] = SysAllocString(szValue);
				nStrCount++;
			}

			// Create a SAFEARRAY from our array of bstr strings
			SAFEARRAY *psa = CreateSafeArray(VT_BSTR, nStrCount);
			for (long nStr = 0; nStr < nStrCount; nStr++) 
				SafeArrayPutElement(psa, &nStr, paStrs[nStr]);

			if (nStrCount > 0)
			{
				VARIANT vtData;
				vtData.vt = VT_BSTR | VT_ARRAY;
				vtData.parray = psa;

				//------------------------------------------------
				// bstrPropName
				hr = PutWbemInstancePropertyEx(bstrPropName, vtData, pWbemObj);
			}

			// free up the strings array
			for (nStr = 0; nStr < nStrCount; nStr++) 
				SysFreeString(paStrs[nStr]);
			SafeArrayDestroy(psa);
			CoTaskMemFree(paStrs);
		}
	}
	__except(TRUE)
	{
	}
	return hr;
}


///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreSecZonesAndContentRatings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreSecZonesAndContentRatings)
	HRESULT hr = NOERROR;
	__try
	{
		//------------------------------------------------
		// importSecurityZoneSettings
		BOOL bValue = GetInsBool(SECURITY_IMPORTS, TEXT("ImportSecZones"), FALSE);
		if (bValue)
			hr = PutWbemInstanceProperty(L"importSecurityZoneSettings", true);

		// TODO: eventually create associations to these security classes from
		// RSOP_IEAKPolicySetting

		// First open the INF file and get 2 contexts going - for HKLM and for HKCU
		// Get the path of the seczones.inf file
		TCHAR szRSOPZoneFile[MAX_PATH];
		TCHAR szRSOPRatingsFile[MAX_PATH];

		StrCpy(szRSOPZoneFile, m_szINSFile);
		PathRemoveFileSpec(szRSOPZoneFile);
		StrCpy(szRSOPRatingsFile, szRSOPZoneFile);

		StrCat(szRSOPZoneFile, TEXT("\\seczrsop.inf"));
		OutD(LI1(TEXT("Reading from %s"), szRSOPZoneFile));

		hr = StoreZoneSettings(szRSOPZoneFile);

		StrCat(szRSOPRatingsFile, TEXT("\\ratrsop.inf"));
		OutD(LI1(TEXT("Reading from %s"), szRSOPRatingsFile));

		hr = StoreRatingsSettings(szRSOPRatingsFile);

		//------------------------------------------------
		// importContentRatingsSettings
		bValue = GetInsBool(SECURITY_IMPORTS, TEXT("ImportRatings"), FALSE);
		if (bValue)
			hr = PutWbemInstanceProperty(L"importContentRatingsSettings", true);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreSecZonesAndContentRatings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreZoneSettings(LPCTSTR szFile)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreZoneSettings)

	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IESecurityZoneSettings";

		DWORD dwZoneCount = GetPrivateProfileInt(SECURITY_IMPORTS, IK_ZONES, 0, szFile);
		
		//------------------------------------------------
		// importedZoneCount
		if (dwZoneCount > 0)
			hr = PutWbemInstanceProperty(L"importedZoneCount", (long)dwZoneCount);

		TCHAR szSection[32];
		for (UINT nZone = 0; nZone < dwZoneCount; nZone++)
		{
			for (int nHKLM = 0; nHKLM < 2; nHKLM++)
			{
				ComPtr<IWbemClassObject> pZoneObj = NULL;
				hr = CreateRSOPObject(bstrClass, &pZoneObj);
				if (SUCCEEDED(hr))
				{
					BOOL fUseHKLM = (0 == nHKLM) ? FALSE : TRUE;
					wnsprintf(szSection, countof(szSection),
								fUseHKLM ? IK_ZONE_HKLM_FMT : IK_ZONE_HKCU_FMT, nZone);

					// Write foreign keys from our stored precedence & id fields
					OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
					hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pZoneObj);

					OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
					hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pZoneObj);

					//------------------------------------------------
					// zoneIndex
					hr = PutWbemInstancePropertyEx(L"zoneIndex", (long)nZone, pZoneObj);

					//------------------------------------------------
					// useHKLM
					hr = PutWbemInstancePropertyEx(L"useHKLM", fUseHKLM ? true : false, pZoneObj);

					//
					// Get the zone attributes
					//

					//------------------------------------------------
					// displayName
					TCHAR szValue[MAX_PATH];
			        GetPrivateProfileString(szSection, IK_DISPLAYNAME, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
					hr = PutWbemInstancePropertyEx(L"displayName", szValue, pZoneObj);

					//------------------------------------------------
					// description
			        GetPrivateProfileString(szSection, IK_DESCRIPTION, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
					hr = PutWbemInstancePropertyEx(L"description", szValue, pZoneObj);

					//------------------------------------------------
					// iconPath
			        GetPrivateProfileString(szSection, IK_ICONPATH, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
					hr = PutWbemInstancePropertyEx(L"iconPath", szValue, pZoneObj);


					//------------------------------------------------
					// minimumTemplateLevel
			        DWORD dwValue = GetPrivateProfileInt(szSection, IK_MINLEVEL, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"minimumTemplateLevel", (long)dwValue, pZoneObj);

					//------------------------------------------------
					// recommendedTemplateLevel
			        dwValue = GetPrivateProfileInt(szSection, IK_RECOMMENDLEVEL, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"recommendedTemplateLevel", (long)dwValue, pZoneObj);

					//------------------------------------------------
					// currentTemplateLevel
			        dwValue = GetPrivateProfileInt(szSection, IK_CURLEVEL, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"currentTemplateLevel", (long)dwValue, pZoneObj);

					//------------------------------------------------
					// flags
			        dwValue = GetPrivateProfileInt(szSection, IK_FLAGS, 0, szFile);
					hr = PutWbemInstancePropertyEx(L"flags", (long)dwValue, pZoneObj);


					// Get the zone action settings
					//------------------------------------------------
					// actionValues
					hr = StoreStringArrayFromIniFile(szSection, IK_ACTIONVALUE_FMT,
													30, 5, szFile, L"actionValues",
													pZoneObj);

					// write out zone mappings
					//------------------------------------------------
					// zoneMappings
					hr = StoreStringArrayFromIniFile(szSection, IK_MAPPING_FMT,
													20, 5, szFile, L"zoneMappings",
													pZoneObj);


					//
					// Commit all above properties by calling PutInstance, semisynchronously
					//
					BSTR bstrNewObjPath = NULL;
					hr = PutWbemInstance(pZoneObj, bstrClass, &bstrNewObjPath);
				}
			}
		}

		// Now store privacy settings which are interdependent with security zones
		hr = StorePrivacySettings(szFile);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreZoneSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StorePrivacySettings(LPCTSTR szFile)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StorePrivacySettings)

	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IEPrivacySettings";

		ComPtr<IWbemClassObject> pPrivObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pPrivObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pPrivObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pPrivObj);

			// Store privacy settings
			//------------------------------------------------
			// firstPartyPrivacyType
			DWORD dwValue = GetPrivateProfileInt(IK_PRIVACY, IK_PRIV_1PARTY_TYPE, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"firstPartyPrivacyType", (long)dwValue, pPrivObj);

			//------------------------------------------------
			// firstPartyPrivacyTypeText
			TCHAR szValue[MAX_PATH];
			GetPrivateProfileString(IK_PRIVACY, IK_PRIV_1PARTY_TYPE_TEXT, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
			hr = PutWbemInstancePropertyEx(L"firstPartyPrivacyTypeText", szValue, pPrivObj);

			//------------------------------------------------
			// thirdPartyPrivacyType
			dwValue = GetPrivateProfileInt(IK_PRIVACY, IK_PRIV_3PARTY_TYPE, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"thirdPartyPrivacyType", (long)dwValue, pPrivObj);

			//------------------------------------------------
			// thirdPartyPrivacyTypeText
			GetPrivateProfileString(IK_PRIVACY, IK_PRIV_3PARTY_TYPE_TEXT, TEXT(""), szValue, ARRAYSIZE(szValue), szFile);
			hr = PutWbemInstancePropertyEx(L"thirdPartyPrivacyTypeText", szValue, pPrivObj);

			//------------------------------------------------
			// useAdvancedSettings
			dwValue = GetPrivateProfileInt(IK_PRIVACY, IK_PRIV_ADV_SETTINGS, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"useAdvancedSettings", (0 == dwValue) ? false : true, pPrivObj);

			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			BSTR bstrNewObjPath = NULL;
			hr = PutWbemInstance(pPrivObj, bstrClass, &bstrNewObjPath);
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StorePrivacySettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreRatingsSettings(LPCTSTR szFile)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreRatingsSettings)

	HRESULT hr = NOERROR;
	__try
	{
		_bstr_t bstrClass = L"RSOP_IESecurityContentRatings";

		ComPtr<IWbemClassObject> pRatObj = NULL;
		hr = CreateRSOPObject(bstrClass, &pRatObj);
		if (SUCCEEDED(hr))
		{
			// Write foreign keys from our stored precedence & id fields
			OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"), (BSTR)bstrClass, m_dwPrecedence));
			hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pRatObj);

			OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"), (BSTR)bstrClass, (BSTR)m_bstrID));
			hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pRatObj);

			// Store rating system filenames
			//------------------------------------------------
			// ratingSystemFileNames
			hr = StoreStringArrayFromIniFile(IK_FF_GENERAL, TEXT("FileName%i"),
											10, 5, szFile, L"ratingSystemFileNames",
											pRatObj);

			//------------------------------------------------
			// viewUnknownRatedSites
			DWORD dwValue = GetPrivateProfileInt(IK_FF_GENERAL, VIEW_UNKNOWN_RATED_SITES, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"viewUnknownRatedSites", (0 == dwValue) ? false : true, pRatObj);

			//------------------------------------------------
			// passwordOverrideEnabled
			dwValue = GetPrivateProfileInt(IK_FF_GENERAL, PASSWORD_OVERRIDE_ENABLED, 0, szFile);
			hr = PutWbemInstancePropertyEx(L"passwordOverrideEnabled", (0 == dwValue) ? false : true, pRatObj);

			// Store approved sites
			//------------------------------------------------
			// alwaysViewableSites
			hr = StoreStringArrayFromIniFile(IK_FF_GENERAL, TEXT("Approved%i"),
											10, 5, szFile, L"alwaysViewableSites",
											pRatObj);

			// Store disapproved sites
			//------------------------------------------------
			// neverViewableSites
			hr = StoreStringArrayFromIniFile(IK_FF_GENERAL, TEXT("Disapproved%i"),
											10, 5, szFile, L"neverViewableSites",
											pRatObj);

			//------------------------------------------------
			// selectedRatingsBureau
			TCHAR szValue[MAX_PATH];
			if (GetPrivateProfileString(IK_FF_GENERAL, IK_BUREAU, TEXT(""),
										szValue, ARRAYSIZE(szValue), szFile))
			{
				hr = PutWbemInstancePropertyEx(L"selectedRatingsBureau", szValue, pRatObj);
			}

			//
			// Commit all above properties by calling PutInstance, semisynchronously
			//
			BSTR bstrNewObjPath = NULL;
			hr = PutWbemInstance(pRatObj, bstrClass, &bstrNewObjPath);
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreRatingsSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreAuthenticodeSettings()
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreAuthenticodeSettings)
	HRESULT hr = NOERROR;
	__try
	{
		//------------------------------------------------
		// importAuthenticodeSecurityInfo
		BOOL bValue = GetInsBool(SECURITY_IMPORTS, TEXT("ImportAuthCode"), FALSE);
		if (bValue)
		{
			hr = PutWbemInstanceProperty(L"importAuthenticodeSecurityInfo", true);

			hr = StoreCertificates();
		}

		//------------------------------------------------
		// enableTrustedPublisherLockdown
		bValue = GetInsBool(SECURITY_IMPORTS, IK_TRUSTPUBLOCK, FALSE);
		if (bValue)
			hr = PutWbemInstanceProperty(L"enableTrustedPublisherLockdown", true);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreAuthenticodeSettings.")));
	}

  return hr;
}

///////////////////////////////////////////////////////////
//  Check to see if the certificate is an end-entity cert
//
///////////////////////////////////////////////////////////
BOOL IsCertificateEndEntity(PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION                     pCertExt=NULL;
    BOOL                                fEndEntity=FALSE;
    DWORD                               cbData=0;
    PCERT_BASIC_CONSTRAINTS_INFO        pBasicInfo=NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO       pBasicInfo2=NULL;

    if(!pCertContext)
        return FALSE;

    //get the extension szOID_BASIC_CONSTRAINTS2
    pCertExt=CertFindExtension(
              szOID_BASIC_CONSTRAINTS2,
              pCertContext->pCertInfo->cExtension,
              pCertContext->pCertInfo->rgExtension);


    if(pCertExt)
    {
        //deocde the extension
        cbData=0;

        if(!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_BASIC_CONSTRAINTS2,
                pCertExt->Value.pbData,
                pCertExt->Value.cbData,
                0,
                NULL,
                &cbData))
            goto CLEANUP;

       pBasicInfo2=(PCERT_BASIC_CONSTRAINTS2_INFO)LocalAlloc(LPTR, cbData);

       if(NULL==pBasicInfo2)
           goto CLEANUP;

        if(!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_BASIC_CONSTRAINTS2,
                pCertExt->Value.pbData,
                pCertExt->Value.cbData,
                0,
                pBasicInfo2,
                &cbData))
            goto CLEANUP;

        if(pBasicInfo2->fCA)
            fEndEntity=FALSE;
        else
            fEndEntity=TRUE;
    }
    else
    {
        //get the extension szOID_BASIC_CONSTRAINTS
        pCertExt=CertFindExtension(
                  szOID_BASIC_CONSTRAINTS,
                  pCertContext->pCertInfo->cExtension,
                  pCertContext->pCertInfo->rgExtension);

        if(pCertExt)
        {
            //deocde the extension
            cbData=0;

            if(!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS,
                    pCertExt->Value.pbData,
                    pCertExt->Value.cbData,
                    0,
                    NULL,
                    &cbData))
                goto CLEANUP;

           pBasicInfo=(PCERT_BASIC_CONSTRAINTS_INFO)LocalAlloc(LPTR, cbData);

           if(NULL==pBasicInfo)
               goto CLEANUP;

            if(!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS,
                    pCertExt->Value.pbData,
                    pCertExt->Value.cbData,
                    0,
                    pBasicInfo,
                    &cbData))
                goto CLEANUP;

            if(0 == pBasicInfo->SubjectType.cbData)
            {
                fEndEntity=FALSE;
            }
            else
            {

                if(CERT_END_ENTITY_SUBJECT_FLAG & (pBasicInfo->SubjectType.pbData[0]))
                    fEndEntity=TRUE;
                else
                {
                    if(CERT_CA_SUBJECT_FLAG & (pBasicInfo->SubjectType.pbData[0]))
                      fEndEntity=FALSE;
                }
            }
        }
    }


CLEANUP:

    if(pBasicInfo)
        LocalFree((HLOCAL)pBasicInfo);

    if(pBasicInfo2)
        LocalFree((HLOCAL)pBasicInfo2);

    return fEndEntity;

}

BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,
								  DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) ||
        (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding, 
                                     &pContext->pCertInfo->Issuer,
                                     &pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD dwFlag = CERT_STORE_SIGNATURE_FLAG;
    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}

//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY, 
                pszObjId, 
                0);

    if (pOIDInfo != NULL)
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}

#define CRYPTUI_MAX_STRING_SIZE 768
//////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////
BOOL FormatEnhancedKeyUsageString(LPWSTR *ppString, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly, BOOL fMultiline)
{
    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
    DWORD               cbKeyUsage = 0;
    DWORD               numChars = 1;
    WCHAR               szText[CRYPTUI_MAX_STRING_SIZE];
    DWORD               i;

    //
    // Try to get the enhanced key usage property
    //

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    NULL,
                                    &cbKeyUsage))
    {
        return FALSE;
    }

    if (NULL == (pKeyUsage = (CERT_ENHKEY_USAGE *) malloc(cbKeyUsage)))
    {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage (  pCertContext,
                                    fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                    pKeyUsage,
                                    &cbKeyUsage))
    {
        free(pKeyUsage);
        return FALSE;
    }

    if (pKeyUsage->cUsageIdentifier == 0)
    {
        free (pKeyUsage);
        if (GetLastError() == CRYPT_E_NOT_FOUND)
        {
			LPWSTR wszTemp = L"<All>";
			*ppString = (LPWSTR) malloc((wcslen(wszTemp)+1) * sizeof(WCHAR));
			if (NULL == *ppString)
			{
				SetLastError((DWORD)E_OUTOFMEMORY);
                return FALSE; 
			}
			else
			{
				lstrcpyW(*ppString, wszTemp);
                return TRUE;
			}
        }
        else
        {
			LPWSTR wszTemp = L"<None>";
			*ppString = (LPWSTR) malloc((wcslen(wszTemp)+1) * sizeof(WCHAR));
			if (NULL == *ppString)
			{
				SetLastError((DWORD)E_OUTOFMEMORY);
                return FALSE; 
			}
			else
			{
				lstrcpyW(*ppString, wszTemp);
                return TRUE;
			}
        }
    }

    //
    // calculate size
    //

    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                numChars += 2;
            }

            numChars += (DWORD)wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    if (NULL == (*ppString = (LPWSTR) malloc((numChars+1) * sizeof(WCHAR))))
    {
        free (pKeyUsage);
        return FALSE; 
    }

    //
    // copy to buffer
    //
    (*ppString)[0] = 0;
    // loop for each usage and add it to the display string
    for (i=0; i<pKeyUsage->cUsageIdentifier; i++)
    {
        if (MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i]))
        {
            // add delimeter if not first iteration
            if (i != 0)
            {
                if (fMultiline)
                    wcscat(*ppString, L"\n");
                else
                    wcscat(*ppString, L", ");
                    
                numChars += 2;
            }

            //  add the enhanced key usage string
            wcscat(*ppString, szText);
            numChars += (DWORD)wcslen(szText);
        }
        else
        {
            free (pKeyUsage);
            return FALSE;   
        }
    }

    free (pKeyUsage);
    return TRUE;
}

///////////////////////////////////////////////////////////
// Based on the tab(store) and the intended purpose selected,
// find the correct certificates and store them in WMI
// Criteria:
//      Tab 0:  My Store with private key
//      Tab 1:  Ca Store's end-entity cert and the "ADDRESSBOOK" store
//      Tab 2:  Ca Store's CA certs
//      Tab 3:  Root store's self signed certs
//      Tab 4:  Trusted publisher certs
///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreCertificates()
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreCertificates)
	HRESULT hr = NOERROR;
	__try
	{
	//TODO    FreeCerts(pCertMgrInfo);

		//open the correct store based on the tab selected
		HCERTSTORE rghCertStore[] = {NULL, NULL};
		BOOL bContinue = TRUE;
		for (DWORD dwTabIndex = 0; dwTabIndex < 5; dwTabIndex++)
		{
			DWORD dwStoreCount = 0;
			DWORD dwCertIndex = 0;
			switch (dwTabIndex)
			{
			case 0:
				//open my store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"my");
				if (NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			case 1:
				//open ca store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"ca");
				if(NULL != rghCertStore[dwStoreCount])
				{
					dwStoreCount++;

					//open the "AddressBook" store
					rghCertStore[dwStoreCount] = CertOpenStore(
								CERT_STORE_PROV_SYSTEM_W,
								g_dwMsgAndCertEncodingType,
								NULL,
								CERT_STORE_MAXIMUM_ALLOWED_FLAG |
								CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
								CERT_SYSTEM_STORE_CURRENT_USER |
								CERT_STORE_OPEN_EXISTING_FLAG,
								(LPWSTR)L"ADDRESSBOOK");

					if(NULL != rghCertStore[dwStoreCount])
						dwStoreCount++;
					else
					{
						//it is OK that user does not have "AddressBook" store
						rghCertStore[dwStoreCount]=NULL;
					}
				}
				else
					bContinue = FALSE;

				break;
			case 2:
				//open CA store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"ca");
				if(NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			case 3:
				//open root store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"root");
				if(NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			case 4:
				//open trusted publisher store
				rghCertStore[dwStoreCount] = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
															g_dwMsgAndCertEncodingType,
															NULL,
															CERT_STORE_MAXIMUM_ALLOWED_FLAG |
															CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
															CERT_SYSTEM_STORE_CURRENT_USER,
															(LPWSTR)L"TrustedPublisher");
				if(NULL != rghCertStore[dwStoreCount])
					dwStoreCount++;
				else
					bContinue = FALSE;

				break;
			default:
				bContinue = FALSE;
				break;
			}

			if (!bContinue)
			{
				OutD(LI1(TEXT("Exited prematurely in tab %d"), dwTabIndex));
				continue;
			}


			//gather new certificates from the store opened
			PCCERT_CONTEXT pCurCertContext = NULL;
			PCCERT_CONTEXT pPreCertContext = NULL;
			BOOL fValidCert = FALSE;
			for (DWORD dwIndex=0; dwIndex < dwStoreCount; dwIndex++)
			{
				pPreCertContext = NULL;
				pCurCertContext = CertEnumCertificatesInStore(rghCertStore[dwIndex],
																pPreCertContext);
				while (NULL != pCurCertContext)
				{
					DWORD cbData=0;
					switch (dwTabIndex)
					{
						case 0:
							//certificate has to have private key associated
							//with it
							if( (CertGetCertificateContextProperty(
									pCurCertContext, CERT_KEY_PROV_INFO_PROP_ID,	
									NULL, &cbData) && (0!=cbData)) ||
								(CertGetCertificateContextProperty(
									pCurCertContext, CERT_PVK_FILE_PROP_ID, NULL,	
									&cbData) && (0!=cbData)) )
							{
							   fValidCert=TRUE;
							}
							break;
						case 1:
							//the certificate has to be end entity cert for CA cert
							if(0 == dwIndex)
							{
								if (IsCertificateEndEntity(pCurCertContext))
									fValidCert=TRUE;
							}

							//we display everything in the addressbook store
							if(1==dwIndex)
								fValidCert=TRUE;
							break;
						case 2:
							//for certificate in CA store, has to be CA cert
							if(!IsCertificateEndEntity(pCurCertContext))
								fValidCert=TRUE;
							break;
						case 4:
							fValidCert=TRUE;
							break;
						case 3:
						default:
							//the certificate has to be self-signed
							if (TrustIsCertificateSelfSigned(pCurCertContext,
									pCurCertContext->dwCertEncodingType, 0))
							{
								fValidCert=TRUE;
							}

							break;
					}

					if (fValidCert)
					{
						// Create & populate RSOP_IEAuthenticodeCertificate
						_bstr_t bstrClass = L"RSOP_IEAuthenticodeCertificate";
						ComPtr<IWbemClassObject> pCert = NULL;
						HRESULT hr = CreateRSOPObject(bstrClass, &pCert);
						if (SUCCEEDED(hr))
						{
							// Write foreign keys from our stored precedence & id fields
							OutD(LI2(TEXT("Storing property 'rsopPrecedence' in %s, value = %lx"),
									(BSTR)bstrClass, m_dwPrecedence));
							hr = PutWbemInstancePropertyEx(L"rsopPrecedence", (long)m_dwPrecedence, pCert);

							OutD(LI2(TEXT("Storing property 'rsopID' in %s, value = %s"),
									(BSTR)bstrClass, (BSTR)m_bstrID));
							hr = PutWbemInstancePropertyEx(L"rsopID", m_bstrID, pCert);

							//------------------------------------------------
							// tabIndex
							hr = PutWbemInstancePropertyEx(L"tabIndex", (long)dwTabIndex, pCert);

							//------------------------------------------------
							// certIndex
							hr = PutWbemInstancePropertyEx(L"certIndex", (long)dwCertIndex, pCert);

							//------------------------------------------------
							// subjectName
							DWORD dwChar = CertGetNameStringW(pCurCertContext,
															CERT_NAME_SIMPLE_DISPLAY_TYPE,
															0, NULL, NULL, 0);

							LPWSTR wszVal = NULL;
							_bstr_t bstrVal;
							if (0 != dwChar)
								wszVal = (LPWSTR)LocalAlloc(LPTR, dwChar * sizeof(WCHAR));
							if (0 != dwChar && NULL != wszVal)
							{
								CertGetNameStringW(pCurCertContext,
													CERT_NAME_SIMPLE_DISPLAY_TYPE,
													0, NULL, wszVal, dwChar);

								bstrVal = wszVal;
								hr = PutWbemInstancePropertyEx(L"subjectName", bstrVal, pCert);

								//free the memory
								LocalFree((HLOCAL)wszVal);
								wszVal = NULL;
							}

							//------------------------------------------------
							// issuerName
							dwChar = CertGetNameStringW(pCurCertContext,
														CERT_NAME_SIMPLE_DISPLAY_TYPE,
														CERT_NAME_ISSUER_FLAG, NULL,
														NULL, 0);

							if (0 != dwChar)
								wszVal = (LPWSTR)LocalAlloc(LPTR, dwChar * sizeof(WCHAR));
							if (0 != dwChar && NULL != wszVal)
							{
								CertGetNameStringW(pCurCertContext,
													CERT_NAME_SIMPLE_DISPLAY_TYPE,
													CERT_NAME_ISSUER_FLAG,
													NULL, wszVal, dwChar);

								bstrVal = wszVal;
								hr = PutWbemInstancePropertyEx(L"issuerName", bstrVal, pCert);

								//free the memory
								LocalFree((HLOCAL)wszVal);
								wszVal = NULL;
							}

							//------------------------------------------------
							// expirationDate
							SYSTEMTIME sysTime;
							if (!FileTimeToSystemTime( &pCurCertContext->pCertInfo->NotAfter, &sysTime ))
								OutD(LI1(TEXT("FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
							else
							{
								_bstr_t bstrTime;
								HRESULT hr = SystemTimeToWbemTime(sysTime, bstrTime);
								if(FAILED(hr) || bstrTime.length() <= 0)
									OutD(LI1(TEXT("Call to SystemTimeToWbemTime failed. hr=0x%08X"), hr));
								else
								{
									hr = PutWbemInstancePropertyEx(L"expirationDate", bstrTime, pCert);
									if ( FAILED(hr) )
										OutD(LI1(TEXT("Put failed with 0x%x" ), hr ));
								}
							}

							//------------------------------------------------
							// friendlyName
							if (CertGetCertificateContextProperty(pCurCertContext,
																CERT_FRIENDLY_NAME_PROP_ID,
																NULL, &dwChar) && (0 != dwChar))
							{
								wszVal = (LPWSTR)LocalAlloc(LPTR, dwChar * sizeof(WCHAR));
								if (NULL != wszVal)
								{
								   CertGetCertificateContextProperty(pCurCertContext,
																	CERT_FRIENDLY_NAME_PROP_ID,
																	wszVal, &dwChar);
								}

								bstrVal = wszVal;
								hr = PutWbemInstancePropertyEx(L"friendlyName", bstrVal, pCert);

								//free the memory
								LocalFree((HLOCAL)wszVal);
								wszVal = NULL;
							}

							//------------------------------------------------
							// intendedPurposes
							if (FormatEnhancedKeyUsageString(&wszVal, pCurCertContext, FALSE, FALSE))
							{
								if (wszVal != NULL)
								{
									bstrVal = wszVal;
									hr = PutWbemInstancePropertyEx(L"intendedPurposes", bstrVal, pCert);

									free(wszVal);
									wszVal = NULL;
								}
							}
    

							//
							// Commit all above properties by calling PutInstance, semisynchronously
							//
							BSTR bstrCurCertObj = NULL;
							hr = PutWbemInstance(pCert, bstrClass, &bstrCurCertObj);
						}
					}

					fValidCert=FALSE;

					pPreCertContext=pCurCertContext;
					pCurCertContext = CertEnumCertificatesInStore(rghCertStore[dwIndex],
																	pPreCertContext);

					dwCertIndex++;
				}
			}

			//close all the certificate stores
			for (DWORD dwIndex=0; dwIndex<dwStoreCount; dwIndex++)
				CertCloseStore(rghCertStore[dwIndex], 0);
		} // end looping through 5 tabs
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreCertificates.")));
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\rsopadm.cpp ===
#include "precomp.h"

// The following bug may be due to having CHICAGO_PRODUCT set in sources.
// This file and all rsop??.cpp files need to have WINVER defined at at least 500

// BUGBUG: (andrewgu) no need to say how bad this is!
#undef   WINVER
#define  WINVER 0x0501
#include <userenv.h>

#include "RSoP.h"
//#include "wbemtime.h"
#include "utils.h"

#include <tchar.h>

typedef BOOL (*PFNREGFILECALLBACK)(BOOL bHKCU, LPTSTR lpKeyName,
                                   LPTSTR lpValueName, DWORD dwType,
                                   DWORD dwDataLength, LPBYTE lpData,
                                   REGHASHTABLE *pHashTable);

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512
const MAX_LENGTH = 100; // Length of stringized guid

HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, _bstr_t &xbstrWbemTime);

extern SAFEARRAY *CreateSafeArray(VARTYPE vtType, long nElements, long nDimensions = 1);


///////////////////////////////////////////////////////////
//  CheckSlash() - from nt\ds\security\gina\userenv\utils\util.c
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
///////////////////////////////////////////////////////////
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

///////////////////////////////////////////////////////////
//  IsUNCPath() - from nt\ds\security\gina\userenv\utils\util.c
//
//  Purpose:    Is the given path a UNC path
//
//  Parameters: lpPath  -   Path to check
//
//  Return:     TRUE if the path is UNC
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
///////////////////////////////////////////////////////////
BOOL IsUNCPath(LPCTSTR lpPath)
{

    if ((!lpPath) || (!lpPath[0]) && (!lpPath[1]))
        return FALSE;

    if (lpPath[0] == TEXT('\\') && lpPath[1] == TEXT('\\')) {
        return(TRUE);
    }
    return(FALSE);
}

///////////////////////////////////////////////////////////
//  MakePathUNC()
//
//  Purpose:    Makes the given path UNC s.t. it can be accessed from a remote machine..
//              if the path contains %systemroot% expanded then it substitutes
//              \\machname\admin$ otherwise \\machname\<driveletter>$
//
//  Parameters: lpPath          -   Input Path (needs to be absolute)
//              szComputerName  -   Name of the computer on which this is the local path
//
//  Return:     Path if it was fone successfully
//              NULL if not
//
//  Comments:
///////////////////////////////////////////////////////////
LPTSTR MakePathUNC(LPTSTR pwszFile, LPTSTR szComputerName)
{   MACRO_LI_PrologEx_C(PIF_STD_C, MakePathUNC)
    LPTSTR szUNCPath = NULL;
    TCHAR szSysRoot[MAX_PATH];
    DWORD dwSysLen;
    LPTSTR lpEnd = NULL;


    OutD(LI1(TEXT("Entering with <%s>"), pwszFile ? pwszFile : TEXT("NULL")));

	szUNCPath = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(pwszFile)+lstrlen(szComputerName)+3+lstrlen(TEXT("admin$"))+1));

    if (!szUNCPath)
        return NULL;

    if (!pwszFile || !*pwszFile) {
        OutD(LI0(TEXT("lpFile is NULL, setting lpResult to a null string")));
        *szUNCPath = TEXT('\0');
        return szUNCPath;
    }


    if (IsUNCPath(pwszFile)) {
        lstrcpy(szUNCPath, pwszFile);
        return szUNCPath;
    }


    lstrcpy(szUNCPath, TEXT("\\\\"));
    lstrcat(szUNCPath, szComputerName);


    //
    // If the first part of lpFile is the expanded value of %SystemRoot%
    //

    if (!ExpandEnvironmentStrings (TEXT("%SystemRoot%"), szSysRoot, MAX_PATH)) {
        OutD(LI1(TEXT("ExpandEnvironmentString failed with error %d, setting szSysRoot to %systemroot% "), GetLastError()));
        LocalFree((HLOCAL)szUNCPath);
        return NULL;
    }


    dwSysLen = lstrlen(szSysRoot);
    lpEnd = CheckSlash(szUNCPath);


    //
    // if the prefix is the same as expanded systemroot then..
    //

    if (((DWORD)lstrlen(pwszFile) > dwSysLen) &&
        (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       szSysRoot, dwSysLen,
                       pwszFile, dwSysLen) == CSTR_EQUAL)) {

        lstrcat(szUNCPath, TEXT("admin$"));
        lstrcat(szUNCPath, pwszFile+dwSysLen);
    }
    else {

        if (pwszFile[1] != TEXT(':')) {
            OutD(LI1(TEXT("Input path %s is not an absolute path"), pwszFile));
            lstrcpy(szUNCPath, pwszFile);
            return szUNCPath;
        }

        lpEnd[0] = pwszFile[0];
        lpEnd[1] = TEXT('$');
        lpEnd[2] = TEXT('\0');

        lstrcat(szUNCPath, pwszFile+2);
    }

    OutD(LI1(TEXT("Returning a UNCPath of %s"), szUNCPath));

    return szUNCPath;
}

///////////////////////////////////////////////////////////
//  AllocAdmFileInfo()
//
//  Purpose:    Allocates a new struct for ADMFILEINFO
//
//  Parameters: pwszFile  -  File name
//              pwszGPO   -  Gpo
//              pftWrite  -  Last write time
///////////////////////////////////////////////////////////
ADMFILEINFO *AllocAdmFileInfo(WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite)
{   MACRO_LI_PrologEx_C(PIF_STD_C, AllocAdmFileInfo)
    ADMFILEINFO *pAdmFileInfo = (ADMFILEINFO *) LocalAlloc( LPTR, sizeof(ADMFILEINFO) );
    if  ( pAdmFileInfo == NULL ) {
        OutD(LI0(TEXT("Failed to allocate memory.")));
        return NULL;
    }

    pAdmFileInfo->pwszFile = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszFile) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszFile == NULL ) {
        OutD(LI0(TEXT("Failed to allocate memory.")));
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    pAdmFileInfo->pwszGPO = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszGPO) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszGPO == NULL ) {
        OutD(LI0(TEXT("Failed to allocate memory.")));
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    lstrcpy( pAdmFileInfo->pwszFile, pwszFile );
    lstrcpy( pAdmFileInfo->pwszGPO, pwszGPO );

    pAdmFileInfo->ftWrite = *pftWrite;

    return pAdmFileInfo;
}

///////////////////////////////////////////////////////////
//  FreeAdmFileInfo()
//
//  Purpose:    Deletes a ADMFILEINFO struct
//
//  Parameters: pAdmFileInfo - Struct to delete
//              pftWrite   -  Last write time
///////////////////////////////////////////////////////////
void FreeAdmFileInfo( ADMFILEINFO *pAdmFileInfo )
{
    if ( pAdmFileInfo ) {
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo->pwszGPO );
        LocalFree( pAdmFileInfo );
    }
}

///////////////////////////////////////////////////////////
//  FreeAdmFileCache() - taken from gpreg.cpp in nt\ds\security\gina\userenv\policy
//
//  Purpose:    Frees Adm File list
//
//  Parameters: pAdmFileCache - List of Adm files to free
///////////////////////////////////////////////////////////
void FreeAdmFileCache( ADMFILEINFO *pAdmFileCache )
{
    ADMFILEINFO *pNext;

    while ( pAdmFileCache ) {
        pNext = pAdmFileCache->pNext;
        FreeAdmFileInfo( pAdmFileCache );
        pAdmFileCache = pNext;
    }
}

///////////////////////////////////////////////////////////
//  AddAdmFile() - taken from gpreg.cpp in nt\ds\security\gina\userenv\policy
//
//  Purpose:    Prepends to list of Adm files
//
//  Parameters: pwszFile       - File path
//              pwszGPO        - Gpo
//              pftWrite       - Last write time
//              ppAdmFileCache - List of Adm files processed
///////////////////////////////////////////////////////////
BOOL AddAdmFile(WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite,
				WCHAR *szComputerName, ADMFILEINFO **ppAdmFileCache)
{   MACRO_LI_PrologEx_C(PIF_STD_C, AddAdmFile)
	LPWSTR wszLongPath;
    LPWSTR pwszUNCPath;

    OutD(LI1(TEXT("Adding File name <%s> to the Adm list."), pwszFile));
    if ((szComputerName) && (*szComputerName) && (!IsUNCPath(pwszFile))) {
        wszLongPath = MakePathUNC(pwszFile, szComputerName);

        if (!wszLongPath) {
            OutD(LI1(TEXT("Failed to Make the path UNC with error %d."), GetLastError()));
            return FALSE;
        }
        pwszUNCPath = wszLongPath;
    }
    else
        pwszUNCPath = pwszFile;


    ADMFILEINFO *pAdmInfo = AllocAdmFileInfo(pwszUNCPath, pwszGPO, pftWrite);
    if ( pAdmInfo == NULL )
        return FALSE;

    pAdmInfo->pNext = *ppAdmFileCache;
    *ppAdmFileCache = pAdmInfo;

    return TRUE;
}

///////////////////////////////////////////////////////////
// Function:        SystemTimeToWbemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:         12/08/99        leonardm    Created.
///////////////////////////////////////////////////////////
#define WBEM_TIME_STRING_LENGTH 25
HRESULT SystemTimeToWbemTime(SYSTEMTIME& sysTime, _bstr_t &xbstrWbemTime)
{
    WCHAR *xTemp = new WCHAR[WBEM_TIME_STRING_LENGTH + 1];

    if(!xTemp)
        return E_OUTOFMEMORY;

    int nRes = wsprintf(xTemp, L"%04d%02d%02d%02d%02d%02d.000000+000",
                sysTime.wYear,
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond);

    if(nRes != WBEM_TIME_STRING_LENGTH)
        return E_FAIL;

    xbstrWbemTime = xTemp;

    if(!xbstrWbemTime)
        return E_OUTOFMEMORY;

    return S_OK;
}

///////////////////////////////////////////////////////////
//  ParseRegistryFile()
//
//  Purpose:    Parses a registry.pol file
//
//  Parameters: lpRegistry         -   Path to registry file (.INF)
//              pfnRegFileCallback -   Callback function
//              pHashTable         -   Hash table for registry keys
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
///////////////////////////////////////////////////////////
BOOL ParseRegistryFile (LPTSTR lpRegistry,
                        PFNREGFILECALLBACK pfnRegFileCallback,
						REGHASHTABLE *pHashTable)
{   MACRO_LI_PrologEx_C(PIF_STD_C, ParseRegistryFile)
	BOOL bRet = FALSE;
	__try
	{
		OutD(LI1(TEXT("Entering with <%s>."), lpRegistry));

		//
		// Allocate buffers to hold the keyname, valuename, and data
		//

		LPWSTR lpValueName = NULL;
	    LPBYTE lpData = NULL;
		INT iType;
		DWORD dwType = REG_SZ, dwDataLength, dwValue = 0;
		BOOL bHKCU = TRUE;

		UINT nErrLine = 0;
		HINF hInfAdm = NULL;

		LPWSTR lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));
		if (!lpKeyName)
		{
			OutD(LI1(TEXT("Failed to allocate memory with %d"), GetLastError()));
			goto Exit;
		}


		lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));
		if (!lpValueName)
		{
			OutD(LI1(TEXT("Failed to allocate memory with %d"), GetLastError()));
			goto Exit;
		}

		// Get the AddReg.Hkcu section for the registry strings.
		nErrLine = 0;
		hInfAdm = SetupOpenInfFile(lpRegistry, NULL, INF_STYLE_WIN4, &nErrLine);
		if (INVALID_HANDLE_VALUE != hInfAdm)
		{
			for (int iSection = 0; iSection < 2; iSection++)
			{
				OutD(LI1(TEXT("Reading section #%d."), iSection));
				bHKCU = (1 == iSection) ? TRUE : FALSE;

				// Get the first line in this section.
				INFCONTEXT infContext;
				BOOL bLineFound = SetupFindFirstLine(hInfAdm, bHKCU ?
													TEXT("AddRegSection.HKCU") : 
													TEXT("AddRegSection.HKLM"),
													NULL, &infContext);

				DWORD dwReqSize = 0;
				while (bLineFound)
				{
					// Read the data

					// **********************************
					// Process the registry setting line.

					// Read the keyname
					ZeroMemory(lpKeyName, MAX_KEYNAME_SIZE);
					dwReqSize = 0;
					if (!SetupGetStringField(&infContext, 2, lpKeyName,
											MAX_KEYNAME_SIZE, &dwReqSize))
					{
						if (dwReqSize >= MAX_KEYNAME_SIZE)
							OutD(LI0(TEXT("Keyname exceeded max size")));
						else
							OutD(LI1(TEXT("Failed to read keyname from line, error %d."), GetLastError()));
						goto Exit;
					}

					// Read the valuename
					ZeroMemory(lpValueName, MAX_VALUENAME_SIZE);
					dwReqSize = 0;
					if (!SetupGetStringField(&infContext, 3, lpValueName,
											MAX_VALUENAME_SIZE, &dwReqSize))
					{
						if (dwReqSize >= MAX_VALUENAME_SIZE)
							OutD(LI0(TEXT("Valuename exceeded max size")));
						else
						{
							OutD(LI1(TEXT("Failed to read valuename from line, error %d."),
									GetLastError()));
						}
						goto Exit;
					}

					// Read the type
					if (!SetupGetIntField(&infContext, 4, &iType))
					{
						OutD(LI1(TEXT("Failed to read type from line, error %d."),
								GetLastError()));
						goto Exit;
					}

					lpData = NULL;
					dwDataLength = 0;
					if (0 == iType)
					{
						dwType = REG_SZ;

						// Allocate memory for data
						dwReqSize = 0;
						if (!SetupGetStringField(&infContext, 5, NULL, 0, &dwReqSize))
						{
							OutD(LI1(TEXT("Failed to get size of string value from line, error %d."),
									GetLastError()));
							goto Exit;
						}

						if (dwReqSize > 0)
						{
							lpData = (LPBYTE)LocalAlloc(LPTR, dwReqSize * sizeof(TCHAR));
							if (!lpData)
							{
								OutD(LI1(TEXT("Failed to allocate memory for data with %d"),
										 GetLastError()));
								goto Exit;
							}

							// Read string data
							dwDataLength = dwReqSize;
							dwReqSize = 0;
							if (!SetupGetStringField(&infContext, 5, (LPTSTR)lpData, dwDataLength, &dwReqSize))
							{
								OutD(LI1(TEXT("Failed to get size of string value from line, error %d."),
										GetLastError()));
								goto Exit;
							}

							// convert to wide char string so the reader of the data doesn't have to guess
							// whether the data was written in ansi or unicode.
							if (NULL != lpData && dwDataLength > 0)
							{
								_bstr_t bstrData = (LPTSTR)lpData;
								dwDataLength = bstrData.length() * sizeof(WCHAR);
							}
						}
						else
							OutD(LI0(TEXT("Error.  Size of string data is 0.")));
					}
					else if (0x10001 == iType)
					{
						dwType = REG_DWORD;

						// Read numeric data
						dwDataLength = sizeof(dwValue);
						dwValue = 0;
						dwReqSize = 0;
						if (!SetupGetBinaryField(&infContext, 5, (PBYTE)&dwValue, dwDataLength, &dwReqSize))
						{
							OutD(LI1(TEXT("Failed to get DWORD value from line, error %d."),
									GetLastError()));
							goto Exit;
						}

						lpData = (LPBYTE)&dwValue;
					}
					else
					{
						OutD(LI1(TEXT("Invalid type (%lX)."), dwType));
						goto Exit;
					}

					if (NULL != lpData)
					{
						// Call the callback function
						if (!pfnRegFileCallback (bHKCU, lpKeyName, lpValueName, dwType,
												dwDataLength, lpData, pHashTable ))
						{
							OutD(LI0(TEXT("Callback function returned false.")));
							goto Exit;
						}
					}

					if (0 == iType && lpData)
						LocalFree (lpData);
					lpData = NULL;
					// **********************************

					// Move to the next line in the INF file.
					bLineFound = SetupFindNextLine(&infContext, &infContext);
				}
			}

			bRet = TRUE;
		}
		else
			OutD(LI1(TEXT("Error %d opening INF file,"), GetLastError()));

Exit:
		// Finished
		OutD(LI0(TEXT("Leaving.")));
		if (lpData)
			LocalFree(lpData);
		if (lpKeyName)
			LocalFree(lpKeyName);
		if (lpValueName)
			LocalFree(lpValueName);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in ParseRegistryFile.")));
	}
	return bRet;
}

///////////////////////////////////////////////////////////
//  SetRegistryValue()
//
//  Purpose:    Callback from ParseRegistryFile that sets
//              registry policies
//
//  Parameters: lpKeyName   -  Key name
//              lpValueName -  Value name
//              dwType      -  Registry data type
//              lpData      -  Registry data
//              pwszGPO     -   Gpo
//              pwszSOM     -   Sdou that the Gpo is linked to
//              pHashTable  -   Hash table for registry keys
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
///////////////////////////////////////////////////////////
BOOL SetRegistryValue (BOOL bHKCU, LPTSTR lpKeyName,
                       LPTSTR lpValueName, DWORD dwType,
                       DWORD dwDataLength, LPBYTE lpData,
                       REGHASHTABLE *pHashTable)
{   MACRO_LI_PrologEx_C(PIF_STD_C, SetRegistryValue)

    BOOL bRet = FALSE;
	__try
	{
		BOOL bUseValueName = FALSE;
    
		//
		// Save registry value
		//
		bRet = AddRegHashEntry( pHashTable, REG_ADDVALUE, bHKCU, lpKeyName,
									  lpValueName, dwType, dwDataLength, lpData,
									  NULL, NULL, bUseValueName ? lpValueName : TEXT(""), TRUE );
		if (bRet) 
		{
			switch (dwType)
			{
				case REG_SZ:
				case REG_EXPAND_SZ:
					OutD(LI2(TEXT("%s => %s  [OK]"), lpValueName, (LPTSTR)lpData));
					break;

				case REG_DWORD:
					OutD(LI2(TEXT("%s => %d  [OK]"), lpValueName, *((LPDWORD)lpData)));
					break;

				case REG_NONE:
					break;

				default:
					OutD(LI1(TEXT("%s was set successfully"), lpValueName));
					break;
			}
		}
		else
		{
			pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());

			OutD(LI2(TEXT("Failed AddRegHashEntry for value <%s> with %d"),
					 lpValueName, pHashTable->hrError));
		}
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in SetRegistryValue.")));
	}
	return bRet;
}

///////////////////////////////////////////////////////////
HRESULT CRSoPGPO::StoreADMSettings(LPWSTR wszGPO, LPWSTR wszSOM)
{   MACRO_LI_PrologEx_C(PIF_STD_C, StoreADMSettings)

	HRESULT hr = E_FAIL;
	BOOL bContinue = TRUE;
	__try
	{
		OutD(LI0(TEXT("\r\nEntered StoreADMSettings function.")));

		// Setup hash table
		REGHASHTABLE *pHashTable = AllocHashTable();
		if (NULL == pHashTable)
		{
			bContinue = FALSE;
			hr = HRESULT_FROM_WIN32(GetLastError());
		}

		WCHAR pwszFile[MAX_PATH];
		LPWSTR pwszEnd = NULL;
		if (bContinue)
		{
			// convert the INS file path to a wide char string
			_bstr_t bstrINSFile = m_szINSFile;
			StrCpyW(pwszFile, (LPWSTR)bstrINSFile);
			PathRemoveFileSpec(pwszFile);

			// Log Adm data
			pwszEnd = pwszFile + lstrlen(pwszFile);
			lstrcpy(pwszEnd, L"\\*.adm");

			// Remember end point so that the actual Adm filename can be
			// easily concatenated.
			pwszEnd = pwszEnd + lstrlen( L"\\" );
		}

		HANDLE hFindFile = NULL;
	    WIN32_FIND_DATA findData;
		ZeroMemory(&findData, sizeof(findData));
		if (bContinue)
		{
			//
			// Enumerate all Adm files
			//
			hFindFile = FindFirstFile( pwszFile, &findData);
			if (INVALID_HANDLE_VALUE == hFindFile)
				bContinue = FALSE;
		}

	    ADMFILEINFO *pAdmFileCache = NULL;
		if (bContinue)
		{
			WIN32_FILE_ATTRIBUTE_DATA attrData;
			TCHAR szComputerName[3*MAX_COMPUTERNAME_LENGTH + 1];
			do
			{
				DWORD dwSize = 3*MAX_COMPUTERNAME_LENGTH + 1;
				if (!GetComputerName(szComputerName, &dwSize))
				{
					OutD(LI1(TEXT("ProcessGPORegistryPolicy: Couldn't get the computer Name with error %d."), GetLastError()));
					szComputerName[0] = TEXT('\0');
				}

				if ( !(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
				{
					lstrcpy( pwszEnd, findData.cFileName);

					WCHAR wszRegDataFile[MAX_PATH];
					StrCpyW(wszRegDataFile, pwszFile);
					PathRenameExtension(wszRegDataFile, TEXT(".INF"));

					if (ParseRegistryFile(wszRegDataFile, SetRegistryValue, pHashTable))
					{
						ZeroMemory (&attrData, sizeof(attrData));
						if ( GetFileAttributesEx (pwszFile, GetFileExInfoStandard, &attrData ) != 0 )
						{
							if (!AddAdmFile( pwszFile, wszGPO, &attrData.ftLastWriteTime,
											  szComputerName, &pAdmFileCache ) )
							{
								OutD(LI0(TEXT("ProcessGPORegistryPolicy: AddAdmFile failed.")));

								if (pHashTable->hrError == S_OK)
									pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
								hr = pHashTable->hrError;
							}
						}
					}
					else
						OutD(LI0(TEXT("ProcessGPORegistryPolicy: ParseRegistryFile failed.")));
				}   // if findData & file_attr_dir

			}  while ( FindNextFile(hFindFile, &findData) );//  do

			FindClose(hFindFile);

		}   // if hfindfile

		//
		// Log registry data to Cimom database
		//
		if (!LogRegistryRsopData(pHashTable, wszGPO, wszSOM))
		{
			OutD(LI0(TEXT("ProcessGPOs: Error when logging Registry Rsop data. Continuing.")));

			if (pHashTable->hrError == S_OK)
				pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
			hr = pHashTable->hrError;
		}
		if (!LogAdmRsopData(pAdmFileCache))
		{
			OutD(LI0(TEXT("ProcessGPOs: Error when logging Adm Rsop data. Continuing.")));

			if (pHashTable->hrError == S_OK)
				pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
			hr = pHashTable->hrError;
		}

		FreeHashTable(pHashTable);
		FreeAdmFileCache(pAdmFileCache);
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in StoreADMSettings.")));
	}

	OutD(LI0(TEXT("Exiting StoreADMSettings function.\r\n")));
	return hr;
}

///////////////////////////////////////////////////////////
//  LogAdmRsopData()
//
//  Purpose:    Logs Rsop ADM template data to Cimom database
//
//  Parameters: pAdmFileCache - List of adm file to log
//              pWbemServices - Namespace pointer
//
//  Return:     True if successful
///////////////////////////////////////////////////////////
BOOL CRSoPGPO::LogAdmRsopData(ADMFILEINFO *pAdmFileCache)
{   MACRO_LI_PrologEx_C(PIF_STD_C, LogAdmRsopData)
	BOOL bRet = TRUE;
	__try
	{
	//    if ( !DeleteInstances( L"RSOP_AdministrativeTemplateFile", pWbemServices ) )
	//         return FALSE;

		// Create & populate RSOP_IEAdministrativeTemplateFile
		_bstr_t bstrClass = L"RSOP_IEAdministrativeTemplateFile";
		ComPtr<IWbemClassObject> pATF = NULL;
		HRESULT hr = CreateRSOPObject(bstrClass, &pATF);
		if (SUCCEEDED(hr))
		{
			while ( pAdmFileCache )
			{
				//------------------------------------------------
				// name
				_bstr_t bstrName = pAdmFileCache->pwszFile;
				hr = PutWbemInstancePropertyEx(L"name", bstrName, pATF);

				//------------------------------------------------
				// GPOID
				hr = PutWbemInstancePropertyEx(L"GPOID", pAdmFileCache->pwszGPO, pATF);

				//------------------------------------------------
				// lastWriteTime
				SYSTEMTIME sysTime;
				if (!FileTimeToSystemTime( &pAdmFileCache->ftWrite, &sysTime ))
					OutD(LI1(TEXT("FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
				else
				{
					_bstr_t bstrTime;
					HRESULT hr = SystemTimeToWbemTime(sysTime, bstrTime);
					if(FAILED(hr) || bstrTime.length() <= 0)
						OutD(LI1(TEXT("Call to SystemTimeToWbemTime failed. hr=0x%08X"),hr));
					else
					{
						hr = PutWbemInstancePropertyEx(L"lastWriteTime", bstrTime, pATF);
						if ( FAILED(hr) )
							OutD(LI1(TEXT("Put failed with 0x%x" ), hr ));
					}
				}

				//
				// Commit all above properties by calling PutInstance, semisynchronously
				//
				BSTR bstrObjPath = NULL;
				hr = PutWbemInstance(pATF, bstrClass, &bstrObjPath);

				pAdmFileCache = pAdmFileCache->pNext;
			}
		}
		else
			bRet = FALSE;

		OutD(LI0(TEXT("Successfully logged Adm data" )));
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in LogAdmRsopData.")));
	}
	return bRet;
}

///////////////////////////////////////////////////////////
//  LogRegistryRsopData()
//
//  Purpose:    Logs registry Rsop data to Cimom database
//
//  Parameters: dwFlags       - Gpo Info flags
//              pHashTable    - Hash table with registry policy data
//              pWbemServices - Namespace pointer for logging
//
//  Return:     True if successful
///////////////////////////////////////////////////////////
BOOL CRSoPGPO::LogRegistryRsopData(REGHASHTABLE *pHashTable, LPWSTR wszGPOID,
								   LPWSTR wszSOMID)
{   MACRO_LI_PrologEx_C(PIF_STD_C, LogRegistryRsopData)
	BOOL bRet = FALSE;
	__try
	{
		_bstr_t bstrGPOID = wszGPOID;
		_bstr_t bstrSOMID = wszSOMID;

//    if ( !DeleteInstances( L"RSOP_RegistryPolicySetting", pWbemServices ) )
//         return FALSE;

		// Create & populate RSOP_IERegistryPolicySetting
		_bstr_t bstrClass = L"RSOP_IERegistryPolicySetting";
		ComPtr<IWbemClassObject> pRPS = NULL;
		HRESULT hr = CreateRSOPObject(bstrClass, &pRPS);
		if (SUCCEEDED(hr))
		{
			for ( DWORD i=0; i<HASH_TABLE_SIZE; i++ )
			{
				REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
				while ( pKeyEntry )
				{
					WCHAR *pwszKeyName = pKeyEntry->pwszKeyName;
					REGVALUEENTRY *pValueEntry = pKeyEntry->pValueList;

					while ( pValueEntry )
					{
						DWORD dwOrder = 1;
						WCHAR *pwszValueName = pValueEntry->pwszValueName;
						REGDATAENTRY *pDataEntry = pValueEntry->pDataList;

						while ( pDataEntry )
						{
							// Write RSOP_PolicySetting keys out

							//------------------------------------------------
							// precedence
							OutD(LI2(TEXT("Storing property 'precedence' in %s, value = %lx"),
									(BSTR)bstrClass, m_dwPrecedence));
							hr = PutWbemInstancePropertyEx(L"precedence", (long)m_dwPrecedence, pRPS);

							//------------------------------------------------
							// id
							GUID guid;
							hr = CoCreateGuid( &guid );
							if ( FAILED(hr) ) {
								OutD(LI0(TEXT("Failed to obtain guid" )));
								return FALSE;
							}

							WCHAR wszId[MAX_LENGTH];
							StringFromGUID2(guid, wszId, sizeof(wszId));

							_bstr_t xId( wszId );
							if ( !xId ) {
								 OutD(LI0(TEXT("Failed to allocate memory" )));
								 return FALSE;
							}

							hr = PutWbemInstancePropertyEx(L"id", xId, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// currentUser
							hr = PutWbemInstancePropertyEx(L"currentUser", pKeyEntry->bHKCU ? true : false, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// deleted
							hr = PutWbemInstancePropertyEx(L"deleted", pDataEntry->bDeleted ? true : false, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// name
							_bstr_t xName( pwszValueName );
							hr = PutWbemInstancePropertyEx(L"name", xName, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// valueName
							hr = PutWbemInstancePropertyEx(L"valueName", xName, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// registryKey
							_bstr_t xKey( pwszKeyName );
							hr = PutWbemInstancePropertyEx(L"registryKey", xKey, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// GPOID
							hr = PutWbemInstancePropertyEx(L"GPOID", bstrGPOID, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// SOMID
							hr = PutWbemInstancePropertyEx(L"SOMID", bstrSOMID, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// command
							_bstr_t xCommand( pDataEntry->pwszCommand );
							hr = PutWbemInstancePropertyEx(L"command", xCommand, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// valueType
							hr = PutWbemInstancePropertyEx(L"valueType", (long)pDataEntry->dwValueType, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							//------------------------------------------------
							// value
							// Create a SAFEARRAY from our array of bstr connection names
							SAFEARRAY *psa = NULL;
							if (pDataEntry->dwDataLen > 0)
							{
								psa = CreateSafeArray(VT_UI1, pDataEntry->dwDataLen);
								if (NULL == psa)
								{
									OutD(LI0(TEXT("Failed to allocate memory" )));
									return FALSE;
								}
							}

							for (DWORD iElem = 0; iElem < pDataEntry->dwDataLen; iElem++) 
							{
								hr = SafeArrayPutElement(psa, (LONG*)&iElem, (void*)&pDataEntry->pData[iElem]);
								if ( FAILED( hr ) ) 
								{
									OutD(LI1(TEXT("Failed to SafeArrayPutElement with 0x%x" ), hr ));
									return FALSE;
								}
							}

							VARIANT var;
							var.vt = VT_ARRAY | VT_UI1;
							var.parray = psa;

							hr = PutWbemInstancePropertyEx(L"value", &var, pRPS);
							if ( FAILED(hr) )
								return FALSE;

							OutD(LI0(TEXT("<<object>>")));
							//
							// Commit all above properties by calling PutInstance, semisynchronously
							//
							BSTR bstrObjPath = NULL;
							hr = PutWbemInstance(pRPS, bstrClass, &bstrObjPath);
							if ( FAILED(hr) )
								return FALSE;

							pDataEntry = pDataEntry->pNext;
							dwOrder++;
						}

						pValueEntry = pValueEntry->pNext;

					}   // while pValueEntry

					pKeyEntry = pKeyEntry->pNext;

				}   // while pKeyEntry

			}   // for
			bRet = TRUE;
		}

	    OutD(LI0(TEXT("LogRegistry RsopData: Successfully logged registry Rsop data" )));
	}
	__except(TRUE)
	{
		OutD(LI0(TEXT("Exception in LogRegistryRsopData.")));
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

BOOL    InitializeDependancies(BOOL fInit = TRUE);

HRESULT MoveCabVersionsToHKLM(LPCTSTR pszIns);
LPCTSTR DecodeTitle(LPTSTR pszTitle, LPCTSTR pszIns);
BOOL    SHGetSetActiveDesktop(BOOL fSet, PBOOL pfValue);

#define SHGetFolderPathSimple(nFolder, pszPath) \
    (SHGetFolderPath(NULL, (nFolder), g_GetUserToken(), SHGFP_TYPE_CURRENT, (pszPath)))
HRESULT SHGetFolderLocationSimple(int nFolder, LPITEMIDLIST *ppidl);

LPCTSTR GetIEPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetWebPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetFavoritesPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetChannelsPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetSoftwareUpdatesPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetLinksPath(LPTSTR pszPath = NULL, UINT cch = 0);
LPCTSTR GetQuickLaunchPath(LPTSTR pszPath = NULL, UINT cch = 0);
BOOL    CreateWebFolder();

BOOL    SetFeatureBranded(UINT nID, DWORD dwFlags = FF_ENABLE);
DWORD   GetFeatureBranded(UINT nID);

BOOL    CreateCustomBrandingCabUI(BOOL fCreate = TRUE);

BOOL    SetUserFileOwner(HANDLE hUserToken, LPCTSTR pcszPath);

// download.cpp
BOOL    UpdateBrandingCab(BOOL fForceUpdate);
BOOL    UpdateDesktopCab (BOOL fForceUpdate);
HRESULT DownloadSourceFile(LPCTSTR pszURL, LPTSTR pszTargetPath, UINT cchTargetPath, BOOL fCheckTrust = TRUE);


// cmdline.cpp
static const MAPDW2PSZ g_mpFeatures[] = {
    { FID_CLEARBRANDING,         TEXT("clr")  },
    { FID_MIGRATEOLDSETTINGS,    NULL         },
    { FID_WININETSETUP,          NULL         },
    { FID_CS_DELETE,             TEXT("csd")  },
    { FID_ZONES_HKCU,            TEXT("znu")  },
    { FID_ZONES_HKLM,            NULL         },
    { FID_RATINGS,               NULL         },
    { FID_AUTHCODE,              NULL         },
    { FID_PROGRAMS,              NULL         },
    { FID_EXTREGINF_HKLM,        TEXT("erim") },
    { FID_EXTREGINF_HKCU,        TEXT("eriu") },
    { FID_LCY50_EXTREGINF,       NULL         },
    { FID_GENERAL,               TEXT("gen")  },
    { FID_CUSTOMHELPVER,         TEXT("chv")  },
    { FID_TOOLBARBUTTONS,        TEXT("tbb")  },
    { FID_ROOTCERT,              TEXT("rct")  },
    { FID_FAV_DELETE,            TEXT("favd") },
    { FID_FAV_MAIN,              TEXT("fav")  },
    { FID_FAV_ORDER,             TEXT("favo") },
    { FID_QL_MAIN,               TEXT("ql")   },
    { FID_QL_ORDER,              TEXT("qlo")  },
    { FID_CS_MAIN,               TEXT("cs")   },
    { FID_TPL,                   TEXT("tpl")  },
    { FID_CD_WELCOME,            TEXT("cdw")  },
    { FID_ACTIVESETUPSITES,      NULL         },
    { FID_LINKS_DELETE,          TEXT("lnkd") },
    { FID_OUTLOOKEXPRESS,        TEXT("oe")   },
    { FID_LCY4X_ACTIVEDESKTOP,   TEXT("ad")   },
    { FID_LCY4X_CHANNELS,        TEXT("chl")  },
    { FID_LCY4X_SOFTWAREUPDATES, TEXT("swu")  },
    { FID_LCY4X_WEBCHECK,        TEXT("wchk") },
    { FID_LCY4X_CHANNELBAR,      TEXT("chlb") },
    { FID_LCY4X_SUBSCRIPTIONS,   TEXT("sbs")  },
    { FID_REFRESHBROWSER,        TEXT("ref")  }
};

typedef struct tagCMDLINESWITCHES {
    DWORD dwContext;
    TCHAR szIns[MAX_PATH];
    TCHAR szTargetPath[MAX_PATH];
    BOOL  fPerUser;
    DWORD rgdwFlags[FID_LAST];
    BOOL  fDisable;
} CMDLINESWITCHES, *PCMDLINESWITCHES;

HRESULT GetCmdLineSwitches(PCTSTR pszCmdLine, PCMDLINESWITCHES pcls);


// Miscellaneous
BOOL BackToIE3orLower();

void Out(PCTSTR pszMsg);
void OutD(PCTSTR pszMsg);
void WINAPIV OutEx(PCTSTR pszFmt ...);

void TimerSleep(UINT nMilliSecs);
UINT GetFlagsNumber(DWORD dwFlags);

struct SInitializeDependancies {
// Constructor and Destructor
public:
    SInitializeDependancies()  { InitializeDependancies();      }
    ~SInitializeDependancies() { InitializeDependancies(FALSE); }
};

#define MACRO_InitializeDependacies() SInitializeDependancies init

// NOTE: (oliverl) must overload all references to HKEY_CURRENT_USER since when we're running as a
// GP client side extension we can't trust that HKEY_CURRENT_USER is correct since we're in the
// system context. do not allow the utils APIs that mask HKCU in this module.
#ifndef SHCreateKeyHKCU
#error  SHCreateKeyHKCU was not defined by ieakutil.h yet! Please correct.
#endif
#undef  SHCreateKeyHKCU

#ifndef SHOpenKeyHKCU
#error  SHOpenKeyHKCU was not defined by ieakutil.h yet! Please correct.
#endif
#undef  SHOpenKeyHKCU

// NOTE: (oliverl) save away real HKEY_CURRENT_USER since we need it in globals.cpp to handle non
// GP case.
#ifndef HKEY_CURRENT_USER
#error  HKEY_CURRENT_USER is somehow not defined! Please correct.
#endif
__declspec(selectany) HKEY g_hHKCU = HKEY_CURRENT_USER;
#undef HKEY_CURRENT_USER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\autorun\autorun.c ===
//---------------------------------------------------------------------------
// Internet Explorer 2.0 Demo CD-ROM autorun application
// for questions, contact a-nathk
// MICROSOFT CONFIDENTIAL
//---------------------------------------------------------------------------
#include "autorun.h"
#include "resource.h"
#include <mmsystem.h>
#include <regstr.h>
#include <shlobj.h>
#include <stdio.h>

#define ISK_KILLSETUPHANDLE     WM_USER + 0x0010

#define DEMO    0
#define EXTRAS  1
#define README  2

//---------------------------------------------------------------------------
// appwide globals
HINSTANCE g_hinst = NULL;
HWND    g_hwnd;
BOOL    g_bCustomBMP;
BOOL    g_fCrapForColor = FALSE;
BOOL    g_fNeedPalette = FALSE;
BOOL    g_fMouseAvailable = FALSE;
BOOL    g_fSetup = FALSE;
BOOL    g_fClosed = FALSE;
BOOL    g_fIeRunning = FALSE;
BOOL    g_fRunDemo = FALSE;
BOOL    g_fRunExtras = FALSE;
BOOL    g_fRunReadme = FALSE;
BOOL    g_fSetupRunning = FALSE;
BOOL    g_fIEInstalled = TRUE;
BOOL    g_fChangeIcon = FALSE;
BOOL    g_fNewIEIcon = FALSE;
BOOL    g_fIeOnHardDisk = FALSE;
char    g_szTemp[2048] = {0};
char    g_szTemp2[2048] = {0};
char    g_szCurrentDir[MAX_PATH];
char    g_szTheInternetPath[MAX_PATH];
BYTE    g_abValue[2048];
BYTE    g_abValue2[2048];
DWORD   g_dwLength = 2048;
DWORD   g_dwLength2 = 2048;
DWORD   g_dwType;
DWORD   g_dwBitmapHeight;
DWORD   g_dwBitmapWidth;
DWORD   g_dwWindowHeight;
DWORD   g_dwWindowWidth;
HKEY    g_hkRegKey;
HANDLE  g_hIE = NULL;
HANDLE  g_hSETUP = NULL;
HANDLE  g_hIEExtra = NULL;
HANDLE  g_hREADME = NULL;
DWORD   g_cWait = 0;
HANDLE  g_ahWait[100];
BOOL    g_fClicked = FALSE;

//FARPROC g_pfnWake[10];
void UpdateIE( );
void AutoRunUpdateReg( );
extern BOOL GetDataButtons( LPSTR szCurrentDir );
extern BOOL PathAppend(LPSTR pPath, LPCSTR pMore);
extern BOOL _PathRemoveFileSpec(LPSTR pFile);
extern BOOL GetDataAppTitle( LPSTR szAppTitle, LPSTR szCurrentDir );

//---------------------------------------------------------------------------
// file globals
BOOL    g_fAppDisabled = TRUE;
HHOOK   g_hMouseHook = NULL;
HWND    g_hMainWindow = NULL;   // less of a pain for our mouse hook to see
int     g_iActiveButton = -2;   // less of a pain for our mouse hook to see

const RGBQUAD g_rgbBlack = {0};
const RGBQUAD g_rgbWhite = {0xFF, 0xFF, 0xFF, 0};

#pragma data_seg(".text")
static const char c_szAutoRunPrevention[] = "__Win95SetupDiskQuery";
static const char c_szAutoRunClass[] = "AutoRunMain";
static const char c_szNULL[] = "";
static const char c_szArial[] = "Arial";
static const char c_szButtonClass[] = "Button";
static const char c_szSetupKey[] = REGSTR_PATH_SETUP "\\SETUP";
static const char c_szExpoSwitch[] = "Expostrt";
#pragma data_seg()

//---------------------------------------------------------------------------
// private messages
#define ARM_MOUSEOVER       (WM_APP)

//---------------------------------------------------------------------------
// states for tracking mouse over buttons
#define BTNST_DEAD          (0)
#define BTNST_UP            (1)
#define BTNST_DOWN          (2)
#define BTNST_UNDOWN        (3)

//---------------------------------------------------------------------------
// how to root a relative path (if at all)
#define NOROOT      (0x00000000)
#define ONACD       (0x00000001)
#define INWIN       (0x00000002)
#define INSYS       (0x00000003)
#define INTMP       (0x00000004)
#define ALLROOTS  (0x00000003)

#define ROOTED(app,parms,dir) \
                            ((((DWORD)app)<<6)|(((DWORD)parms)<<3)|(DWORD)dir)

#define CMD_ROOT(item)      ((((DWORD)item)>>6)&ALLROOTS)
#define PARAMS_ROOT(item)   ((((DWORD)item)>>3)&ALLROOTS)
#define DEFDIR_ROOT(item)    (((DWORD)item)&ALLROOTS)

#define dbMSG(msg,title)    (MessageBox(NULL,msg,title,MB_OK | MB_ICONINFORMATION))

#define REGLEN(str)         (strlen(str) + 1)

// button x and y coords.  Default is 59x59

DWORD BUTTON_IMAGE_X_SIZE =     59;
DWORD BUTTON_IMAGE_Y_SIZE =     59;

#define NORMAL_IMAGE_X_OFFSET       (0)
#define FOCUS_IMAGE_X_OFFSET        (BUTTON_IMAGE_X_SIZE)
#define SELECTED_IMAGE_X_OFFSET     (2 * BUTTON_IMAGE_X_SIZE)
#define DISABLED_IMAGE_X_OFFSET     (3 * BUTTON_IMAGE_X_SIZE)

#define BUTTON_DEFAULT_CX           (BUTTON_IMAGE_X_SIZE)
#define BUTTON_DEFAULT_CY           (BUTTON_IMAGE_Y_SIZE)

//#define BUTTON_LABEL_RECT           { -160, 17, -20, 66 }
#define BUTTON_LABEL_RECT           { -160, 15, -10, 100 }
#define BUTTON_LABEL_RECT2           { -160, 18, -10, 90 }

#define DEF_BUTTON_LABEL_HEIGHT         (19)

#define AUTORUN_DESCRIPTION_LEFT    (36)
//#define AUTORUN_DESCRIPTION_TOP     (313)
#define AUTORUN_DESCRIPTION_RIGHT   (360)

DWORD AUTORUN_DESCRIPTION_TOP = 30;
//DWORD AUTORUN_DESCRIPTION_TOP = 313;

#define MIN_WINDOW_WIDTH            500
#define MIN_WINDOW_HEIGHT           300
#define MAX_WINDOW_WIDTH            600
#define MAX_WINDOW_HEIGHT           440
#define DEFAULT_WINDOW_WIDTH        600
#define DEFAULT_WINDOW_HEIGHT       420

//#define AUTORUN_4BIT_TEXTCOLOR             RGB(192,192,192)
//#define AUTORUN_4BIT_HIGHLIGHT             RGB(255,255,255)
//#define AUTORUN_4BIT_DISABLED              RGB(127,127,127)
//#define AUTORUN_4BIT_DESCRIPTION           RGB(192,192,192)


// main text box
#define MAINTEXT_TOPMARGIN      268
#define MAINTEXT_LEFTMARGIN     25
#define MAINTEXT_RIGHTMARGIN    25
#define MAINTEXT_BOTTOMMARGIN   10
//#define MAINTEXT_TOPMARGIN      10
//#define MAINTEXT_LEFTMARGIN     100
//#define MAINTEXT_RIGHTMARGIN    10

/*DWORD AUTORUN_4BIT_TEXTCOLOR = RGB(000,000,000);
DWORD AUTORUN_4BIT_HIGHLIGHT = RGB(000,000,127);
DWORD AUTORUN_4BIT_DISABLED = RGB(000,000,000);
DWORD AUTORUN_4BIT_DESCRIPTION = RGB(000,000,000);
*/
DWORD AUTORUN_4BIT_TEXTCOLOR = RGB(97,137,192);
DWORD AUTORUN_4BIT_HIGHLIGHT = RGB(255,255,255);
DWORD AUTORUN_4BIT_DISABLED = RGB(127,127,127);
DWORD AUTORUN_4BIT_DESCRIPTION = RGB(97,137,192);

//DWORD AUTORUN_8BIT_TEXTCOLOR = RGB(000,000,127);
DWORD AUTORUN_8BIT_TEXTCOLOR = PALETTERGB(97,137,192);
DWORD AUTORUN_8BIT_HIGHLIGHT = PALETTERGB(255,255,255);
DWORD AUTORUN_8BIT_DISABLED = PALETTERGB(127,127,127);
DWORD AUTORUN_8BIT_DESCRIPTION = PALETTERGB(97,137,192);

#define NORMAL 1
#define HIGHLIGHT 2

//#define AUTORUN_4BIT_TEXTCOLOR             RGB(000,000,000)
//#define AUTORUN_4BIT_HIGHLIGHT             RGB(000,000,127)
//#define AUTORUN_4BIT_DISABLED              RGB(107,136,185)
//#define AUTORUN_4BIT_DESCRIPTION           RGB(000,000,127)

//#define AUTORUN_8BIT_TEXTCOLOR      PALETTERGB( 75, 90,129)
//#define AUTORUN_8BIT_HIGHLIGHT             RGB(000,000,000)
//#define AUTORUN_8BIT_DISABLED       PALETTERGB(107,136,185)
//#define AUTORUN_8BIT_DESCRIPTION           RGB(000,000,000)

// button placements.  Default, x=519, y=40
DWORD BUTTON_X_PLACEMENT =  519;
DWORD BUTTON_Y_MARGIN =     0;

//#define BUTTON_Y_MARGIN             (40)

//#define BUTTON_X_PLACEMENT          (519)  x placement = window right - 80
//#define BUTTON_Y_MARGIN             (9)

//#define SHADOW_FACTOR               (930)

#define SHADOW_FACTOR       (0)

#define BUTTON_CLEAR_PALETTE_INDEX  (250)
#define BUTTON_SHADOW_PALETTE_INDEX (251)

#define LABEL_VERIFY_TIMER          (0)

#define MBERROR_INFO                (MB_OKCANCEL | MB_ICONINFORMATION)

//---------------------------------------------------------------------------
typedef struct
{
    int res;            // base for all resources this button owns

    DWORD rooting;      // packed info on how to root paths for the command

    int xpos, ypos;     // location of button in window
    RECT face;          // client coordinates of actual button image on video
    RECT textrect;      // parent coordinates of accompanying label text

    BOOL abdicated;     // did we just release the capture?
    int state;          // what are we doing?

    HWND window;        // handle of button control
    WNDPROC oldproc;    // original window procedure
    BOOL isdorky;       // is this a dorky icon button?

    char text[64];          // the label for the button
    char description[256];  // the description of the button's function

} AUTORUNBTN;

//---------------------------------------------------------------------------
AUTORUNBTN g_ButtonInfo[] =
{
    { IESETUP,    ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 59, 59, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 },
    { IEFROMCD,   ROOTED(ONACD,  NOROOT, ONACD), 0, 0, 0, 0, 59, 59, 0, 0, 0, 0, FALSE, 0, NULL, NULL, FALSE, 0 }
};
#define IDAB_IEFROMCD   1
#define IDAB_IESETUP    0
#define AUTORUN_NUM_BUTTONS (sizeof(g_ButtonInfo)/sizeof(g_ButtonInfo[0]))

//---------------------------------------------------------------------------
typedef struct
{
    HWND window;        // main app window

    HDC image;          // source dc with our cool backdrop
    HBITMAP oldbmp;     // the default bitmap from the dc above
    HDC btnimage;       // source dc with our cool buttons
    HBITMAP oldbtnbmp;  // the default bitmap from the dc above
    HPALETTE palette;   // our app's palette (if any)

    HFONT textfont;     // font for labels
    RECT descrect;      // client coordinates of description text
    int wndheight;      // height of client area

    COLORREF clrnormal;      // normal text color
    COLORREF clrhigh;        // highlighted text color
    COLORREF clrdisable;     // disabled text color
    COLORREF clrdescription; // disabled text color

    BOOL keyboard;      // whether the app is under keyboard control

} AUTORUNDATA;


/////////////////////////////////////////////////////////////////////////////
// randomness
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI AnotherStrToLong(LPCSTR sz)
{
    long l=0;
    BOOL fNeg = (*sz == '-');

    if (fNeg)
        sz++;

    while (*sz >= '0' && *sz <= '9')
        l = l*10 + (*sz++ - '0');

    if (fNeg)
        l *= -1L;

    return l;
}

//---------------------------------------------------------------------------
//      G E T  I E  V E R S I O N
//
//  ISK3
//  This will pull build information out of the system registry and return
//  true if it is less than IE4.
//---------------------------------------------------------------------------
int GetIEVersion( )
{
    HKEY hkIE;
    DWORD dwType;
    DWORD dwSize = 32;
    DWORD result;
    char szData[32];
	BOOL bNotIE4 = 1;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, KEY_READ|KEY_WRITE, &hkIE ) == ERROR_SUCCESS)
    {
        result = RegQueryValueEx( hkIE, "Version", NULL, &dwType, szData, &dwSize );
        if( result == ERROR_SUCCESS )
	    {
		    if(szData[0]=='4')
		    {
			    bNotIE4=0;
		    }
	    }
    
	    RegCloseKey( hkIE );
    }
    
	return bNotIE4;
}

//---------------------------------------------------------------------------
// Convert a string resource into a character pointer
// NOTE: Flag is in case we call this twice before we use the data
char * Res2Str(int rsString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        LoadString(HINST_THISAPP, rsString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    LoadString(HINST_THISAPP, rsString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

//---------------------------------------------------------------------------
BOOL PathFileExists(LPCSTR lpszPath)
{
        return GetFileAttributes(lpszPath) !=-1;
}

//---------------------------------------------------------------------------
//      G E T  I E  P A T H
//
//  ISK3
//  This will retrieve the AppPath for IEXPLORE.EXE from the system registry
//  and return it as a string.
//
//  Parameters:
//      pszString - pointer to buffer to store path
//      nSize     - size of buffer
//---------------------------------------------------------------------------
char *GetIEPath( LPSTR pszString, int nSize )
{
    HKEY hkAppPath;
    DWORD dwType = REG_SZ;
    DWORD dwSize;

    dwSize = nSize;
    RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE",
        0, KEY_READ|KEY_WRITE, &hkAppPath );
    RegQueryValueEx( hkAppPath, "", NULL, &dwType, pszString, &dwSize );
    RegCloseKey( hkAppPath );

    return pszString;
}
//---------------------------------------------------------------------------
//      S E T  I E  H O M E
//
//  ISK3
//  This will set the Start and Search pages in the Registry for Internet
//  Explorer.
//
//  Parameters:
//      pszStart  - pointer to Start Page string
//      pszSearch - pointer to Search Page string
//---------------------------------------------------------------------------
void SetIEHome( LPSTR pszStart, LPSTR pszSearch )
{
    char szExtrasPath[MAX_PATH];
    char szHomePath[MAX_PATH];
    HKEY IEKey;

    lstrcpy( szExtrasPath, "file:" );
    lstrcat( szExtrasPath, g_szCurrentDir );
    lstrcat( szExtrasPath, pszStart );
	//Home CD Page
    lstrcpy( szHomePath, "file:" );
    lstrcat( szHomePath, g_szCurrentDir );
    lstrcat( szHomePath, pszSearch );

    if (RegOpenKeyEx(HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Internet Explorer\\Main",0,KEY_QUERY_VALUE, &IEKey) == ERROR_SUCCESS)
    {
        RegSetValueEx(IEKey, "Start Page", 0, REG_SZ, szExtrasPath , REGLEN(szExtrasPath));
        RegSetValueEx(IEKey, "Search Page", 0, REG_SZ, szHomePath, REGLEN(szHomePath));
        RegCloseKey( IEKey );
    }
}

/////////////////////////////////////////////////////////////////////////////
// main crap
/////////////////////////////////////////////////////////////////////////////
BOOL AssembleButtonImagesReal(AUTORUNDATA *data, HDC cellimage, HDC srcimage,
    SIZE size)
{
    RGBQUAD rgbSrc[256], rgbCell[256], rgbMask[256] = {0};
    HBITMAP dstbmp = CreateCompatibleBitmap(data->image, size.cx, size.cy);
    UINT uColors, uSrcColors, u;
    int iButton;

    //
    // set up the destination dc
    //
    if (!dstbmp)
        return FALSE;

    if ((data->btnimage = CreateCompatibleDC(data->image)) == NULL)
    {
        DeleteBitmap(dstbmp);
        return FALSE;
    }

    data->oldbtnbmp = SelectBitmap(data->btnimage, dstbmp);

    //
    // build a tile of the cell backgrounds based on button positions
    //
    for (iButton = 0; iButton < AUTORUN_NUM_BUTTONS; iButton++)
    {
        AUTORUNBTN *pButton = g_ButtonInfo + iButton;

        if (pButton->res != -1)
        {
            int xsrc = pButton->xpos;
            int ysrc = pButton->ypos;
            int xdst, ydst = iButton * BUTTON_IMAGE_Y_SIZE;

            for (xdst = 0; xdst < size.cx; xdst += BUTTON_IMAGE_X_SIZE)
            {
                BitBlt(cellimage, xdst, ydst, BUTTON_IMAGE_X_SIZE,
                    BUTTON_IMAGE_Y_SIZE, data->image, xsrc, ysrc,
                    SRCCOPY);
            }
        }
    }

    //
    // copy the entire cell backgrounds to the destination image
    //
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, cellimage, 0, 0, SRCCOPY);

    //
    // save the color table of the source image for posterity
    //
    uSrcColors = GetDIBColorTable(srcimage, 0, 256, rgbSrc);

    //
    // mask out holes on the destination for the buttons and shadows
    //
//    rgbMask[0] = g_rgbWhite;
    rgbMask[BUTTON_CLEAR_PALETTE_INDEX] = g_rgbWhite;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbMask);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCAND);

    //
    // dim the background cells to produce the shadow image
    //
    u = uColors = GetDIBColorTable(cellimage, 0, 256, rgbCell);
    while (u--)
    {
        rgbCell[u].rgbBlue =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbBlue / 1000);
        rgbCell[u].rgbGreen =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbGreen / 1000);
        rgbCell[u].rgbRed =
            (BYTE)(SHADOW_FACTOR * (UINT)rgbCell[u].rgbRed / 1000);
    }
    SetDIBColorTable(cellimage, 0, uColors, rgbCell);

    //
    // mask out the shadows and add them to the destination image
    //
//    rgbMask[0] = g_rgbBlack;
//    rgbMask[1] = g_rgbWhite;
    rgbMask[BUTTON_CLEAR_PALETTE_INDEX] = g_rgbBlack;
    rgbMask[BUTTON_SHADOW_PALETTE_INDEX] = g_rgbWhite;

    SetDIBColorTable(srcimage, 0, uSrcColors, rgbMask);
    BitBlt(cellimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCAND);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, cellimage, 0, 0, SRCPAINT);

    //
    // mask out the button faces and add them to the destination image
    //
//    rgbSrc[0] = rgbSrc[1] = g_rgbBlack;
    rgbSrc[BUTTON_CLEAR_PALETTE_INDEX] = rgbSrc[BUTTON_SHADOW_PALETTE_INDEX] = g_rgbBlack;
    SetDIBColorTable(srcimage, 0, uSrcColors, rgbSrc);
    BitBlt(data->btnimage, 0, 0, size.cx, size.cy, srcimage, 0, 0, SRCPAINT);

    // all done
    return TRUE;
}

//---------------------------------------------------------------------------
BOOL AssembleButtonImages(AUTORUNDATA *data)
{
    BOOL result = FALSE;
    HBITMAP hbmSrc;
    char szBmpPath[MAX_PATH];

    lstrcpy( szBmpPath, g_szCurrentDir );
    lstrcat( szBmpPath, "\\btns.bmp" );

    hbmSrc = LoadImage(HINST_THISAPP, szBmpPath, IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION | LR_LOADFROMFILE);

    if( !hbmSrc )
    {
        hbmSrc = LoadImage(HINST_THISAPP,
            MAKEINTRESOURCE(IDB_8BPP_BUTTONS),IMAGE_BITMAP, 0, 0,
            LR_CREATEDIBSECTION);
    }

    if (hbmSrc)
    {
        HDC hdcSrc = CreateCompatibleDC(data->image);
        BITMAP bm;

        GetObject(hbmSrc, sizeof(bm), &bm);

        if (hdcSrc)
        {
            HBITMAP hbmSrcOld = SelectBitmap(hdcSrc, hbmSrc);

// changed for iak
//            SIZE size = {bm.bmWidth, bm.bmHeight};
            SIZE size = {g_dwWindowWidth, g_dwWindowHeight};

            HBITMAP hbmTmp =
                CreateCompatibleBitmap(data->image, size.cx, size.cy);

            if (hbmTmp)
            {
                HDC hdcTmp = CreateCompatibleDC(data->image);

                if (hdcTmp)
                {
                    HBITMAP hbmTmpOld = SelectBitmap(hdcTmp, hbmTmp);

                    result = AssembleButtonImagesReal(data, hdcTmp, hdcSrc,
                        size);

                    SelectBitmap(hdcTmp, hbmTmpOld);
                    DeleteDC(hdcTmp);

                }

                DeleteBitmap(hbmTmp);
            }

            SelectBitmap(hdcSrc, hbmSrcOld);
            DeleteDC(hdcSrc);
        }

        DeleteBitmap(hbmSrc);
    }

    return result;
}

//---------------------------------------------------------------------------
LRESULT CALLBACK
AutoRunButtonSubclassProc(HWND window, UINT msg, WPARAM wp, LPARAM lp)
{
    int index = (int)GetWindowLongPtr(window, GWLP_ID);

    if ((index >= 0) && (index < AUTORUN_NUM_BUTTONS))
    {
        if (msg == WM_KEYDOWN)
            PostMessage(GetParent(window), msg, wp, lp);

        return CallWindowProc((g_ButtonInfo + index)->oldproc,
            window, msg, wp, lp);
    }

    return 0L;
}

//---------------------------------------------------------------------------
#define DORKYBUTTONSTYLE \
    (WS_CHILD | WS_VISIBLE | BS_ICON | BS_CENTER | BS_VCENTER)

HWND AutoRunCreateDorkyButton(AUTORUNDATA *data, AUTORUNBTN *button)
{
    HICON icon = LoadIcon(HINST_THISAPP, IDI_ICON(button->res));
    HWND child = NULL;

    if (icon)
    {
        child = CreateWindow(c_szButtonClass, c_szNULL, DORKYBUTTONSTYLE,
            0, 0, 0, 0, data->window, NULL, HINST_THISAPP, 0);

        if (child)
        {
            button->isdorky = TRUE;
            SendMessage(child, BM_SETIMAGE, MAKEWPARAM(IMAGE_ICON,0),
                (LPARAM)icon);
        }
    }

    return child;
}

//---------------------------------------------------------------------------
#define COOLBUTTONSTYLE \
    (WS_CHILD | WS_VISIBLE | BS_OWNERDRAW)

HWND AutoRunCreateCoolButton(AUTORUNDATA *data, AUTORUNBTN *button)
{
    return CreateWindow(c_szButtonClass, c_szNULL, COOLBUTTONSTYLE,
        0, 0, 0, 0, data->window, NULL, HINST_THISAPP, 0);
}

//---------------------------------------------------------------------------
void AutoRunCreateButtons(AUTORUNDATA *data)
{
    RECT labelbase = BUTTON_LABEL_RECT;
    RECT labelbase2 = BUTTON_LABEL_RECT2;
    int i;

    for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
    {
        AUTORUNBTN *button = g_ButtonInfo + i;
        HWND child = NULL;

        if (button->res != -1)
        {
            if( g_fCrapForColor )
            {
                child = AutoRunCreateDorkyButton( data, button );
            }

            if (!g_fCrapForColor)
            if(GetDataButtons(g_szCurrentDir))
                child = AutoRunCreateCoolButton(data, button);

            if (!child)
                child = AutoRunCreateDorkyButton(data, button);
        }

        if (child)
        {
            int cx = BUTTON_DEFAULT_CX;
            int cy = BUTTON_DEFAULT_CY;

            button->window = child;
            SetWindowLongPtr(child, GWLP_ID, i);
            button->oldproc = SubclassWindow(child,
                (WNDPROC)AutoRunButtonSubclassProc);

            if (button->isdorky)
            {
                cx = button->face.right - button->face.left;
                cy = button->face.bottom - button->face.top;
            }

            SetWindowPos(child, NULL, button->xpos, button->ypos, cx, cy,
                SWP_NOZORDER | SWP_NOACTIVATE);

            LoadString(HINST_THISAPP, IDS_TITLE(button->res),
                button->text, ARRAYSIZE(button->text));

            LoadString(HINST_THISAPP, IDS_INFO(button->res),
                button->description, ARRAYSIZE(button->description));
				if (i != 1)
					{
               button->textrect = labelbase;
					}
				else
					{
               button->textrect = labelbase2;
					}
            OffsetRect(&button->textrect, button->xpos, button->ypos);
            InvalidateRect(data->window, &button->textrect, FALSE);
        }
    }
}

//---------------------------------------------------------------------------
void CleanupAutoRunWindow(AUTORUNDATA *data)
{
    //
    // Deactivate any button so its timer will get killed
    //
    if (g_iActiveButton >= 0)
    {
        data->keyboard = FALSE;
        SendMessage(data->window, ARM_MOUSEOVER, TRUE, (LPARAM)-1L);
    }

    if (data->image)
    {
        if (data->oldbmp)
        {
            SelectBitmap(data->image, data->oldbmp);
            // real backdrop image is deleted in WinMain
            data->oldbmp = NULL;
        }

        DeleteDC(data->image);
        data->image = NULL;
    }

    if (data->btnimage)
    {
        if (data->oldbtnbmp)
        {
            DeleteBitmap(SelectBitmap(data->btnimage, data->oldbtnbmp));
            data->oldbtnbmp = NULL;
        }

        DeleteDC(data->btnimage);
        data->btnimage = NULL;
    }

    if (data->palette)
    {
        DeleteObject(data->palette);
        data->palette = NULL;
    }

    if (data->textfont)
    {
        DeleteObject(data->textfont);
        data->textfont = NULL;
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunBuildPath(char *spec, int resid, DWORD rooting)
{
    char prefix[MAX_PATH];

    //
    // get the relative path of the spec
    //
    if (resid == -1)
    {
        //
        // empty string hack for callers
        //
        *spec = 0;
    }
    else
    {
        //
        // normal case
        //
        if (!LoadString(HINST_THISAPP, resid, spec, MAX_PATH))
            return FALSE;
    }

    //
    // our "empty" strings contain a single space so we know they succeeded
    //
    if ((*spec == ' ') && !spec[1])
        *spec = 0;

    //
    // figure out what the prefix should be
    //
    *prefix = 0;
    switch (rooting)
    {
        case ONACD:
            //
            // assume the cd is the root of wherever we were launched from
            //
//            GetModuleFileName(HINST_THISAPP, prefix, ARRAYSIZE(prefix));
//            _PathStripToRoot(prefix);
            lstrcpy( prefix, g_szCurrentDir );
            break;

        case INWIN:
            GetRealWindowsDirectory(prefix, ARRAYSIZE(prefix));
            break;

        case INSYS:
            GetSystemDirectory(prefix, ARRAYSIZE(prefix));
            break;

        case INTMP:
            GetTempPath(ARRAYSIZE(prefix), prefix);
            break;
    }

    //
    // if we have a prefix then prepend it
    //
    if (*prefix)
    {
        if (*spec)
        {
            //
            // tack the spec onto its new prefix
            //
            PathAppend(prefix, spec);
        }

        //
        // copy the whole mess out to the original buffer
        //
        lstrcpy(spec, prefix);
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL InitAutoRunWindow(HWND window, AUTORUNDATA *data, LPCREATESTRUCT cs)
{
    AUTORUNBTN *button;

    data->window = window;

    if ((data->image = CreateCompatibleDC(NULL)) == NULL)
        goto im_doug;

    if ((data->oldbmp = SelectBitmap(data->image,
        (HBITMAP)cs->lpCreateParams)) == NULL)
    {
        goto im_doug;
    }

    if (g_fNeedPalette)
    {
        if ((data->palette = PaletteFromDS(data->image)) == NULL)
            goto im_doug;
    }

    // artifical scoping oh boy!
    {
        BITMAP bm;
        int i, ivis = 0;
        int range = 0;
        int origin, extent;

        for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
        {
            button = g_ButtonInfo + i;

            if (button->res != -1)
                range++;
        }

        GetObject((HBITMAP)cs->lpCreateParams, sizeof(bm), &bm);
        origin = BUTTON_Y_MARGIN * ((1 + AUTORUN_NUM_BUTTONS) - range);

// changed for iak
//        extent = bm.bmHeight - ((2 * origin) + BUTTON_IMAGE_Y_SIZE);
        extent = g_dwWindowHeight - ((2 * origin) + BUTTON_IMAGE_Y_SIZE);

        if (--range < 1)
            range = 1;

        for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
        {
            button = g_ButtonInfo + i;

            if (button->res != -1)
            {
                button->xpos = BUTTON_X_PLACEMENT;
//                //button->ypos = ivis * extent / range + origin;
//                button->ypos = (ivis * extent) + (g_dwWindowHeight / 2) - BUTTON_IMAGE_Y_SIZE;
//                button->ypos = (g_dwWindowHeight / 3) * (ivis + 1) + 20;
                button->ypos = (g_dwWindowHeight / 4) * (ivis) + 20;
                ivis++;
            }
        }
    }

    // more artifical scoping!
    {
        HDC screen = GetDC(NULL);
        LOGFONT lf = { DEF_BUTTON_LABEL_HEIGHT, 0, 0, 0, FW_BOLD, FALSE,
            FALSE, FALSE, (screen? GetTextCharset(screen) : DEFAULT_CHARSET),
            OUT_STROKE_PRECIS, CLIP_DEFAULT_PRECIS,
            PROOF_QUALITY | NONANTIALIASED_QUALITY,
            VARIABLE_PITCH | FF_DONTCARE, 0 };
        char buf[32];

        if (screen)
            ReleaseDC(NULL, screen);

        if (!LoadString(HINST_THISAPP, IDS_LABELFONT, lf.lfFaceName,
            ARRAYSIZE(lf.lfFaceName)))
        {
            lstrcpy(lf.lfFaceName, c_szArial);
        }

        if (LoadString(HINST_THISAPP, IDS_LABELHEIGHT, buf, ARRAYSIZE(buf)))
            lf.lfHeight = AnotherStrToLong(buf);

        if ((data->textfont = CreateFontIndirect(&lf)) == NULL)
            goto im_doug;
    }
    //
    // see if we need to do 8bit+ work...
    //

    if (g_fCrapForColor)
    {
        data->clrnormal      = AUTORUN_4BIT_TEXTCOLOR;
        data->clrhigh        = AUTORUN_4BIT_HIGHLIGHT;
        data->clrdisable     = AUTORUN_4BIT_DISABLED;
        data->clrdescription = AUTORUN_4BIT_DESCRIPTION;
    }
    else
    {
        data->clrnormal      = AUTORUN_8BIT_TEXTCOLOR;
        data->clrhigh        = AUTORUN_8BIT_HIGHLIGHT;
        data->clrdisable     = AUTORUN_8BIT_DISABLED;
        data->clrdescription = AUTORUN_8BIT_DESCRIPTION;
        if (!AssembleButtonImages(data))
            goto im_doug;
    }

    PostMessage(g_hMainWindow, ARM_MOUSEOVER, TRUE, (LPARAM)-1L);
    return TRUE;

im_doug:
    CleanupAutoRunWindow(data);
    return FALSE;
}

//---------------------------------------------------------------------------
void AutoRunSized(AUTORUNDATA *data)
{
#ifdef DESCRIPTIONS
    GetClientRect(data->window, &data->descrect);
    data->wndheight = data->descrect.bottom - data->descrect.top;
    data->descrect.left = AUTORUN_DESCRIPTION_LEFT;
    data->descrect.top = AUTORUN_DESCRIPTION_TOP;
    data->descrect.right = AUTORUN_DESCRIPTION_RIGHT;
#else
    SetRectEmpty( &data->descrect);
#endif
}

//---------------------------------------------------------------------------
void AutoRunRealize(HWND window, AUTORUNDATA *data, HDC theirdc)
{
    if (data->palette)
    {
        HDC dc = theirdc? theirdc : GetDC(window);

        if (dc)
        {
            BOOL repaint = FALSE;

            SelectPalette(dc, data->palette, FALSE);
            repaint = (RealizePalette(dc) > 0);

            if (!theirdc)
                ReleaseDC(window, dc);

            if (repaint)
            {
                RedrawWindow(window, NULL, NULL, RDW_INVALIDATE |
                    RDW_ERASE | RDW_ALLCHILDREN);
            }
        }
    }
}

//---------------------------------------------------------------------------
void AutoRunErase(AUTORUNDATA *data, HDC dc)
{
    RECT rc;
    RECT textrect;

    GetClientRect(data->window, &rc);

    AutoRunRealize(data->window, data, dc);
    BitBlt(dc, 0, 0, rc.right, rc.bottom, data->image, 0, 0, SRCCOPY);

//    StretchBlt(dc, 0, 0, rc.right, rc.bottom, data->image, 0, 0, g_dwBitmapWidth, g_dwBitmapHeight, SRCCOPY);

    textrect.top = MAINTEXT_TOPMARGIN;
    textrect.left = MAINTEXT_LEFTMARGIN;
    textrect.right = g_dwWindowWidth - MAINTEXT_RIGHTMARGIN;
    textrect.bottom = g_dwWindowHeight - MAINTEXT_BOTTOMMARGIN;
//    textrect.bottom = g_dwWindowHeight / 2;

    SetBkMode(dc, TRANSPARENT);

    if( g_fCrapForColor )
        SetTextColor( dc, AUTORUN_4BIT_TEXTCOLOR );
    else
        SetTextColor( dc, AUTORUN_8BIT_TEXTCOLOR );

    if(!g_bCustomBMP) //if there is a custom bitmap, don't put up our text
    {
        DrawText(dc, Res2Str( IDS_MAINTEXT ), -1, &textrect,
            DT_WORDBREAK | DT_LEFT | DT_TOP);
    }
}

//---------------------------------------------------------------------------
void AutoRunPaint(AUTORUNDATA *data)
{
    PAINTSTRUCT ps;
    HDC dc = BeginPaint(data->window, &ps);
    AUTORUNBTN *button;
    COLORREF curtextcolor = GetTextColor(dc);
    COLORREF color;
    HFONT hfold = NULL;
    int i;

    AutoRunRealize(data->window, data, dc);
    SetBkMode(dc, TRANSPARENT);

    //
    // paint all the button labels
    //
    if (data->textfont)
        hfold = SelectFont(dc, data->textfont);

    for (i = 0; i < AUTORUN_NUM_BUTTONS; i++)
    {
        button = g_ButtonInfo + i;

        if (button->window)
        {
            color = (i == g_iActiveButton)? data->clrhigh :
                (IsWindowEnabled(button->window)? data->clrnormal :
                data->clrdisable);

            if (color != curtextcolor)
            {
                SetTextColor(dc, color);
                curtextcolor = color;
            }

            DrawText(dc, button->text, -1, &button->textrect,
                DT_WORDBREAK | DT_RIGHT | DT_TOP);
        }
    }

/* Removed for ISK3
    //
    // paint the description for the current button
    //
    if (g_iActiveButton >= 0)
    {
        button = g_ButtonInfo + g_iActiveButton;

        color = data->clrdescription;
        if (color != curtextcolor)
        {
            SetTextColor(dc, color);
            curtextcolor = color;
        }

// Removed for ISK3
//        DrawText(dc, button->description, -1, &data->descrect,
//            DT_WORDBREAK | DT_LEFT | DT_TOP);
    }
*/

    if (hfold)
        SelectFont(dc, hfold);

    EndPaint(data->window, &ps);
}

//---------------------------------------------------------------------------
void AutoRunDrawItem(AUTORUNDATA *data, DRAWITEMSTRUCT *dis)
{
    POINT loc = { dis->rcItem.left, dis->rcItem.top };
    SIZE size = { dis->rcItem.right - loc.x, dis->rcItem.bottom - loc.y };

    loc.y += dis->CtlID * BUTTON_IMAGE_Y_SIZE;

    if (dis->itemState & ODS_DISABLED)
    {
        loc.x += DISABLED_IMAGE_X_OFFSET;
    }
    else if (dis->itemState & ODS_SELECTED)
    {
        loc.x += SELECTED_IMAGE_X_OFFSET;
    }
    else if (dis->itemState & ODS_FOCUS)
    {
        loc.x += FOCUS_IMAGE_X_OFFSET;
    }

    AutoRunRealize(dis->hwndItem, data, dis->hDC);
    BitBlt(dis->hDC, dis->rcItem.left, dis->rcItem.top, size.cx, size.cy,
        data->btnimage, loc.x, loc.y, SRCCOPY);
}

//---------------------------------------------------------------------------
void AutoRunActivateItem(AUTORUNDATA *data, int index)
{
    if (index >= 0)
    {
        //
        // prevent disabled buttons from getting focus...
        //
        AUTORUNBTN *button = g_ButtonInfo + index;
        if (!button->window || !IsWindowEnabled(button->window))
            index = -1;
    }

    if (g_iActiveButton != index)
    {
        AUTORUNBTN *newbtn = (index >= 0)? (g_ButtonInfo + index) : NULL;
        AUTORUNBTN *oldbtn = (g_iActiveButton >= 0)?
            (g_ButtonInfo + g_iActiveButton) : NULL;

        //
        // if there was an previous button, repaint its label highlight
        //
        if (oldbtn)
            InvalidateRect(data->window, &oldbtn->textrect, FALSE);

        g_iActiveButton = index;

        if (newbtn)
        {
            InvalidateRect(data->window, &newbtn->textrect, FALSE);
            SetFocus(newbtn->window);

            //
            // if activating via mouse, track it (trust me...)
            //
            if (g_fMouseAvailable && !data->keyboard)
                SetTimer(data->window, LABEL_VERIFY_TIMER, 333, NULL);
        }
        else
        {
            SetFocus(data->window);

            if (g_fMouseAvailable)
                KillTimer(data->window, LABEL_VERIFY_TIMER);
        }

        //
        // go ahead and paint any label changes now before we erase
        //
        UpdateWindow(data->window);
        InvalidateRect(data->window, &data->descrect, TRUE);
    }
}

//---------------------------------------------------------------------------
void AutoRunMouseOver(AUTORUNDATA *data, int index, BOOL fForce)
{
    if ((index >= 0) || !data->keyboard || fForce)
    {
        data->keyboard = !g_fMouseAvailable;
        AutoRunActivateItem(data, index);
    }
}

//---------------------------------------------------------------------------
int AutoRunProcessPotentialHit(HWND candidate, const POINT *loc)
{
    if (GetAsyncKeyState(VK_LBUTTON) < 0)
        return g_iActiveButton;

    if (candidate && IsWindowEnabled(candidate) &&
        (GetParent(candidate) == g_hMainWindow))
    {
        int index;

        index = (int)GetWindowLongPtr(candidate, GWLP_ID);
        if ((index >= 0) && (index < AUTORUN_NUM_BUTTONS))
        {
            AUTORUNBTN *button = g_ButtonInfo + index;
            POINT cli = *loc;

            ScreenToClient(candidate, &cli);
            if (PtInRect(&button->face, cli)||PtInRect(&button->textrect,cli))
                return index;
        }
    }

    return -1;
}

//---------------------------------------------------------------------------
void AutoRunVerifyActiveItem(AUTORUNDATA *data)
{
    if (!data->keyboard)
    {
        int index = -1;

        if (!g_fAppDisabled)
        {
            POINT loc;
            HWND candidate;

            GetCursorPos(&loc);

            if ((candidate = WindowFromPoint(loc)) != NULL)
                index = AutoRunProcessPotentialHit(candidate, &loc);
        }

        if (index != g_iActiveButton)
            AutoRunMouseOver(data, index, FALSE);
    }
}

//---------------------------------------------------------------------------
void AutorunEnableButton(AUTORUNDATA *data, int id, BOOL f)
{
    if ((id >= 0) && (id < AUTORUN_NUM_BUTTONS))
    {
        AUTORUNBTN *button = g_ButtonInfo + id;
        HWND window = button->window;

        if (button->window && IsWindow(button->window))
        {
            EnableWindow(button->window, f);
            InvalidateRect(data->window, &button->textrect, FALSE);
            AutoRunVerifyActiveItem(data);
        }
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunCDIsInDrive( )
{
    char me[MAX_PATH];
    GetModuleFileName(HINST_THISAPP, me, ARRAYSIZE(me));

    while (!PathFileExists(me))
    {
        if (MessageBox(NULL,Res2Str(IDS_NEEDCDROM),
            Res2Str(IDS_APPTITLE),
            MB_OKCANCEL | MB_ICONSTOP) == IDCANCEL)
        {
            return FALSE;
        }
    }
    return TRUE;
}
//---------------------------------------------------------------------------
void AutoRunMinimize( BOOL fMin )
{
    HWND hwndIE;

    if( fMin )
    {
        //Find Autorun App and Minimize it.
        hwndIE = FindWindow( "AutoRunMain", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_MINIMIZE, 0L );
    }
    else
    {
        //Find Autorun App and Restore it.
        hwndIE = FindWindow( "AutoRunMain", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_RESTORE, 0L );
    }
}

//ZZZZ
//---------------------------------------------------------------------------
HANDLE AutoRunExec( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;

    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);


    if( ShellExecuteEx(&sei) )
    {
        g_ahWait[g_cWait] = sei.hProcess;
        g_cWait += 1;

        return sei.hProcess;
    }

    return NULL;

}

//---------------------------------------------------------------------------
BOOL AutoRunKillProcess( DWORD dwResult )
{
    char lpFName[MAX_PATH];
    char szCommand[MAX_PATH];
    char szDir[MAX_PATH];
    char szPath[MAX_PATH];
    HKEY    hkRunOnce;
    HKEY    hkIE;

    AutoRunCDIsInDrive();   //make sure we still have the CD in

    if( g_ahWait[dwResult] == g_hSETUP )
    {
		g_cWait -= 1;
        CloseHandle( g_ahWait[dwResult] );
        MoveMemory( &g_ahWait[dwResult], &g_ahWait[dwResult + 1], ARRAYSIZE(g_ahWait) - dwResult - 1);
        g_hSETUP = NULL;

        g_fSetupRunning = FALSE;

        AutoRunMinimize( FALSE );   //restore autorun app

        // See if the user actually installed IE

        GetWindowsDirectory( lpFName, MAX_PATH );
        lstrcat( lpFName, "\\inf\\mos105e.inf" );

        if( GetFileAttributes( lpFName ) != 0xFFFFFFFF )
        {

            g_fSetup = TRUE;
            if (!g_fIEInstalled) g_fNewIEIcon = TRUE;
            g_fIEInstalled = TRUE;
            g_fChangeIcon = TRUE;

            lstrcpy(szCommand, g_szCurrentDir);
            lstrcat(szCommand, Res2Str(IDS_CMD_MSN));
            lstrcpy(szDir, g_szCurrentDir);
            lstrcat(szDir, "\\");
            ShellExecute( NULL, NULL, szCommand, " ", szDir, SW_SHOWNORMAL );
        }

        SetFocus( g_hwnd );

        return TRUE;
    }

    if( g_ahWait[dwResult] == g_hIE )
    {
		g_cWait -= 1;
        CloseHandle( g_ahWait[dwResult] );
        MoveMemory( &g_ahWait[dwResult], &g_ahWait[dwResult + 1], ARRAYSIZE(g_ahWait) - dwResult - 1);
        g_hIE = NULL;
        g_fIeRunning = FALSE;

        if( !g_fRunReadme && !g_fRunExtras && !g_fRunDemo && !g_fSetupRunning)
        {
            AutoRunMinimize( FALSE );   //restore autorun app
        }

        return TRUE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
void AutoRunKillIE( void )
{
    HWND hwndIE;

    hwndIE = FindWindow( "IEFrame", NULL );
    PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );

}

//AAA
//---------------------------------------------------------------------------
void AutoRunClick(AUTORUNDATA *data, int nCmd)
{
    char command[MAX_PATH], dir[MAX_PATH], params[MAX_PATH];
    char lpFName[MAX_PATH];
    char szMSNCommand[MAX_PATH];
    char szMSNDir[MAX_PATH];
    AUTORUNBTN *button;
    HKEY    IEKey;
    DWORD   dwLength = 2048;
    HWND    hwndIE;

    if( g_fSetupRunning ) goto cancelquit;  //if setup is running, get out of here

    AutoRunMinimize( TRUE );    //Minimize autorun app

    if ((nCmd < 0) || (nCmd >= AUTORUN_NUM_BUTTONS))
        return;

    button = g_ButtonInfo + nCmd;

    AutoRunBuildPath( command, IDS_CMD(button->res), CMD_ROOT(button->rooting));
    AutoRunBuildPath( dir, IDS_DIR(button->res), DEFDIR_ROOT(button->rooting));

    //
    // verify that the app disk is still visible and prompt if not...
    //
    if(!AutoRunCDIsInDrive( )) return;

    if(nCmd == IDAB_IEFROMCD)
    {
        HANDLE hReadme;

        PlaySound(MAKEINTRESOURCE(IDW_DEMO), HINST_THISAPP,
            SND_RESOURCE | SND_SYNC | SND_NODEFAULT);

        g_hIE = AutoRunExec( command, " ", dir, SW_SHOWNORMAL );

    }

    if(nCmd == IDAB_IESETUP)
    {
        HKEY hkRegKey,hkRunOnce;
		char szPath[MAX_PATH];
		char szWinPath[MAX_PATH];
		char szDestPath[MAX_PATH];
        DWORD dwVal;

        PlaySound(MAKEINTRESOURCE(IDW_INSTALL), HINST_THISAPP,
            SND_RESOURCE | SND_SYNC | SND_NODEFAULT);

        GetWindowsDirectory( szWinPath, MAX_PATH );
        wsprintf( szPath, "%s\\isk3ro.exe %s\\iecd.exe", szWinPath, g_szCurrentDir );
        if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, KEY_READ|KEY_WRITE, &hkRunOnce ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hkRunOnce, "ShowIE4Plus", 0, REG_SZ, szPath, REGLEN(szPath));
            dwVal = 1;
            RegSetValueEx( hkRunOnce, "DisableStartHtm", 0, REG_DWORD, (CONST BYTE *)&dwVal, sizeof(dwVal));
            RegCloseKey( hkRunOnce );
        }

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hkRegKey, "IEFromCD", 0, REG_SZ, "1", 2 );
            RegCloseKey( hkRegKey );
        }

        g_fClicked = TRUE;

        g_hSETUP = AutoRunExec( command, " ", dir, SW_SHOWNORMAL );
//        g_fSetupRunning = TRUE;

		PostMessage(g_hwnd,WM_CLOSE,(WPARAM) 0,(LPARAM) 0);
    }

cancelquit:
    ;

}

//---------------------------------------------------------------------------
void AutoRunHandleKeystroke(AUTORUNDATA *data, TCHAR key, LPARAM lp)
{
    int move = 0;
    int where = g_iActiveButton;

    //
    // see if we care about this keystroke
    //
    switch (key)
    {
    case VK_RETURN:
        if (where >= 0)
            AutoRunClick(data, where);
        //fallthru
    case VK_ESCAPE:
        where = -1;
        break;

    case VK_TAB:
        move = (GetKeyState(VK_SHIFT) < 0)? -1 : 1;
        break;

    case VK_END:
        where = AUTORUN_NUM_BUTTONS;
        //fallthru
    case VK_UP:
    case VK_LEFT:
        move = -1;
        break;

    case VK_HOME:
        where = -1;
        //fallthru
    case VK_DOWN:
    case VK_RIGHT:
        move = 1;
        break;

    default:
        return;
    }

    //
    // we should only get down here if the active button is going to change
    //
    if (move)
    {
        int scanned;

        for (scanned = 0; scanned <= AUTORUN_NUM_BUTTONS; scanned++)
        {
            where += move;

            if (where >= (int)AUTORUN_NUM_BUTTONS)
            {
                where = -1;
            }
            else if (where < 0)
            {
                where = AUTORUN_NUM_BUTTONS;
            }
            else
            {
                HWND child = (g_ButtonInfo + where)->window;
                if (child && IsWindowEnabled(child))
                    break;
            }
        }

    }

    if (where >= 0)
    {
        SetCursor(NULL);
        data->keyboard = TRUE;
    }
    else
        data->keyboard = !g_fMouseAvailable;

    AutoRunActivateItem(data, where);
}

//---------------------------------------------------------------------------
BOOL CheckVersionConsistency(AUTORUNDATA *data)
{
    DWORD dwResult;
    DWORD dwMajor;
    DWORD dwMinor;
    BOOL result = FALSE;

    dwResult = GetVersion();
    dwMajor = (DWORD)(LOBYTE(LOWORD(dwResult)));
    dwMinor = (DWORD)(HIBYTE(LOWORD(dwResult)));

    if( dwMajor == 4 && dwResult >= 0x80000000 )    //windows 95
    {
        result = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}

//---------------------------------------------------------------------------
LRESULT CALLBACK AutoRunMouseHook(int code, WPARAM wp, LPARAM lp)
{
    if (code >= 0)
    {
        #define hook ((MOUSEHOOKSTRUCT *)lp)
        int id = g_fAppDisabled? -1 :
            AutoRunProcessPotentialHit(hook->hwnd, &hook->pt);

        if (id != g_iActiveButton)
            PostMessage(g_hMainWindow, ARM_MOUSEOVER, FALSE, (LPARAM)id);

        #undef hook
    }

    return CallNextHookEx(g_hMouseHook, code, wp, lp);
}


// CreateLink - uses the shell's IShellLink and IPersistFile interfaces
//   to create and store a shortcut to the specified object.
// Returns the result of calling the member functions of the interfaces.
// lpszPathObj - address of a buffer containing the path of the object
// lpszPathLink - address of a buffer containing the path where the
//   shell link is to be stored
// lpszDesc - address of a buffer containing the description of the
//   shell link
HRESULT CreateLink(LPCSTR lpszPathObj,
    LPSTR lpszPathLink, LPSTR lpszDesc)
{
    HRESULT hres;
    IShellLink* psl;

    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(&CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, &IID_IShellLink, &psl);
    if (SUCCEEDED(hres)) {
        IPersistFile* ppf;

        // Set the path to the shortcut target, and add the
        // description.
        psl->lpVtbl->SetPath(psl, lpszPathObj);
        psl->lpVtbl->SetDescription(psl, lpszDesc);

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
        hres = psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile,
            &ppf);

        if (SUCCEEDED(hres)) {
            WORD wsz[MAX_PATH];

            // Ensure that the string is ANSI.
            MultiByteToWideChar(CP_ACP, 0, lpszPathLink, -1,
                wsz, MAX_PATH);

            // Save the link by calling IPersistFile::Save.
            hres = ppf->lpVtbl->Save(ppf, wsz, TRUE);
            ppf->lpVtbl->Release(ppf);
        }
        psl->lpVtbl->Release(psl);
    }
    return hres;
}
//---------------------------------------------------------------------------
void InstallICWScript( )
{
    char szDest[MAX_PATH];
    char szSource[MAX_PATH];
    HKEY hkAppPath;
    DWORD dwType;
    DWORD dwLength = MAX_PATH;

    memset( szDest, 0, MAX_PATH );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE",
        0, KEY_READ|KEY_WRITE, &hkAppPath ) != ERROR_SUCCESS )
        return;
    RegQueryValueEx( hkAppPath, "", NULL, &dwType, szDest, &dwLength );
    RegCloseKey( hkAppPath );

    if( lstrlen( szDest ) == 0 )
        return;

    _PathRemoveFileSpec( szDest );

    lstrcat( szDest, "\\ICWSCRPT.EXE" );

    wsprintf( szSource, "%s\\..\\ICWSCRPT.EXE", g_szCurrentDir );

    CopyFile( szSource, szDest, FALSE );

}

//---------------------------------------------------------------------------
LRESULT CALLBACK AutoRunWndProc(HWND window, UINT msg, WPARAM wp, LPARAM lp)
{
    AUTORUNDATA *data = (AUTORUNDATA *)GetWindowLongPtr(window, GWLP_USERDATA);
    HWND hwndIE;
    char szPath[MAX_PATH];
    char szWinPath[MAX_PATH];
    char szDestPath[MAX_PATH];
    HKEY hkIE;
    HKEY hkRunOnce;

    switch (msg)
    {
    case WM_NCCREATE:
        data = (AUTORUNDATA *)LocalAlloc(LPTR, sizeof(AUTORUNDATA));
        if (data && !InitAutoRunWindow(window, data, (LPCREATESTRUCT)lp))
        {
            LocalFree((HANDLE)data);
            data = NULL;
        }
        SetWindowLongPtr(window, GWLP_USERDATA, (UINT_PTR)data);
        if (!data)
            return FALSE;
        g_hMainWindow = window;
        goto DoDefault;

    case WM_CREATE:
        PlaySound(MAKEINTRESOURCE(IDW_STARTAPP), HINST_THISAPP,
            SND_RESOURCE | SND_ASYNC | SND_NODEFAULT);

        AutoRunCreateButtons(data);
        ShowWindow(window, SW_SHOWNORMAL);

        g_hwnd = window;

// version - fix for NT
//        if(!CheckVersionConsistency(data))
//            return -1;

        GetWindowsDirectory( szWinPath, MAX_PATH );
        wsprintf( szPath, "%s\\isk3ro.exe", g_szCurrentDir );
        wsprintf( szDestPath, "%s\\isk3ro.exe", szWinPath );
        
		if(GetFileAttributes(szDestPath)!=0xFFFFFFFF)
		{
			SetFileAttributes(szDestPath,FILE_ATTRIBUTE_ARCHIVE);
			
			DeleteFile(szDestPath);
		}

		CopyFile( szPath, szDestPath, FALSE );

        wsprintf( szPath, "%s\\welc.exe", g_szCurrentDir );
        wsprintf( szDestPath, "%s\\welc.exe", szWinPath );
        
		CopyFile( szPath, szDestPath, FALSE );

        break;

    case WM_CLOSE:

/*        hwndIE = FindWindow( "IEFrame", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );

        if (g_cWait)
        {
            ShowWindow(window, SW_HIDE);
            g_fClosed = TRUE;
            break;
        }
*/
        goto DoDefault;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_NCDESTROY:
        if (data)
        {
            CleanupAutoRunWindow(data);
            LocalFree((HANDLE)data);
        }
        g_hMainWindow = NULL;
        goto DoDefault;

    case WM_ENDSESSION:
        if( !g_fClicked ) // bugid 3099
            goto DoDefault;

//        GetWindowsDirectory( szWinPath, MAX_PATH );
//        wsprintf( szPath, "%s\\packages\\isk3ro.exe", g_szCurrentDir );
//        wsprintf( szDestPath, "%s\\%s\\isk3ro.exe", szWinPath, Res2Str( IDS_STARTUPGROUP ));
//        wsprintf( szDestPath, "%s\\isk3ro.exe", szWinPath );
//        CopyFile( szPath, szDestPath, FALSE );
        GetWindowsDirectory( szWinPath, MAX_PATH );
        wsprintf( szPath, "%s\\isk3ro.exe %s\\iecd.exe", szWinPath, g_szCurrentDir );
        RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce", 0, KEY_READ|KEY_WRITE, &hkRunOnce );
        RegSetValueEx( hkRunOnce, "RunPlus", 0, REG_SZ, szPath, REGLEN(szPath));
        RegCloseKey( hkRunOnce );

        GetWindowsDirectory( szWinPath, MAX_PATH );

//        InstallICWScript( );

//        wsprintf( szPath, "%s\\isk3ro.exe %s\\..\\setup.exe", szWinPath, g_szCurrentDir );
//        wsprintf( szDestPath, "%s\\%s\\isk3ro.exe", szWinPath, Res2Str( IDS_STARTUPGROUP ));
//        CreateLink( szPath, szDestPath, "Internet Starter Kit");

        if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Explorer\\Document Windows", 0, KEY_READ|KEY_WRITE, &hkIE ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hkIE, "Maximized", 0, REG_SZ, "yes", 4 );
            RegCloseKey( hkIE );
        }
        goto DoDefault;

    case WM_SIZE:
        AutoRunSized(data);
        break;

    case WM_DRAWITEM:
        AutoRunDrawItem(data, (DRAWITEMSTRUCT *)lp);
        break;

    case ARM_MOUSEOVER:
        AutoRunMouseOver(data, (int)lp, (BOOL)wp);
        break;

    case WM_ACTIVATE:
        g_fAppDisabled = ((LOWORD(wp) == WA_INACTIVE) || HIWORD(wp));
        AutoRunVerifyActiveItem(data);
        goto DoDefault;

    case WM_TIMER:
        AutoRunVerifyActiveItem(data);
        break;

    case ISK_KILLSETUPHANDLE:
        CloseHandle( g_hSETUP );
        break;

    case WM_KEYDOWN:
        AutoRunHandleKeystroke(data, (TCHAR)wp, lp);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wp, lp) == BN_CLICKED)
		{
            EnableWindow(window, FALSE);
					
            AutoRunClick(data, GET_WM_COMMAND_ID(wp, lp));

			EnableWindow(window, TRUE);
		}
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wp == window)
            break;
        //fallthru
    case WM_QUERYNEWPALETTE:
        AutoRunRealize(window, data, NULL);
        break;

    case WM_ERASEBKGND:
        AutoRunErase(data, (HDC)wp);
        break;

    case WM_PAINT:
        AutoRunPaint(data);
        break;

    default:
    DoDefault:
        return DefWindowProc(window, msg, wp, lp);
    }

    return 1;
}


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    char szAppTitle[128];
    char szBmpPath[MAX_PATH];
    WNDCLASS wc;
    HBITMAP hbm = NULL;
    BITMAP bm;
    DWORD style;
    HWND window;
    RECT r;
    HDC screen;
    int retval = -1;
    HWND hwndIE;
    HKEY hkRegKey;

    g_hinst = hInstance;

    //in case this is run from another directory...
    GetModuleFileName( NULL, g_szCurrentDir, MAX_PATH );
    _PathRemoveFileSpec( g_szCurrentDir );

    // put our path into the registry
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hkRegKey, "IESKPath", 0, REG_SZ, g_szCurrentDir, lstrlen( g_szCurrentDir ) + 1 );
        RegCloseKey( hkRegKey );
    }

    //
    // is setup asking the user to insert a disk?
    //
/*    window = FindWindow(c_szAutoRunPrevention, c_szAutoRunPrevention);
    if (window)
    {
        // do nothing
        // setup is probably trying to copy a driver or something...
        retval = 0;
        goto im_doug;
    }
*/
    //
    // overwrite default apptitle if data file exists
    //
    GetDataAppTitle( szAppTitle, g_szCurrentDir );

    if( lstrlen( szAppTitle ) == 0 ) {
        lstrcpy( szAppTitle, Res2Str( IDS_APPTITLE ));
    }

    //
    // identity crisis?
    //
    window = FindWindow(c_szAutoRunClass, szAppTitle);
    if (window)
    {
        retval = 0;
        hwndIE = FindWindow( "IEFrame", NULL );
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_MINIMIZE, 0L );

//        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );
        ShowWindowAsync(window, SW_SHOWNORMAL);
        SetForegroundWindow(window);
        goto im_doug;
    }
    //kill Internet Explorer if it is running
    hwndIE = FindWindow( "IEFrame", NULL );
    if( hwndIE != NULL )
    {
        if( MessageBox( NULL, Res2Str( IDS_IERUNNINGMSG ), Res2Str( IDS_APPTITLE ), MB_YESNO | MB_ICONINFORMATION ) == IDNO )
        {
            goto im_doug;
        }
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );
    }
    //kill Internet Explorer if it is running
    hwndIE = FindWindow( "Internet Explorer_Frame", NULL );
    if( hwndIE != NULL )
    {
        if( MessageBox( NULL, Res2Str( IDS_IERUNNINGMSG ), Res2Str( IDS_APPTITLE ), MB_YESNO | MB_ICONINFORMATION ) == IDNO )
        {
            goto im_doug;
        }
        PostMessage( hwndIE, WM_SYSCOMMAND, SC_CLOSE, 0L );
    }

    //
    // yet more mundane platform-centric details
    //
    if (!GetClassInfo(HINST_THISAPP, c_szAutoRunClass, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = AutoRunWndProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szAutoRunClass;

        if (!RegisterClass(&wc))
            goto im_doug;
    }

    //
    // get text color information from .ini file
    //

    AUTORUN_8BIT_TEXTCOLOR = GetDataTextColor( NORMAL, g_szCurrentDir );
    AUTORUN_8BIT_HIGHLIGHT = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );
    AUTORUN_8BIT_DESCRIPTION = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );
    AUTORUN_4BIT_TEXTCOLOR = GetDataTextColor( NORMAL, g_szCurrentDir );
    AUTORUN_4BIT_HIGHLIGHT = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );
    AUTORUN_4BIT_DESCRIPTION = GetDataTextColor( HIGHLIGHT, g_szCurrentDir );

    //
    // get a few tidbits about the display we're running on
    //
    screen = GetDC(NULL);

#if defined (DEBUG) && defined (FORCE_CRAP)
    g_fCrapForColor = TRUE;
#else
    g_fCrapForColor = (GetDeviceCaps(screen, PLANES) *
        GetDeviceCaps(screen, BITSPIXEL)) < 8;
#endif

    g_fNeedPalette = (!g_fCrapForColor &&
        (GetDeviceCaps(screen, RASTERCAPS) & RC_PALETTE));

    ReleaseDC(NULL, screen);

    //
    // load the window backdrop image
    //

    lstrcpy( szBmpPath, g_szCurrentDir );
    lstrcat( szBmpPath, "\\back.bmp" );
    hbm = LoadImage( NULL, szBmpPath, IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION | LR_LOADFROMFILE );

    g_bCustomBMP=TRUE;

    if(!hbm)    //if it doesn't exist, load the default
    {
        hbm = LoadImage(HINST_THISAPP, MAKEINTRESOURCE(g_fCrapForColor?
            IDB_4BPP_BACKDROP : IDB_8BPP_BACKDROP), IMAGE_BITMAP, 0, 0,
            LR_CREATEDIBSECTION );

        g_bCustomBMP=FALSE;
    }

    if (!hbm)
        goto im_doug;

//    if(!GetDataBackdrop( hbm ))
//        goto im_doug;


    //
    //
    // see if there is a moose around
    //
    if ((g_fMouseAvailable = (GetSystemMetrics(SM_MOUSEPRESENT) != 0)) != 0)
    {
        //
        // set up a moose hook for our thread
        // don't worrke if it fails, the app will stil work...
        //
        g_hMouseHook = SetWindowsHookEx(WH_MOUSE, AutoRunMouseHook,
            HINST_THISAPP, GetCurrentThreadId());
    }

    //
    // create the window based on the backdrop image
    //
    GetObject(hbm, sizeof(bm), &bm);

    g_dwBitmapWidth = bm.bmWidth;
    g_dwBitmapHeight = bm.bmHeight;
    g_dwWindowWidth = bm.bmWidth;
    g_dwWindowHeight = bm.bmHeight;
/*
    if( g_dwBitmapWidth < MIN_WINDOW_WIDTH || g_dwBitmapHeight < MIN_WINDOW_HEIGHT || g_dwBitmapHeight > MAX_WINDOW_HEIGHT || g_dwBitmapWidth > MAX_WINDOW_WIDTH)
    {
        // scale the window to a default scale.
        r.left = (GetSystemMetrics(SM_CXSCREEN) - DEFAULT_WINDOW_WIDTH) / 2;
        r.top = (GetSystemMetrics(SM_CYSCREEN) - DEFAULT_WINDOW_HEIGHT) / 3; // intended
        r.right = r.left + DEFAULT_WINDOW_WIDTH;
        r.bottom = r.top + DEFAULT_WINDOW_HEIGHT;
        g_dwWindowWidth = DEFAULT_WINDOW_WIDTH;
        g_dwWindowHeight = DEFAULT_WINDOW_HEIGHT;
    }
    else
    {
*/
        r.left = (GetSystemMetrics(SM_CXSCREEN) - bm.bmWidth) / 2;
        r.top = (GetSystemMetrics(SM_CYSCREEN) - bm.bmHeight) / 3; // intended
        r.right = r.left + bm.bmWidth;
        r.bottom = r.top + bm.bmHeight;
//    }

    BUTTON_X_PLACEMENT = g_dwWindowWidth - 80;
    AUTORUN_DESCRIPTION_TOP = g_dwWindowHeight - 100;

    style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
    AdjustWindowRect(&r, style, FALSE);

    g_hMainWindow = CreateWindow(c_szAutoRunClass, szAppTitle, style,
        r.left, r.top, r.right - r.left, r.bottom - r.top, NULL, NULL,
        HINST_THISAPP, hbm);

    //
    // if we got here it's probably safe to show ourselves and pump messages
    //
    if (g_hMainWindow)
    {
        MSG msg;

        for (;;)
        {
            DWORD dwResult = MsgWaitForMultipleObjects(g_cWait, g_ahWait, FALSE,
                INFINITE, QS_ALLINPUT);

            if (dwResult == WAIT_OBJECT_0 + g_cWait)
            {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                        goto get_out;
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else
            {
                dwResult -= WAIT_OBJECT_0;
                if( AutoRunKillProcess( dwResult ) )
                {
                    if( g_fClosed ) {
                        goto get_out;
                    }
                }
            }
        }

    get_out:

        retval = (int)msg.wParam;
    }

//    InstallICWScript( );

im_doug:
    //
    // random cleanup
    //
    if (g_hMouseHook)
    {
        UnhookWindowsHookEx(g_hMouseHook);
//        g_hMouseHook = NULL;
    }

    if (hbm)
        DeleteObject(hbm);

    // delete ini out of temp dir
    GetTempPath( MAX_PATH, szBmpPath );
    lstrcat( szBmpPath, "\\iecd.ini" );
    DeleteFile( szBmpPath );

    return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\brandll\utils.cpp ===
#include "precomp.h"
#include <shlobjp.h>                            // for SHELLSTATE structure only
#include "cabver.h"

// Private forward decalarations
#define SHGetSetSettings 68

void getSetOwnerPrivileges(BOOL fSet);

BOOL InitializeDependancies(BOOL fInit /*= TRUE*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, InitializeDependancies)

    static int s_iComRef = 0;

    if (fInit) {
        HRESULT hr;

        // initialize COM
        if (s_iComRef == 0) {
            hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            if (SUCCEEDED(hr))
                Out(LI1(TEXT("COM initialized with %s success code."), GetHrSz(hr)));

            else if (hr == RPC_E_CHANGED_MODE) {
                hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
                if (SUCCEEDED(hr))
                    Out(LI1(TEXT("COM initialized on a second attempt with %s success code!"), GetHrSz(hr)));
            }

            if (FAILED(hr)) {
                Out(LI1(TEXT("! COM initialization failed with %s."), GetHrSz(hr)));
                return FALSE;
            }
        }
        s_iComRef++;

        MACRO_LI_Offset(-1);                    // last thing to do on init
    }
    else {
        MACRO_LI_Offset(+1);                    // first thing to do on uninit

        // free COM
        if (s_iComRef == 1)
            CoUninitialize();

        if (s_iComRef > 0)
            s_iComRef--;
    }

    return TRUE;
}


HRESULT MoveCabVersionsToHKLM(LPCTSTR pszIns)
{   MACRO_LI_PrologEx_C(PIF_STD_C, MoveCabVersionsToHKLM)

    TCHAR   szInsLine[INTERNET_MAX_URL_LENGTH + 50],
            szVersion[32], szDate[32];
    LPCTSTR rgpszInsInfo[6];
    LPTSTR  pszCabFileURL, pszDelim;
    HKEY    hkNew,    hkOld,
            hkNewCur, hkOldCur;
    DWORD   cchVersion, cchDate,
            dwResult;
    BOOL    fResult;

    Out(LI0(TEXT("Migrating cabs version information to per-machine settings...")));

    // HKLM information exists -> no migration is needed
    dwResult = SHOpenKeyHKLM(RK_IEAK_CABVER, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkNew);
    if (dwResult == ERROR_SUCCESS) {
        SHCloseKey(hkNew);

        SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
        SHDeleteEmptyKey(g_GetHKCU(), RK_IEAK);

        Out(LI0(TEXT("Per-machine settings already exist!")));
        return S_FALSE;
    }

    // no HKCU information -> bail out
    dwResult = SHOpenKey(g_GetHKCU(), RK_IEAK_CABVER, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkOld);
    if (dwResult != ERROR_SUCCESS) {
        Out(LI0(TEXT("! Cabs version information is absent.")));
        return (dwResult == ERROR_FILE_NOT_FOUND) ? E_UNEXPECTED : E_FAIL;
    }

    //----- Main processing -----
    dwResult = SHCreateKeyHKLM(RK_IEAK_CABVER, KEY_CREATE_SUB_KEY | KEY_SET_VALUE, &hkNew);
    if (dwResult != ERROR_SUCCESS)
        return E_FAIL;

    // move version sections of individual cabs
    rgpszInsInfo[0] = IS_CUSTOMBRANDING; rgpszInsInfo[1] = IK_BRANDING;
    rgpszInsInfo[2] = IS_CUSTOMDESKTOP;  rgpszInsInfo[3] = IK_DESKTOP;
    rgpszInsInfo[4] = IS_CUSTOMCHANNELS; rgpszInsInfo[5] = IK_CHANNELS;

    fResult = TRUE;
    for (UINT i = 0; i < countof(rgpszInsInfo); i += 2) {
        GetPrivateProfileString(rgpszInsInfo[i], rgpszInsInfo[i+1], TEXT(""), szInsLine, countof(szInsLine), pszIns);
        if (szInsLine[0] == TEXT('\0'))
            GetPrivateProfileString(IS_CUSTOMVER, rgpszInsInfo[i+1], TEXT(""), szInsLine, countof(szInsLine), pszIns);
        if (szInsLine[0] == TEXT('\0')) {
            fResult = FALSE;
            Out(LI1(TEXT("! Download URL for \"%s\" cab can not be determined."), rgpszInsInfo[i+1]));
            continue;
        }

        dwResult = SHOpenKey(hkOld, rgpszInsInfo[i+1], KEY_QUERY_VALUE, &hkOldCur);
        if (dwResult != ERROR_SUCCESS) {
            fResult = FALSE;
            Out(LI1(TEXT("! Version information for \"%s\" cab is absent."), rgpszInsInfo[i+1]));
            continue;
        }

        dwResult = SHCreateKey(hkNew, rgpszInsInfo[i+1], KEY_SET_VALUE, &hkNewCur);
        if (dwResult != ERROR_SUCCESS) {
            ASSERT(hkOldCur != NULL);
            SHCloseKey(hkOldCur);

            fResult = FALSE;
            continue;
        }

        // cab url
        pszCabFileURL = szInsLine;
        pszDelim      = StrChr(pszCabFileURL, TEXT(','));
        if (pszDelim != NULL)
            *pszDelim = TEXT('\0');
        StrRemoveWhitespace(pszCabFileURL);

        // version
        szVersion[0] = TEXT('\0');
        cchVersion   = sizeof(szVersion);
        RegQueryValueEx(hkOldCur, RV_VERSION, NULL, NULL, (LPBYTE)&szVersion, &cchVersion);

        // date
        szDate[0] = TEXT('\0');
        cchDate   = sizeof(szDate);
        RegQueryValueEx(hkOldCur, RV_DATE, NULL, NULL, (LPBYTE)&szDate, &cchDate);

        RegSetValueEx(hkNewCur, RV_URL,     0, REG_SZ, (LPBYTE)pszCabFileURL, (DWORD)StrCbFromSz(pszCabFileURL));
        RegSetValueEx(hkNewCur, RV_VERSION, 0, REG_SZ, (LPBYTE)szVersion,     cchVersion);
        RegSetValueEx(hkNewCur, RV_DATE,    0, REG_SZ, (LPBYTE)szDate,        cchDate);

        SHCloseKey(hkOldCur);
        SHCloseKey(hkNewCur);
    }

    SHCloseKey(hkOld);
    SHCloseKey(hkNew);

    SHDeleteKey(g_GetHKCU(), RK_IEAK_CABVER);
    SHDeleteEmptyKey(g_GetHKCU(), RK_IEAK);

    Out(LI0(TEXT("Done.")));
    return S_OK;
}


LPCTSTR DecodeTitle(LPTSTR pszTitle, LPCTSTR pszIns)
{
    static BOOL fInit = FALSE,
                fDecode;

    TCHAR   szBuffer[MAX_PATH];
    LPCTSTR pszFrom;
    LPTSTR  pszTo;
    TCHAR   chAux;

    if (!fInit) {
        fDecode = InsGetBool(IS_BRANDING, IK_FAVORITES_ENCODE, FALSE, pszIns);
        fInit   = TRUE;
    }

    if (!fDecode)
        return pszTitle;

    pszFrom = szBuffer;
    pszTo   = pszTitle;
    StrCpy(szBuffer, pszTitle);

    while ((chAux = *pszFrom++) != TEXT('\0'))
        if (chAux != TEXT('%'))
            *pszTo++ = chAux;

        else
            switch (chAux = *pszFrom++) {
                case TEXT('('): *pszTo++ = TEXT('['); break;
                case TEXT(')'): *pszTo++ = TEXT(']'); break;
                case TEXT('-'): *pszTo++ = TEXT('='); break;
                case TEXT('%'): *pszTo++ = TEXT('%'); break;
                case TEXT('/'): *pszTo++ = IsDBCSLeadByte((CHAR)*(pszTo-1)) ? TEXT('\\') : TEXT('/'); break;
                default       : *pszTo++ = TEXT('%'); *pszTo++ = chAux; break;
            }

    *pszTo = TEXT('\0');
    return pszTitle;
}

BOOL SHGetSetActiveDesktop(BOOL fSet, PBOOL pfValue)
{   MACRO_LI_PrologEx_C(PIF_STD_C, SHGetSetActiveDesktop)

    typedef void (WINAPI *PFNSHGETSET)(LPSHELLSTATE, DWORD, BOOL);

    SHELLSTATE  ss;
    PFNSHGETSET pfnSHGetSet;
    HINSTANCE   hShell32Dll;
    BOOL        fResult;

    if (pfValue == NULL)
        return FALSE;
    fResult = FALSE;

    hShell32Dll = LoadLibrary(TEXT("shell32.dll"));
    if (hShell32Dll == NULL) {
        Out(LI0(TEXT("! \"shell32.dll\" could not be loaded.")));
        goto Exit;
    }

    pfnSHGetSet = (PFNSHGETSET)GetProcAddress(hShell32Dll, (LPCSTR)SHGetSetSettings);
    if (pfnSHGetSet == NULL) {
        Out(LI0(TEXT("! \"SHGetSetSettings\" in shell32.dll was not found.")));
        goto Exit;
    }

    ZeroMemory(&ss, sizeof(ss));
    if (fSet)
        ss.fDesktopHTML = *pfValue;

    // NOTE: (andrewgu) unicode vs. ansi issue. we are fine here even though on w95/ie4/ad4
    // shell32.dll is ansi. we may end up calling with unicode SHELLSTATE on this platform and get
    // back ansi stuff. the only variable were it matters is pszHiddenFileExts, which we never
    // reference.
    (*pfnSHGetSet)(&ss, SSF_DESKTOPHTML, fSet);

    if (!fSet)
        *pfValue = ss.fDesktopHTML;

    fResult = TRUE;

Exit:
    if (hShell32Dll != NULL)
        FreeLibrary(hShell32Dll);

    return fResult;
}

HRESULT SHGetFolderLocationSimple(int nFolder, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    hr = E_FAIL;
    if (!IsOS(OS_NT5)) {
        nFolder &= ~CSIDL_FLAG_MASK;
        hr       = SHGetSpecialFolderLocation(NULL, nFolder, ppidl);
    }
    else {
        // need to call NT5 version in case we need to impersonate the user
        HINSTANCE hShell32Dll;

        if (NULL != ppidl)
            *ppidl = NULL;

        hShell32Dll = LoadLibrary(TEXT("shell32.dll"));
        if (NULL != hShell32Dll) {
            typedef HRESULT (WINAPI *PSHGETFOLDERLOCATION)(HWND, int, HANDLE, DWORD, LPITEMIDLIST *);

            PSHGETFOLDERLOCATION pfnSHGetFolderLocation;

            pfnSHGetFolderLocation = (PSHGETFOLDERLOCATION)GetProcAddress(hShell32Dll, "SHGetFolderLocation");
            if (NULL != pfnSHGetFolderLocation)
                hr = pfnSHGetFolderLocation(NULL, nFolder, g_GetUserToken(), 0, ppidl);

            FreeLibrary(hShell32Dll);
        }
    }

    return hr;
}


LPCTSTR GetIEPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{
    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        PTSTR pszAux;
        LONG  lResult;

        s_dwSize = sizeof(s_szPath);
        lResult = SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\iexplore.exe"), RV_PATH, NULL, (LPBYTE)&s_szPath, &s_dwSize);
        if (lResult != ERROR_SUCCESS)
            return NULL;

        ASSERT(s_dwSize > 0);
        s_dwSize /= sizeof(TCHAR);
        s_dwSize--;

        if (StrRemoveWhitespace(s_szPath))
            s_dwSize = StrLen(s_szPath);

        ASSERT(s_dwSize > 0);
        if (s_szPath[s_dwSize - 1] == TEXT(';')) {
            s_szPath[s_dwSize - 1] = TEXT('\0');
            s_dwSize--;
        }

        pszAux = PathRemoveBackslash(s_szPath);
        if (*pszAux == TEXT('\0'))              // backslash was removed
            s_dwSize--;
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetWebPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetWebPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (g_CtxIsGp())
    {
        StrCpy(s_szPath, g_GetTargetPath());
        s_dwSize = StrLen(s_szPath) + 1;
    }
    else
    {
        if (s_szPath[0] == TEXT('\0')) {
            s_dwSize = GetWindowsDirectory(s_szPath, countof(s_szPath));
            
            PathAppend(s_szPath, FOLDER_WEB);
            s_dwSize += 1 + countof(FOLDER_WEB)-1;
            
            Out(LI1(TEXT("<Web> folder location is \"%s\"."), s_szPath));
        }
        else
            ASSERT(s_dwSize > 0);
    }

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetFavoritesPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetFavoritesPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        if (FAILED(SHGetFolderPathSimple(CSIDL_FAVORITES, s_szPath)))
            return NULL;

        s_dwSize = StrLen(s_szPath);
        Out(LI1(TEXT("<Favorites> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetChannelsPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetChannelsPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        TCHAR   szFolder[MAX_PATH];
        LPCTSTR pszFavoritesPath;

        pszFavoritesPath = GetFavoritesPath();
        if (pszFavoritesPath == NULL)
            return NULL;

        szFolder[0] = TEXT('\0');
        LoadString(g_GetHinst(), IDS_FOLDER_CHANNELS, szFolder, countof(szFolder));
        if (szFolder[0] == TEXT('\0'))
            return NULL;

        PathCombine(s_szPath, pszFavoritesPath, szFolder);
        s_dwSize = StrLen(s_szPath);

        if (!PathFileExists(s_szPath))
            return NULL;

        Out(LI1(TEXT("<Channels> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetSoftwareUpdatesPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetSoftwareUpdatesPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        TCHAR   szFolder[MAX_PATH];
        LPCTSTR pszFavoritesPath;

        pszFavoritesPath = GetFavoritesPath();
        if (pszFavoritesPath == NULL)
            return NULL;

        szFolder[0] = TEXT('\0');
        LoadString(g_GetHinst(), IDS_FOLDER_SOFTWAREUPDATES, szFolder, countof(szFolder));
        if (szFolder[0] == TEXT('\0'))
            return NULL;

        PathCombine(s_szPath, pszFavoritesPath, szFolder);
        s_dwSize = StrLen(s_szPath);

        if (!PathFileExists(s_szPath))
            return NULL;

        Out(LI1(TEXT("<Software Updates> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetLinksPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetLinksPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        TCHAR   szFolder[MAX_PATH];
        LPCTSTR pszFavoritesPath;

        pszFavoritesPath = GetFavoritesPath();
        if (pszFavoritesPath == NULL)
            return NULL;

        szFolder[0] = TEXT('\0');
        LoadString(g_GetHinst(), IDS_FOLDER_LINKS, szFolder, countof(szFolder));
        if (szFolder[0] == TEXT('\0'))
            return NULL;

        PathCombine(s_szPath, pszFavoritesPath, szFolder);
        s_dwSize = StrLen(s_szPath);

        if (!PathFileExists(s_szPath))
            return NULL;

        Out(LI1(TEXT("<Links> folder location is \"%s\"."), s_szPath));
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

LPCTSTR GetQuickLaunchPath(LPTSTR pszPath /*= NULL*/, UINT cch /*= 0*/)
{   MACRO_LI_PrologEx_C(PIF_STD_C, GetQuickLinksPath)

    static TCHAR s_szPath[MAX_PATH];
    static DWORD s_dwSize;

    if (pszPath != NULL)
        *pszPath = TEXT('\0');

    if (s_szPath[0] == TEXT('\0')) {
        HRESULT hr;
        TCHAR szAux[MAX_PATH];

        hr = SHGetFolderPathSimple(CSIDL_APPDATA, s_szPath);
        if (FAILED(hr))
            GetWindowsDirectory(s_szPath, countof(s_szPath));
        
        LoadString(g_GetHinst(), IDS_FOLDER_QUICKLAUNCH, szAux, countof(szAux));

        PathAppend(s_szPath, TEXT("Microsoft\\Internet Explorer"));
        PathAppend(s_szPath, szAux);
    }
    else
        ASSERT(s_dwSize > 0);

    if (pszPath == NULL || cch <= (UINT)s_dwSize)
        return s_szPath;

    StrCpy(pszPath, s_szPath);
    return pszPath;
}

BOOL CreateWebFolder()
{
    LPCTSTR pszWebPath;

    pszWebPath = GetWebPath();
    if (pszWebPath == NULL)
        return FALSE;

    if (PathFileExists(pszWebPath))
        return TRUE;

    return CreateDirectory(pszWebPath, NULL);
}


static MAPDW2PSZ
    s_rgZonesHKCU     [] = { { FF_ENABLE, RV_BF_ZONES_HKCU         } },
    s_rgZonesHKLM     [] = { { FF_ENABLE, RV_BF_ZONES_HKLM         } },
    s_rgRatings       [] = { { FF_ENABLE, RV_BF_RATINGS            } },
    s_rgAuthcode      [] = { { FF_ENABLE, RV_BF_AUTHCODE           } },
    s_rgPrograms      [] = { { FF_ENABLE, RV_BF_PROGRAMS           } },
    s_rgGeneral       [] = {
        { FF_GEN_TITLE,        RV_BF_TITLE        },
        { FF_GEN_HOMEPAGE,     RV_BF_HOMEPAGE     },
        { FF_GEN_SEARCHPAGE,   RV_BF_SEARCHPAGE   },
        { FF_GEN_HELPPAGE,     RV_BF_HELPPAGE     },
        { FF_GEN_UASTRING,     RV_BF_UASTRING     },
        { FF_GEN_TOOLBARBMP,   RV_BF_TOOLBARBMP   },
        { FF_GEN_STATICLOGO,   RV_BF_STATICLOGO   },
        { FF_GEN_ANIMATEDLOGO, RV_BF_ANIMATEDLOGO },
        { FF_GEN_TBICONTHEME,  RV_BF_TBICONTHEME  }
//      not required in the GP context
//      { FF_GEN_FIRSTHOMEPAGE,RV_BF_FIRSTHOMEPAGE}
    },
    s_rgToolbarButtons[] = { { FF_ENABLE, RV_BF_TOOLBARBUTTONS     } },
    s_rgFavorites     [] = { { FF_ENABLE, RV_BF_FAVORITES          } },
    s_rgConSettings   [] = { { FF_ENABLE, RV_BF_CONNECTIONSETTINGS } },
    s_rgChannels      [] = { { FF_ENABLE, RV_BF_CHANNELS           } };

static struct {
    PMAPDW2PSZ pmapFlagToRegValue;
    UINT       cMapEntries;
} s_mapFidToRegInfo[] = {
    { NULL,               0                           },    // FID_CLEARBRANDING
    { NULL,               0                           },    // FID_MIGRATEOLDSETTINGS
    { NULL,               0                           },    // FID_WININETSETUP
    { NULL,               0                           },    // FID_CS_DELETE
    { s_rgZonesHKCU,      countof(s_rgZonesHKCU)      },    // FID_ZONES_HKCU
    { s_rgZonesHKLM,      countof(s_rgZonesHKLM)      },    // FID_ZONES_HKLM
    { s_rgRatings,        countof(s_rgRatings)        },    // FID_RATINGS
    { s_rgAuthcode,       countof(s_rgAuthcode)       },    // FID_AUTHCODE
    { s_rgPrograms,       countof(s_rgPrograms)       },    // FID_PROGRAMS
    { NULL,               0                           },    // FID_EXTREGINF_HKLM
    { NULL,               0                           },    // FID_EXTREGINF_HKCU
    { NULL,               0                           },    // FID_LCY50_EXTREGINF
    { s_rgGeneral,        countof(s_rgGeneral)        },    // FID_GENERAL
    { NULL,               0                           },    // FID_CUSTOMHELPVER
    { s_rgToolbarButtons, countof(s_rgToolbarButtons) },    // FID_TOOLBARBUTTONS
    { NULL,               0                           },    // FID_ROOTCERT
    { NULL,               0                           },    // FID_FAV_DELETE
    { s_rgFavorites,      countof(s_rgFavorites)      },    // FID_FAV_MAIN
    { NULL,               0                           },    // FID_FAV_ORDER
    { NULL,               0                           },    // FID_QL_MAIN
    { NULL,               0                           },    // FID_QL_ORDER
    { s_rgConSettings,    countof(s_rgConSettings)    },    // FID_CS_MAIN
    { NULL,               0                           },    // FID_TPL
    { NULL,               0                           },    // FID_CD_WELCOME
    { NULL,               0                           },    // FID_ACTIVESETUPSITES
    { NULL,               0                           },    // FID_LINKS_DELETE
    { NULL,               0                           },    // FID_OUTLOOKEXPRESS
    { NULL,               0                           },    // FID_LCY4X_ACTIVEDESKTOP
    { s_rgChannels,       countof(s_rgChannels)       },    // FID_LCY4X_CHANNELS
    { NULL,               0                           },    // FID_LCY4X_SOFTWAREUPDATES
    { NULL,               0                           },    // FID_LCY4X_WEBCHECK
    { NULL,               0                           },    // FID_LCY4X_CHANNELBAR
    { NULL,               0                           },    // FID_LCY4X_SUBSCRIPTIONS
    { NULL,               0                           }     // FID_REFRESHBROWSER
};

BOOL SetFeatureBranded(UINT nID, DWORD dwFlags /*= FF_ENABLE*/)
{
    PMAPDW2PSZ pMap;
    HKEY       hk;
    DWORD      dwValue;
    UINT       cMapEntries,
               i;

    if (!g_CtxIsGp() || g_CtxIs(CTX_MISC_PREFERENCES))
        return FALSE;

    if (nID < FID_FIRST || nID >= FID_LAST)
        return FALSE;

    pMap        = s_mapFidToRegInfo[nID].pmapFlagToRegValue;
    cMapEntries = s_mapFidToRegInfo[nID].cMapEntries;
    if (NULL == pMap || 0 == cMapEntries)
        return FALSE;

    hk = NULL;
    SHCreateKey(g_GetHKCU(), RK_IEAK_BRANDED, KEY_SET_VALUE, &hk);
    if (NULL == hk)
        return FALSE;

    for (i = 0; i < cMapEntries; i++) {
        if (HasFlag((pMap + i)->dw, dwFlags) || ((pMap + i)->dw == dwFlags)) {
            dwValue = FF_ENABLE;
            RegSetValueEx(hk, (pMap + i)->psz, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(dwValue));
        }
    }

    SHCloseKey(hk);
    return TRUE;
}

DWORD GetFeatureBranded(UINT nID)
{
    PMAPDW2PSZ pMap;
    HKEY       hk;
    DWORD      dwValue, cValue,
               dwResult;
    UINT       cMapEntries,
               i;

    dwResult = FF_DISABLE;

    if (!g_CtxIsGp())
        return dwResult;

    if (nID < FID_FIRST || nID >= FID_LAST)
        return dwResult;

    pMap        = s_mapFidToRegInfo[nID].pmapFlagToRegValue;
    cMapEntries = s_mapFidToRegInfo[nID].cMapEntries;
    if (NULL == pMap || 0 == cMapEntries)
        return dwResult;

    // PERF: <oliverl> we should really look into caching this whole key since we go
    // through this code path so frequently

    hk = NULL;
    SHOpenKey(g_GetHKCU(), RK_IEAK_BRANDED, KEY_QUERY_VALUE, &hk);
    if (NULL == hk)
        return dwResult;

    for (i = 0; i < cMapEntries; i++) {
        if (S_OK != SHValueExists(hk, (pMap + i)->psz))
            continue;

        dwValue = FF_DISABLE;
        cValue  = sizeof(dwValue);
        RegQueryValueEx(hk, (pMap + i)->psz, NULL, NULL, (PBYTE)&dwValue, &cValue);

        if (FF_DISABLE != dwValue) {
            if (FF_DISABLE == dwResult)
                dwResult = 0;

            SetFlag(&dwResult, (pMap + i)->dw);
        }
    }

    SHCloseKey(hk);
    return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// CreateCustomBrandingCabUI, ShowUIDlgProc, ShowUIThreadProc

DWORD WINAPI   ShowUIThreadProc(LPVOID);
BOOL  CALLBACK ShowUIDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM);

HWND  s_hDlg;
HICON s_hIcon;
BOOL  s_fDialogInit = FALSE;

BOOL CreateCustomBrandingCabUI(BOOL fCreate /*= TRUE*/)
{
    static HANDLE s_hThread = NULL;

    MSG    msg;
    DWORD  dwThreadID; 

    if (fCreate) {
        s_hThread = CreateThread(NULL, 4096, ShowUIThreadProc, NULL, 0, &dwThreadID);
        ASSERT(s_hThread != NULL);
    }
    else
        if (s_hThread != NULL) {
            while (s_fDialogInit == FALSE)
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

            PostMessage(s_hDlg, WM_CLOSE, 0, 0L);

            while (MsgWaitForMultipleObjects(1, &s_hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

            CloseHandle(s_hThread);
        }

    return TRUE;
}

DWORD WINAPI ShowUIThreadProc(LPVOID)
{
    TCHAR szIcon[MAX_PATH];

    GetWindowsDirectory(szIcon, countof(szIcon));
    PathAppend(szIcon, TEXT("cursors\\globe.ani"));
    
    s_hIcon = (HICON)LoadImage(NULL, szIcon, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);

    DialogBox(g_GetHinst(), MAKEINTRESOURCE(IDD_DISPLAY), NULL, (DLGPROC)ShowUIDlgProc);
   
    if (s_hIcon != NULL)
        DestroyIcon(s_hIcon);
    s_hIcon = NULL;

    return 0L;
}

BOOL CALLBACK ShowUIDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM)
{
    switch (uMsg) {
        case WM_INITDIALOG:
            s_hDlg = hDlg;
            if (s_hIcon != NULL)
                SendDlgItemMessage(hDlg, IDC_ANIM, STM_SETICON, (WPARAM)s_hIcon, 0);
            s_fDialogInit = TRUE;
            break;

        case WM_CLOSE:
            EndDialog(hDlg, 0);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Miscellaneous

BOOL BackToIE3orLower()
{
    TCHAR szPrevIEVer[32];
    DWORD dwResult,
          dwSize;
    BOOL  fResult;

    fResult  = FALSE;
    dwSize   = sizeof(szPrevIEVer);
    dwResult = SHGetValue(HKEY_LOCAL_MACHINE, RK_IE4SETUP, TEXT("PreviousIESysFile"), NULL, (LPVOID)szPrevIEVer, &dwSize);
    if (dwResult == ERROR_SUCCESS) {
        SCabVersion cvPrevIE, cvIE4;

        // IE3's version is 4.70.xxxx.xx; so check against the major number of IE4
        if (cvPrevIE.Init(szPrevIEVer) && cvIE4.Init(TEXT("4.71.0.0")))
            fResult = (cvPrevIE < cvIE4);
    }

    return fResult;
}


void Out(PCTSTR pszMsg)
{
    USES_CONVERSION;

    DWORD dwWritten;

    if (pszMsg == NULL)
        return;

    if (g_hfileLog == NULL)
        return;

    WriteFile(g_hfileLog, T2CA(pszMsg), StrLen(pszMsg), &dwWritten, NULL);

    if (g_fFlushEveryWrite)
        FlushFileBuffers(g_hfileLog);
}

void OutD(PCTSTR pszMsg)
{
    UNREFERENCED_PARAMETER(pszMsg);
    DEBUG_CODE(Out(pszMsg));
}

void WINAPIV OutEx(PCTSTR pszFmt ...)
{
    USES_CONVERSION;

    TCHAR szMessage[3 * MAX_PATH];
    DWORD dwWritten;
    UINT  nLen;

    if (pszFmt == NULL)
        return;

    if (g_hfileLog == NULL)
        return;

    va_list  arglist;
    va_start(arglist, pszFmt);
    nLen = wvnsprintf(szMessage, countof(szMessage), pszFmt, arglist);
    va_end(arglist);

    WriteFile(g_hfileLog, T2CA(szMessage), nLen, &dwWritten, NULL);

    if (g_fFlushEveryWrite)
        FlushFileBuffers(g_hfileLog);
}


// REVIEW: (andrewgu) the following API isused by CloseRASConnections only
void TimerSleep(UINT nMilliSecs)
{
    MSG      msg;
    UINT_PTR idTimer;
    DWORD    dwInitTick;

    idTimer = SetTimer(NULL, 0, nMilliSecs, NULL);
    if (idTimer == 0)
        return;

    dwInitTick = GetTickCount();
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        if (msg.message == WM_TIMER && GetTickCount() >= dwInitTick + nMilliSecs)
            break;
    }

    KillTimer(NULL, idTimer);
}

UINT GetFlagsNumber(DWORD dwFlags)
{
    UINT nMaxFlags,
         i, cchFlags;

    if (dwFlags == 0)
        return 0;

    nMaxFlags = sizeof(DWORD) * 8;
    if (dwFlags == (DWORD)-1)
        return nMaxFlags;

    for (cchFlags = 0, i = 0; i < nMaxFlags; i++)
        if (HasFlag(dwFlags, 1 << i))
            cchFlags++;

    return cchFlags;
}

BOOL SetUserFileOwner(HANDLE hUserToken, LPCTSTR pcszPath)
{
    SECURITY_DESCRIPTOR SecDesc;
    PTOKEN_USER pTokenUser = NULL;
    PSID pSidUser = NULL;
    DWORD dwSize;
    BOOL fToken = FALSE;
    BOOL bRet = FALSE;
    
    getSetOwnerPrivileges(TRUE);

    dwSize = 0;
    pTokenUser = (PTOKEN_USER)CoTaskMemAlloc(sizeof(TOKEN_USER));

    if (pTokenUser == NULL)
        return FALSE;

    fToken = GetTokenInformation(hUserToken, TokenUser, pTokenUser, sizeof(TOKEN_USER), &dwSize);
    
    if (!fToken && (dwSize > sizeof(TOKEN_USER)))
    {
        CoTaskMemFree(pTokenUser);
        pTokenUser = (PTOKEN_USER)CoTaskMemAlloc(dwSize);
        if (pTokenUser != NULL)
            fToken = GetTokenInformation(hUserToken, TokenUser, pTokenUser, dwSize, &dwSize); 
    }
    
    if ((pTokenUser != NULL) && fToken)
    {
        dwSize = GetLengthSid(pTokenUser->User.Sid);
        pSidUser = (PSID)CoTaskMemAlloc(dwSize);
        
        if ((pSidUser != NULL) && (CopySid(dwSize, pSidUser, pTokenUser->User.Sid)))
        {
            if (InitializeSecurityDescriptor(&SecDesc, SECURITY_DESCRIPTOR_REVISION) &&
                SetSecurityDescriptorOwner(&SecDesc, pSidUser, FALSE))
            {
                bRet = SetFileSecurity(pcszPath, OWNER_SECURITY_INFORMATION, &SecDesc);
            }
        }
    }
    
    if (pTokenUser != NULL)
        CoTaskMemFree(pTokenUser);
    
    if (pSidUser != NULL)
        CoTaskMemFree(pSidUser);

    getSetOwnerPrivileges(FALSE);

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

void ShortPathName(LPTSTR pszFilename)
{
    UNREFERENCED_PARAMETER(pszFilename);
}

// this code ripped off from folder redirection in windows\gina\fdeploy\utils.cxx

TCHAR* NTPrivs[] = {
    SE_TAKE_OWNERSHIP_NAME,     //we only need take ownership privileges
    SE_RESTORE_NAME,            //we only need to be able to assign owners
    TEXT("\0")
};

void getSetOwnerPrivileges(BOOL fSet)
{
    static  DWORD s_dwTakeOwnerVal = 0xFFFFFFFF;
    static  DWORD s_dwRestoreNameVal = 0xFFFFFFFF;
    BOOL    bStatus;
    DWORD   dwSize = 0;
    DWORD   i, j;
    DWORD   dwPrivCount;
    PTOKEN_PRIVILEGES pPrivs = NULL;
    PTOKEN_PRIVILEGES pTokenPriv = NULL;
    HANDLE  hToken;
    
    //try to get all the windows NT privileges.
    for (i=0, dwPrivCount=0; *NTPrivs[i]; i++)
        dwPrivCount++;
    
    dwSize = sizeof (LUID_AND_ATTRIBUTES) * (dwPrivCount - 1) +
        sizeof(TOKEN_PRIVILEGES);
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        pPrivs = (PTOKEN_PRIVILEGES) CoTaskMemAlloc(dwSize);
        
        if (pPrivs != NULL)
        {    
            BOOL fToken = FALSE;
    
            if (fSet)
            {
                pTokenPriv = (PTOKEN_PRIVILEGES)CoTaskMemAlloc(sizeof(TOKEN_PRIVILEGES));

                fToken = GetTokenInformation(hToken, TokenPrivileges, pTokenPriv, sizeof(TOKEN_PRIVILEGES), &dwSize);
    
                if (!fToken && (dwSize > sizeof(TOKEN_PRIVILEGES)))
                {
                    CoTaskMemFree(pTokenPriv);
                    pTokenPriv = (PTOKEN_PRIVILEGES)CoTaskMemAlloc(dwSize);
                    if (pTokenPriv != NULL)
                        fToken = GetTokenInformation(hToken, TokenPrivileges, pTokenPriv, dwSize, &dwSize); 
                }
            }

            for (i=0, dwPrivCount = 0; *NTPrivs[i]; i++)
            {
                bStatus = LookupPrivilegeValue(NULL, NTPrivs[i], &(pPrivs->Privileges[dwPrivCount].Luid));
                if (!bStatus)
                    continue;

                if (fSet)
                {
                    if (fToken && (pTokenPriv != NULL))
                    {
                        for (j = 0; j < pTokenPriv->PrivilegeCount; j++)
                        {
                            TCHAR szName[MAX_PATH];

                            dwSize = countof(szName);
                            if (LookupPrivilegeName(TEXT(""), &(pTokenPriv->Privileges[j].Luid), szName, &dwSize) &&
                                (StrCmpI(szName, NTPrivs[i]) == 0))
                            {
                                if (i == 0)
                                    s_dwTakeOwnerVal = pTokenPriv->Privileges[j].Attributes;
                                else
                                    s_dwRestoreNameVal = pTokenPriv->Privileges[j].Attributes;
                            }
                        }
                    }
                    pPrivs->Privileges[dwPrivCount++].Attributes = SE_PRIVILEGE_ENABLED;
                }
                else
                {
                    if (i == 0) 
                        pPrivs->Privileges[dwPrivCount].Attributes = s_dwTakeOwnerVal;
                    else
                        pPrivs->Privileges[dwPrivCount].Attributes = s_dwRestoreNameVal;

                    if (pPrivs->Privileges[dwPrivCount].Attributes != 0xFFFFFFFF)
                        dwPrivCount++;
                }
            }
            
            pPrivs->PrivilegeCount = dwPrivCount;
            
            AdjustTokenPrivileges(hToken, FALSE, pPrivs, NULL, NULL, NULL);
                                    
            CoTaskMemFree(pPrivs);

            if (pTokenPriv != NULL)
                CoTaskMemFree(pTokenPriv);
        }
        CloseHandle(hToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\detect\detect.c ===
#include <windows.h>
#include <shellapi.h>
#include <string.h>
#include "resource.h"

//---------------------------------------------------------------------------
// appwide globals

char g_szCurrentDir[MAX_PATH];
char g_szCodePage[32];

//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;        // stripped something
    }
}

//---------------------------------------------------------------------------
void ExecuteAutorun()
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];
    char szAutorunApp[MAX_PATH];
    char szDir[MAX_PATH];
    char szLang[8];
    BOOL fExecuted = FALSE;

    lstrcpy( szTmpPath, g_szCurrentDir );
    lstrcat( szTmpPath, "\\locale.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "locale.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    if (GetPrivateProfileString("Locale", g_szCodePage, "", szLang, sizeof(szLang), szIniPath))
    {
        lstrcpy( szDir, g_szCurrentDir );
        lstrcat( szDir, szLang );
        lstrcat( szDir, TEXT("bin\\") );
        lstrcpy( szAutorunApp, szDir );
        lstrcat( szAutorunApp, "IECD.exe" );

        if (GetFileAttributes(szAutorunApp) != 0xFFFFFFFF)
        {
            ShellExecute( NULL, NULL, szAutorunApp, " ", szDir, SW_SHOWNORMAL );
            fExecuted = TRUE;
        }
    }
    
    if( !fExecuted )
    {
        GetPrivateProfileString( "Locale", "Default", "\\EN\\", szLang, sizeof(szLang), szIniPath );
        lstrcpy( szDir, g_szCurrentDir );
        lstrcat( szDir, szLang );
        lstrcat( szDir, TEXT("bin\\") );
        lstrcpy( szAutorunApp, szDir );
        lstrcat( szAutorunApp, "IECD.exe" );
        ShellExecute( NULL, NULL, szAutorunApp, " ", szDir, SW_SHOWNORMAL );
    }
}

//---------------------------------------------------------------------------
void GetCodePage( )
{
    DWORD dwLCID;

    dwLCID = GetSystemDefaultLCID();

    if (dwLCID > 0x00000FFF)
        wsprintf(g_szCodePage, "0000%x", dwLCID);
    else
        wsprintf(g_szCodePage, "00000%x", dwLCID);
}

//---------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    GetModuleFileName(NULL, g_szCurrentDir, sizeof(g_szCurrentDir));
    _PathRemoveFileSpec(g_szCurrentDir);

    if (lstrlen(g_szCurrentDir) == 3)
        g_szCurrentDir[2] = '\0';

    GetCodePage();
    ExecuteAutorun();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\autorun\autorun.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#define _INC_OLE
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <regstr.h>
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define IE4_VERSION     44444

//---------------------------------------------------------------------------
// appwide globals
extern HINSTANCE g_hinst;
#define HINST_THISAPP g_hinst

extern BOOL g_fCrapForColor;
extern BOOL g_fPaletteDevice;

//---------------------------------------------------------------------------
// helpers.c

// just how many places is this floating around these days?
HPALETTE PaletteFromDS(HDC);

// handles SBS crap
void GetRealWindowsDirectory(char *buffer, int maxlen);

// non-exporeted code stolen from shelldll (prefixed by underscores)
BOOL _PathStripToRoot(LPSTR);


DWORD GetDataTextColor( int, LPSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\autorun\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// the following resources are defined once for the whole app
//
///////////////////////////////////////////////////////////////////////////////

// waveforms
#define IDW_STARTAPP        1
#define IDW_INSTALL         4
#define IDW_DEMO            5

// bitmaps
#define IDB_4BPP_BACKDROP        200
#define IDB_8BPP_BACKDROP        201
#define IDB_8BPP_BUTTONS         202

// strings
#define IDS_APPTITLE            1
#define IDS_NEEDCDROM           2
#define IDS_LABELFONT           8
#define IDS_LABELHEIGHT         9
#define IDS_STARTPAGE           10
#define IDS_SEARCHPAGE          11
#define IDS_IERUNNINGMSG        13
#define IDS_MAINTEXT            21

// string group helpers
#define IDS_TITLE(item)     ((item) + 1)
#define IDS_INFO(item)      ((item) + 2)
#define IDS_CMD(item)       ((item) + 3)
#define IDS_DIR(item)       ((item) + 4)

#define IDI_ICON(item)      (MAKEINTRESOURCE(item))

//
// string groups
// resource compiler doesn't expand macros
// so all these are declared as separate ids
//
#define IEFROMCD                100
#define IDS_TITLE_IEFROMCD      101
#define IDS_CMD_IEFROMCD        103
#define IDS_DIR_IEFROMCD        104
#define IESETUP                 110
#define IDS_TITLE_IESETUP       111
#define IDS_CMD_IESETUP         113
#define IDS_DIR_IESETUP         114
#define IDS_CMD_MSN             141
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\autorun\helpers.c ===
//---------------------------------------------------------------------------
#include "autorun.h"
#include "resource.h"

//#include "port32.h"
#define dbMSG(msg,title)    (MessageBox(NULL,msg,title,MB_OK | MB_ICONINFORMATION))

#define NORMAL 1
#define HIGHLIGHT 2

LONG WINAPI AnotherStrToLong( LPCSTR );
extern char * Res2Str(int rsString);

extern DWORD AUTORUN_8BIT_TEXTCOLOR;
extern DWORD AUTORUN_8BIT_HIGHLIGHT;

//---------------------------------------------------------------------------
LONG WINAPI StrToLong(LPCSTR sz)
{
    long l=0;
    BOOL fNeg = (*sz == '-');

    if (fNeg)
        sz++;

    while (*sz >= '0' && *sz <= '9')
        l = l*10 + (*sz++ - '0');

    if (fNeg)
        l *= -1L;

    return l;
}

//---------------------------------------------------------------------------
HPALETTE PaletteFromDS(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

    adw[0] = MAKELONG(0x300, n);

    return CreatePalette((LPLOGPALETTE)&adw[0]);
}
//---------------------------------------------------------------------------
void DrawBitmap ( HDC hdc, HBITMAP hBitmap, short xStart, short yStart )
{
    BITMAP  bm;
    HDC     hdcMem;
    DWORD   dwSize;
    POINT   ptSize, ptOrg;

    hdcMem = CreateCompatibleDC( hdc );
    SelectObject( hdcMem, hBitmap );
    SetMapMode( hdcMem, GetMapMode( hdc ));
    GetObject( hBitmap, sizeof(BITMAP), (LPSTR) &bm);
    ptSize.x = bm.bmWidth;
    ptSize.y = bm.bmHeight;
    DPtoLP( hdc, &ptSize, 1 );

    ptOrg.x = 0;
    ptOrg.y = 0;
    DPtoLP( hdcMem, &ptOrg, 1);

    BitBlt( hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem,
        ptOrg.x, ptOrg.y, SRCCOPY );

    DeleteDC( hdcMem );
}
//---------------------------------------------------------------------------
#pragma data_seg(".text")
static const char szRegStr_Setup[] = REGSTR_PATH_SETUP "\\Setup";
static const char szSharedDir[] = "SharedDir";
#pragma data_seg()

void GetRealWindowsDirectory(char *buffer, int maxlen)
{
    static char szRealWinDir[MAX_PATH] = "";

    if (!*szRealWinDir)
    {
        HKEY key = NULL;

        if(RegOpenKey(HKEY_LOCAL_MACHINE, szRegStr_Setup, &key) ==
            ERROR_SUCCESS)
        {
            LONG len = sizeof(szRealWinDir) / sizeof(szRealWinDir[0]);

            if( RegQueryValueEx(key, szSharedDir, NULL, NULL,
                (LPBYTE)szRealWinDir, &len) != ERROR_SUCCESS)
            {
                *szRealWinDir = '\0';
            }

            RegCloseKey(key);
        }

        if (!*szRealWinDir)
            GetWindowsDirectory(szRealWinDir, MAX_PATH);
    }

    if (maxlen > MAX_PATH)
        maxlen = MAX_PATH;

    lstrcpyn(buffer, szRealWinDir, maxlen);
}

//---------------------------------------------------------------------------
#define DBL_BSLASH(sz) (*(WORD *)(sz) == 0x5C5C)    // '\\'
#pragma data_seg(".text")
static const char c_szColonSlash[] = ":\\";
#pragma data_seg()

//---------------------------------------------------------------------------
BOOL _ChrCmp(WORD w1, WORD wMatch)
{
  /* Most of the time this won't match, so test it first for speed.
   */
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
        {
          return(w1 != wMatch);
        }
      return FALSE;
    }
  return TRUE;
}

//---------------------------------------------------------------------------
LPSTR _StrChr(LPCSTR lpStart, WORD wMatch)
{
  for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
      if (!_ChrCmp(*(WORD FAR *)lpStart, wMatch))
          return((LPSTR)lpStart);
    }
  return (NULL);
}

//---------------------------------------------------------------------------
LPSTR _StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlen(lpStart);

  for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
      if (!_ChrCmp(*(WORD FAR *)lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}

//---------------------------------------------------------------------------
BOOL _PathIsRelative(LPCSTR lpszPath)
{
    // The NULL path is assumed relative
    if (*lpszPath == 0)
        return TRUE;

    // Does it begin with a slash ?
    if (lpszPath[0] == '\\')
        return FALSE;
    // Does it begin with a drive and a colon ?
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == ':')
        return FALSE;
    // Probably relative.
    else
        return TRUE;
}

//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = AnsiNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

//---------------------------------------------------------------------------
BOOL _PathIsRoot(LPCSTR pPath)
{
    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, c_szColonSlash))                  // "X:\" case
            return TRUE;
    }

    if ((*pPath == '\\') && (*(pPath + 1) == 0))        // "\" case
        return TRUE;

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = AnsiNext(p)) {
            if (*p == '\\' && (++cBackslashes > 1))
               return FALSE;   /* not a bare UNC name, therefore not a root dir */
        }
        return TRUE;    /* end of string with only 1 more backslash */
                        /* must be a bare UNC, which looks like a root dir */
    }
    return FALSE;
}

//---------------------------------------------------------------------------
BOOL _PathStripToRoot(LPSTR szRoot)
{
    while(!_PathIsRoot(szRoot))
    {
        if (!_PathRemoveFileSpec(szRoot))
        {
            // If we didn't strip anything off,
            // must be current drive
            return(FALSE);
        }
    }

    return(TRUE);
}

//--------------------------------------------------------------------------
BOOL _PathIsUNC(LPCSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}

//--------------------------------------------------------------------------
LPCSTR _GetPCEnd(LPCSTR lpszStart)
{
        LPCSTR lpszEnd;

        lpszEnd = _StrChr(lpszStart, '\\');
        if (!lpszEnd)
        {
                lpszEnd = lpszStart + lstrlen(lpszStart);
        }

        return lpszEnd;
}
//--------------------------------------------------------------------------
LPCSTR _PCStart(LPCSTR lpszStart, LPCSTR lpszEnd)
{
        LPCSTR lpszBegin = _StrRChr(lpszStart, lpszEnd, '\\');
        if (!lpszBegin)
        {
                lpszBegin = lpszStart;
        }
        return lpszBegin;
}

//--------------------------------------------------------------------------
// Fix up a few special cases so that things roughly make sense.
void _NearRootFixups(LPSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == '\0')
        {
        // Fix up.
        lpszPath[0] = '\\';
        lpszPath[1] = '\0';
        }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == ':' && lpszPath[2] == '\0')
        {
        // Fix up.
        lpszPath[2] = '\\';
        lpszPath[3] = '\0';
        }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == '\\' && lpszPath[1] == '\0')
        {
        // Fix up.
        lpszPath[0] = '\\';
        lpszPath[1] = '\\';
        lpszPath[2] = '\0';
        }
}

//---------------------------------------------------------------------------
BOOL _PathCanonicalize(LPSTR lpszDst, LPCSTR lpszSrc)
{
    LPCSTR lpchSrc;
    LPCSTR lpchPCEnd;           // Pointer to end of path component.
    LPSTR lpchDst;
    BOOL fUNC;
    int cbPC;

    fUNC = _PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
        {
        // REVIEW: this should just return the count
        lpchPCEnd = _GetPCEnd(lpchSrc);
        cbPC = (int)(lpchPCEnd - lpchSrc) + 1;

        // Check for slashes.
        if (cbPC == 1 && *lpchSrc == '\\')
            {
            // Just copy them.
            *lpchDst = '\\';
            lpchDst++;
            lpchSrc++;
            }
        // Check for dots.
        else if (cbPC == 2 && *lpchSrc == '.')
            {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == '\0')
                {
                lpchDst--;
                lpchSrc++;
                }
            else
                lpchSrc += 2;
            }
        // Check for dot dot.
        else if (cbPC == 3 && *lpchSrc == '.' && *(lpchSrc + 1) == '.')
            {
            // make sure we aren't already at the root
            if (!_PathIsRoot(lpszDst))
                {
                // Go up... Remove the previous path component.
                lpchDst = (LPSTR)_PCStart(lpszDst, lpchDst - 1);
                }
            else
                {
                // When we can't back up, remove the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == '\\')
                    {
                    lpchSrc++;
                    }
                }
            lpchSrc += 2;       // skip ".."
            }
        // Everything else
        else
            {
            // Just copy it.
            lstrcpyn(lpchDst, lpchSrc, cbPC);
            lpchDst += cbPC - 1;
            lpchSrc += cbPC - 1;
            }
        // Keep everything nice and tidy.
        *lpchDst = '\0';
        }

    // Check for weirdo root directory stuff.
    _NearRootFixups(lpszDst, fUNC);

    return TRUE;
}

//---------------------------------------------------------------------------
LPSTR _PathAddBackslash(LPSTR lpszPath)
{
    LPSTR lpszEnd;

    int ichPath = lstrlen(lpszPath);
    if (ichPath >= (MAX_PATH - 1))
        return(NULL);

    lpszEnd = lpszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*lpszPath)
        return lpszEnd;

    /* Get the end of the source directory
    */
    switch(*AnsiPrev(lpszPath, lpszEnd)) {
    case '\\':
        break;

    default:
        *lpszEnd++ = '\\';
        *lpszEnd = '\0';
    }
    return lpszEnd;
}

//---------------------------------------------------------------------------
LPSTR _PathCombine(LPSTR lpszDest, LPCSTR lpszDir, LPCSTR lpszFile)
{
    char szTemp[MAX_PATH];
    LPSTR pszT;

    if (!lpszFile || *lpszFile=='\0') {

        lstrcpyn(szTemp, lpszDir, sizeof(szTemp));       // lpszFile is empty

    } else if (lpszDir && *lpszDir && _PathIsRelative(lpszFile)) {

        lstrcpyn(szTemp, lpszDir, sizeof(szTemp));
        pszT = _PathAddBackslash(szTemp);
        if (pszT) {
            int iLen = lstrlen(szTemp);
            if ((iLen + lstrlen(lpszFile)) < sizeof(szTemp)) {
                lstrcpy(pszT, lpszFile);
            } else
                return NULL;
        } else
            return NULL;

    } else if (lpszDir && *lpszDir &&
        *lpszFile == '\\' && !_PathIsUNC(lpszFile)) {

        lstrcpyn(szTemp, lpszDir, sizeof(szTemp));
        // BUGBUG: Note that we do not check that an actual root is returned;
        // it is assumed that we are given valid parameters
        _PathStripToRoot(szTemp);

        pszT = _PathAddBackslash(szTemp);
        if (pszT)
        {
            // Skip the backslash when copying
            lstrcpyn(pszT, lpszFile+1, (int)(sizeof(szTemp) - 1 - (size_t)(pszT-szTemp)));
        } else
            return NULL;

    } else {

        lstrcpyn(szTemp, lpszFile, sizeof(szTemp));     // already fully qualified file part

    }

    _PathCanonicalize(lpszDest, szTemp);    // this deals with .. and . stuff

    return lpszDest;
}

//---------------------------------------------------------------------------
BOOL PathAppend(LPSTR pPath, LPCSTR pMore)
{

    /* Skip any initial terminators on input. */
    while (*pMore == '\\')
        pMore = AnsiNext(pMore);

    return (_PathCombine(pPath, pPath, pMore) != NULL) ? TRUE : FALSE;
}
//---------------------------------------------------------------------------
void CreateURLPath( LPSTR lpPath )  //create a directory from a URL name
{
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, lpPath );
    _PathRemoveFileSpec( szTmpPath );

    CreateDirectory( szTmpPath, NULL );

}
//---------------------------------------------------------------------------
void CreateURL( LPSTR szCurrentDir )
{
    char szBuffer[80 * 80] = {0};
    char szDestPath[MAX_PATH];
    char szFavPath[MAX_PATH] = {0};
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];
    char szFileBuffer[1024] = {0};
    char *lpString;
    LONG lError = 0;
    DWORD dwType = 0;
    DWORD dwLength = MAX_PATH;
    BOOL fFile = FALSE;
    HANDLE hFile;
    HKEY hkFav;
    DWORD dwWriteLen = 0;
    int i = 0;

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "fav.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileSection( "Favorites", szBuffer, sizeof( szBuffer ), szIniPath);

    // pull favorites path out of the registry
    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", 0, KEY_ALL_ACCESS, &hkFav );
    lError = RegQueryValueEx( hkFav, "Favorites", NULL, &dwType, szFavPath, &dwLength );
    //if no favorites directory exists, create one.
    if( lError != ERROR_SUCCESS )
    {
        GetPrivateProfileString( "Directory", "Dir", "Favorites", szTmpPath, sizeof( szTmpPath ), szIniPath );
        GetWindowsDirectory( szFavPath, MAX_PATH );
        lstrcat( szFavPath, "\\" );
        lstrcat( szFavPath, szTmpPath );
        if(!CreateDirectory( szFavPath, NULL ))
        {
            DeleteFile( szIniPath );
            RegCloseKey( hkFav );
            goto fail_gracefully;
        }
        RegSetValueEx( hkFav, "Favorites", 0, REG_SZ, szFavPath, strlen( szFavPath ) + 1);
    }

    DeleteFile( szIniPath );

    for( i = 0; i < sizeof(szBuffer); i++ )
    {
        if( szBuffer[i] == '=' )
            szBuffer[i] = (char)NULL;
    }

    lstrcat( szFavPath, "\\" );
    lstrcpy( szDestPath, szFavPath );
    RegCloseKey( hkFav );

    lstrcpyn( szDestPath + lstrlen(szDestPath), szBuffer, sizeof(szDestPath) - lstrlen(szDestPath) );
    CreateURLPath( szDestPath );
    hFile = CreateFile( szDestPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        goto fail_gracefully;
    lstrcpy( szDestPath, szFavPath );

    for( i = 0; i < sizeof(szBuffer); i++ )
    {
        if( szBuffer[i] == (char)NULL )
        {
            if( szBuffer[i + 1] == (char)NULL ) break;
            lpString = &szBuffer[i] + 1;
            if( fFile )
            {
                lstrcpyn( szDestPath + lstrlen(szDestPath), lpString, sizeof(szDestPath) - lstrlen(szDestPath) );
                CreateURLPath( szDestPath );
                hFile = CreateFile( szDestPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                    FILE_ATTRIBUTE_NORMAL, NULL );
                lstrcpy( szDestPath, szFavPath );
            }
            else
            {
                lstrcpy( szFileBuffer, "[InternetShortcut]\nURL=");
                lstrcpyn( szFileBuffer + lstrlen(szFileBuffer), lpString, sizeof(szFileBuffer) - lstrlen(szFileBuffer) );
                WriteFile( hFile, szFileBuffer, strlen( szFileBuffer ),
                    &dwWriteLen, NULL );
                CloseHandle( hFile );
            }
            fFile = !fFile;
        }
    }

fail_gracefully:
    ;
}
//---------------------------------------------------------------------------
void VirusWarning( BOOL fWarning )
{
    HKEY hkVW;
    DWORD dwFlags;

    if( fWarning )
    {
        dwFlags = 0x000007d8;
    }
    else
    {
        dwFlags = 0x000107d0;
    }

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\classes\\exefile", 0, KEY_ALL_ACCESS, &hkVW ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hkVW, "EditFlags", 0, REG_BINARY,(char *) &dwFlags, 4);
        RegCloseKey( hkVW );
    }
}
//---------------------------------------------------------------------------
BOOL IEExists( )
{
    HKEY hkAppPaths;
    LONG lError;
    DWORD dwType;
    DWORD dwLength = MAX_PATH;
    DWORD dwError;
    char szPath[MAX_PATH];

    lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE", 0, KEY_ALL_ACCESS, &hkAppPaths );
    if( lError != ERROR_SUCCESS ) return FALSE;
    RegQueryValueEx( hkAppPaths, "", NULL, &dwType, szPath, &dwLength );
    RegCloseKey( hkAppPaths );

    dwError = GetFileAttributes( szPath );
    if( dwError == 0xFFFFFFFF )
    {
        return FALSE;
    }

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL IEFutureBuild( )
{
    HKEY hkAppPaths;
    LONG lBuild;
    DWORD dwType;
    DWORD dwLength = 10;
    DWORD dwError;
    char szBuild[10];

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, KEY_ALL_ACCESS, &hkAppPaths ) == ERROR_SUCCESS)
    {
        RegQueryValueEx( hkAppPaths, "Build", NULL, &dwType, szBuild, &dwLength );
        RegCloseKey( hkAppPaths );
    
        lBuild = StrToLong( szBuild );

        if( lBuild > IE4_VERSION ) return TRUE;
    }

    return FALSE;
}
//---------------------------------------------------------------------------
BOOL GetDataAppTitle( LPSTR szAppTitle, LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileString( "Custom", "Title", "Microsoft Internet Explorer CD", szTmpPath, sizeof( szTmpPath ), szIniPath );

    lstrcpy( szAppTitle, szTmpPath );

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL GetDataPages( LPSTR szStartPage, LPSTR szSearchPage, LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileString( "Custom", "Start", (char *)Res2Str( IDS_STARTPAGE ), szTmpPath, sizeof( szTmpPath ), szIniPath );
    lstrcpy( szStartPage, szTmpPath );
    GetPrivateProfileString( "Custom", "Search", (char *)Res2Str( IDS_SEARCHPAGE ), szTmpPath, sizeof( szTmpPath ), szIniPath );
    lstrcpy( szSearchPage, szTmpPath );

    return TRUE;
}
//---------------------------------------------------------------------------
DWORD GetDataTextColor( int nColor, LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];
    char szColor[32];
    DWORD dwColor;

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    if ( nColor == HIGHLIGHT )
    {
        char szDefault[MAX_PATH];

        wsprintf(szDefault, "%d", AUTORUN_8BIT_HIGHLIGHT);
        GetPrivateProfileString( "Custom", "HighlightColor", szDefault, szColor,
            32, szIniPath );
    }
    if ( nColor == NORMAL )
    {
        char szDefault[MAX_PATH];

        wsprintf(szDefault, "%d", AUTORUN_8BIT_TEXTCOLOR);
        GetPrivateProfileString( "Custom", "NormalColor", szDefault, szColor,
            32, szIniPath );
    }

    dwColor = AnotherStrToLong( szColor );
    if ( dwColor == -1 )
    {
        if ( nColor == NORMAL ) return (DWORD) AUTORUN_8BIT_TEXTCOLOR;
        if ( nColor == HIGHLIGHT ) return (DWORD) AUTORUN_8BIT_HIGHLIGHT;
    }

    return dwColor;
}
//---------------------------------------------------------------------------
BOOL GetDataButtons( LPSTR szCurrentDir )
{
    char szIniPath[MAX_PATH];
    char szTmpPath[MAX_PATH];

    lstrcpy( szTmpPath, szCurrentDir );
    lstrcat( szTmpPath, "\\iecd.ini" );
    GetTempPath( MAX_PATH, szIniPath );
    lstrcat( szIniPath, "iecd.ini" );
    CopyFile( szTmpPath, szIniPath, FALSE );
    SetFileAttributes( szIniPath, FILE_ATTRIBUTE_NORMAL );

    GetPrivateProfileString( "Custom", "CoolButtons", "1", szTmpPath, sizeof( szTmpPath ), szIniPath );
    if( szTmpPath[0] == '1' )
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\closeie\closeie.c ===
#include <windows.h>

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND hwndIE;

    if ((hwndIE = FindWindow("IEFrame", NULL)) != NULL  ||
        (hwndIE = FindWindow("Internet Explorer_Frame", NULL)) != NULL  ||
        (hwndIE = FindWindow("CabinetWClass", NULL)) != NULL)
        PostMessage(hwndIE, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);

    if ((hwndIE = FindWindow("IECD", NULL)) != NULL)
        PostMessage(hwndIE, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\detect\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// the following resources are defined once for the whole app
//
///////////////////////////////////////////////////////////////////////////////

// icons
#define IDI_CDSTARTAPP      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\iecd\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// the following resources are defined once for the whole app
//
///////////////////////////////////////////////////////////////////////////////

// icons
#define IDI_CDSTARTAPP      1

// strings
#define IDS_APPTITLE            1
#define IDS_NEEDCDROM           2
#define IDS_STARTPAGE           10
#define IDS_SEARCHPAGE          11
#define IDS_VIDEO               21
#define IDS_IE_VERSION          145
#define IDS_LATESTVER		146
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\iecd\iecd.c ===
#include <windows.h>
#include <shellapi.h>
#include <advpub.h>
#include <ntverp.h>
#include "resource.h"


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define REGLEN(str)     (lstrlen(str) + 1)

#define NUM_VERSION_NUM 4

//---------------------------------------------------------------------------
// appwide globals
HINSTANCE g_hinst = NULL;
HANDLE g_hIExplore = NULL;
char    g_szTemp[2048] = {0};
char    g_szTemp2[2048] = {0};
char    g_szCurrentDir[MAX_PATH];
BOOL    g_fWindowsNT;

void ConvertVersionStr(LPSTR pszVer, WORD rwVer[]);
int VersionCmp(WORD rwVer1[], WORD rwVer2[]);

long AtoL(const char *nptr);

//---------------------------------------------------------------------------
// Convert a string resource into a character pointer
// NOTE: Flag is in case we call this twice before we use the data
char * Res2Str(int rsString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
	    LoadString(g_hinst, rsString, g_szTemp, ARRAYSIZE(g_szTemp));
	    fSet = FALSE;
	    return(g_szTemp);
    }

    LoadString(g_hinst, rsString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

//---------------------------------------------------------------------------
//      G E T  I E  V E R S I O N
//
//  ISK3
//  This will pull build information out of the system registry and return
//  true if it is less than IE5.
//---------------------------------------------------------------------------
int GetIEVersion( )
{
    HKEY hkIE;
    DWORD dwType;
    DWORD dwSize = 32;
    DWORD result;
    char szData[32],* lpszData;
	BOOL bNotIE5=1;

    if(RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer", 0, KEY_READ|KEY_WRITE, &hkIE ) == ERROR_SUCCESS)
    {
	    result = RegQueryValueEx( hkIE, "Version", NULL, &dwType, szData, &dwSize );
	    if( result == ERROR_SUCCESS )
	    {
	        WORD rwRegVer[NUM_VERSION_NUM];
	        WORD rwRegVer2[NUM_VERSION_NUM];
	        ConvertVersionStr(szData, rwRegVer);

	        if (LoadString(g_hinst, IDS_IE_VERSION, szData, sizeof(szData)) == 0)
    		    lstrcpy(szData, VER_PRODUCTVERSION_STR);

	        ConvertVersionStr(szData, rwRegVer2);
	        // Check the version of IE is 5.0 or greater is installed
	        if (VersionCmp(rwRegVer, rwRegVer2) >= 0)
	            bNotIE5=0;
	    }
	    RegCloseKey( hkIE );
    }

	return bNotIE5;
}
//---------------------------------------------------------------------------
//      C H E C K  B R A N D
//
//  ISK3
//---------------------------------------------------------------------------
BOOL CheckBrand( )
{
    HKEY hkRegKey;
    char szCompany[MAX_PATH];
    char szInsPath[MAX_PATH];
    char szName[MAX_PATH];
    DWORD dwType;
    DWORD dwLength = MAX_PATH;

    wsprintf( szInsPath, "%s\\install.ins", g_szCurrentDir );
    GetPrivateProfileString( "Branding", "CompanyName", "", szName, MAX_PATH, szInsPath );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer\\Main", 0, KEY_READ|KEY_WRITE, &hkRegKey ) != ERROR_SUCCESS )
	    if( lstrlen( szName ) != 0 )
	        return FALSE;

    RegQueryValueEx( hkRegKey, "CompanyName", NULL, &dwType, szCompany, &dwLength );
    RegCloseKey( hkRegKey );

    if( lstrlen( szName ) == 0 )
	    return TRUE;

    if( lstrlen(szCompany) == 0 )
	    return FALSE;

    if( lstrcmpi( szName, szCompany ) == 0 )
	    return TRUE;

    return FALSE;
}

//---------------------------------------------------------------------------
//      G E T  I E  P A T H
//
//  ISK3
//  This will retrieve the AppPath for IEXPLORE.EXE from the system registry
//  and return it as a string.
//
//  Parameters:
//      pszString - pointer to buffer to store path
//      nSize     - size of buffer
//---------------------------------------------------------------------------
char *GetIEPath( LPSTR pszString, int nSize )
{
    HKEY hkAppPath;
    DWORD dwType = REG_SZ;
    DWORD dwSize;

    dwSize = nSize;
    RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE",
	0, KEY_READ|KEY_WRITE, &hkAppPath );
    RegQueryValueEx( hkAppPath, "", NULL, &dwType, pszString, &dwSize );
    RegCloseKey( hkAppPath );

    return pszString;
}

//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;	// stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;	// stripped something
    }
}

//---------------------------------------------------------------------------
BOOL AutoRunCDIsInDrive( )
{
    char me[MAX_PATH];
    GetModuleFileName(g_hinst, me, ARRAYSIZE(me));

    while (!(GetFileAttributes(me)!=-1))
        if (MessageBox(NULL,Res2Str(IDS_NEEDCDROM),Res2Str(IDS_APPTITLE),MB_OKCANCEL | MB_ICONSTOP) == IDCANCEL)
	        return FALSE;
    return TRUE;
}

//---------------------------------------------------------------------------
//      E X E C  A P P
//
//  ISK3
//  Similar to AutoRunExec except that we don't put process information into
//  the g_ahWait array.  For use with WaitForSingleObject.
//---------------------------------------------------------------------------
HANDLE ExecApp( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;

    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);

    if( ShellExecuteEx(&sei) )
        return sei.hProcess;
    
    return NULL;
}

//---------------------------------------------------------------------------
void AutoRunKillIE( void )
{
    HWND hwndIE;

	hwndIE=FindWindow("IEFrame",NULL);
    if(hwndIE!=NULL)
    {
        PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
    }
    else if ((hwndIE=FindWindow("Internet Explorer_Frame",NULL))!=NULL)
    {
        PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
    }
    else
    {
        hwndIE=FindWindow("CabinetWClass",NULL);
        if(hwndIE!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
    }
}

//---------------------------------------------------------------------------
void RegisterISKRun( )
{
    HKEY hkISK;
    HKEY hkISK2;
    DWORD dwDisp;
    char szCommand[MAX_PATH];
    char szSource[MAX_PATH];

    lstrcpy( szSource, g_szCurrentDir );
    lstrcat( szSource, "\\iskrun.exe" );

    GetWindowsDirectory( szCommand, MAX_PATH );
    lstrcat( szCommand, "\\iskrun.exe" );

    CopyFile( szSource, szCommand, FALSE );

    lstrcat( szCommand, " %1" );

    if (RegCreateKeyEx( HKEY_CLASSES_ROOT, ".isk", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK, &dwDisp ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hkISK, "", 0, REG_SZ, "ISKFile", REGLEN( "ISKFile" ));
        RegCloseKey( hkISK );
    }

    if (RegCreateKeyEx( HKEY_CLASSES_ROOT, "ISKFile", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK, &dwDisp ) == ERROR_SUCCESS)
    {
        if (RegCreateKeyEx( hkISK, "Shell", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK2, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkISK );
            return;
        }
        RegCloseKey( hkISK );
        if (RegCreateKeyEx( hkISK2, "Open", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkISK2 );
            return;
        }
        RegCloseKey( hkISK2 );
        if (RegCreateKeyEx( hkISK, "Command", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkISK2, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkISK );
            return;
        }
        RegCloseKey( hkISK );
        RegSetValueEx( hkISK2, "", 0, REG_SZ, szCommand, REGLEN( szCommand ));
        RegCloseKey( hkISK2 );
    }
}

//---------------------------------------------------------------------------
void UnregisterISKRun( )
{
    HKEY hkISK;
    HKEY hkISK2;
    char szCommand[MAX_PATH];

    GetWindowsDirectory( szCommand, MAX_PATH );
    lstrcat( szCommand, "\\iskrun.exe" );

    SetFileAttributes( szCommand, FILE_ATTRIBUTE_NORMAL );

    DeleteFile( szCommand );

    RegDeleteKey( HKEY_CLASSES_ROOT, ".isk" );
    if (RegOpenKeyEx( HKEY_CLASSES_ROOT, "ISKFile\\Shell\\Open", 0, KEY_READ|KEY_WRITE, &hkISK ) == ERROR_SUCCESS)
    {
        RegDeleteKey( hkISK, "Command" );
        RegCloseKey( hkISK );
    }
    if (RegOpenKeyEx( HKEY_CLASSES_ROOT, "ISKFile\\Shell", 0, KEY_READ|KEY_WRITE, &hkISK ) == ERROR_SUCCESS)
    {
        RegDeleteKey( hkISK, "Open" );
        RegCloseKey( hkISK );
    }
    if (RegOpenKeyEx( HKEY_CLASSES_ROOT, "ISKFile", 0, KEY_READ|KEY_WRITE, &hkISK ) == ERROR_SUCCESS)
    {
        RegDeleteKey( hkISK, "Shell" );
        RegCloseKey( hkISK );
    }
    RegDeleteKey( HKEY_CLASSES_ROOT, "ISKFile" );
}

//---------------------------------------------------------------------------
void ActiveXEnable( )
{
    HKEY hkRegKey;
    DWORD dwType;
    DWORD dwLength = 4;
    DWORD dwValue;
    char szSCD[16];

    if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
    {
        if( RegQueryValueEx( hkRegKey, "Security_RunActiveXControls", NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
	        RegSetValueEx( hkRegKey, "SRAXC_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        else
        {
	        dwValue = 1;
	        RegSetValueEx( hkRegKey, "SRAXC_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        }
        dwValue = 1;
        RegSetValueEx( hkRegKey, "Security_RunActiveXControls", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );

        dwLength = 4 ;
        if( RegQueryValueEx( hkRegKey, "Security_RunJavaApplets", NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
            RegSetValueEx( hkRegKey, "SRJA_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        else
        {
	        dwValue = 1;
	        RegSetValueEx( hkRegKey, "SRJA_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        }
        dwValue = 1;
        RegSetValueEx( hkRegKey, "Security_RunJavaApplets", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );

        dwLength = 4 ;
        if( RegQueryValueEx( hkRegKey, "Security_RunScripts", NULL, &dwType, (LPBYTE) &dwValue, &dwLength ) == ERROR_SUCCESS )
            RegSetValueEx( hkRegKey, "SRS_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        else
        {
	        dwValue = 1;
	        RegSetValueEx( hkRegKey, "SRS_BACKUP", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        }
        dwValue = 1;
        RegSetValueEx( hkRegKey, "Security_RunScripts", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );

        dwLength = 16;
        dwType = REG_SZ;
        if( RegQueryValueEx( hkRegKey, "Code Download", NULL, &dwType, szSCD, &dwLength ) == ERROR_SUCCESS )
            RegSetValueEx( hkRegKey, "SCD_BACKUP", 0, REG_SZ, szSCD, lstrlen(szSCD) + 1);
        else
            RegSetValueEx( hkRegKey, "SCD_BACKUP", 0, REG_SZ, "yes", 4);
        RegSetValueEx( hkRegKey, "Code Download", 0, REG_SZ, "yes", 4 );
        RegCloseKey( hkRegKey );
    }
}

//---------------------------------------------------------------------------
void RestoreActiveX( )
{
    HKEY hkRegKey;
    DWORD dwType;
    DWORD dwLength = 4;
    DWORD dwValue;
    char szSCD[16];

    if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_READ|KEY_WRITE, &hkRegKey ) == ERROR_SUCCESS)
    {
        RegQueryValueEx( hkRegKey, "SRAXC_BACKUP", NULL, &dwType, (LPBYTE) &dwValue, &dwLength );
        RegSetValueEx( hkRegKey, "Security_RunActiveXControls", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        RegDeleteValue( hkRegKey, "SRAXC_BACKUP" );

        dwLength = 4;
        RegQueryValueEx( hkRegKey, "SRJA_BACKUP", NULL, &dwType, (LPBYTE) &dwValue, &dwLength );
        RegSetValueEx( hkRegKey, "Security_RunJavaApplets", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        RegDeleteValue( hkRegKey, "SRJA_BACKUP" );

        dwLength = 4;
        RegQueryValueEx( hkRegKey, "SRS_BACKUP", NULL, &dwType, (LPBYTE) &dwValue, &dwLength );
        RegSetValueEx( hkRegKey, "Security_RunScripts", 0, REG_BINARY, (LPBYTE) &dwValue, sizeof(DWORD) );
        RegDeleteValue( hkRegKey, "SRS_BACKUP" );

        dwLength = 16;
        RegQueryValueEx( hkRegKey, "SCD_BACKUP", NULL, &dwType, szSCD, &dwLength );
        RegSetValueEx( hkRegKey, "Code Download", 0, REG_SZ, szSCD, lstrlen(szSCD) + 1);
        RegDeleteValue( hkRegKey, "SCD_BACKUP" );

        RegCloseKey( hkRegKey );
    }
}

//---------------------------------------------------------------------------
void CreateAppPath( )
{
    HKEY hkAppPath;
    HKEY hkIECD;
    DWORD dwDisp;
    char szIECD[MAX_PATH];

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths", 0, KEY_READ|KEY_WRITE, &hkAppPath ) == ERROR_SUCCESS)
    {
        if (RegCreateKeyEx( hkAppPath, "IECD.EXE", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkIECD, &dwDisp ) != ERROR_SUCCESS)
        {
            RegCloseKey( hkAppPath );
            return;
        }
        RegCloseKey( hkAppPath );
        lstrcpy( szIECD, g_szCurrentDir );
        lstrcat( szIECD, "\\iecd.exe" );

        RegSetValueEx( hkIECD, "", 0, REG_SZ, szIECD, REGLEN( szIECD ));
        RegCloseKey( hkIECD );
    }

}

//---------------------------------------------------------------------------
BOOL InstallVideoCodec( )
{
    char szInfPath[MAX_PATH];
    char szInfFile[MAX_PATH];
    HKEY hkRegKey;
    DWORD dwType = REG_SZ;
    DWORD dwLength = sizeof(szInfPath)/sizeof(szInfPath[0]);
    HRESULT hReturnCode;
    HANDLE hSetupLib;
    HRESULT (WINAPI *RunSetupCommand)(HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,HANDLE,DWORD,LPVOID);
    char szSetupPath[MAX_PATH];
    char szInstalled[32];
    char szIECD[MAX_PATH];

    // quit if we are under NT
    if( g_fWindowsNT )
	    return TRUE;

    // Check to see if video is installed
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\icm", 0, KEY_READ|KEY_WRITE, &hkRegKey ) != ERROR_SUCCESS)
        return TRUE;
    RegQueryValueEx( hkRegKey, "Installed", NULL, &dwType, szInstalled, &dwLength );
    RegCloseKey( hkRegKey );
    if( szInstalled[0] == '1' )
    	return TRUE;
    
    dwLength = MAX_PATH;

    // get inf path
    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion", 0, KEY_READ|KEY_WRITE, &hkRegKey ) != ERROR_SUCCESS )
	    return TRUE;
    RegQueryValueEx( hkRegKey, "DevicePath", NULL, &dwType, szInfPath, &dwLength );
    RegCloseKey( hkRegKey );

    if( lstrlen( szInfPath ) == 0 )
	    return TRUE;

    // load dll
    hSetupLib = LoadLibrary( "advpack.dll" );
    if( hSetupLib )
    {
	    RunSetupCommand = (RUNSETUPCOMMAND) GetProcAddress( hSetupLib, "RunSetupCommand" );
        if( !RunSetupCommand )
	        return TRUE;
    }

    wsprintf( szInfFile, "%s\\motown.inf", szInfPath );

    // get setup directory
    RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Setup", 0, KEY_READ|KEY_WRITE, &hkRegKey );
    dwLength = MAX_PATH;
    RegQueryValueEx( hkRegKey, "SourcePath", NULL, &dwType, szSetupPath, &dwLength );
    RegCloseKey( hkRegKey );

    if( lstrlen( szSetupPath ) == 0 )
	    lstrcpy( szSetupPath, szInfPath );

    if( lstrlen( szSetupPath ) > 4 )
	    szSetupPath[lstrlen(szSetupPath) - 1] = '\0';

    if(MessageBox( NULL, Res2Str( IDS_VIDEO ), Res2Str( IDS_APPTITLE ), MB_YESNO | MB_ICONQUESTION | MB_SETFOREGROUND ) == IDNO )
	    return TRUE;

    // run setup
    hReturnCode = (*RunSetupCommand)( NULL, szInfFile, "media_icm", szSetupPath, Res2Str( IDS_APPTITLE ),
	NULL, RSC_FLAG_INF | RSC_FLAG_QUIET, NULL );


    lstrcpy( szIECD, g_szCurrentDir );
    lstrcpy( szIECD, "\\iecd.exe" );


    if( !AutoRunCDIsInDrive( ))
	    return FALSE;

    FreeLibrary( hSetupLib );

    return TRUE;

}

//-------------------------------------------------------------------------
//
//      C H E C K  O S  V E R S I O N
//
//
//  Checks the platform and version.
//-------------------------------------------------------------------------
BOOL CheckOsVersion( )
{
    OSVERSIONINFO osVersion;

    osVersion.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    GetVersionEx( &osVersion );

    // if we are running anything less than Windows NT 4.0 or Windows 95, return FALSE
    if( osVersion.dwMajorVersion < 4 )
    {
//        MessageBox( NULL, Res2Str( IDS_WRONGVERSION ), Res2Str( IDS_TITLE ), MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    if( osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT )
	    g_fWindowsNT = TRUE;
    else
	    g_fWindowsNT = FALSE;

    return TRUE;
}

LRESULT CALLBACK MainWndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
	case WM_QUERYENDSESSION:
	{
	    HWND hwndIE;
	    DWORD dwExitCode=0;

	    AutoRunKillIE();

	    do 
        {
		    if(hwndIE=FindWindow(NULL,"Microsoft Internet Explorer"))
		    {                        
		        HWND hButton;

		        hButton=GetWindow(hwndIE,GW_CHILD);
		        PostMessage(hwndIE,WM_COMMAND,MAKEWPARAM(IDOK,BN_CLICKED),MAKELPARAM(hButton,0)); //Press the ok button to dismiss the dialog
		    }

		    GetExitCodeProcess(g_hIExplore,&dwExitCode);
	    } while(dwExitCode==STILL_ACTIVE);

	    return(TRUE);
	}
	case WM_DESTROY:

	    PostQuitMessage(0);
	    break;

	default:
	    return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    return 1;
}


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


//---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND window;
    HWND hwndIE;
    HWND hwndTray;
    HKEY hkLocale;
    HKEY hkIE;
    HKEY hkWin;
    int retval;
    char szIECmd[MAX_PATH];
    char szLang[MAX_PATH];
    DWORD dwLangSize=MAX_PATH;
    char szIEParams[MAX_PATH];
    char szIEDir[MAX_PATH];
    char szTemp[1024];
    char szStartHtm[MAX_PATH];
    // for security settings
    DWORD dwType;
    DWORD dwSize = 64;
    char szSecurity[64];
    char szTrust[64];
    BOOL fCmdLine = FALSE;
    HANDLE hMutex,hCDCache;
    HWND hIskRo;
    WNDCLASS wc;
    MSG msg;

    if( lstrlen( lpCmdLine ) != 0 )
	    fCmdLine = TRUE;

    g_hinst = hInstance;

    if( !CheckOsVersion( ))
	    return FALSE;

    //in case this is run from another directory...
    GetModuleFileName( NULL, g_szCurrentDir, MAX_PATH );
    _PathRemoveFileSpec( g_szCurrentDir );

    hMutex = CreateMutex( NULL, TRUE, "IESK_IECD" );
    if( GetLastError( ) == ERROR_ALREADY_EXISTS )
	    return(0);

    RegisterISKRun( );

    //
    // make sure they have IE5 Installed
    //

    if( (GetIEVersion()) || (!CheckBrand()) )
    {
	    //Install Microsoft Explorer 6
	    char szIE5Cmd[MAX_PATH],szInstallMessage[MAX_PATH],szInstallTitle[MAX_PATH];

	    // build paths for ExecApp
	    lstrcpy( szIE5Cmd, g_szCurrentDir );
	    lstrcat( szIE5Cmd, "\\ie3inst.exe" );

	    ExecApp( szIE5Cmd, " ", g_szCurrentDir, SW_SHOWNORMAL );

	    UnregisterISKRun( );

	    ReleaseMutex( hMutex );

	    return 0;
    }

    lstrcpy( szIEDir, GetIEPath( szIECmd, MAX_PATH ));
    _PathRemoveFileSpec( szIEDir );

    // add video compression drivers
    if(!InstallVideoCodec( ))
    {
	    UnregisterISKRun( );

	    ReleaseMutex( hMutex );

	    return 0;
    }

    CreateAppPath( );

    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Explorer\\Document Windows", 0, KEY_READ|KEY_WRITE, &hkIE );
    RegSetValueEx( hkIE, "Maximized", 0, REG_SZ, "yes", 4 );
    RegCloseKey( hkIE );

    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Explorer\\Security", 0, KEY_READ|KEY_WRITE, &hkIE );
    RegQueryValueEx( hkIE, "Safety Warning Level", NULL, &dwType, szSecurity, &dwSize );
    RegSetValueEx( hkIE, "SWL Backup", 0, REG_SZ, szSecurity, REGLEN( szSecurity ));
    RegSetValueEx( hkIE, "Safety Warning Level", 0, REG_SZ, "SucceedSilent", 14 );

    RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_READ|KEY_WRITE, &hkWin );
    dwSize = 64;
	RegQueryValueEx( hkWin, "Trust Warning Level", NULL, &dwType, szTrust, &dwSize );
    RegSetValueEx( hkWin, "TWL Backup", 0, REG_SZ, szTrust, REGLEN( szTrust ));
    RegSetValueEx( hkWin, "Trust Warning Level", 0, REG_SZ, "No Security", 12 );

    ActiveXEnable( );

    lstrcpy( szIEParams, "-SLF -k file://" );

    if( !fCmdLine )
    {
        lstrcat( szIEParams, g_szCurrentDir );
        lstrcat( szIEParams, "\\start.htm" );
        lstrcpy( szStartHtm, g_szCurrentDir);
        lstrcat( szStartHtm, "\\start.htm");
    }
    else
    {
        lstrcat( szIEParams, lpCmdLine );
        lstrcpy( szStartHtm, lpCmdLine);
    }

    if (GetFileAttributes(szStartHtm) != 0xFFFFFFFF)
    {
        g_hIExplore = ExecApp( szIECmd, szIEParams, szIEDir, SW_SHOWNORMAL );
        
        if(g_hIExplore)
        {
            DWORD dwExitCode;
            BOOL bContinue=TRUE;
            HANDLE hArray[2];
            HWND hIEWnd;
            
            hArray[0]=g_hIExplore;
            
            wc.style = 0;
            wc.lpfnWndProc = MainWndProc;
            wc.cbClsExtra = wc.cbWndExtra = 0;
            wc.hInstance = g_hinst;
            wc.hCursor = LoadCursor(NULL, IDC_ARROW);
            wc.hIcon = NULL;
            wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
            wc.lpszMenuName = NULL;
            wc.lpszClassName = "IECD";
            
            RegisterClass(&wc);
            
            // NOTE: If the window classname is changed, it should be reflected in closeie.exe,
            // iskrun.exe and browseui.dll which depend on the classname to check whether iecd.exe
            // is running.
            hIEWnd=CreateWindow( "IECD", "IECD", WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, 0, 0, 30, 30,
                NULL, NULL, g_hinst, NULL );
            
            hArray[1]=hIEWnd;
            
            while(bContinue)
            {
                MsgWaitForMultipleObjects(2,hArray,FALSE,INFINITE,QS_ALLINPUT);
                
                if(PeekMessage(&msg,hIEWnd,0,0,PM_REMOVE))
                {
                    if(msg.message==WM_QUIT)
                    {
                        bContinue=FALSE;
                    }
                    else
                    {
                        TranslateMessage( &msg );
                        DispatchMessage( &msg );
                    }
                }
                
                GetExitCodeProcess(g_hIExplore,&dwExitCode);
                
                if(dwExitCode!=STILL_ACTIVE)
                {
                    bContinue=FALSE;
                }
            }
        }
    }
    else
    {
        BOOL fShow = TRUE;
        DWORD dwVal = 0;
        HKEY hkShow;

        if (RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, KEY_READ|KEY_WRITE, &hkShow ) == ERROR_SUCCESS)
        {
            if ((RegQueryValueEx( hkShow, "DisableStartHtm", NULL, &dwType, (LPBYTE)&dwVal, &dwSize ) == ERROR_SUCCESS) &&
                dwVal)
            {
                RegDeleteValue(hkShow, "DisableStartHtm");
                fShow = FALSE;
            }
            RegCloseKey( hkShow );
        }

        if (fShow)
            MessageBox(NULL, Res2Str(IDS_LATESTVER), Res2Str(IDS_APPTITLE), MB_OK);
    }

    RestoreActiveX( );

    RegSetValueEx( hkIE, "Safety Warning Level", 0, REG_SZ, szSecurity, REGLEN( szSecurity ));
    RegDeleteValue( hkIE, "SWL Backup" );
    RegCloseKey( hkIE );

    RegSetValueEx( hkWin, "Trust Warning Level", 0, REG_SZ, szTrust, REGLEN( szTrust ));
    RegDeleteValue( hkWin, "TWL Backup" );
    RegCloseKey( hkWin );

    UnregisterISKRun( );

    ReleaseMutex( hMutex );

    return 0;
}

void ConvertVersionStr(LPSTR pszVer, WORD rwVer[])
{
    int i;
    for(i = 0; i < NUM_VERSION_NUM; i++)
	rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
	rwVer[i] = (WORD) AtoL(pszVer);
	pszVer = strchr(pszVer, '.');
	if (pszVer)
	    pszVer++;
    }
}

// Returns:
//    -1   Ver1 < Ver2
//     0   Ver1 == Ver2
//     1   Ver1 > Ver2
// Notes:
int VersionCmp(WORD rwVer1[], WORD rwVer2[])
{
    int i;
    for(i = 0; i < NUM_VERSION_NUM; i++)
    {
        if(rwVer1[i] < rwVer2[i])
            return -1;
        if(rwVer1[i] > rwVer2[i])
            return 1;
    }
    return 0;
}


#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)              ((c) >= '0'  &&  (c) <= '9')

// copied from msdev\crt\src\atox.c
/***
*long AtoL(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long AtoL(const char *nptr)
{
        int c;                  /* current char */
        long total;             /* current total */
        int sign;               /* if '-', then negative, otherwise positive */

        // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
        // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
        // DBCS Trailing bytes -- pritvi

        /* skip whitespace */
        while ( IsSpace((int)(unsigned char)*nptr) )
                ++nptr;

        c = (int)(unsigned char)*nptr++;
        sign = c;               /* save sign indication */
        if (c == '-' || c == '+')
                c = (int)(unsigned char)*nptr++;        /* skip sign */

        total = 0;

        while (IsDigit(c)) {
                total = 10 * total + (c - '0');         /* accumulate digit */
                c = (int)(unsigned char)*nptr++;        /* get next char */
        }

        if (sign == '-')
                return -total;
        else
                return total;   /* return result, negated if necessary */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\isk3ro\resource.h ===
#define IDS_CDMESSAGE   100
#define IDS_CDTITLE     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\iskrun\resource.h ===
#define IDS_TITLE   1
#define IDS_WINNT   2
#define IDS_ISW     3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\isk3ro\isk3ro.c ===
#include <windows.h>
#include "resource.h"

#define ISK_STARTAPP    WM_USER + 0x020
#define ISK_CLOSEAPP    WM_USER + 0x021

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

HINSTANCE g_hInst;
char g_lpCmd[MAX_PATH];
int g_nCount=0;
BOOL g_fFirst = FALSE;
HANDLE g_hExec;

BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
   STARTUPINFO startInfo;
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;
   
   if(phProc)
      *phProc = NULL;

   // Create process on pszCmd
   ZeroMemory(&startInfo, sizeof(startInfo));
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   startInfo.wShowWindow = (WORD) uShow;
   fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE, 
              NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
   if(!fRet)
      return E_FAIL;

   if(phProc)
      *phProc = processInfo.hProcess;
   else
      CloseHandle(processInfo.hProcess);

   CloseHandle(processInfo.hThread);
   
   return S_OK;
}
   

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT LaunchAndWait(LPSTR pszCmd, HANDLE hAbort, HANDLE *phProc, LPSTR pszDir, UINT uShow)
{
   HRESULT hr = S_OK;

   hr = LaunchProcess(pszCmd, phProc, pszDir, uShow);
   
   if(SUCCEEDED(hr))
   {
      DWORD dwRet;
      HANDLE pHandles[2];
      BOOL fQuit = FALSE;

      pHandles[0] = *phProc;
      
      if(hAbort)
         pHandles[1] = hAbort;     

      while(!fQuit)
      {
         dwRet = MsgWaitForMultipleObjects(hAbort ? 2 : 1, pHandles, FALSE, INFINITE, QS_ALLINPUT);
         // Give abort the highest priority
         if(dwRet == WAIT_OBJECT_0)
         {
            fQuit = TRUE;
         }
         else if((dwRet == WAIT_OBJECT_0 + 1) && hAbort)
         {
            // Any abort work?
            hr = E_ABORT;
            fQuit = TRUE;
         }
         else
         {
            MSG msg;
            // read all of the messages in this next loop 
            // removing each message as we read it 
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            { 
 
               // if it's a quit message we're out of here 
               if (msg.message == WM_QUIT)
               {
				   TerminateProcess(pHandles[0],0);
				   fQuit = TRUE; 
               }
			   else
               {
                  // otherwise dispatch it 
                 DispatchMessage(&msg); 
               } // end of PeekMessage while loop 
            }
         }
      }
   }
   
   return hr;
}

LRESULT CALLBACK MainWndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    char szCDPath[MAX_PATH];
	char * szCheckRunOnce;
    char szMsg[128];
	char szPath[MAX_PATH];
	char szWinPath[MAX_PATH];
	char szTest[MAX_PATH];
	long lResult;
	HKEY hkRunOnce;
	DWORD dwTest;

    switch( msg )
    {
    case WM_CREATE:
        ShowWindow( hWnd, SW_HIDE );

        lstrcpy( szCDPath, g_lpCmd);
        _PathRemoveFileSpec( szCDPath );
        if(LaunchAndWait(g_lpCmd, NULL, &g_hExec, szCDPath, SW_SHOWNORMAL)==E_FAIL)
        {
            TCHAR szMessage[MAX_PATH];
            TCHAR szTitle[MAX_PATH];

            LoadString( g_hInst, IDS_CDMESSAGE, szMessage, MAX_PATH );
            LoadString( g_hInst, IDS_CDTITLE, szTitle, MAX_PATH );

            MessageBox(NULL,szMessage,szTitle,MB_OK);
        }

        SendMessage(hWnd,WM_CLOSE,(WPARAM) 0,(LPARAM) 0);

        break;

    case ISK_STARTAPP:
        if( !g_fFirst )
            g_fFirst = TRUE;
        g_nCount++;
//        wsprintf( szMsg, "Start App\ng_nCount++\ng_nCount: %d", g_nCount );
//        MessageBox( NULL, szMsg, "ISK3RO", MB_OK | MB_SETFOREGROUND );
        break;

    case ISK_CLOSEAPP:
        g_nCount--;
        if( g_fFirst )
        {
            if( g_nCount < 1 )
                PostQuitMessage(0);
        }
        wsprintf( szMsg, "Close App\ng_nCount--\ng_nCount: %d", g_nCount );
//        MessageBox( NULL, szMsg, "ISK3RO", MB_OK | MB_SETFOREGROUND );
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    return 1;
}

void RegisterMe( )
{
    WNDCLASS wc;
    MSG msg;


    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "ISK3RO";

    RegisterClass(&wc);


    CreateWindow( "ISK3RO", "Isk3Ro", WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX, 0, 0, 30, 30,
        NULL, NULL, g_hInst, NULL );

    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

}

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    char szCDPath[MAX_PATH];
    HWND hwndIE=NULL;
    char *pParams;
    int i;
    int len;
	BOOL bIsOk;
    HKEY hkCheckCD;

    g_hInst = hInst;

    lstrcpy( g_lpCmd, lpCmdLine );

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion",0,KEY_READ|KEY_WRITE,&hkCheckCD)==ERROR_SUCCESS)
    {
        HKEY hkTips;
        TCHAR szClass[64];
        char szCheckCD[MAX_PATH];
        DWORD dwType=REG_SZ;
        DWORD dwSize;
        DWORD dwRes;

        dwSize = sizeof(szCheckCD);
        if(RegQueryValueEx(hkCheckCD,"DeleteWelcome",NULL,&dwType,szCheckCD,&dwSize)==ERROR_SUCCESS)
        {
            DeleteFile(szCheckCD);
            RegDeleteValue(hkCheckCD, "DeleteWelcome");

            if(RegCreateKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, szClass,
                REG_OPTION_NON_VOLATILE,KEY_READ|KEY_WRITE,NULL,&hkTips,&dwRes)
                 == ERROR_SUCCESS)
            {
                DWORD K0 = 0;
                RegSetValueEx(hkTips, "ShowIE4", 0, REG_DWORD,(LPBYTE) &K0, 4);
                RegCloseKey(hkTips);
            }
        }

        dwSize = sizeof(szCheckCD);
        if(RegQueryValueEx(hkCheckCD,"CDForcedOn",NULL,&dwType,szCheckCD,&dwSize)==ERROR_SUCCESS)
        {
            RegDeleteValue(hkCheckCD,"CDForcedOn");

            if(RegCreateKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips", 0, szClass,
                0,KEY_READ|KEY_WRITE,NULL,&hkTips,NULL)
                 == ERROR_SUCCESS)
            {
                DWORD K0 = 0;
                RegSetValueEx(hkTips, "ShowIE4", 0, REG_DWORD,(LPBYTE) &K0, 4);
                RegCloseKey(hkTips);
            }
        }

        RegCloseKey(hkCheckCD);
    }

    RegisterMe( );

    return TRUE;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\readme\resource.h ===
#define IDD_README                      102
#define IDC_README                      1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\iskrun\iskrun.c ===
#include <windows.h>
#include <shellapi.h>
#include "resource.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define ISK_CLOSEAPP    WM_USER + 0x021

HINSTANCE g_hInst;

char g_szTemp[1024];
char g_szTemp2[1024];

//-------------------------------------------------------------------------
//
//      R E S  2  S T R
//
//
//  Converts a resource identifier into a character pointer
//-------------------------------------------------------------------------
char *Res2Str(int nString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        LoadString(g_hInst, nString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    LoadString(g_hInst, nString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}
//-------------------------------------------------------------------------
//
//      P A T H  R E M O V E  F I L E  S P E C
//
//
//  Removes the file name from a path
//-------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything
    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}
//-------------------------------------------------------------------------
//
//      F I L E  E X I S T S
//
//
//  Checks to see if a file exists and returns true if it does
//-------------------------------------------------------------------------
BOOL FileExists( char *pszFile )
{
    return (GetFileAttributes( pszFile ) != -1 );
}
//-------------------------------------------------------------------------
//
//      E X E C  A P P
//
//
//  Executes and application and returns the process handle
//-------------------------------------------------------------------------
HANDLE ExecApp( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);

    if( ShellExecuteEx(&sei) )
        return sei.hProcess;

    return NULL;
}

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    HANDLE hProcess;
    char szCommand[MAX_PATH];
    char szParams[MAX_PATH];
    char szDir[MAX_PATH];
    char szTemp[1024];
    char szRetPage[1024];
    BOOL fRetPage = FALSE;
    HWND hIskRo;
    HWND hISW;

    g_hInst = hInst;

    if( lstrlen( lpCmdLine ) == 0 )
        return FALSE;

    if( !FileExists( lpCmdLine ) )
        return FALSE;

    if( GetPrivateProfileInt( "ISK", "NoNT", 0, lpCmdLine ) == 1 )
    {
        OSVERSIONINFO osver;

        osver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

        GetVersionEx( &osver );

        if( osver.dwMajorVersion < 4 || osver.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            MessageBox( NULL, Res2Str( IDS_WINNT ), Res2Str( IDS_TITLE ), MB_OK | MB_SETFOREGROUND );
            return FALSE;
        }
    }

    if( GetPrivateProfileInt( "ISK", "CloseIE", 0, lpCmdLine ) == 1 )
    {
        HWND hwndIE;

        fRetPage = TRUE;

        hwndIE=FindWindow("IEFrame",NULL);
        if(hwndIE!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
        else if ((hwndIE=FindWindow("Internet Explorer_Frame",NULL))!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
        else
        {
            hwndIE=FindWindow("CabinetWClass",NULL);
            if(hwndIE!=NULL)
            {
                PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
            }
        }

        hwndIE=FindWindow("IECD",NULL);
        if(hwndIE!=NULL)
        {
            PostMessage(hwndIE,WM_CLOSE,(WPARAM) NULL,(LPARAM) NULL);
        }
    }

    if( GetPrivateProfileInt( "ISK", "RunIExplore", 0, lpCmdLine ) == 1 )
    {
        char szPage[MAX_PATH];

        GetPrivateProfileString( "ISK", "Params", "", szParams, MAX_PATH, lpCmdLine );

        lstrcpy( szDir, lpCmdLine );
        _PathRemoveFileSpec( szDir );

        wsprintf( szPage, "file://%s\\%s", szDir, szParams );

        hProcess = ExecApp( "IEXPLORE.EXE", szPage, szDir, SW_SHOWNORMAL );
    }
    else
    {
        GetPrivateProfileString( "ISK", "Command", "", szCommand, MAX_PATH, lpCmdLine );
        GetPrivateProfileString( "ISK", "Params", "", szParams, MAX_PATH, lpCmdLine );

        lstrcpy( szDir, lpCmdLine );
        _PathRemoveFileSpec( szDir );

        hProcess = ExecApp( szCommand, szParams, szDir, SW_SHOWNORMAL );
    }
    if( fRetPage )
    {
        if( hProcess )
        {
            DWORD dwResult;
            while((dwResult=MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                MSG msg;
                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if( msg.message == WM_QUIT )
                        goto get_out;
                    DefWindowProc( msg.hwnd, msg.message, msg.wParam, msg.lParam );
//                    DispatchMessage( &msg );
                }
            }
        }

get_out:

//        WaitForSingleObject( hProcess, INFINITE );


        hISW = FindWindow( NULL, Res2Str( IDS_ISW ) );
        if( hISW != NULL )
        {
            DWORD dwProcessId;
            HANDLE hProcess;

            GetWindowThreadProcessId( hISW, &dwProcessId );
            hProcess = OpenProcess( PROCESS_ALL_ACCESS, TRUE, dwProcessId );
            if( hProcess )
            {
                DWORD dwResult;
                while((dwResult=MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
                {
                    MSG msg;
                    // read all of the messages in this next loop
                    // removing each message as we read it
                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        if( msg.message == WM_QUIT )
                            goto get_out2;
                        DefWindowProc( msg.hwnd, msg.message, msg.wParam, msg.lParam );
                    }
                }
            }
        }
get_out2:

        GetPrivateProfileString( "ISK", "RetPage", "", szTemp, 1024, lpCmdLine );

        if( lstrlen( szTemp ) > 0 )
        {
            wsprintf( szRetPage, "%s\\%s", szDir, szTemp );
            ExecApp( "IECD.EXE", szRetPage, "", SW_SHOWNORMAL );
        }

        Sleep( 2000 );

        hIskRo = FindWindow( "ISK3RO", NULL );
        if( hIskRo ) SendMessage( hIskRo, ISK_CLOSEAPP, 0, 0 );

    }

    return 0;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\runisp32\runisp32.c ===
#include <windows.h>
#include <shellapi.h>

//-------------------------------------------------------------------------
//
//      P A T H  R E M O V E  F I L E  S P E C
//
//
//  Removes the file name from a path
//-------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything
    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}
//-------------------------------------------------------------------------
//
//      E X E C  A P P
//
//
//  Executes and application and returns the process handle
//-------------------------------------------------------------------------
HANDLE ExecApp( char *command, char *params, char *dir, int nWinState )
{
    SHELLEXECUTEINFO sei;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = "Open";
    sei.lpFile = command;
    sei.lpParameters = params;
    sei.lpDirectory = dir;
    sei.nShow = nWinState;
    sei.cbSize = sizeof(sei);

    if( ShellExecuteEx(&sei) )
        return sei.hProcess;

    return NULL;
}

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    HKEY hkRegKey;
    DWORD dwType;
    DWORD dwLength=MAX_PATH;
    char szIEPath[MAX_PATH];
    char szDir[MAX_PATH];
    char szParams[MAX_PATH];
    HANDLE hProcess;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE", 0, KEY_ALL_ACCESS, &hkRegKey ) != ERROR_SUCCESS)
        //we're toast
        goto get_out;
    RegQueryValueEx( hkRegKey, "", NULL, &dwType, szIEPath, &dwLength );
    RegCloseKey( hkRegKey );


    _PathRemoveFileSpec( szIEPath );

    lstrcat( szIEPath, "\\signup" );
    lstrcpy( szDir, szIEPath );
    lstrcat( szIEPath, "\\signup.htm" );

    wsprintf( szParams, "-h %s", szIEPath );
    hProcess = ExecApp( "ISIGNUP.EXE", szParams, szDir, SW_SHOWNORMAL );
    if( hProcess )
    {
        DWORD dwResult;
        while((dwResult=MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
            MSG msg;
            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if( msg.message == WM_QUIT )
                    goto get_out;
                DefWindowProc( msg.hwnd, msg.message, msg.wParam, msg.lParam );
            }
        }
    }
get_out:
    return 0;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\readme\readme.c ===
#include <windows.h>
#include <windowsx.h>
#include "resource.h"

char g_szCurrentDir[MAX_PATH];
char *g_szLicenseText;
//---------------------------------------------------------------------------
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;	// stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;	// stripped something
    }
}


//---------------------------------------------------------------------------
//      L O A D  R E A D M E
//
//  ISK3
//  This will load the readme data file
//
//---------------------------------------------------------------------------
void LoadReadme( char *szLicenseText)
{
    CHAR    szLicensePath[MAX_PATH];
    const   CHAR szLicenseFile[] = "\\license.txt";
    BOOL    retval = FALSE;
    HANDLE  hLicense;
    INT     filesize;
    DWORD   cbRead;

    lstrcpy( szLicensePath, g_szCurrentDir );
    lstrcat( szLicensePath, "\\Moreinfo.txt" );

    if (GetFileAttributes(szLicensePath) != (DWORD) -1)
    {
        // Open the file
        hLicense = CreateFile(szLicensePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hLicense != INVALID_HANDLE_VALUE)
        {

            // Get size and allocate buffer
            filesize = GetFileSize(hLicense, NULL);

            // Read File
            if (ReadFile( hLicense, szLicenseText, filesize, &cbRead, NULL))
            {
                // NULL terminate it
                szLicenseText[ filesize ] = '\0';

            }
        }
        CloseHandle( hLicense );
    }
}

void ReadmeCenterWindow( HWND hwnd )
{
    int screenx;
    int screeny;
    int height, width, x, y;
    RECT rect;

    screenx = GetSystemMetrics( SM_CXSCREEN );
    screeny = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwnd, &rect );

    width = rect.right - rect.left;
    height = rect.bottom - rect.top;
    x = (screenx / 2) - (width / 2);
    y = (screeny / 2) - (height / 2);

    SetWindowPos( hwnd, HWND_TOP, x, y, width, height, SWP_NOZORDER );

}

void InitSysFont(HWND hDlg, int iCtrlID)
{
    static HFONT hfontSys;

    LOGFONT lf;
    HDC     hDC;
    HWND    hwndCtrl = GetDlgItem(hDlg, iCtrlID);
    HFONT   hFont;
    int     cyLogPixels;

    hDC = GetDC(NULL);
    if (hDC == NULL)
        return;

    cyLogPixels = GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    if (hfontSys == NULL) {
        LOGFONT lfTemp;
        HFONT   hfontDef = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

        GetObject(hfontDef, sizeof(lfTemp), &lfTemp);
        hFont = GetWindowFont(hwndCtrl);
        if (hFont != NULL)
            if (GetObject(hFont, sizeof(LOGFONT), (PVOID)&lf)) {
                lstrcpy(lf.lfFaceName, lfTemp.lfFaceName);
                lf.lfQuality        = lfTemp.lfQuality;
                lf.lfPitchAndFamily = lfTemp.lfPitchAndFamily;
                lf.lfCharSet        = lfTemp.lfCharSet;

                hfontSys = CreateFontIndirect(&lf);
            }
    }

    if (iCtrlID == 0xFFFF)
        return;

    if (hfontSys != NULL)
        SetWindowFont(hwndCtrl, hfontSys, FALSE);
}

BOOL CALLBACK ReadmeProc( HWND hDlg, UINT msg, WPARAM wparam, LPARAM lparam )
{
    switch( msg )
    {
        case WM_INITDIALOG:
            InitSysFont(hDlg, IDC_README);
            ReadmeCenterWindow( hDlg );
            SetDlgItemText( hDlg, IDC_README, g_szLicenseText );
            return(0);
        case WM_COMMAND:
            if( wparam == IDOK )
                EndDialog( hDlg, 0 );
                break;
            if( wparam == IDC_README )
                return(0);
                break;

        case WM_CLOSE:
            EndDialog( hDlg, 0 );
            break;
    }
    return(0);
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    char *szLicenseText = (char *) LocalAlloc( LPTR, 64000 );

    g_szLicenseText = szLicenseText;

    GetModuleFileName( NULL, g_szCurrentDir, MAX_PATH );
    _PathRemoveFileSpec( g_szCurrentDir );

    LoadReadme( szLicenseText );

    DialogBox( hInstance, MAKEINTRESOURCE( IDD_README ), NULL, (DLGPROC) ReadmeProc );

    LocalFree( szLicenseText );

    szLicenseText = NULL;

	return(0);
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\setup\version.h ===
#define OFFICIAL   1
#define FINAL      1

#define IEDKIT

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

/*XLATOFF*/
#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 
/*XLATON*/

/*--------------------------------------------------------------*/
/*                                                              */
/*                    CHANGING VERSION?                         */
/*                                                              */
/*                      PLEASE READ!                            */
/*                                                              */
/* The version has BOTH hex and string representations.  Take   */
/* care that the string version components are PROPERLY         */
/* CONVERTED TO HEX and that the hex values are INSERTED INTO   */
/* THE CORRECT POSITION in the hex versions.                    */
/*                                                              */
/* Suppose the version was being defined as:                    */
/*                                                              */
/*           #define VERSION  "9.99.1234"                       */
/*                                                              */
/* The other string preresentations of the version would be:    */ 
/*                                                              */
/*           #define VER_PRODUCTVERSION_STR  "9.99.1234\0"      */
/*           #define VER_PRODUCTVERSION       9,99,0,1234       */
/*                                                              */
/* The hex versions would NOT be 0x0999????.  The correct       */
/* definitions are:                                             */
/*                                                              */
/*    #define VER_PRODUCTVERSION_BUILD 1234                     */
/*    #define VER_PRODUCTVERSION_DW    (0x09630000 | 1234)      */
/*    #define VER_PRODUCTVERSION_W     (0x0963)                 */
/*                                                              */
/* The last four digits of the build number should be modified  */
/* by the official builder for each build.                      */
/*                                                              */
/*--------------------------------------------------------------*/
#if defined(IEDKIT)

/*--------------------------------------------------------------*/
/* Version numbers for IE Distribution kit                      */
/*--------------------------------------------------------------*/

#define VERSION                     "3.0.0.0006"
#define VER_PRODUCTVERSION_STR      "3.0.0.0006\0"
#define VER_PRODUCTVERSION          3,0,0,6
#define VER_PRODUCTVERSION_BUILD    6
#define VER_PRODUCTVERSION_DW       (0x01000000 | 6)
#define VER_PRODUCTVERSION_W        (0x0100)
#endif


/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#define VER_PRODUCTNAME_STR         "Microsoft\256 Internet Explorer CD\0"

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cdinst\resource.h ===
#define IDS_TITLE                   0
#define IDS_SRCDIR_NOT_FOUND        1
#define IDS_DESTDIR_NOT_FOUND       2
#define IDS_INI_NOT_FOUND           3
#define IDS_NOT_ENOUGH_DISK_SPACE   4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cdinst\cdinst.cpp ===
#include <windows.h>
#include <regstr.h>
#include <shellapi.h>
#include "cdinst.h"
#include "resource.h"

// global variables
HINSTANCE g_hInst;
CHAR g_szTitle[128];
CHAR g_szSrcDir[MAX_PATH], g_szDstDir[MAX_PATH];


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, INT iCmdShow)
{
    BOOL bIniCopiedToTemp = FALSE;
    CHAR szIniFile[MAX_PATH], szSrcDir[MAX_PATH], szDstDir[MAX_PATH];
    LPSTR pszSection, pszPtr, pszLine, pszFile, pszSrcSubDir, pszDstSubDir;
    DWORD dwLen, dwSpaceReq, dwSpaceFree;

    g_hInst = hInstance;

    LoadString(g_hInst, IDS_TITLE, g_szTitle, sizeof(g_szTitle));

    ParseCmdLine(pszCmdLine);

    if (*g_szSrcDir == '\0')
    {
        if (GetModuleFileName(g_hInst, g_szSrcDir, sizeof(g_szSrcDir)))
            if ((pszPtr = ANSIStrRChr(g_szSrcDir, '\\')) != NULL)
                *pszPtr = '\0';

        if (*g_szSrcDir == '\0')
        {
            ErrorMsg(IDS_SRCDIR_NOT_FOUND);
            return -1;
        }
    }

    if (*g_szDstDir == '\0')
    {
        HKEY hk;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS "\\ieak6wiz.exe", 0, KEY_READ, &hk) == ERROR_SUCCESS)
        {
            dwLen = sizeof(g_szDstDir);

            RegQueryValueEx(hk, "Path", NULL, NULL, (LPBYTE) g_szDstDir, &dwLen);
            RegCloseKey(hk);
        }

        if (*g_szDstDir == '\0')
        {
            ErrorMsg(IDS_DESTDIR_NOT_FOUND);
            return -1;
        }
    }

    // look for cdinst.ini in the dir where the parent module (ieak6cd.exe) is running from
    *szIniFile = '\0';
    lstrcpy(szIniFile, g_szSrcDir);
    AddPath(szIniFile, "cdinst.ini");
    if (!FileExists(szIniFile))
    {
        // not found where ieak6cd.exe is running from; so look for it in the dir where the current
        // module (cdinst.exe) is running from
        *szIniFile = '\0';
        if (GetModuleFileName(g_hInst, szIniFile, sizeof(szIniFile)))
        {
            if ((pszPtr = ANSIStrRChr(szIniFile, '\\')) != NULL)
                *pszPtr = '\0';
            AddPath(szIniFile, "cdinst.ini");
        }

        if (!FileExists(szIniFile))
        {
            *szIniFile = '\0';
            GetModuleFileName(g_hInst, szIniFile, sizeof(szIniFile));
            ErrorMsg(IDS_INI_NOT_FOUND, g_szSrcDir, szIniFile);
            return -1;
        }
    }

    // copy cdinst.ini to the temp dir -- need to do this because on Win95, if cdinst.ini
    // is at the same location as ieak6cd.exe on a read-only media (like CD), then
    // GetPrivateProfileSection() calls would fail.
    // NOTE: szSrcDir and szDstDir are used as temp variables below
    if (GetTempPath(sizeof(szSrcDir), szSrcDir))
        if (GetTempFileName(szSrcDir, "cdinst", 0, szDstDir))
            if (CopyFile(szIniFile, szDstDir, FALSE))
            {
                bIniCopiedToTemp = TRUE;
                lstrcpy(szIniFile, szDstDir);
                SetFileAttributes(szIniFile, FILE_ATTRIBUTE_NORMAL);
            }

    // NOTE: If the destination dir is a UNC path, GetFreeDiskSpace() won't return the right value on Win95 Gold.
    //       So we turn off disk space checking if installing to a UNC path.
    while (!EnoughDiskSpace(g_szSrcDir, g_szDstDir, szIniFile, &dwSpaceReq, &dwSpaceFree))
    {
        if (ErrorMsg(IDS_NOT_ENOUGH_DISK_SPACE, dwSpaceReq, dwSpaceFree) == IDNO)
            return -1;
    }

    // copy files that are specified in the [copy] section
    // format of a line in the [copy] section is (all the fields should be on one line):
    //     <file (can contain wildcards)>,
    //     <src sub dir (can be a relative path) - optional>,
    //     <dest sub dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Copy", &pszSection, &dwLen, szIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
            GetDirPath(g_szSrcDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), szIniFile);
            GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
            CopyFiles(szSrcDir, pszFile, szDstDir, FALSE);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    // delete files that are specified in the [exclude] section from the destination dir
    // format of a line in the [exclude] section is (all the fields should be on one line):
    //     <file (can contain wildcards)>,
    //     <dest sub dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Exclude", &pszSection, &dwLen, szIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, NULL, &pszDstSubDir);
            GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
            DelFiles(pszFile, szDstDir);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    // extract all the files from cabs that are specified in the [extract] section
    // format of a line in the [extract] section is (all the fields should be on one line):
    //     <cab file (can contain wildcards)>,
    //     <src sub dir (can be a relative path) - optional>,
    //     <dest sub dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Extract", &pszSection, &dwLen, szIniFile))
    {
        HINSTANCE hAdvpack;

        if ((hAdvpack = LoadLibrary("advpack.dll")) != NULL)
        {
            EXTRACTFILES pfnExtractFiles;

            if ((pfnExtractFiles = (EXTRACTFILES) GetProcAddress(hAdvpack, "ExtractFiles")) != NULL)
            {
                for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
                {
                    ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
                    GetDirPath(g_szSrcDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), szIniFile);
                    GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
                    ExtractFiles(szSrcDir, pszFile, szDstDir, pfnExtractFiles);
                }
            }

            FreeLibrary(hAdvpack);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    // move files that are specified in the [move] section from a subdir to another subdir under the destination dir
    // format of a line in the [move] section is (all the fields should be on one line):
    //     <file (can contain wildcards)>,
    //     <from sub dir under the dest dir (can be a relative path) - optional>,
    //     <to sub dir under the dest dir (can be a relative path) - optional>
    if (ReadSectionFromInf("Move", &pszSection, &dwLen, szIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
            GetDirPath(g_szDstDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), szIniFile);
            GetDirPath(g_szDstDir, pszDstSubDir, szDstDir, sizeof(szDstDir), szIniFile);
            MoveFiles(szSrcDir, pszFile, szDstDir);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    if (bIniCopiedToTemp)
        DeleteFile(szIniFile);

    return 0;
}


BOOL EnoughDiskSpace(LPCSTR pcszSrcRootDir, LPCSTR pcszDstRootDir, LPCSTR pcszIniFile, LPDWORD pdwSpaceReq, LPDWORD pdwSpaceFree)
// check if there is enough free disk space to copy all the files
{
    DWORD dwSpaceReq = 0, dwSpaceFree;
    CHAR szSrcDir[MAX_PATH], szDstDir[MAX_PATH];
    LPSTR pszSection, pszLine, pszFile, pszSrcSubDir, pszDstSubDir;
    DWORD dwLen, dwFlags;

    if (!GetFreeDiskSpace(pcszDstRootDir, &dwSpaceFree, &dwFlags))
    {
        // if we can't get FreeDiskSpace info, then turn off disk space checking
        return TRUE;
    }

    // total space required =
    //     size of all the files to be copied +
    //     2 * size of all the files to be extracted

    if (ReadSectionFromInf("Copy", &pszSection, &dwLen, pcszIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, &pszDstSubDir);
            GetDirPath(pcszSrcRootDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), pcszIniFile);
            GetDirPath(pcszDstRootDir, pszDstSubDir, szDstDir, sizeof(szDstDir), pcszIniFile);

            dwSpaceReq += FindSpaceRequired(szSrcDir, pszFile, szDstDir);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    if (ReadSectionFromInf("Extract", &pszSection, &dwLen, pcszIniFile))
    {
        for (pszLine = pszSection;  dwLen = lstrlen(pszLine);  pszLine += dwLen + 1)
        {
            ParseIniLine(pszLine, &pszFile, &pszSrcSubDir, NULL);
            GetDirPath(pcszSrcRootDir, pszSrcSubDir, szSrcDir, sizeof(szSrcDir), pcszIniFile);

            dwSpaceReq += 2 * FindSpaceRequired(szSrcDir, pszFile, NULL);
        }
    }
    if (pszSection != NULL)
        LocalFree(pszSection);

    dwSpaceReq += 1024;             // 1MB buffer to account for random stuff

    if (dwFlags & FS_VOL_IS_COMPRESSED)
    {
        // if the destination volume is compressed, the free space returned is only
        // a guesstimate; for example, if it's a DoubleSpace volume, the system thinks
        // that it can compress by 50% and so it reports the free space as (actual free space * 2)

        // it's better to be safe when dealing with compressed volumes; so bump up the space
        // requirement by a factor 2
        dwSpaceReq <<= 1;           // multiply by 2
    }

    if (pdwSpaceReq != NULL)
        *pdwSpaceReq = dwSpaceReq;

    if (pdwSpaceFree != NULL)
        *pdwSpaceFree = dwSpaceFree;

    return dwSpaceFree > dwSpaceReq;
}


BOOL GetFreeDiskSpace(LPCSTR pcszDir, LPDWORD pdwFreeSpace, LPDWORD pdwFlags)
// Return the free disk space (in KBytes) in *pdwFreeSpace
{
    BOOL bRet = FALSE;
    DWORD dwFreeSpace = 0;
    DWORD nSectorsPerCluster, nBytesPerSector, nFreeClusters, nTotalClusters;
    CHAR szDrive[8];

    if (pcszDir == NULL  ||  *pcszDir == '\0'  ||  *(pcszDir + 1) != ':')
        return FALSE;

    if (pdwFreeSpace == NULL)
        return FALSE;

    lstrcpyn(szDrive, pcszDir, 3);
    AddPath(szDrive, NULL);
    if (GetDiskFreeSpace(szDrive, &nSectorsPerCluster, &nBytesPerSector, &nFreeClusters, &nTotalClusters))
    {
        // convert size to KBytes; assumption here is that the free space doesn't exceed 4096 gigs
        if ((*pdwFreeSpace = MulDiv(nFreeClusters, nSectorsPerCluster * nBytesPerSector, 1024)) != (DWORD) -1)
        {
            bRet = TRUE;

            if (pdwFlags != NULL)
            {
                *pdwFlags = 0;
                GetVolumeInformation(szDrive, NULL, 0, NULL, NULL, pdwFlags, NULL, 0);
            }
        }
    }

    return bRet;
}


DWORD FindSpaceRequired(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir)
// Return the difference in size (in KBytes) of pcszFile (can contain wildcards)
// under pcszSrcDir and pcszDstDir (if specified)
{
    DWORD dwSizeReq = 0;
    CHAR szSrcFile[MAX_PATH], szDstFile[MAX_PATH];
    LPSTR pszSrcPtr, pszDstPtr;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;

    lstrcpy(szSrcFile, pcszSrcDir);
    AddPath(szSrcFile, NULL);
    pszSrcPtr = szSrcFile + lstrlen(szSrcFile);

    if (pcszDstDir != NULL)
    {
        lstrcpy(szDstFile, pcszDstDir);
        AddPath(szDstFile, NULL);
        pszDstPtr = szDstFile + lstrlen(szDstFile);
    }

    lstrcpy(pszSrcPtr, pcszFile);
    if ((hFindFile = FindFirstFile(szSrcFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                DWORD dwSrcSize, dwDstSize;

                // assumption here is that the size of the file doesn't exceed 4 gigs
                dwSrcSize = fileData.nFileSizeLow;
                dwDstSize = 0;

                if (pcszDstDir != NULL)
                {
                    lstrcpy(pszDstPtr, fileData.cFileName);
                    dwDstSize = FileSize(szDstFile);
                }

                if (dwSrcSize >= dwDstSize)
                {
                    // divide the difference by 1024 (we are interested in KBytes)
                    dwSizeReq += ((dwSrcSize - dwDstSize) >> 10);
                    if (dwSrcSize > dwDstSize)
                        dwSizeReq++;            // increment by 1 to promote any fraction to a whole number
                }
            }
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }

    return dwSizeReq;
}


VOID ParseIniLine(LPSTR pszLine, LPSTR *ppszFile, LPSTR *ppszSrcDir, LPSTR *ppszDstDir)
{
    if (ppszFile != NULL)
        *ppszFile = Trim(GetNextField(&pszLine, ",", REMOVE_QUOTES));
    if (ppszSrcDir != NULL)
        *ppszSrcDir = Trim(GetNextField(&pszLine, ",", REMOVE_QUOTES));
    if (ppszDstDir != NULL)
        *ppszDstDir = Trim(GetNextField(&pszLine, ",", REMOVE_QUOTES));
}


LPSTR GetDirPath(LPCSTR pcszRootDir, LPCSTR pcszSubDir, CHAR szDirPath[], DWORD cchBuffer, LPCSTR pcszIniFile)
{
    *szDirPath = '\0';

    if (pcszRootDir == NULL)
        return NULL;

    lstrcpyn(szDirPath, pcszRootDir, cchBuffer);
    if (pcszSubDir != NULL  &&  *pcszSubDir)
    {
        CHAR szTemp[MAX_PATH];

        // if there are any placeholders in pcszSubDir (%en%, etc), ReplacePlaceholders will replace
        // them with the actual strings
        if (ReplacePlaceholders(pcszSubDir, pcszIniFile, szTemp, sizeof(szTemp)))
        {
            if ((DWORD) lstrlen(szDirPath) + 1 < cchBuffer)     // there is room for '\\' which AddPath
                                                                // might append to szDirPath (see below)
            {
                INT iLen;

                AddPath(szDirPath, NULL);                       // we have enough room in szDirPath for '\\'

                if (cchBuffer > (DWORD) (iLen = lstrlen(szDirPath)))
                    lstrcpyn(szDirPath + iLen, szTemp, cchBuffer - iLen);
            }
        }
    }

    return szDirPath;
}


DWORD ReplacePlaceholders(LPCSTR pszSrc, LPCSTR pszIns, LPSTR pszBuffer, DWORD cchBuffer)
{
    LPCSTR pszAux;
    CHAR szResult[MAX_PATH];
    UINT nDestPos, nLeftPos;

    nDestPos = 0;
    nLeftPos = (UINT) -1;

    for (pszAux = pszSrc;  *pszAux;  pszAux = CharNext(pszAux))
    {
        if (*pszAux != '%')
        {
            szResult[nDestPos++] = *pszAux;

            if (IsDBCSLeadByte(*pszAux))
                szResult[nDestPos++] = *(pszAux + 1);   // copy the trail byte as well
        }
        else if (*(pszAux + 1) == '%')                  // "%%" is just '%' in the string
        {
            if (nLeftPos != (UINT) -1)
                // REVIEW: (andrewgu) "%%" are not allowed inside tokens. this also means that
                // tokens can't be like %foo%%bar%, where the intention is for foo and bar to
                // be tokens.
                return 0;

            szResult[nDestPos++] = *pszAux++;
        }
        else
        {
            UINT nRightPos;

            nRightPos = (UINT) (pszAux - pszSrc);       // initialized, but not necessarily used as such
            if (nLeftPos == (UINT) -1)
                nLeftPos = nRightPos;
            else
            {
                CHAR szAux1[MAX_PATH], szAux2[MAX_PATH];
                DWORD dwLen;
                UINT nTokenLen;

                // "%%" is invalid here
                nTokenLen = nRightPos - nLeftPos - 1;

                lstrcpyn(szAux1, pszSrc + nLeftPos + 1, nTokenLen + 1);

                if ((dwLen = GetPrivateProfileString("Strings", szAux1, "", szAux2, sizeof(szAux2), pszIns)))
                {
                    lstrcpy(&szResult[nDestPos - nTokenLen], szAux2);
                    nDestPos += dwLen - nTokenLen;
                }

                nLeftPos = (UINT) -1;
            }
        }
    }

    if (nLeftPos != (UINT) -1)                      // mismatched '%'
        return 0;

    if (cchBuffer <= nDestPos)                      // insufficient buffer size
        return 0;

    szResult[nDestPos] = '\0';                      // make sure zero terminated
    lstrcpy(pszBuffer, szResult);

    return nDestPos;
}


VOID SetAttribsToNormal(LPCSTR pcszFile, LPCSTR pcszDir)
// Set the attribs of pcszFile (can contain wildcards) under pcszDir to NORMAL
{
    CHAR szFile[MAX_PATH];
    LPSTR pszPtr;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;

    lstrcpy(szFile, pcszDir);
    AddPath(szFile, NULL);
    pszPtr = szFile + lstrlen(szFile);

    lstrcpy(pszPtr, pcszFile);
    if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                lstrcpy(pszPtr, fileData.cFileName);
                SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
            }
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }
}


VOID CopyFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, BOOL fQuiet)
{
    SHFILEOPSTRUCT shfStruc;
    CHAR szSrcFiles[MAX_PATH + 1];

    if (!PathExists(pcszDstDir))
        PathCreatePath(pcszDstDir);
    else
    {
        // set the attribs of files under pcszDstDir to NORMAL so that on a reinstall,
        // SHFileOperation doesn't choke on read-only files
        SetAttribsToNormal(pcszFile, pcszDstDir);
    }

    ZeroMemory(szSrcFiles, sizeof(szSrcFiles));
    lstrcpy(szSrcFiles, pcszSrcDir);
    AddPath(szSrcFiles, pcszFile);

    ZeroMemory(&shfStruc, sizeof(shfStruc));

    shfStruc.hwnd = NULL;
    shfStruc.wFunc = FO_COPY;
    shfStruc.pFrom = szSrcFiles;
    shfStruc.pTo = pcszDstDir;
    shfStruc.fFlags = FOF_FILESONLY | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;
    if (fQuiet)
        shfStruc.fFlags |= FOF_SILENT;

    SHFileOperation(&shfStruc);
}


VOID DelFiles(LPCSTR pcszFile, LPCSTR pcszDstDir)
{
    SHFILEOPSTRUCT shfStruc;
    CHAR szDstFiles[MAX_PATH + 1];

    // set the attribs of files under pcszDstDir to NORMAL so that
    // SHFileOperation doesn't choke on read-only files
    SetAttribsToNormal(pcszFile, pcszDstDir);

    ZeroMemory(szDstFiles, sizeof(szDstFiles));
    lstrcpy(szDstFiles, pcszDstDir);
    AddPath(szDstFiles, pcszFile);

    ZeroMemory(&shfStruc, sizeof(shfStruc));

    shfStruc.hwnd = NULL;
    shfStruc.wFunc = FO_DELETE;
    shfStruc.pFrom = szDstFiles;
    shfStruc.fFlags = FOF_FILESONLY | FOF_NOCONFIRMATION | FOF_SILENT | FOF_NOERRORUI;

    SHFileOperation(&shfStruc);
}


VOID ExtractFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, EXTRACTFILES pfnExtractFiles)
{
    CHAR szSrcCab[MAX_PATH];

    lstrcpy(szSrcCab, pcszSrcDir);
    AddPath(szSrcCab, pcszFile);

    // NOTE: ExtractFiles fails if the dest dir doesn't exist
    if (!PathExists(pcszDstDir))
        PathCreatePath(pcszDstDir);
    else
    {
        // set the attribs of all the files under pcszDstDir to NORMAL so that on a reinstall,
        // ExtractFiles doesn't choke on read-only files
        SetAttribsToNormal("*.*", pcszDstDir);
    }

    pfnExtractFiles(szSrcCab, pcszDstDir, 0, NULL, NULL, 0);
}


VOID MoveFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir)
{
    // Can't use SHFileOperation to move files because on a reinstall,
    // we get an error saying that the target files already exist.
    // Workaround is to call CopyFiles and then DelFiles.

    CopyFiles(pcszSrcDir, pcszFile, pcszDstDir, TRUE);
    DelFiles(pcszFile, pcszSrcDir);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cdinst\cdinst.h ===
// CDINST.H

// macro definitions
#define REMOVE_QUOTES           0x01
#define IGNORE_QUOTES           0x02

#define MAX_BUF_LEN             (32 * 1024)         // 32K - 1 is the size limit for a section in an INF

#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')

#define PathIsFullPath(p)       ((p)[1] == ':'   &&  (p)[2] == '\\')
#define PathIsUNC(p)            ((p)[0] == '\\'  &&  (p)[1] == '\\')


// type definitions
typedef HRESULT (WINAPI * EXTRACTFILES)(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                                        LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);


// prototype declarations for functions in cdinst.cpp
BOOL EnoughDiskSpace(LPCSTR pcszSrcRootDir, LPCSTR pcszDstRootDir, LPCSTR pcszIniFile, LPDWORD pdwSpaceReq, LPDWORD pdwSpaceFree);
BOOL GetFreeDiskSpace(LPCSTR pcszDir, LPDWORD pdwFreeSpace, LPDWORD pdwFlags);
DWORD FindSpaceRequired(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir);

VOID ParseIniLine(LPSTR pszLine, LPSTR *ppszFile, LPSTR *ppszSrcDir, LPSTR *ppszDstDir);

LPSTR GetDirPath(LPCSTR pcszRootDir, LPCSTR pcszSubDir, CHAR szDirPath[], DWORD cchBuffer, LPCSTR pcszIniFile);
DWORD ReplacePlaceholders(LPCSTR pszSrc, LPCSTR pszIns, LPSTR pszBuffer, DWORD cchBuffer);

VOID SetAttribsToNormal(LPCSTR pcszFile, LPCSTR pcszDir);

VOID CopyFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, BOOL fQuiet);
VOID DelFiles(LPCSTR pcszFile, LPCSTR pcszDstDir);
VOID ExtractFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir, EXTRACTFILES pfnExtractFiles);
VOID MoveFiles(LPCSTR pcszSrcDir, LPCSTR pcszFile, LPCSTR pcszDstDir);

// prototype declarations for functions in utils.cpp
VOID ParseCmdLine(LPSTR pszCmdLine);

DWORD ReadSectionFromInf(LPCSTR pcszSecName, LPSTR *ppszBuf, PDWORD pdwBufLen, LPCSTR pcszInfName);

BOOL PathExists(LPCSTR pcszDir);
BOOL FileExists(LPCSTR pcszFileName);
DWORD FileSize(LPCSTR pcszFile);
LPSTR AddPath(LPSTR pszPath, LPCSTR pcszFileName);
BOOL PathIsUNCServer(LPCSTR pcszPath);
BOOL PathIsUNCServerShare(LPCSTR pcszPath);
BOOL PathCreatePath(LPCSTR pcszPathToCreate);

VOID ErrorMsg(UINT uStringID);
VOID ErrorMsg(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2);
INT ErrorMsg(UINT uStringID, DWORD dwParam1, DWORD dwParam2);
LPSTR FormatMessageString(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2);
LPSTR FormatMessageString(UINT uStringID, DWORD dwParam1, DWORD dwParam2);
LPSTR FormatString(LPCSTR pcszFormatString, ...);

LPSTR GetNextField(LPSTR *ppszData, LPCSTR pcszDeLims, DWORD dwFlags);
LPSTR Trim(LPSTR pszData);

LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch);
LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch);
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch);


// extern declaration of global variables
extern HINSTANCE g_hInst;
extern CHAR g_szTitle[];
extern CHAR g_szSrcDir[], g_szDstDir[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cd\setup\setup.c ===
#include <windows.h>
#include <shellapi.h>
#include <ver.h>
#include <malloc.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <dos.h>

#define IDS_FILE        1
#define IDS_VER         2
#define IDS_LOWVER      3
#define IDS_HIGHVER     4
#define IDS_OLDER       5
#define IDS_TITLE       6
#define IDS_NOSETUP     7
#define IDS_VERSION     8
#define IDS_LATESTVER   9

#define MAX_PATH 128
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define NUM_VERSION_NUM 4

HINSTANCE g_hInst;

char g_szTemp[1024];
char g_szTemp2[1024];
char g_szIExplore[128];
char g_szSetupExe[MAX_PATH];
BOOL g_fNoSetup = FALSE;

char *Res2Str(int nString)
{
    static BOOL fSet = FALSE;

    if(fSet)
    {
        LoadString(g_hInst, nString, g_szTemp, ARRAYSIZE(g_szTemp));
        fSet = FALSE;
        return(g_szTemp);
    }

    LoadString(g_hInst, nString, g_szTemp2, ARRAYSIZE(g_szTemp2));
    fSet = TRUE;
    return(g_szTemp2);
}

BOOL FileExists( LPSTR pszFile )
{
    HFILE hFile;
    OFSTRUCT ofsFile;

    hFile = OpenFile( pszFile, &ofsFile, OF_EXIST );
    if( hFile == HFILE_ERROR )
        return FALSE;

    return TRUE;
}
BOOL _PathRemoveFileSpec(LPSTR pFile)
{
    LPSTR pT;
    LPSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = AnsiNext(pT2)) {
        if (*pT2 == '\\')
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == ':') {   // skip ":\" so we don't
            if (pT2[1] =='\\')    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything
    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == '\\')) {
        // Is it just a '\'?
        if (*(pT+1) != '\0') {
            // Nope.
            *(pT+1) = '\0';
            return TRUE;    // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}

void FindSetupExeName( LPSTR szDir, LPSTR szName )
{
    lstrcpy( szName, "iesetup.exe" );
//    struct _find_t fileinfo;
//    int nRetVal = 0;
//    char szFind[MAX_PATH];
//
//    lstrcpy( szFind, szDir );
//    lstrcat( szFind, "\\*.exe" );
//
//    _dos_findfirst( szFind, 0, &fileinfo );
//
//    lstrcpy( szName, fileinfo.name );
}

void GetLanguage( LPSTR szLang, LPSTR szDir, int nSize )
{
// may need this later
//    struct _find_t fileinfo;
    int nRetVal = 0;
//    _dos_findfirst( "win31\\*.*", _A_SUBDIR, &fileinfo );
//    while( lstrlen( fileinfo.name ) != 3 && nRetVal == 0 )
//    {
//        nRetVal = _dos_findnext( &fileinfo );
//    }
//    lstrcpy( szLang, fileinfo.name );

    char szDirTemp[MAX_PATH];

    GetProfileString( "intl", "sLanguage", "eng", szLang, nSize);

    // special case english
    if( lstrcmpi( szLang, "enu" ) == 0 )
        lstrcpy( szLang, "eng" );

    // special case russian
    if(( lstrcmpi( szLang, "ukr" ) == 0 ) || ( lstrcmpi( szLang, "bel" ) == 0 ))
        lstrcpy( szLang, "rus" );

    // special case modern spanish

    if (lstrcmpi( szLang, "esn") == 0)
        lstrcpy( szLang, "esp");

    // special case french canadian

    if (lstrcmpi( szLang, "frc") == 0)
        lstrcpy( szLang, "fra");

    wsprintf( szDirTemp, "%s\\%s\\%s", szDir, szLang, (LPSTR)g_szSetupExe );

    if( !FileExists( szDirTemp ))
    {
        // special case Slovak -> Czech
        if( lstrcmpi( szLang, "sky" ) == 0 )
        {
            lstrcpy( szLang, "csy" );
            wsprintf( szDirTemp, "%s\\%s", szDir, szLang );
//            FindSetupExeName( szDirTemp, g_szSetupExe );
            wsprintf( szDirTemp, "%s\\%s\\%s", szDir, szLang, (LPSTR)g_szSetupExe );
        }
        else if( lstrcmpi( szLang, "csy" ) == 0 )
        {
            lstrcpy( szLang, "sky" );
            wsprintf( szDirTemp, "%s\\%s", szDir, szLang );
//            FindSetupExeName( szDirTemp, g_szSetupExe );
            wsprintf( szDirTemp, "%s\\%s\\%s", szDir, szLang, (LPSTR)g_szSetupExe );
        }
    }

    if( !FileExists( szDirTemp ))
    {
        struct _find_t fileinfo;
        char szFilePath[MAX_PATH];
        char szLang1[16];
        char szLang2[16];

        lstrcpy( szLang1, szLang );
        szLang1[2] = '\0';

        wsprintf( szFilePath, "%s\\*.*", szDir );

        _dos_findfirst( szFilePath, _A_SUBDIR, &fileinfo );
        lstrcpy(szLang2, fileinfo.name);
        szLang2[2] = '\0';

        while( nRetVal == 0 && lstrcmpi(szLang1, szLang2))
        {
            nRetVal = _dos_findnext( &fileinfo );
            lstrcpy(szLang2, fileinfo.name);
            szLang2[2] = '\0';
        }

        if (nRetVal == 0)
        {
            lstrcpy( szLang, fileinfo.name );
            lstrcpy( szDirTemp, szDir );
            lstrcat( szDirTemp, "\\" );
            lstrcat( szDirTemp, szLang );
            lstrcat( szDirTemp, "\\" );
            lstrcat( szDirTemp, g_szSetupExe );
        }
        else
            lstrcpy(szDirTemp, "");

    }

    if( !FileExists( szDirTemp ))
    {
        MessageBox( NULL, Res2Str( IDS_NOSETUP ), Res2Str( IDS_TITLE ), MB_OK | MB_ICONINFORMATION );
    }
//    // default to english if no other choice
//    if( !FileExists(szDirTemp) )
//    {
//        lstrcpy( szLang, "eng" );
//    }
}


void ConvertVersionStr(PSTR pszVer, WORD rwVer[])
{
    int i;
    for(i = 0; i < NUM_VERSION_NUM; i++)
        rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
        rwVer[i] = (WORD) atol(pszVer);
        pszVer = strchr(pszVer, '.');
        if (pszVer)
            pszVer++;
    }
}

// Returns:
//    -1   Ver1 < Ver2
//     0   Ver1 == Ver2
//     1   Ver1 > Ver2
// Notes:
int VersionCmp(WORD rwVer1[], WORD rwVer2[])
{
   int i;
   for(i = 0; i < NUM_VERSION_NUM; i++)
   {
      if(rwVer1[i] < rwVer2[i])
         return -1;
      if(rwVer1[i] > rwVer2[i])
         return 1;
   }
   return 0;
}

BOOL CheckVersion( LPSTR szIniFile )
{
    VS_FIXEDFILEINFO *lpVSFixedFileInfo;
    char szIExplore[MAX_PATH];
    BYTE *pVersionInfo;
    DWORD dwVerInfoSize;
    DWORD dwHandle;
    WORD rwRegVer[NUM_VERSION_NUM];
    WORD rwRegVer2[NUM_VERSION_NUM];
    char szData[32];
    char *pTemp;
    HKEY    hKey;
    
    if (RegOpenKey(HKEY_CLASSES_ROOT, "mhtmlfile\\shell\\open\\command", &hKey) != ERROR_SUCCESS)
        return FALSE;

    dwVerInfoSize = sizeof(szIExplore);
    if (RegQueryValue(hKey, NULL, szIExplore, &dwVerInfoSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return FALSE;
    }
    
    pTemp = strchr(szIExplore, ' ');
    if (pTemp)
        *pTemp = '\0';
    
    lstrcpy( g_szIExplore, szIExplore );

    // get the version information
    dwVerInfoSize = GetFileVersionInfoSize( szIExplore, &dwHandle );
    pVersionInfo = (BYTE *) malloc( (size_t)dwVerInfoSize );
    if( !pVersionInfo )
        return FALSE;

    if( !GetFileVersionInfo( szIExplore, dwHandle, dwVerInfoSize, pVersionInfo ))
    {
        free( pVersionInfo );
        return TRUE;
    }
    
    VerQueryValue( (const void FAR*)pVersionInfo, "\\", (VOID FAR* FAR*)&lpVSFixedFileInfo, (UINT FAR*)&dwVerInfoSize );
    rwRegVer[0] = HIWORD(lpVSFixedFileInfo->dwFileVersionMS);
    rwRegVer[1] = LOWORD(lpVSFixedFileInfo->dwFileVersionMS);
    rwRegVer[2] = HIWORD(lpVSFixedFileInfo->dwFileVersionLS);
    rwRegVer[3] = LOWORD(lpVSFixedFileInfo->dwFileVersionLS);

    free( pVersionInfo );
    if (LoadString(g_hInst, IDS_VERSION, szData, ARRAYSIZE(szData)) == 0)
        lstrcpy(szData, "5.0.913.2200");
    ConvertVersionStr(szData, rwRegVer2);
    
    return (VersionCmp(rwRegVer, rwRegVer2) >= 0);
}

int FAR PASCAL WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow )
{
    DWORD dwVersion;
    DWORD dwFlags;
    char szDir[MAX_PATH];
    char szTempFile[1024];
//    char szLoadLine[1024];
    char szExecFile[MAX_PATH];
    char szPage[MAX_PATH];
//    char szTemp[MAX_PATH];
    char szLang[32];

    g_hInst = hInst;

    GetModuleFileName( hInst, szDir, MAX_PATH );
    _PathRemoveFileSpec( szDir );

    if( lstrlen( szDir ) < 4 )
        szDir[2] = '\0';

    if (LoadString(g_hInst, IDS_FILE, g_szSetupExe, ARRAYSIZE(g_szSetupExe)) == 0)
        lstrcpy(g_szSetupExe, "Setup.exe");
    // check for WinNT
    dwFlags = GetWinFlags( );
    if( dwFlags & 0x4000 )
    {
        lstrcat( szDir, "\\WIN32" );
        lstrcpy( szExecFile, szDir );
        lstrcat( szExecFile, "\\IE.EXE" );
        goto execsetup;
    }

    // check for Win95 and Win31
    dwVersion = GetVersion( );
    if( HIBYTE(LOWORD(dwVersion)) == 95 )
    {
        lstrcat( szDir, "\\WIN32" );
        lstrcpy( szExecFile, szDir );
        lstrcat( szExecFile, "\\IE.EXE" );
    }
    else
    {
        lstrcat( szDir, "\\WIN16" );

        GetLanguage( szLang, szDir, ARRAYSIZE(szLang) );

        /***
        GetProfileString( "iesk", "load", "", szLoadLine, ARRAYSIZE( szLoadLine ));
        if( lstrlen( szLoadLine ) > 0 )
            WriteProfileString( "windows", "load", szLoadLine );
        else
            WriteProfileString( "windows", "load", "" );

        memset( szLoadLine, 0, ARRAYSIZE( szLoadLine ));
        ***/

        // check for IE
        GetWindowsDirectory( szTempFile, MAX_PATH );
        lstrcat( szTempFile, "\\iexplore.ini" );

        lstrcpy( szPage, szDir );
        lstrcat( szPage, "\\" );
        lstrcat( szPage, szLang );
        lstrcat( szPage, "\\BIN\\START.HTM" );

        if(CheckVersion( szTempFile ))
        {
            HINSTANCE hIEInst;

            if (FileExists(szPage))
            {
                lstrcpy( szPage, "-k -slf file:");
                lstrcat( szPage, szDir );
                lstrcat( szPage, "\\" );
                lstrcat( szPage, szLang );
                lstrcat( szPage, "\\BIN\\START.HTM" );

                hIEInst=ShellExecute( NULL, NULL, "IEXPLORE.EXE", szPage, "", SW_SHOWNORMAL );
                
                if(hIEInst <= 32) //shell execute failed
                {
                    ShellExecute( NULL, NULL, g_szIExplore, szPage, "", SW_SHOWNORMAL );                
                }
            }
            else
            {
                MessageBox( NULL, Res2Str( IDS_LATESTVER), Res2Str( IDS_TITLE ), MB_OK );
            }

            return 1;
        }
        else
        {
            char szFileName[MAX_PATH];
            int nRetVal = 0;

            if( g_fNoSetup )
                return 1;

            if (FileExists(szPage))
            {
                // write to the [ieak] section; runonc16.exe would read this in and run it
                // at the end of runonce processing (it would delete this entry after reading it in).
                GetModuleFileName( hInst, szFileName, MAX_PATH );
                WriteProfileString("ieak", "load", szFileName);

                /***
                GetProfileString( "windows", "load", "", szLoadLine, ARRAYSIZE( szLoadLine ));
                if( lstrlen( szLoadLine ) > 0 )
                {
                    WriteProfileString( "iesk", "load", szLoadLine );
                    lstrcat( szLoadLine, ";" );
                }

                lstrcat( szLoadLine, szFileName );
                WriteProfileString( "windows", "load", szLoadLine );
                ***/
            }

            lstrcpy( szExecFile, szDir );
            lstrcat( szExecFile, "\\");
            lstrcat( szExecFile, szLang );
            lstrcat( szExecFile, "\\" );
            lstrcat( szExecFile, g_szSetupExe );

        }
    }

execsetup:
    ShellExecute( NULL, NULL, szExecFile, "", szDir, SW_SHOWNORMAL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\cdinst\utils.cpp ===
#include <windows.h>
#include "cdinst.h"


VOID ParseCmdLine(LPSTR pszCmdLine)
{
    LPSTR pszCurrArg;
    LPSTR pszPtr;

    GetNextField(&pszCmdLine, "/", 0);              // point to the first argument
    while ((pszCurrArg = GetNextField(&pszCmdLine, "/", 0)) != NULL)
    {
        switch (*pszCurrArg)
        {
            case 's':
            case 'S':
                if (*++pszCurrArg == ':')
                    pszCurrArg++;

                // Source dir from where to grab the files
                if ((pszPtr = Trim(GetNextField(&pszCurrArg, ",", REMOVE_QUOTES))) != NULL)
                    lstrcpy(g_szSrcDir, pszPtr);
                else
                    *g_szSrcDir = '\0';

                break;

            case 'd':
            case 'D':
                if (*++pszCurrArg == ':')
                    pszCurrArg++;

                // Destination dir to where to copy the files
                if ((pszPtr = Trim(GetNextField(&pszCurrArg, ",", REMOVE_QUOTES))) != NULL)
                    lstrcpy(g_szDstDir, pszPtr);
                else
                    *g_szDstDir = '\0';

                break;

            default:                                // ignore these arguments
                break;
        }
    }
}


DWORD ReadSectionFromInf(LPCSTR pcszSecName, LPSTR *ppszBuf, PDWORD pdwBufLen, LPCSTR pcszInfName)
{
    DWORD dwRet;

    // set the file attrib of pcszInfName to NORMAL so that GetPrivateProfileSecion doesn't
    // barf in case pcszInfName is read only
    SetFileAttributes(pcszInfName, FILE_ATTRIBUTE_NORMAL);

    // keep allocating buffers in increasing size of 1K till the entire section is read
    *ppszBuf = NULL;
    *pdwBufLen = 1024;
    do
    {
        if (*ppszBuf != NULL)
            LocalFree(*ppszBuf);            // free the previously allocated memory

        if (*pdwBufLen == MAX_BUF_LEN)
            (*pdwBufLen)--;                   // 32K - 1 is the size limit for a section

        if ((*ppszBuf = (LPSTR) LocalAlloc(LPTR, *pdwBufLen)) == NULL)
        {
            *pdwBufLen = 0;
            return 0;
        }
    } while ((dwRet = GetPrivateProfileSection(pcszSecName, *ppszBuf, *pdwBufLen, pcszInfName)) == *pdwBufLen - 2  &&
             (*pdwBufLen += 1024) <= MAX_BUF_LEN);

    return dwRet;
}


BOOL PathExists(LPCSTR pcszDir)
{
    DWORD dwAttrib = GetFileAttributes(pcszDir);

    return (dwAttrib != (DWORD) -1)  &&  (dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL FileExists(LPCSTR pcszFileName)
{
    DWORD dwAttrib = GetFileAttributes(pcszFileName);

    if (dwAttrib == (DWORD) -1)
        return FALSE;

    return !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}


DWORD FileSize(LPCSTR pcszFile)
{
    DWORD dwFileSize = 0;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile;

    if (pcszFile == NULL  ||  *pcszFile == '\0')
        return dwFileSize;

    if ((hFile = FindFirstFile(pcszFile, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        // assumption here is that the size of the file doesn't exceed 4 gigs
        dwFileSize = FindFileData.nFileSizeLow;
        FindClose(hFile);
    }

    return dwFileSize;
}


LPSTR AddPath(LPSTR pszPath, LPCSTR pcszFileName)
{
    LPSTR pszPtr;

    if (pszPath == NULL)
        return NULL;

    pszPtr = pszPath + lstrlen(pszPath);
    if (pszPtr > pszPath  &&  *CharPrev(pszPath, pszPtr) != '\\')
        *pszPtr++ = '\\';

    if (pcszFileName != NULL)
        lstrcpy(pszPtr, pcszFileName);
    else
        *pszPtr = '\0';

    return pszPath;
}


BOOL PathIsUNCServer(LPCSTR pcszPath)
{
    if (PathIsUNC(pcszPath))
    {
        int i = 0;

        for ( ;  pcszPath != NULL && *pcszPath;  pcszPath = CharNext(pcszPath))
            if (*pcszPath == '\\')
                i++;

       return i == 2;
    }

    return FALSE;
}


BOOL PathIsUNCServerShare(LPCSTR pcszPath)
{
    if (PathIsUNC(pcszPath))
    {
        int i = 0;

        for ( ;  pcszPath != NULL && *pcszPath;  pcszPath = CharNext(pcszPath))
            if (*pcszPath == '\\')
                i++;

       return i == 3;
    }

    return FALSE;
}


BOOL PathCreatePath(LPCSTR pcszPathToCreate)
{
    CHAR szPath[MAX_PATH];
    LPSTR pszPtr;

    if (pcszPathToCreate == NULL  ||  lstrlen(pcszPathToCreate) <= 3)
        return FALSE;

    // eliminate relative paths
    if (!PathIsFullPath(pcszPathToCreate)  &&  !PathIsUNC(pcszPathToCreate))
        return FALSE;

    if (PathIsUNCServer(pcszPathToCreate)  ||  PathIsUNCServerShare(pcszPathToCreate))
        return FALSE;

    lstrcpy(szPath, pcszPathToCreate);

    // chop off the trailing backslash, if it exists
    pszPtr = CharPrev(szPath, szPath + lstrlen(szPath));
    if (*pszPtr == '\\')
        *pszPtr = '\0';

    // if it's a UNC path, seek up to the first dir after the share name
    if (PathIsUNC(szPath))
    {
        INT i;

        pszPtr = &szPath[2];

        for (i = 0;  i < 2;  i++)
            for ( ;  *pszPtr != '\\';  pszPtr = CharNext(pszPtr))
                ;

        pszPtr = CharNext(pszPtr);
    }
    else        // otherwise, just point to the beginning of the first dir
        pszPtr = &szPath[3];

    for ( ;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        CHAR ch;

        // skip the non-backslash chars
        while (*pszPtr  &&  *pszPtr != '\\')
            pszPtr = CharNext(pszPtr);

        // save the current char
        ch = *pszPtr;

        *pszPtr = '\0';
        if (GetFileAttributes(szPath) == 0xFFFFFFFF)        // dir doesn't exist
            if (!CreateDirectory(szPath, NULL))
                return FALSE;

        // restore the current char
        *pszPtr = ch;
    }

    return TRUE;
}


VOID ErrorMsg(UINT uStringID)
{
    ErrorMsg(uStringID, "", "");
}


VOID ErrorMsg(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2)
{
    LPSTR pszTextString;

    pszTextString = FormatMessageString(uStringID, pcszParam1, pcszParam2);

    MessageBox(NULL, (pszTextString != NULL) ? pszTextString : "", g_szTitle, MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);

    if (pszTextString != NULL)
        LocalFree(pszTextString);
}


INT ErrorMsg(UINT uStringID, DWORD dwParam1, DWORD dwParam2)
{
    INT iRet;
    LPSTR pszTextString;

    pszTextString = FormatMessageString(uStringID, dwParam1, dwParam2);

    iRet = MessageBox(NULL, (pszTextString != NULL) ? pszTextString : "", g_szTitle, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 | MB_SETFOREGROUND);

    if (pszTextString != NULL)
        LocalFree(pszTextString);

    return iRet;
}


LPSTR FormatMessageString(UINT uStringID, LPCSTR pcszParam1, LPCSTR pcszParam2)
{
    CHAR szBuf[512];

    if (LoadString(g_hInst, uStringID, szBuf, sizeof(szBuf)))
    {
        LPSTR pszTextString;

        if ((pszTextString = FormatString(szBuf, pcszParam1, pcszParam2)) != NULL)
            return pszTextString;
    }

    return NULL;
}


LPSTR FormatMessageString(UINT uStringID, DWORD dwParam1, DWORD dwParam2)
{
    CHAR szBuf[512];

    if (LoadString(g_hInst, uStringID, szBuf, sizeof(szBuf)))
    {
        LPSTR pszTextString;

        if ((pszTextString = FormatString(szBuf, dwParam1, dwParam2)) != NULL)
            return pszTextString;
    }

    return NULL;
}


LPSTR FormatString(LPCSTR pcszFormatString, ...)
{
    va_list vaArgs;
    LPSTR pszOutString = NULL;

    va_start(vaArgs, pcszFormatString);
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                  (LPCVOID) pcszFormatString, 0, 0, (PSTR) &pszOutString, 0, &vaArgs);
    va_end(vaArgs);

    return pszOutString;
}


LPSTR GetNextField(LPSTR *ppszData, LPCSTR pcszDeLims, DWORD dwFlags)
// If (dwFlags & IGNORE_QUOTES) is TRUE, then look for any char in pcszDeLims in *ppszData.  If found,
// replace it with the '\0' char and set *ppszData to point to the beginning of the next field and return
// pointer to current field.
//
// If (dwFlags & IGNORE_QUOTES) is FALSE, then look for any char in pcszDeLims outside of balanced quoted sub-strings
// in *ppszData.  If found, replace it with the '\0' char and set *ppszData to point to the beginning of
// the next field and return pointer to current field.
//
// If (dwFlags & REMOVE_QUOTES) is TRUE, then remove the surrounding quotes and replace two consecutive quotes by one.
//
// NOTE: If IGNORE_QUOTES and REMOVE_QUOTES are both specified, then IGNORE_QUOTES takes precedence over REMOVE_QUOTES.
//
// If you just want to remove the quotes from a string, call this function as
// GetNextField(&pszData, "\"" or "'" or "", REMOVE_QUOTES).
//
// If you call this function as GetNextField(&pszData, "\"" or "'" or "", 0), you will get back the
// entire pszData as the field.
//
{
    LPSTR pszRetPtr, pszPtr;
    BOOL fWithinQuotes = FALSE, fRemoveQuote;
    CHAR chQuote;

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == '\0')
        return NULL;

    for (pszRetPtr = pszPtr = *ppszData;  *pszPtr;  pszPtr = CharNext(pszPtr))
    {
        if (!(dwFlags & IGNORE_QUOTES)  &&  (*pszPtr == '"'  ||  *pszPtr == '\''))
        {
            fRemoveQuote = FALSE;

            if (*pszPtr == *(pszPtr + 1))           // two consecutive quotes become one
            {
                pszPtr++;

                if (dwFlags & REMOVE_QUOTES)
                    fRemoveQuote = TRUE;
                else
                {
                    // if pcszDeLims is '"' or '\'', then *pszPtr == pcszDeLims would
                    // be TRUE and we would break out of the loop against the design specs;
                    // to prevent this just continue
                    continue;
                }
            }
            else if (!fWithinQuotes)
            {
                fWithinQuotes = TRUE;
                chQuote = *pszPtr;                  // save the quote char

                fRemoveQuote = dwFlags & REMOVE_QUOTES;
            }
            else
            {
                if (*pszPtr == chQuote)             // match the correct quote char
                {
                    fWithinQuotes = FALSE;
                    fRemoveQuote = dwFlags & REMOVE_QUOTES;
                }
            }

            if (fRemoveQuote)
            {
                // shift the entire string one char to the left to get rid of the quote char
                MoveMemory(pszPtr, pszPtr + 1, lstrlen(pszPtr));
            }
        }

        // BUGBUG: Is type casting pszPtr to UNALIGNED necessary? -- copied it from ANSIStrChr
        // check if pszPtr is pointing to one of the chars in pcszDeLims
        if (!fWithinQuotes  &&
            ANSIStrChr(pcszDeLims, (WORD) (IsDBCSLeadByte(*pszPtr) ? *((UNALIGNED WORD *) pszPtr) : *pszPtr)) != NULL)
            break;
    }

    // NOTE: if fWithinQuotes is TRUE here, then we have an unbalanced quoted string; but we don't care!
    //       the entire string after the beginning quote becomes the field

    if (*pszPtr)                                    // pszPtr is pointing to a char in pcszDeLims
    {
        *ppszData = CharNext(pszPtr);               // save the pointer to the beginning of next field in *ppszData
        *pszPtr = '\0';                             // replace the DeLim char with the '\0' char
    }
    else
        *ppszData = pszPtr;                         // we have reached the end of the string; next call to this function
                                                    // would return NULL

    return pszRetPtr;
}


LPSTR Trim(LPSTR pszData)
// Trim the leading and trailing white space chars in pszData
{
    LPSTR pszRetPtr;

    if (pszData == NULL)
        return NULL;

    // trim the leading white space chars
    for ( ;  *pszData;  pszData = CharNext(pszData))
        if (!IsSpace(*pszData))
            break;

    // save the return ptr
    pszRetPtr = pszData;

    // go to the end and start trimming the trailing white space chars
    pszData += lstrlen(pszData);
    while ((pszData = CharPrev(pszRetPtr, pszData)) != pszRetPtr)
        if (!IsSpace(*pszData))
            break;

    if (*pszData)
    {
        pszData = CharNext(pszData);
        *pszData = '\0';
    }

    return pszRetPtr;
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}


// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\channels.h ===
#ifndef __CHANNELS_H_
#define __CHANNELS_H_

#include <wininet.h>

typedef struct tag_channelA
{
    CHAR szTitle[MAX_PATH];
    CHAR szWebUrl[INTERNET_MAX_URL_LENGTH];
    CHAR szPreUrlPath[MAX_PATH];
    CHAR szIcon[MAX_PATH];
    CHAR szLogo[MAX_PATH];
    BOOL fCategory;
    BOOL fOffline;
    HWND hDlg;
} CHANNELA, *PCHANNELA;

typedef struct tag_channelW
{
    WCHAR szTitle[MAX_PATH];
    WCHAR szWebUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR szPreUrlPath[MAX_PATH];
    WCHAR szIcon[MAX_PATH];
    WCHAR szLogo[MAX_PATH];
    BOOL fCategory;
    BOOL fOffline;
    HWND hDlg;
} CHANNELW, *PCHANNELW;

// TCHAR mappings

#ifdef UNICODE

#define CHANNEL                 CHANNELW
#define PCHANNEL                PCHANNELW

#else

#define CHANNEL                 CHANNELA
#define PCHANNEL                PCHANNELA

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\adm.h ===
#ifndef _ADM_H_
#define _ADM_H_

class CDscrWnd
{
private:
    HWND  hWndMain;
    HWND  hWndDscrTitle;
    HWND  hWndDscrText;
    HFONT hFontDscrTitle;

public:
    CDscrWnd();
    ~CDscrWnd();
    void Create(HWND hWndParent, HWND hWndInsertAfter, int nXPos, int nYPos, int nWidth, int nHeight);
    void SetText(LPCTSTR pcszTitle, LPCTSTR pcszText, BOOL fUpdateWindowState = TRUE);
    void ShowWindow(BOOL fShow);
    void GetRect(RECT* lpRect);
    void MoveWindow(int nXPos, int nYPos, int nWidth, int nHeight);
};

#endif // _ADM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\btoolbar.h ===
#ifndef _BTOOLBAR_H_
#define _BTOOLBAR_H_

#include <wininet.h>

typedef struct tag_btoolbarA
{
    CHAR szCaption[MAX_BTOOLBAR_TEXT_LENGTH+1];
    CHAR szAction[INTERNET_MAX_URL_LENGTH];
    CHAR szIcon[MAX_PATH];
    CHAR szHotIcon[MAX_PATH];
//  TCHAR szToolTipText[MAX_PATH];   // disable for IE5 since not implemented in browser
    BOOL fShow;
    BOOL fDeleted;
} BTOOLBARA, *PBTOOLBARA;

typedef struct tag_btoolbarW
{
    WCHAR szCaption[MAX_BTOOLBAR_TEXT_LENGTH+1];
    WCHAR szAction[INTERNET_MAX_URL_LENGTH];
    WCHAR szIcon[MAX_PATH];
    WCHAR szHotIcon[MAX_PATH];
//  TCHAR szToolTipText[MAX_PATH];   // disable for IE5 since not implemented in browser
    BOOL fShow;
    BOOL fDeleted;
} BTOOLBARW, *PBTOOLBARW;

// TCHAR mappings

#ifdef UNICODE

#define BTOOLBAR                BTOOLBARW
#define PBTOOLBAR               PBTOOLBARW

#else

#define BTOOLBAR                BTOOLBARA
#define PBTOOLBAR               PBTOOLBARA

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\adm.cpp ===
// adm.cpp

#include "precomp.h"
#include "admparse.h"
#include "adm.h"

typedef struct Category
{
    LPTSTR pszName;
    HWND hWnd;
    HKEY hKeyClass;
    LPVOID pData;
	BOOL fRSoPMode;
} ADMCategory;

typedef struct ADM
{
    LPTSTR pszName;
    TCHAR  szFileName[MAX_PATH];
    DWORD  dwAdm;
    LPVOID pData;
} ADMFile;

#define ADM_DSCRLEN         32767
#define ADM_DSCRLINELEN     100
#define ADM_TITLELEN        100

TCHAR g_szLogFileName[MAX_PATH];
HTREEITEM g_hPolicyRootItem = NULL; // only used by profile manager
int g_ADMClose, g_ADMCategory;

#define GetFirstPolicyItem(hTreeView)    ((g_hPolicyRootItem != NULL) ? TreeView_GetChild(hTreeView, g_hPolicyRootItem) : TreeView_GetRoot(hTreeView))
#define PolicyRoot()    ((g_hPolicyRootItem != NULL) ? g_hPolicyRootItem : NULL)
#define IsWizard()      ((g_hPolicyRootItem == NULL) ? TRUE : FALSE)

// private helper functions
static HFONT getBoldFont(HWND hWnd);
static BOOL isADMFileVisibleHelper(LPCTSTR pcszFileName, int nRole, DWORD dwPlatformId);
static BOOL loadADMFilesHelper(HWND hTreeView, HTREEITEM hPolicyRootItem,
                               LPCTSTR pcszADMFilePath, LPCTSTR pcszWorkDir,
                               DWORD dwPlatformId, int nRole,
                               int nIconADMClose, int nIconADMCategory);
static void deleteADMItemHelper(HWND hTreeView, HTREEITEM hParentItem, LPCTSTR pcszWorkDir,
                                LPCTSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave);
static void deleteADMItemsHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile,
                                 BOOL bSave);
static void getADMDescriptionTitle(LPCTSTR pcszFileName, LPTSTR pszDscrTitle);
static void getADMDescription(LPCTSTR pcszFileName, LPTSTR pszDscr);
static void importADMFileHelper(HWND hMainWnd, HWND hTreeView, LPCTSTR pcszADMFilePath,
                                LPCTSTR pcszWorkDir, int nRole, LPCTSTR pcszInsFile);
static void resetAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, BOOL bReset);
static void saveAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile);
static BOOL CALLBACK logDialogProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM);
static BOOL getAdmFileListHelper(LPRESULTITEM* pResultItems, int* pnResultItems, int nRole);
static HTREEITEM addADMItemHelper(HWND hTreeView, LPCTSTR pcszADMFilePath, LPCTSTR pcszFileName,
                                  LPCTSTR pcszWorkDir, int nRole, BSTR bstrRSoPNamespace);

void WINAPI CreateADMWindow(HWND hOwner, HWND hWndInsertAfter, int nXPos, int nYPos,
                            int nWidth, int nHeight)
{
    CDscrWnd* pDscrWnd = new CDscrWnd;
    if (pDscrWnd != NULL)
    {
        SetWindowLongPtr(hOwner, GWLP_USERDATA, (LONG_PTR)pDscrWnd);
        pDscrWnd->Create(GetParent(hOwner), hWndInsertAfter, nXPos, nYPos, nWidth, nHeight);
    }
}

void WINAPI ShowADMWindow(HWND hOwner, BOOL fShow)
{
    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->ShowWindow(fShow);
}

void WINAPI MoveADMWindow(HWND hOwner, int nXPos, int nYPos, int nWidth, int nHeight)
{
    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->MoveWindow(nXPos, nYPos, nWidth, nHeight);
}

void WINAPI SetADMWindowTextA(HWND hOwner, LPCSTR pcszTitle, LPCSTR pcszText,
                              BOOL fUpdateWindowState /* = TRUE */)
{
    USES_CONVERSION;

    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->SetText(A2CT(pcszTitle), A2CT(pcszText), fUpdateWindowState);
}

void WINAPI SetADMWindowTextW(HWND hOwner, LPCWSTR pcwszTitle, LPCWSTR pcwszText,
                              BOOL fUpdateWindowState /* = TRUE */)
{
    USES_CONVERSION;

    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
        pDscrWnd->SetText(W2CT(pcwszTitle), W2CT(pcwszText), fUpdateWindowState);
}

void WINAPI DestroyADMWindow(HWND hOwner)
{
    CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hOwner, GWLP_USERDATA);
    
    if (pDscrWnd != NULL)
    {
        delete pDscrWnd;
        SetWindowLongPtr(hOwner, GWLP_USERDATA, 0L);
    }
}

BOOL WINAPI IsADMFileVisibleA(LPCSTR pcszFileName, int nRole, DWORD dwPlatformId)
{
    USES_CONVERSION;

    return isADMFileVisibleHelper(A2CT(pcszFileName), nRole, dwPlatformId);
}

BOOL WINAPI IsADMFileVisibleW(LPCWSTR pcwszFileName, int nRole, DWORD dwPlatformId)
{
    USES_CONVERSION;

    return isADMFileVisibleHelper(W2CT(pcwszFileName), nRole, dwPlatformId);
}

BOOL WINAPI LoadADMFilesA(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCSTR pcszADMFilePath,
                          LPCSTR pcszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory)
{
    USES_CONVERSION;

    return loadADMFilesHelper(hTreeView, hPolicyRootItem, A2CT(pcszADMFilePath),
        A2CT(pcszWorkDir), dwPlatformId, nRole, nIconADMClose, nIconADMCategory);
}

BOOL WINAPI LoadADMFilesW(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCWSTR pcwszADMFilePath,
                          LPCWSTR pcwszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory)
{
    USES_CONVERSION;

    return loadADMFilesHelper(hTreeView, hPolicyRootItem, W2CT(pcwszADMFilePath),
        W2CT(pcwszWorkDir), dwPlatformId, nRole, nIconADMClose, nIconADMCategory);
}

void WINAPI DeleteADMItemA(HWND hTreeView, HTREEITEM hParentItem, LPCSTR pcszWorkDir,
                           LPCSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemHelper(hTreeView, hParentItem, A2CT(pcszWorkDir), A2CT(pcszInsFile),
        bDeleteFile, bSave);
}

void WINAPI DeleteADMItemW(HWND hTreeView, HTREEITEM hParentItem, LPCWSTR pcwszWorkDir,
                           LPCWSTR pcwszInsFile, BOOL bDeleteFile, BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemHelper(hTreeView, hParentItem, W2CT(pcwszWorkDir), W2CT(pcwszInsFile),
        bDeleteFile, bSave);
}

void WINAPI DeleteADMItemsA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile,
                            BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemsHelper(hTreeView, A2CT(pcszWorkDir), A2CT(pcszInsFile), bSave);
}

void WINAPI DeleteADMItemsW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile,
                            BOOL bSave)
{
    USES_CONVERSION;

    deleteADMItemsHelper(hTreeView, W2CT(pcwszWorkDir), W2CT(pcwszInsFile), bSave);
}

// Displays the description of the adm file or displays the category window
// depending on whether the selected item was an ADMFile Item or a category item.
void WINAPI DisplayADMItem(HWND hWnd, HWND hTreeView, LPTVITEM lpSelectedItem,
                           BOOL fShowDisabled)
{
    TV_ITEM tvitem;
    HWND hAdmWnd = NULL;
    RECT rect;
    RECT wndRect;
    HTREEITEM hParentItem = TreeView_GetParent(hTreeView, lpSelectedItem->hItem);
    int nWidth, nHeight;
    TCHAR szDscrTitle[ADM_TITLELEN];
    TCHAR szDscr[ADM_DSCRLEN];
    ADMFile* pADMFile;

    if(hParentItem != PolicyRoot())
    {   // item is a category
        ShowADMWindow(hTreeView, FALSE);
        if(lpSelectedItem->lParam != NULL)
        {
            ADMCategory* pADMCategory;

            tvitem.mask = TVIF_PARAM;
            tvitem.hItem = hParentItem;
            TreeView_GetItem(hTreeView, &tvitem);

            // get the cooridnates to display the window
            // the coordinates are the same as the static instruction window
            GetWindowRect(hWnd, &wndRect);

            if(!IsWizard())
            {
                wndRect.left += GetSystemMetrics(SM_CXFIXEDFRAME);
                wndRect.top += (GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYMENU) +
                                GetSystemMetrics(SM_CYFIXEDFRAME));
            }

            CDscrWnd* pDscrWnd = (CDscrWnd*)GetWindowLongPtr(hTreeView, GWLP_USERDATA);
            if (pDscrWnd != NULL)
            {
                pDscrWnd->GetRect(&rect);
                
                rect.right = (rect.left - wndRect.left) + (rect.right - rect.left);
                rect.bottom = (rect.top - wndRect.top) + (rect.bottom - rect.top);
                rect.left = rect.left - wndRect.left;
                rect.top = rect.top - wndRect.top;
            }
            else
            {
                RECT rectTreeView;

                GetWindowRect(hTreeView, &rectTreeView);

                rect.left = rectTreeView.right - wndRect.left + 7;
                rect.top = rectTreeView.top - wndRect.top + 2;
                rect.right = (wndRect.right -  wndRect.left - 7 -
                               ((!IsWizard()) ? GetSystemMetrics(SM_CXFIXEDFRAME) : 0));
                rect.bottom = rect.top + rectTreeView.bottom - rectTreeView.top - 4;
            }

            nWidth = rect.right - rect.left;
            nHeight = rect.bottom - rect.top;

            pADMFile = (ADMFile*)tvitem.lParam;
            pADMCategory = (ADMCategory*)lpSelectedItem->lParam;

            // Display the window associated with the item/category
            CreateAdmUi(pADMFile->dwAdm, hWnd, rect.left, rect.top, nWidth, nHeight,
                WS_TABSTOP, 0, pADMCategory->pszName, pADMCategory->hKeyClass, &hAdmWnd,
                pADMFile->pData, &pADMCategory->pData, pADMCategory->fRSoPMode);
            pADMCategory->hWnd = hAdmWnd;

            if(fShowDisabled)
                EnableWindow(hAdmWnd, FALSE);
            else
                EnableWindow(hAdmWnd, TRUE);
        }
    }
    else
    {   // item is a adm file
        ShowADMWindow(hTreeView, TRUE);
        ZeroMemory(szDscrTitle, ADM_TITLELEN);
        ZeroMemory(szDscr, ADM_DSCRLEN);

        if(lpSelectedItem->lParam != NULL)
        {
            pADMFile = (ADMFile*)lpSelectedItem->lParam;
            getADMDescriptionTitle(pADMFile->szFileName, szDscrTitle);
            getADMDescription(pADMFile->szFileName, szDscr);
        }
        else
        {
            if(!IsWizard())
            {
                LoadString(g_hInst, IDS_POLICYBRANCHTITLE, szDscrTitle, ADM_TITLELEN);
                LoadString(g_hInst, IDS_POLICYBRANCHTEXT, szDscr, ADM_DSCRLEN);
            }
        }
        SetADMWindowText(hTreeView, szDscrTitle, szDscr);
    }
}

// Displays an ADM file description or category window depending
// on the type of the selected item
void WINAPI SelectADMItem(HWND hWnd, HWND hTreeView, LPTVITEM lpTVItem,
                          BOOL bSelect, BOOL fShowDisabled)
{
    HTREEITEM hParentItem;
    TCHAR szDscrTitle[ADM_TITLELEN];
    TCHAR szDscr[ADM_DSCRLEN];

    hParentItem = TreeView_GetParent(hTreeView, lpTVItem->hItem);

    if(bSelect == FALSE)
    {
        // if the previously selected item was a category item,
        // save the category information and destroy the window
        // associated with that category
        if(hParentItem != g_hPolicyRootItem)
        {
            if(lpTVItem->lParam != NULL)
                SaveADMItem(hTreeView, lpTVItem, ITEM_SAVE | ITEM_DESTROY);
        }
        else
            ShowADMWindow(hTreeView, FALSE);
    }
    else
    {
        if(hParentItem == NULL)
        {
            LoadString(g_hInst, IDS_POLICYBRANCHTITLE, szDscrTitle, ADM_TITLELEN);
            LoadString(g_hInst, IDS_POLICYBRANCHTEXT, szDscr, ADM_DSCRLEN);
            SetADMWindowText(hTreeView, szDscrTitle, szDscr);
            return;
        }
        // display the information for the newly selected item
        DisplayADMItem(hWnd, hTreeView, lpTVItem, fShowDisabled);
    }
}

void WINAPI ImportADMFileA(HWND hMainWnd, HWND hTreeView, LPCSTR pcszADMFilePath,
                           LPCSTR pcszWorkDir, int nRole, LPCSTR pcszInsFile)
{
    USES_CONVERSION;

    importADMFileHelper(hMainWnd, hTreeView, A2CT(pcszADMFilePath), A2CT(pcszWorkDir),
        nRole, A2CT(pcszInsFile));
}

void WINAPI ImportADMFileW(HWND hMainWnd, HWND hTreeView, LPCWSTR pcwszADMFilePath,
                           LPCWSTR pcwszWorkDir, int nRole, LPCWSTR pcwszInsFile)
{
    USES_CONVERSION;

    importADMFileHelper(hMainWnd, hTreeView, W2CT(pcwszADMFilePath), W2CT(pcwszWorkDir),
        nRole, W2CT(pcwszInsFile));
}


void WINAPI CheckForDupKeys(HWND hMainWnd, HWND hTreeView, HTREEITEM hItem,
                            BOOL bDispSuccessMsg)
{
    TV_ITEM tvitem;
    TV_ITEM tvitem1;
    HANDLE hFile;
    HRESULT hResult;
    TCHAR szMessage[MAX_PATH];
    BOOL bClearLog = TRUE;
    HTREEITEM hPolicyItem = GetFirstPolicyItem(hTreeView);
    TCHAR szRoot[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    tvitem.mask = TVIF_PARAM;
    tvitem.hItem = hItem;
    TreeView_GetItem(hTreeView, &tvitem);

    LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
    if(ISNULL(g_szLogFileName))
    {
        LPTSTR pLastSlash;
        DWORD dwSize = sizeof(szRoot);

        GetModuleFileName(GetModuleHandle(NULL), szRoot, MAX_PATH);
        if(ISNULL(szRoot))
            SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEAK6WIZ.EXE"), NULL, NULL, (LPVOID) szRoot, &dwSize);
        if(ISNONNULL(szRoot))
        {
            pLastSlash = StrRChr(szRoot, NULL, TEXT('\\'));
            if (pLastSlash)
                *(++pLastSlash) = 0;
            CharUpper(szRoot);
        }
        wnsprintf(g_szLogFileName, ARRAYSIZE(g_szLogFileName), TEXT("%sadmlog.txt"), szRoot);
    }

    do
    {
        tvitem1.mask = TVIF_PARAM;
        tvitem1.hItem = hPolicyItem;
        TreeView_GetItem(hTreeView, &tvitem1);

        hResult = CheckDuplicateKeys(((ADMFile*)tvitem.lParam)->dwAdm, ((ADMFile*)tvitem1.lParam)->dwAdm,
                                    g_szLogFileName, bClearLog);
        if(hResult != S_OK)
        {
            if(GetLastError() == STATUS_NO_MEMORY)
            {
                LoadString(g_hInst, IDS_MEMORY_ERROR, szMessage, ARRAYSIZE(szMessage));
            }
            else if(GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                LoadString(g_hInst, IDS_FILE_ERROR, szMessage, ARRAYSIZE(szMessage));
            }
            MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
            return;
        }
        bClearLog = FALSE;
    }while((hPolicyItem = TreeView_GetNextSibling(hTreeView, hPolicyItem)) != NULL); // get next item

    hFile = CreateFile( g_szLogFileName, GENERIC_READ, FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        LoadString(g_hInst, IDS_NO_DUPLICATEKEYS, szMessage, ARRAYSIZE(szMessage));
        MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
        return;
    }

    if(GetFileSize( hFile, NULL ) == 0)
    {
        CloseHandle(hFile);
        if(bDispSuccessMsg)
        {
            LoadString(g_hInst, IDS_NO_DUPLICATEKEYS, szMessage, ARRAYSIZE(szMessage));
            MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
        }
    }
    else
    {
        CloseHandle(hFile);

        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ERRORLOG), hMainWnd, (DLGPROC) logDialogProc);
    }
    SetFocus(hMainWnd);
}

void WINAPI ResetAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, BOOL bReset)
{
    USES_CONVERSION;

    resetAdmFilesHelper(hTreeView, A2CT(pcszWorkDir), bReset);
}

void WINAPI ResetAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, BOOL bReset)
{
    USES_CONVERSION;

    resetAdmFilesHelper(hTreeView, W2CT(pcwszWorkDir), bReset);
}

void WINAPI SaveAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile)
{
    USES_CONVERSION;

    saveAdmFilesHelper(hTreeView, A2CT(pcszWorkDir), A2CT(pcszInsFile));
}

void WINAPI SaveAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile)
{
    USES_CONVERSION;

    saveAdmFilesHelper(hTreeView, W2CT(pcwszWorkDir), W2CT(pcwszInsFile));
}

BOOL WINAPI CanDeleteADM(HWND hTreeView, HTREEITEM hItem)
{
    TV_ITEM tvitem;
    int nDeleteLock = 0;

    tvitem.mask = TVIF_PARAM;
    tvitem.hItem = hItem;
    TreeView_GetItem(hTreeView, &tvitem);
    if(tvitem.lParam != NULL)
    {
        nDeleteLock = GetPrivateProfileInt(TEXT("IEAK"), TEXT("Lock"), 0,
                                           ((ADMFile*)tvitem.lParam)->szFileName);
    }
    return (BOOL) !nDeleteLock;
}

HWND WINAPI GetAdmWindowHandle(HWND hTreeView, HTREEITEM hItem)
{
    TV_ITEM tvitem;

    tvitem.mask = TVIF_PARAM;
    tvitem.hItem = hItem;
    if (TreeView_GetItem(hTreeView, &tvitem) == TRUE)
        return ((ADMCategory*)tvitem.lParam)->hWnd;
    else
        return NULL;
}

void WINAPI SaveADMItem(HWND hTreeView, LPTVITEM lpTVItem, DWORD dwFlags)
{
    if (lpTVItem != NULL && lpTVItem->lParam != NULL)
    {
        TVITEM tvitem;

        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = TreeView_GetParent(hTreeView, lpTVItem->hItem);
        TreeView_GetItem(hTreeView, &tvitem);

        if (dwFlags)
        {
            DWORD  dwAdmFlags = 0;
            ADMFile* pADMFile = (ADMFile*)tvitem.lParam;
            ADMCategory* pADMCategory = (ADMCategory*)lpTVItem->lParam;

            if (pADMCategory != NULL)
            {
                if (HasFlag(dwFlags, ITEM_SAVE))
                    dwAdmFlags |= ADM_SAVE;
                if (HasFlag(dwFlags, ITEM_DESTROY))
                    dwAdmFlags |= ADM_DESTROY;
                AdmSaveData(pADMFile->dwAdm, pADMFile->pData, pADMCategory->pData, dwAdmFlags);

                if (HasFlag(dwFlags, ITEM_DESTROY))
                {
                    DestroyWindow(pADMCategory->hWnd);
                    pADMCategory->hWnd = NULL;
                    pADMCategory->pData = NULL;
                }
            }
        }
    }
}

BOOL WINAPI GetAdmFileListA(LPRESULTITEMA* pResultItemsArrayA, int* pnResultItems, int nRole)
{
    LPRESULTITEM pResultItemArray = NULL;
    BOOL fRet;

    fRet = getAdmFileListHelper(&pResultItemArray, pnResultItems, nRole);

    if (pResultItemArray != NULL)
    {
        int i;

        if ((i = *pnResultItems) != 0)
        {
            if ((*pResultItemsArrayA = (LPRESULTITEMA)CoTaskMemAlloc(i * sizeof(RESULTITEMA))) != NULL)
            {
                for (i--; i >= 0; i--)
                {
                    // must used StrLen manually here to figure out how many bytes to allocate!
                    
                    if (pResultItemArray[i].pszName != NULL)
                        (*pResultItemsArrayA)[i].pszName = 
                            (LPSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszName)+1)*2);
                    if (pResultItemArray[i].pszDesc != NULL)
                        (*pResultItemsArrayA)[i].pszDesc = 
                            (LPSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszDesc)+1)*2);
                    ResultItemT2A(&pResultItemArray[i], &(*pResultItemsArrayA)[i]);
                    if (pResultItemArray[i].pszName != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszName);
                    if (pResultItemArray[i].pszDesc != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszDesc);
                }
            }
        }

        CoTaskMemFree(pResultItemArray);
    }

    return fRet;
}

BOOL WINAPI GetAdmFileListW(LPRESULTITEMW* pResultItemsArrayW, int* pnResultItems, int nRole)
{
    LPRESULTITEM pResultItemArray = NULL;
    BOOL fRet;

    fRet = getAdmFileListHelper(&pResultItemArray, pnResultItems, nRole);

    if (pResultItemArray != NULL)
    {
        int i;

        if ((i = *pnResultItems) != 0)
        {
            if ((*pResultItemsArrayW = (LPRESULTITEMW)CoTaskMemAlloc(i * sizeof(RESULTITEMW))) != NULL)
            {
                for (i--; i >= 0; i--)
                {
                    // must used StrLen manually here to figure out how many bytes to allocate!
                    
                    if (pResultItemArray[i].pszName != NULL)
                        (*pResultItemsArrayW)[i].pszName = 
                            (LPWSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszName)+1) * sizeof(WCHAR));
                    if (pResultItemArray[i].pszDesc != NULL)
                        (*pResultItemsArrayW)[i].pszDesc = 
                            (LPWSTR)CoTaskMemAlloc((StrLen(pResultItemArray[i].pszDesc)+1) * sizeof(WCHAR));
                    ResultItemT2W(&pResultItemArray[i], &(*pResultItemsArrayW)[i]); 
                    if (pResultItemArray[i].pszName != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszName);
                    if (pResultItemArray[i].pszDesc != NULL)
                        CoTaskMemFree(pResultItemArray[i].pszDesc);
                }
            }
        }

        CoTaskMemFree(pResultItemArray);
    }

    return fRet;
}

HTREEITEM WINAPI AddADMItemA(HWND hTreeView, LPCSTR pcszADMFilePath, LPCSTR pcszFileName,
                            LPCSTR pcszWorkDir, int nRole, BSTR bstrRSOPNamespace)
{
    USES_CONVERSION;

    return addADMItemHelper(hTreeView, A2CT(pcszADMFilePath), A2CT(pcszFileName), 
        A2CT(pcszWorkDir), nRole, bstrRSOPNamespace);
}

HTREEITEM WINAPI AddADMItemW(HWND hTreeView, LPCWSTR pcwszADMFilePath, LPCWSTR pcwszFileName,
                            LPCWSTR pcwszWorkDir, int nRole, BSTR bstrRSOPNamespace)
{
    USES_CONVERSION;

    return addADMItemHelper(hTreeView, W2CT(pcwszADMFilePath), W2CT(pcwszFileName), 
        W2CT(pcwszWorkDir), nRole, bstrRSOPNamespace);
}

// Converts the .adm filename to .inf filename and concatenates the
// appropriate path for the .inf file
static void getInfFileName(LPCTSTR pcszADMFileName, LPTSTR pszInfFileName, DWORD cchInfFile, LPCTSTR pcszWorkDir)
{
    TCHAR szBaseFileName[MAX_PATH];

    ZeroMemory(pszInfFileName, cchInfFile*sizeof(TCHAR));
    StrCpy(szBaseFileName, PathFindFileName(pcszADMFileName));
    PathRemoveExtension(szBaseFileName);
    if(ISNONNULL(pcszWorkDir))
        wnsprintf(pszInfFileName, cchInfFile, TEXT("%s\\%s.inf"), pcszWorkDir, szBaseFileName);
}

// Loads all the categories for a specified .adm file
static void loadCategories(HWND hTreeView, HTREEITEM hParentItem, DWORD dwAdm,
						   BOOL fRSoPMode)
{
    int nSize = 0;
    int nCategorySize = 0;
    TV_INSERTSTRUCT tvis;
    TCHAR szCategories[2048];
    TCHAR szCategory[1024];
    HKEY hKeyCurrentClass = HKEY_CURRENT_USER;

    // Get the category list. The category strings are concatenated into a
    // single string with '\0' as the seperator and the last string is
    // terminated with "\0\0"
    GetAdmCategories(dwAdm, szCategories, ARRAYSIZE(szCategories), &nSize);

    for(int nIndex = 0; nIndex < (nSize - 2); nIndex++)
    {
        memset(szCategory, 0, sizeof(szCategory));
        nCategorySize = 0;
        while(szCategories[nIndex] != TEXT('\0'))
        {
            szCategory[nCategorySize++] = szCategories[nIndex++];
        }

        if(StrCmpI(szCategory, TEXT("HKLM")) == 0)
        {
            hKeyCurrentClass = HKEY_LOCAL_MACHINE;
            continue;
        }
        else if(StrCmpI(szCategory, TEXT("HKCU")) == 0)
        {
            hKeyCurrentClass = HKEY_CURRENT_USER;
            continue;
        }

        ADMCategory* pCategory = (ADMCategory*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADMCategory));
        if(pCategory == NULL) // not enough memory available
        {
            return;
        }
        memset(pCategory, 0, sizeof(ADMCategory));
        pCategory->pszName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
            (lstrlen(szCategory) + 1)*sizeof(TCHAR));
        if(pCategory->pszName == NULL) // not enough memory available
        {
            HeapFree(GetProcessHeap(), 0, pCategory);
            return;
        }
        StrCpy(pCategory->pszName, szCategory);
        pCategory->hKeyClass = hKeyCurrentClass;
		pCategory->fRSoPMode = fRSoPMode;

        tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvis.item.pszText = pCategory->pszName;
        tvis.item.cchTextMax = lstrlen(pCategory->pszName);
        tvis.item.lParam = (LPARAM) pCategory;
        tvis.item.iImage = tvis.item.iSelectedImage = g_ADMCategory;

        tvis.hInsertAfter = (HTREEITEM) TVI_LAST;
        tvis.hParent = hParentItem;
        if(TreeView_InsertItem( hTreeView,  &tvis) == NULL)
        {   // insert failure
            HeapFree(GetProcessHeap(), 0, pCategory->pszName);
            HeapFree(GetProcessHeap(), 0, pCategory);
        }
    }
}

// Checks whether a particular .adm file is to be displayed in the tree view
// depending on the PLATFORM key in the IEAK section
static BOOL isADMFileVisibleHelper(LPCTSTR pcszFileName, int nRole, DWORD dwPlatformId)
{
    TCHAR szRoles[5];
    TCHAR szPlatform[10];

    ZeroMemory(szRoles,sizeof(szRoles));
    ZeroMemory(szPlatform, sizeof(szPlatform));

    if(IsWizard())
    {
        // if the Roles are not specified or are not of the proper format,
        // the adm file is assumed to be visible
        if(GetPrivateProfileString(TEXT("IEAK"), TEXT("Roles"), TEXT(""), szRoles, ARRAYSIZE(szRoles), pcszFileName) == 3)
        {
            if(!((szRoles[0] == TEXT('0') || szRoles[0] == TEXT('1')) &&
               (szRoles[1] == TEXT('0') || szRoles[1] == TEXT('1')) &&
               (szRoles[2] == TEXT('0') || szRoles[2] == TEXT('1')) &&
               ((szRoles[0] == TEXT('1') && nRole == ROLE_ICP)  ||  // ICP
               (szRoles[1] == TEXT('1') && nRole == ROLE_ISP)   ||  // ISP
               (szRoles[2] == TEXT('1') && nRole == ROLE_CORP))))   // Corp. Admin
            {
                return FALSE;
            }
        }
    }
    
    GetPrivateProfileString(TEXT("IEAK"), TEXT("Platform"), TEXT(""), szPlatform, ARRAYSIZE(szPlatform), pcszFileName);
    if(!((szPlatform[1] == TEXT('1') && dwPlatformId == PLATFORM_WIN32)   ||     // WIN32
       (szPlatform[3] == TEXT('1') && dwPlatformId == PLATFORM_W2K)))            // W2K
    {
        return FALSE;
    }

    return TRUE;
}

// Adds an item (.adm file) to the tree view
static HTREEITEM addADMItemHelper(HWND hTreeView, LPCTSTR pcszADMFilePath, LPCTSTR pcszFileName,
                                  LPCTSTR pcszWorkDir, int nRole, BSTR bstrRSOPNamespace)
{
    TV_INSERTSTRUCT tvis;
    HTREEITEM hItem = NULL;
    DWORD dwAdm = 0;
    TCHAR szADMFileName[MAX_PATH];
    TCHAR szOutputFile[MAX_PATH];
    TCHAR szTitle[ADM_TITLELEN];
    PathCombine(szADMFileName, pcszADMFilePath, pcszFileName);

    // check for the visibility of the adm file
    if(!IsADMFileVisible(szADMFileName, nRole, g_dwPlatformId))
        return NULL;

    ADMFile* pADMFile = (ADMFile*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(ADMFile));
    if(pADMFile == NULL) // not enough memory available
    {
        return NULL;
    }
    ZeroMemory(pADMFile, sizeof(ADMFile));
    StrCpy(pADMFile->szFileName, szADMFileName);
    ZeroMemory(szTitle, sizeof(szTitle));
    GetPrivateProfileString(TEXT("Strings"), TEXT("IEAK_Title"), pcszFileName, szTitle,
        ARRAYSIZE(szTitle), pADMFile->szFileName);
    pADMFile->pszName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
        (StrLen(szTitle) + 1)*sizeof(TCHAR));
    if(pADMFile->pszName == NULL) // not enough memory available
    {
        HeapFree(GetProcessHeap(), 0, pADMFile);
        return NULL;
    }
    StrCpy(pADMFile->pszName, szTitle);

    tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvis.item.pszText = pADMFile->pszName;
    tvis.item.cchTextMax = StrLen(pADMFile->pszName);
    tvis.item.lParam = (LPARAM) pADMFile;
    if (IsWizard())
    {
        tvis.item.mask |= TVIF_STATE;
        tvis.item.stateMask = tvis.item.state = TVIS_BOLD;
    }
    tvis.item.iImage = tvis.item.iSelectedImage = g_ADMClose;

    tvis.hInsertAfter = (HTREEITEM) TVI_LAST;
    tvis.hParent = PolicyRoot();

    getInfFileName(pADMFile->szFileName, szOutputFile, ARRAYSIZE(szOutputFile), pcszWorkDir);
    if(AdmInit(pADMFile->szFileName, szOutputFile, bstrRSOPNamespace, &dwAdm, &pADMFile->pData) == S_OK)
    {
        pADMFile->dwAdm = dwAdm;
        if((hItem = TreeView_InsertItem( hTreeView,  &tvis)) != NULL)
        {   // insert success
            loadCategories(hTreeView, hItem, dwAdm, (NULL == bstrRSOPNamespace) ? FALSE : TRUE);
        }
    }

    if(hItem == NULL)
    {
        HeapFree(GetProcessHeap(), 0, pADMFile->pszName);
        HeapFree(GetProcessHeap(), 0, pADMFile);
        hItem = NULL;
    }
    return hItem;
}

static void addAdmItems(HWND hTreeView, LPCTSTR pcszFileType, LPCTSTR pcszADMFilePath,
                        LPCTSTR pcszWorkDir, int nRole)
{
    WIN32_FIND_DATA FindFileData;
    TCHAR szFileName[MAX_PATH];

    PathCombine(szFileName, pcszADMFilePath, pcszFileType);

    HANDLE hFind = FindFirstFile(szFileName, &FindFileData);
    if(hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
			// addAdmItems is called from loadADMFiles which is never called in RSoP mode,
			// so just pass in FALSE always.
            addADMItemHelper(hTreeView, pcszADMFilePath, FindFileData.cFileName,
							pcszWorkDir, nRole, NULL);
        }while(FindNextFile(hFind, &FindFileData));
        FindClose(hFind);
    }
}

// Loads all the .adm files from a specific path
static BOOL loadADMFilesHelper(HWND hTreeView, HTREEITEM hPolicyRootItem,
                               LPCTSTR pcszADMFilePath, LPCTSTR pcszWorkDir,
                               DWORD dwPlatformId, int nRole,
                               int nIconADMClose, int nIconADMCategory)
{
    g_hPolicyRootItem = hPolicyRootItem;
    g_dwPlatformId = dwPlatformId;
    g_ADMClose = nIconADMClose;
    g_ADMCategory = nIconADMCategory;
    ZeroMemory(g_szLogFileName, sizeof(g_szLogFileName));

    addAdmItems(hTreeView, TEXT("*.adm"), pcszADMFilePath, pcszWorkDir, nRole);
    // add also files with .opa extension, Office requirement - 06/08/98
    addAdmItems(hTreeView, TEXT("*.opa"), pcszADMFilePath, pcszWorkDir, nRole);

    return TRUE;
}

// Returns the item handle for the requested filename if any
static HTREEITEM getADMItemHandle(HWND hTreeView, LPTSTR pszADMFileName)
{
    HTREEITEM hItem = NULL;
    TV_ITEM tvitem;

    hItem = GetFirstPolicyItem(hTreeView);
    while(hItem != NULL) // if items in the tree view
    {
        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hItem;
        TreeView_GetItem(hTreeView, &tvitem);
        if(tvitem.lParam != NULL &&
            StrCmp(((ADMFile*) tvitem.lParam)->szFileName, pszADMFileName) == 0)
        {
            return hItem;
        }
        hItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
    }
    return NULL;
}

// Deletes an item from the tree view and releases any memory
// allocated with that item
static void deleteADMItemHelper(HWND hTreeView, HTREEITEM hParentItem, LPCTSTR pcszWorkDir,
                                LPCTSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave)
{
    ADMFile* pADMFile = NULL;
    ADMCategory* pADMCategory = NULL;
    HTREEITEM hItem = NULL;
    HTREEITEM hNextItem = NULL;
    TCHAR szRegistryData[MAX_PATH + 15];
    TCHAR szBaseFileName[_MAX_FNAME];
    TV_ITEM tvitem;
    TV_ITEM tvparentitem;
    TCHAR szOutputFile[MAX_PATH];

    tvparentitem.mask = TVIF_PARAM;
    tvparentitem.hItem = hParentItem;
    TreeView_GetItem(hTreeView, &tvparentitem);
    if(tvparentitem.lParam != NULL)
    {
        pADMFile = (ADMFile*) tvparentitem.lParam;
        hItem = TreeView_GetChild(hTreeView, hParentItem); // get child item
        while(hItem != NULL)
        {
            hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next child item
            tvitem.mask = TVIF_PARAM;
            tvitem.hItem = hItem;
            TreeView_GetItem(hTreeView, &tvitem);
            if(tvitem.lParam != NULL)
            {
                pADMCategory = (ADMCategory*) tvitem.lParam;
                HeapFree(GetProcessHeap(), 0, pADMCategory->pszName);
                HeapFree(GetProcessHeap(), 0, pADMCategory);

                TreeView_DeleteItem(hTreeView, hItem);
            }
            hItem = hNextItem;
        }

        getInfFileName(pADMFile->szFileName, szOutputFile, ARRAYSIZE(szOutputFile),
            pcszWorkDir);
        StrCpy(szBaseFileName, PathFindFileName(szOutputFile));
        PathRemoveExtension(szBaseFileName);
        if(bDeleteFile == TRUE)
        {
            DeleteFile(pADMFile->szFileName);
            DeleteFile(szOutputFile);
            
        }
        else
        {
            if (bSave)
            {
                AdmFinished(pADMFile->dwAdm, szOutputFile, pADMFile->pData);
                if (PathFileExists(szOutputFile))
                {
                    wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                        TEXT("*,%s,DefaultInstall"), PathFindFileName(szOutputFile));
                    InsWriteString(IS_EXTREGINF, szBaseFileName, szRegistryData, pcszInsFile);

                    if (!InsIsSectionEmpty(TEXT("AddRegSection.HKLM"), szOutputFile))
                    {
                        wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                                  TEXT("%s,IEAKInstall.HKLM"), PathFindFileName(szOutputFile));
                        InsWriteString(IS_EXTREGINF_HKLM, szBaseFileName, szRegistryData, pcszInsFile);

                    }
                    if (!InsIsSectionEmpty(TEXT("AddRegSection.HKCU"), szOutputFile))
                    {
                        wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                                  TEXT("%s,IEAKInstall.HKCU"), PathFindFileName(szOutputFile));
                        InsWriteString(IS_EXTREGINF_HKCU, szBaseFileName, szRegistryData, pcszInsFile);

                    }
                }
            }
        }

        AdmClose(pADMFile->dwAdm, &pADMFile->pData, bDeleteFile);
        HeapFree(GetProcessHeap(), 0, pADMFile->pszName);
        HeapFree(GetProcessHeap(), 0, pADMFile);

        TreeView_DeleteItem(hTreeView, hParentItem);
        if(TreeView_GetCount(hTreeView) == 0) // if no items in the tree view
            SetADMWindowText(hTreeView, TEXT(""), TEXT(""));
    }
    WritePrivateProfileString(NULL, NULL, NULL, pcszInsFile);
}

// Deletes all the items from the tree view
static void deleteADMItemsHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile,
                                 BOOL bSave)
{
    HTREEITEM hItem = GetFirstPolicyItem(hTreeView); // get policy fisrt item
    HTREEITEM hNextItem = NULL;
    HTREEITEM hSelectedItem = TreeView_GetSelection(hTreeView); // get selected item

    if(hSelectedItem != NULL)
    {
        TreeView_Select(hTreeView, NULL, TVGN_CARET);
    }

    while(hItem != NULL) // if items in the tree view
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item
        deleteADMItemHelper(hTreeView, hItem, pcszWorkDir, pcszInsFile, FALSE, bSave);
        hItem = hNextItem;
    }
}

static void getADMDescriptionTitle(LPCTSTR pcszFileName, LPTSTR pszDscrTitle)
{
    GetPrivateProfileString(TEXT("Strings"), TEXT("IEAK_DescriptionTitle"), TEXT(""),
        pszDscrTitle, ADM_DSCRLINELEN, pcszFileName);
}

// Reads the description from the specified adm file
static void getADMDescription(LPCTSTR pcszFileName, LPTSTR pszDscr)
{
    DWORD dwSize = 0;
    TCHAR szDscrText[ADM_DSCRLEN];
    TCHAR szDscrKey[20];
    int nIndex = 0;

    int nDscrLines = GetPrivateProfileInt(TEXT("IEAK"), TEXT("NumOfDescLines"), 0, pcszFileName);

    *pszDscr = TEXT('\0');
    for(nIndex = 1; nIndex <= nDscrLines; nIndex++)
    {
        wnsprintf(szDscrKey, ARRAYSIZE(szDscrKey), TEXT("IEAK_Description%d"), nIndex);
        dwSize = GetPrivateProfileString(TEXT("Strings"), szDscrKey, NULL,
            szDscrText, ADM_DSCRLEN, pcszFileName);
        if (dwSize)
        {
            if(nIndex == 1)
                StrCpy(pszDscr, szDscrText);
            else
            {
                StrCat(pszDscr, TEXT("\r\n\r\n"));
                StrCat(pszDscr, szDscrText);
            }
        }
    }
}

// Imports ADM file from the directory specified by the user to the
// adm directory and calls addADMItemHelper to show the item on the tree list
static void importADMFileHelper(HWND hMainWnd, HWND hTreeView, LPCTSTR pcszADMFilePath,
                                LPCTSTR pcszWorkDir, int nRole, LPCTSTR pcszInsFile)
{
    HTREEITEM hItem = NULL;
    TCHAR szFileName[MAX_PATH]=TEXT("");
    LPTSTR pExt = NULL;
    TCHAR szADMFileName[MAX_PATH];
    TCHAR szMessage[512];
    TCHAR szTitle[MAX_PATH];

    LoadString(g_hDLLInst, IDS_ENGINE_TITLE, szTitle, ARRAYSIZE(szTitle));
    if( BrowseForFile( hTreeView, szFileName, ARRAYSIZE(szFileName), GFN_ADM ))
    {
        pExt = PathFindExtension(szFileName);
        if(pExt != NULL)
            pExt++;
        // Only .adm file extensions to be added to the list
        if(StrCmpI(pExt, TEXT("adm")) == 0 || StrCmpI(pExt, TEXT("opa")) == 0)
        {
            PathCombine(szADMFileName, pcszADMFilePath, PathFindFileName(szFileName));

            // if already there exists a file with the same name, prompt
            // the user for overwrite confirmation.
            if(!CopyFile(szFileName, szADMFileName, TRUE))
            {
                LoadString(g_hInst, IDS_ADMOVRWWARN, szMessage, ARRAYSIZE(szMessage));
                if(MessageBox(hTreeView, szMessage, szTitle, MB_ICONQUESTION|MB_YESNO) == IDYES)
                {
                    CopyFile(szFileName, szADMFileName, FALSE);
                    hItem = getADMItemHandle(hTreeView, szADMFileName);
                    if(hItem != NULL)
                    {
                        TreeView_Select(hTreeView, NULL, TVGN_CARET);
                        deleteADMItemHelper(hTreeView, hItem, pcszWorkDir, pcszInsFile,
                            FALSE, TRUE);
                    }

					// importADMFile is never called in RSoP mode,
					// so just pass in FALSE always.
                    hItem = addADMItemHelper(hTreeView, pcszADMFilePath,
                        PathFindFileName(szADMFileName), pcszWorkDir, nRole, NULL);
                    if(hItem != NULL)
                    {
                        TreeView_Select(hTreeView, hItem, TVGN_CARET);
                        CheckForDupKeys(hMainWnd, hTreeView, hItem, FALSE);
                    }
                }
            }
            else
            {
				// importADMFile is never called in RSoP mode,
				// so just pass in FALSE always.
                if((hItem = addADMItemHelper(hTreeView, pcszADMFilePath,
                    PathFindFileName(szADMFileName), pcszWorkDir, nRole, NULL)) != NULL)
                {
                    TreeView_Select(hTreeView, hItem, TVGN_CARET);
                    CheckForDupKeys(hMainWnd, hTreeView, hItem, FALSE);
                }
            }
        }
        else
        {
            LoadString(g_hInst, IDS_ADMINVALIDEXTN, szMessage, ARRAYSIZE(szMessage));
            MessageBox(hTreeView, szMessage, szTitle, MB_ICONINFORMATION|MB_OK);
        }
    }
}

static BOOL CALLBACK logDialogProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM)
{
    HANDLE hFile = NULL;
    HGLOBAL hFileMem = NULL;
    int nFileSize = 0;
    DWORD dwRead = 0;

    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_LOGTEXT);

        hFile = CreateFile( g_szLogFileName, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            EndDialog(hDlg, 1);
            break;
        }

        nFileSize = GetFileSize( hFile, NULL );
        hFileMem = LocalAlloc( LPTR, nFileSize + 2);
        if( hFileMem != NULL )
        {
            if (ReadFile( hFile, (LPSTR) hFileMem, (DWORD) nFileSize, &dwRead, NULL)==TRUE)
                SetWindowTextA(GetDlgItem(hDlg, IDC_LOGTEXT), (LPCSTR) hFileMem);
            PostMessage(GetDlgItem(hDlg, IDC_LOGTEXT), EM_SETSEL, 0, 0L);
            LocalFree(hFileMem);
            hFileMem = NULL;
        }
        CloseHandle( hFile );
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED && LOWORD( wParam ) == IDOK)
            EndDialog(hDlg, 1);
        break;

    default:
        return 0;
    }
    return 1;
}

//*********
// All the below functions is used only by the Profile Manager

static BOOL isPolicyTree(HWND hTreeView, HTREEITEM hItem)
{
    BOOL bRet = FALSE;
    HTREEITEM hParentItem = NULL;

    while(1)
    {
        hParentItem = TreeView_GetParent(hTreeView, hItem);
        if(hParentItem == NULL)
        {
            bRet = (hItem == g_hPolicyRootItem) ? TRUE : FALSE;
            break;
        }
        hItem = hParentItem;
    };

    return bRet;
}

static void resetAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, BOOL bReset)
{
    HTREEITEM hItem = TreeView_GetChild(hTreeView, g_hPolicyRootItem); // get first policy item
    HTREEITEM hNextItem = NULL;
    TV_ITEM tvitem;
    TCHAR szInfFile[MAX_PATH];
    HTREEITEM hSelectedItem = TreeView_GetSelection(hTreeView); // get selected item
    ADMFile* pADMFile = NULL;
    ADMCategory* pADMCategory = NULL;

    if(g_hPolicyRootItem == NULL) // no elements under policy item
        return;

    while(hItem != NULL) // if items in the tree view
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item

        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hItem;
        TreeView_GetItem(hTreeView, &tvitem);

        pADMFile = (ADMFile*)tvitem.lParam;

        if (hSelectedItem != NULL &&
            TreeView_GetParent(hTreeView, hSelectedItem) == hItem)
        {
            TV_ITEM tvItem;

            tvItem.mask = TVIF_PARAM;
            tvItem.hItem = hSelectedItem;
            TreeView_GetItem(hTreeView, &tvItem);

            pADMCategory = (ADMCategory*)tvitem.lParam;
        }
        else
            pADMCategory = NULL;

        ZeroMemory(szInfFile, sizeof(szInfFile));
        if(bReset)
        {
            getInfFileName(pADMFile->szFileName, szInfFile,
                ARRAYSIZE(szInfFile), pcszWorkDir);
            if (pADMCategory != NULL)
                AdmReset(pADMFile->dwAdm, szInfFile, pADMFile->pData, pADMCategory->pData);
            else
                AdmReset(pADMFile->dwAdm, szInfFile, pADMFile->pData, NULL);
        }
        else
        {
            if (pADMCategory != NULL)
                AdmReset(pADMFile->dwAdm, NULL, pADMFile->pData, pADMCategory->pData);
            else
                AdmReset(pADMFile->dwAdm, NULL, pADMFile->pData, NULL);
        }

        hItem = hNextItem;
    }

    if(hSelectedItem != NULL && isPolicyTree(hTreeView, hSelectedItem) && hSelectedItem != g_hPolicyRootItem &&
        TreeView_GetParent(hTreeView, hSelectedItem) != g_hPolicyRootItem)
    {
        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hSelectedItem;
        TreeView_GetItem(hTreeView, &tvitem);
        
        pADMCategory = (ADMCategory*)tvitem.lParam;

        EnableWindow(pADMCategory->hWnd, TRUE);
    }
}

static void saveAdmFilesHelper(HWND hTreeView, LPCTSTR pcszWorkDir, LPCTSTR pcszInsFile)
{
    HTREEITEM hItem = TreeView_GetChild(hTreeView, g_hPolicyRootItem); // get first policy item
    HTREEITEM hNextItem = NULL;
    TV_ITEM tvitem;
    TCHAR szInfFile[MAX_PATH];
    TCHAR szRegistryData[MAX_PATH + 15];
    TCHAR szBaseFileName[_MAX_FNAME];
    LPTSTR pExt = NULL;
    ADMFile* pADMFile;

    if(!IsAdmDirty() || g_hPolicyRootItem == NULL) // no elements under policy item
        return;

    while(hItem != NULL) // if items in the tree view
    {
        hNextItem = TreeView_GetNextSibling(hTreeView, hItem); // get next item

        tvitem.mask = TVIF_PARAM;
        tvitem.hItem = hItem;
        TreeView_GetItem(hTreeView, &tvitem);

        pADMFile = (ADMFile*)tvitem.lParam;
        
        ZeroMemory(szInfFile, sizeof(szInfFile));
        getInfFileName(pADMFile->szFileName, szInfFile,
            ARRAYSIZE(szInfFile), pcszWorkDir);
        StrCpy(szBaseFileName, PathFindFileName(szInfFile));
        PathRemoveExtension(szBaseFileName);

        AdmFinished(pADMFile->dwAdm, szInfFile, pADMFile->pData);
        if (PathFileExists(szInfFile))
        {
            pExt = PathFindExtension(szInfFile);
            wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                    TEXT("*,%s,DefaultInstall"), PathFindFileName(szInfFile));
            InsWriteString(IS_EXTREGINF, szBaseFileName, szRegistryData, pcszInsFile);

            if (!InsIsSectionEmpty(TEXT("AddRegSection.HKLM"), szInfFile))
            {
               wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                        TEXT("%s,IEAKInstall.HKLM"), PathFindFileName(szInfFile));
               InsWriteString(IS_EXTREGINF_HKLM, szBaseFileName, szRegistryData, pcszInsFile);
            }
            if (!InsIsSectionEmpty(TEXT("AddRegSection.HKCU"), szInfFile))
            {
               wnsprintf(szRegistryData, ARRAYSIZE(szRegistryData),
                        TEXT("%s,IEAKInstall.HKCU"), PathFindFileName(szInfFile));
               InsWriteString(IS_EXTREGINF_HKCU, szBaseFileName, szRegistryData, pcszInsFile);
            }
        }
        hItem = hNextItem;
    }
    WritePrivateProfileString(NULL, NULL, NULL, pcszInsFile);
}

//*********

// CDscrWnd
// This window is used to display the description title and text for the top level item selected in the treeview.

CDscrWnd::CDscrWnd()
{
    hWndMain      = NULL;
    hWndDscrTitle = NULL;
    hWndDscrText  = NULL;
    hFontDscrTitle = NULL;
}

CDscrWnd::~CDscrWnd()
{
    if (hFontDscrTitle != NULL)
    {
        DeleteObject(hFontDscrTitle);
        hFontDscrTitle = NULL;
    }

    if (hWndMain != NULL) //destroying the main window destroys its child windows
        DestroyWindow(hWndMain);
}

static WNDPROC g_lpfnDscrTextWndProc = NULL;

LRESULT CALLBACK DscrTextWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_GETDLGCODE)
        return (DLGC_WANTARROWS | DLGC_WANTCHARS);
    return (CallWindowProc(g_lpfnDscrTextWndProc, hWnd, uMsg, wParam, lParam));
}

void CDscrWnd::Create(HWND hWndParent, HWND hWndInsertAfter, int nXPos, int nYPos, int nWidth,
                      int nHeight)
{
    if (hWndMain != NULL) // already created
        return;

    // create the main window
    hWndMain = CreateWindowEx(WS_EX_CONTROLPARENT, TEXT("STATIC"), TEXT(""), WS_VISIBLE | WS_CHILD | WS_GROUP,
                              nXPos, nYPos, nWidth, nHeight, hWndParent, NULL, g_hInst, NULL);
    if (hWndMain == NULL)
        return;

    if (hWndInsertAfter != NULL)
        SetWindowPos(hWndMain, hWndInsertAfter, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    // create the description title window
    hWndDscrTitle = CreateWindowEx(0, TEXT("STATIC"), TEXT(""), WS_VISIBLE | WS_CHILD | SS_LEFT | SS_NOPREFIX,
                                   0, 0, nWidth, 0, hWndMain, NULL, g_hInst, NULL );
    if (hWndDscrTitle == NULL)
        return;

    // change the font of the title to make it bold
    HDC        hDC = GetDC(hWndDscrTitle);

    if (hFontDscrTitle == NULL)
        hFontDscrTitle = getBoldFont(hWndDscrTitle);

    if (hFontDscrTitle)
        SelectObject(hDC, hFontDscrTitle);

    ReleaseDC(hWndDscrTitle, hDC);

    // create the description text window
    hWndDscrText = CreateWindowEx(0, TEXT("EDIT"), TEXT(""), WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_VSCROLL |
                                  ES_LEFT | ES_MULTILINE | ES_READONLY,
                                  0, 25, nWidth, 0, hWndMain, NULL, g_hInst, NULL );
    if (hWndDscrText == NULL)
        return;

    // change the font of the text to default gui font
    HFONT hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    SendMessage(hWndDscrText, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));

    g_lpfnDscrTextWndProc = (WNDPROC) GetWindowLongPtr(hWndDscrText, GWLP_WNDPROC);
    SetWindowLongPtr(hWndDscrText, GWLP_WNDPROC, (LONG_PTR) DscrTextWndProc);
}

void CDscrWnd::ShowWindow(BOOL fShow)
{
    if (hWndMain != NULL)
    {
        if (fShow)
            ::ShowWindow(hWndMain, SW_SHOWNORMAL);
        else
            ::ShowWindow(hWndMain, SW_HIDE);
    }
}

void CDscrWnd::SetText(LPCTSTR pcszTitle, LPCTSTR pcszText, BOOL fUpdateWindowState)
{
    int nYPos = 0;
    HDC hDC = NULL;
    int nHeight = 0;
    int nWidth = 0;
    RECT rect;

    if (hWndMain == NULL)
        return;

    if (fUpdateWindowState)
        ::ShowWindow(hWndMain, SW_SHOWNORMAL);
    if (hWndDscrTitle != NULL)
    {
        if(pcszTitle == NULL || *pcszTitle == TEXT('\0'))
        {
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrTitle, SW_HIDE);
        }
        else
        {
            GetClientRect(GetParent(hWndDscrTitle), &rect);
            nWidth = rect.right;
            hDC = GetDC(hWndDscrTitle);
            nHeight = DrawText(hDC, pcszTitle, -1, &rect, DT_LEFT | DT_WORDBREAK | DT_CALCRECT);
            ReleaseDC(hWndDscrTitle, hDC);
            SetWindowPos(hWndDscrTitle, NULL, 0, 0, nWidth, nHeight, SWP_NOMOVE | SWP_NOZORDER);

            SetWindowText(hWndDscrTitle, pcszTitle);
            nYPos = nHeight + 5;
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrTitle, SW_SHOWNORMAL);
        }
    }

    if (hWndDscrText != NULL)
    {
        if (pcszText == NULL || *pcszText == TEXT('\0'))
        {
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrText, SW_HIDE);
        }
        else
        {
            GetClientRect(GetParent(hWndDscrText), &rect);
            SetWindowPos(hWndDscrText, NULL, 0, nYPos, rect.right, rect.bottom - nYPos, SWP_NOZORDER);

            SetWindowText(hWndDscrText, pcszText);
            if (fUpdateWindowState)
                ::ShowWindow(hWndDscrText, SW_SHOWNORMAL);
        }
    }
}

void CDscrWnd::GetRect(RECT* lpRect)
{
    ZeroMemory(lpRect, sizeof(RECT));
    if (hWndMain != NULL)
        GetWindowRect(hWndMain, lpRect);
}

void CDscrWnd::MoveWindow(int nXPos, int nYPos, int nWidth, int nHeight)
{
    TCHAR szDscrTitle[ADM_TITLELEN];
    TCHAR szDscr[ADM_DSCRLEN];

    if (hWndMain == NULL)
        return;

    ::MoveWindow(hWndMain, nXPos, nYPos, nWidth, nHeight, TRUE);

    ZeroMemory(szDscrTitle, ADM_TITLELEN);
    if (hWndDscrTitle != NULL)
        GetWindowText(hWndDscrTitle, szDscrTitle, ADM_TITLELEN);

    ZeroMemory(szDscr, ADM_DSCRLEN);
    if (hWndDscrText != NULL)
        GetWindowText(hWndDscrText, szDscr, ADM_DSCRLEN);

    SetText(szDscrTitle, szDscr, FALSE);
}

static HFONT getBoldFont(HWND hWnd)
{
    static HFONT hFont = NULL;
    LOGFONT    lf;
    TEXTMETRIC tm;
    HDC        hDC;
    int        nFontSize = 0;

    ZeroMemory(&lf, sizeof(lf));

    if (hFont == NULL)
    {
        if (GetFontInfo != NULL)
            GetFontInfo(lf.lfFaceName, &nFontSize);

        if (*(lf.lfFaceName) == TEXT('\0'))
        {
            StrCpy(lf.lfFaceName, TEXT("MS Sans Serif"));
            nFontSize = 10;
        }

        hDC = GetDC(hWnd);

        lf.lfHeight = -((nFontSize * GetDeviceCaps(hDC, LOGPIXELSY)) / 72);
        lf.lfWeight = FW_BOLD;

        GetTextMetrics(hDC, &tm);
        lf.lfCharSet = tm.tmCharSet;

        ReleaseDC(hWnd, hDC);

        hFont = CreateFontIndirect(&lf);
    }

    return hFont;
}

static BOOL getAdmFileListHelper(LPRESULTITEM* pResultItems, int* pnResultItems, int nRole)
{
    WIN32_FIND_DATA FindFileData;
    TCHAR szFileName[MAX_PATH];
    TCHAR szADMFilePath[MAX_PATH];
    int nAdmFiles = 0;
    int nAllocatedBuffer = 10;

    *pResultItems = (LPRESULTITEM) CoTaskMemAlloc(sizeof(RESULTITEM) * nAllocatedBuffer);
    if (*pResultItems == NULL)
    {
        ErrorMessageBox(NULL, IDS_MEMORY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    // BUGBUG: for now assume the admfilepath
    GetWindowsDirectory(szADMFilePath, countof(szADMFilePath));
    PathAppend(szADMFilePath, TEXT("INF"));
    PathCombine(szFileName, szADMFilePath, TEXT("*.adm"));

    HANDLE hFind = FindFirstFile(szFileName, &FindFileData);
    if(hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            TCHAR szBuffer[MAX_PATH];
            LPRESULTITEM lpResultItem;

            PathCombine(szFileName, szADMFilePath, FindFileData.cFileName);

            if (InsIsSectionEmpty(TEXT("IEAK"), szFileName) ||
                !isADMFileVisibleHelper(szFileName, nRole, g_dwPlatformId))
                continue;

            if (nAdmFiles >= nAllocatedBuffer)
            {
                LPVOID lpTemp;

                nAllocatedBuffer += 5;
                lpTemp = CoTaskMemRealloc(*pResultItems, sizeof(RESULTITEM) * nAllocatedBuffer);
                if (lpTemp == NULL)
                {
                    ErrorMessageBox(NULL, IDS_MEMORY_ERROR, MB_ICONINFORMATION | MB_OK);
                    CoTaskMemFree(*pResultItems);
                    *pResultItems = NULL;
                    return FALSE;
                }

                *pResultItems = (LPRESULTITEM) lpTemp;
            }

            ZeroMemory(&((*pResultItems)[nAdmFiles]), sizeof((*pResultItems)[nAdmFiles]));

            GetPrivateProfileString(IS_STRINGS, TEXT("IEAK_Title"), szFileName, 
                                    szBuffer, countof(szBuffer), szFileName);

            lpResultItem = &((*pResultItems)[nAdmFiles]);

            if ((lpResultItem->pszName = (LPTSTR)CoTaskMemAlloc(StrCbFromSz(szBuffer))) != NULL)
                StrCpy(lpResultItem->pszName, szBuffer);

            if ((lpResultItem->pszDesc = (LPTSTR)CoTaskMemAlloc(StrCbFromSz(szFileName))) != NULL)
                StrCpy(lpResultItem->pszDesc, szFileName);

            nAdmFiles++;

        }while(FindNextFile(hFind, &FindFileData));
        FindClose(hFind);
    }

    *pnResultItems = nAdmFiles;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\channels.cpp ===
#include "precomp.h"
#include "channels.h"

#define NSUBGRPS 10

static DWORD s_dwMode;

static void channels_InitHelper(HWND hDlg, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir, LPCTSTR pcszCustIns,
                                WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline);
static void channels_SaveHelper(HWND hwndList, LPCTSTR pcszChanDir, LPCTSTR pcszCustIns, DWORD dwMode);
static int importChannels(HWND hDlg);
static BOOL CALLBACK addEditChannel(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static PCHANNEL findFreeChannel(HWND hwndList);

void WINAPI Channels_InitA(HWND hDlg, LPCSTR pcszAltDir, LPCSTR pcszWorkDir, LPCSTR pcszCustIns,
                           WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    channels_InitHelper(hDlg, A2CT(pcszAltDir), A2CT(pcszWorkDir), A2CT(pcszCustIns), idList,
        dwPlatformId, fIgnoreOffline);
}

void WINAPI Channels_InitW(HWND hDlg, LPCWSTR pcwszAltDir, LPCWSTR pcwszWorkDir, LPCWSTR pcwszCustIns, 
                           WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline)
{
    USES_CONVERSION;

    channels_InitHelper(hDlg, W2CT(pcwszAltDir), W2CT(pcwszWorkDir), W2CT(pcwszCustIns), 
        idList, dwPlatformId, fIgnoreOffline);
}

void WINAPI Channels_SaveA(HWND hwndList, LPCSTR pcszChanDir, LPCSTR pcszCustIns, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    channels_SaveHelper(hwndList, A2CT(pcszChanDir), A2CT(pcszCustIns), dwMode);
}

void WINAPI Channels_SaveW(HWND hwndList, LPCWSTR pcwszChanDir, LPCWSTR pcwszCustIns, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    channels_SaveHelper(hwndList, W2CT(pcwszChanDir), W2CT(pcwszCustIns), dwMode);
}

int WINAPI Channels_Import(HWND hDlg)
{
    int nChannels = 0;

    nChannels = importChannels(hDlg);
    if (nChannels == 0)
        ErrorMessageBox(hDlg, IDS_NOCHANNELSTOIMPORT);

    return nChannels;
}

BOOL WINAPI Channels_Remove(HWND hDlg)
{
    PCHANNEL pChan;
    int i;

    i = (INT) SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_GETCURSEL, 0, 0);
    pChan = (PCHANNEL)SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_GETITEMDATA, (WPARAM)i, 0);
    *pChan->szTitle = TEXT('\0');
    SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_DELETESTRING, (WPARAM)i, 0);

    // if add buttons have been disabled because we reached the max, then reenable them

    if (!IsWindowEnabled(GetDlgItem(hDlg, IDC_ADDCHANNEL)))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADDCHANNEL), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_ADDCATEGORY), TRUE);
    }

    if (SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETCURSEL, (WPARAM)i, 0) == LB_ERR)
    {
        if (SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETCURSEL, (WPARAM)(i-1), 0) == LB_ERR)
        {
            EnsureDialogFocus(hDlg, IDC_EDITCHANNEL, IDC_ADDCHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_EDITCHANNEL), FALSE);
            EnsureDialogFocus(hDlg, IDC_REMOVECHANNEL, IDC_ADDCHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_REMOVECHANNEL), FALSE);
        }
        else
            SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETTOPINDEX, (WPARAM)i, 0);
    }
    else
        SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETTOPINDEX, (WPARAM)i, 0);

    return TRUE;
}

static HRESULT xML_GetElementByIndex(IXMLElementCollection* pIXMLElementCollection, LONG nIndex,
                                     IXMLElement** ppIXMLElement)
{
    HRESULT hr;
    VARIANT var1, var2;

    if (!pIXMLElementCollection || !ppIXMLElement)
        return E_FAIL;

    VariantInit(&var1);
    VariantInit(&var2);

    var1.vt   = VT_I4;
    var1.lVal = nIndex;

    IDispatch* pIDispatch;

    hr = pIXMLElementCollection->item(var1, var2, &pIDispatch);

    if (SUCCEEDED(hr) && pIDispatch)
    {
        hr = pIDispatch->QueryInterface(IID_IXMLElement, (void**)ppIXMLElement);

        pIDispatch->Release();
    }
    else
    {
        *ppIXMLElement = NULL;
        hr = E_FAIL;
    }

    return hr;
}

static BOOL xML_ParseElement(IXMLElement * pIXMLElement, LPTSTR pszPath,
                             LPCWSTR pcwszImageTypeW, LPCTSTR pcszBaseUrl)
{
    HRESULT hr;
    BSTR bstrTagName;
    VARIANT var;
    WCHAR szImagePathW[MAX_PATH];
    TCHAR szFullUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szImageUrl[INTERNET_MAX_URL_LENGTH];
    INTERNET_CACHE_ENTRY_INFO *lpiceiInfo;
    DWORD dwSize = 0;

    USES_CONVERSION;

    hr = pIXMLElement->get_tagName(&bstrTagName);

    if (SUCCEEDED(hr) && bstrTagName)
    {
        if (StrCmpIW(bstrTagName, WSTR_LOGO) == 0)
        {
            VariantInit(&var);
            hr = pIXMLElement->getAttribute(WSTR_STYLE, &var);
            if ((SUCCEEDED(hr)) && (var.vt == VT_BSTR) && (var.bstrVal != NULL))
            {
                if ((StrCmpIW(var.bstrVal, pcwszImageTypeW) == 0) ||
                    ((StrCmpIW(pcwszImageTypeW, WSTR_IMAGEW) == 0) &&
                    (StrCmpIW(var.bstrVal, L"IMAGEWIDE") == 0)))
                {
                    VariantClear(&var);
                    hr = pIXMLElement->getAttribute(WSTR_HREF, &var);
                    if ((SUCCEEDED(hr)) && (var.vt == VT_BSTR) && (var.bstrVal != NULL))
                    {
                        W2Tbux(var.bstrVal, szImageUrl);
                        if (PathIsURL(szImageUrl)  ||  ISNULL(pcszBaseUrl))
                            StrCpy(szFullUrl, szImageUrl);
                        else
                        {
                            DWORD cbSize = sizeof(szFullUrl);

                            InternetCombineUrl(pcszBaseUrl, szImageUrl, szFullUrl, &cbSize, ICU_NO_ENCODE);
                        }

                        RetrieveUrlCacheEntryFile(szFullUrl, NULL, &dwSize, 0);
                        lpiceiInfo = (INTERNET_CACHE_ENTRY_INFO *)LocalAlloc(LPTR, dwSize);
                        if (RetrieveUrlCacheEntryFile(szFullUrl, lpiceiInfo, &dwSize, 0))
                        {
                            StrCpy(pszPath, lpiceiInfo->lpszLocalFileName);
                            LocalFree(lpiceiInfo);
                            UnlockUrlCacheEntryFile(szFullUrl, 0);
                            return TRUE;
                        }
                        else
                        {
                            LocalFree(lpiceiInfo);
                            hr = URLDownloadToCacheFileW(NULL, T2W(szFullUrl), szImagePathW, ARRAYSIZE(szImagePathW), 0, NULL);
                            if (SUCCEEDED(hr))
                            {
                                W2Tbux(szImagePathW, pszPath);
                                return TRUE;
                            }
                        }
                    }
                }
            }
        }
    }

    return FALSE;
}
// Takes a cdf url, downloads to the cache if necessary, and parses to
// find the image path in the cache(downloading again if necessary) for
// either wide logo, logo or image.  Returns FALSE if none specified

static BOOL getCdfImage(LPCTSTR szCdfUrl, LPTSTR szPath, LPCWSTR szImageTypeW)
{
    TCHAR szCdfUrlPath[INTERNET_MAX_URL_LENGTH];
    IXMLDocument* pIXMLDocument = NULL;
    IPersistStreamInit* pIPersistStreamInit = NULL;
    IStream* pIStream = NULL;
    IXMLElement *pRootElem = NULL;
    BOOL bLoad = FALSE;
    HRESULT hr = S_OK;
    INTERNET_CACHE_ENTRY_INFO *lpiceiInfo;
    DWORD dwSize = 0;

    RetrieveUrlCacheEntryFile(szCdfUrl, NULL, &dwSize, 0);
    lpiceiInfo = (INTERNET_CACHE_ENTRY_INFO *)LocalAlloc(LPTR, dwSize);
    if (RetrieveUrlCacheEntryFile(szCdfUrl, lpiceiInfo, &dwSize, 0))
    {
        StrCpy(szCdfUrlPath, lpiceiInfo->lpszLocalFileName);
        UnlockUrlCacheEntryFile(szCdfUrl, 0);
    }
    else
    {
        hr = URLDownloadToCacheFile(NULL, szCdfUrl, szCdfUrlPath, ARRAYSIZE(szCdfUrlPath), 0, NULL);
    }
    LocalFree(lpiceiInfo);

    if (!SUCCEEDED(hr))
    {
        return FALSE;
    }

    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDocument, (void**)&pIXMLDocument);

    // load the document

    if (SUCCEEDED(hr) && pIXMLDocument)
    {
        hr = pIXMLDocument->QueryInterface(IID_IPersistStreamInit,
                                          (void**)&pIPersistStreamInit);

        if (SUCCEEDED(hr) && pIPersistStreamInit)
        {
            hr = SHCreateStreamOnFile(szCdfUrlPath, STGM_READ, &pIStream);

            if (SUCCEEDED(hr) && pIStream)
            {
                hr = pIPersistStreamInit->Load(pIStream);
                pIStream->Release();
                bLoad = TRUE;
            }
            pIPersistStreamInit->Release();
        }
    }

    if (!bLoad)
    {
        if (pIXMLDocument)
            pIXMLDocument->Release();
        return FALSE;
    }

    // Now lets get the image

    hr = pIXMLDocument->get_root(&pRootElem);

    if (SUCCEEDED(hr) && pRootElem)
    {
        TCHAR szBaseUrl[INTERNET_MAX_URL_LENGTH];
        VARIANT var;
        IXMLElementCollection* pIXMLElementCollection;

        VariantInit(&var);

        *szBaseUrl = TEXT('\0');
        hr = pRootElem->getAttribute(WSTR_BASE, &var);
        if ((SUCCEEDED(hr)) && (var.vt == VT_BSTR) && (var.bstrVal != NULL))
            W2Tbux(var.bstrVal, szBaseUrl);

        hr = pRootElem->get_children(&pIXMLElementCollection);

        if (SUCCEEDED(hr) && pIXMLElementCollection)
        {
            LONG nCount;

            hr = pIXMLElementCollection->get_length(&nCount);

            if (SUCCEEDED(hr))
            {
                for (int i = 0; i < nCount; i++)
                {
                    IXMLElement* pIXMLElement;

                    hr = xML_GetElementByIndex(pIXMLElementCollection, i, &pIXMLElement);

                    if (SUCCEEDED(hr) && pIXMLElement)
                    {
                        if (xML_ParseElement(pIXMLElement, szPath, szImageTypeW, szBaseUrl))
                        {
                            pIXMLElement->Release();
                            hr = S_OK;
                            break;
                        }
                        pIXMLElement->Release();
                        hr = E_FAIL;
                    }
                }
            }
            pIXMLElementCollection->Release();
        }
        pRootElem->Release();
    }
    pIXMLDocument->Release();

    if (SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

// This DlgProc handles the processing for all popups on all platforms
// Note that the narrow image, wide image, and icon resource id's are the
// same for channels and categories.

static BOOL CALLBACK addEditChannel(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szWrk[MAX_URL];
    TCHAR szTitle[MAX_PATH] = TEXT("");               // buffers used for validation
    TCHAR szPreUrlPath[MAX_PATH] = TEXT("");
    TCHAR szIcon[MAX_PATH] = TEXT("");
    TCHAR szLogo[MAX_PATH] = TEXT("");
    TCHAR szWebUrl[INTERNET_MAX_URL_LENGTH] = TEXT("");
    PCHANNEL pSelCh;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pSelCh = (PCHANNEL)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pSelCh);
        if (pSelCh->fCategory)
        {
            EnableDBCSChars(hDlg, IDC_CATEGORYHTML);
            EnableDBCSChars(hDlg, IDE_CATEGORYTITLE);
            SetDlgItemText(hDlg,  IDC_CATEGORYHTML,  pSelCh->szWebUrl);
            SetDlgItemText(hDlg,  IDE_CATEGORYTITLE, pSelCh->szTitle);
        }
        else
        {
            EnableDBCSChars(hDlg, IDE_CHANNELSRVURL2);
            EnableDBCSChars(hDlg, IDE_CHANNELTITLE2);
            SetDlgItemText(hDlg,  IDE_CHANNELSRVURL2, pSelCh->szWebUrl);
            SetDlgItemText(hDlg,  IDE_CHANNELTITLE2,  pSelCh->szTitle);
        }

        EnableDBCSChars(hDlg, IDC_CHANNELBITMAP2);
        EnableDBCSChars(hDlg, IDC_CHANNELICON2);
        SetDlgItemText(hDlg, IDC_CHANNELBITMAP2, pSelCh->szLogo);
        SetDlgItemText(hDlg, IDC_CHANNELICON2, pSelCh->szIcon);

        if (!pSelCh->fCategory)
        {
            EnableDBCSChars(hDlg, IDC_CHANNELURL2);
            SetDlgItemText(hDlg,  IDC_CHANNELURL2, pSelCh->szPreUrlPath);

            if (!HasFlag(s_dwMode, (IEM_CORP | IEM_PROFMGR)))
                DisableDlgItem(hDlg, IDC_CHANNELOFFL);

            else
                if (pSelCh->fOffline)
                    CheckDlgButton(hDlg, IDC_CHANNELOFFL, BST_CHECKED);
        }
        else
            ASSERT(!HasFlag(s_dwMode, IEM_ADMIN));
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_BROWSECHBMP2:
                GetDlgItemText(hDlg, IDC_CHANNELBITMAP2, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_PICTURE))
                    SetDlgItemText(hDlg, IDC_CHANNELBITMAP2, szWrk);
                break;
            case IDC_BROWSECHICO2:
                GetDlgItemText(hDlg, IDC_CHANNELICON2, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_ICO | GFN_PICTURE))
                    SetDlgItemText(hDlg, IDC_CHANNELICON2, szWrk);
                break;
            case IDC_BROWSECDF2:
                GetDlgItemText(hDlg, IDC_CHANNELURL2, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_CDF))
                    SetDlgItemText(hDlg, IDC_CHANNELURL2, szWrk);
                break;
            case IDC_BROWSECATHTML:
                GetDlgItemText(hDlg, IDC_CATEGORYHTML, szWrk, ARRAYSIZE(szWrk));
                if (BrowseForFile(hDlg, szWrk, ARRAYSIZE(szWrk), GFN_LOCALHTM))
                    SetDlgItemText(hDlg, IDC_CATEGORYHTML, szWrk);
                break;
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDOK:
                pSelCh = (PCHANNEL)GetWindowLongPtr(hDlg, DWLP_USER);
                if (pSelCh->fCategory)
                {
                    GetDlgItemText( hDlg, IDE_CATEGORYTITLE, szTitle, ARRAYSIZE(szTitle) );
                    GetDlgItemText( hDlg, IDC_CATEGORYHTML, szWebUrl, ARRAYSIZE(szWebUrl) );
                }
                else
                {
                    GetDlgItemText( hDlg, IDE_CHANNELTITLE2, szTitle, ARRAYSIZE(szTitle) );
                    GetDlgItemText( hDlg, IDE_CHANNELSRVURL2, szWebUrl, ARRAYSIZE(szWebUrl) );
                }

                GetDlgItemText( hDlg, IDC_CHANNELBITMAP2, szLogo, ARRAYSIZE(szLogo) );
                GetDlgItemText( hDlg, IDC_CHANNELICON2, szIcon, ARRAYSIZE(szIcon) );
                if (!pSelCh->fCategory) {
                    GetDlgItemText(hDlg, IDC_CHANNELURL2, szPreUrlPath, ARRAYSIZE(szPreUrlPath));

                    pSelCh->fOffline = IsWindowEnabled(GetDlgItem(hDlg, IDC_CHANNELOFFL)) &&
                                         (IsDlgButtonChecked(hDlg, IDC_CHANNELOFFL) == BST_CHECKED);
                }

                if (pSelCh->fCategory)
                {
                    if (!CheckField(hDlg, IDE_CATEGORYTITLE, FC_NONNULL))
                        break;
                }
                else
                {
                    if (!CheckField(hDlg, IDE_CHANNELTITLE2, FC_NONNULL) ||
                        !CheckField(hDlg, IDE_CHANNELSRVURL2, FC_NONNULL | FC_URL))
                        break;
                }

                if (!CheckField(hDlg, IDC_CHANNELBITMAP2, FC_FILE | FC_EXISTS) ||
                    !CheckField(hDlg, IDC_CHANNELICON2, FC_FILE | FC_EXISTS) ||
                    (!pSelCh->fCategory && !CheckField(hDlg, IDC_CHANNELURL2, FC_FILE | FC_EXISTS)))
                    break;

                // make sure they're not adding a duplicate channel/category name

                if ((StrCmpI(pSelCh->szTitle, szTitle) != 0) &&
                    (ListBox_GetCount(GetDlgItem(pSelCh->hDlg, IDC_CHANNELLIST))) &&
                    (ListBox_FindStringExact(GetDlgItem(pSelCh->hDlg, IDC_CHANNELLIST), -1,
                    szTitle) != LB_ERR))
                {
                    ErrorMessageBox(hDlg, IDS_DUPCHAN);
                    break;
                }

                StrCpy(pSelCh->szTitle, szTitle);
                StrCpy(pSelCh->szWebUrl, szWebUrl);

                StrCpy(pSelCh->szPreUrlPath, szPreUrlPath);
                StrCpy(pSelCh->szIcon, szIcon);
                StrCpy(pSelCh->szLogo, szLogo);

                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

static PCHANNEL findFreeChannel(HWND hwndList)
{
    int i;
    PCHANNEL pChan;

    for (i=0, pChan=(PCHANNEL)GetWindowLongPtr(hwndList, GWLP_USERDATA);
         (i < MAX_CHAN) && (pChan != NULL); i++, pChan++)
    {
        if (ISNULL(pChan->szTitle))
        {
            ZeroMemory(pChan, sizeof(CHANNEL));
            return pChan;
        }
    }

    return NULL;
}

static void convertUrlToFile(LPTSTR pszUrl)
{
    TCHAR szFileName[MAX_PATH];
    LPTSTR pFile;

    if (ISNULL(pszUrl))
        return;

    if (StrCmpNI(pszUrl, TEXT("file:"), 5) != 0)
        return;
    else
    {
        pFile = pszUrl + 5;
        while ((*pFile == TEXT('/')) || (*pFile == TEXT(' ')))
        {
            pFile++;
        }
    }
    StrCpy(szFileName, pFile);
    StrCpy(pszUrl, szFileName);
}

static BOOL importAddChannel(HWND hDlg, LPTSTR pszDir, LPTSTR pszChan, PCHANNEL pChan, BOOL fCategory)
{
    TCHAR szDeskIni[MAX_PATH];
    DWORD dwSize = sizeof(pChan->szWebUrl);
    HKEY hkPreload;
    int i;

    if (ListBox_FindStringExact(GetDlgItem(hDlg, IDC_CHANNELLIST), -1,
        pszChan) != LB_ERR)
        return FALSE;

    PathCombine(szDeskIni, pszDir, TEXT("Desktop.Ini"));
    if (!PathFileExists(szDeskIni))
        return FALSE;

    pChan->szWebUrl[0] = TEXT('\0');
    if (fCategory)
    {
        GetPrivateProfileString(SHELLCLASSINFO, URL, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), szDeskIni );
        GetPrivateProfileString(SHELLCLASSINFO, LOGO, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), szDeskIni );
        GetPrivateProfileString(SHELLCLASSINFO, ICONFILE, TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), szDeskIni );

        // szWebUrl can be empty (this is valid according to the specs)
        if (ISNONNULL(pChan->szWebUrl))
        {
            // szWebUrl is an 8.3 name; construct the fully qualified path
            StrCpy(pChan->szPreUrlPath, pChan->szWebUrl);   // szPreUrlPath is used
                                                        // as a temp buffer
            StrCpy(pChan->szWebUrl, pszDir);
            PathAppend(pChan->szWebUrl, pChan->szPreUrlPath);
            pChan->szPreUrlPath[0] = TEXT('\0');
        }
    }
    else
    {
        GetPrivateProfileString(CHANNEL_SECT, CDFURL, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), szDeskIni );
        GetPrivateProfileString(CHANNEL_SECT, LOGO, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), szDeskIni );
        GetPrivateProfileString(CHANNEL_SECT, ICON, TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), szDeskIni );
        if (RegOpenKeyEx(HKEY_CURRENT_USER, PRELOAD_KEY, 0, KEY_DEFAULT_ACCESS, &hkPreload) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkPreload, pChan->szWebUrl, NULL, NULL, (LPBYTE)pChan->szPreUrlPath, &dwSize) != ERROR_SUCCESS)
                pChan->szPreUrlPath[0] = TEXT('\0');
            else
                convertUrlToFile(pChan->szPreUrlPath);  // strip "file://" from szPreUrlPath
            RegCloseKey(hkPreload);
        }
    }

    // categories do not need to have an .htm file according to the original channel spec
    if (!fCategory && ISNULL(pChan->szWebUrl))
    {
        ZeroMemory(pChan, sizeof(CHANNEL));
        return FALSE;
    }

    StrCpy(pChan->szTitle, pszChan);
    pChan->fCategory = fCategory;

    i = (INT) SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_ADDSTRING, 0, (LPARAM)pChan->szTitle);
    SendDlgItemMessage(hDlg, IDC_CHANNELLIST, LB_SETITEMDATA, (WPARAM)i, (LPARAM)pChan);

    if (ISNULL(pChan->szLogo))
    {
        if (!getCdfImage(pChan->szWebUrl, pChan->szLogo, WSTR_IMAGE))
            pChan->szLogo[0] = TEXT('\0');
    }
    convertUrlToFile(pChan->szLogo);

    if (ISNULL(pChan->szIcon))
    {
        if (!getCdfImage(pChan->szWebUrl, pChan->szIcon, WSTR_ICON))
            pChan->szIcon[0] = TEXT('\0');
    }
    convertUrlToFile(pChan->szIcon);

    return TRUE;
}


static BOOL enumChannels(HWND hDlg, LPTSTR pszDir, LPTSTR pszCat, LPINT pnChannels)
{
    WIN32_FIND_DATA fd;
    TCHAR           szFindPath[MAX_PATH];
    HANDLE          hFind;
    BOOL            fCategory = FALSE;

    StrCpy(szFindPath, pszDir);
    PathAppend(szFindPath, TEXT("*.*"));
    hFind = FindFirstFile(szFindPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        TCHAR szSubChan[MAX_PATH];

        // NOTE: if pszCat is empty string (""), PathAppend doesn't prefix a
        // backslash in szSubChan
        StrCpy(szSubChan, pszCat);
        PathAppend(szSubChan, fd.cFileName);
        if ((StrCmp(fd.cFileName, TEXT(".")) != 0) &&
            (StrCmp(fd.cFileName, TEXT("..")) != 0) &&
            (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            TCHAR szSubDir[MAX_PATH];

            PathCombine(szSubDir, pszDir, fd.cFileName);
            fCategory = TRUE;
            if (!enumChannels(hDlg, szSubDir, szSubChan, pnChannels))
                return FALSE;
        }
    } while (FindNextFile(hFind, &fd));

	FindClose(hFind);

    if (ISNONNULL(pszCat))
    {
        PCHANNEL pChan = findFreeChannel(GetDlgItem(hDlg, IDC_CHANNELLIST));

        if (pChan == NULL)      // MAX_CHAN reached
        {
            EnsureDialogFocus(hDlg, IDC_ADDCHANNEL, IDC_REMOVECHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDCHANNEL), FALSE);
            EnsureDialogFocus(hDlg, IDC_ADDCATEGORY, IDC_REMOVECHANNEL);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDCATEGORY), FALSE);
            return FALSE;
        }
        if (importAddChannel(hDlg, pszDir, pszCat, pChan, fCategory))
            (*pnChannels)++;
    }

    return TRUE;
}

static int importChannels(HWND hDlg)
{
    DWORD dwLength, dwType;
    TCHAR szChanPath[MAX_PATH];
    TCHAR szChannelsDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    HKEY hkFav;
    int  nChannels = 0;

    SetCursor(LoadCursor(NULL, IDC_WAIT) );

    // build path to current user favorites
    dwLength = MAX_PATH;
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
            0, KEY_DEFAULT_ACCESS, &hkFav ) != ERROR_SUCCESS)
    {
        return 0;
    }

    if (RegQueryValueEx( hkFav, TEXT("Favorites"), NULL, &dwType, (LPBYTE) szChanPath, &dwLength ) != ERROR_SUCCESS)
    {
        RegCloseKey(hkFav);
        return 0;
    }
    RegCloseKey(hkFav);

    // write info about Regular Channels

    LoadString( g_hInst, IDS_CHANNELSDIR, szChannelsDir, ARRAYSIZE(szChannelsDir) );
    PathCombine(szTemp, szChanPath, szChannelsDir);

     // The following scenario would arise if you don't upgrade IE5 over IE4 and
    // add a channel.  In this case, IE5 would add the channel under the
    // Favorites folder itself (szChanPath contains the path to the Favorites
    // folder)

    if (!PathFileExists(szTemp))
        StrCpy(szTemp, szChanPath);

    enumChannels(hDlg, szTemp, TEXT(""), &nChannels);

    return nChannels;
}

static void channels_InitHelper(HWND hDlg, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir, LPCTSTR pcszCustIns,
                                WORD idList, DWORD dwPlatformId, BOOL fIgnoreOffline)
{
    TCHAR    szTempBuf[16];
    PCHANNEL paChannels;
    PCHANNEL paOldChannels;
    int      i;

    ASSERT(((pcszAltDir == NULL) && (pcszWorkDir == NULL)) || 
        ((pcszAltDir != NULL) && (pcszWorkDir != NULL)));

    g_dwPlatformId = dwPlatformId;

    SendDlgItemMessage(hDlg, idList, LB_RESETCONTENT, 0, 0);

    if ((paChannels = (PCHANNEL)CoTaskMemAlloc(sizeof(CHANNEL) * MAX_CHAN)) == NULL)
        return;

    ZeroMemory(paChannels, sizeof(CHANNEL) * MAX_CHAN);
    paOldChannels = (PCHANNEL)SetWindowLongPtr(GetDlgItem(hDlg, idList), GWLP_USERDATA, (LONG_PTR)paChannels);
    
    // delete previous allocation(mainly for profile manager)
    if (paOldChannels != NULL)
        CoTaskMemFree(paOldChannels);

    if (GetPrivateProfileSection(CHANNEL_ADD, szTempBuf, ARRAYSIZE(szTempBuf), pcszCustIns))
    {
        PCHANNEL pChan;
        TCHAR    szChTitleParm[16],
                 szChUrlParm[16],
                 szChPreUrlParm[32],
                 szChIconParm[32],
                 szChBmpParm[32],
                 szChOfflineParm[16];
        int      j;

        if (StrCmpI(szTempBuf, TEXT("No Channels")) == 0)
            return;

        for (i = 0, pChan = paChannels; i < MAX_CHAN; i++, pChan++)
        {
            wnsprintf(szChUrlParm, ARRAYSIZE(szChUrlParm),   TEXT("%s%u"),  CDFURL,  i);
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"),  CHTITLE, i);

            if (GetPrivateProfileString(CHANNEL_ADD, szChTitleParm, TEXT(""), pChan->szTitle, ARRAYSIZE(pChan->szTitle), pcszCustIns) == 0)
                break;

            GetPrivateProfileString(CHANNEL_ADD, szChUrlParm, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), pcszCustIns);

            wnsprintf(szChPreUrlParm, ARRAYSIZE(szChPreUrlParm), TEXT("%s%u"), CHPREURLPATH, i);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm),   TEXT("%s%u"), CHICON,       i);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm),    TEXT("%s%u"), CHBMP,        i);

            GetPrivateProfileString(CHANNEL_ADD, szChPreUrlParm, TEXT(""), pChan->szPreUrlPath, ARRAYSIZE(pChan->szPreUrlPath), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChIconParm,TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChBmpParm, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), pcszCustIns);

            pChan->fOffline = FALSE;
            if (!fIgnoreOffline) {
                wnsprintf(szChOfflineParm, ARRAYSIZE(szChOfflineParm), TEXT("%s%u"), IK_CHL_OFFLINE, i);
                pChan->fOffline = (BOOL)GetPrivateProfileInt(IS_CHANNEL_ADD, szChOfflineParm, (int)FALSE, pcszCustIns);
            }

            // delete the files from an alternative dir (desktop dir in profmgr, ieaklite dir
            // in wizard), making sure to copy them to the work dir first 

            if (pcszAltDir != NULL)
            {
                MoveFileToWorkDir(PathFindFileName(pChan->szPreUrlPath), pcszAltDir, pcszWorkDir, TRUE);
                MoveFileToWorkDir(PathFindFileName(pChan->szIcon), pcszAltDir, pcszWorkDir);
                MoveFileToWorkDir(PathFindFileName(pChan->szLogo), pcszAltDir, pcszWorkDir);
            }

            j = (int)SendDlgItemMessage( hDlg, idList, LB_ADDSTRING, 0, (LPARAM) pChan->szTitle);
            SendDlgItemMessage(hDlg, idList, LB_SETITEMDATA, (WPARAM)j, (LPARAM)pChan);
        }

        for (i = 0; i < MAX_CHAN; i++, pChan++)
        {
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"), CATTITLE, i);

            if (GetPrivateProfileString(CHANNEL_ADD, szChTitleParm, TEXT(""), pChan->szTitle, ARRAYSIZE(pChan->szTitle), pcszCustIns) == 0)
                break;

            pChan->fCategory = TRUE;
            wnsprintf(szChUrlParm, ARRAYSIZE(szChUrlParm),  TEXT("%s%u"), CATHTML, i);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm), TEXT("%s%u"), CATICON, i);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm),  TEXT("%s%u"), CATBMP,  i);

            GetPrivateProfileString(CHANNEL_ADD, szChUrlParm, TEXT(""), pChan->szWebUrl, ARRAYSIZE(pChan->szWebUrl), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChIconParm, TEXT(""), pChan->szIcon, ARRAYSIZE(pChan->szIcon), pcszCustIns);
            GetPrivateProfileString(CHANNEL_ADD, szChBmpParm, TEXT(""), pChan->szLogo, ARRAYSIZE(pChan->szLogo), pcszCustIns);
            pChan->fOffline = FALSE;

            // delete the files from the desktop dir
            if (pcszAltDir != NULL)
            {
                MoveFileToWorkDir(PathFindFileName(pChan->szWebUrl), pcszAltDir, pcszWorkDir, TRUE);
                MoveFileToWorkDir(PathFindFileName(pChan->szIcon), pcszAltDir, pcszWorkDir, TRUE);
                MoveFileToWorkDir(PathFindFileName(pChan->szLogo), pcszAltDir, pcszWorkDir, TRUE);
            }

            j = (int)SendDlgItemMessage( hDlg, idList, LB_ADDSTRING, 0, (LPARAM) pChan->szTitle);
            SendDlgItemMessage(hDlg, idList, LB_SETITEMDATA, (WPARAM)j, (LPARAM)pChan);
        }
    }

    SendDlgItemMessage(hDlg, idList, LB_SETCURSEL, (WPARAM)-1, 0);
}

static void writeIE4Info(HANDLE hInf, int index, PCHANNEL pChan)
{
    static const TCHAR c_szInfTitle[]      = TEXT("HKCU,\"%s\",\"Title\",,\"%s\"\r\n");
    static const TCHAR c_szInfURL_File[]   = TEXT("HKCU,\"%s\",\"URL\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfURL_HTTP[]   = TEXT("HKCU,\"%s\",\"URL\",,\"%s\"\r\n");
    static const TCHAR c_szInfPreloadUrl[] = TEXT("HKCU,\"%s\",\"PreloadURL\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfLogo_File[]  = TEXT("HKCU,\"%s\",\"Logo\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfLogo_HTTP[]  = TEXT("HKCU,\"%s\",\"Logo\",,\"%s\"\r\n");
    static const TCHAR c_szInfIcon_File[]  = TEXT("HKCU,\"%s\",\"Icon\",,\"%s%%10%%\\web\\%s\"\r\n");
    static const TCHAR c_szInfIcon_HTTP[]  = TEXT("HKCU,\"%s\",\"Icon\",,\"%s\"\r\n");
    static const TCHAR c_szInfCategory[]   = TEXT("HKCU,\"%s\",\"Category\",65537,1\r\n");

    TCHAR szKey[MAX_PATH];
    TCHAR szInfLine[MAX_PATH];
    TCHAR szFileUrlPrefix[ARRAYSIZE(FILEPREFIX)] = TEXT("");
    DWORD dwSize;

    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%%ChannelKey%%\\ieakChl%u"), index);

    dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfTitle, szKey, pChan->szTitle);
    WriteStringToFile(hInf, szInfLine, dwSize);

    if (pChan->fCategory)
    {
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfCategory, szKey);
        WriteStringToFile(hInf, szInfLine, dwSize);
    }
    else
        StrCpy(szFileUrlPrefix, FILEPREFIX);

    // BUGBUG: (pritobla) For a category, szWebUrl can be empty; we should take care of this case
    if (PathIsFileOrFileURL(pChan->szWebUrl))
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfURL_File, szKey, szFileUrlPrefix, PathFindFileName(pChan->szWebUrl));
    else
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfURL_HTTP, szKey, pChan->szWebUrl);
    WriteStringToFile(hInf, szInfLine, dwSize);

    if (ISNONNULL(pChan->szPreUrlPath))
    {
        dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfPreloadUrl, szKey, szFileUrlPrefix, PathFindFileName(pChan->szPreUrlPath));
        WriteStringToFile(hInf, szInfLine, dwSize);
    }

    if (ISNONNULL(pChan->szLogo))
    {
        if (PathIsFileOrFileURL(pChan->szLogo))
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfLogo_File, szKey, szFileUrlPrefix, PathFindFileName(pChan->szLogo));
        else
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfLogo_HTTP, szKey, pChan->szLogo);
        WriteStringToFile(hInf, szInfLine, dwSize);
    }

    if (ISNONNULL(pChan->szIcon))
    {
        if (PathIsFileOrFileURL(pChan->szIcon))
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfIcon_File, szKey, szFileUrlPrefix, PathFindFileName(pChan->szIcon));
        else
            dwSize = wnsprintf(szInfLine, ARRAYSIZE(szInfLine), c_szInfIcon_HTTP, szKey, pChan->szIcon);
        WriteStringToFile(hInf, szInfLine, dwSize);
    }
}

// The ie4chnls.inf is not made as a template inf file because in the GPE context the
// template inf's will not be available.
static TCHAR szIE4Buf[] = TEXT("[Version]\r\n\
Signature=\"$CHICAGO$\"\r\n\
AdvancedINF=2.5\r\n\r\n\
[DefaultInstall]\r\n\
RequiredEngine=Setupapi,\"Couldn't find Setupapi.dll\"\r\n\
Delreg=IeakChan.DelReg\r\n\
Addreg=IeakChan.AddReg\r\n\
RegisterOCXs=IeakChan.Register\r\n\
DoShellRefresh=1\r\n\r\n\
[IeakChan.Register]\r\n\
%11%\\webcheck.dll,IN,Policy\r\n\r\n\
[IeakChan.DelReg]\r\n\
HKCU,\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\CompletedModifications\",\"ChannelDefault\",,,\r\n\r\n\
[Strings]\r\n\
DiskName=\"Channel Files\"\r\n\
ChannelKey=\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Modifications\\ChannelDefault\\AddChannels\"\r\n\
SubKey=\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Modifications\\ChannelDefault\\AddSubscriptions\"\r\n\
CleanKey=\"Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Modifications\\ChannelDefault\\RemoveAllChannels\"\r\n\r\n\0");

static void channels_SaveHelper(HWND hwndList, LPCTSTR pcszChanDir, LPCTSTR pcszCustIns, DWORD dwMode)
{
    PCHANNEL pChan;
    PCHANNEL paChannel;
    TCHAR    szIE4ChnlsInf[MAX_PATH],
             szChTitleParm[32],
             szChUrlParm[32],
             szChPreUrlParm[32],
             szChBmpParm[32],
             szChIconParm[32],
             szChPreUrlNameParm[32],
             szChBmpNameParm[32],
             szChOfflineParm[16],
             szChIconNameParm[32],
             szTempPath[MAX_PATH];
    LPTSTR   pWrk;
    HANDLE   hInf = NULL;
    DWORD    dwSize;
    int      i, j, k;
    BOOL     fChan = FALSE;
    GUID     guid;
    TCHAR    szChlSizeLine[MAX_PATH],
             szOemSizeLine[MAX_PATH];
    TCHAR    szChlSize[5];
    TCHAR    szOemSize[5];
    BYTE     bData;
    LPTSTR   pszBuf;
    HKEY     hk;

    // create a temp path to copy all files to temporarily

    GetTempPath(countof(szTempPath), szTempPath);
    if (CoCreateGuid(&guid) == NOERROR)
    {
        TCHAR szGUID[128];

        CoStringFromGUID(guid, szGUID, countof(szGUID));
        PathAppend(szTempPath, szGUID);
    }
    else
        PathAppend(szTempPath, TEXT("IEAKCHAN"));

    PathCreatePath(szTempPath);

    WritePrivateProfileString(CHANNEL_ADD, NULL, NULL, pcszCustIns);
    WritePrivateProfileString(NULL, NULL, NULL, pcszCustIns);

    PathCombine(szIE4ChnlsInf, szTempPath, TEXT("ie4chnls.inf"));

    //----- Prepare Channel Size and OEM Size -----
    StrCpy(szChlSize, TEXT("0x0B"));
    StrCpy(szOemSize, TEXT("0x00"));
    if (RegOpenKeyEx(HKEY_CURRENT_USER, DESKTOPKEY, 0, KEY_DEFAULT_ACCESS, &hk) == ERROR_SUCCESS) {
        dwSize = sizeof(bData);
        if (RegQueryValueEx(hk, CHANNELSIZE, NULL, NULL, &bData, &dwSize) == ERROR_SUCCESS) {
            szChlSize[2] = TEXT('\0');
            AppendCommaHex(szChlSize, bData, 0);
        }

        dwSize = sizeof(bData);
        if (RegQueryValueEx(hk, OEMSIZE, NULL, NULL, &bData, &dwSize) == ERROR_SUCCESS) {
            szOemSize[2] = TEXT('\0');
            AppendCommaHex(szOemSize, bData, 0);
        }
        RegCloseKey(hk);
    }
    wnsprintf(szChlSizeLine, ARRAYSIZE(szChlSizeLine), REG_KEY_CHAN_SIZE, szChlSize);
    wnsprintf(szOemSizeLine, ARRAYSIZE(szOemSizeLine), REG_KEY_OEM_SIZE,  szOemSize);

    //----- Write the standard goo ---
    pszBuf = (LPTSTR)LocalAlloc(LPTR, INF_BUF_SIZE*sizeof(TCHAR));
    if (pszBuf == NULL)
        return;

    dwSize = wnsprintf(pszBuf, INF_BUF_SIZE, TEXT("\r\n[%s]\r\n%s\r\n%s\r\n\r\n"), IEAKCHANADDREG, szChlSizeLine, szOemSizeLine);

    hInf = CreateFile(szIE4ChnlsInf, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, NULL, NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        LocalFree(pszBuf);
        return;
    }

    SetFilePointer(hInf, 0, NULL, FILE_BEGIN);
    WriteStringToFile(hInf, szIE4Buf, ARRAYSIZE(szIE4Buf));
    SetFilePointer(hInf, 0, NULL, FILE_END);
    WriteStringToFile(hInf, pszBuf, dwSize);
    LocalFree(pszBuf);

    paChannel = (PCHANNEL)GetWindowLongPtr(hwndList, GWLP_USERDATA);

    for (i = 0, j = 0, k = 0, pChan = paChannel; (i < MAX_CHAN) && (pChan != NULL); i++, pChan++)
    {
        if (ISNULL(pChan->szTitle))
            continue;

        if (!pChan->fCategory)
        {
            fChan = TRUE;
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"),  CHTITLE, j);
            wnsprintf(szChUrlParm, ARRAYSIZE(szChUrlParm),   TEXT("%s%u"),  CDFURL,  j);

            WritePrivateProfileString(CHANNEL_ADD, szChTitleParm, pChan->szTitle, pcszCustIns);
            WritePrivateProfileString(CHANNEL_ADD, szChUrlParm,   pChan->szWebUrl, pcszCustIns);

            writeIE4Info(hInf, i, pChan);

            wnsprintf(szChPreUrlParm, ARRAYSIZE(szChPreUrlParm), TEXT("%s%u"), CHPREURLPATH, j);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm), TEXT("%s%u"), CHICON, j);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm), TEXT("%s%u"), CHBMP, j);
            wnsprintf(szChPreUrlNameParm, ARRAYSIZE(szChPreUrlNameParm), TEXT("%s%u"), CHPREURLNAME, j);
            wnsprintf(szChIconNameParm, ARRAYSIZE(szChIconNameParm), TEXT("%s%u"), CHICONNAME, j);
            wnsprintf(szChBmpNameParm, ARRAYSIZE(szChBmpNameParm), TEXT("%s%u"), CHBMPNAME, j);
            wnsprintf(szChOfflineParm, ARRAYSIZE(szChOfflineParm), TEXT("%s%u"), IK_CHL_OFFLINE, j);

            WritePrivateProfileString(CHANNEL_ADD, szChPreUrlParm, pChan->szPreUrlPath, pcszCustIns);
            pWrk = StrRChr(pChan->szPreUrlPath, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChPreUrlNameParm, pWrk, pcszCustIns );

                if (PathFileExists(pChan->szPreUrlPath))
                {
                    CopyFileToDir(pChan->szPreUrlPath, szTempPath);
                    CopyHtmlImgs(pChan->szPreUrlPath, szTempPath, NULL, NULL);
                }
                else
                {
                   TCHAR szFile[MAX_PATH];

                   PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szPreUrlPath));
                   CopyFileToDir(szFile, szTempPath);
                   CopyHtmlImgs(szFile, szTempPath, NULL, NULL);
                }
            }

            WritePrivateProfileString(CHANNEL_ADD, szChIconParm, pChan->szIcon, pcszCustIns);
            pWrk = StrRChr(pChan->szIcon, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChIconNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szIcon))
                    CopyFileToDir(pChan->szIcon, szTempPath);
                else
                {
                   TCHAR szFile[MAX_PATH];

                   PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szIcon));
                   CopyFileToDir(szFile, szTempPath);
                }
            }

            WritePrivateProfileString(CHANNEL_ADD, szChBmpParm, pChan->szLogo, pcszCustIns);
            pWrk = StrRChr(pChan->szLogo, NULL, TEXT('\\'));
            if (pWrk)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChBmpNameParm, pWrk, pcszCustIns );
                
                if (PathFileExists(pChan->szLogo))
                    CopyFileToDir(pChan->szLogo, szTempPath);
                else
                {
                   TCHAR szFile[MAX_PATH];

                   PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szLogo));
                   CopyFileToDir(szFile, szTempPath);
                }
            }

            if (pChan->fOffline)
                // NOTE: (andrewgu) no need to write NULL on FALSE as the whole section was
                // wiped out up above.
                WritePrivateProfileString(IS_CHANNEL_ADD, szChOfflineParm, TEXT("1"), pcszCustIns);
            
            j++;
        }
        else
        {
            fChan = TRUE;
            wnsprintf(szChTitleParm, ARRAYSIZE(szChTitleParm), TEXT("%s%u"), CATTITLE, k);
            WritePrivateProfileString(CHANNEL_ADD, szChTitleParm, pChan->szTitle, pcszCustIns);

            writeIE4Info(hInf, i, pChan);

            wnsprintf(szChPreUrlParm, ARRAYSIZE(szChPreUrlParm), TEXT("%s%u"), CATHTML, k);
            wnsprintf(szChIconParm, ARRAYSIZE(szChIconParm), TEXT("%s%u"), CATICON, k);
            wnsprintf(szChBmpParm, ARRAYSIZE(szChBmpParm), TEXT("%s%u"), CATBMP, k);
            wnsprintf(szChPreUrlNameParm, ARRAYSIZE(szChPreUrlNameParm), TEXT("%s%u"), CATHTMLNAME, k);
            wnsprintf(szChIconNameParm, ARRAYSIZE(szChIconNameParm), TEXT("%s%u"), CATICONNAME, k);
            wnsprintf(szChBmpNameParm, ARRAYSIZE(szChBmpNameParm), TEXT("%s%u"), CATBMPNAME, k);

            WritePrivateProfileString(CHANNEL_ADD, szChPreUrlParm, pChan->szWebUrl, pcszCustIns);
            pWrk = StrRChr(pChan->szWebUrl, NULL, TEXT('\\'));
            if (pWrk != NULL)         // make sure we're not copying over the file as hidden/system
            {
                DWORD dwFileAttrib;

                dwFileAttrib = GetFileAttributes(pChan->szWebUrl);
                SetFileAttributes(pChan->szWebUrl, FILE_ATTRIBUTE_NORMAL);
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChPreUrlNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szWebUrl))
                    CopyFileToDir(pChan->szWebUrl, szTempPath);
                else
                {
                    TCHAR szFile[MAX_PATH];
                    
                    PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szWebUrl));
                    CopyFileToDir(szFile, szTempPath);
                }
                SetFileAttributes(pChan->szWebUrl, dwFileAttrib);
            }

            WritePrivateProfileString(CHANNEL_ADD, szChIconParm, pChan->szIcon, pcszCustIns);
            pWrk = StrRChr(pChan->szIcon, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChIconNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szIcon))
                    CopyFileToDir(pChan->szIcon, szTempPath);
                else
                {
                    TCHAR szFile[MAX_PATH];
                    
                    PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szIcon));
                    CopyFileToDir(szFile, szTempPath);
                }
            }

            WritePrivateProfileString(CHANNEL_ADD, szChBmpParm, pChan->szLogo, pcszCustIns);
            pWrk = StrRChr(pChan->szLogo, NULL, TEXT('\\'));
            if (pWrk != NULL)
            {
                pWrk++;
                WritePrivateProfileString( CHANNEL_ADD, szChBmpNameParm, pWrk, pcszCustIns );
                if (PathFileExists(pChan->szLogo))
                    CopyFileToDir(pChan->szLogo, szTempPath);
                else
                {
                    TCHAR szFile[MAX_PATH];
                    
                    PathCombine(szFile, pcszChanDir, PathFindFileName(pChan->szLogo));
                    CopyFileToDir(szFile, szTempPath);
                }
            }

            k++;
        }
    }

    PathRemovePath(pcszChanDir);
        
    if (!fChan)
        WritePrivateProfileSection(CHANNEL_ADD, TEXT("No Channels\0"), pcszCustIns);
    else
    {
        // copy over all the files from the temp dir back to the working dir
        PathCreatePath(pcszChanDir);
        CopyFileToDir(szTempPath, pcszChanDir);
    }

    WritePrivateProfileString(NULL, NULL, NULL, pcszCustIns);

    CloseHandle(hInf);

    if (fChan)
    {
        TCHAR szBuf[MAX_PATH];

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,ie4chnls.inf,%s"), DEFAULT_INSTALL);
        WritePrivateProfileString(EXTREGINF, TEXT("channels"), szBuf, pcszCustIns);
    }
    else
    {
        WritePrivateProfileString(EXTREGINF, TEXT("channels"), NULL, pcszCustIns);
        DeleteFile(szIE4ChnlsInf);
    }

    PathRemovePath(szTempPath);

    // do not free for profile manager since we might still be on the page due to file save
    if (!HasFlag(dwMode, IEM_PROFMGR) && (paChannel != NULL))
    {
        CoTaskMemFree(paChannel);
        SetWindowLong(hwndList, GWLP_USERDATA, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\btoolbar.cpp ===
#include "precomp.h"
#include "btoolbar.h"

static DWORD bToolbar_InitHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir);
static void bToolbar_SaveHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszBToolbarDir, DWORD dwMode);
static PBTOOLBAR findBToolbar(HWND hwndList);
static BOOL CALLBACK editBToolbarProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

DWORD WINAPI BToolbar_InitA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszAltDir, LPCSTR pcszWorkDir)
{
    USES_CONVERSION;

    return bToolbar_InitHelper(hwndList, A2CT(pcszCustIns), A2CT(pcszAltDir), A2CT(pcszWorkDir));
}

DWORD WINAPI BToolbar_InitW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszAltDir, LPCWSTR pcwszWorkDir)
{
    USES_CONVERSION;

    return bToolbar_InitHelper(hwndList, W2CT(pcwszCustIns), W2CT(pcwszAltDir), W2CT(pcwszWorkDir));
}

void WINAPI BToolbar_Remove(HWND hwndList)
{
    PBTOOLBAR pBToolbar;
    int i;

    i = ListBox_GetCurSel(hwndList);
    pBToolbar = (PBTOOLBAR)ListBox_GetItemData(hwndList, (WPARAM)i);
    pBToolbar->fDeleted = TRUE;
    ListBox_DeleteString(hwndList, (WPARAM)i);
    if (ListBox_SetCurSel(hwndList, (WPARAM)i) == LB_ERR)          // last item in the list
    {
        if (ListBox_SetCurSel(hwndList, (WPARAM)(i-1)) == LB_ERR)  // no more items left
        {
            int rgids[] = { IDC_EDITBTOOLBAR, IDC_REMOVEBTOOLBAR };

            EnsureDialogFocus(GetParent(hwndList), rgids, countof(rgids), IDC_ADDBTOOLBAR);
            DisableDlgItems  (GetParent(hwndList), rgids, countof(rgids));
        }
    }

    EnableWindow(GetDlgItem(GetParent(hwndList), IDC_ADDBTOOLBAR), TRUE);
}

void WINAPI BToolbar_Edit(HWND hwndList, BOOL fAdd)
{
    PBTOOLBAR pBToolbar;
    int i = -1;

    if (fAdd)
        pBToolbar = findBToolbar(hwndList);
    else
    {
        i = ListBox_GetCurSel(hwndList);
        pBToolbar = (PBTOOLBAR)ListBox_GetItemData(hwndList, (WPARAM)i);
    }

    if (pBToolbar == NULL)
    {
        if (fAdd) {
            // REVIEW: (andrewgu) from the code perspective it looks like this can only happen
            // when maximum number of toolbar buttons reached. if this is the case it's high time
            // to delete some.
            EnsureDialogFocus(GetParent(hwndList), IDC_ADDBTOOLBAR, IDC_REMOVEBTOOLBAR);
            DisableDlgItem   (GetParent(hwndList), IDC_ADDBTOOLBAR);
        }
        return;
    }

    if (DialogBoxParam( g_hInst, MAKEINTRESOURCE(IDD_BTOOLBARPOPUP),
        GetParent(hwndList), (DLGPROC)editBToolbarProc, (LPARAM)pBToolbar ) == IDOK)
    {
        if (!fAdd)
            ListBox_DeleteString(hwndList, (WPARAM)i);

        i = ListBox_AddString(hwndList, (LPARAM) pBToolbar->szCaption);
        ListBox_SetItemData(hwndList, (WPARAM)i, (LPARAM)pBToolbar);
        ListBox_SetCurSel(hwndList, (WPARAM)i);
        ListBox_SetTopIndex(hwndList, (WPARAM)i);
        EnableWindow(GetDlgItem(GetParent(hwndList), IDC_REMOVEBTOOLBAR), TRUE);
        EnableWindow(GetDlgItem(GetParent(hwndList), IDC_EDITBTOOLBAR), TRUE);
    }
}

void  WINAPI BToolbar_SaveA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszBToolbarDir, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    bToolbar_SaveHelper(hwndList, A2CT(pcszCustIns), A2CT(pcszBToolbarDir), dwMode);
}

void  WINAPI BToolbar_SaveW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszBToolbarDir, DWORD dwMode /*= IEM_NEUTRAL*/)
{
    USES_CONVERSION;

    bToolbar_SaveHelper(hwndList, W2CT(pcwszCustIns), W2CT(pcwszBToolbarDir), dwMode);
}

static DWORD bToolbar_InitHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszAltDir, LPCTSTR pcszWorkDir)
{
    PBTOOLBAR pBToolbar;
    PBTOOLBAR paBToolbar;
    PBTOOLBAR paOldBToolbar;
    TCHAR szBToolbarTextParam[32];
    TCHAR szBToolbarIcoParam[32];
    TCHAR szBToolbarActionParam[32];
    TCHAR szBToolbarHotIcoParam[32];
//  TCHAR szBToolbarToolTextParam[32];
    TCHAR szBToolbarShowParam[32];
    int i, j;

    ASSERT(((pcszAltDir == NULL) && (pcszWorkDir == NULL)) || 
        ((pcszAltDir != NULL) && (pcszWorkDir != NULL)));

    ListBox_ResetContent(hwndList);

    if ((paBToolbar = (PBTOOLBAR)CoTaskMemAlloc(sizeof(BTOOLBAR) * MAX_BTOOLBARS)) == NULL)
        return 0;

    ZeroMemory(paBToolbar, sizeof(BTOOLBAR) * MAX_BTOOLBARS);

    for (i=0, pBToolbar = paBToolbar; i < MAX_BTOOLBARS; i++, pBToolbar++)
    {
        wnsprintf(szBToolbarTextParam, ARRAYSIZE(szBToolbarTextParam), TEXT("%s%i"), IK_BTCAPTION, i);
        wnsprintf(szBToolbarIcoParam, ARRAYSIZE(szBToolbarIcoParam), TEXT("%s%i"), IK_BTICON, i);
        wnsprintf(szBToolbarActionParam, ARRAYSIZE(szBToolbarActionParam), TEXT("%s%i"), IK_BTACTION, i);
        wnsprintf(szBToolbarHotIcoParam, ARRAYSIZE(szBToolbarHotIcoParam), TEXT("%s%i"), IK_BTHOTICO, i);
//      wnsprintf(szBToolbarToolTextParam, ARRAYSIZE(szBToolbarToolTextParam), TEXT("%s%i"), IK_BTTOOLTIP, i);
        wnsprintf(szBToolbarShowParam, ARRAYSIZE(szBToolbarShowParam), TEXT("%s%i"), IK_BTSHOW, i);

        if (GetPrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, TEXT(""),
            pBToolbar->szCaption, ARRAYSIZE(pBToolbar->szCaption), pcszCustIns) == 0)
            break;

        GetPrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, TEXT(""), pBToolbar->szIcon, ARRAYSIZE(pBToolbar->szIcon), pcszCustIns);
        GetPrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, TEXT(""), pBToolbar->szAction, ARRAYSIZE(pBToolbar->szAction), pcszCustIns);
        GetPrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, TEXT(""), pBToolbar->szHotIcon, ARRAYSIZE(pBToolbar->szHotIcon), pcszCustIns);
//      GetPrivateProfileString(IS_BTOOLBARS, szBToolbarToolTextParam, TEXT(""), pBToolbar->szToolTipText, ARRAYSIZE(pBToolbar->szToolTipText), pcszCustIns);
        pBToolbar->fShow = (BOOL)GetPrivateProfileInt(IS_BTOOLBARS, szBToolbarShowParam, 1, pcszCustIns);

        if (pcszAltDir != NULL)
        {
            MoveFileToWorkDir(PathFindFileName(pBToolbar->szIcon), pcszAltDir, pcszWorkDir);
            MoveFileToWorkDir(PathFindFileName(pBToolbar->szHotIcon), pcszAltDir, pcszWorkDir);
        }

        j = ListBox_AddString(hwndList, (LPARAM) pBToolbar->szCaption );
        ListBox_SetItemData(hwndList, (WPARAM)j, (LPARAM)pBToolbar);
    }

    paOldBToolbar = (PBTOOLBAR)SetWindowLongPtr(hwndList, GWLP_USERDATA, (LONG_PTR)paBToolbar);

    // delete previous allocation(mainly for profile manager)
    if (paOldBToolbar != NULL)
        CoTaskMemFree(paOldBToolbar);

    return i;
}

static void bToolbar_SaveHelper(HWND hwndList, LPCTSTR pcszCustIns, LPCTSTR pcszBToolbarDir, DWORD dwMode)
{
    TCHAR szBToolbarTextParam[32];
    TCHAR szBToolbarIcoParam[32];
    TCHAR szBToolbarActionParam[32];
    TCHAR szBToolbarHotIcoParam[32];
//  TCHAR szBToolbarToolTextParam[32];
    TCHAR szBToolbarShowParam[32];
    TCHAR szTempPath[MAX_PATH];
    PBTOOLBAR pBToolbar;
    PBTOOLBAR paBToolbar;
    GUID guid;
    int i, j;

    // create a temp path to copy all files to temporarily

    GetTempPath(countof(szTempPath), szTempPath);
    if (CoCreateGuid(&guid) == NOERROR)
    {
        TCHAR szGUID[128];

        CoStringFromGUID(guid, szGUID, countof(szGUID));
        PathAppend(szTempPath, szGUID);
    }
    else
        PathAppend(szTempPath, TEXT("IEAKTOOL"));

    PathCreatePath(szTempPath);

    WritePrivateProfileString(IS_BTOOLBARS, NULL, NULL, pcszCustIns);
    WritePrivateProfileString(NULL, NULL, NULL, pcszCustIns);

    paBToolbar = (PBTOOLBAR)GetWindowLongPtr(hwndList, GWLP_USERDATA);
    for (i = 0, j = 0, pBToolbar = paBToolbar; (i < MAX_BTOOLBARS) && (pBToolbar != NULL); i++, pBToolbar++ )
    {
        if (pBToolbar->fDeleted || ISNULL(pBToolbar->szCaption))
            continue;

        wnsprintf(szBToolbarTextParam, ARRAYSIZE(szBToolbarTextParam), TEXT("%s%i"), IK_BTCAPTION, j);
        wnsprintf(szBToolbarIcoParam, ARRAYSIZE(szBToolbarIcoParam), TEXT("%s%i"), IK_BTICON, j);
        wnsprintf(szBToolbarActionParam, ARRAYSIZE(szBToolbarActionParam), TEXT("%s%i"), IK_BTACTION, j);
        wnsprintf(szBToolbarHotIcoParam, ARRAYSIZE(szBToolbarHotIcoParam), TEXT("%s%i"), IK_BTHOTICO, j);
//      wnsprintf(szBToolbarToolTextParam, ARRAYSIZE(szBToolbarToolTextParam), TEXT("%s%i"), IK_BTTOOLTIP, j);
        wnsprintf(szBToolbarShowParam, ARRAYSIZE(szBToolbarShowParam), TEXT("%s%i"), IK_BTSHOW, j);

        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarTextParam, pBToolbar->szCaption, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarActionParam, pBToolbar->szAction, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarIcoParam, pBToolbar->szIcon, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarHotIcoParam, pBToolbar->szHotIcon, pcszCustIns);
//      WritePrivateProfileString(IS_BTOOLBARS, szBToolbarToolTextParam, pBToolbar->szToolTipText, pcszCustIns);
        WritePrivateProfileString(IS_BTOOLBARS, szBToolbarShowParam, pBToolbar->fShow ? TEXT("1") : TEXT("0"), pcszCustIns);

        if (PathFileExists(pBToolbar->szIcon))
            CopyFileToDir(pBToolbar->szIcon, szTempPath);
        else
        {
            TCHAR szFile[MAX_PATH];
            
            PathCombine(szFile, pcszBToolbarDir, PathFindFileName(pBToolbar->szIcon));
            CopyFileToDir(szFile, szTempPath);
        }

        if (PathFileExists(pBToolbar->szHotIcon))
            CopyFileToDir(pBToolbar->szHotIcon, szTempPath);
        else
        {
            TCHAR szFile[MAX_PATH];
            
            PathCombine(szFile, pcszBToolbarDir, PathFindFileName(pBToolbar->szHotIcon));
            CopyFileToDir(szFile, szTempPath);
        }
        j++;
    }

    // do not free for profile manager since we might still be on the page due to file save
    if (!HasFlag(dwMode, IEM_PROFMGR) && (paBToolbar != NULL))
    {
        CoTaskMemFree(paBToolbar);
        SetWindowLong(hwndList, GWLP_USERDATA, NULL);
    }

    PathRemovePath(pcszBToolbarDir);
    PathCreatePath(pcszBToolbarDir);
    CopyFileToDir(szTempPath, pcszBToolbarDir);
    PathRemovePath(szTempPath);
}

static PBTOOLBAR findBToolbar(HWND hwndList)
{
    PBTOOLBAR pBToolbar;
    int i;

    for (pBToolbar = (PBTOOLBAR)GetWindowLongPtr(hwndList, GWLP_USERDATA), i = 0; 
         (i < MAX_BTOOLBARS) && (pBToolbar != NULL); i++, pBToolbar++)
    {
        if (pBToolbar->fDeleted || ISNULL(pBToolbar->szCaption))
        {
            ZeroMemory(pBToolbar, sizeof (BTOOLBAR));
            pBToolbar->fShow = TRUE;
            return pBToolbar;
        }
    }

    return NULL;
}

static BOOL CALLBACK editBToolbarProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PBTOOLBAR pBToolbar;
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pBToolbar = (PBTOOLBAR)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pBToolbar);
        EnableDBCSChars(hDlg, IDE_BTCAPTION);
        EnableDBCSChars(hDlg, IDE_BTACTION);
//      EnableDBCSChars(hDlg, IDE_BTTOOLTEXT);
        EnableDBCSChars(hDlg, IDE_BTICON);
        EnableDBCSChars(hDlg, IDE_BTHOTICON);

        Edit_LimitText(GetDlgItem(hDlg, IDE_BTCAPTION), MAX_BTOOLBAR_TEXT_LENGTH);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTACTION), _MAX_FNAME);
//      Edit_LimitText(GetDlgItem(hDlg, IDE_BTTOOLTEXT), ARRAYSIZE(pBToolbar->szToolTipText)-1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTICON), _MAX_FNAME);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BTHOTICON), _MAX_FNAME);

        SetDlgItemText(hDlg, IDE_BTCAPTION, pBToolbar->szCaption);
        SetDlgItemText(hDlg, IDE_BTACTION, pBToolbar->szAction);
//      SetDlgItemText(hDlg, IDE_BTTOOLTEXT, pBToolbar->szToolTipText);
        SetDlgItemText(hDlg, IDE_BTICON, pBToolbar->szIcon);
        SetDlgItemText(hDlg, IDE_BTHOTICON, pBToolbar->szHotIcon);
        CheckDlgButton(hDlg, IDC_BUTTONSTATE,
            pBToolbar->fShow ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_BROWSEBTICO:
            case IDC_BROWSEBTHOTICO:
                if (BrowseForFile(hDlg, szTemp, ARRAYSIZE(szTemp), GFN_ICO ))
                    SetDlgItemText(hDlg,
                        (LOWORD(wParam) == IDC_BROWSEBTICO) ? IDE_BTICON : IDE_BTHOTICON, szTemp);
                break;
            case IDC_BROWSEBTACTION:
                if (BrowseForFile(hDlg, szTemp, ARRAYSIZE(szTemp), GFN_EXE ))
                    SetDlgItemText(hDlg, IDE_BTACTION, szTemp);
                break;
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDOK:
                if (!CheckField(hDlg, IDE_BTCAPTION, FC_NONNULL) ||
                    !CheckField(hDlg, IDE_BTACTION, FC_NONNULL) ||
                    !CheckField(hDlg, IDE_BTHOTICON, FC_NONNULL | FC_FILE | FC_EXISTS) ||
                    !CheckField(hDlg, IDE_BTICON, FC_NONNULL | FC_FILE | FC_EXISTS))
                    break;

                pBToolbar = (PBTOOLBAR)GetWindowLongPtr(hDlg, DWLP_USER);
                GetDlgItemText(hDlg, IDE_BTCAPTION, pBToolbar->szCaption, ARRAYSIZE(pBToolbar->szCaption));
                GetDlgItemText(hDlg, IDE_BTACTION, pBToolbar->szAction, ARRAYSIZE(pBToolbar->szAction));
//              GetDlgItemText(hDlg, IDE_BTTOOLTEXT, pBToolbar->szToolTipText, ARRAYSIZE(pBToolbar->szToolTipText));
                GetDlgItemText(hDlg, IDE_BTICON, pBToolbar->szIcon, ARRAYSIZE(pBToolbar->szIcon));
                GetDlgItemText(hDlg, IDE_BTHOTICON, pBToolbar->szHotIcon, ARRAYSIZE(pBToolbar->szHotIcon));
                pBToolbar->fShow = (IsDlgButtonChecked(hDlg, IDC_BUTTONSTATE) == BST_CHECKED);

                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\connset.cpp ===
#include "precomp.h"
#include <rashelp.h>

#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union
#include <winineti.h>

// Implementation helper structures/routines declarations
BOOL importConnectSet(PCTSTR pszIns, PCTSTR pszTargetPath, PCTSTR pszCleanupPath, BOOL fImport,
    DWORD dwMode, PCTSTR pszPbkFile = NULL, HKEY hkRoot = NULL);

typedef struct tagRASSETPARAMS {
    PCTSTR pszExtractPath;
    PCTSTR pszIns;
    HANDLE hfileDat,
           hfileInf;
    BOOL   fInfFileNeeded,
           fIntranet;

    // support for legacy format in ie50
    struct {
        HANDLE hfileRas,
               hfileSet;
        UINT   nRasFileIndex;
    } lcy50;

} RASSETPARAMS, *PRASSETPARAMS;

BOOL rasMainEnumProc(PCWSTR pszNameW, LPARAM lParam);

BOOL exportRasSettings           (PCWSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL exportRasCredentialsSettings(PCWSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL exportWininetSettings       (PCWSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL exportOtherSettings         (PCWSTR pszNameA, const PRASSETPARAMS pcrsp);

void lcy50_Initialize           (PRASSETPARAMS prsp);
void lcy50_Uninitialize         (PRASSETPARAMS prsp);
BOOL lcy50_ExportRasSettings    (PCSTR pszNameA, const PRASSETPARAMS pcrsp);
BOOL lcy50_ExportWininetSettings(PCSTR pszNameA, const PRASSETPARAMS pcrsp);
void lcy50_CopySzToBlobA        (PBYTE *ppBlob, PCSTR pszStrA);

BOOL deleteScriptFiles(PCTSTR pszSettingsFile, PCTSTR pszExtractPath, PCTSTR pszIns);
void parseProxyToIns(PCTSTR pszProxy, PCTSTR pszIns);
void copySzToBlob(PBYTE *ppBlob, PCWSTR pszStrW);


BOOL WINAPI ImportConnectSetA(LPCSTR pcszIns, LPCSTR pcszTargetPath, LPCSTR pcszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCSTR pcszPbkFile /*= NULL*/, HKEY hkRoot /*= NULL*/)
{
    USES_CONVERSION;

    return importConnectSet(A2CT(pcszIns), A2CT(pcszTargetPath), A2CT(pcszCleanupPath),
                            fImport, dwMode, A2CT(pcszPbkFile), hkRoot);
}

BOOL WINAPI ImportConnectSetW(LPCWSTR pcwszIns, LPCWSTR pcwszTargetPath, LPCWSTR pcwszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCWSTR pcwszPbkFile /*= NULL*/, HKEY hkRoot /*= NULL*/)
{
    USES_CONVERSION;

    return importConnectSet(W2CT(pcwszIns), W2CT(pcwszTargetPath), W2CT(pcwszCleanupPath), 
                            fImport, dwMode, W2CT(pcwszPbkFile), hkRoot);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helper routines

BOOL importConnectSet(PCTSTR pszIns, PCTSTR pszTargetPath, PCTSTR pszCleanupPath, BOOL fImport,
    DWORD dwMode, PCTSTR pszPbkFile /*= NULL*/, HKEY hkRoot /*= NULL*/)
{
    UNREFERENCED_PARAMETER(pszPbkFile);
    UNREFERENCED_PARAMETER(hkRoot);

    USES_CONVERSION;

    RASSETPARAMS rsp;
    TCHAR szTargetFile[MAX_PATH],
          szExtRegInfLine[MAX_PATH];
    DWORD dwAux,
          dwResult;
    BOOL  fResult,
          fAux;

    //----- Clear out previous settings -----
    PathCombine(szTargetFile, pszCleanupPath, CONNECT_RAS);
    deleteScriptFiles(szTargetFile, pszCleanupPath, pszIns);

    DeleteFileInDir(CS_DAT, pszCleanupPath);

    // delete legacy stuff if there
    DeleteFileInDir(CONNECT_RAS, pszCleanupPath);
    DeleteFileInDir(CONNECT_SET, pszCleanupPath);
    DeleteFileInDir(CONNECT_INF, pszCleanupPath);

    InsDeleteSection(IS_CONNECTSET, pszIns);
    InsDeleteKey    (IS_EXTREGINF,  IK_CONNECTSET, pszIns);

    if (!fImport)
        return TRUE;                            // bail if that's all we need

    //----- Initialization -----
    fResult = FALSE;

    ZeroMemory(&rsp, sizeof(rsp));
    rsp.pszExtractPath = pszTargetPath;
    rsp.pszIns         = pszIns;
    rsp.fIntranet      = HasFlag(dwMode, IEM_ADMIN);

    PathCombine(szTargetFile, pszTargetPath, CS_DAT);
    rsp.hfileDat = CreateNewFile(szTargetFile);
    if (INVALID_HANDLE_VALUE == rsp.hfileDat) {
        rsp.hfileDat = NULL;
        goto Exit;
    }

    if (RasIsInstalled()) {
        PathCombine(szTargetFile, pszTargetPath, CONNECT_INF);
        rsp.hfileInf = CreateNewFile(szTargetFile);
        if (INVALID_HANDLE_VALUE == rsp.hfileInf) {
            rsp.hfileInf = NULL;
            goto Exit;
        }
    }

    //----- Write initial information into output files -----
    dwAux = CS_VERSION_5X;
    WriteFile(rsp.hfileDat, &dwAux, sizeof(DWORD), &dwResult, NULL);

    if (rsp.hfileInf != NULL)
        WriteStringToFile(rsp.hfileInf, INF_PROLOG_CS, StrLen(INF_PROLOG_CS));

    lcy50_Initialize(&rsp);

    //----- Enumerate connections -----
    fResult = RasEnumEntriesCallback(NULL, rasMainEnumProc, (LPARAM)&rsp);
    if (!fResult)
        goto Exit;

    //----- Save global registry settings into the inf file -----
    if (rsp.hfileInf != NULL) {
        HKEY hk;

        if (ERROR_SUCCESS == SHOpenKeyHKCU(RK_INETSETTINGS, KEY_READ, &hk)) {
            if (S_OK == SHValueExists(hk, RV_ENABLESECURITYCHECK)) {
                ExportRegValue2Inf(hk, RV_ENABLESECURITYCHECK, TEXT("HKCU"), RK_INETSETTINGS, rsp.hfileInf);
                rsp.fInfFileNeeded = TRUE;
            }

            SHCloseKey(hk);
        }

        if (ERROR_SUCCESS == SHOpenKeyHKCU(RK_REMOTEACCESS, KEY_READ, &hk)) {
            if (S_OK == SHValueExists(hk, RV_INTERNETPROFILE)) {
                ExportRegValue2Inf(hk, RV_INTERNETPROFILE, TEXT("HKCU"), RK_REMOTEACCESS, rsp.hfileInf);
                rsp.fInfFileNeeded = TRUE;
            }

            SHCloseKey(hk);
        }

        if (rsp.fInfFileNeeded) {
            szExtRegInfLine[0] = TEXT('\0');
            wnsprintf(szExtRegInfLine, countof(szExtRegInfLine), TEXT("%s,") IS_DEFAULTINSTALL, CONNECT_INF);
            InsWriteString(IS_EXTREGINF, IK_CONNECTSET, szExtRegInfLine, pszIns);

            szExtRegInfLine[0] = TEXT('\0');
            wnsprintf(szExtRegInfLine, countof(szExtRegInfLine), TEXT("%s,") IS_IEAKINSTALL_HKCU, CONNECT_INF);
            InsWriteString(IS_EXTREGINF_HKCU, IK_CONNECTSET, szExtRegInfLine, pszIns);
        }
    }

    //----- Save global settings into the ins file -----
    InsWriteBool(IS_CONNECTSET, IK_OPTION, TRUE, pszIns);

    // NOTE: (andrewgu) have to do this instead of going through inf because it's impossible to
    // write to HKCC in the inf. and we have to write to HKCC, otherwise clients with intergated
    // shell are broken.
    dwAux    = sizeof(fAux);
    dwResult = SHGetValue(HKEY_CURRENT_USER, RK_INETSETTINGS, RV_ENABLEAUTODIAL, NULL, (LPBYTE)&fAux, &dwAux);
    if (dwResult == ERROR_SUCCESS)
        InsWriteBool(IS_CONNECTSET, IK_ENABLEAUTODIAL, fAux, pszIns);

    dwAux    = sizeof(fAux);
    dwResult = SHGetValue(HKEY_CURRENT_USER, RK_INETSETTINGS, RV_NONETAUTODIAL, NULL, (LPBYTE)&fAux, &dwAux);
    if (dwResult == ERROR_SUCCESS)
        InsWriteBool(IS_CONNECTSET, IK_NONETAUTODIAL, fAux, pszIns);

    fResult = TRUE;

Exit:
    lcy50_Uninitialize(&rsp);

    if (NULL != rsp.hfileInf) {
        CloseFile(rsp.hfileInf);

        if (!rsp.fInfFileNeeded)
            DeleteFileInDir(CONNECT_INF, pszTargetPath);
    }

    if (NULL != rsp.hfileDat)
        CloseFile(rsp.hfileDat);

    return fResult;
}


BOOL rasMainEnumProc(PCWSTR pszNameW, LPARAM lParam)
{
    USES_CONVERSION;

    PRASSETPARAMS pcrsp;
    BYTE   rgbName[2*sizeof(DWORD) + StrCbFromCch(RAS_MaxEntryName+1)];
    PCSTR  pszNameA;
    PBYTE  pCur;
    DWORD  cbName,
           dwAux;

    pcrsp = (const PRASSETPARAMS)lParam;
    ASSERT(NULL != pcrsp && NULL != pcrsp->hfileDat);

    //----- Connection name -----
    ZeroMemory(rgbName, sizeof(rgbName));
    pCur    = rgbName;
    cbName  = 2*sizeof(DWORD);
    cbName += (DWORD)((pszNameW != NULL) ? StrCbFromSzW(pszNameW) : sizeof(DWORD));

    *((PDWORD)pCur) = CS_STRUCT_HEADER;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbName;
    pCur += sizeof(DWORD);

    copySzToBlob(&pCur, pszNameW);

    WriteFile(pcrsp->hfileDat, rgbName, cbName, &dwAux, NULL);

    //----- All other structures -----
    pszNameA = W2CA(pszNameW);

    if (NULL != pszNameW) {
        ASSERT(RasIsInstalled());

        exportRasSettings           (pszNameW, pcrsp);
        exportRasCredentialsSettings(pszNameW, pcrsp);
        exportWininetSettings       (pszNameW, pcrsp);
        exportOtherSettings         (pszNameW, pcrsp);

        lcy50_ExportRasSettings     (pszNameA, pcrsp);
        lcy50_ExportWininetSettings (pszNameA, pcrsp);
    }
    else {
        exportWininetSettings       (pszNameW, pcrsp);
        lcy50_ExportWininetSettings (pszNameA, pcrsp);
    }

    return TRUE;
}


BOOL exportRasSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    LPRASENTRYW preW;
    PBYTE pBlob, pCur;
    DWORD cbBlob, cbWritten,
          dwResult;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL);
    ASSERT(pcrsp != NULL && pcrsp->hfileDat != NULL);

    pBlob = NULL;

    //----- RAS structure -----
    dwResult = RasGetEntryPropertiesExW(pszNameW, (LPRASENTRYW *)&pBlob, &cbBlob);
    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    cbBlob += 2*sizeof(DWORD);
    pBlob   = (PBYTE)CoTaskMemRealloc(pBlob, cbBlob);
    if (pBlob == NULL)
        goto Exit;
    MoveMemory(pBlob + 2*sizeof(DWORD), pBlob, cbBlob - 2*sizeof(DWORD));

    //----- Header -----
    pCur = pBlob;

    *((PDWORD)pCur) = CS_STRUCT_RAS;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbBlob;
    pCur += sizeof(DWORD);

    //----- Script file -----
    preW = (LPRASENTRYW)pCur;

    if (preW->szScript[0] != L'\0') {
        PCWSTR pszScriptW;

        pszScriptW = preW->szScript;
        if (preW->szScript[0] == L'[')
            pszScriptW = &preW->szScript[1];

        if (PathFileExistsW(pszScriptW)) {
            if (pszScriptW > preW->szScript)
                StrCpyW(preW->szScript, pszScriptW);

            CopyFileToDir(W2CT(preW->szScript), pcrsp->pszExtractPath);
        }
    }

    WriteFile(pcrsp->hfileDat, pBlob, cbBlob, &cbWritten, NULL);

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    return TRUE;
}

BOOL exportRasCredentialsSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    RASDIALPARAMSW rdpW;
    PCWSTR pszUserNameW, pszPasswordW, pszDomainW;
    PBYTE  pBlob, pCur;
    DWORD  cbBlob, cbWritten,
           dwResult;
    BOOL   fPassword;

    ASSERT(RasIsInstalled());
    ASSERT(pszNameW != NULL);
    ASSERT(pcrsp != NULL && pcrsp->hfileDat != NULL);

    pBlob = NULL;

    ZeroMemory(&rdpW, sizeof(rdpW));
    rdpW.dwSize = sizeof(rdpW);
    StrCpyW(rdpW.szEntryName, pszNameW);

    dwResult = RasGetEntryDialParamsWrap(&rdpW, &fPassword);
    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    pszUserNameW = (*rdpW.szUserName != TEXT('\0')) ? rdpW.szUserName : NULL;
    pszPasswordW = fPassword ? rdpW.szPassword : NULL;
    pszDomainW   = (*rdpW.szDomain != TEXT('\0')) ? rdpW.szDomain : NULL;

    //----- Figure out the size of the blob  -----
    // size of structure header
    cbBlob = 2*sizeof(DWORD);

    // size of essential information
    cbBlob += (DWORD)((pszUserNameW != NULL) ? StrCbFromSzW(pszUserNameW) : sizeof(DWORD));
    cbBlob += (DWORD)((pszPasswordW != NULL) ? StrCbFromSzW(pszPasswordW) : sizeof(DWORD));
    cbBlob += (DWORD)((pszDomainW   != NULL) ? StrCbFromSzW(pszDomainW)   : sizeof(DWORD));

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (pBlob == NULL)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    //----- Copy information into the blob -----
    pCur = pBlob;

    // stucture header
    *((PDWORD)pCur) = CS_STRUCT_RAS_CREADENTIALS;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbBlob;
    pCur += sizeof(DWORD);

    // essential information
    copySzToBlob(&pCur, pszUserNameW);
    copySzToBlob(&pCur, pszPasswordW);
    copySzToBlob(&pCur, pszDomainW);
    ASSERT(pCur == pBlob + cbBlob);

    WriteFile(pcrsp->hfileDat, pBlob, cbBlob, &cbWritten, NULL);

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    return TRUE;
}

BOOL exportWininetSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    INTERNET_PER_CONN_OPTION_LISTW list;
    INTERNET_PER_CONN_OPTIONW      rgOptions[7];
    PCWSTR pszAuxW;
    PBYTE  pBlob, pCur;
    DWORD  cbBlob, cbAux;
    UINT   i;

    ASSERT(pcrsp != NULL && pcrsp->hfileDat != NULL && pcrsp->pszIns != NULL);

    pBlob = NULL;

    ZeroMemory(&list, sizeof(list));
    list.dwSize        = sizeof(list);
    list.pszConnection = (PWSTR)pszNameW;

    ZeroMemory(rgOptions, sizeof(rgOptions));
    list.dwOptionCount = countof(rgOptions);
    list.pOptions      = rgOptions;

    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    list.pOptions[4].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    list.pOptions[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    list.pOptions[6].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        list.dwOptionCount = 3;

    cbAux = list.dwSize;
    if (FALSE == InternetQueryOptionW(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &cbAux))
        goto Exit;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        list.pOptions[0].Value.dwValue &= PROXY_TYPE_PROXY;

    //----- Figure out the size of the blob -----
    // size of structure header
    cbBlob = 2*sizeof(DWORD);

    // size of INTERNET_PER_CONN_OPTION_LIST header
    cbBlob += sizeof(DWORD);                    // list.dwOptionCount

    // size of INTERNET_PER_CONN_xxx - all of list.pOptions
    for (i = 0; i < min(list.dwOptionCount, countof(rgOptions)); i++) {
        cbBlob += sizeof(DWORD);

        switch (list.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszAuxW  = list.pOptions[i].Value.pszValue;
            cbBlob  += (DWORD)((pszAuxW != NULL) ? StrCbFromSzW(pszAuxW) : sizeof(DWORD));
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            cbBlob += sizeof(DWORD);
            break;
        }
    }

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (pBlob == NULL)
        goto Exit;

    //----- Copy information into the blob -----
    ZeroMemory(pBlob, cbBlob);
    pCur = pBlob;

    // stucture header
    *((PDWORD)pCur) = CS_STRUCT_WININET;
    pCur += sizeof(DWORD);

    *((PDWORD)pCur) = cbBlob;
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_OPTION_LIST header
    *((PDWORD)pCur) = list.dwOptionCount;       // list.dwOptionCount
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_xxx - all of list.pOptions
    for (i = 0; i < min(list.dwOptionCount, countof(rgOptions)); i++) {
        *((PDWORD)pCur) = list.pOptions[i].dwOption;
        pCur += sizeof(DWORD);

        switch (list.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            copySzToBlob(&pCur, list.pOptions[i].Value.pszValue);
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            *((PDWORD)pCur) = list.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    WriteFile(pcrsp->hfileDat, pBlob, cbBlob, &cbAux, NULL);

    //----- Save LAN's autoconfig and proxy settings to the ins -----
    if (pszNameW == NULL) {
        ASSERT(list.pOptions[0].dwOption == INTERNET_PER_CONN_FLAGS);

        //_____ autoconfig _____
        if (pcrsp->fIntranet) {
            TCHAR szReloadDelayMins[33];

            InsWriteBool(IS_URL, IK_DETECTCONFIG,
                HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_AUTO_DETECT), pcrsp->pszIns);

            InsWriteBool(IS_URL, IK_USEAUTOCONF,
                HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_AUTO_PROXY_URL), pcrsp->pszIns);

            ASSERT(list.pOptions[3].dwOption == INTERNET_PER_CONN_AUTOCONFIG_URL);
            InsWriteString(IS_URL, IK_AUTOCONFURL, W2CT(list.pOptions[3].Value.pszValue), pcrsp->pszIns);

            ASSERT(list.pOptions[4].dwOption == INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL);
            InsWriteString(IS_URL, IK_AUTOCONFURLJS, W2CT(list.pOptions[4].Value.pszValue), pcrsp->pszIns);

            ASSERT(list.pOptions[5].dwOption == INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS);
            wnsprintf(szReloadDelayMins, countof(szReloadDelayMins), TEXT("%lu"), list.pOptions[5].Value.dwValue);
            InsWriteString(IS_URL, IK_AUTOCONFTIME, szReloadDelayMins, pcrsp->pszIns);
        }
        else { /* if (!pcrsp->fIntranet) */     // autoconfig stuff should be ignored
            InsDeleteKey(IS_URL, IK_DETECTCONFIG,  pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_USEAUTOCONF,   pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_AUTOCONFURL,   pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_AUTOCONFURLJS, pcrsp->pszIns);
            InsDeleteKey(IS_URL, IK_AUTOCONFTIME,  pcrsp->pszIns);
        }

        //_____ proxy and proxy bypass settings _____
        if (pcrsp->fIntranet || HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY)) {
            InsWriteBool(IS_PROXY, IK_PROXYENABLE,
                HasFlag(list.pOptions[0].Value.dwValue, PROXY_TYPE_PROXY), pcrsp->pszIns);

            ASSERT(list.pOptions[1].dwOption == INTERNET_PER_CONN_PROXY_SERVER);
            parseProxyToIns(W2CT(list.pOptions[1].Value.pszValue), pcrsp->pszIns);

            ASSERT(list.pOptions[2].dwOption == INTERNET_PER_CONN_PROXY_BYPASS);
            InsWriteString(IS_PROXY, IK_PROXYOVERRIDE, W2CT(list.pOptions[2].Value.pszValue), pcrsp->pszIns);
        }
        else                                    // proxy not customized, delete the section
            InsDeleteSection(IS_PROXY, pcrsp->pszIns);
    }

Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    if (list.pOptions[1].Value.pszValue != NULL) // INTERNET_PER_CONN_PROXY_SERVER
        GlobalFree(list.pOptions[1].Value.pszValue);

    if (list.pOptions[2].Value.pszValue != NULL) // INTERNET_PER_CONN_PROXY_BYPASS
        GlobalFree(list.pOptions[2].Value.pszValue);

    if (list.pOptions[3].Value.pszValue != NULL) // INTERNET_PER_CONN_AUTOCONFIG_URL
        GlobalFree(list.pOptions[3].Value.pszValue);

    if (list.pOptions[4].Value.pszValue != NULL) // INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL
        GlobalFree(list.pOptions[4].Value.pszValue);

    return TRUE;
}

BOOL exportOtherSettings(PCWSTR pszNameW, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    TCHAR  szKey[MAX_PATH];
    PCTSTR pszName;
    HKEY   hk;
    BOOL   fExported;

    ASSERT(pszNameW != NULL);
    ASSERT(pcrsp    != NULL && pcrsp->hfileInf != NULL && pcrsp->pszIns != NULL);

    fExported = FALSE;

    pszName = W2CT(pszNameW);
    wnsprintf(szKey, countof(szKey), RK_REMOTEACCESS_PROFILES TEXT("\\%s"), pszName);

    if (ERROR_SUCCESS != SHOpenKeyHKCU(szKey, KEY_READ, &hk))
        return TRUE;

    if (S_OK == SHValueExists(hk, RV_COVEREXCLUDE)) {
        ExportRegValue2Inf(hk, RV_COVEREXCLUDE, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_ENABLEAUTODISCONNECT)) {
        ExportRegValue2Inf(hk, RV_ENABLEAUTODISCONNECT, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_ENABLEEXITDISCONNECT)) {
        ExportRegValue2Inf(hk, RV_ENABLEEXITDISCONNECT, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_DISCONNECTIDLETIME)) {
        ExportRegValue2Inf(hk, RV_DISCONNECTIDLETIME, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_REDIALATTEMPTS)) {
        ExportRegValue2Inf(hk, RV_REDIALATTEMPTS, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    if (S_OK == SHValueExists(hk, RV_REDIALINTERVAL)) {
        ExportRegValue2Inf(hk, RV_REDIALINTERVAL, TEXT("HKCU"), szKey, pcrsp->hfileInf);
        pcrsp->fInfFileNeeded = fExported = TRUE;
    }

    SHCloseKey(hk);

    if (fExported)
        WriteStringToFile(pcrsp->hfileInf, (LPCVOID)TEXT("\r\n"), 2);

    return TRUE;
}


void lcy50_Initialize(PRASSETPARAMS prsp)
{
    TCHAR szTargetFile[MAX_PATH];
    DWORD dwVersion,
          dwAux;

    ASSERT(NULL != prsp && NULL != prsp->pszExtractPath);

    ZeroMemory(&prsp->lcy50, sizeof(prsp->lcy50));
    dwVersion = CS_VERSION_50;

    if (RasIsInstalled()) {
        PathCombine(szTargetFile, prsp->pszExtractPath, CONNECT_RAS);
        prsp->lcy50.hfileRas = CreateNewFile(szTargetFile);

        if (INVALID_HANDLE_VALUE != prsp->lcy50.hfileRas)
            WriteFile(prsp->lcy50.hfileRas, &dwVersion, sizeof(DWORD), &dwAux, NULL);
        else
            prsp->lcy50.hfileRas = NULL;
    }

    PathCombine(szTargetFile, prsp->pszExtractPath, CONNECT_SET);
    prsp->lcy50.hfileSet = CreateNewFile(szTargetFile);
    if (INVALID_HANDLE_VALUE != prsp->lcy50.hfileSet)
        WriteFile(prsp->lcy50.hfileSet, &dwVersion, sizeof(DWORD), &dwAux, NULL);
    else
        prsp->lcy50.hfileSet = NULL;
}

void lcy50_Uninitialize(PRASSETPARAMS prsp)
{
    ASSERT(NULL != prsp && NULL != prsp->pszExtractPath);

    if (NULL != prsp->lcy50.hfileSet) {
        CloseFile(prsp->lcy50.hfileSet);
        prsp->lcy50.hfileSet = NULL;
    }

    if (NULL != prsp->lcy50.hfileRas) {
        CloseFile(prsp->lcy50.hfileRas);
        prsp->lcy50.hfileRas = NULL;

        if (prsp->lcy50.nRasFileIndex == 0)
            DeleteFileInDir(CONNECT_RAS, prsp->pszExtractPath);
    }
}

BOOL lcy50_ExportRasSettings(PCSTR pszNameA, const PRASSETPARAMS pcrsp)
{
    USES_CONVERSION;

    TCHAR szKeyName[16],
          szKeySize[16],
          szValueSize[16];
    PBYTE pBlob;
    DWORD cbBlob,
          dwResult;

    if (NULL == pcrsp->lcy50.hfileRas)
        return FALSE;

    ASSERT(RasIsInstalled());
    ASSERT(NULL != pszNameA);
    ASSERT(NULL != pcrsp && NULL != pcrsp->pszIns);

    pBlob    = NULL;
    dwResult = RasGetEntryPropertiesExA(pszNameA, (LPRASENTRYA *)&pBlob, &cbBlob);
    if (dwResult != ERROR_SUCCESS)
        goto Exit;

    // NOTE: (andrewgu) need to write the size of the data in the ins file because it's variable.
    // it can change depending on alternate phone numbers list at the end of the RASENTRYA
    // structure.
    wnsprintf(szKeyName,   countof(szKeyName),   IK_CONNECTNAME, pcrsp->lcy50.nRasFileIndex);
    wnsprintf(szKeySize,   countof(szKeySize),   IK_CONNECTSIZE, pcrsp->lcy50.nRasFileIndex);
    wnsprintf(szValueSize, countof(szValueSize), TEXT("%lu"),    cbBlob);

    InsWriteString(IS_CONNECTSET, szKeyName, A2CT(pszNameA), pcrsp->pszIns);
    InsWriteString(IS_CONNECTSET, szKeySize, szValueSize,    pcrsp->pszIns);

    // NOTE: (andrewgu) no script file processing is needed here. it's been taken care of when
    // processing settings for the new format. connection is ulimately the same it's just stored
    // differently.

    WriteFile(pcrsp->lcy50.hfileRas, pBlob, cbBlob, &dwResult, NULL);
    pcrsp->lcy50.nRasFileIndex++;

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    return TRUE;
}

BOOL lcy50_ExportWininetSettings(PCSTR pszNameA, const PRASSETPARAMS pcrsp)
{
    INTERNET_PER_CONN_OPTION_LISTA listA;
    INTERNET_PER_CONN_OPTIONA      rgOptionsA[7];
    PCSTR pszAuxA;
    PBYTE pBlob, pCur;
    DWORD cbBlob, cbAux;
    UINT  i;

    if (NULL == pcrsp->lcy50.hfileSet)
        return FALSE;

    ASSERT(NULL != pcrsp && NULL != pcrsp->pszIns);

    pBlob = NULL;

    ZeroMemory(&listA, sizeof(listA));
    listA.dwSize        = sizeof(listA);
    listA.pszConnection = (PSTR)pszNameA;

    ZeroMemory(rgOptionsA, sizeof(rgOptionsA));
    listA.dwOptionCount = countof(rgOptionsA);
    listA.pOptions      = rgOptionsA;

    listA.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    listA.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    listA.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    listA.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    listA.pOptions[4].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    listA.pOptions[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    listA.pOptions[6].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        listA.dwOptionCount = 3;

    cbAux = listA.dwSize;
    if (FALSE == InternetQueryOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &listA, &cbAux))
        goto Exit;

    if (!pcrsp->fIntranet)                      // autoconfig stuff should be ignored
        listA.pOptions[0].Value.dwValue &= PROXY_TYPE_PROXY;

    //----- Figure out the size of the blob describing this connection -----

    // size of INTERNET_PER_CONN_OPTION_LIST header
    cbBlob  = sizeof(DWORD);                    // listA.dwSize
    pszAuxA = listA.pszConnection;              // listA.pszConnection
    cbBlob += (DWORD)((NULL != pszAuxA) ? StrCbFromSzA(pszAuxA) : sizeof(DWORD));
#ifdef _WIN64
    cbBlob = LcbAlignLcb(cbBlob);
#endif
    cbBlob += sizeof(DWORD);                    // listA.dwOptionCount

    // size of INTERNET_PER_CONN_xxx - all of listA.pOptions
    for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
        cbBlob += sizeof(DWORD);

        switch (listA.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszAuxA = listA.pOptions[i].Value.pszValue;
            cbBlob += (DWORD)((NULL != pszAuxA) ? StrCbFromSzA(pszAuxA) : sizeof(DWORD));
#ifdef _WIN64
            cbBlob = LcbAlignLcb(cbBlob);
#endif
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            cbBlob += sizeof(DWORD);
            break;
        }
    }

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (NULL == pBlob)
        goto Exit;

    //----- Copy connection information into the blob -----
    ZeroMemory(pBlob, cbBlob);
    pCur = pBlob;

    // INTERNET_PER_CONN_OPTION_LIST header
    *((PDWORD)pCur) = cbBlob;                        // listA.dwSize
    pCur += sizeof(DWORD);
    lcy50_CopySzToBlobA(&pCur, listA.pszConnection); // listA.pszConnection
#ifdef _WIN64
    pCur = MyPbAlignPb(pCur);
#endif

    *((PDWORD)pCur) = listA.dwOptionCount;           // listA.dwOptionCount
    pCur += sizeof(DWORD);

    // INTERNET_PER_CONN_xxx - all of listA.pOptions
    for (i = 0; i < min(listA.dwOptionCount, countof(rgOptionsA)); i++) {
        *((PDWORD)pCur) = listA.pOptions[i].dwOption;
        pCur += sizeof(DWORD);

        switch (listA.pOptions[i].dwOption) {
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            lcy50_CopySzToBlobA(&pCur, listA.pOptions[i].Value.pszValue);
#ifdef _WIN64
            pCur = MyPbAlignPb(pCur);
#endif
            break;

        case INTERNET_PER_CONN_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        default:                        // everything else is also DWORD
            *((PDWORD)pCur) = listA.pOptions[i].Value.dwValue;
            pCur += sizeof(DWORD);
            break;
        }
    }
    ASSERT(pCur == pBlob + cbBlob);

    WriteFile(pcrsp->lcy50.hfileSet, pBlob, cbBlob, &cbAux, NULL);

    // NOTE: (andrewgu) no processing that saves LAN's autoconfig and proxy settings to the ins is
    // needed. this processing is performed when processing settings for the new format. the
    // information is ulimately the same it's just stored differently.

Exit:
    if (NULL != pBlob)
        CoTaskMemFree(pBlob);

    if (NULL != listA.pOptions[1].Value.pszValue) // INTERNET_PER_CONN_PROXY_SERVER
        GlobalFree(listA.pOptions[1].Value.pszValue);

    if (NULL != listA.pOptions[2].Value.pszValue) // INTERNET_PER_CONN_PROXY_BYPASS
        GlobalFree(listA.pOptions[2].Value.pszValue);

    if (NULL != listA.pOptions[3].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_URL
        GlobalFree(listA.pOptions[3].Value.pszValue);

    if (NULL != listA.pOptions[4].Value.pszValue) // INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL
        GlobalFree(listA.pOptions[4].Value.pszValue);

    return TRUE;
}

inline void lcy50_CopySzToBlobA(PBYTE *ppBlob, PCSTR pszStrA)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL);

    if (NULL == pszStrA) {
        *((PDWORD)(*ppBlob)) = (DWORD)NULL;
        *ppBlob += sizeof(DWORD);
    }
    else {
        StrCpyA((PSTR)(*ppBlob), pszStrA);
        *ppBlob += StrCbFromSzA(pszStrA);
    }
}


BOOL deleteScriptFiles(PCTSTR pszSettingsFile, PCTSTR pszExtractPath, PCTSTR pszIns)
{
    TCHAR  szScript[MAX_PATH],
           szKey[16];
    PBYTE  pBlob, pCur;
    HANDLE hFile;
    DWORD  dwVersion,
           cbBlob, cbAux;
    BOOL   fResult;

    if (pszSettingsFile == NULL || *pszSettingsFile == TEXT('\0') ||
        pszExtractPath  == NULL || *pszExtractPath  == TEXT('\0'))
        return FALSE;

    hFile   = NULL;
    pBlob   = NULL;
    fResult = FALSE;

    //----- Read settings file into internal memory buffer -----
    hFile = CreateFile(pszSettingsFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = NULL;
        goto Exit;
    }

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    cbBlob = GetFileSize(hFile, NULL);
    if (cbBlob == 0xFFFFFFFF)
        goto Exit;

    pBlob = (PBYTE)CoTaskMemAlloc(cbBlob);
    if (pBlob == NULL)
        goto Exit;
    ZeroMemory(pBlob, cbBlob);

    if (ReadFile(hFile, pBlob, cbBlob, &cbAux, NULL) != TRUE)
        goto Exit;

    dwVersion = *((PDWORD)pBlob);
    pCur      = pBlob + sizeof(DWORD);

    if (dwVersion == CS_VERSION_50) {
        LPRASENTRYA preA;
        PSTR pszScriptA;
        UINT i;

        //----- Parse through RAS connections information -----
        for (i = 0; TRUE; i++, pCur += cbAux) {

            //_____ Initialization _____
            wnsprintf(szKey, countof(szKey), IK_CONNECTNAME, i);
            if (InsKeyExists(IS_CONNECTSET, szKey, pszIns))
                break;

            wnsprintf(szKey, countof(szKey), IK_CONNECTSIZE, i);
            cbAux = InsGetInt(IS_CONNECTSET, szKey, 0, pszIns);
            if (cbAux == 0)
                goto Exit;

            //_____ Main processing _____
            preA = (LPRASENTRYA)pCur;

            if (preA->szScript[0] != '\0') {
                pszScriptA = preA->szScript;
                if (preA->szScript[0] == '[')
                    pszScriptA = &preA->szScript[1];

                A2Tbuf(pszScriptA, szScript, countof(szScript));
                DeleteFileInDir(PathFindFileName(szScript), pszExtractPath);
            }
        }
    }
    else if (dwVersion >= CS_VERSION_5X && dwVersion <= CS_VERSION_5X_MAX) {
        LPRASENTRYW preW;
        PWSTR pszScriptW;

        //----- Parse through all structures -----
        while (pCur < pBlob + cbBlob)
            switch (*((PDWORD)pCur)) {
            case CS_STRUCT_RAS:
                //_____ Main processing _____
                preW = (LPRASENTRYW)(pCur + 2*sizeof(DWORD));

                // preW->szScript
                if (preW->szScript[0] != L'\0') {
                    pszScriptW = preW->szScript;
                    if (preW->szScript[0] == L'[')
                        pszScriptW = &preW->szScript[1];

                    W2Tbuf(pszScriptW, szScript, countof(szScript));
                    DeleteFileInDir(PathFindFileName(szScript), pszExtractPath);
                }
                break;

            default:
                pCur += *((PDWORD)(pCur + sizeof(DWORD)));
            }
    }
    else {
        ASSERT(FALSE);
        goto Exit;
    }

    fResult = TRUE;

    //----- Cleanup -----
Exit:
    if (pBlob != NULL)
        CoTaskMemFree(pBlob);

    if (hFile != NULL)
        CloseFile(hFile);

    return fResult;
}

void parseProxyToIns(PCTSTR pszProxy, PCTSTR pszIns)
{
    struct {
        PCTSTR pszServer;
        PCTSTR pszKey;
        PCTSTR pszValue;
    } rgProxyMap[] = {
        { TEXT("http"),   IK_HTTPPROXY,   NULL },
        { TEXT("https"),  IK_SECPROXY,    NULL },
        { TEXT("ftp"),    IK_FTPPROXY,    NULL },
        { TEXT("gopher"), IK_GOPHERPROXY, NULL },
        { TEXT("socks"),  IK_SOCKSPROXY,  NULL }
    };

    TCHAR szProxy[MAX_PATH];
    PTSTR pszCur, pszToken, pszAux;
    UINT  i;
    BOOL  fSameProxy;

    if (pszProxy == NULL || *pszProxy == TEXT('\0') ||
        pszIns   == NULL || *pszIns   == TEXT('\0'))
        return;

    fSameProxy = (NULL == StrChr(pszProxy, TEXT('=')));
    InsWriteBool(IS_PROXY, IK_SAMEPROXY, fSameProxy, pszIns);

    if (fSameProxy) {
        InsWriteString(IS_PROXY, IK_HTTPPROXY, pszProxy, pszIns);
        return;
    }

    StrCpy(szProxy, pszProxy);
    for (pszCur  = szProxy;
         pszCur != NULL && *pszCur != TEXT('\0');
         pszCur  = (pszToken != NULL) ? (pszToken + 1) : NULL) {

        // strip out token in the from "server=value:port#;"
        pszToken = StrChr(pszCur, TEXT(';'));
        if (pszToken != NULL)
            *pszToken = TEXT('\0');

        // strip out the server part "server="
        pszAux = StrChr(pszCur, TEXT('='));
        if (pszAux == NULL) {
            ASSERT(FALSE);                      // no TEXT('=') in the token,
            continue;                           // continue
        }
        *pszAux = TEXT('\0');
        StrRemoveWhitespace(pszCur);

        for (i = 0; i < countof(rgProxyMap); i++)
            if (0 == StrCmpI(rgProxyMap[i].pszServer, pszCur))
                break;
        if (i >= countof(rgProxyMap))
            continue;                           // unknown server, continue

        StrRemoveWhitespace(pszAux + 1);
        rgProxyMap[i].pszValue = pszAux + 1;
    }

    for (i = 0; i < countof(rgProxyMap); i++)
        InsWriteString(IS_PROXY, rgProxyMap[i].pszKey, rgProxyMap[i].pszValue, pszIns);
}

inline void copySzToBlob(PBYTE *ppBlob, PCWSTR pszStrW)
{
    ASSERT(ppBlob != NULL && *ppBlob != NULL);

    if (pszStrW == NULL) {
        *((PDWORD)(*ppBlob)) = (DWORD)NULL;
        *ppBlob += sizeof(DWORD);
    }
    else {
        StrCpyW((PWSTR)(*ppBlob), pszStrW);
        *ppBlob += StrCbFromSzW(pszStrW);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\convert.cpp ===
#include "precomp.h"

// functions used internally by ieakeng to convert between ansi and unicode versions of
// various structs
// Note: these functions assume ptrs to buffers already have the buffers allocated.

LPNMTVGETINFOTIPW TVInfoTipA2W(LPNMTVGETINFOTIPA pTvInfoTipA, LPNMTVGETINFOTIPW pTvInfoTipW)
{
    pTvInfoTipW->cchTextMax = pTvInfoTipA->cchTextMax;
    pTvInfoTipW->hdr = pTvInfoTipA->hdr;
    pTvInfoTipW->hItem = pTvInfoTipA->hItem;
    pTvInfoTipW->lParam = pTvInfoTipA->lParam;
    A2Wbux(pTvInfoTipA->pszText, pTvInfoTipW->pszText);

    return pTvInfoTipW;
}

LPNMTVGETINFOTIPA TVInfoTipW2A(LPNMTVGETINFOTIPW pTvInfoTipW, LPNMTVGETINFOTIPA pTvInfoTipA)
{
    pTvInfoTipA->cchTextMax = pTvInfoTipW->cchTextMax;
    pTvInfoTipA->hdr = pTvInfoTipW->hdr;
    pTvInfoTipA->hItem = pTvInfoTipW->hItem;
    pTvInfoTipA->lParam = pTvInfoTipW->lParam;
    W2Abux(pTvInfoTipW->pszText, pTvInfoTipA->pszText);

    return pTvInfoTipA;
}

LPNMTVGETINFOTIP TVInfoTipSameToSame(LPNMTVGETINFOTIP pTvInfoTipIn,
                                     LPNMTVGETINFOTIP pTvInfoTipOut)
{
    pTvInfoTipOut->cchTextMax = pTvInfoTipIn->cchTextMax;
    pTvInfoTipOut->hdr = pTvInfoTipIn->hdr;
    pTvInfoTipOut->hItem = pTvInfoTipIn->hItem;
    pTvInfoTipOut->lParam = pTvInfoTipIn->lParam;
    StrCpy(pTvInfoTipOut->pszText, pTvInfoTipIn->pszText);

    return pTvInfoTipOut;
}

LPRESULTITEMW ResultItemA2W(LPRESULTITEMA pResultItemA, LPRESULTITEMW pResultItemW)
{
    pResultItemW->dwNameSpaceItem = pResultItemA->dwNameSpaceItem;
    pResultItemW->iDescID = pResultItemA->iDescID;
    pResultItemW->iDlgID = pResultItemA->iDlgID;
    pResultItemW->iImage = pResultItemA->iImage;
    pResultItemW->iNameID = pResultItemA->iNameID;
    A2Wbux(pResultItemA->pszName, pResultItemW->pszName);
    A2Wbux(pResultItemA->pszDesc, pResultItemW->pszDesc);
    pResultItemW->pfnDlgProc = pResultItemA->pfnDlgProc;

    return pResultItemW;
}

LPRESULTITEMA ResultItemW2A(LPRESULTITEMW pResultItemW, LPRESULTITEMA pResultItemA)
{
    pResultItemA->dwNameSpaceItem = pResultItemW->dwNameSpaceItem;
    pResultItemA->iDescID = pResultItemW->iDescID;
    pResultItemA->iDlgID = pResultItemW->iDlgID;
    pResultItemA->iImage = pResultItemW->iImage;
    pResultItemA->iNameID = pResultItemW->iNameID;
    W2Abux(pResultItemW->pszName, pResultItemA->pszName);
    W2Abux(pResultItemW->pszDesc, pResultItemA->pszDesc);
    pResultItemA->pfnDlgProc = pResultItemW->pfnDlgProc;

    return pResultItemA;
}

LPRESULTITEM ResultItemSameToSame(LPRESULTITEM pResultItemIn, LPRESULTITEM pResultItemOut)
{
    pResultItemOut->dwNameSpaceItem = pResultItemIn->dwNameSpaceItem;
    pResultItemOut->iDescID = pResultItemIn->iDescID;
    pResultItemOut->iDlgID = pResultItemIn->iDlgID;
    pResultItemOut->iImage = pResultItemIn->iImage;
    pResultItemOut->iNameID = pResultItemIn->iNameID;
    StrCpy(pResultItemOut->pszName, pResultItemIn->pszName);
    StrCpy(pResultItemOut->pszDesc, pResultItemIn->pszDesc);
    pResultItemOut->pfnDlgProc = pResultItemIn->pfnDlgProc;

    return pResultItemOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\exports.h ===
//
// EXPORTS.H
//

#ifndef _EXPORTS_H
#define _EXPORTS_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "ieaksie.h"

// IEM_xxx stands for Ieak Engine Mode
#define IEM_NEUTRAL 0x00000000                  // agnostic
#define IEM_ICP     0x00000000                  // wizard - icp mode
#define IEM_ISP     0x00000000                  // wizard - isp mode
#define IEM_CORP    0x00000001                  // wizard - corp
#define IEM_PROFMGR 0x00000002                  // profmgr
#define IEM_GP      0x00000004                  // gp (snapin)
#define IEM_ADMIN   0x00000007


// prototype declarations

// desktop.cpp
BOOL WINAPI ImportADTInfoA(LPCSTR pcszInsFile, LPCSTR pcszDeskWorkDir, LPCSTR pcszDeskInf, BOOL fImportADT);
BOOL WINAPI ImportADTInfoW(LPCWSTR pcszInsFile, LPCWSTR pcszDeskWorkDir, LPCWSTR pcszDeskInf, BOOL fImportADT);
BOOL WINAPI ShowDeskCpl(VOID);

// toolbar.cpp
BOOL WINAPI ImportToolbarInfoA(LPCSTR pcszInsFile, LPCSTR pcszToolbarWorkDir, LPCSTR pcszToolbarInf, BOOL fImportToolbars);
BOOL WINAPI ImportToolbarInfoW(LPCWSTR pcwszInsFile, LPCWSTR pcwszToolbarWorkDir, LPCWSTR pcwszToolbarInf, BOOL fImportToolbars);

// mccphtt.cpp
BOOL WINAPI CopyHttFileA(LPCSTR pcszInsFile, LPCSTR pcszHttWorkDir, LPCSTR pcszHttFile, LPCSTR pcszHttKey);
BOOL WINAPI CopyHttFileW(LPCWSTR pcwszInsFile, LPCWSTR pcwszHttWorkDir, LPCWSTR pcwszHttFile, LPCWSTR pcwszHttKey);

// seccerts.cpp
BOOL WINAPI ImportSiteCertA(LPCSTR pcszInsFile, LPCSTR pcszSCWorkDir, LPCSTR pcszSCInf, BOOL fImportSC);
BOOL WINAPI ImportSiteCertW(LPCWSTR pcwszInsFile, LPCWSTR pcwszSCWorkDir, LPCWSTR pcwszSCInf, BOOL fImportSC);
BOOL WINAPI ModifySiteCert(HWND hDlg);
BOOL WINAPI ImportAuthCodeA(LPCSTR pcszInsFile, LPCSTR pcszAuthWorkDir, LPCSTR pcszAuthInf, BOOL fImportAuth);
BOOL WINAPI ImportAuthCodeW(LPCWSTR pcwszInsFile, LPCWSTR pcwszAuthWorkDir, LPCWSTR pcwszAuthInf, BOOL fImportAuth);
BOOL WINAPI ModifyAuthCode(HWND hDlg);

// seczones.cpp
BOOL WINAPI ImportZonesA(LPCSTR pcszInsFile, LPCSTR pcszZonesWorkDir, LPCSTR pcszZonesInf, BOOL fImportZones);
BOOL WINAPI ImportZonesW(LPCWSTR pcwszInsFile, LPCWSTR pcwszZonesWorkDir, LPCWSTR pcwszZonesInf, BOOL fImportZones);
BOOL WINAPI ModifyZones(HWND hDlg);
BOOL WINAPI ImportRatingsA(LPCSTR pcszInsFile, LPCSTR pcszRatingsWorkDir, LPCSTR pcszRatingsInf, BOOL fImportRatings);
BOOL WINAPI ImportRatingsW(LPCWSTR pcwszInsFile, LPCWSTR pcwszRatingsWorkDir, LPCWSTR pcwszRatingsInf, BOOL fImportRatings);
BOOL WINAPI ModifyRatings(HWND hDlg);

// oe.cpp
BOOL WINAPI ImportLDAPBitmapA(LPCSTR pcszIns, LPCSTR pcszWorkDir, BOOL fImport);
BOOL WINAPI ImportLDAPBitmapW(LPCWSTR pcwszIns, LPCWSTR pcwszWorkDir, BOOL fImport);
BOOL WINAPI ImportOEInfoA(LPCSTR pcszIns, LPCSTR pcszWorkDir, BOOL fImport);
BOOL WINAPI ImportOEInfoW(LPCWSTR pcwszIns, LPCWSTR pcwszWorkDir, BOOL fImport);
BOOL WINAPI EncodeSignatureA(LPCSTR pcszFrom, LPSTR pszTo, BOOL fEncode);
BOOL WINAPI EncodeSignatureW(LPCWSTR pcwszFrom, LPWSTR pwszTo, BOOL fEncode);

// utils.cpp
#define FC_NONNULL      0x00000001
#define FC_URL          0x00000002
#define FC_NOSPACE      0x00000004
#define FC_NOCOLON      0x00000008
#define FC_PATH         0x00000010
#define FC_NOEXCHAR     0x00000020
#define FC_EXISTS       0x00000040
#define FC_FILE         (FC_PATH | 0x00000100)
#define FC_DIR          (FC_PATH | 0x00000200)
#define FC_NUMBER       0x00000080
BOOL WINAPI CheckField(HWND hDlg, int nIDDlgItem, DWORD dwFlags, LPARAM lParam = 0);

#define BMP_SMALLER     0x00000001   // bitmap file must have dimensions smaller than cx and cy
#define BMP_EXACT       0x00000002   // bitmap must be exact size specified

BOOL IsAnimBitmapFileValidA(HWND hDlg, UINT nID, LPSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                              UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth);
BOOL IsAnimBitmapFileValidW(HWND hDlg, UINT nID, LPWSTR pszBuffer, PUINT pcch, UINT nIDTooBig,
                              UINT nIDTooSmall, long lBmpMinWidth, long lBmpMaxWidth);

BOOL WINAPI IsBitmapFileValidA(HWND hDlg, UINT nID, LPSTR pszBuffer, PUINT pcch, int cx,
                               int cy, UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags = 0);
BOOL WINAPI IsBitmapFileValidW(HWND hDlg, UINT nID, LPWSTR pwszBuffer, PUINT pcch, int cx,
                               int cy, UINT nIDTooBig, UINT nIDTooSmall, DWORD dwFlags = 0);

BOOL WINAPI BrowseForFileA(HWND hDlg, LPSTR pszFileName, DWORD cchSize, DWORD dwFilterMasks,
                           LPCSTR pcszTitle = NULL);
BOOL WINAPI BrowseForFileW(HWND hDlg, LPWSTR pwszFileName, DWORD cchSize, DWORD dwFilterMasks,
                           LPCWSTR pcwszTitle = NULL);
BOOL WINAPI BrowseForFolderA(HWND hDlg, LPSTR pszFileName, LPCSTR pcszDesc = NULL);
BOOL WINAPI BrowseForFolderW(HWND hDlg, LPWSTR pwszFileName, LPCWSTR pcwszDesc = NULL);
void WINAPI ErrorMessageBox(HWND hWnd, UINT idErrorStr, DWORD dwFlags = 0);
void WINAPI ExportRegTree2InfA(HKEY hkSubKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey,
                               HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegTree2InfW(HKEY hkSubKey, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey,
                               HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegKey2InfA(HKEY hkSubKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey,
                              HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegKey2InfW(HKEY hkSubKey, LPCWSTR pcwszRootKey, LPCWSTR pcwszSubKey,
                              HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegValue2InfA(HKEY hkSubKey, LPCSTR pcszValue, LPCSTR pcszRootKey,
                                LPCSTR pcszSubKey, HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI ExportRegValue2InfW(HKEY hkSubKey, LPCWSTR pcwszValue, LPCWSTR pcwszRootKey,
                                LPCWSTR pcwszSubKey, HANDLE hInf, BOOL fUseLdids = FALSE);
void WINAPI SignFileA(LPCSTR pcszFilename, LPCSTR pcszDir, LPCSTR pcszIns,
                      LPSTR pszUnsignedFiles = NULL, LPCSTR pcszCustInf = NULL, BOOL fTest = FALSE);
void WINAPI SignFileW(LPCWSTR pcwszFilename, LPCWSTR pcwszDir, LPCWSTR pcwszIns,
                      LPWSTR pwszUnsignedFiles = NULL, LPCWSTR pcwszCustInf = NULL, BOOL fTest = FALSE);
void WINAPI DoReboot(HWND hwndUI);

void WINAPI ShowInetcpl(HWND hDlg, DWORD dwPages, DWORD dwMode = IEM_ADMIN);
void WINAPI SetLBWidth(HWND hLb);

// dlgprocs.cpp
void WINAPI TestURLA(LPCSTR pcszUrl);
void WINAPI TestURLW(LPCWSTR pcwszUrl);
void WINAPI SetProxyDlgA(HWND hDlg, LPCSTR pcszProxy, DWORD dwIdName, DWORD dwIdPort,
                         BOOL fDef80);
void WINAPI SetProxyDlgW(HWND hDlg, LPCWSTR pcwszProxy, DWORD dwIdName, DWORD dwIdPort,
                         BOOL fDef80);
void WINAPI GetProxyDlgA(HWND hDlg, LPSTR pszProxy, DWORD dwIdName, DWORD dwIdPort);
void WINAPI GetProxyDlgW(HWND hDlg, LPWSTR pwszProxy, DWORD dwIdName, DWORD dwIdPort);
HPALETTE WINAPI BuildPalette(HDC hdc);
void WINAPI ShowBitmapA(HWND hControl, LPCSTR pcszFileName, int nBitmapId, PHANDLE pBitmap);
void WINAPI ShowBitmapW(HWND hControl, LPCWSTR pcwszFileName, int nBitmapId, PHANDLE pBitmap);
BOOL WINAPI CopyAnimBmpA(HWND hDlg, LPSTR pszBmp, LPCSTR pcszWorkDir, LPCSTR pcszNameStr,
                         LPCSTR pcszPathStr, LPCSTR pcszInsFile);
BOOL WINAPI CopyAnimBmpW(HWND hDlg, LPWSTR pwszBmp, LPCWSTR pcwszWorkDir, LPCWSTR pcwszNameStr,
                         LPCWSTR pcwszPathStr, LPCWSTR pcwszInsFile);
BOOL WINAPI CopyLogoBmpA(HWND hDlg, LPSTR pszBmp, LPCSTR pcszLogoStr,
                         LPCSTR pcszWorkDir, LPCSTR pcszInsFile);
BOOL WINAPI CopyLogoBmpW(HWND hDlg, LPWSTR pwszBmp, LPCWSTR pcwszLogoStr,
                         LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile);
BOOL WINAPI CopyWallPaperA(HWND hDlg, LPCSTR pcszWallPaper, UINT nBitmapId,
                           LPCSTR pcszWorkDir, LPCSTR pcszInsFile, BOOL fCopy);
BOOL WINAPI CopyWallPaperW(HWND hDlg, LPCWSTR pcwszWallPaper, UINT nBitmapId,
                           LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile, BOOL fCopy);

// urls.cpp

void WINAPI InitializeStartSearchA(HWND hDlg, LPCSTR pcszInsFile, LPCSTR pcszServerFile);
void WINAPI InitializeStartSearchW(HWND hDlg, LPCWSTR pcwszInsFile, LPCWSTR pcwszServerFile);
BOOL WINAPI SaveStartSearchA(HWND hDlg, LPCSTR pcszInsFile, LPCSTR pcszServerFile,
                             BOOL *pfInsDirty = NULL, BOOL fCheckDirtyOnly = FALSE);
BOOL WINAPI SaveStartSearchW(HWND hDlg, LPCWSTR pcwszInsFile, LPCWSTR pcwszServerFile,
                             BOOL *pfInsDirty = NULL, BOOL fCheckDirtyOnly = FALSE);

// btoolbar.cpp
DWORD WINAPI BToolbar_InitA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszAltDir, LPCSTR pcszWorkDir);
DWORD WINAPI BToolbar_InitW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszAltDir, LPCWSTR pcwszWorkDir);
void  WINAPI BToolbar_Remove(HWND hwndList);
void  WINAPI BToolbar_Edit(HWND hwndList, BOOL fAdd);
void  WINAPI BToolbar_SaveA(HWND hwndList, LPCSTR pcszCustIns, LPCSTR pcszBToolbarDir, DWORD dwMode = IEM_NEUTRAL);
void  WINAPI BToolbar_SaveW(HWND hwndList, LPCWSTR pcwszCustIns, LPCWSTR pcwszBToolbarDir, DWORD dwMode = IEM_NEUTRAL);

// connset.cpp
BOOL WINAPI ImportConnectSetA(LPCSTR pcszIns, LPCSTR pcszTargetPath, LPCSTR pcszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCSTR pcszPbkFile = NULL, HKEY hkRoot = NULL);
BOOL WINAPI ImportConnectSetW(LPCWSTR pcwszIns, LPCWSTR pcwszTargetPath, LPCWSTR pcwszCleanupPath,
    BOOL fImport, DWORD dwMode, LPCWSTR pcwszPbkFile = NULL, HKEY hkRoot = NULL);

// programs.cpp
BOOL WINAPI ImportProgramsA(LPCSTR pcszInsFile, LPCSTR pcszWorkDir, BOOL fImport);
BOOL WINAPI ImportProgramsW(LPCWSTR pcwszInsFile, LPCWSTR pcwszWorkDir, BOOL fImport);

// favsproc.cpp
BOOL WINAPI MigrateFavoritesA(LPCSTR pcszIns);
BOOL WINAPI MigrateFavoritesW(LPCWSTR pcwszIns);

void WINAPI MigrateToOldFavoritesA(LPCSTR pcszIns);
void WINAPI MigrateToOldFavoritesW(LPCWSTR pcwszIns);

int  WINAPI ImportFavoritesA(HWND htv, LPCSTR pcszDefInf, LPCSTR pcszIns, LPCSTR pcszFixPath,
                             LPCSTR pcszNewPath, BOOL fIgnoreOffline);
int  WINAPI ImportFavoritesW(HWND htv, LPCWSTR pcwszDefInf, LPCWSTR pcwszIns,
                             LPCWSTR pcwszFixPath, LPCWSTR pcwszNewPath, BOOL fIgnoreOffline);

int  WINAPI ImportQuickLinksA(HWND htv, LPCSTR pcszDefInf, LPCSTR pcszIns, LPCSTR pcszFixPath,
                              LPCSTR pcszNewPath, BOOL fIgnoreOffline);
int  WINAPI ImportQuickLinksW(HWND htv, LPCWSTR pcwszDefInf, LPCWSTR pcwszIns,
                              LPCWSTR pcwszFixPath, LPCWSTR pcwszNewPath, BOOL fIgnoreOffline);

BOOL WINAPI NewUrlA(HWND htv, LPCSTR pcszExtractPath, DWORD dwPlatformID, DWORD dwMode);
BOOL WINAPI NewUrlW(HWND htv, LPCWSTR pcwszExtractPath, DWORD dwPlatformID, DWORD dwMode);

BOOL WINAPI NewFolder(HWND htv);

BOOL WINAPI ModifyFavoriteA(HWND htv, HTREEITEM hti, LPCSTR  pcszExtractPath,  LPCSTR   pcszPrevExtractPath,  DWORD dwPlatformID, DWORD dwMode);
BOOL WINAPI ModifyFavoriteW(HWND htv, HTREEITEM hti, LPCWSTR pcwszExtractPath, LPCWSTR  pcwszPrevExtractPath, DWORD dwPlatformID, DWORD dwMode);

BOOL WINAPI DeleteFavoriteA(HWND htv, HTREEITEM hti, LPCSTR  pcszExtractPath);
BOOL WINAPI DeleteFavoriteW(HWND htv, HTREEITEM hti, LPCWSTR pcwszExtractPath);

BOOL WINAPI MoveUpFavorite  (HWND htv, HTREEITEM hti);
BOOL WINAPI MoveDownFavorite(HWND htv, HTREEITEM hti);

BOOL WINAPI IsFavoriteItem       (HWND htv, HTREEITEM hti);
UINT WINAPI GetFavoritesNumber   (HWND htv, BOOL fQL = FALSE);
UINT WINAPI GetFavoritesMaxNumber(BOOL fQL = FALSE);

int  WINAPI ImportFavoritesCmdA(HWND htv, LPCSTR pcszExtractPath);
int  WINAPI ImportFavoritesCmdW(HWND htv, LPCWSTR pcwszExtractPath);

void WINAPI ExportFavoritesA(HWND htv, LPCSTR pcszIns, LPCSTR pcszExtractPath, BOOL fFixUpPath);
void WINAPI ExportFavoritesW(HWND htv, LPCWSTR pcwszIns, LPCWSTR pcwszExtractPath, BOOL fFixUpPath);

void WINAPI ExportQuickLinksA(HWND htv, LPCSTR pcszIns, LPCSTR pcszExtractPath, BOOL fFixUpPath);
void WINAPI ExportQuickLinksW(HWND htv, LPCWSTR pcwszIns, LPCWSTR pcwszExtractPath, BOOL fFixUpPath);

void WINAPI GetFavoritesInfoTipA(LPNMTVGETINFOTIPA pGetInfoTipA);
void WINAPI GetFavoritesInfoTipW(LPNMTVGETINFOTIPW pGetInfoTipW);

BOOL WINAPI GetFavoriteUrlA(HWND htv, HTREEITEM hti, LPSTR pszUrl, DWORD cchSize);
BOOL WINAPI GetFavoriteUrlW(HWND htv, HTREEITEM hti, LPWSTR pwszUrl, DWORD cchSize);

void WINAPI ProcessFavSelChange(HWND hDlg, HWND hTv, LPNMTREEVIEW pnmtv);

// adm.cpp
void WINAPI CreateADMWindow(HWND hOwner, HWND hWndInsertAfter, int nXPos, int nYPos,
                            int nWidth, int nHeight);
void WINAPI ShowADMWindow(HWND hOwner, BOOL fShow);
void WINAPI MoveADMWindow(HWND hOwner, int nXPos, int nYPos, int nWidth, int nHeight);
void WINAPI SetADMWindowTextA(HWND hOwner, LPCSTR pcszTitle, LPCSTR pcszText,
                              BOOL fUpdateWindowState  = TRUE);
void WINAPI SetADMWindowTextW(HWND hOwner, LPCWSTR pcwszTitle, LPCWSTR pcwszText,
                              BOOL fUpdateWindowState = TRUE);
void WINAPI DestroyADMWindow(HWND hOwner);
BOOL WINAPI IsADMFileVisibleA(LPCSTR pcszFileName, int nRole, DWORD dwPlatformId);
BOOL WINAPI IsADMFileVisibleW(LPCWSTR pcwszFileName, int nRole, DWORD dwPlatformId);
BOOL WINAPI LoadADMFilesA(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCSTR pcszADMFilePath,
                          LPCSTR pcszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory);
BOOL WINAPI LoadADMFilesW(HWND hTreeView, HTREEITEM hPolicyRootItem, LPCWSTR pcwszADMFilePath,
                          LPCWSTR pcwszWorkDir, DWORD dwPlatformId, int nRole,
                          int nIconADMClose, int nIconADMCategory);
void WINAPI DeleteADMItemA(HWND hTreeView, HTREEITEM hParentItem, LPCSTR pcszWorkDir,
                           LPCSTR pcszInsFile, BOOL bDeleteFile, BOOL bSave);
void WINAPI DeleteADMItemW(HWND hTreeView, HTREEITEM hParentItem, LPCWSTR pcwszWorkDir,
                           LPCWSTR pcwszInsFile, BOOL bDeleteFile, BOOL bSave);
void WINAPI DeleteADMItemsA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile,
                            BOOL bSave);
void WINAPI DeleteADMItemsW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile,
                            BOOL bSave);
void WINAPI DisplayADMItem(HWND hWnd, HWND hTreeView, LPTVITEM lpSelectedItem,
                           BOOL fShowDisabled);
void WINAPI SelectADMItem(HWND hMainWnd, HWND hTreeView, LPTVITEM lpTVItem,
                          BOOL bSelect, BOOL fShowDisabled);
void WINAPI ImportADMFileA(HWND hMainWnd, HWND hTreeView, LPCSTR pcszADMFilePath,
                           LPCSTR pcszWorkDir, int nRole, LPCSTR pcszInsFile);
void WINAPI ImportADMFileW(HWND hMainWnd, HWND hTreeView, LPCWSTR pcwszADMFilePath,
                           LPCWSTR pcwszWorkDir, int nRole, LPCWSTR pcwszInsFile);
void WINAPI CheckForDupKeys(HWND hMainWnd, HWND hTreeView, HTREEITEM hItem,
                            BOOL bDispSuccessMsg);
void WINAPI ResetAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, BOOL bReset);
void WINAPI ResetAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, BOOL bReset);
void WINAPI SaveAdmFilesA(HWND hTreeView, LPCSTR pcszWorkDir, LPCSTR pcszInsFile);
void WINAPI SaveAdmFilesW(HWND hTreeView, LPCWSTR pcwszWorkDir, LPCWSTR pcwszInsFile);
BOOL WINAPI CanDeleteADM(HWND hTreeView, HTREEITEM hItem);
HWND WINAPI GetAdmWindowHandle(HWND hTreeView, HTREEITEM hItem);
BOOL WINAPI AdmDirty();
void WINAPI ClearAdmDirtyFlag();

// these #defines is also used in insedit.dll

#define ITEM_SAVE       0x00000001
#define ITEM_DESTROY    0x00000002
#define ITEM_CHECKDIRTY 0x00000004

void WINAPI SaveADMItem(HWND hTreeView, LPTVITEM lpTVItem, DWORD dwFlags);
BOOL WINAPI GetAdmFileListA(LPRESULTITEMA* pResultItemsArrayA, int* pnResultItems, int nRole);
BOOL WINAPI GetAdmFileListW(LPRESULTITEMW* pResultItemsArrayW, int* pnResultItems, int nRole);
HTREEITEM WINAPI AddADMItemA(HWND hTreeView, LPCSTR pcszADMFilePath, LPCSTR pcszFileName,
                            LPCSTR pcszWorkDir, int nRole, BSTR bstrRSOPNamespace);
HTREEITEM WINAPI AddADMItemW(HWND hTreeView, LPCWSTR pcwszADMFilePath, LPCWSTR pcwszFileName,
                            LPCWSTR pcwszWorkDir, int nRole, BSTR bstrRSOPNamespace);

// version.cpp
int WINAPI CheckVerA(LPCSTR pcszPrevVer, LPCSTR pcszNewVer);
int WINAPI CheckVerW(LPCWSTR pcwszPrevVer, LPCWSTR pcwszNewVer);
void WINAPI GenerateNewVersionStrA(LPCSTR pcszInsFile, LPSTR pszNewVersionStr);
void WINAPI GenerateNewVersionStrW(LPCWSTR pcwszInsFile, LPWSTR pwszNewVersionStr);
void WINAPI SetOrClearVersionInfoA(LPCSTR pcszInsFile, DWORD dwCabType, LPCSTR pcszCabName,
                            LPCSTR pcszCabsURLPath, LPSTR pszNewVersionStr, BOOL fSet);
void WINAPI SetOrClearVersionInfoW(LPCWSTR pcwszInsFile, DWORD dwCabType, LPCWSTR pcwszCabName,
                            LPCWSTR pcwszCabsURLPath, LPWSTR pwszNewVersionStr, BOOL fSet);
void WINAPI GetBaseFileNameA(LPCSTR pcszFile, LPSTR pszBaseFileName, INT cchSize);
void WINAPI GetBaseFileNameW(LPCWSTR pcwszFile, LPWSTR pwszBaseFileName, INT cchSize);

// TCHAR mappings for functions

#ifdef UNICODE                                                  //UNICODE

#define ImportADTInfo           ImportADTInfoW                  // desktop.cpp

#define ImportToolbarInfo       ImportToolbarInfoW              // toolbar.cpp

#define CopyHttFile             CopyHttFileW                    // mccphtt.cpp

#define ImportSiteCert          ImportSiteCertW                 // seccerts.cpp
#define ImportAuthCode          ImportAuthCodeW

#define ImportZones             ImportZonesW                    // seczones.cpp
#define ImportRatings           ImportRatingsW

#define ImportLDAPBitmap        ImportLDAPBitmapW               // oe.cpp
#define ImportOEInfo            ImportOEInfoW
#define EncodeSignature         EncodeSignatureW

#define BrowseForFile           BrowseForFileW                  // utils.cpp
#define BrowseForFolder         BrowseForFolderW
#define ExportRegTree2Inf       ExportRegTree2InfW
#define ExportRegKey2Inf        ExportRegKey2InfW
#define ExportRegValue2Inf      ExportRegValue2InfW
#define IsAnimBitmapFileValid   IsAnimBitmapFileValidW
#define IsBitmapFileValid       IsBitmapFileValidW
#define SignFile                SignFileW

#define TestURL                 TestURLW                        // dlgprocs.cpp
#define SetProxyDlg             SetProxyDlgW
#define GetProxyDlg             GetProxyDlgW
#define ShowBitmap              ShowBitmapW
#define CopyAnimBmp             CopyAnimBmpW
#define CopyLogoBmp             CopyLogoBmpW
#define CopyWallPaper           CopyWallPaperW

#define InitializeStartSearch   InitializeStartSearchW          // urls.cpp
#define SaveStartSearch         SaveStartSearchW

#define BToolbar_Init           BToolbar_InitW                  // btoolbar.cpp
#define BToolbar_Save           BToolbar_SaveW

#define ImportConnectSet        ImportConnectSetW               // connset.cpp

#define ImportPrograms          ImportProgramsW                 // programs.cpp

#define MigrateFavorites        MigrateFavoritesW               // favsproc.cpp
#define MigrateToOldFavorites   MigrateToOldFavoritesW
#define ImportFavorites         ImportFavoritesW
#define ImportQuickLinks        ImportQuickLinksW
#define NewUrl                  NewUrlW
#define ModifyFavorite          ModifyFavoriteW
#define DeleteFavorite          DeleteFavoriteW
#define ImportFavoritesCmd      ImportFavoritesCmdW
#define ExportFavorites         ExportFavoritesW
#define ExportQuickLinks        ExportQuickLinksW
#define GetFavoritesInfoTip     GetFavoritesInfoTipW
#define GetFavoriteUrl          GetFavoriteUrlW

#define SetADMWindowText        SetADMWindowTextW               // adm.cpp
#define IsADMFileVisible        IsADMFileVisibleW
#define LoadADMFiles            LoadADMFilesW
#define DeleteADMItem           DeleteADMItemW
#define DeleteADMItems          DeleteADMItemsW
#define ImportADMFile           ImportADMFileW
#define ResetAdmFiles           ResetAdmFilesW
#define SaveAdmFiles            SaveAdmFilesW
#define GetAdmFileList          GetAdmFileListW
#define AddADMItem              AddADMItemW

#define CheckVer                CheckVerW                       // version.cpp
#define GenerateNewVersionStr   GenerateNewVersionStrW
#define SetOrClearVersionInfo   SetOrClearVersionInfoW
#define GetBaseFileName         GetBaseFileNameW

#else   //----------------------------------------------------  !UNICODE

#define ImportADTInfo           ImportADTInfoA                  // desktop.cpp

#define ImportToolbarInfo       ImportToolbarInfoA              // toolbar.cpp

#define CopyHttFile             CopyHttFileA                    // mccphtt.cpp

#define ImportSiteCert          ImportSiteCertA                 // seccerts.cpp
#define ImportAuthCode          ImportAuthCodeA

#define ImportZones             ImportZonesA                    // seczones.cpp
#define ImportRatings           ImportRatingsA

#define ImportLDAPBitmap        ImportLDAPBitmapA               // oe.cpp
#define ImportOEInfo            ImportOEInfoA
#define EncodeSignature         EncodeSignatureA

#define BrowseForFile           BrowseForFileA                  // utils.cpp
#define BrowseForFolder         BrowseForFolderA
#define ExportRegTree2Inf       ExportRegTree2InfA
#define ExportRegKey2Inf        ExportRegKey2InfA
#define ExportRegValue2Inf      ExportRegValue2InfA
#define IsAnimBitmapFileValid   IsAnimBitmapFileValidA
#define IsBitmapFileValid       IsBitmapFileValidA
#define SignFile                SignFileA

#define TestURL                 TestURLA                        // dlgprocs.cpp
#define SetProxyDlg             SetProxyDlgA
#define GetProxyDlg             GetProxyDlgA
#define ShowBitmap              ShowBitmapA
#define CopyAnimBmp             CopyAnimBmpA
#define CopyLogoBmp             CopyLogoBmpA
#define CopyWallPaper           CopyWallPaperA

#define InitializeStartSearch   InitializeStartSearchA          // urls.cpp
#define SaveStartSearch         SaveStartSearchA

#define BToolbar_Init           BToolbar_InitA                  // btoolbar.cpp
#define BToolbar_Save           BToolbar_SaveA

#define ImportConnectSet        ImportConnectSetA               // connset.cpp

#define ImportPrograms          ImportProgramsA                 // programs.cpp

#define MigrateFavorites        MigrateFavoritesA               // favsproc.cpp
#define MigrateToOldFavorites   MigrateToOldFavoritesA
#define ImportFavorites         ImportFavoritesA
#define ImportQuickLinks        ImportQuickLinksA
#define NewUrl                  NewUrlA
#define ModifyFavorite          ModifyFavoriteA
#define DeleteFavorite          DeleteFavoriteA
#define ImportFavoritesCmd      ImportFavoritesCmdA
#define ExportFavorites         ExportFavoritesA
#define ExportQuickLinks        ExportQuickLinksA
#define GetFavoritesInfoTip     GetFavoritesInfoTipA
#define GetFavoriteUrl          GetFavoriteUrlA

#define SetADMWindowText        SetADMWindowTextA               // adm.cpp
#define IsADMFileVisible        IsADMFileVisibleA
#define LoadADMFiles            LoadADMFilesA
#define DeleteADMItem           DeleteADMItemA
#define DeleteADMItems          DeleteADMItemsA
#define ImportADMFile           ImportADMFileA
#define ResetAdmFiles           ResetAdmFilesA
#define SaveAdmFiles            SaveAdmFilesA
#define GetAdmFileList          GetAdmFileListA
#define AddADMItem              AddADMItemA

#define CheckVer                CheckVerA                       // version.cpp
#define GenerateNewVersionStr   GenerateNewVersionStrA
#define SetOrClearVersionInfo   SetOrClearVersionInfoA
#define GetBaseFileName         GetBaseFileNameA

#endif

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _EXPORTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\desktop.cpp ===
//
// DESKTOP.CPP
//

#include "precomp.h"


// prototype declarations
static BOOL ImportADTInfoHelper(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADT);
static BOOL ImportDesktopComps(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADTComps);
static BOOL ImportWallpaperInfo(LPCTSTR pcszInsFile, LPCTSTR pcszWallpaperWorkDir, BOOL fImportWallpaper);
static BOOL RunningOnWin98();

BOOL WINAPI ImportADTInfoA(LPCSTR pcszInsFile, LPCSTR pcszDeskWorkDir, LPCSTR pcszDeskInf, BOOL fImportADT)
{
    USES_CONVERSION;

    return ImportADTInfoHelper(A2CT(pcszInsFile), A2CT(pcszDeskWorkDir), A2CT(pcszDeskInf), fImportADT);
}

BOOL WINAPI ImportADTInfoW(LPCWSTR pcwszInsFile, LPCWSTR pcwszDeskWorkDir, LPCWSTR pcwszDeskInf, BOOL fImportADT)
{
    USES_CONVERSION;

    return ImportADTInfoHelper(W2CT((LPWSTR)pcwszInsFile), W2CT((LPWSTR)pcwszDeskWorkDir), W2CT((LPWSTR)pcwszDeskInf), fImportADT);
}

BOOL WINAPI ShowDeskCpl(VOID)
{
    BOOL bRet = FALSE;
    HKEY hkPol;
    DWORD dwOldScrSav = 0, dwOldAppearance = 0, dwOldSettings = 0;

    // display desk.cpl (right-click->properties on the desktop) but hide the ScreenSaver, Appearance and Settings
    // tabs by setting their corresponding reg values to 1
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_DEFAULT_ACCESS, NULL, &hkPol, NULL) == ERROR_SUCCESS)
    {
        DWORD dwData = 1;
        DWORD cbSize;

        // save the old values before setting them to 1

        cbSize = sizeof(dwOldScrSav);
        RegQueryValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE, NULL, NULL, (LPBYTE) &dwOldScrSav, &cbSize);
        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));

        cbSize = sizeof(dwOldAppearance);
        RegQueryValueEx(hkPol, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE, NULL, NULL, (LPBYTE) &dwOldAppearance, &cbSize);
        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));

        cbSize = sizeof(dwOldSettings);
        RegQueryValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE, NULL, NULL, (LPBYTE) &dwOldSettings, &cbSize);

        // if we are running on Win98, because of a bug in desk.cpl, if all the restrictions for the tabs in Display properties
        // are set to 1, the Web tab doesn't show up.  Workaround for this bug is to not set the SettingsPage to 1.
        if (!IsOS(OS_MEMPHIS))
            RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));

        RegCloseKey(hkPol);
    }

    bRet = RunAndWaitA("rundll32.exe shell32.dll,Control_RunDLL desk.cpl", NULL, SW_SHOW);

    // restore the original values
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_DEFAULT_ACCESS, NULL, &hkPol, NULL) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSCRSAVPAGE, 0, REG_DWORD,
                            (CONST BYTE *) &dwOldScrSav, sizeof(dwOldScrSav));

        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE, 0, REG_DWORD,
                            (CONST BYTE *) &dwOldAppearance, sizeof(dwOldAppearance));

        RegSetValueEx(hkPol, REGSTR_VAL_DISPCPL_NOSETTINGSPAGE, 0, REG_DWORD,
                            (CONST BYTE *) &dwOldSettings, sizeof(dwOldSettings));

        RegCloseKey(hkPol);
    }

    return bRet;
}


static BOOL ImportADTInfoHelper(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADT)
{
    BOOL bRet = TRUE;

    if (pcszInsFile == NULL  ||  pcszDeskWorkDir == NULL  ||  pcszDeskInf == NULL)
        return FALSE;

    bRet = ImportDesktopComps(pcszInsFile, pcszDeskWorkDir, pcszDeskInf, fImportADT)  &&  bRet;
    bRet = ImportWallpaperInfo(pcszInsFile, pcszDeskWorkDir, fImportADT)  &&  bRet;

    return bRet;
}

static BOOL ImportDesktopComps(LPCTSTR pcszInsFile, LPCTSTR pcszDeskWorkDir, LPCTSTR pcszDeskInf, BOOL fImportADTComps)
{
    BOOL bRet = FALSE;
    HKEY hkDesk;

    // Before processing anything, first clear out the entries in the INS file and delete work dirs

    // clear out the entries in the INS file that correspond to importing Active Desktop components
    InsWriteBool(DESKTOP_OBJ_SECT, IMPORT_DESKTOP, FALSE, pcszInsFile);
    InsWriteString(EXTREGINF, DESKTOP, NULL, pcszInsFile);

    // blow away the pcszDeskWorkDir and pcszDeskInf
    PathRemovePath(pcszDeskWorkDir);
    PathRemovePath(pcszDeskInf);

    if (!fImportADTComps)
        return TRUE;

                
    InsWriteBool(DESKTOP_OBJ_SECT, IMPORT_DESKTOP, TRUE, pcszInsFile);
            
    // Import the Active Desktop components
    if (RegOpenKeyEx(HKEY_CURRENT_USER, KEY_DESKTOP_COMP, 0, KEY_DEFAULT_ACCESS, &hkDesk) == ERROR_SUCCESS)
    {
        TCHAR szFullInfName[MAX_PATH];
        HANDLE hInf;

        if (PathIsFileSpec(pcszDeskInf))                        // create DESKTOP.INF under pcszDeskWorkDir
            PathCombine(szFullInfName, pcszDeskWorkDir, pcszDeskInf);
        else
            StrCpy(szFullInfName, pcszDeskInf);

        // create DESKTOP.INF file
        if ((hInf = CreateNewFile(szFullInfName)) != INVALID_HANDLE_VALUE)
        {
            DWORD dwType, dwOldGeneralFlags, dwGeneralFlags, cbSize;
            TCHAR szSubKey[MAX_PATH];
            DWORD dwIndex, cchSize;
            BOOL fUpdateIns = FALSE;
            
            dwOldGeneralFlags = 0;
            cbSize = sizeof(dwOldGeneralFlags);
            RegQueryValueEx(hkDesk, GEN_FLAGS, NULL, &dwType, (LPBYTE) &dwOldGeneralFlags, &cbSize);

            dwGeneralFlags = dwOldGeneralFlags | RD_DIRTY;
            RegSetValueEx(hkDesk, GEN_FLAGS, 0, dwType, (CONST BYTE *) &dwGeneralFlags, sizeof(dwGeneralFlags));

            // first, write the standard goo - [Version], [DefaultInstall], etc. - to DESKTOP.INF
            WriteStringToFile(hInf, (LPCVOID) DESK_INF_ADD, StrLen(DESK_INF_ADD));

            ExportRegKey2Inf(hkDesk, TEXT("HKCU"), KEY_DESKTOP_COMP, hInf);
            WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);

            // restore the original value for GEN_FLAGS
            RegSetValueEx(hkDesk, GEN_FLAGS, 0, dwType, (CONST BYTE *) &dwOldGeneralFlags, sizeof(dwOldGeneralFlags));

            // for each desktop component that's enumerated, spit out its information to DESKTOP.INF and
            // if it's a local file, copy it to pcszDeskWorkDir
            for (dwIndex = 0, cchSize = ARRAYSIZE(szSubKey);
                    RegEnumKeyEx(hkDesk, dwIndex, szSubKey, &cchSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
                    dwIndex++, cchSize = ARRAYSIZE(szSubKey))
            {
                HKEY hkSub;

                if (RegOpenKeyEx(hkDesk, szSubKey, 0, KEY_DEFAULT_ACCESS, &hkSub) == ERROR_SUCCESS)
                {
                    TCHAR szDeskCompFile[MAX_URL];
                    TCHAR szFullSubkey[MAX_PATH];
                    BOOL fRestoreSource = FALSE;

                    // get the name of the component from SOURCE
                    *szDeskCompFile = TEXT('\0');
                    cbSize = sizeof(szDeskCompFile);
                    RegQueryValueEx(hkSub, SOURCE, NULL, NULL, (LPBYTE) szDeskCompFile, &cbSize);

                    if (PathIsLocalPath(szDeskCompFile)  &&  PathFileExists(szDeskCompFile)  &&  !PathIsDirectory(szDeskCompFile))
                    {
                        // During branding time, all the local files get copied into the
                        // "<windows>\web" dir; so temporarily set the SOURCE in the registry
                        // to point to this location before it's exported to DESKTOP.INF

                        if (CopyFileToDir(szDeskCompFile, pcszDeskWorkDir))
                        {
                            TCHAR szNewPath[MAX_URL];

                            // if the file is a .htm file, then copy all the IMG SRC's specified in it to pcszDeskWorkDir
                            if (PathIsExtension(szDeskCompFile, TEXT(".htm"))  ||  PathIsExtension(szDeskCompFile, TEXT(".html")))
                                CopyHtmlImgs(szDeskCompFile, pcszDeskWorkDir, NULL, NULL);

                            wnsprintf(szNewPath, ARRAYSIZE(szNewPath), TEXT("%%25%%\\Web\\%s"), PathFindFileName(szDeskCompFile));

                            fRestoreSource = TRUE;

                            RegSetValueEx(hkSub, SOURCE, 0, REG_SZ, (CONST BYTE *)szNewPath, (DWORD)StrCbFromSz(szNewPath));
                            RegSetValueEx(hkSub, SUBSCRIBEDURL, 0, REG_SZ, (CONST BYTE *)szNewPath, (DWORD)StrCbFromSz(szNewPath));
                        }
                    }

                    // dump the registry info for this component to DESKTOP.INF
                    wnsprintf(szFullSubkey, ARRAYSIZE(szFullSubkey), TEXT("%s\\%s"), KEY_DESKTOP_COMP, szSubKey);
                    ExportRegKey2Inf(hkSub, TEXT("HKCU"), szFullSubkey, hInf);
                    WriteStringToFile(hInf, (LPCVOID) TEXT("\r\n"), 2);

                    fUpdateIns = TRUE;

                    if (fRestoreSource)
                    {
                        RegSetValueEx(hkSub, SOURCE, 0, REG_SZ, (CONST BYTE *)szDeskCompFile, (DWORD)StrCbFromSz(szDeskCompFile));
                        RegSetValueEx(hkSub, SUBSCRIBEDURL, 0, REG_SZ, (CONST BYTE *)szDeskCompFile, (DWORD)StrCbFromSz(szDeskCompFile));
                    }

                    RegCloseKey(hkSub);
                }
            }

            CloseFile(hInf);

            if (fUpdateIns)
            {
                TCHAR szBuf[MAX_PATH];
                
                // update the INS file
                wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("*,%s,DefaultInstall"), PathFindFileName(pcszDeskInf));
                WritePrivateProfileString(EXTREGINF, DESKTOP, szBuf, pcszInsFile);

                bRet = TRUE;
            }
            else
            {
                PathRemovePath(pcszDeskWorkDir);
                PathRemovePath(szFullInfName);
            }
        }

        RegCloseKey(hkDesk);
    }

    return bRet;
}


static BOOL ImportWallpaperInfo(LPCTSTR pcszInsFile, LPCTSTR pcszWallpaperWorkDir, BOOL fImportWallpaper)
{
    BOOL bRet = FALSE;
    HKEY hkDesk;

    // Before processing anything, first clear out the entries in the INS file

    // delete the WALLPAPER section in the INS file
    WritePrivateProfileString(WALLPAPER, NULL, NULL, pcszInsFile);

    if (!fImportWallpaper)
        return TRUE;

    // Import the wallpaper information
    if (RegOpenKeyEx(HKEY_CURRENT_USER, KEY_DESKTOP_GEN, 0, KEY_DEFAULT_ACCESS, &hkDesk) == ERROR_SUCCESS)
    {
        DWORD cbSize;
        TCHAR szWallpaperFile[MAX_PATH];

        *szWallpaperFile = TEXT('\0');
        cbSize = sizeof(szWallpaperFile);
        if (RegQueryValueEx(hkDesk, WALLPAPER, NULL, NULL, (LPBYTE) szWallpaperFile, &cbSize) != ERROR_SUCCESS  ||
            *szWallpaperFile == TEXT('\0'))
        {
            // try reading the information from BACKUPWALLPAPER
            cbSize = sizeof(szWallpaperFile);
            RegQueryValueEx(hkDesk, BACKUPWALLPAPER, NULL, NULL, (LPBYTE) szWallpaperFile, &cbSize);
        }

        // During branding time, all the wallpaper files specified in the INS file will
        // get copied into whatever dir that's specified in the registry or if not found,
        // into "<windows>\web\wallpaper"

        // BUGBUG: even if szWallpaperFile points to a UNC or network path, we will still copy the files
        // to pcszWallpaperWorkDir and during branding time, would get copied into the client's machine

        if (CopyFileToDirEx(szWallpaperFile, pcszWallpaperWorkDir, WALLPAPER, pcszInsFile))
        {
            TCHAR szBuf[16];
            DWORD dwPos = 0;

            // if the file is a local .htm file, then copy all the IMG SRC's specified in it to pcszWallpaperWorkDir
            if (PathIsExtension(szWallpaperFile, TEXT(".htm"))  ||  PathIsExtension(szWallpaperFile, TEXT(".htm")))
                CopyHtmlImgs(szWallpaperFile, pcszWallpaperWorkDir, WALLPAPER, pcszInsFile);

            cbSize = sizeof(dwPos);
            RegQueryValueEx(hkDesk, COMPONENTPOS, NULL, NULL, (LPBYTE) &dwPos, &cbSize);

            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%lu"), dwPos);

            // update the INS file
            WritePrivateProfileString(DESKTOP_OBJ_SECT, OPTION, TEXT("1"), pcszInsFile);
            WritePrivateProfileString(WALLPAPER, COMPONENTPOS, szBuf, pcszInsFile);

            bRet = TRUE;
        }

        RegCloseKey(hkDesk);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\favsproc.h ===
#ifndef __FAVORITES_H_
#define __FAVORITES_H_

#include <commctrl.h>
#include <subsmgr.h>

#define NUM_FAVS 200
#define NUM_LINKS 50

#define FTYPE_UNUSED 0
#define FTYPE_FOLDER 1
#define FTYPE_URL    2

#define FF_DEFAULT 0x0000
#define FF_NAME    0x0001
#define FF_PATH    0x0002
#define FF_URL     0x0004
#define FF_ICON    0x0008
#define FF_TVI     0x0010
#define FF_ALL     0x001F

struct SFav
{
// Constructors and destructors
public:
    SFav();
    ~SFav();

// Attiributes
public:
    WORD wType;

    LPTSTR pszName;
    LPTSTR pszPath;
    LPTSTR pszUrl;
    LPTSTR pszIconFile;
    BOOL   fOffline;

    LPTV_ITEM pTvItem;

// Properties
public:
    HRESULT Load(UINT nIndex, LPCTSTR pszIns, BOOL fQL = FALSE,
        LPCTSTR pszFixPath = NULL, LPCTSTR pszNewPath = NULL, BOOL fIgnoreOffline = FALSE);
    HRESULT Load(LPCTSTR pszName, LPCTSTR pszFavorite, LPCTSTR pszExtractPath,
        ISubscriptionMgr2 *psm = NULL, BOOL fIgnoreOffline = FALSE);
    HRESULT Add (HWND htv, HTREEITEM hti);
    HRESULT Save(HWND htv, UINT nIndex, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fQL = FALSE,
        BOOL fFixUpPath = TRUE);

    void SetTVI();

// Operations
public:
    static SFav* CreateNew   (HWND htv, BOOL fQL = FALSE);
    static SFav* GetFirst    (HWND htv, BOOL fQL = FALSE);
    SFav*        GetNext     (HWND htv, BOOL fQL = FALSE) const;
    void         Free        (HWND htv, BOOL fQL, LPCTSTR pszExtractPath = NULL);
    static UINT  GetNumber   (HWND htv, BOOL fQL = FALSE);
    static UINT  GetMaxNumber(BOOL fQL = FALSE);

    BOOL Expand(WORD wFlags = FF_DEFAULT);
    void Shrink(WORD wFlags = FF_ALL);
    void Delete(WORD wFlags = FF_ALL);

    BOOL GetPath(HWND htv, LPTSTR pszResult, UINT cchResult = 0) const;
};
typedef SFav FAVSTRUC, *LPFAVSTRUC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\ieakeng\favsproc.cpp ===
#include "precomp.h"
#include <olectl.h>

// Implementation helper structures/routines declarations
typedef struct tagFAVLIST {
    LPFAVSTRUC pfs;
    int        cElements;
} FAVLIST, (FAR *LPFAVLIST);

typedef struct tagPERCONTROLDATA {
    FAVLIST flFavorites;
    FAVLIST flQuickLinks;
} PERCONTROLDATA, (FAR *LPPERCONTROLDATA);

typedef struct tagAEFAVPARAMS {
    LPFAVSTRUC pfs;
    BOOL       fQL;

    HWND       hwndErrorParent;
    HWND       htv;
    HTREEITEM  hti;
    LPCTSTR    pszExtractPath;
    LPCTSTR    pszPrevExtractPath;

    DWORD      dwPlatformID;
    DWORD      dwMode;
} AEFAVPARAMS, (FAR *LPAEFAVPARAMS);

static BOOL migrateFavoritesHelper(LPCTSTR pszIns);
static void migrateToOldFavoritesHelper(LPCTSTR pszIns);
static int  importFavoritesHelper(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns,
    LPCTSTR pszFixPath, LPCTSTR pszNewPath, BOOL fIgnoreOffline);
static int  importQuickLinksHelper(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns,
    LPCTSTR pszFixPath, LPCTSTR pszNewPath, BOOL fIgnoreOffline);
static BOOL newUrlHelper(HWND htv, LPCTSTR pszExtractPath, DWORD dwPlatformID, DWORD dwMode);
static BOOL modifyFavoriteHelper(HWND htv, HTREEITEM hti, LPCTSTR pszExtractPath, LPCTSTR pszPrevExtractPath,
                                 DWORD dwPlatformID, DWORD dwMode);
static BOOL deleteFavoriteHelper(HWND htv, HTREEITEM hti, LPCTSTR pszExtractPath);
static int importFavoritesCmdHelper(HWND htv, LPCTSTR pszExtractPath);
static void exportFavoritesHelper(HWND htv, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath = TRUE);
static void exportQuickLinksHelper(HWND htv, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath = TRUE);
static void getFavoritesInfoTipHelper(LPNMTVGETINFOTIP pGetInfoTip);
static BOOL getFavoriteUrlHelper(HWND htv, HTREEITEM hti, LPTSTR pszUrl);

static int importItems(HWND htv, LPCTSTR pszDefInf, LPCTSTR pszIns, LPCTSTR pszFixPath, LPCTSTR pszNewPath,
                       BOOL fIgnoreOffline, BOOL fQL = FALSE);

static BOOL CALLBACK addEditFavoriteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

static LPFAVSTRUC getItem       (HWND htv, HTREEITEM hti);
static LPFAVSTRUC getFolderItem (HWND htv, HTREEITEM hti);
static LPFAVSTRUC findByName    (HWND htv, HTREEITEM hti, LPCTSTR pszName);
static LPFAVSTRUC findPath      (HWND htv, HTREEITEM hti, LPCTSTR pszFolders);
static HRESULT    isFavoriteItem(HWND htv, HTREEITEM hti);

static LPFAVSTRUC createFolderItems(HWND htv, HTREEITEM hti, LPCTSTR pszFolders);
static BOOL       importPath (HWND htv, HTREEITEM htiFrom, HTREEITEM *phtiAfter);
static void       importPath (HWND htv, HTREEITEM hti, LPCTSTR pszFilesPath, LPCTSTR pszExtractPath, LPCTSTR pszReserved = NULL);
static int        exportItems(HWND htv, HTREEITEM hti, LPCTSTR pszIns, LPCTSTR pszExtractPath, BOOL fFixUpPath = TRUE);

BOOL    extractIcon(LPCTSTR pszIconFile, int iIconIndex, LPCTSTR pszExtractPath, LPTSTR pszResult, UINT cchResult);
static LPCTSTR getLinksPath(LPTSTR pszPath, UINT cchPath = 0);

static LPTSTR encodeFavName(LPTSTR pszFavName, LPCTSTR pszIns);
static LPTSTR decodeFavName(LPTSTR pszFavName, LPCTSTR pszIns);


/////////////////////////////////////////////////////////////////////////////
// SFav constructors and destructors

SFav::SFav()
{
    wType = FTYPE_UNUSED;

    pszName     = NULL;
    pszPath     = NULL;
    pszUrl      = NULL;
    pszIconFile = NULL;
    fOffline    = FALSE;

    pTvItem = NULL;
}

SFav::~SFav()
{
    Delete();
}


/////////////////////////////////////////////////////////////////////////////
// SFav properties

HRESULT SFav::Load(UINT nIndex, LPCTSTR pszIns, BOOL fQL /*= FALSE*/,
    LPCTSTR pszFixPath /*= NULL*/, LPCTSTR pszNewPath /*= NULL*/, BOOL fIgnoreOffline /*= FALSE*/)
{
    TCHAR   szKey[32];
    LPCTSTR pszSection, pszKeyFmt;

    if (pszIns == NULL)
        return E_INVALIDARG;

    if (!fQL) {
        pszSection = IS_FAVORITESEX;
        pszKeyFmt  = IK_TITLE_FMT;
    }
    else {
        pszSection = IS_URL;
        pszKeyFmt  = IK_QUICKLINK_NAME;
    }

    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    if (InsIsKeyEmpty(pszSection, szKey, pszIns))
        return S_FALSE;

    wType = FTYPE_URL;
    if (!Expand())
        return E_OUTOFMEMORY;

    // Title
    pszKeyFmt = (!fQL ? IK_TITLE_FMT : IK_QUICKLINK_NAME);
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    InsGetString(pszSection, szKey, pszName, MAX_PATH, pszIns);
    if (*pszName == TEXT('\0'))
        goto Fail;

    // URL
    pszKeyFmt = (!fQL ? IK_URL_FMT : IK_QUICKLINK_URL);
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    InsGetString(pszSection, szKey, pszUrl, INTERNET_MAX_URL_LENGTH, pszIns);
    if (*pszUrl == TEXT('\0'))
        goto Fail;

    // Icon file (never required)
    pszKeyFmt = (!fQL ? IK_ICON_FMT : IK_QUICKLINK_ICON);
    wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
    InsGetString(pszSection, szKey, pszIconFile, INTERNET_MAX_URL_LENGTH, pszIns);

    if (*pszIconFile != TEXT('\0') && !PathIsURL(pszIconFile)) {
        BOOL fTryToFix;

        fTryToFix = FALSE;
        if (pszFixPath == NULL)
            fTryToFix = TRUE;

        else
            if (PathIsPrefix(pszFixPath, pszIconFile))
                fTryToFix = !PathFileExists(pszIconFile);

        if (fTryToFix && pszNewPath != NULL) {
            TCHAR szNewPath[MAX_PATH];

            PathCombine(szNewPath, pszNewPath, PathFindFileName(pszIconFile));
            StrCpy(pszIconFile, szNewPath);
            if (!PathFileExists(pszIconFile))
                *pszIconFile = TEXT('\0');
        }
    }

    // Make available offline flag
    fOffline = FALSE;
    if (!fIgnoreOffline) {
        pszKeyFmt = (!fQL ? IK_OFFLINE_FMT : IK_QUICKLINK_OFFLINE);
        wnsprintf(szKey, countof(szKey), pszKeyFmt, nIndex);
        fOffline  = InsGetBool(pszSection, szKey, FALSE, pszIns);
    }

    SetTVI();
    Shrink();
    return S_OK;

Fail:
    Delete();
    return E_FAIL;
}

HRESULT SFav::Load(LPCTSTR pszName, LPCTSTR pszFavorite, LPCTSTR pszExtractPath,
    ISubscriptionMgr2 *psm /*= NULL*/, BOOL fIgnoreOffline /*= FALSE*/)
{
    TCHAR szIconFile[INTERNET_MAX_URL_LENGTH];

    USES_CONVERSION;

    if (pszFavorite == NULL)
        return E_INVALIDARG;

    wType = FTYPE_URL;
    if (!Expand())
        return E_OUTOFMEMORY;

    // Title
    if (pszName == NULL)
        pszName = PathFindFileName(pszFavorite);
    else
        ASSERT(StrStrI(pszFavorite, pszName) != NULL);
    StrCpy(SFav::pszName, pszName);
    PathRenameExtension(SFav::pszName, DOT_URL);

    // URL
    InsGetString(IS_INTERNETSHORTCUT, IK_URL, pszUrl, INTERNET_MAX_URL_LENGTH, pszFavorite);
    if (*pszUrl == TEXT('\0'))
        goto Fail;

    // Icon file
    InsGetString(IS_INTERNETSHORTCUT, IK_ICONFILE, szIconFile, countof(szIconFile), pszFavorite);
    if (szIconFile[0] != TEXT('\0')) {
        int iIconIndex;

        iIconIndex = GetPrivateProfileInt(IS_INTERNETSHORTCUT, IK_ICONINDEX, 1, pszFavorite);
        ::extractIcon(szIconFile, iIconIndex, pszExtractPath, pszIconFile, INTERNET_MAX_URL_LENGTH);
    }

    // Make available offline flag
    fOffline = FALSE;
    if (!fIgnoreOffline) {
        HRESULT hr;
        BOOL    fOwnSubMgr;

        fOwnSubMgr = FALSE;
        if (psm == NULL) {
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (LPVOID *)&psm);
            if (SUCCEEDED(hr))
                fOwnSubMgr = TRUE;
        }

        if (psm != NULL) {
            hr = psm->IsSubscribed(T2W(pszUrl), &fOffline);
            if (FAILED(hr))
                fOffline = FALSE;
        }

        if (fOwnSubMgr)
            psm->Release();
    }

    SetTVI();
    Shrink();
    return S_OK;

Fail:
    Delete();
    return E_FAIL;
}

HRESULT SFav::Add(HWND htv, HTREEITEM hti)
{
    SFav            *pfsFolder;
    TV_INSERTSTRUCT tvins;
    HTREEITEM       htiParent;

    if (hti == NULL)
        hti = TreeView_GetSelection(htv);

    pfsFolder = NULL;
    if (wType == FTYPE_URL) {
        TCHAR   szFolders[MAX_PATH];
        LPTSTR  pszFile;

        pszFile = PathFindFileName(pszName);
        if (pszFile > pszName) {
            *(pszFile-1) = TEXT('\0');
            StrCpy(szFolders, pszName);
            StrCpy(pszName, pszFile);

            pfsFolder = ::createFolderItems(htv, hti, szFolders);
            if (pfsFolder == NULL)
                goto Fail;
        }
    }

    SetTVI();

    if (pfsFolder == NULL)
        pfsFolder = ::getFolderItem(htv, hti);
    if (pfsFolder != NULL) {
        if (pfsFolder->pTvItem == NULL || pfsFolder->pTvItem->hItem == NULL)
            goto Fail;

        htiParent = pfsFolder->pTvItem->hItem;
    }
    else
        htiParent = TVI_ROOT;

    ZeroMemory(&tvins, sizeof(tvins));
    tvins.hParent      = htiParent;
    tvins.hInsertAfter = TVI_LAST;

    CopyMemory(&tvins.item, pTvItem, sizeof(TV_ITEM));
    pTvItem->hItem = TreeView_InsertItem(htv, &tvins);

    pTvItem->mask  = TVIF_HANDLE | TVIF_STATE;
    TreeView_GetItem(htv, pTvItem);

    if (pfsFolder != NULL)
        TreeView_Expand(htv, htiParent, TVE_EXPAND);

    TreeView_Select