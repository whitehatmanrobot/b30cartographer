eclspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_SNAPIN_GETCOOKIE = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\fspext.cpp ===
// fspext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f fspextps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "fspext.h"

#include "fspext_i.c"
#include "FSP.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_FSP, CFSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
        ISnapInDataInterface::Init();
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__82C8EBD8_7584_11D1_83D6_00C04FB6E984__INCLUDED_)
#define AFX_STDAFX_H__82C8EBD8_7584_11D1_83D6_00C04FB6E984__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef  _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <mmc.h>
#include  <objidl.h>

#ifdef DEBUG
#define _DEBUG
#define _ATL_DEBUG_REFCOUNT
#define _ATL_DEBUG_QI
#endif

#include <windows.h>
#include <shellapi.h>
#include <tchar.h>

#include "faxutil.h" // defines Assert

#ifndef _ASSERTE
#define _ASSERTE    Assert
#endif

#include <atl21\atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atl21\atlwin.h>
#include <atl21\atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__82C8EBD8_7584_11D1_83D6_00C04FB6E984__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fspext.rc
//
#define IDS_PROJNAME                    100
#define IDB_FSP_16                      101
#define IDS_TITLE                       101
#define IDB_FSP_32                      102
#define IDD_FSP                         103
#define IDR_FSP                         104
#define IDS_BROWSE_TITLE                105
#define IDC_LOG_NONE                    201
#define IDC_LOG_ERRORS                  202
#define IDC_LOG_ALL                     203
#define IDC_LOGLOCATION                 204
#define IDC_LOGBROWSE                   205
#define IDC_STATIC                      206
#define IDC_LOCATION_LABEL              207

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         208
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\fsp.h ===
#ifndef __FSP_H_
#define __FSP_H_
#include "resource.h"
#include "atlsnap.h"
#include <shlobj.h>


#define LOGKEY                                          TEXT("Software\\Microsoft\\Fax\\Device Providers\\Microsoft Modem Device Provider")
#define LOGLEVEL                                        TEXT("ModemLogLevel")
#define LOGLOCATION                                     TEXT("ModemLogLocation")
#define LOGGING_NONE                                    0x0
#define LOGGING_ERRORS                                  0x1
#define LOGGING_ALL                                     0x100

class CFSPPage : public CPropertyPageImpl<CFSPPage>
{
private:
    BOOL m_bChanged;
    DWORD m_LoggingLevel;
    LPWSTR m_LoggingDirectory;
    HKEY m_LogKey;
public :
    CFSPPage(TCHAR* pTitle = NULL) : CPropertyPageImpl<CFSPPage> (pTitle)
	{
        m_bChanged = FALSE;
        m_LogKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,LOGKEY,FALSE,0);
        if  (!m_LogKey) {
            m_LoggingLevel = 0;
            m_LoggingDirectory = NULL;
        } else {
            m_LoggingLevel = GetRegistryDword(m_LogKey,LOGLEVEL);
            m_LoggingDirectory = GetRegistryString(m_LogKey,LOGLOCATION,TEXT(""));
        }

    }	

    ~CFSPPage() {
        if (m_LoggingDirectory) {
            MemFree(m_LoggingDirectory);
        }
        if (m_LogKey) {
            RegCloseKey(m_LogKey);
        }
    }

	enum { IDD = IDD_FSP };

	BEGIN_MSG_MAP(CFSPPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDC_LOG_NONE, DisableLogging);
        COMMAND_ID_HANDLER(IDC_LOG_ERRORS, EnableLogging);
        COMMAND_ID_HANDLER(IDC_LOG_ALL, EnableLogging);
        COMMAND_ID_HANDLER(IDC_LOGBROWSE, OnBrowseDir);
		CHAIN_MSG_MAP(CPropertyPageImpl<CFSPPage>)
	END_MSG_MAP()

    LRESULT DisableLogging(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT EnableLogging(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnBrowseDir(INT code, INT id, HWND hwnd, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);	

    VOID SetChangedFlag( BOOL Flag );

    BOOL OnApply();
private:
    BOOL BrowseForDirectory();
    BOOL ValidateLogLocation();

};

class CFSPData : public CSnapInDataInterface< CFSPData, TRUE >
{
	static const GUID* m_NODETYPE;
	static const TCHAR* m_SZNODETYPE;
	static const TCHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

public:
	static CComPtr<IControlbar> m_spControlBar;

public:

	CFSPData()
	{
	}

	~CFSPData()
	{
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle, IUnknown* pUnk)
	{   
        TCHAR Title[MAX_TITLE_LEN];
        LoadString(_Module.GetModuleInstance(),IDS_TITLE,Title,sizeof(Title));
		CFSPPage* pPage = new CFSPPage(Title);
		lpProvider->AddPage(pPage->Create());
		return S_OK;
	}

    STDMETHOD(QueryPagesFor)(void)
	{
		return S_OK;
	}

	void* GetNodeType()
	{
		return (void*)m_NODETYPE;
	}

	void* GetSZNodeType()
	{
		return (void*)m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)m_SNAPIN_CLASSID;
	}
	IDataObject* m_pDataObject;
	BOOL InitDataClass(IDataObject* pDataObject)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
		return TRUE;
	}
};

class CFSP : public CSnapinObjectRootEx<CComSingleThreadModel>,
	public IExtendPropertySheetImpl<CFSP>,
    public CComCoClass<CFSP, &CLSID_FSP>
{
public:
EXTENSION_SNAPIN_DATACLASS(CFSPData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CFSP)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CFSPData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CFSP)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FSP)

DECLARE_NOT_AGGREGATABLE(CFSP)

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\fspext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\atlsnap.h ===
#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#ifndef UNICODE
#error "Only Unicode builds supported"
#endif

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")


// Wrappers for propertypage and HBITMAP
#ifndef CPropertyPageImpl
#pragma comment(lib, "comctl32.lib")

template <class T>
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBase
{
public:
        PROPSHEETPAGE m_psp;

        operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
        CPropertyPageImpl(LPCTSTR lpszTitle = NULL)
        {
                // initialize PROPSHEETPAGE struct
                memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
                m_psp.dwSize = sizeof(PROPSHEETPAGE);
                m_psp.dwFlags = PSP_USECALLBACK;
                m_psp.hInstance = _Module.GetResourceInstance();
                m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
                m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
                m_psp.pfnCallback = T::PropPageCallback;
                m_psp.lParam = (LPARAM)this;

                if(lpszTitle != NULL)
                {
                        m_psp.pszTitle = lpszTitle;
                        m_psp.dwFlags |= PSP_USETITLE;
                }
        }

        static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
        {
                if(uMsg == PSPCB_CREATE)
                {
                        _ASSERTE(hWnd == NULL);
                        CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
                        _Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
                }

                return 1;
        }

        HPROPSHEETPAGE Create()
        {
                return ::CreatePropertySheetPage(&m_psp);
        }

        BOOL EndDialog(int)
        {
                // do nothing here, calling ::EndDialog will close the whole sheet
                _ASSERTE(FALSE);
                return FALSE;
        }

// Operations
        void CancelToClose()
        {
                _ASSERTE(::IsWindow(m_hWnd));
                _ASSERTE(GetParent() != NULL);

                ::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
        }
        void SetModified(BOOL bChanged = TRUE)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                _ASSERTE(GetParent() != NULL);

                if(bChanged)
                        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
                else
                        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
        }
        LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                _ASSERTE(GetParent() != NULL);

                return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
        }

        BEGIN_MSG_MAP(CPropertyPageImpl< T >)
                MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
        END_MSG_MAP()

// Message handler
        LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
        {
                _ASSERTE(::IsWindow(m_hWnd));
                NMHDR* pNMHDR = (NMHDR*)lParam;

                // don't handle messages not from the page/sheet itself
                if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
                {
                        bHandled = FALSE;
                        return 1;
                }

                T* pT = (T*)this;
                LRESULT lResult = 0;
                // handle default
                switch(pNMHDR->code)
                {
                case PSN_SETACTIVE:
                        lResult = pT->OnSetActive() ? 0 : -1;
                        break;
                case PSN_KILLACTIVE:
                        lResult = !pT->OnKillActive();
                        break;
                case PSN_APPLY:
                        lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
                        break;
                case PSN_RESET:
                        pT->OnReset();
                        break;
                case PSN_QUERYCANCEL:
                        lResult = !pT->OnQueryCancel();
                        break;
                case PSN_WIZNEXT:
                        lResult = !pT->OnWizardNext();
                        break;
                case PSN_WIZBACK:
                        lResult = !pT->OnWizardBack();
                        break;
                case PSN_WIZFINISH:
                        lResult = !pT->OnWizardFinish();
                        break;
                case PSN_HELP:
                        lResult = pT->OnHelp();
                        break;
                default:
                        bHandled = FALSE;       // not handled
                }

                return lResult;
        }

// Overridables
        BOOL OnSetActive()
        {
                return TRUE;
        }
        BOOL OnKillActive()
        {
                return TRUE;
        }
        BOOL OnApply()
        {
                return TRUE;
        }
        void OnReset()
        {
        }
        BOOL OnQueryCancel()
        {
                return TRUE;    // ok to cancel
        }
        BOOL OnWizardBack()
        {
                return TRUE;
        }
        BOOL OnWizardNext()
        {
                return TRUE;
        }
        BOOL OnWizardFinish()
        {
                return TRUE;
        }
        BOOL OnHelp()
        {
                return TRUE;
        }
};
#endif

#ifndef CBitmap
class CBitmap
{
public:
        HBITMAP m_hBitmap;

        CBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
        { }
        ~CBitmap()
        {
                if(m_hBitmap != NULL)
                        DeleteObject();
        }

        CBitmap& operator=(HBITMAP hBitmap)
        {
                m_hBitmap = hBitmap;
                return *this;
        }

        void Attach(HBITMAP hBitmap)
        {
                m_hBitmap = hBitmap;
        }
        HBITMAP Detach()
        {
                HBITMAP hBitmap = m_hBitmap;
                m_hBitmap = NULL;
                return hBitmap;
        }

        operator HBITMAP() const { return m_hBitmap; }

        HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
                return m_hBitmap;
        }
        HBITMAP LoadBitmap(UINT nIDResource)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
                return m_hBitmap;
        }
        HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
                return m_hBitmap;
        }
        HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
                return m_hBitmap;
        }
        HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
                return m_hBitmap;
        }
        HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
                return m_hBitmap;
        }
        HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
                return m_hBitmap;
        }
        HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
        {
                _ASSERTE(m_hBitmap == NULL);
                m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
                return m_hBitmap;
        }

        BOOL DeleteObject()
        {
                _ASSERTE(m_hBitmap != NULL);
                BOOL bRet = ::DeleteObject(m_hBitmap);
                if(bRet)
                        m_hBitmap = NULL;
                return bRet;
        }

// Attributes
        int GetBitmap(BITMAP* pBitMap)
        {
                _ASSERTE(m_hBitmap != NULL);
                return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
        }
// Operations
        DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
        {
                _ASSERTE(m_hBitmap != NULL);
                return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
        }
        DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
        {
                _ASSERTE(m_hBitmap != NULL);
                return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
        }
        BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
        {
                _ASSERTE(m_hBitmap != NULL);
                return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
        }
        BOOL GetBitmapDimension(LPSIZE lpSize) const
        {
                _ASSERTE(m_hBitmap != NULL);
                return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
        }
};

#endif

class ATL_NO_VTABLE ISnapInDataInterface 
{
public:
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        long arg,
        long param,
        BOOL bComponentData,
        IConsole  *pConsole,
        IHeaderCtrl  *pHeader,
        IToolbar  *pToolbar) = 0;
    
    STDMETHOD(GetDispInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppVIewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed) = 0;
    
    STDMETHOD(Command)(long lCommandID) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
                IUnknown* pUnk) = 0;
    
    STDMETHOD(QueryPagesFor)() = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
        MMC_NOTIFY_TYPE event,
        long arg,
        long param) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

        STDMETHOD(FillData)(CLIPFORMAT cf, 
                LPSTREAM pStream) = 0;

        static ISnapInDataInterface* GetDataClass(IDataObject* pDataObj)
        {
                STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
                FORMATETC formatetc = { m_CCF_SNAPIN_GETCOOKIE, 
                        NULL, 
                        DVASPECT_CONTENT, 
                        -1, 
                        TYMED_HGLOBAL 
                };

                stgmedium.hGlobal = GlobalAlloc(0, sizeof(ISnapInDataInterface*));
                
                if (FAILED(pDataObj->GetDataHere(&formatetc, &stgmedium)))
                        return NULL;
                
                ISnapInDataInterface* pTemp = *(ISnapInDataInterface**)stgmedium.hGlobal;
                
                GlobalFree(stgmedium.hGlobal);
                
                return pTemp;
        }
        virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj) = 0;

        static void Init()
        {
                m_CCF_NODETYPE                  = (CLIPFORMAT) RegisterClipboardFormat(CCF_NODETYPE);;
                m_CCF_SZNODETYPE                = (CLIPFORMAT) RegisterClipboardFormat(CCF_SZNODETYPE);  
                m_CCF_DISPLAY_NAME              = (CLIPFORMAT) RegisterClipboardFormat(CCF_DISPLAY_NAME); 
                m_CCF_SNAPIN_CLASSID    = (CLIPFORMAT) RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
                m_CCF_SNAPIN_GETCOOKIE  = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETCOOKIE"));
        }
public:
        static CLIPFORMAT m_CCF_NODETYPE;
        static CLIPFORMAT m_CCF_SZNODETYPE;
        static CLIPFORMAT m_CCF_DISPLAY_NAME;
        static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
        static CLIPFORMAT m_CCF_SNAPIN_GETCOOKIE;
};

template <class T>
class CSnapinObjectRootEx : public CComObjectRootEx< T >
{
public:
        ISnapInDataInterface* GetDataClass(IDataObject* pDataObject)
        {
                return ISnapInDataInterface::GetDataClass(pDataObject);
        }
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
        ISnapInDataInterface* GetDataClass(IDataObject* pDataObject) \
        { \
                STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
                FORMATETC formatetc = { ISnapInDataInterface::m_CCF_NODETYPE, \
                        NULL, \
                        DVASPECT_CONTENT, \
                        -1, \
                        TYMED_HGLOBAL \
                }; \
\
                stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
\
                if (FAILED(pDataObject->GetDataHere(&formatetc, &stgmedium))) \
                        return NULL; \
\
                GUID guid; \
                memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
                GlobalFree(stgmedium.hGlobal); 
                


#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
                if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
                { \
                        m_##dataClass.InitDataClass(pDataObject); \
                        return &m_##dataClass; \
                }

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
                        return ISnapInDataInterface::GetDataClass(pDataObject); \
        };

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
        public CComObjectRoot
{
public:
        BEGIN_COM_MAP(CSnapInDataObjectImpl)
                COM_INTERFACE_ENTRY(IDataObject)
        END_COM_MAP()
        STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
        }

        STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
        {
                ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
                if (pmedium == NULL)
                        return E_POINTER;

                HRESULT hr = DV_E_TYMED;
                // Make sure the type medium is HGLOBAL
                if (pmedium->tymed == TYMED_HGLOBAL)
                {
                        // Create the stream on the hGlobal passed in
                        LPSTREAM pStream;
                        hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &pStream);
                        if (SUCCEEDED(hr))
                        {
                                hr = m_pData->FillData(pformatetc->cfFormat, pStream);
                                pStream->Release();
                        }
                }

                return hr;
        }

        STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
        }
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
        }
        STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
        }
        STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
        }
        STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
                DWORD *pdwConnection)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
        }
        STDMETHOD(DUnadvise)(DWORD dwConnection)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
        }
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
        {
                ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
        }

        ISnapInDataInterface* m_pData;
};


template <class T, class C>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> m_spConsoleNameSpace;
        CComQIPtr<IConsole, &IID_IConsole> m_spConsole;
        
        IComponentDataImpl()
        {
                m_pNode = NULL;
        }

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
        {
                ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

                if (pUnknown == NULL)
                {
                        ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
                        return E_UNEXPECTED;
                }

                m_spConsoleNameSpace = pUnknown;
                if (m_spConsoleNameSpace == NULL)
                {
                        ATLTRACE(_T("QI for IConsoleNameSpace failed\n"));
                        return E_UNEXPECTED;
                }

                m_spConsole = pUnknown;
                if (m_spConsole == NULL)
                {
                        ATLTRACE(_T("QI for IConsole failed\n"));
                        return E_UNEXPECTED;
                }

                return S_OK;
        }

        STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
        {
                ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));
                if (ppComponent == NULL)
                {
                        ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
                        return E_UNEXPECTED;
                }

                *ppComponent = NULL;
                
                CComObject< C >* pComponent;
                HRESULT hr = CComObject< C >::CreateInstance(&pComponent);
                if (FAILED(hr))
                {
                        ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
                        return hr;
                }
                
                return pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
        }

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        long arg,
        long param)
        {
                ATLTRACE(_T("IComponentDataImpl::Notify\n"));
                if (lpDataObject == NULL)
                {
                        ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
                        return E_UNEXPECTED;
                }

                ISnapInDataInterface* pData = ISnapInDataInterface::GetDataClass(lpDataObject);
                if (pData == NULL)
                {
                        return E_UNEXPECTED;
                }
                return pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);
        }

    STDMETHOD(Destroy)(void)
        {
                ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

                m_spConsole.Release();
                m_spConsoleNameSpace.Release();
                return S_OK;
        }

    STDMETHOD(QueryDataObject)(long cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
        {
                ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
                _ASSERTE(m_pNode != NULL);

                if (ppDataObject == NULL)
                {
                        ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
                        return E_UNEXPECTED;
                }

                *ppDataObject = NULL;

                if (cookie == NULL)
                        return m_pNode->GetDataObject(ppDataObject);

                ISnapInDataInterface* pData = (ISnapInDataInterface*) cookie;
                return pData->GetDataObject(ppDataObject);
        }
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
        {
                ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));

                if (pScopeDataItem == NULL)
                {
                        ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
                        return E_UNEXPECTED;
                }

                ISnapInDataInterface* pData= (ISnapInDataInterface*) pScopeDataItem->lParam;
                if (pData == NULL)
                        pData = m_pNode;

                if (pData == NULL)
                {
                        return E_UNEXPECTED;
                }
                return pData->GetDispInfo(pScopeDataItem);
        }
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
        {
                ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
                return S_FALSE;
    }

        protected:
                ISnapInDataInterface* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
//Review all of these may not be required
        CComPtr<IConsole> m_spConsole;
        CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> m_spHeaderCtrl;
        CComPtr<IImageList> m_spImageList;
        CComPtr<IConsoleVerb> m_spConsoleVerb;

    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
        {
                ATLTRACE(_T("IComponentImpl::Initialize\n"));

                if (lpConsole == NULL)
                {
                        ATLTRACE(_T("lpConsole is NULL\n"));
                        return E_UNEXPECTED;
                }

                m_spConsole = lpConsole;

                m_spHeaderCtrl = lpConsole;
                if (m_spHeaderCtrl == NULL)
                {
                        ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
                        return E_UNEXPECTED;
                }

                HRESULT hr = m_spConsole->SetHeader(m_spHeaderCtrl);
                if (FAILED(hr))
                {
                        ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
                        return hr;
                }
                        
                hr = lpConsole->QueryResultImageList(&m_spImageList);
                if (FAILED(hr))
                {
                        ATLTRACE(_T("IConsole::QueryResultImageList failed (HRESULT = %x)\n"), hr);
                        return hr;
                }

                lpConsole->QueryConsoleVerb(&m_spConsoleVerb) ;
                if (FAILED(hr))
                {
                        ATLTRACE(_T("IConsole::QueryConsoleVerb failed (HRESULT = %x)\n"), hr);
                        return hr;
                }

                return S_OK;
        }
    
        STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        long arg,
        long param)
        {
                ATLTRACE(_T("IComponentImpl::Notify\n"));
                if (lpDataObject == NULL)
                {
                        ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
                        return E_UNEXPECTED;
                }

                ISnapInDataInterface* pData = ISnapInDataInterface::GetDataClass(lpDataObject);
                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Data Object\n"));
                        return E_UNEXPECTED;
                }
                return pData->Notify(event, arg, param, FALSE, m_spConsole, m_spHeaderCtrl, NULL);
        }
    
    STDMETHOD(Destroy)(long cookie)
        {
                ATLTRACE(_T("IComponentImpl::Destroy\n"));

                m_spConsoleVerb = NULL;
                m_spImageList = NULL;
                m_spHeaderCtrl.Release();       
                m_spConsole.Release();

                return S_OK;
        }
    
    STDMETHOD(QueryDataObject)(long cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
        {
                ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

                if (ppDataObject == NULL)
                {
                        ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
                        return E_UNEXPECTED;
                }
                
                if (cookie == NULL)
                {
                        ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
                        return E_UNEXPECTED;
                }

                *ppDataObject = NULL;

                ISnapInDataInterface* pData = (ISnapInDataInterface*) cookie;
                return pData->GetDataObject(ppDataObject);
        }
    
    STDMETHOD(GetResultViewType)(long cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
        {
                ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

                if (cookie == NULL)
                {
                        *ppViewType = NULL;
                        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
                        return S_OK;
                }
                
                ISnapInDataInterface* pData = (ISnapInDataInterface*)cookie;
                return pData->GetResultViewType(ppViewType, pViewOptions);
        }
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
        {
                ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));
                if (pResultDataItem == NULL)
                {
                        ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
                        return E_UNEXPECTED;
                }

                ISnapInDataInterface* pData = (ISnapInDataInterface*) pResultDataItem->lParam;

                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Item\n"));
                        return E_UNEXPECTED;
                }
                return pData->GetDisplayInfo(pResultDataItem);
        }
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
        {
                ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
        }
};

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        long cookieA,
        long cookieB,
        int *pnResult)
        {
                ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
        }
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
        {
                ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));
                if (pDataObject == NULL)
                {
                        ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
                        return E_UNEXPECTED;
                }

                T* pT = static_cast<T*>(this);
                ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);

                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Data Object\n"));
                        return E_UNEXPECTED;
                }
                return pData->AddMenuItems(piCallback, pInsertionAllowed);
        }
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
        {
                ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));
                if (pDataObject == NULL)
                {
                        ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
                        return E_UNEXPECTED;
                }
                
                T* pT = static_cast<T*>(this);
                ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);
                
                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Data Object\n"));
                        return E_UNEXPECTED;
                }
                return pData->Command(lCommandID);
        }
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
        STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
        {
                ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));
                if (pDataObject == NULL)
                {
                        ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
                        return E_UNEXPECTED;
                }

                T* pT = static_cast<T*>(this);
                ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);

                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Data Object\n"));
                        return E_UNEXPECTED;
                }
                return pData->CreatePropertyPages(lpProvider, handle, this);
        }
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
        {
                ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
                if (pDataObject == NULL)
                {
                        ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
                        return E_UNEXPECTED;
                }

                T* pT = static_cast<T*>(this);
                ISnapInDataInterface* pData = pT->GetDataClass(pDataObject);

                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Data Object\n"));
                        return E_UNEXPECTED;
                }
                return pData->QueryPagesFor();
        }
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
        CComPtr <IControlbar> m_spControlbar;
public:
        STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
        {
                ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
                if (pControlbar == NULL)
                {
                        ATLTRACE(_T("IExtendControlbar::SetControlbar called with pControlbar==NULL\n"));
                        return E_UNEXPECTED;
                }
                m_spControlbar = pControlbar;
                return S_OK;
        }
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        long arg,
        long param)
        {
                ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

                ISnapInDataInterface* pData = NULL;
                T* pT = static_cast<T*>(this);
                if (event == MMCN_BTN_CLICK)
                {
                        pData = pT->GetDataClass((IDataObject*) arg);
                }
                else if (event == MMCN_SELECT)
                {
                        BOOL bScope = (BOOL) LOWORD(arg);
                        if (bScope)
                        {
                                LPDATAOBJECT* ppDataobject = (LPDATAOBJECT*) param;
                                if (ppDataobject[0])
                                {
                                        pData = pT->GetDataClass(ppDataobject[0]);
                                        if (pData != NULL)
                                                pData->ControlbarNotify(m_spControlbar, this, event, arg, param);
                                }
                                        
                                if (ppDataobject[1])
                                {
                                        pData = pT->GetDataClass(ppDataobject[1]);
                                }
                        }
                        else
                                pData = pT->GetDataClass((IDataObject*) param);
                }
                if (pData == NULL)
                {
                        ATLTRACE(_T("Invalid Data Object\n"));
                        return E_UNEXPECTED;
                }
                HRESULT hr = pData->ControlbarNotify(m_spControlbar, this, event, arg, param);
                ATLTRACE(_T("Exiting : IExtendControlbarImpl::ControlbarNotify\n"));
                return hr;
        }
};

#define SNAPINMENUID(id) \
public: \
        static const UINT GetMenuID() \
        { \
                static const UINT IDMENU = id; \
                return id; \
        }

#define EXT_SNAPINMENUID(id) \
public: \
        static const UINT GetMenuID() \
        { \
                static const UINT IDMENU = id; \
                return id; \
        }


#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
        typedef  CSnapInDataInterface< theClass, bIsExtension > baseClass; \
        HRESULT ProcessCommand(UINT nID, IDataObject* pDataObject) \
        { \
                BOOL _bIsExtension = bIsExtension;

#define SNAPINCOMMAND_ENTRY(id, func) \
                if (id == nID) \
                        return func();

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
                if (id1 >= nID && nID <= id2) \
                        return func(nID);

#define END_SNAPINCOMMAND_MAP() \
                        return baseClass::ProcessCommand(nID, pDataObject); \
        }

struct CSnapInToolBarData
{
        WORD wVersion;
        WORD wWidth;
        WORD wHeight;
        WORD wItemCount;
        //WORD aItems[wItemCount]

        WORD* items()
                { return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)

struct CSnapInToolbarInfo
{
public:
        TCHAR** m_pStrToolTip;
        TCHAR** m_pStrButtonText;
        UINT* m_pnButtonID;
        UINT m_idToolbar;
        UINT m_nButtonCount;
        IToolbar* m_pToolbar;

        ~CSnapInToolbarInfo()
        {
                if (m_pStrToolTip)
                {
                        for (UINT i = 0; i < m_nButtonCount; i++)
                        {
                                delete m_pStrToolTip[i];
                                m_pStrToolTip[i] = NULL;
                        }
                        delete [] m_pStrToolTip;
                        m_pStrToolTip = NULL;
                }

                if (m_pStrButtonText)
                {
                        for (UINT i = 0; i < m_nButtonCount; i++)
                        {
                                delete m_pStrButtonText[i];
                                m_pStrButtonText[i] = NULL;
                        }

                        delete [] m_pStrButtonText;
                        m_pStrButtonText = NULL;
                }
                if (m_pnButtonID)
                {
                        delete m_pnButtonID;
                        m_pnButtonID = NULL;
                }

                m_nButtonCount = 0;
                if (m_pToolbar)
                        m_pToolbar->Release();
                m_pToolbar = NULL;
        }
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
        static CSnapInToolbarInfo* GetToolbarInfo() \
        { \
                static CSnapInToolbarInfo m_toolbarInfo[] = \
                {

#define SNAPINTOOLBARID_ENTRY(id) \
                        { NULL, NULL, NULL, id, 0, NULL},

#define END_SNAPINTOOLBARID_MAP() \
                        { NULL, NULL, NULL, 0, 0, NULL} \
                }; \
                return m_toolbarInfo; \
        }       

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInDataInterface : public ISnapInDataInterface
{
public:
        OLECHAR* m_pszDisplayName;

        SCOPEDATAITEM m_scopeDataItem;
        RESULTDATAITEM m_resultDataItem;
        CSnapInDataInterface()
        {
                m_pszDisplayName = NULL;

                memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));

                m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_PARENT;
                m_scopeDataItem.displayname = MMC_CALLBACK;
                m_scopeDataItem.nImage = 0;
                m_scopeDataItem.nOpenImage = 1;

                memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));

                m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                m_resultDataItem.str = MMC_CALLBACK;
                m_resultDataItem.nImage = 2;

        }

        virtual ~CSnapInDataInterface()
        {
                delete [] m_pszDisplayName;
                m_pszDisplayName = NULL;
        }    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
                BOOL bComponentData,
                IConsole* pConsole,
                IHeaderCtrl* pHeader,
                IToolbar* pToolbar)
        {
                ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::Notify"));
        }
    
    STDMETHOD(GetDispInfo)(SCOPEDATAITEM *pScopeDataItem)
        {
                ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::GetDispInfo"));
        }
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppVIewType,
        long *pViewOptions)
        {
                ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::GetResultViewType"));
        }
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
        {
                ATLTRACE(_T("ISnapInDataInterfaceImpl::GetDisplayInfo"));
                T* pT = static_cast<T*> (this);

                if (pResultDataItem->bScopeItem)
                {
                        if (pResultDataItem->mask & RDI_STR)
                        {
                                pResultDataItem->str = pT->GetResultPaneInfo(pResultDataItem->nCol);
                        }
                        if (pResultDataItem->mask & RDI_IMAGE)
                        {
                                pResultDataItem->nImage = m_scopeDataItem.nImage;
                        }

                        return S_OK;
                }
                if (pResultDataItem->mask & RDI_STR)
                {
                        pResultDataItem->str = pT->GetResultPaneInfo(pResultDataItem->nCol);
                }
                if (pResultDataItem->mask & RDI_IMAGE)
                {
                        pResultDataItem->nImage = m_resultDataItem.nImage;
                }
                return S_OK;
        }
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
        {
                ATLTRACE(_T("ISnapInDataInterfaceImpl::AddMenuItems"));
                T* pT = static_cast<T*> (this);
                UINT menuID = pT->GetMenuID();
                if (menuID == 0)
                        return S_OK;
//              return SnapInMenuHelper<T> (pT, menuID, piCallback, pInsertionAllowed);

                HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
                long insertionID;
                if (hMenu)
                {
                        for (int i = 0; 1; i++)
                        {
                                HMENU hSubMenu = GetSubMenu(hMenu, i);
                                if (hSubMenu == NULL)
                                        break;
                                
                                MENUITEMINFO menuItemInfo;
                                memset(&menuItemInfo, 0, sizeof(menuItemInfo));
                                menuItemInfo.cbSize = sizeof(menuItemInfo);

                                switch (i)
                                {
                                case 0:
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
                                                continue;
                                        insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                                        break;

                                case 1:
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
                                                continue;
                                        if (bIsExtension)
                                                insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
                                        else
                                                insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
                                        break;

                                case 2:;
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
                                                continue;
                                        if (bIsExtension)
                                                insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
                                        else
                                                insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                                        break;
                                case 3:;
                                        if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
                                                continue;
                                        insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
                                        break;
                                default:
                                        {
                                                insertionID = 0;
                                                continue;
// Review
// Determine what to do here.
                                                menuItemInfo.fMask = MIIM_TYPE ;
                                                menuItemInfo.fType = MFT_STRING;
                                                TCHAR buf[128];
                                                menuItemInfo.dwTypeData = buf;
                                                menuItemInfo.cch = 128;
                                                if (!GetMenuItemInfo(hMenu, i, TRUE, &menuItemInfo))
                                                        continue;
//                                              insertionID = _ttol(buf);
                                        }
                                        break;
                                }

                                menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
                                menuItemInfo.fType = MFT_STRING;
                                TCHAR buf[128];
                                menuItemInfo.dwTypeData = buf;

                                for (int j = 0; 1; j++)
                                {
                                        menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
                                        menuItemInfo.fType = MFT_STRING;
                                        menuItemInfo.cch = 128;
                                        TCHAR strStatusBar[257];

                                        if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
                                                break;

                                        pT->UpdateMenuState(menuItemInfo.wID, buf, &menuItemInfo.fState);
                                        LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, strStatusBar, 257);

                                        CONTEXTMENUITEM contextMenuItem;
                                        memset(&contextMenuItem, 0, sizeof(contextMenuItem));
                                        contextMenuItem.strName = buf;
                                        contextMenuItem.strStatusBarText = strStatusBar;
                                        contextMenuItem.lCommandID = menuItemInfo.wID;
                                        contextMenuItem.lInsertionPointID = insertionID;
                                        contextMenuItem.fFlags = menuItemInfo.fState;
                                        
                                        HRESULT hr = piCallback->AddItem(&contextMenuItem);
                                        _ASSERTE(SUCCEEDED(hr));
                                }
                        }
                        DestroyMenu(hMenu);
                }
                if (!bIsExtension)
                        *pInsertionAllowed = CCM_INSERTIONALLOWED_TOP | CCM_INSERTIONALLOWED_NEW |
                                CCM_INSERTIONALLOWED_TASK | CCM_INSERTIONALLOWED_VIEW;

                return S_OK;
        }
    
    STDMETHOD(Command)(long lCommandID)
        {
                ATLTRACE(_T("ISnapInDataInterfaceImpl::Command\n"));
                T* pT = static_cast<T*>(this);
                return pT->ProcessCommand(lCommandID, NULL);
        }
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, IUnknown* pUnk)
        {
                ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::CreatePropertyPages"));
        }
    
    STDMETHOD(QueryPagesFor)(void)
        {
                ATLTRACENOTIMPL(_T("ISnapInDataInterfaceImpl::QueryPagesFor"));
        }

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, IExtendControlbar* pExtendControlBar)
        {
                ATLTRACE(_T("ISnapInDataInterfaceImpl::SetControlbar\n"));
                T* pT = static_cast<T*>(this);

                CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
                if (pInfo == NULL)
                        return S_OK;

                for( ; pInfo->m_idToolbar; pInfo++)
                {
                        if (pInfo->m_pToolbar)
                                continue;

                        HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
                        if (hBitmap == NULL)
                                return S_OK;

                        HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
                        if (hRsrc == NULL)
                                return S_OK;

                        HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
                        if (hGlobal == NULL)
                                return S_OK;

                        CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
                        if (pData == NULL)
                                return S_OK;
                        _ASSERTE(pData->wVersion == 1);
                        _ASSERTE(pData->wWidth == 16);
                        _ASSERTE(pData->wHeight == 16);

                        pInfo->m_nButtonCount = pData->wItemCount;
                        pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];
                        MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
                        
                        pInfo->m_pStrToolTip = new TCHAR* [pData->wItemCount];
                        if (pInfo->m_pStrToolTip == NULL)
                                continue;

                        for (int i = 0, j = 0; i < pData->wItemCount; i++)
                        {
                                pInfo->m_pStrToolTip[i] = NULL;
                                memset(&pButtons[i], 0, sizeof(MMCBUTTON));
                                pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
                                if (pButtons[i].idCommand)
                                {
                                        pButtons[i].nBitmap = j++;
                                        // get the statusbar string and allow modification of the button state
                                        TCHAR strStatusBar[512];
                                        LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, strStatusBar, 512);
                                        
                                        pInfo->m_pStrToolTip[i] = new TCHAR[lstrlen(strStatusBar) + 1];
                                        if (pInfo->m_pStrToolTip[i] == NULL)
                                                continue;
                                        lstrcpy(pInfo->m_pStrToolTip[i], strStatusBar);
                                        pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
                                        pButtons[i].lpButtonText = _T("");
                                        pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
                                }
                                else
                                {
                                        pButtons[i].lpTooltipText = _T("");
                                        pButtons[i].lpButtonText = _T("");
                                        pButtons[i].fsType = TBSTYLE_SEP;
                                }
                        }

                HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pInfo->m_pToolbar));
                        if (FAILED(hr))
                                continue;

                        hr = pInfo->m_pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
                        if (FAILED(hr))
                        {
                                pInfo->m_pToolbar->Release();
                                pInfo->m_pToolbar = NULL;
                                continue;
                        }

                        hr = pInfo->m_pToolbar->AddButtons(pData->wItemCount, pButtons);
                        if (FAILED(hr))
                        {
                                pInfo->m_pToolbar->Release();
                                pInfo->m_pToolbar = NULL;
                        }

                        delete [] pButtons;
                }
                return S_OK;
        }
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
                MMC_NOTIFY_TYPE event,
        long arg, long param)
        {
                ATLTRACE(_T("ISnapInDataInterfaceImpl::ControlbarNotify\n"));
                T* pT = static_cast<T*>(this);

                SetControlbar(pControlbar, pExtendControlbar);

                if(event == MMCN_SELECT)
                {
                        BOOL bScope = (BOOL) LOWORD(arg);
                        BOOL bSelect = (BOOL) HIWORD (arg);

                        if (!bScope)
                        {
                                CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
                                if (pInfo == NULL)
                                        return S_OK;

                                if (!bSelect)
                                        return S_OK;

                                for(; pInfo->m_idToolbar; pInfo++)
                                {
                                        for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
                                        {
                                                if (pInfo->m_pnButtonID[i])
                                                {
                                                        for (int j = ENABLED; j <= BUTTONPRESSED; j++)
                                                        {
                                                                pInfo->m_pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                                        (MMC_BUTTON_STATE)j,
                                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], (MMC_BUTTON_STATE)j));
                                                        }                                                                       
                                                }
                                        }
                                }
                        }
                        else
                        {
                                LPDATAOBJECT* pData = (LPDATAOBJECT*) param;
                                if (pData[0] == NULL)
                                        return S_OK;
                                if (pData[0] == pData[1])
                                        return S_OK;
                                ISnapInDataInterface* pCookie = ISnapInDataInterface::GetDataClass(pData[0]);
                                if (pCookie == (ISnapInDataInterface*)this)
                                {
                                        CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
                                        if (pInfo == NULL)
                                                return S_OK;

                                        for(; pInfo->m_idToolbar; pInfo++)
                                        {
                                                pControlbar->Detach(pInfo->m_pToolbar);
                                        }
                                        return S_OK;
                                }

                                CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
                                if (pInfo == NULL)
                                        return S_OK;

                                for(; pInfo->m_idToolbar; pInfo++)
                                {
                                        pControlbar->Attach(TOOLBAR, pInfo->m_pToolbar);
                                        for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
                                        {
                                                if (pInfo->m_pnButtonID[i])
                                                {
                                                        for (int j = ENABLED; j <= BUTTONPRESSED; j++)
                                                        {
                                                                pInfo->m_pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
                                                                        (MMC_BUTTON_STATE)j,
                                                                        pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], (MMC_BUTTON_STATE)j));
                                                        }                                                                       
                                                }
                                        }
                                }
                                return S_OK;
                        }
                }
                return pT->ProcessCommand((UINT) param, NULL);
        }

        STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
        {
                if (pScopeDataItem == NULL)
                        return E_FAIL;

                *pScopeDataItem = &m_scopeDataItem;
                return S_OK;
        }
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
        {
                if (pResultDataItem == NULL)
                        return E_FAIL;

                *pResultDataItem = &m_resultDataItem;
                return S_OK;
        }

        STDMETHOD(GetDataObject)(IDataObject** pDataObj)
        {
                CComObject<CSnapInDataObjectImpl>* pData;
                HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
                if (FAILED(hr))
                        return hr;

                pData->m_pData = this;

                hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));

                return hr;
        }

        void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
        {
                return;
        }

        void SetToolbarButtonInfo(UINT id, BYTE *fsState, BYTE *fsType)
        {
                *fsState = TBSTATE_ENABLED;
                *fsType = TBSTYLE_BUTTON;
        }

        BOOL UpdateToolbarButton(UINT id, BYTE fsState)
        {
                if (fsState == ENABLED)
                        return TRUE;
                return FALSE;
        }

        HRESULT ProcessCommand(UINT nID, IDataObject* pDataObject)
        {
                ATLTRACE(_T("No handler for item with ID %d\n"), nID);
                return S_OK;
        }

        STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
        {
                HRESULT hr = DV_E_CLIPFORMAT;
                ULONG uWritten;

                T* pT = static_cast<T*> (this);

                if (cf == m_CCF_NODETYPE)
                {
                        hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
                        return hr;
                }

                if (cf == m_CCF_SZNODETYPE)
                {
                        hr = pStream->Write(pT->GetSZNodeType(), (lstrlen((LPCTSTR)pT->GetSZNodeType()) + 1 )* sizeof(TCHAR), &uWritten);
                        return hr;
                }

                if (cf == m_CCF_DISPLAY_NAME)
                {
                        hr = pStream->Write(pT->GetDisplayName(), (lstrlen((LPCTSTR)pT->GetDisplayName()) + 1) * sizeof(TCHAR), &uWritten);
                        return hr;
                }

                if (cf == m_CCF_SNAPIN_CLASSID)
                {
                        hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(CLSID), &uWritten);
                        return hr;
                }
                if (cf == m_CCF_SNAPIN_GETCOOKIE)
                {
                        hr = pStream->Write(&pT, sizeof(T*), &uWritten);
                        return hr;
                }


                return hr;
        }
        OLECHAR* GetResultPaneInfo(int nCol)
        {
                if (nCol == 0 && m_pszDisplayName)
                        return m_pszDisplayName;

                return L"Override GetResultPaneInfo in your derived class";
        }

        static CSnapInToolbarInfo* GetToolbarInfo()
        {
                return NULL;
        }

        static const UINT GetMenuID() 
        {
                return 0;
        }
};


_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT ISnapInDataInterface::m_CCF_SNAPIN_GETCOOKIE = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by routeext.rc
//
#define IDS_PROJNAME                    100
#define IDB_ROUTE_16                    101
#define IDS_ERROR_DLGTITLE              101
#define IDB_ROUTE_32                    102
#define IDS_EMAIL_PROFILE               102
#define IDD_ROUTE                       103
#define IDS_INBOX_PROFILE               103
#define IDR_ROUTE                       104
#define IDS_DEST_FOLDER                 104
#define IDS_CANT_SAVE                   105
#define IDS_DIR_TOO_LONG                106
#define IDS_INBOUND_DIR                 107
#define IDS_TITLE                       108
#define IDS_PRINT_TO                    109
#define IDS_ONE_ENABLE                  110
#define IDC_PRINT                       201
#define IDC_PRINT_TO                    202
#define IDC_SAVE                        203
#define IDC_INBOX                       205
#define IDC_INBOX_PROFILE               206
#define IDC_INBOX_LABEL                 207
#define IDC_EMAIL                       208
#define IDC_DEST_FOLDER                 210
#define IDC_BROWSE_DIR                  211
#define IDC_ROUTE_TITLE                 214


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         212
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\route.h ===
#ifndef __ROUTE_H_
#define __ROUTE_H_
#include "resource.h"

#include "atlsnap.h"
#include <winfax.h>
#include <winfaxp.h>
#include <shlobj.h>


#define MAX_STRING_LEN  128
#define MAX_TITLE_LEN   60
#define MAX_MESSAGE_LEN 256
#define MAX_ARCHIVE_DIR (MAX_PATH - 16)

#define RM_EMAIL    0
#define RM_INBOX    1
#define RM_FOLDER   2
#define RM_PRINT    3

#define RM_COUNT    4           // number of routing methods

#define FAX_DRIVER_NAME     L"Windows NT Fax Driver"

#define MAPIENABLED (m_MapiProfiles && *m_MapiProfiles)

class CRoutePage : public CPropertyPageImpl<CRoutePage>
{
    HANDLE m_FaxHandle;
    HANDLE m_PortHandle;
    DWORD m_DeviceId;
    BOOL m_bChanged;
    WCHAR m_Title[MAX_TITLE_LEN];
    WCHAR m_ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    PFAX_ROUTING_METHOD m_RoutingMethods[RM_COUNT];
    PFAX_ROUTING_METHOD m_BaseMethod;

    LPBYTE m_RoutingInfo[RM_COUNT];
    DWORD m_RoutingInfoSize[RM_COUNT];

    LPBYTE m_MapiProfiles;

    VOID SystemErrorMsg( DWORD ErrorCode );
    VOID EnumMapiProfiles( HWND hwnd );
    VOID SetChangedFlag( BOOL Flag );
    INT DisplayMessageDialog( INT TitleId, INT MsgId, UINT Type = MB_OK | MB_ICONERROR );
    BOOL BrowseForDirectory( );\

public :
    CRoutePage(TCHAR* pTitle = NULL, HANDLE FaxHandle = NULL, DWORD DeviceId = NULL, LPWSTR ComputerName = NULL);

    enum { IDD = IDD_ROUTE };

        BEGIN_MSG_MAP(CRoutePage)
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            MESSAGE_HANDLER(WM_HELP, OnWmHelp)
            MESSAGE_HANDLER(WM_CONTEXTMENU, OnWmContextHelp)
            COMMAND_ID_HANDLER(IDC_PRINT, OnPrint)
            COMMAND_ID_HANDLER(IDC_PRINT_TO, OnPrintTo)
            COMMAND_ID_HANDLER(IDC_SAVE, OnSaveTo)
            COMMAND_ID_HANDLER(IDC_INBOX, OnInbox)
            COMMAND_ID_HANDLER(IDC_EMAIL, OnEmail)
            COMMAND_ID_HANDLER(IDC_INBOX_PROFILE, OnProfile)
            COMMAND_ID_HANDLER(IDC_DEST_FOLDER, OnDestDir)
            COMMAND_ID_HANDLER(IDC_BROWSE_DIR, OnBrowseDir)
            CHAIN_MSG_MAP(CPropertyPageImpl<CRoutePage>)
        END_MSG_MAP()
    
    LRESULT OnPrint(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnPrintTo(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnSaveTo(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnInbox(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnEmail(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnProfile(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnDestDir(INT code, INT id, HWND hwnd, BOOL& bHandled);
    LRESULT OnBrowseDir(INT code, INT id, HWND hwnd, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWmHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWmContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BOOL OnApply();
};

class CRouteData : public CSnapInDataInterface< CRouteData, TRUE >
{
        static const GUID* m_NODETYPE;
        static const TCHAR* m_SZNODETYPE;
        static const TCHAR* m_SZDISPLAY_NAME;
        static const CLSID* m_SNAPIN_CLASSID;
    
    
public:
        static CComPtr<IControlbar> m_spControlBar;

public:

    CRouteData()
    {       
    }

    ~CRouteData()
    {
    }

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown* pUnk
        );
    

    STDMETHOD(QueryPagesFor)(void)
    {
            return S_OK;
    }

    void* GetNodeType()
    {
            return (void*)m_NODETYPE;
    }

    void* GetSZNodeType()
    {
            return (void*)m_SZNODETYPE;
    }

    void* GetDisplayName()
    {
            return (void*)m_SZDISPLAY_NAME;
    }

    void* GetSnapInCLSID()
    {
            return (void*)m_SNAPIN_CLASSID;
    }
    IDataObject* m_pDataObject;
    BOOL InitDataClass(IDataObject* pDataObject)
    {
            m_pDataObject = pDataObject;
            // The default code stores off the pointer to the Dataobject the class is wrapping
            // at the time. 
            // Alternatively you could convert the dataobject to the internal format
            // it represents and store that information
            return TRUE;
    }
};

class CRoute : public CSnapinObjectRootEx<CComSingleThreadModel>,
        public IExtendPropertySheetImpl<CRoute>,
    public CComCoClass<CRoute, &CLSID_Route>
{
public:
    EXTENSION_SNAPIN_DATACLASS(CRouteData)

    BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CRoute)
        EXTENSION_SNAPIN_NODEINFO_ENTRY(CRouteData)
    END_EXTENSION_SNAPIN_NODEINFO_MAP()

    BEGIN_COM_MAP(CRoute)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_ROUTE)

    DECLARE_NOT_AGGREGATABLE(CRoute)

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\route.cpp ===
#include "stdafx.h"
#include "routeext.h"
#include "Route.h"
#include "faxhelp.h"
#include <atl21\atlwin.cpp>

#define MyHideWindow(_hwnd)   ::SetWindowLong((_hwnd),GWL_STYLE,::GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)

/////////////////////////////////////////////////////////////////////////////
// CRouteComponentData
static const GUID CRouteGUID_NODETYPE =
{ 0xde58ae00, 0x4c0f, 0x11d1, { 0x90, 0x83, 0x0, 0xa0, 0xc9, 0xa, 0xb5, 0x4}};
const GUID*  CRouteData::m_NODETYPE = &CRouteGUID_NODETYPE;
const TCHAR* CRouteData::m_SZNODETYPE = _T("de58ae00-4c0f-11d1-9083-00a0c90ab504");
const TCHAR* CRouteData::m_SZDISPLAY_NAME = _T("CRoute");
const CLSID* CRouteData::m_SNAPIN_CLASSID = &CLSID_Route;

static const LPCWSTR RoutingGuids[RM_COUNT] = {
    L"{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}",       // RM_EMAIL
    L"{9d3d0c32-9af2-11d0-abf7-00c04fd91a4e}",       // RM_INBOX
    L"{92041a90-9af2-11d0-abf7-00c04fd91a4e}",       // RM_FOLDER
    L"{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}"        // RM_PRINT
};

static const ULONG_PTR RoutingHelpIds[] = {
    IDC_ROUTE_TITLE,                IDH_Fax_Modem_Routing_InboundRouting_GRP,
    IDC_PRINT,                      IDH_Fax_Modem_Routing_PrintTo,      
    IDC_PRINT_TO,                   IDH_Fax_Modem_Routing_PrintTo,      
    IDC_SAVE,                       IDH_Fax_Modem_Routing_SaveInFolder, 
    IDC_INBOX,                      IDH_Fax_Modem_Routing_SendToLocalInbox,
    IDC_INBOX_PROFILE,              IDH_Fax_Modem_Routing_ProfileName,           
    IDC_INBOX_LABEL,                IDH_Fax_Modem_Routing_ProfileName,           
    IDC_DEST_FOLDER,                IDH_Fax_Modem_Routing_SaveInFolder,
    IDC_BROWSE_DIR,                 IDH_Fax_Modem_Routing_SaveInFolder,
    IDC_EMAIL,                      IDH_Fax_Modem_Routing_SendToLocalInbox,
    0,                              0
};


CRoutePage::CRoutePage(
    TCHAR* pTitle, 
    HANDLE FaxHandle, 
    DWORD DeviceId, 
    LPWSTR ComputerName
    ) : CPropertyPageImpl<CRoutePage> (pTitle)
{
    DWORD rc = ERROR_SUCCESS;
    DWORD cMethods = 0;

    m_FaxHandle = FaxHandle;
    m_DeviceId = DeviceId;
    m_BaseMethod = NULL;
    m_PortHandle = NULL;
    wcscpy( m_ComputerName, ComputerName );
   
    m_MapiProfiles = NULL;
    if (!FaxGetMapiProfiles(m_FaxHandle, &m_MapiProfiles)) {
        m_MapiProfiles = NULL;
    }
 
    wcsncpy( m_Title, pTitle, MAX_TITLE_LEN);

    m_bChanged = FALSE;

    if (!FaxOpenPort( m_FaxHandle, m_DeviceId, PORT_OPEN_QUERY, &m_PortHandle )) {
        rc = GetLastError();
        goto exit;
    }

    if (!FaxEnumRoutingMethods( m_PortHandle, &m_BaseMethod, &cMethods )) {
        rc = GetLastError();
    } else {
        DWORD CurrentRM;
        DWORD i;       
        
        for (CurrentRM = RM_EMAIL; CurrentRM < RM_COUNT; CurrentRM++) {
            m_RoutingMethods[CurrentRM] = NULL;
            for (i = 0; i < cMethods; i++) {
                if (_wcsicmp( m_BaseMethod[i].Guid, RoutingGuids[CurrentRM] ) == 0) {
                    m_RoutingMethods[CurrentRM] = &m_BaseMethod[i];

                    if (!FaxGetRoutingInfo( m_PortHandle, m_BaseMethod[i].Guid, &m_RoutingInfo[CurrentRM], &m_RoutingInfoSize[CurrentRM] )) {
                        m_RoutingMethods[CurrentRM]->Enabled = FALSE;
                    }
                    break;
                }
            }
        }
    }

exit:
    if (rc != ERROR_SUCCESS) {
        SystemErrorMsg( rc );
    }

    if (m_PortHandle) {
        FaxClose(m_PortHandle);
        m_PortHandle = NULL;
    }

}

HRESULT
CRouteData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    IUnknown* pUnk
    )
{
    UINT cf = RegisterClipboardFormat(L"CF_FAX_DEVICE");
    HRESULT hr = S_OK;
    STGMEDIUM stgmedium =  {  TYMED_HGLOBAL,  NULL};
    FORMATETC formatetc =  {  (CLIPFORMAT)cf, NULL,  DVASPECT_CONTENT,  -1,  TYMED_HGLOBAL};
    LPSTREAM lpStream;
    DWORD cbytes;
    HANDLE FaxHandle;
    DWORD DeviceId;
    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR Title[MAX_TITLE_LEN];

    do 
    {
        // Allocate memory for the stream

        stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, 128);

        if (!stgmedium.hGlobal) {
            ATLTRACE(_T("Out of memory\n"));
            hr = E_OUTOFMEMORY;
            break;
        }


        hr = m_pDataObject->GetDataHere(&formatetc, &stgmedium);

        if (FAILED(hr)) {
            break;
        }

    } while (0); 

    if (FAILED(hr)) {
        return(hr);
    }

    // this also frees the memory pointed to by stgmedium.hGlobal

    CreateStreamOnHGlobal( stgmedium.hGlobal, TRUE, &lpStream );
    
    lpStream->Read( (LPVOID) &FaxHandle, sizeof(DWORD), &cbytes ); 
    lpStream->Read( (LPVOID) &DeviceId, sizeof(DWORD), &cbytes ); 
    lpStream->Read( (LPVOID) ComputerName, sizeof(ComputerName), &cbytes );
    lpStream->Release();


    LoadString(_Module.m_hInst, IDS_TITLE, Title, MAX_TITLE_LEN);

    CRoutePage* pPage = new CRoutePage(Title, FaxHandle, DeviceId, ComputerName);
    if (!pPage) {
        return(E_OUTOFMEMORY);
    }

    lpProvider->AddPage(pPage->Create());
    return(S_OK);
}


LRESULT
CRoutePage::OnInitDialog(
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
    )
{

    for (int i = 0; i < RM_COUNT; i++) {
        BOOL Enabled;
        LPWSTR CurSel;
        HWND hControl;
        PPRINTER_INFO_2 pPrinterInfo2, pSaved;
        DWORD           cPrinters, dwFlags;

        Enabled = m_RoutingMethods[i]->Enabled;
        CurSel = (LPWSTR) (m_RoutingInfo[i] + sizeof(DWORD));
        SetChangedFlag( FALSE );

        switch (i) {
        case RM_EMAIL:
            MyHideWindow( GetDlgItem( IDC_EMAIL ));
            
            break;

            if (MAPIENABLED) {
                CheckDlgButton( IDC_EMAIL, Enabled ? BST_CHECKED : BST_UNCHECKED );
            } else {
                MyHideWindow( GetDlgItem( IDC_EMAIL ) );
            }
            break;
        case RM_INBOX:
            if (MAPIENABLED) {
                ::SendMessage( hControl = GetDlgItem( IDC_INBOX_PROFILE ), CB_RESETCONTENT, 0, 0 );
                CheckDlgButton( IDC_INBOX, Enabled ? BST_CHECKED : BST_UNCHECKED );
                ::EnableWindow( GetDlgItem( IDC_INBOX_LABEL ), Enabled );
                ::EnableWindow( hControl, Enabled );
                EnumMapiProfiles( hControl );
                ::SendMessage( hControl, CB_SETCURSEL, 0, 0 );
                if (*CurSel) {
                    ::SendMessage( hControl, CB_SELECTSTRING, 0, (LPARAM) CurSel );
                }
            } else {
                ::EnableWindow( GetDlgItem( IDC_INBOX ), FALSE );
                ::EnableWindow( GetDlgItem( IDC_INBOX_LABEL ), FALSE );
                ::EnableWindow( GetDlgItem( IDC_INBOX_PROFILE ), FALSE );
            }
            break;
        case RM_FOLDER:

            CheckDlgButton( IDC_SAVE, Enabled ? BST_CHECKED : BST_UNCHECKED );

            ::EnableWindow( GetDlgItem( IDC_DEST_FOLDER ), Enabled );

            ::EnableWindow( GetDlgItem( IDC_BROWSE_DIR ), Enabled );

            SendDlgItemMessage( IDC_DEST_FOLDER, EM_SETLIMITTEXT, MAX_PATH - 16, 0 );

            if (*CurSel) {
                SetDlgItemText( IDC_DEST_FOLDER, CurSel );
            }
            break;
        case RM_PRINT:
            BOOL bPrinters = FALSE;

            dwFlags = m_ComputerName[0] ?
                      PRINTER_ENUM_NAME :
                      (PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS);

            hControl = GetDlgItem( IDC_PRINT_TO );

            pPrinterInfo2 = (PPRINTER_INFO_2) MyEnumPrinters(m_ComputerName, 2, &cPrinters, dwFlags);

            if (pSaved = pPrinterInfo2) {

                //
                // Filtering out fax printers from the list
                //

                for ( ; cPrinters--; pPrinterInfo2++) {

                    if (_wcsicmp(pPrinterInfo2->pDriverName, FAX_DRIVER_NAME) != 0) {
                        ::SendMessage( hControl, CB_ADDSTRING, 0, (LPARAM) pPrinterInfo2->pPrinterName);
                        bPrinters = TRUE;
                    }
                }

                MemFree(pSaved);
            }

            CheckDlgButton( IDC_PRINT, (Enabled && bPrinters) ? BST_CHECKED : BST_UNCHECKED );                

            ::EnableWindow( GetDlgItem(IDC_PRINT), bPrinters);

            if (*CurSel) {
                ::SendMessage( hControl, CB_SELECTSTRING, 0, (LPARAM) CurSel );
            } else {
                ::SendMessage( hControl, CB_SETCURSEL, 0, 0 );
            }

            ::EnableWindow( GetDlgItem( IDC_PRINT_TO ), (Enabled && bPrinters) );
            break;
        }
    }
    ::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
    return 1;
}

LRESULT
CRoutePage::OnEmail(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    SetChangedFlag( TRUE );
    return 1;
}

LRESULT
CRoutePage::OnPrint(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    ::EnableWindow( GetDlgItem( IDC_PRINT_TO ), IsDlgButtonChecked( id ) == BST_CHECKED ? TRUE : FALSE );
    SetChangedFlag( TRUE );
    return 1;
}

LRESULT
CRoutePage::OnPrintTo(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    if (code == CBN_SELCHANGE) {
        SetChangedFlag( TRUE );
    }
    return 1;
}

LRESULT
CRoutePage::OnSaveTo(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    ::EnableWindow( GetDlgItem( IDC_DEST_FOLDER ), IsDlgButtonChecked( id ) == BST_CHECKED ? TRUE : FALSE );
    ::EnableWindow( GetDlgItem( IDC_BROWSE_DIR ), IsDlgButtonChecked( id ) == BST_CHECKED ? TRUE : FALSE );
    SetChangedFlag( TRUE );
    return 1;
}

LRESULT
CRoutePage::OnInbox(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    ::EnableWindow( GetDlgItem( IDC_INBOX_PROFILE ), IsDlgButtonChecked( id ) == BST_CHECKED ? TRUE : FALSE );
    ::EnableWindow( GetDlgItem( IDC_INBOX_LABEL ), IsDlgButtonChecked( id ) == BST_CHECKED ? TRUE : FALSE );
    SetChangedFlag( TRUE );
    return 1;
}

LRESULT
CRoutePage::OnProfile(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    if (code == CBN_SELCHANGE) {
        SetChangedFlag( TRUE );
    }
    return 1;
}

LRESULT
CRoutePage::OnDestDir(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    if (code == EN_UPDATE) {
        SetChangedFlag( TRUE );
    }
    return 1;
}

LRESULT
CRoutePage::OnBrowseDir(
    INT code, 
    INT id, 
    HWND hwnd, 
    BOOL& bHandled
    )
{
    BrowseForDirectory();
    return 1;
}


#define INFO_SIZE   (MAX_PATH * sizeof(WCHAR) + sizeof(DWORD))

BOOL
CRoutePage::OnApply()
{

    BYTE SetInfo[RM_COUNT][INFO_SIZE];
    LPWSTR lpCurSel; 
    LPDWORD Enabled; 
    DWORD ec;
    DWORD OneEnabled = 0;
    DWORD i;

    if (!m_bChanged) { 
        return TRUE;
    }

    for (i = 0; i < RM_COUNT; i++) {
        INT SelIndex;
        HWND hControl;
        lpCurSel = (LPWSTR)(SetInfo[i] + sizeof(DWORD));
        Enabled = (LPDWORD) SetInfo[i];
        *Enabled = 0;
        ZeroMemory( lpCurSel, MAX_PATH * sizeof(WCHAR) );

        switch (i) {
        case RM_PRINT:

            *Enabled = (IsDlgButtonChecked( IDC_PRINT ) == BST_CHECKED);

            if (*Enabled) {

                SelIndex = (INT)::SendMessage( hControl = GetDlgItem( IDC_PRINT_TO ), CB_GETCURSEL, 0, 0 );
                if (SelIndex != CB_ERR) {
                    ::SendMessage( hControl, CB_GETLBTEXT, SelIndex, (LPARAM) lpCurSel );
                } else {
                    lpCurSel[0] = 0;
                }
                if (lpCurSel[0] == 0) {
                    DisplayMessageDialog( 0, IDS_PRINT_TO );
                    return FALSE;
                }
            }

            break;

        case RM_EMAIL:

            if (!MAPIENABLED) {
                break;
            }

            *Enabled = (IsDlgButtonChecked( IDC_EMAIL ) == BST_CHECKED);

            break;

        case RM_INBOX:

            if (!MAPIENABLED) {
                break;
            }

            *Enabled = (IsDlgButtonChecked( IDC_INBOX ) == BST_CHECKED);

            if (*Enabled) {

                SelIndex = (INT)::SendMessage( hControl = GetDlgItem( IDC_INBOX_PROFILE ), CB_GETCURSEL, 0, 0 );
                if (SelIndex != CB_ERR) {
                    ::SendMessage( hControl, CB_GETLBTEXT, SelIndex, (LPARAM) lpCurSel );
                } else {
                    lpCurSel[0] = 0;
                }
                if (lpCurSel[0] == 0) {
                    DisplayMessageDialog( 0, IDS_INBOX_PROFILE );
                    return FALSE;
                }
            }

            break;

        case RM_FOLDER:

            *Enabled = (IsDlgButtonChecked( IDC_SAVE ) == BST_CHECKED);

            if (*Enabled) {

                GetDlgItemText( IDC_DEST_FOLDER, lpCurSel, MAX_PATH - 1 );

                if (lpCurSel[0] == 0) {
                    DisplayMessageDialog( 0, IDS_DEST_FOLDER );
                    return FALSE;
                }
            }
        }

        OneEnabled |= *Enabled;
    }

    if (!OneEnabled) {
        DisplayMessageDialog( 0, IDS_ONE_ENABLE );
        return FALSE;
    }

    if (!FaxOpenPort( m_FaxHandle, m_DeviceId, PORT_OPEN_QUERY | PORT_OPEN_MODIFY, &m_PortHandle )) {
        ec = GetLastError();
        DisplayMessageDialog( 0, IDS_CANT_SAVE );
        return FALSE;
    }

    ec = ERROR_SUCCESS;

    for (i = 0; i < RM_COUNT; i++) {

        Enabled = (LPDWORD) SetInfo[i];
        if (!FaxEnableRoutingMethod(
                                   m_PortHandle, 
                                   m_RoutingMethods[i]->Guid, 
                                   *Enabled
                                   )) {

            ec = GetLastError();        

            DisplayMessageDialog( 0, IDS_CANT_SAVE );

            if (ec == ERROR_ACCESS_DENIED) {
                break;
            }
        }
        else if (*Enabled && i!= RM_EMAIL && !FaxSetRoutingInfo(
                                                          m_PortHandle, 
                                                          m_RoutingMethods[i]->Guid, 
                                                          &SetInfo[i][0], 
                                                          INFO_SIZE)) {

            ec = GetLastError();        

            DisplayMessageDialog( 0, IDS_CANT_SAVE );

            if (ec == ERROR_ACCESS_DENIED) {
                break;
            }
        }
    }

    if (m_PortHandle) {
        FaxClose( m_PortHandle );
        m_PortHandle = NULL;
    }

    return (ec == ERROR_SUCCESS);
}



VOID
CRoutePage::SystemErrorMsg(
    DWORD ErrorCode
    )
{
    LPTSTR lpMsgBuf;


    FormatMessage(
                 FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                 NULL,
                 ErrorCode,
                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                 (LPTSTR) &lpMsgBuf,
                 0,
                 NULL
                 );

    MessageBox( lpMsgBuf, m_Title );

    MemFree( lpMsgBuf );
}

VOID
CRoutePage::EnumMapiProfiles(
    HWND hwnd                           
    )
/*++

Routine Description:

    Put the mapi profiles in the combo box

Arguments:

    hwnd - window handle to mapi profiles combo box

Return Value:

    NONE

--*/
{
    LPWSTR MapiProfiles;

    MapiProfiles = (LPWSTR) m_MapiProfiles;

    while (MapiProfiles && *MapiProfiles) {
        ::SendMessage(
                     hwnd,
                     CB_ADDSTRING,
                     0,
                     (LPARAM) MapiProfiles
                     );
        MapiProfiles += wcslen(MapiProfiles) + 1;
    }
}

VOID
CRoutePage::SetChangedFlag(
    BOOL Flag
    )
{
    PropSheet_Changed( GetParent(), m_hWnd );
    m_bChanged = TRUE;
}


INT
CRoutePage::DisplayMessageDialog(
    INT     titleStrId,
    INT     formatStrId,
    UINT    type
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    type - Specifies the type of message box to be displayed
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    Same as the return value from MessageBox

--*/

{
    LPWSTR  pTitle, pFormat, pMessage;
    INT     result;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = (LPWSTR)MemAlloc(MAX_TITLE_LEN * sizeof(WCHAR))) &&
        (pFormat = (LPWSTR)MemAlloc(MAX_STRING_LEN * sizeof(WCHAR))) &&
        (pMessage = (LPWSTR)MemAlloc(MAX_MESSAGE_LEN * sizeof(WCHAR)))) {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_DLGTITLE;

        LoadString(_Module.m_hInst, titleStrId, pTitle, MAX_TITLE_LEN);

        //
        // Load message format string resource
        //

        LoadString(_Module.m_hInst, formatStrId, pFormat, MAX_STRING_LEN);


        //
        // Display the message box
        //

        result = MessageBox(pFormat, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}

BOOL
CRoutePage::BrowseForDirectory(
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    textFieldId - Specifies the text field adjacent to the Browse button
    titleStrId - Specifies the title to be displayed in the browse window

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    WCHAR           buffer[MAX_PATH];
    WCHAR           title[MAX_TITLE_LEN];
    VOID            SHFree(LPVOID);
    BOOL            result = FALSE;
    LPMALLOC        pMalloc;

    BROWSEINFO bi = {

        m_hWnd,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS,
        NULL,
        (LPARAM) buffer,
    };

    if (! LoadString(_Module.m_hInst, IDS_INBOUND_DIR, title, MAX_TITLE_LEN))
        title[0] = 0;

    if (! GetDlgItemText( IDC_DEST_FOLDER, buffer, MAX_PATH))
        buffer[0] = 0;

    if (pidl = SHBrowseForFolder(&bi)) {

        if (SHGetPathFromIDList(pidl, buffer)) {

            if (wcslen(buffer) > MAX_ARCHIVE_DIR)
                DisplayMessageDialog(0,IDS_DIR_TOO_LONG);
            else {

                SetDlgItemText(IDC_DEST_FOLDER, buffer);
                result = TRUE;
            }
        }

        SHGetMalloc(&pMalloc);

        pMalloc->Free(pidl);

        pMalloc->Release();
    }

    return result;
}

LRESULT
CRoutePage::OnWmHelp(
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
    )
{
    
    ::WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
            FAXCFG_HELP_FILENAME,
            HELP_WM_HELP,
            (ULONG_PTR) &RoutingHelpIds);    
    return 1;
}

LRESULT
CRoutePage::OnWmContextHelp(
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
    )
{
    ::WinHelp((HWND) wParam,
            FAXCFG_HELP_FILENAME,
            HELP_CONTEXTMENU,
            (ULONG_PTR) &RoutingHelpIds);
    
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\routeext.cpp ===
// routeext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL, 
//              run nmake -f routeextps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "routeext.h"

#include "routeext_i.c"
#include "Route.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Route, CRoute)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
        if (dwReason == DLL_PROCESS_ATTACH)
        {
                _Module.Init(ObjectMap, hInstance);
        ISnapInDataInterface::Init();
                DisableThreadLibraryCalls(hInstance);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
                _Module.Term();
        return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        // registers object, typelib and all interfaces in typelib
        return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\admin\routeext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__DAB1A259_4FD7_11D1_842C_00C04FB6C218__INCLUDED_)
#define AFX_STDAFX_H__DAB1A259_4FD7_11D1_842C_00C04FB6C218__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <mmc.h>
#include <objidl.h>

#ifdef DEBUG
 #ifndef _DEBUG
  #define _DEBUG
 #endif
#define _ATL_DEBUG_REFCOUNT
#define _ATL_DEBUG_QI
#endif


#include <windows.h>
#include <shellapi.h>
#include <winspool.h>
#include <tchar.h>

#include "faxutil.h"

#define _ASSERTE    Assert

#include <atl21\atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;


#include <atl21\atlwin.h>
#include <atl21\atlcom.h>



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DAB1A259_4FD7_11D1_842C_00C04FB6C218__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\cpl\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Declaration of resource ID constants

Environment:

	Windows NT fax configuration applet

Revision History:

	02/22/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// String resource IDs
//

#define IDS_FAX                         256
#define IDS_CONFIG_FAX                  257
#define IDS_FAX_CLIENT                  258
#define IDS_CONFIG_FAX_CLIENT           259
#define IDS_FAX_SERVER                  260
#define IDS_CONFIG_FAX_SERVER           261

//
// Icon resource IDs
//

#define IDI_FAX                         256
#define IDI_FAX_CLIENT                  257
#define IDI_FAX_SERVER                  258

#endif	// !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\cfghelp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cfghelp.h

Abstract:

    Help related declarations

Environment:

    Windows NT fax configuration applet

Revision History:

    07/17/96 -davidx-
        Created it.

    07/26/96 - a-jmike
        Added id numbers for help topics and updated,
        changed help file name from faxcfg.hlp to fax.hlp

    dd-mm-yy -author-
        description

--*/

#include "faxhelp.h"

#ifndef _CFGHELP_H_
#define _CFGHELP_H_


//
// Fax Client applet: General tab
//

static DWORD clientOptionsHelpIDs[] = {

    IDCSTATIC_ORIENTATION,      IDH_ORIENTATION,
    IDC_SEND_WHEN_MINUTE,       IDH_SEND_AT_TIME,
    IDC_PRINTER_LIST,           IDH_PRINTER_LIST,
    IDC_SEND_WHEN_AMPM,         IDH_SEND_AT_TIME,
    IDC_NEW_PRINTER,            IDH_NEW_PRINTER,
    IDC_TIME_ARROW,             IDH_SEND_AT_TIME,
    IDC_DELETE_PRINTER,         IDH_DELETE_PRINTER,
    IDC_SEND_ASAP,              IDH_SEND_ASAP,
    IDC_SEND_AT_CHEAP,          IDH_SEND_AT_CHEAP,
    IDC_SEND_AT_TIME,           IDH_SEND_AT_TIME,
    IDC_PAPER_SIZE,             IDH_PAPER_SIZE,
    IDC_IMAGE_QUALITY,          IDH_IMAGE_QUALITY,
    IDC_PORTRAIT,               IDH_PORTRAIT,
    IDC_LANDSCAPE,              IDH_LANDSCAPE,
    IDC_BILLING_CODE,           IDH_BILLING_CODE,
    IDC_SEND_WHEN_HOUR,         IDH_SEND_AT_TIME,
    IDCSTATIC_TIME_TO_SEND,     IDH_INACTIVE,
    IDCSTATIC_FAX_PRINTERS,     IDH_PRINTER_LIST,
    IDCSTATIC_PRINT_SETUP,      IDH_PRINT_SETUP,
    IDCSTATIC_PAPER_SIZE,       IDH_PAPER_SIZE,
    IDCSTATIC_IMAGE_QUALITY,    IDH_IMAGE_QUALITY,
    IDCSTATIC_BILLING_CODE,     IDH_BILLING_CODE,
    IDCSTATIC_FAXOPTS_ICON,     IDH_INACTIVE,
    IDCSTATIC_CLIENT_OPTIONS,   IDH_INACTIVE,
    0,                          0
};

//
// Fax Client applet: Cover Page tab
//

static DWORD personalCoverPageHelpIDs[] = {

    IDC_COVERPG_LIST,           IDH_COVERPG_LIST_CLIENT,
    IDC_COVERPG_ADD,            IDH_COVERPG_ADD,
    IDC_COVERPG_NEW,            IDH_COVERPG_NEW,
    IDC_COVERPG_OPEN,           IDH_COVERPG_OPEN,
    IDC_COVERPG_REMOVE,         IDH_COVERPG_REMOVE,
    IDCSTATIC_COVERPAGE_ICON,   IDH_INACTIVE,
    IDCSTATIC_COVER_PAGE,       IDH_INACTIVE,
    0,                          0
};

//
// Fax Client applet: User Info tab
//

static DWORD userInfoHelpIDs[] = {

    IDC_SENDER_NAME,            IDH_SENDER_NAME,
    IDC_SENDER_FAX_NUMBER,      IDH_FAX_NUMBER,
    IDC_SENDER_MAILBOX,         IDH_SENDER_MAILBOX,
    IDC_SENDER_COMPANY,         IDH_SENDER_COMPANY,
    IDC_SENDER_ADDRESS,         IDH_SENDER_ADDRESS,
    IDC_SENDER_TITLE,           IDH_SENDER_TITLE,
    IDC_SENDER_DEPT,            IDH_SENDER_DEPT,
    IDC_SENDER_OFFICE_LOC,      IDH_SENDER_OFFICE_LOC,
    IDC_SENDER_OFFICE_TL,       IDH_SENDER_OFFICE_TL,
    IDC_SENDER_HOME_TL,         IDH_SENDER_HOME_TL,
    IDCSTATIC_FULLNAME,         IDH_SENDER_NAME,
    IDCSTATIC_FAX_NUMBER_GROUP, IDH_FAX_NUMBER_GROUP,
    IDCSTATIC_COUNTRY,          IDH_SENDER_COUNTRY_CODE,
    IDCSTATIC_FAX_NUMBER,       IDH_FAX_NUMBER,
    IDCSTATIC_MAILBOX,          IDH_SENDER_MAILBOX,
    IDCSTATIC_TITLE,            IDH_SENDER_TITLE,
    IDCSTATIC_COMPANY,          IDH_SENDER_COMPANY,
    IDCSTATIC_OFFICE,           IDH_SENDER_OFFICE_LOC,
    IDCSTATIC_DEPT,             IDH_SENDER_DEPT,
    IDCSTATIC_HOME_PHONE,       IDH_SENDER_HOME_TL,
    IDCSTATIC_WORK_PHONE,       IDH_SENDER_OFFICE_TL,
    IDCSTATIC_ADDRESS,          IDH_SENDER_ADDRESS,
    IDCSTATIC_FAX_NUMBER_GROUP, IDH_FAX_NUMBER_GROUP,
    IDCSTATIC_USERINFO_ICON,    IDH_INACTIVE,
    IDCSTATIC_USERINFO,         IDH_INACTIVE,
    0,                          0
};

//
// Fax Server applet: General tab
//

static DWORD serverOptionsHelpIDs[] = {

    IDC_NUMRETRIES,             IDH_NUMRETRIES,
    IDC_RETRY_INTERVAL,         IDH_RETRY_INTERVAL,
    IDC_MAXJOBLIFE,             IDH_MAXJOBLIFE,
    IDC_USE_DEVICE_TSID,        IDH_USE_DEVICE_TSID,
    IDC_PRINT_BANNER,           IDH_PRINT_BANNER,
    IDCSTATIC_RETRY_GROUP,      IDH_RETRY_GROUP,
    IDCSTATIC_MAXJOBLIFE,       IDH_MAXJOBLIFE,
    IDCSTATIC_LOCATION_LIST,    IDH_LOCATION_LIST,
    IDCSTATIC_RETRY_INTERVAL,   IDH_RETRY_INTERVAL,
    IDCSTATIC_NUMRETRIES,       IDH_NUMRETRIES,
    IDCSTATIC_DIALING_ICON,     IDH_INACTIVE,
    IDCSTATIC_SERVER_OPTIONS,   IDH_INACTIVE,
    0,                          0
};

//
// Fax Server applet: Cover Page tab
//

static DWORD serverCoverPageHelpIDs[] = {

    IDC_PRINTER_LIST,           IDH_PRINTER_LIST,
    IDC_NEW_PRINTER,            IDH_NEW_PRINTER,
    IDC_DELETE_PRINTER,         IDH_DELETE_PRINTER,
    IDC_COVERPG_LIST,           IDH_COVERPG_LIST_SERVER,
    IDC_COVERPG_ADD,            IDH_COVERPG_ADD,
    IDC_COVERPG_NEW,            IDH_COVERPG_NEW,
    IDC_COVERPG_OPEN,           IDH_COVERPG_OPEN,
    IDC_COVERPG_REMOVE,         IDH_COVERPG_REMOVE,
    IDC_USE_SERVERCP,           IDH_USE_SERVERCP,
    IDCSTATIC_COVERPAGE_ICON,   IDH_INACTIVE,
    IDCSTATIC_COVER_PAGE,       IDH_INACTIVE,
    0,                          0
};

//
// Fax Server applet: Send tab
//

static DWORD sendOptionsHelpIDs[] = {

    IDC_PRINTER_LIST,           IDH_PRINTER_LIST,
    IDC_BROWSE_DIR,             IDH_BROWSE_DIR,
    IDC_NEW_PRINTER,            IDH_NEW_PRINTER,
    IDC_DELETE_PRINTER,         IDH_DELETE_PRINTER,
    IDC_TC_CHEAP_BEGIN,         IDH_CHEAP_BEGIN,
    IDC_CHEAP_BEGIN_HOUR,       IDH_CHEAP_BEGIN,
    IDC_TIME_SEP1,              IDH_CHEAP_BEGIN,
    IDC_CHEAP_BEGIN_MINUTE,     IDH_CHEAP_BEGIN,
    IDC_CHEAP_BEGIN_AMPM,       IDH_CHEAP_BEGIN,
    IDC_TSID,                   IDH_TSID,
    IDC_CHEAP_BEGIN_TARROW,     IDH_CHEAP_BEGIN,
    IDC_ARCHIVE_CHECKBOX,       IDH_ARCHIVE_CHECKBOX,
    IDC_ARCHIVE_DIRECTORY,      IDH_ARCHIVE_DIRECTORY,
    IDC_FAX_DEVICE_LIST,        IDH_FAX_DEVICE_LIST,
    IDC_TC_CHEAP_END,           IDH_CHEAP_END,
    IDC_CHEAP_END_HOUR,         IDH_CHEAP_END,
    IDC_CHEAP_END_MINUTE,       IDH_CHEAP_END,
    IDC_CHEAP_END_AMPM,         IDH_CHEAP_END,
    IDC_CHEAP_END_TARROW,       IDH_CHEAP_END,
    IDCSTATIC_FAX_PRINTERS,     IDH_PRINTER_LIST,
    IDCSTATIC_FAX_DEVICES,      IDH_FAX_DEVICE_LIST,
    IDCSTATIC_TSID,             IDH_TSID,
    IDCSTATIC_CHEAP_BEGIN,      IDH_CHEAP_BEGIN,
    IDCSTATIC_CHEAP_END,        IDH_CHEAP_END,
    IDCSTATIC_SEND_ICON,        IDH_INACTIVE,
    IDCSTATIC_SEND_OPTIONS,     IDH_INACTIVE,
    0,                          0
};

//
// Fax Server applet: Receive tab
//

static DWORD receiveOptionsHelpIDs[] = {

    IDC_DEST_DIRPATH,           IDH_DEST_DIRPATH,
    IDC_BROWSE_DIR,             IDH_BROWSE_DIR,
    IDC_DEST_EMAIL,             IDH_DEST_EMAIL,
    IDC_DEST_MAILBOX,           IDH_DEST_MAILBOX,
    IDC_DEST_PROFILENAME,       IDH_DEST_PROFILENAME,
    IDC_CSID,                   IDH_CSID,
    IDC_FAX_DEVICE_LIST,        IDH_FAX_DEVICE_LIST,
    IDC_DEST_PRINTER,           IDH_DEST_PRINTER,
    IDC_DEST_PRINTERLIST,       IDH_DEST_PRINTERLIST,
    IDC_DEST_DIR,               IDH_DEST_DIR,
    IDCSTATIC_FAX_DEVICES,      IDH_FAX_DEVICE_LIST,
    IDCSTATIC_DEVICE_OPTIONS,   IDH_SELECT_DEVICES_GROUP,
    IDCSTATIC_CSID,             IDH_CSID,
    IDCSTATIC_PROFILE_NAME,     IDH_DEST_PROFILENAME,
    IDCSTATIC_RECEIVE_ICON,     IDH_INACTIVE,
    IDCSTATIC_RECEIVE_OPTIONS,  IDH_INACTIVE,
    IDC_DEST_RINGS,             IDH_RECEIVE_RINGS_BEFORE_ANSWER,
    0,                          0
};

//
// Fax Server applet: Priority tab
//

static DWORD devicePriorityHelpIDs[] = {

    IDC_FAX_DEVICE_LIST,        IDH_FAX_DEVICE_LIST,
    IDC_MOVEUP,                 IDH_MOVEUP,
    IDC_MOVEDOWN,               IDH_MOVEDOWN,
    0,                          0
};

//
// Fax Server applet: Status tab
//

static DWORD deviceStatusHelpIDs[] = {

    IDC_DETAILS,                IDH_DETAILS,
    IDC_REFRESH,                IDH_REFRESH,
    IDC_FAX_DEVICE_LIST,        IDH_FAX_DEVICE_LIST_STATUS,
    IDCSTATIC_STATUS_ICON,      IDH_INACTIVE,
    IDCSTATIC_DEVICE_STATUS,    IDH_INACTIVE,
    0,                          0
};

//
// Fax Server applet: Monitor tab
//

static DWORD statusMonitorHelpIDs[] = {
    IDC_STATUS_TASKBAR,         IDH_STATUS_DISPLAY_ON_TASKBAR,
    IDC_STATUS_ONTOP,           IDH_STATUS_ALWAYS_ON_TOP,
    IDC_STATUS_VISUAL,          IDH_STATUS_VISUAL_NOTIFICATION,
    IDC_STATUS_SOUND,           IDH_STATUS_SOUND_NOTIFICATION,
    IDC_STATUS_MANUAL,          IDH_STATUS_ENABLE_MANUAL_ANSWER,
    0,                          0
};

//
// Fax Server applet: Logging tab
//

static DWORD loggingHelpIDs[] = {

    IDC_LOGGING_LIST,             IDH_LOGGING_LIST,
    IDC_LOG_NONE,                 IDH_LOG_LEVEL,
    IDC_LOG_MIN,                  IDH_LOG_LEVEL,
    IDC_LOG_MED,                  IDH_LOG_LEVEL,
    IDC_LOG_MAX,                  IDH_LOG_LEVEL,
    IDCSTATIC_LOGGING_CATEGORIES, IDH_LOGGING_LIST,
    IDCSTATIC_LOGGING_LEVEL,      IDH_LOG_LEVEL,
    IDCSTATIC_LOGGING_ICON,       IDH_INACTIVE,
    IDCSTATIC_LOGGING,            IDH_INACTIVE,
    0,                          0
};

//
// "Add Fax Printer" Dialog Box
//

static DWORD addPrinterHelpIDs[]= {

    IDC_PRINTER_NAME,           IDH_PRINTER_NAME,
    0,                          0
};

//
// "Add Fax Printer Connection" Dialog Box
//

static DWORD addPrinterConnectionHelpIDs[]= {

    IDC_PRINTER_NAME,           IDH_PRINTER_CONNECTION,
    0,                          0
};

#endif  // !_CFGHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\cpl\faxcfg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcfg.c

Abstract:

    Implementation of the control panel applet entry point

Environment:

        Windows NT fax configuration applet

Revision History:

        02/27/96 -davidx-
                Created it.

        05/22/96 -davidx-
                Share the same DLL with remote admin program.

        mm/dd/yy -author-
                description

--*/

#include <stdlib.h>
#include <windows.h>
#include <commctrl.h>
#include <cpl.h>
#include <tchar.h>

#include "faxcfg.h"
#include "resource.h"


//
// Fax configuration applet index
//

#define FAX_CLIENT_APPLET       0
#define FAX_SERVER_APPLET       1

//
// Definition of global variables
//

HANDLE      ghInstance;         // DLL instance handle
INT         faxConfigType;      // fax configuration type

//
// Forward declaration of local functions
//

VOID FillOutCPlInfo(CPLINFO *, INT);
INT DoFaxConfiguration(HWND, INT, LPTSTR);



BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason) {

    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}



LONG
CPlApplet(
    HWND    hwndCPl,
    UINT    uMsg,
    LONG    lParam1,
    LONG    lParam2
    )

/*++

Routine Description:

    Control panel applet entry point

Arguments:

    hwndCPl - Identifies the Control Panel window
    uMsg - Specifies the message being sent to the Control Panel applet
    lParam1 - Specifies additional message-specific information
    lParam2 - Specifies additional message-specific information

Return Value:

    Depends on the message

--*/

{
    static BOOL Failed = FALSE;


    switch (uMsg) {

    case CPL_INIT:

        {
            DWORD Size;
            WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+4];

            ComputerName[0] = L'\\';
            ComputerName[1] = L'\\';

            Size = sizeof(ComputerName)/sizeof(WCHAR);

            GetComputerName( &ComputerName[2], &Size );

            return (faxConfigType = FaxConfigInit(ComputerName, TRUE)) >= 0;
        }

    case CPL_GETCOUNT:

        //
        // We export one or two applets depending on whether
        // we're doing client, server, or workstation configuration
        //

        return (faxConfigType == FAXCONFIG_SERVER) ? 2 : 1;

    case CPL_INQUIRE:

        //
        // Fill out the CPLINFO structure depending on the fax configuration type
        //

        FillOutCPlInfo((CPLINFO *) lParam2, lParam1);
        break;

    case CPL_DBLCLK:

        //
        // Treat this as CPL_STARTWPARMS with no parameter
        //
        if (Failed) {
            return 1;
        }
        return DoFaxConfiguration(hwndCPl, lParam1, NULL);

    case CPL_STARTWPARMS:

        //
        // Display fax configuration dialog: client, server, or workstation
        //

        if (!(DoFaxConfiguration(hwndCPl, lParam1, (LPTSTR) lParam2) == 0)) {
            Failed = TRUE;
            return 1;
        }
        return 0;

    case CPL_EXIT:

        FaxConfigCleanup();
        break;
    }

    return 0;
}



VOID
FillOutCPlInfo(
    CPLINFO *pCPlInfo,
    INT     cplIndex
    )

/*++

Routine Description:

    Fill out the CPLINFO structure corresponding to the
    specified fax configuration control panel applet

Arguments:

    pCPlInfo - Points to a CPLINFO buffer
    cplIndex - Index of the interested fax conguration applet

Return Value:

    NONE

--*/

{
    pCPlInfo->lData = 0;

    switch (faxConfigType) {

    case FAXCONFIG_SERVER:

        if (cplIndex == FAX_SERVER_APPLET) {

            //
            // Fax server configuration
            //

            pCPlInfo->idIcon = IDI_FAX_SERVER;
            pCPlInfo->idName = IDS_FAX_SERVER;
            pCPlInfo->idInfo = IDS_CONFIG_FAX_SERVER;

        } else {

            //
            // Fax client configuration
            //

            pCPlInfo->idIcon = IDI_FAX_CLIENT;
            pCPlInfo->idName = IDS_FAX_CLIENT;
            pCPlInfo->idInfo = IDS_CONFIG_FAX_CLIENT;
        }
        break;

    default:

        //
        // Fax client or workstation configuration
        //

        pCPlInfo->idIcon = IDI_FAX;
        pCPlInfo->idName = IDS_FAX;
        pCPlInfo->idInfo = IDS_CONFIG_FAX;
        break;
    }
}



INT
DoFaxConfiguration(
    HWND    hwndCPl,
    INT     cplIndex,
    LPTSTR  pCmdLine
    )

/*++

Routine Description:

    Display fax configuration dialogs: client, server, or workstation

Arguments:

    hwndCPl - Handle to the Control Panel window
    cplIndex - Index of the interested fax configuration applet
    pCmdLine - Command line parameters

Return Value:

    0 if successful, -1 if there is an error

--*/

#define MAX_PAGES       16
#define MAX_TITLE_LEN   64

{
    HPROPSHEETPAGE  hPropSheetPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    CPLINFO         cplInfo;
    TCHAR           dlgTitle[MAX_TITLE_LEN];
    INT             nPages, nStartPage;

    //
    // Get an array of property sheet page handles
    //

    switch (faxConfigType) {

    case FAXCONFIG_WORKSTATION:

        nPages = FaxConfigGetWorkstationPages(hPropSheetPages, MAX_PAGES);
        break;

    case FAXCONFIG_SERVER:

        if (cplIndex == FAX_SERVER_APPLET) {

            nPages = FaxConfigGetServerPages(hPropSheetPages, MAX_PAGES);
            break;
        }

    default:

        nPages = FaxConfigGetClientPages(hPropSheetPages, MAX_PAGES);
        break;
    };

    if (nPages < 0 || nPages > MAX_PAGES)
        return -1;

    //
    // Determine which page to activate initially
    //

    nStartPage = pCmdLine ? _ttol(pCmdLine) : 0;

    if (nStartPage < 0 || nStartPage >= nPages)
        nStartPage = 0;

    //
    // Fill out PROPSHEETHEADER structure
    //

    FillOutCPlInfo(&cplInfo, cplIndex);
    LoadString(ghInstance, cplInfo.idInfo, dlgTitle, MAX_TITLE_LEN);

    ZeroMemory(&psh, sizeof(psh));
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID;
    psh.hwndParent = hwndCPl;
    psh.hInstance = ghInstance;
    psh.pszIcon = MAKEINTRESOURCE(cplInfo.idIcon);
    psh.pszCaption = dlgTitle;
    psh.nPages = nPages;
    psh.nStartPage = nStartPage;
    psh.phpage = hPropSheetPages;

    //
    // Display the property sheet
    //

    return (PropertySheet(&psh) == -1) ? -1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\clientcp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clientcp.c

Abstract:

    Functions for handling events in the "Client Cover Page" tab of
    the fax client configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"
#include "coverpg.h"



BOOL
ClientCoverPageProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Client Cover Page" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;

    switch (message) {

    case WM_INITDIALOG:

        Assert(ValidConfigData(gConfigData) && gConfigData->pCPInfo == NULL);

        gConfigData->pCPInfo =
            AllocCoverPageInfo(gConfigData->configType == FAXCONFIG_WORKSTATION);

        InitCoverPageList(gConfigData->pCPInfo, hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_COVERPG_ADD:
        case IDC_COVERPG_NEW:
        case IDC_COVERPG_OPEN:
        case IDC_COVERPG_REMOVE:

            //
            // User clicked one of the buttons for managing cover page files
            //

            cmdId = (cmdId == IDC_COVERPG_REMOVE) ? CPACTION_REMOVE :
                    (cmdId == IDC_COVERPG_OPEN) ? CPACTION_OPEN :
                    (cmdId == IDC_COVERPG_NEW) ? CPACTION_NEW : CPACTION_BROWSE;

            ManageCoverPageList(hDlg,
                                gConfigData->pCPInfo,
                                GetDlgItem(hDlg, IDC_COVERPG_LIST),
                                cmdId);
            break;

        case IDC_COVERPG_LIST:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

            case LBN_SELCHANGE:

                UpdateCoverPageControls(hDlg);
                break;

            case LBN_DBLCLK:

                //
                // Double-clicking in the cover page list is equivalent
                // to pressing the "Open" button
                //

                ManageCoverPageList(hDlg,
                                    gConfigData->pCPInfo,
                                    GetDlgItem(hDlg, cmdId),
                                    CPACTION_OPEN);
                break;
            }
            break;

        default:

            return FALSE;
        }
        return TRUE;

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

        case PSN_SETACTIVE:

            break;

        case PSN_APPLY:

            return PSNRET_NOERROR;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, CLIENT_COVERPG_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\diaglog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    diaglog.c

Abstract:

    Functions for handling events in the "Diagnostics Logging" tab of
    the fax server configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/22/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"



VOID
UpdateLoggingLevels(
    HWND    hwndLV
    )

/*++

Routine Description:

    Display current logging level for each category

Arguments:

    hwndLV - Specifies the list view window

Return Value:

    NONE

--*/

{
    INT     index, nItems, strId;
    TCHAR   buffer[MAX_TITLE_LEN];
    LV_ITEM lvi;

    //
    // Count the number of items in the list view
    //

    if (hwndLV == NULL ||
        (nItems = ListView_GetItemCount(hwndLV)) == -1 ||
        gConfigData->pFaxConfig == NULL ||
        nItems > (INT) gConfigData->NumberCategories)
    {
        return;
    }

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 1;
    lvi.pszText = buffer;

    for (index=0; index < nItems; index++) {

        //
        // Map logging level to radio button control ID
        //

        switch (gConfigData->pFaxLogging[index].Level) {

        case FAXLOG_LEVEL_MIN:

            strId = IDS_LOGGING_MIN;
            break;

        case FAXLOG_LEVEL_MED:

            strId = IDS_LOGGING_MED;
            break;

        case FAXLOG_LEVEL_MAX:

            strId = IDS_LOGGING_MAX;
            break;

        default:

            strId = IDS_LOGGING_NONE;
            break;
        }

        if (! LoadString(ghInstance, strId, buffer, MAX_TITLE_LEN))
            buffer[0] = NUL;

        lvi.iItem = index;

        if (! ListView_SetItem(hwndLV, &lvi))
            Error(("ListView_SetItem failed\n"));
    }
}



VOID
DoInitDiagLog(
    HWND    hDlg
    )

/*++

Routine Description:

    Perform one-time initialization of "Diagnostics Logging" property page

Arguments:

    hDlg - Window handle to the "Diagnostics Logging" property page

Return Value:

    NONE

--*/

{
    HWND        hwndLV;
    RECT        rect;
    LV_COLUMN   lvc;
    TCHAR       buffer[MAX_TITLE_LEN];

    //
    // Connect to the fax service and retrieve the list of fax devices
    //

    GetFaxDeviceAndConfigInfo();

    //
    // Insert two columns: Category and Logging Level
    //

    if (! (hwndLV = GetDlgItem(hDlg, IDC_LOGGING_LIST)))
        return;

    GetClientRect(hwndLV, &rect);
    rect.right -= rect.left;

    ZeroMemory(&lvc, sizeof(lvc));

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = buffer;

    lvc.cx = rect.right * 2 / 3;
    lvc.iSubItem = 0;
    LoadString(ghInstance, IDS_CATEGORY, buffer, MAX_TITLE_LEN);

    if (ListView_InsertColumn(hwndLV, 0, &lvc) == -1) {

        Error(("ListView_InsertColumn failed\n"));
        return;
    }

    lvc.cx = rect.right / 3 - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 1;
    LoadString(ghInstance, IDS_LOGGING_LEVEL, buffer, MAX_TITLE_LEN);

    if (ListView_InsertColumn(hwndLV, 1, &lvc) == -1) {

        Error(("ListView_InsertColumn failed\n"));
        return;
    }

    //
    // Insert an item for each category
    //

    if (gConfigData->pFaxConfig) {

        LV_ITEM         lvi;
        DWORD           index;

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT;

        for (index=0; index < gConfigData->NumberCategories; index++) {

            lvi.iItem = index;
            lvi.pszText = gConfigData->pFaxLogging[index].Name;

            if (ListView_InsertItem(hwndLV, &lvi) == -1) {

                Error(("ListView_InsertItem failed\n"));
                break;
            }
        }
    }

    UpdateLoggingLevels(hwndLV);

    //
    // The initial selection is the first category in the list
    //

    ListView_SetItemState(hwndLV, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
}



BOOL
DoSaveDiagLog(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Diagnostics Logging" property page

Arguments:

    hDlg - Handle to the "Diagnostics Logging" property page

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Diagnostics Logging' page ...\n"));

    if (! GetChangedFlag(DIAG_LOG_PAGE))
        return TRUE;

    //
    // Save the fax device information if this is the last modified page
    //

    return SaveFaxDeviceAndConfigInfo(hDlg, DIAG_LOG_PAGE);
}



VOID
DoChangeLoggingCategory(
    HWND    hDlg,
    HWND    hwndLV
    )

/*++

Routine Description:

    Called when the changes the category selection

Arguments:

    hDlg - Handle to the "Diagnostics Logging" property page
    hwndLV - Handle to the logging category list view

Return Value:

    NONE

--*/

{
    INT             index, itemId;
    DWORD           level = 0xffffffff;

    //
    // Find the common level shared by selected categories
    //

    if (hwndLV == NULL || gConfigData->pFaxLogging == NULL)
        return;

    if ((index = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) != -1) {

        Assert(index < (INT) gConfigData->NumberCategories);
        level = gConfigData->pFaxLogging[index].Level;

        while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

            Assert(index < (INT) gConfigData->NumberCategories );

            if (gConfigData->pFaxLogging[index].Level != level) {

                level = 0xffffffff;
                break;
            }
        }
    }

    //
    // Map logging level to radio button control ID
    //

    switch (level) {

    case FAXLOG_LEVEL_NONE:

        itemId = IDC_LOG_NONE;
        break;

    case FAXLOG_LEVEL_MIN:

        itemId = IDC_LOG_MIN;
        break;

    case FAXLOG_LEVEL_MED:

        itemId = IDC_LOG_MED;
        break;

    case FAXLOG_LEVEL_MAX:

        itemId = IDC_LOG_MAX;
        break;

    default:

        itemId = 0;
        break;
    }

    for (index=IDC_LOG_NONE; index <= IDC_LOG_MAX; index++)
        CheckDlgButton(hDlg, index, (index == itemId) ? BST_CHECKED : BST_UNCHECKED);
}



VOID
DoChangeLoggingLevel(
    HWND    hDlg,
    INT     itemId
    )

/*++

Routine Description:

    Change the logging level of the currently selected categories

Arguments:

    hDlg - Handle to the "Diagnostics Logging" property page
    itemId - Control ID of the selected logging level

Return Value:

    NONE

--*/

{
    HWND            hwndLV;
    DWORD           level;
    INT             index = -1;


    if (!(hwndLV = GetDlgItem(hDlg, IDC_LOGGING_LIST)) || gConfigData->pFaxLogging == NULL)
        return;

    switch (itemId) {

    case IDC_LOG_NONE:

        level = FAXLOG_LEVEL_NONE;
        break;

    case IDC_LOG_MIN:

        level = FAXLOG_LEVEL_MIN;
        break;

    case IDC_LOG_MED:

        level = FAXLOG_LEVEL_MED;
        break;

    case IDC_LOG_MAX:

        level = FAXLOG_LEVEL_MAX;
        break;
    }

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

        Assert(index < (INT) gConfigData->NumberCategories);

        gConfigData->pFaxLogging[index].Level = level;
    }

    UpdateLoggingLevels(hwndLV);
}



BOOL
DiagLogProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Diagnostics Logging" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;
    NMHDR  *pNMHdr;

    switch (message) {

    case WM_INITDIALOG:

        DoInitDiagLog(hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_LOG_NONE:
        case IDC_LOG_MIN:
        case IDC_LOG_MED:
        case IDC_LOG_MAX:

            DoChangeLoggingLevel(hDlg, cmdId);
            SetChangedFlag(hDlg, DIAG_LOG_PAGE, TRUE);
            return TRUE;

        default:

            break;
        }
        break;

    case WM_NOTIFY:

        pNMHdr = (NMHDR *) lParam;

        if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_LOGGING_LIST)) {

            if (pNMHdr->code == LVN_ITEMCHANGED)
                DoChangeLoggingCategory(hDlg, pNMHdr->hwndFrom);

        } else if (pNMHdr->code == PSN_APPLY) {

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            if (! DoSaveDiagLog(hDlg)) {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;

            } else {

                SetChangedFlag(hDlg, DIAG_LOG_PAGE, FALSE);
                return PSNRET_NOERROR;
            }
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, DIAG_LOG_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\coverpg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.h

Abstract:

    Functions for working with cover pages

Environment:

        Windows NT fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _COVERPAGE_H_
#define _COVERPAGE_H_

//
// Directory on the server for storing cover pages.
// This is concatenated with \\servername\print$.
//

#define SERVER_CP_DIRECTORY TEXT("\\print$\\CoverPg\\")

//
// Cover page filename extension and link filename extension
//

#define CP_FILENAME_EXT     TEXT(".cov")
#define LNK_FILENAME_EXT    TEXT(".lnk")
#define MAX_FILENAME_EXT    4

//
// Data structure for representing a list of cover pages:
//  the first nServerDirs paths refer to the server cover page directory
//  remaining paths contain user cover page directories
//

#define MAX_COVERPAGE_DIRS  8

typedef struct {

    BOOL    serverCP;
    INT     nDirs;
    LPTSTR  pDirPath[MAX_COVERPAGE_DIRS];

} CPDATA, *PCPDATA;

//
// Flag bits attached to each cover page in a listbox
//

#define CPFLAG_DIRINDEX 0x00FF
#define CPFLAG_LINK     0x0100

//
// Generate a list of available cover pages (both server and user)
//

VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hDlg
    );

//
// Perform various action to manage the list of cover pages
//

VOID
ManageCoverPageList(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    INT     action
    );

#define CPACTION_BROWSE 0
#define CPACTION_OPEN   1
#define CPACTION_NEW    2
#define CPACTION_REMOVE 3

//
// Enable/disable buttons for manage cover page files
//

VOID
UpdateCoverPageControls(
    HWND    hDlg
    );

//
// Allocate memory to hold cover page information
//

PCPDATA
AllocCoverPageInfo(
    BOOL serverCP
    );

//
// Free up memory used for cover page information
//

VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    );

//
// Perform OLE deinitialization if necessary
//

VOID
DeinitOle(
    VOID
    );

#endif  // !_COVERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\faxcpl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcpl.c

Abstract:

    Implementation of the control panel applet entry point

Environment:

        Windows NT fax configuration applet

Revision History:

        02/27/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"

#include <tapi.h>
#include "faxdev.h"

//
// Global variable definitions
//

HANDLE      ghInstance = NULL;  // Fax monitor DLL instance handle
PCONFIGDATA gConfigData = NULL; // Fax configuration data structure
INT         _debugLevel = 1;    // Control the amount of debug messages generated

//
// Setup API for determining whether the user has admin privilege on a machine
//

BOOL
IsUserAdmin(
    VOID
    );



extern BOOL WINAPI _CRT_INIT(HANDLE, ULONG, PVOID);

BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason) {

    case DLL_PROCESS_ATTACH:
#if DBG
        _CRT_INIT(hModule, ulReason, pContext);
#endif

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:

        FaxConfigCleanup();
#if DBG
        _CRT_INIT(hModule, ulReason, pContext);
#endif
        break;
    }

    return TRUE;
}



INT
DetermineFaxConfigType(
    BOOL CplInit
    )

/*++

Routine Description:

    Determine the type of fax installation

Arguments:

    CplInit - if this is TRUE then don't display the message box

Return Value:

    FAXCONFIG_CLIENT - client installation
    FAXCONFIG_WORKSTATION - workstation installation
    FAXCONFIG_SERVER - server installation

    -1 if there is an error

--*/

{
    HANDLE  FaxHandle = NULL;
    DWORD   InstallType;
    DWORD   InstalledPlatforms;
    DWORD   ProductType;
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;


    //
    // look at the machine registry for an install type
    // if the install type is for a network client, then
    // that is the cpl that we present.  if there is a
    // network client and a server installed on this machine
    // then the install type will contain a mask of those
    // two values and this check will fail.  this check
    // is here so that on a network client only install
    // we don't go off and try to talk to a server.
    //

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, &hKey ) != ERROR_SUCCESS) {
        return -1;
    }

    Size = sizeof(InstallType);
    if (RegQueryValueEx( hKey, REGVAL_FAXINSTALL_TYPE, NULL, &Type, (LPBYTE) &InstallType, &Size ) != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return -1;
    }

    RegCloseKey( hKey );

    if (InstallType == FAX_INSTALL_NETWORK_CLIENT ) {
        return FAXCONFIG_CLIENT;
    }

    if (CplInit) {
        goto noconnect;
    }
    //
    // ask the server for the install type
    //

    if ((!FaxConnectFaxServer( gConfigData->pServerName, &FaxHandle)) ||
        (!FaxGetInstallType( FaxHandle, &InstallType, &InstalledPlatforms, &ProductType )))
    {
        if (FaxHandle) {
            FaxClose( FaxHandle );
        }

        DisplayMessageDialog( NULL, 0, 0, IDS_NULL_SERVICE_HANDLE );

        return -1;
    }

    FaxClose( FaxHandle );

noconnect:
    Verbose(("Fax installation type: 0x%x\n", InstallType));

    if (InstallType & FAX_INSTALL_SERVER)
        InstallType = FAXCONFIG_SERVER;
    else if (InstallType & FAX_INSTALL_WORKSTATION)
        InstallType = FAXCONFIG_WORKSTATION;
    else
        InstallType = FAXCONFIG_CLIENT;

    return InstallType;
}



LPTSTR
VerifyServerName(
    LPTSTR  pServerName
    )

/*++

Routine Description:

    Verify the server name is well-formed

Arguments:

    pServerName - Specifies the input server name

Return Value:

    Pointer to a copy of the verified server name
    NULL if there is an error

--*/

{
    LPTSTR  pVerifiedName;

    Assert(pServerName != NULL);

    if (pVerifiedName = MemAlloc(SizeOfString(pServerName) + 2*sizeof(TCHAR))) {

        //
        // Make sure the server name always starts with double backslash (\\)
        //

        pVerifiedName[0] = pVerifiedName[1] = TEXT(PATH_SEPARATOR);

        while (*pServerName == TEXT(PATH_SEPARATOR))
            pServerName++;

        _tcscpy(pVerifiedName+2, pServerName);
    }

    return pVerifiedName;
}



INT
FaxConfigInit(
    LPTSTR  pServerName,
    BOOL    CplInit
    )

/*++

Routine Description:

    Initialize fax configuration DLL

Arguments:

    pServerName - Specifies the name of the fax server machine.
        Pass NULL for local machine.

    CplInit - TRUE if called due to CPL_INIT message

Return Value:

    -1 - An error has occurred
    FAXCONFIG_CLIENT -
    FAXCONFIG_SERVER -
    FAXCONFIG_WORKSTATION - Indicates the type of configuration the user can run

--*/

{
    //
    // Allocate memory for the fax configuration data structure
    //

    Assert(gConfigData == NULL);

    if (! (gConfigData = MemAllocZ(sizeof(CONFIGDATA)))) {

        Error(("Memory allocation failed\n"));
        return -1;
    }

    gConfigData->startSign = gConfigData->endSign = gConfigData;

    //
    // Make sure the server name is well-formed
    // Determine the type of fax configuration to be run
    //

    if ((pServerName && !(gConfigData->pServerName = VerifyServerName(pServerName))) ||
        (gConfigData->configType = DetermineFaxConfigType(CplInit)) < 0)
    {
        FaxConfigCleanup();
        return -1;
    }

    return gConfigData->configType;
}



VOID
FaxConfigCleanup(
    VOID
    )

/*++

Routine Description:

    Deinitialize fax configuration DLL

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (gConfigData != NULL) {

        Assert(ValidConfigData(gConfigData));

        //
        // Disconnect from the fax service if we're currently connected
        //

        if (gConfigData->hFaxSvc)
            FaxClose(gConfigData->hFaxSvc);

        //
        // Free up memory used to hold various information:
        //  printer information
        //  form information
        //  port information
        //

        FreeFaxDeviceAndConfigInfo();

        FreeCoverPageInfo(gConfigData->pCPInfo);
        MemFree(gConfigData->pServerName);
        MemFree(gConfigData);
        gConfigData = NULL;

        DeinitTapiService();
    }
}



//
// Information about each fax configuration page
//

typedef struct _FAXCFG_PAGEINFO {

    INT     dialogId;
    DLGPROC dialogProc;

} FAXCFG_PAGEINFO, *PFAXCFG_PAGEINFO;

static FAXCFG_PAGEINFO ClientConfigPageInfo[] = {

    { IDD_CLIENT_COVERPG,  ClientCoverPageProc },
    { IDD_USER_INFO,       UserInfoProc }
};

static FAXCFG_PAGEINFO ServerConfigPageInfo[] = {

    { IDD_SERVER_OPTIONS,  ServerOptionsProc },
    { IDD_SERVER_COVERPG,  ServerCoverPageProc },
    { IDD_SEND_OPTIONS,    SendOptionsProc },
    { IDD_RECEIVE_OPTIONS, ReceiveOptionsProc },
    { IDD_DEVICE_PRIORITY, DevicePriorityProc },
    { IDD_DEVICE_STATUS,   DeviceStatusProc },
    { IDD_LOGGING,         DiagLogProc },
    { IDD_SERVER_GENERAL,  GeneralProc }
};

static FAXCFG_PAGEINFO WorkstationConfigPageInfo[] = {

    { IDD_CLIENT_COVERPG,  ClientCoverPageProc },
    { IDD_USER_INFO,       UserInfoProc },

    { IDD_SERVER_OPTIONS,  ServerOptionsProc },
    { IDD_SEND_OPTIONS,    SendOptionsProc },
    { IDD_RECEIVE_OPTIONS, ReceiveOptionsProc },
    { IDD_LOGGING,         DiagLogProc },
    { IDD_STATUS_OPTIONS,  StatusOptionsProc }
};

#define MAX_CLIENT_PAGES (sizeof(ClientConfigPageInfo) / sizeof(FAXCFG_PAGEINFO))
#define MAX_SERVER_PAGES (sizeof(ServerConfigPageInfo) / sizeof(FAXCFG_PAGEINFO))
#define MAX_WORKSTATION_PAGES (sizeof(WorkstationConfigPageInfo) / sizeof(FAXCFG_PAGEINFO))



INT
FaxConfigGetPageHandles(
    HPROPSHEETPAGE  *phPropSheetPages,
    INT              count,
    PFAXCFG_PAGEINFO pPageInfo,
    INT              nPages
    )

{
    //
    // Zero-initialize the input buffer
    //

    if (count > 0) {

        if (phPropSheetPages == NULL) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return -1;
        }

        ZeroMemory(phPropSheetPages, sizeof(HPROPSHEETPAGE) * count);
    }

    //
    // Make sure the input buffer is large enough to hold all available pages
    //

    if (count >= nPages) {

        PROPSHEETPAGE   psp;
        INT             index;


        ZeroMemory(&psp, sizeof(psp));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.hInstance = ghInstance;
        psp.lParam = (LPARAM) gConfigData;

        for (index=0; index < nPages; index++) {

            //
            // Create property page handles
            //

            psp.pszTemplate = MAKEINTRESOURCE(pPageInfo[index].dialogId);
            psp.pfnDlgProc = pPageInfo[index].dialogProc;

            if (! (phPropSheetPages[index] = CreatePropertySheetPage(&psp))) {

                Error(("CreatePropertySheetPage failed: %d\n", GetLastError()));
                break;
            }
        }

        //
        // If we failed to create handles for all property pages,
        // we must destroy any handles we already created.
        //

        if (index < nPages) {

            while (--index >= 0)
                DestroyPropertySheetPage(phPropSheetPages[index]);

            return -1;
        }
    }

    return nPages;
}



BOOL
DoConnectFaxService(
    VOID
    )

/*++

Routine Description:

    Connect to the fax service if necessary

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD InstallType;
    DWORD InstalledPlatforms;
    DWORD ProductType;

    Assert(ValidConfigData(gConfigData));
    Assert(gConfigData->configType == FAXCONFIG_SERVER ||
           gConfigData->configType == FAXCONFIG_WORKSTATION);

    if ((! gConfigData->hFaxSvc &&
        ! FaxConnectFaxServer(gConfigData->pServerName, &gConfigData->hFaxSvc)) ||
        ! FaxGetInstallType( gConfigData->hFaxSvc, &InstallType, &InstalledPlatforms, &ProductType ))
    {
        DisplayMessageDialog(NULL, 0, 0, IDS_NO_FAX_SERVICE);
        gConfigData->hFaxSvc = NULL;
    }

    return (gConfigData->hFaxSvc != NULL);
}



//
// Get an array of handles to client/server/workstation configuration pages
//
// Parameters:
//
//  phPropSheetPages - Specifies a buffer for storing property page handles
//  count - Specifies the maximum number of handles the input buffer can hold
//
// Return value:
//
//  -1 - An error has occurred
//  >0 - Total number of configuration pages available
//
// Note:
//
//  To figure out how large the input buffer should be, the caller can
//  first call these functions with phPropSheetPages set to NULL and
//  count set to 0.
//

INT
FaxConfigGetClientPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    )

{
    //
    // We can only display client pages for non-workstation configuration types
    //

    if (!ValidConfigData(gConfigData) || gConfigData->configType == FAXCONFIG_WORKSTATION) {

        SetLastError(ERROR_INVALID_FUNCTION);
        return -1;
    }

    return FaxConfigGetPageHandles(phPropSheetPages,
                                   count,
                                   ClientConfigPageInfo,
                                   MAX_CLIENT_PAGES);
}


INT
GetDeviceProviderPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    )
{
    HKEY hKey, hKeyDev;
    DWORD PageCnt = 0;
    DWORD Index = 0;
    WCHAR KeyName[MAX_PATH+1];
    WCHAR ImageName[MAX_PATH+1];
    HMODULE hMod;
    PFAXDEVCONFIGURE pFaxDevConfigure;
    DWORD Size;
    DWORD Type;


    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_DEVICE_PROVIDER_KEY, &hKey ) != ERROR_SUCCESS) {
        return PageCnt;
    }

    while( RegEnumKey( hKey, Index, KeyName, sizeof(KeyName)/sizeof(WCHAR) ) == ERROR_SUCCESS) {

        if (RegOpenKey( hKey, KeyName, &hKeyDev ) == ERROR_SUCCESS) {

            Size = sizeof(KeyName);
            if (RegQueryValueEx( hKeyDev, REGVAL_IMAGE_NAME, 0, &Type, (LPBYTE)KeyName, &Size ) == ERROR_SUCCESS) {

                ExpandEnvironmentStrings( KeyName, ImageName, sizeof(ImageName)/sizeof(TCHAR) );

                hMod = LoadLibrary( ImageName );
                if (hMod) {
                    pFaxDevConfigure = (PFAXDEVCONFIGURE) GetProcAddress( hMod, "FaxDevConfigure" );
                    if (pFaxDevConfigure) {
                        //
                        // this device provider supports configuration
                        // lets call the dll and get the pages
                        //
                        if (pFaxDevConfigure( &phPropSheetPages[PageCnt] )) {
                            PageCnt += 1;
                        }
                    } else {
                        FreeLibrary( hMod );
                    }
                }
            }
            RegCloseKey( hKeyDev );
        }
        if (PageCnt == (DWORD) count) {
            break;
        }
        Index += 1;
    }

    RegCloseKey( hKey );

    return PageCnt;
}


INT
FaxConfigGetServerPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    )

{
    DWORD DevPages = 0;
    DWORD SvrPages = 0;


    //
    // We can only display server pages for server configuration type
    //

    if (!ValidConfigData(gConfigData) || gConfigData->configType != FAXCONFIG_SERVER) {

        SetLastError(ERROR_INVALID_FUNCTION);
        return -1;
    }

    if (!DoConnectFaxService()) {
        return -1;
    }

    SvrPages = FaxConfigGetPageHandles(
        phPropSheetPages,
        count,
        ServerConfigPageInfo,
        MAX_SERVER_PAGES
        );
    if (SvrPages) {
        count -= SvrPages;
        phPropSheetPages += SvrPages;
    }

    DevPages = GetDeviceProviderPages( phPropSheetPages, count );
    if (DevPages) {
        count -= DevPages;
        phPropSheetPages += DevPages;
    }

    return SvrPages + DevPages;
}


INT
FaxConfigGetWorkstationPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    )

{
    DWORD DevPages = 0;
    DWORD WksPages = 0;


    //
    // We can only display workstation pages for workstation configuration type
    //

    if (!ValidConfigData(gConfigData) || gConfigData->configType != FAXCONFIG_WORKSTATION) {

        SetLastError(ERROR_INVALID_FUNCTION);
        return -1;
    }

    if (! DoConnectFaxService())
        return -1;

    WksPages = FaxConfigGetPageHandles(
        phPropSheetPages,
        count,
        WorkstationConfigPageInfo,
        MAX_WORKSTATION_PAGES
        );
    if (WksPages) {
        count -= WksPages;
        phPropSheetPages += WksPages;
    }

    DevPages = GetDeviceProviderPages( phPropSheetPages, count );
    if (DevPages) {
        count -= DevPages;
        phPropSheetPages += DevPages;
    }

    return WksPages + DevPages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\coverpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.c

Abstract:

    Functions for working with cover pages

Environment:

        Windows NT fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>

#define FAXUTIL_DEBUG
#define FAXUTIL_MEM
#define FAXUTIL_REG
#define FAXUTIL_ADAPTIVE
#include "faxutil.h"


//
// Find the filename portion given a filename:
//  return a pointer to the '.' character if successful
//  NULL if there is no extension
//

#define FindFilenameExtension(pFilename) _tcsrchr(pFilename, TEXT(FILENAME_EXT))



VOID
AddCoverPagesToList(
    PCPDATA     pCPInfo,
    HWND        hwndList,
    INT         dirIndex
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a list

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to a list window
    dirIndex - Cover page directory index

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           filename[MAX_PATH];
    HANDLE          hFindFile;
    LPTSTR          pDirPath, pFilename, pExtension;
    INT             listIndex, dirLen, fileLen, flags;

    //
    // Copy the directory path to a local buffer
    //

    flags = dirIndex;
    pDirPath = pCPInfo->pDirPath[dirIndex];

    if (IsEmptyString(pDirPath))
        return;

    if ((dirLen = _tcslen(pDirPath)) >= MAX_PATH - MAX_FILENAME_EXT - 1) {

        Error(("Directory name too long: %ws\n", pDirPath));
        return;
    }

    _tcscpy(filename, pDirPath);

    //
    // Go through the following loop twice:
    //  Once to add the files with .ncp extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //

    do {

        //
        // Generate a specification for the files we're interested in
        //

        pFilename = &filename[dirLen];
        *pFilename = TEXT('*');
        _tcscpy(pFilename+1, (flags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT);

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile(filename, &findData);

        if (hFindFile != INVALID_HANDLE_VALUE) {

            do {

                //
                // Exclude directories and hidden files
                //

                if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY))
                    continue;

                //
                // Make sure we have enough room to store the full pathname
                //

                if ((fileLen = _tcslen(findData.cFileName)) <= MAX_FILENAME_EXT)
                    continue;

                if (fileLen + dirLen >= MAX_PATH) {

                    Error(("Filename too long: %ws%ws\n", pDirPath, findData.cFileName));
                    continue;
                }

                //
                // If we're chasing links, make sure the link refers to
                // a cover page file.
                //

                if (flags & CPFLAG_LINK) {

                    _tcscpy(pFilename, findData.cFileName);

                    if (! IsCoverPageShortcut(filename))
                        continue;
                }

                //
                // Don't display the filename extension
                //

                if (pExtension = FindFilenameExtension(findData.cFileName))
                    *pExtension = NUL;

                //
                // Add the cover page name to the list window
                //

                listIndex = SendMessage(hwndList,
                                        LB_ADDSTRING,
                                        0,
                                        (LPARAM) findData.cFileName);

                if (listIndex != LB_ERR)
                    SendMessage(hwndList, LB_SETITEMDATA, listIndex, flags);

            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;

    } while ((flags & CPFLAG_LINK) && ! pCPInfo->serverCP);
}



VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hDlg
    )

/*++

Routine Description:

    Generate a list of available cover pages

Arguments:

    pCPInfo - Points to cover page information
    hDlg - Handle to the dialog window containing cover page list

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    INT     index, lastSel;

    if ((hwndList = GetDlgItem(hDlg, IDC_COVERPG_LIST)) && pCPInfo) {

        //
        // Disable redraw on the list and reset its content
        //

        if ((lastSel = SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
            lastSel = 0;

        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
        SendMessage(hwndList, LB_RESETCONTENT, 0, 0);

        //
        // Add cover pages to the list
        //

        for (index=0; index < pCPInfo->nDirs; index++)
            AddCoverPagesToList(pCPInfo, hwndList, index);

        //
        // Highlight the first cover page in the list
        //

        if ((index = SendMessage(hwndList, LB_GETCOUNT, 0, 0)) > 0 && lastSel >= index)
            lastSel = index - 1;

        SendMessage(hwndList, LB_SETCURSEL, lastSel, 0);

        //
        // Enable redraw on the list window
        //

        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    } else if (hwndList) {

        SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
    }

    UpdateCoverPageControls(hDlg);
}



INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pBuffer
    )

/*++

Routine Description:

    Retrieve the currently selected cover page filename

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    pBuffer - Points to a buffer for storing the selected cover page filename
        The size of the buffer is assumed to be MAX_PATH characters.
        if pBuffer is NULL, we assume the called is interested in the item flags

Return Value:

    Flags associated with the currently selected item
    Negative if there is an error

--*/

{
    LPTSTR      pDirPath;
    INT         selIndex, itemFlags;

    //
    // Default to empty string in case of an error
    //

    if (pBuffer)
        pBuffer[0] = NUL;

    if (pCPInfo == NULL || hwndList == NULL)
        return LB_ERR;

    //
    // Get currently selected item index
    //

    if ((selIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
        return selIndex;

    //
    // Get the flags associated with the currently selected item
    //

    itemFlags = SendMessage(hwndList, LB_GETITEMDATA, selIndex, 0);

    if (itemFlags == LB_ERR || !pBuffer)
        return itemFlags;

    Assert((itemFlags & CPFLAG_DIRINDEX) < pCPInfo->nDirs);
    pDirPath = pCPInfo->pDirPath[itemFlags & CPFLAG_DIRINDEX];

    //
    // Assemble the full pathname for the cover page file
    //  directory prefix
    //  display name
    //  filename extension
    //

    while (*pBuffer++ = *pDirPath++)
        NULL;

    pBuffer--;

    SendMessage(hwndList, LB_GETTEXT, selIndex, (LPARAM) pBuffer);
    _tcscat(pBuffer, (itemFlags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT);

    return itemFlags;
}



BOOL
GetServerCoverPageDirs(
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Find the directories in which the server cover pages are stored

Arguments:

    hPrinter - Handle to a printer object
    pCPInfo - Points to cover page information

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    BOOL            status = FALSE;
    DWORD           cbNeeded;
    LPTSTR          pServerDir;


    //
    // Find the driver directory on the printer server
    //

    cbNeeded = (_tcslen(gConfigData->pServerName) + _tcslen(SERVER_CP_DIRECTORY) + 16) * sizeof(TCHAR);

    if (pServerDir = MemAllocZ(cbNeeded)) {

        _tcscpy( pServerDir, gConfigData->pServerName );
        _tcscat( pServerDir, SERVER_CP_DIRECTORY );

        Assert(pCPInfo->nDirs == 0);
        pCPInfo->nDirs = 1;
        pCPInfo->pDirPath[0] = pServerDir;
        status = TRUE;

    }

    //
    // Clean up before returning to caller
    //

    if (! status) {
        MemFree(pServerDir);
    }

    return status;
}



VOID
AppendPathSeparator(
    LPTSTR  pDirPath
    )

/*++

Routine Description:

    Append a path separator (if necessary) at the end of a directory name

Arguments:

    pDirPath - Points to a directory name

Return Value:

    NONE

--*/

{
    INT length;


    //
    // Calculate the length of directory string
    //

    length = _tcslen(pDirPath);

    if (length >= MAX_PATH-1 || length < 1)
        return;

    //
    // If the last character is not a path separator,
    // append a path separator at the end
    //

    if (pDirPath[length-1] != TEXT(PATH_SEPARATOR)) {

        pDirPath[length] = TEXT(PATH_SEPARATOR);
        pDirPath[length+1] = NUL;
    }
}



PCPDATA
AllocCoverPageInfo(
    BOOL serverCP
    )

/*++

Routine Description:

    Allocate memory to hold cover page information

Arguments:

    serverCP - Is the caller interested in server or user cover pages
    hPrinter - Handle to a printer object if serverCP is TRUE

Return Value:

    Pointer to a CPDATA structure, NULL if there is an error

NOTE:

    Put this inside a critical section is the caller is concerned about
    being thread safe.

--*/

{
    PCPDATA pCPInfo;
    INT     nDirs;
    LPTSTR  pDirPath, pUserCPDir, pSavedPtr;


    if (pCPInfo = MemAllocZ(sizeof(CPDATA))) {

        if (pCPInfo->serverCP = serverCP) {

            //
            // Find the directory in which the server cover pages are stored
            //

            if (! GetServerCoverPageDirs(pCPInfo))
                Error(("Couldn't get server cover page directories\n"));

        } else if (pUserCPDir = pSavedPtr = GetUserCoverPageDir()) {

            //
            // Find the directory in which the user cover pages are stored
            //

            while (*pUserCPDir && pCPInfo->nDirs < MAX_COVERPAGE_DIRS) {

                LPTSTR  pNextDir = pUserCPDir;

                //
                // Find the next semicolon character
                //

                while (*pNextDir && *pNextDir != TEXT(';'))
                    pNextDir++;

                if (*pNextDir != NUL)
                    *pNextDir++ = NUL;

                //
                // Make sure the directory name is not too long
                //

                if (_tcslen(pUserCPDir) < MAX_PATH) {

                    if (! (pDirPath = AllocStringZ(MAX_PATH)))
                        break;

                    pCPInfo->pDirPath[pCPInfo->nDirs++] = pDirPath;
                    _tcscpy(pDirPath, pUserCPDir);
                }

                pUserCPDir = pNextDir;
            }

            MemFree(pSavedPtr);
        }

        //
        // Append path separators at the end if necessary
        //

        for (nDirs=0; nDirs < pCPInfo->nDirs; nDirs++) {

            AppendPathSeparator(pCPInfo->pDirPath[nDirs]);
            Verbose(("Cover page directory: %ws\n", pCPInfo->pDirPath[nDirs]));
        }
    }

    return pCPInfo;
}



VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Free up memory used for cover page information

Arguments:

    pCPInfo - Points to cover page information to be freed

Return Value:

    NONE

--*/

{
    if (pCPInfo) {

        INT index;

        for (index=0; index < pCPInfo->nDirs; index++)
            MemFree(pCPInfo->pDirPath[index]);

        MemFree(pCPInfo);
    }
}



LPTSTR
MakeQuotedParameterString(
    LPTSTR  pInputStr
    )

/*++

Routine Description:

    Make a copy of the input string and make sure it's in the same form
    as expected by SHELLEXECUTEINFO.lpParameters.

Arguments:

    pInputStr - Specifies the input string

Return Value:

    Pointer to the processed parameter string

--*/

#define QUOTE   TEXT('"')

{
    LPTSTR  pStr, pDestStr;
    INT     length;

    //
    // Special case: if the input string is NULL, simply return NULL
    //

    if (pInputStr == NULL)
        return NULL;

    //
    // Figure out how long the resulting string is.
    // Initial value is 3 = two extra quotes plus NUL terminator.
    //

    for (pStr=pInputStr, length=3; *pStr; pStr++)
        length += (*pStr == QUOTE) ? 3 : 1;

    //
    // Copy the input string and replace quote characters
    //

    if (pStr = pDestStr = MemAlloc(length * sizeof(TCHAR))) {

        *pStr++ = QUOTE;

        while (*pInputStr) {

            if ((*pStr++ = *pInputStr++) == QUOTE) {

                *pStr++ = QUOTE;
                *pStr++ = QUOTE;
            }
        }

        *pStr++ = QUOTE;
        *pStr = NUL;
    }

    return pDestStr;
}



VOID
HandleOpenCoverPage(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelected,
    INT     action
    )

/*++

Routine Description:

    Edit the currently selected cover page file or
    create a new cover page file

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    pSelected - Currently selected cover page filename
    action - Open an existing cover page file or create a new one

Return Value:

    NONE

--*/

{
    TCHAR       filename[MAX_PATH];
    LPTSTR      pExecutableName, pDirPath, pFilename;

    SHELLEXECUTEINFO shellExeInfo = {

        sizeof(SHELLEXECUTEINFO),
        SEE_MASK_NOCLOSEPROCESS,
        hDlg,
        NULL,
        NULL,
        NULL,
        NULL,
        SW_SHOWNORMAL,
    };

    //
    // Determine the default directory to run the cover page editor in:
    //

    if (action == CPACTION_NEW) {

        //
        // When creating a new cover page, the default directory is either
        // the server cover page directory or the user cover page directory
        // depending on whether the user is doing server adminstration.
        //

        pDirPath = pCPInfo->pDirPath[0];
        pFilename = NULL;

    } else {

        INT flags;

        //
        // If the currently selected file is a link, resolve it first
        //

        _tcscpy(filename, pSelected);

        if (!IsEmptyString(pSelected) &&
            (flags = GetSelectedCoverPage(pCPInfo, hwndList, NULL)) > 0 &&
            (flags & CPFLAG_LINK) &&
            !ResolveShortcut(pSelected, filename))
        {
            DisplayMessageDialog(hDlg, 0, 0, IDS_RESOLVE_LINK_FAILED, pSelected);
            return;
        }

        //
        // Separate the filename into directory and filename components
        //

        if (pFilename = _tcsrchr(filename, TEXT(PATH_SEPARATOR))) {

            *pFilename++ = NUL;
            pDirPath = filename;

        } else {

            pFilename = filename;
            pDirPath = NULL;
        }
    }

    //
    // Find the "Cover Page Editor" executable
    //

    if ((pExecutableName = GetCoverPageEditor()) == NULL) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_CANNOT_FIND_CPEDITOR);
        return;
    }

    //
    // Start cover page editor and wait for it to exit before proceeding
    //

    shellExeInfo.lpFile = pExecutableName;
    shellExeInfo.lpDirectory = pDirPath;
    shellExeInfo.lpParameters = MakeQuotedParameterString(pFilename);

    Verbose(("Cover page editor: %ws\n", pExecutableName));
    Verbose(("Initial working directory: %ws\n", pDirPath));
    Verbose(("Cover page filename: %ws\n", shellExeInfo.lpParameters));

    if (! ShellExecuteEx(&shellExeInfo)) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_CANNOT_OPEN_CPEDITOR, pExecutableName);
        MemFree(shellExeInfo.lpParameters);
        MemFree(pExecutableName);
        return;
    }

    //
    // Refresh the list of cover page files when we're done
    //

    MemFree(shellExeInfo.lpParameters);
    MemFree(pExecutableName);

    if (WaitForSingleObject(shellExeInfo.hProcess, INFINITE) != WAIT_FAILED)
        InitCoverPageList(pCPInfo, hDlg);
}



VOID
HandleBrowseCoverPage(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelected
    )

/*++

Routine Description:

    Remove the currently selected cover page file

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    pSelected - Currently selected cover page filename

Return Value:

    NONE

--*/

{
    TCHAR   filename[MAX_PATH];
    TCHAR   title[MAX_TITLE_LEN];
    TCHAR   filter[MAX_TITLE_LEN];
    LPTSTR  pExtension, pFilename;
    LPTSTR  pCPDir;
    INT     n;

    OPENFILENAME ofn = {

        sizeof(OPENFILENAME),
        hDlg,
        ghInstance,
        filter,
        NULL,
        0,
        1,
        filename,
        MAX_PATH,
        NULL,
        0,
        NULL,
        title,
        OFN_FILEMUSTEXIST | OFN_NODEREFERENCELINKS | OFN_HIDEREADONLY,
        0,
        0,
        NULL,
        0,
        NULL,
        NULL,
    };

    //
    // Figure out what the initial directory should be
    //

    if (! IsEmptyString(pSelected)) {

        INT flags;

        //
        // Find out if the currently selected cover page file is a
        // user cover page and whether it's a link
        //

        if ((flags = GetSelectedCoverPage(pCPInfo, hwndList, NULL)) > 0 &&
            (flags & CPFLAG_LINK) &&
            ResolveShortcut(pSelected, filename))
        {
            //
            // Set the initial directory to the link destination
            //

            _tcscpy(pSelected, filename);

            if (pFilename = _tcsrchr(pSelected, TEXT(PATH_SEPARATOR))) {

                *pFilename = NUL;
                ofn.lpstrInitialDir = pSelected;
            }
        }
    }

    //
    // Compose the file-type filter string
    //

    LoadString(ghInstance, IDS_CP_FILETYPE, title, MAX_TITLE_LEN);
    wsprintf(filter, TEXT("%s%c*%s%c"), title, NUL, CP_FILENAME_EXT, NUL);

    LoadString(ghInstance, IDS_BROWSE_COVERPAGE, title, MAX_TITLE_LEN);
    filename[0] = NUL;

    //
    // Present the "Open File" dialog
    //

    if (! GetOpenFileName(&ofn))
        return;

    //
    // Make sure the selected filename has the correct extension
    //

    if ((pExtension = FindFilenameExtension(filename)) == NULL ||
         _tcsicmp(pExtension, CP_FILENAME_EXT) != EQUAL_STRING)
    {
        DisplayMessageDialog(hDlg, 0, 0, IDS_BAD_CP_EXTENSION, CP_FILENAME_EXT);
        return;
    }

    //
    // Check if the selected file is already inside one of the
    // cover page directories
    //

    for (n=0; n < pCPInfo->nDirs; n++) {

        if (_tcsnicmp(filename, pCPInfo->pDirPath[n], ofn.nFileOffset) == EQUAL_STRING) {

            DisplayMessageDialog(hDlg, 0, 0, IDS_CP_DUPLICATE, filename);
            return;
        }
    }

    //
    // Add the selected cover page file to the first cover page directory
    // Create the cover page directory if necessary
    //

    pCPDir = pCPInfo->pDirPath[0];

    if (!pCPDir || IsEmptyString(pCPDir)) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_NO_COVERPG_DIR);
        return;
    }

    CreateDirectory(pCPDir, NULL);

    pFilename = &filename[ofn.nFileOffset];
    _tcscpy(pSelected, pCPDir);
    n = _tcslen(pSelected);

    if (n + _tcslen(pFilename) >= MAX_PATH - MAX_FILENAME_EXT || pFilename >= pExtension) {

        DisplayMessageDialog(hDlg, 0, 0, IDS_FILENAME_TOOLONG);
        return;
    }

    _tcsncpy(pSelected + n, pFilename, pExtension - pFilename);
    n += pExtension - pFilename;

    if (pCPInfo->serverCP) {

        //
        // Copy the physical file for server cover pages
        //

        _tcscpy(pSelected + n, CP_FILENAME_EXT);

        if (! CopyFile(filename, pSelected, FALSE)) {

            DisplayMessageDialog(hDlg, 0, 0, IDS_COPY_FILE_FAILED, filename, pSelected);
            return;
        }

    } else {

        //
        // Create the shortcut file for user cover page
        //

        _tcscpy(pSelected + n, LNK_FILENAME_EXT);

        if (! CreateShortcut(pSelected, filename)) {

            DisplayMessageDialog(hDlg, 0, 0, IDS_CREATE_LINK_FAILED, pSelected, filename);
            return;
        }
    }

    //
    // Refresh the cover page list - we're being lazy here in that
    // we reset the entire list content
    //

    InitCoverPageList(pCPInfo, hDlg);
}



VOID
HandleRemoveCoverPage(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pFilename
    )

/*++

Routine Description:

    Remove the currently selected cover page file

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    pFilename - Currently selected cover page filename

Return Value:

    NONE

--*/

{
    //
    // Display the confirmation dialog before proceeding
    //

    if (DisplayMessageDialog(hDlg,
                             MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2,
                             IDS_CONFIRM_DELETE,
                             IDS_DELETE_PROMPT,
                             pFilename) == IDYES)
    {
        if (DeleteFile(pFilename)) {

            //
            // Update the list box if the file is successfully removed
            //

            INT selIndex, count;

            if ((selIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0)) != LB_ERR) {

                SendMessage(hwndList, LB_DELETESTRING, selIndex, 0);

                if ((count = SendMessage(hwndList, LB_GETCOUNT, 0, 0)) > 0) {

                    count --;
                    SendMessage(hwndList, LB_SETCURSEL, min(selIndex, count), 0);
                }
            }

            UpdateCoverPageControls(hDlg);

        } else
            DisplayMessageDialog(hDlg, 0, 0, IDS_DELETE_FAILED, pFilename);
    }
}



VOID
ManageCoverPageList(
    HWND    hDlg,
    PCPDATA pCPInfo,
    HWND    hwndList,
    INT     action
    )

/*++

Routine Description:

    Perform various action to manage the list of cover pages

Arguments:

    hDlg - Handle to the dialog window on which the list of cover pages is displayed
    pCPInfo - Points to cover page information
    hwndList - Handle to cover page listbox window
    action - What action to perform on the cover page list

Return Value:

    NONE

--*/

{
    TCHAR   filename[MAX_PATH];

    //
    // Get the name of currently selected cover page file
    //

    if (pCPInfo == NULL || hwndList == NULL)
        return;

    GetSelectedCoverPage(pCPInfo, hwndList, filename);

    //
    // Call appropriate function depends on the action parameter
    //

    switch (action) {

    case CPACTION_OPEN:

        if (IsEmptyString(filename))
            break;

    case CPACTION_NEW:

        HandleOpenCoverPage(hDlg, pCPInfo, hwndList, filename, action);
        break;

    case CPACTION_BROWSE:

        HandleBrowseCoverPage(hDlg, pCPInfo, hwndList, filename);
        break;

    case CPACTION_REMOVE:

        if (! IsEmptyString(filename))
            HandleRemoveCoverPage(hDlg, pCPInfo, hwndList, filename);
        break;
    }
}



VOID
UpdateCoverPageControls(
    HWND    hDlg
    )

/*++

Routine Description:

    Enable/disable buttons for manage cover page files

Arguments:

    hDlg - Handle to the property page containing the cover page controls

Return Value:

    NONE

--*/

{
    HWND    hwndOpen, hwndRemove;

    //
    // If all buttons are disabled, leave them alone here
    //

    if (! IsWindowEnabled(GetDlgItem(hDlg, IDC_COVERPG_NEW)))
        return;

    hwndOpen = GetDlgItem(hDlg, IDC_COVERPG_OPEN);
    hwndRemove = GetDlgItem(hDlg, IDC_COVERPG_REMOVE);

    if (SendDlgItemMessage(hDlg, IDC_COVERPG_LIST, LB_GETCURSEL, 0, 0) != LB_ERR) {

        EnableWindow(hwndOpen, TRUE);
        EnableWindow(hwndRemove, TRUE);

    } else {

        if (GetFocus() == hwndOpen || GetFocus() == hwndRemove)
            SetFocus(GetDlgItem(hDlg, IDC_COVERPG_NEW));

        EnableWindow(hwndOpen, FALSE);
        EnableWindow(hwndRemove, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\devstat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devstat.c

Abstract:

    Functions for handling events in the "Device Status" tab of
    the fax server configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"


//
// Information about the fax device list view on "Send Options" page
//

static COLUMNINFO faxDeviceListViewColumnInfo[] = {

    { COLUMN_DEVICE_NAME, 2 },
    { COLUMN_STATUS, 1 },
    { 0, 0 },
};



VOID
DoActivateDeviceStatus(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the "Device Status" property page is activated

Arguments:

    hDlg - Window handle to the "Device Status" property page

Return Value:

    NONE

--*/

{
    HWND    hwndLV;

    //
    // Reinitialize the fax device list view if necessary
    //

    if (!IsFaxDeviceListInSync(DEVICE_STATUS_PAGE) &&
        (hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)))
    {
        InitFaxDeviceListView(hwndLV, 0, faxDeviceListViewColumnInfo);
    }

    SetFaxDeviceListInSync(DEVICE_STATUS_PAGE);
}



VOID
DoRefreshDevStatus(
    HWND    hDlg
    )

/*++

Routine Description:

    Refresh the fax device list on "Device Status" property page

Arguments:

    hDlg - Window handle to the "Device Status" property page

Return Value:

    NONE

--*/

{
    PFAX_PORT_INFO   pFaxPortInfo, pSaved;
    DWORD            cPorts;
    INT              index;

    //
    // Talk with the fax service to get the current status of each device
    //

    if (gConfigData->hFaxSvc &&
        (pSaved = pFaxPortInfo = FaxSvcEnumPorts(gConfigData->hFaxSvc, &cPorts)))
    {
        for (index=0; index < gConfigData->cDevices; index++)
            gConfigData->pDevInfo[index].State = FPS_UNAVAILABLE;

        for ( ; cPorts--; pFaxPortInfo++) {

            for (index=0; index < gConfigData->cDevices; index++) {

                if (gConfigData->pDevInfo[index].DeviceId == pFaxPortInfo->DeviceId) {

                    gConfigData->pDevInfo[index].State = pFaxPortInfo->State;
                    break;
                }
            }
        }

        //
        // Redisplay the fax device status
        //

        FaxFreeBuffer(pSaved);
        UpdateFaxDeviceListViewColumns(GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST),
                                       faxDeviceListViewColumnInfo,
                                       1);
    }
}



VOID
SetTimeField(
    HWND        hwnd,
    PFILETIME   pFileTime
    )

/*++

Routine Description:

    Display the specified time value in a text field

Arguments:

    hwnd - Window handle to the text field
    pFileTime - Time value to be displayed

Return Value:

    NONE

--*/

{
    SYSTEMTIME  systemTime;
    TCHAR       timeString[64];

    if (! FileTimeToSystemTime(pFileTime, &systemTime) ||
        ! GetTimeFormat(LOCALE_USER_DEFAULT, 0, &systemTime, NULL, timeString, 64))
    {
        Error(("Bad time value: error = %d\n", GetLastError()));
        timeString[0] = NUL;
    }

    SetWindowText(hwnd, timeString);
}



BOOL CALLBACK
SendStatusProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for displaying send device status dialog

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    Depends on message

--*/

#define SetStatusTextField(hDlg, idc, p) \
        SetDlgItemText(hDlg, idc, (p) ? (p) : TEXT(""))

{
    PFAX_DEVICE_STATUS  pDevStatus;

    switch (uMsg) {

    case WM_INITDIALOG:

        pDevStatus = (PFAX_DEVICE_STATUS) lParam;

        if (pDevStatus == NULL || pDevStatus->SizeOfStruct != sizeof(FAX_DEVICE_STATUS)) {

            Error(("Corrupted FAX_DEVICE_STATUS structure\n"));
            return TRUE;
        }

        SetStatusTextField(hDlg, IDC_DEVSTAT_DEVICE, pDevStatus->DeviceName);
        SetStatusTextField(hDlg, IDC_DEVSTAT_SENDER, pDevStatus->SenderName);
        SetStatusTextField(hDlg, IDC_DEVSTAT_DOCUMENT, pDevStatus->DocumentName);
        SetStatusTextField(hDlg, IDC_DEVSTAT_TO, pDevStatus->RecipientName);
        SetStatusTextField(hDlg, IDC_DEVSTAT_FAXNUMBER, pDevStatus->PhoneNumber);

        SetDlgItemInt(hDlg, IDC_DEVSTAT_TOTAL_BYTES, pDevStatus->Size, FALSE);
        SetDlgItemInt(hDlg, IDC_DEVSTAT_CURRENT_PAGE, pDevStatus->CurrentPage, FALSE);
        SetDlgItemInt(hDlg, IDC_DEVSTAT_TOTAL_PAGES, pDevStatus->TotalPages, FALSE);

        //
        // Start time and submitted time
        //

        SetTimeField(GetDlgItem(hDlg, IDC_DEVSTAT_STARTEDAT),
                     &pDevStatus->StartTime);

        SetTimeField(GetDlgItem(hDlg, IDC_DEVSTAT_SUBMITTEDAT),
                     &pDevStatus->SubmittedTime);

        //
        // Status string
        //

        if (pDevStatus->Status == 0) {

            SetStatusTextField(hDlg, IDC_DEVSTAT_STATUS, pDevStatus->StatusString);

        } else {

            LPTSTR pStatusString;

            pStatusString = MakeDeviceStatusString(pDevStatus->Status);
            SetStatusTextField(hDlg, IDC_DEVSTAT_STATUS, pStatusString);
            MemFree(pStatusString);
        }

        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }
        break;
    }

    return FALSE;
}



BOOL CALLBACK
ReceiveStatusProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for displaying receive device status dialog

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    Depends on message

--*/

{
    PFAX_DEVICE_STATUS  pDevStatus;

    switch (uMsg) {

    case WM_INITDIALOG:

        pDevStatus = (PFAX_DEVICE_STATUS) lParam;

        if (pDevStatus == NULL || pDevStatus->SizeOfStruct != sizeof(FAX_DEVICE_STATUS)) {

            Error(("Corrupted FAX_DEVICE_STATUS structure\n"));
            return TRUE;
        }

        SetStatusTextField(hDlg, IDC_DEVSTAT_DEVICE, pDevStatus->DeviceName);
        SetStatusTextField(hDlg, IDC_DEVSTAT_SENDER, pDevStatus->Tsid);
        SetStatusTextField(hDlg, IDC_DEVSTAT_TO, pDevStatus->Csid);

        //
        // Start time
        //

        SetTimeField(GetDlgItem(hDlg, IDC_DEVSTAT_STARTEDAT),
                     &pDevStatus->StartTime);

        //
        // Status string
        //

        if (pDevStatus->Status == 0) {

            SetStatusTextField(hDlg, IDC_DEVSTAT_STATUS, pDevStatus->StatusString);

        } else {

            LPTSTR pStatusString;

            pStatusString = MakeDeviceStatusString(pDevStatus->Status);
            SetStatusTextField(hDlg, IDC_DEVSTAT_STATUS, pStatusString);
            MemFree(pStatusString);
        }

        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }
        break;
    }

    return FALSE;
}



VOID
DoShowStatusDetails(
    HWND    hDlg
    )

/*++

Routine Description:

    Display detailed status of the currently selected fax device

Arguments:

    hDlg - Window handle to the "Device Status" property page

Return Value:

    NONE

--*/

{
    HWND                hwndLV;
    INT                 index;
    PFAX_DEVICE_STATUS  pDevStatus = NULL;

    //
    // Get the index of the currently selected item and
    // count the total number of items in the list view
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)) == NULL ||
        (index = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) < 0 ||
        (index >= gConfigData->cDevices))
    {
        return;
    }

    //
    // Call the fax service to get the status of the specified device
    //

    pDevStatus = FaxSvcGetDeviceStatus(gConfigData->hFaxSvc, gConfigData->pDevInfo[index].DeviceId);

    if (pDevStatus == NULL) {

        DisplayMessageDialog(hDlg,
                             0,
                             0,
                             IDS_DEVICE_STATUS_ERROR,
                             gConfigData->pDevInfo[index].DeviceName);

        FaxFreeBuffer(pDevStatus);
        return;
    }

    //
    // Display appropriate status dialog depending on the current job type
    //

    switch (pDevStatus->JobType) {

    case JT_SEND:

        DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_SEND_STATUS),
                       hDlg,
                       SendStatusProc,
                       (LPARAM) pDevStatus);
        break;

    case JT_RECEIVE:

        DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_RECEIVE_STATUS),
                       hDlg,
                       ReceiveStatusProc,
                       (LPARAM) pDevStatus);
        break;

    default:

        if (pDevStatus->JobType != 0)
            Error(("Unknown job type: %d\n", pDevStatus->JobType));

        DisplayMessageDialog(hDlg,
                             MB_OK | MB_ICONINFORMATION,
                             IDS_DEVICE_STATUS,
                             IDS_DEVICE_STATUS_IDLE,
                             gConfigData->pDevInfo[index].DeviceName);

        break;
    }

    FaxFreeBuffer(pDevStatus);
}



VOID
HandleDevStatusListViewMessage(
    HWND    hDlg,
    LPNMHDR pNMHdr
    )

/*++

Routine Description:

    Handle notification events from the fax device list

Arguments:

    hDlg - Window handle to the "Device Status" property page
    pNMHdr - Points to an NMHDR structure

Return Value:

    NONE

--*/

{
    HWND    hwndLV = pNMHdr->hwndFrom;

    switch (pNMHdr->code) {

    case LVN_KEYDOWN:

        if (((LV_KEYDOWN *) pNMHdr)->wVKey != VK_RETURN)
            break;

    case NM_DBLCLK:

        DoShowStatusDetails(hDlg);
        break;
    }
}



BOOL
DeviceStatusProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Device Status" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    LPNMHDR pNMHdr;

    switch (message) {

    case WM_INITDIALOG:

        GetFaxDeviceAndConfigInfo();
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_REFRESH:

            DoRefreshDevStatus(hDlg);
            return TRUE;

        case IDC_DETAILS:

            DoShowStatusDetails(hDlg);
            break;
        }
        break;

    case WM_NOTIFY:

        pNMHdr = (NMHDR *) lParam;

        if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)) {

            HandleDevStatusListViewMessage(hDlg, pNMHdr);

        } else switch (pNMHdr->code) {

        case PSN_SETACTIVE:

            DoActivateDeviceStatus(hDlg);
            break;

        case PSN_APPLY:

            return PSNRET_NOERROR;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, DEVICE_STATUS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\faxcpl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcpl.h

Abstract:

    Header file for fax configuration DLL

Environment:

        Windows NT fax configuration DLL

Revision History:

        02/27/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXCPL_H_
#define _FAXCPL_H_

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include "winfax.h"
#include "winfaxp.h"

#include "faxlib.h"
#include "faxcfg.h"

#include "registry.h"
#include "timectrl.h"
#include "resource.h"
#include "coverpg.h"
#include "util.h"
#include "tapiutil.h"


//
// window mgmt
//

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)

//
// Number of pages in fax client and/or server configuration property sheets
//

#define CLIENT_OPTIONS_PAGE     0
#define CLIENT_COVERPG_PAGE     1
#define USER_INFO_PAGE          2
#define NUM_CLIENT_PAGES        3

#define SERVER_OPTIONS_PAGE     3
#define SERVER_COVERPG_PAGE     4
#define SEND_OPTIONS_PAGE       5
#define RECEIVE_OPTIONS_PAGE    6
#define DEVICE_PRIORITY_PAGE    7
#define DEVICE_STATUS_PAGE      8
#define DIAG_LOG_PAGE           9
#define GENERAL_PAGE           10
#define STATUS_OPTIONS_PAGE    11
#define NUM_SERVER_PAGES        8

#define MAX_PAGES              12
#define NUM_WORKSTATION_PAGES   8  // No "Server Cover Page" and "Priority" tab

//
// Pages which display a printer list:
//  fax options
//  server options
//  send options
//

#define PRINTERPAGE_MASK    ((1 << CLIENT_OPTIONS_PAGE) | \
                             (1 << SERVER_COVERPG_PAGE) | \
                             (1 << SEND_OPTIONS_PAGE))

//
// Pages related to fax device configuration:
//  server options
//  send options
//  receive options
//  device priority
//  diagnostics logging
//

#define CONFIGPAGE_MASK     ((1 << SERVER_OPTIONS_PAGE)  | \
                             (1 << SEND_OPTIONS_PAGE)    | \
                             (1 << RECEIVE_OPTIONS_PAGE) | \
                             (1 << DEVICE_PRIORITY_PAGE) | \
                             (1 << GENERAL_PAGE)         | \
                             (1 << DIAG_LOG_PAGE)        | \
                             (1 << STATUS_OPTIONS_PAGE))

//
// Data structure representing information about a fax printer
//

typedef struct _FAXPRINTERINFO {

    LPTSTR      pPrinterName;
    BOOL        isLocal;

} FAXPRINTERINFO, *PFAXPRINTERINFO;

//
// Data structure representing information about a form supported by fax driver
//

typedef struct _FAXFORMINFO {

    LPTSTR      pFormName;
    INT         paperSizeIndex;

} FAXFORMINFO, *PFAXFORMINFO;

//
// Auxiliary information about TAPI locations
//

typedef PDWORD  PBITARRAY;

#define BITARRAYALLOC(n)    MemAllocZ((((n) + 31) / 32) * 4)
#define BITARRAYFREE(p)     MemFree(p)
#define BITARRAYSET(p, n)   (p)[(n) / 32] |= (1 << ((n) & 31))
#define BITARRAYCLEAR(p, n) (p)[(n) / 32] &= ~(1 << ((n) & 31))
#define BITARRAYCHECK(p, n) ((p)[(n) / 32] & (1 << ((n) & 31)))

typedef struct _AUX_LOCATION_INFO {

    PBITARRAY   pFlags;
    LPTSTR      pPrefixes;

} AUX_LOCATION_INFO, *PAUX_LOCATION_INFO;

#define MIN_PREFIX          200
#define MAX_PREFIX          999

#define MAX_PREFIX_LEN      32

#define PREFIX_SEPARATOR    TEXT(',')

//
// private port info struct
//

typedef struct _CONFIG_PORT_INFO_2 {
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   //
    DWORD               State;                      //
    DWORD               Flags;                      //
    DWORD               Rings;
    DWORD               Priority;                   //
    LPWSTR              DeviceName;                 //
    LPWSTR              TSID;                       //
    DWORD               Mask;                       // ROUTING: how to route an inbound fax
    LPWSTR              PrinterName;                //  |       printer name, NULL = default printer
    LPWSTR              DirStore;                   //  |       dir to store fax into
    LPWSTR              ProfileName;                //  |       profile name for inbox storage
    LPWSTR              CSID;                       //  |---->  receiving station's identifier
} CONFIG_PORT_INFO_2, *PCONFIG_PORT_INFO_2;

//
// Fax configuration data structure
//

typedef struct _CONFIGDATA {

    PVOID           startSign;          // signature

    INT             configType;         // type of configuration
    HANDLE          hFaxSvc;            // handle to fax service
    INT             changeFlag;         // whether any dialog contents were changed
    INT             faxDeviceSyncFlag;  // whether fax device list view is in sync
    LPTSTR          pServerName;        // currently selected fax server name
    PCPDATA         pCPInfo;            // cover page information
    BOOL            priorityChanged;    // device priority was changed

    //
    // Devmode associated with the currently selected printer
    //

    DRVDEVMODE      devmode;

    INT             cForms;
    PFAXFORMINFO    pFormInfo;

    //
    // Information about available fax devices
    //

    INT                 cDevices;
    PCONFIG_PORT_INFO_2 pDevInfo;

    //
    // Fax configuration information
    //

    PFAX_CONFIGURATION  pFaxConfig;
    PFAX_LOG_CATEGORY   pFaxLogging;
    DWORD               NumberCategories;

    PVOID           endSign;

    LPTSTR          pMapiProfiles;

} CONFIGDATA, *PCONFIGDATA;

//
// Validate fax configuration data structure
//

#define ValidConfigData(pData) \
        ((pData) && (pData) == (pData)->startSign && (pData) == (pData)->endSign)

//
// Determine whether the current page was modified at all
//

#define GetChangedFlag(pageIndex) (gConfigData->changeFlag & (1 << (pageIndex)))

//
// Determine whether the fax device list on the current page is in sync
//

#define IsFaxDeviceListInSync(pageIndex) (gConfigData->faxDeviceSyncFlag & (1 << (pageIndex)))

//
// Indicate the fax device list on the current page is now in sync
//

#define SetFaxDeviceListInSync(pageIndex) gConfigData->faxDeviceSyncFlag |= (1 << (pageIndex))

//
// Return the name of currently selected printer
//

#define GetPrinterSelName() \
        ((gConfigData->printerSel < gConfigData->cPrinters) ? \
            gConfigData->pPrinterInfo[gConfigData->printerSel].pPrinterName : NULL)

//
// Determine whether the currently selected printer is installed locally
//

#define IsPrinterSelLocal() \
        ((gConfigData->printerSel < gConfigData->cPrinters) && \
         gConfigData->pPrinterInfo[gConfigData->printerSel].isLocal)

//
// Allocate memory for fax configuration data structure
//

BOOL
AllocConfigData(
    VOID
    );

//
// Dispose of fax configuration data structure
//

VOID
FreeConfigData(
    VOID
    );

//
// Global variable declarations
//

extern HANDLE       ghInstance;      // DLL instance handle
extern PCONFIGDATA  gConfigData;     // fax configuration data structure

//
// Dialog procedure for handling fax configuration property sheet tabs
//

BOOL FaxOptionsProc(HWND, UINT, UINT, LONG);
BOOL ClientCoverPageProc(HWND, UINT, UINT, LONG);
BOOL UserInfoProc(HWND, UINT, UINT, LONG);

BOOL ServerOptionsProc(HWND, UINT, UINT, LONG);
BOOL ServerCoverPageProc(HWND, UINT, UINT, LONG);
BOOL SendOptionsProc(HWND, UINT, UINT, LONG);
BOOL ReceiveOptionsProc(HWND, UINT, UINT, LONG);
BOOL DevicePriorityProc(HWND, UINT, UINT, LONG);
BOOL DeviceStatusProc(HWND, UINT, UINT, LONG);
BOOL DiagLogProc(HWND, UINT, UINT, LONG);
BOOL GeneralProc(HWND, UINT, UINT, LONG);
BOOL StatusOptionsProc(HWND, UINT, UINT, LONG);

//
// Maximum allowable length for outgoing archiving and inbound routing directory
//

#define MAX_ARCHIVE_DIR (MAX_PATH - 16)

#endif  // !_FAXCPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\faxopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxopts.c

Abstract:

    Functions for handling events in the "Fax Options" tab of
    the fax client configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"



VOID
DoActivateFaxOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the "Fax Options" page is activated

Arguments:

    hDlg - Window handle to the "Fax Options" page

Return Value:

    NONE

--*/

{
    //
    // Controls on the "Fax Options" page which may be enabled or disabled
    //

    static INT  faxOptionsCtrls[] = {

        IDC_BILLING_CODE,
        IDC_EMAIL,
        0,
    };


    SetChangedFlag(hDlg, CLIENT_OPTIONS_PAGE, FALSE);

    //
    // Disable dialog controls if there is no printer is selected
    //

    Verbose(("Updating 'Fax Options' page ...\n"));

    //
    // Enable dialog controls
    //

    EnableControls(hDlg, faxOptionsCtrls, TRUE);

    //
    // Billing code
    //

    MySetDlgItemText(hDlg, IDC_BILLING_CODE, pdmPrivate->billingCode);

    //
    // Email Address
    //

    MySetDlgItemText(hDlg, IDC_EMAIL, pdmPrivate->emailAddress);
}



VOID
DoSaveFaxOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Fax Options" property sheet page

Arguments:

    hDlg - Handle to the Fax Options property sheet page

Return Value:

    NONE

--*/

{
    PDEVMODE    pdmPublic;
    PDMPRIVATE  pdmPrivate;
    HWND        hwndList;
    INT         listIdx;
    LPTSTR      pPrinterSelName;

    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Fax Options' page ...\n"));

    if (! GetChangedFlag(CLIENT_OPTIONS_PAGE) ||
        ! IsPrinterSelInSync(CLIENT_OPTIONS_PAGE) ||
        ! (pPrinterSelName = GetPrinterSelName()))
    {
        return;
    }

    //
    // Time to send
    //

    pdmPublic = &gConfigData->devmode.dmPublic;
    pdmPrivate = &gConfigData->devmode.dmPrivate;

    pdmPrivate->whenToSend =
        IsDlgButtonChecked(hDlg, IDC_SEND_AT_CHEAP) ? SENDFAX_AT_CHEAP :
        IsDlgButtonChecked(hDlg, IDC_SEND_AT_TIME) ? SENDFAX_AT_TIME : SENDFAX_ASAP;

    //
    // Retrieve the current settings of send-at time control
    //

    GetTimeControlValue(hDlg, IDC_TC_AT_TIME, &pdmPrivate->sendAtTime);

    //
    // Retrieve the current settings of print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if ((hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) &&
        (listIdx = SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR)
    {
        listIdx = SendMessage(hwndList, CB_GETITEMDATA, listIdx, 0);

        if (listIdx >= 0 && listIdx < gConfigData->cForms) {

            pdmPublic->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH);
            pdmPublic->dmFields |= DM_FORMNAME;
            pdmPublic->dmPaperSize = gConfigData->pFormInfo[listIdx].paperSizeIndex;

            _tcscpy(pdmPublic->dmFormName, gConfigData->pFormInfo[listIdx].pFormName);
        }
    }

    pdmPublic->dmPrintQuality = FAXRES_HORIZONTAL;

    pdmPublic->dmYResolution =
        (SendDlgItemMessage(hDlg, IDC_IMAGE_QUALITY, CB_GETCURSEL, 0, 0) == 1) ?
            FAXRES_VERTDRAFT :
            FAXRES_VERTICAL;

    pdmPublic->dmOrientation =
        IsDlgButtonChecked(hDlg, IDC_LANDSCAPE) ? DMORIENT_LANDSCAPE : DMORIENT_PORTRAIT;

    GetDlgItemText(hDlg, IDC_BILLING_CODE, pdmPrivate->billingCode, MAX_BILLING_CODE);
    GetDlgItemText(hDlg, IDC_EMAIL, pdmPrivate->emailAddress, MAX_EMAIL_ADDRESS);

    //
    // Save per-user devmode information
    //

    SavePerUserDevmode(pPrinterSelName, (PDEVMODE) &gConfigData->devmode);
}



BOOL
FaxOptionsProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Fax Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;
    BOOL    result;

    switch (message) {

    case WM_INITDIALOG:

        SendDlgItemMessage(hDlg, IDC_BILLING_CODE, EM_SETLIMITTEXT, MAX_BILLING_CODE-1, 0);
        SendDlgItemMessage(hDlg, IDC_EMAIL, EM_SETLIMITTEXT, MAX_EMAIL_ADDRESS-1, 0);

        if (gConfigData->configType & FAXCONFIG_WORKSTATION) {
            HideWindow( GetDlgItem( hDlg, IDC_EMAIL ) );
            HideWindow( GetDlgItem( hDlg, IDCSTATIC_EMAIL ) );
        }

        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_BILLING_CODE:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_CHANGE || insideSetDlgItemText)
                return TRUE;
            break;

        case IDC_EMAIL:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_CHANGE || insideSetDlgItemText)
                return TRUE;
            break;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, CLIENT_OPTIONS_PAGE, TRUE);
        return result;

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

        case PSN_SETACTIVE:

            DoActivateFaxOptions(hDlg);
            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveFaxOptions(hDlg);
            SetChangedFlag(hDlg, CLIENT_OPTIONS_PAGE, FALSE);
            return PSNRET_NOERROR;
        }

        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, CLIENT_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\mapiprof.h ===
BOOL
InitializeMapi(
    VOID
    );

VOID
ShutdownMapi(
    VOID
    );

BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    );

BOOL
GetMapiProfiles(
    HWND hwnd
    );

extern BOOL isMapiEnabled;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\general.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    general.c

Abstract:

    Functions for handling events in the "General" tab of
    the fax server configuration property sheet

Environment:

    Fax configuration applet

Revision History:

    10/29/96 -wesw-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxcpl.h"


VOID
EnumMapiProfiles(
    HWND hwnd
    );



BOOL
GeneralProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "General" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    static HWND hwndProfileList;

    switch (message) {

    case WM_INITDIALOG:

        GetFaxDeviceAndConfigInfo();
        GetMapiProfiles();

        if (gConfigData->pMapiProfiles) {

            hwndProfileList = GetDlgItem(hDlg,IDC_DEST_PROFILENAME);
            EnumMapiProfiles(hwndProfileList);
        }

        if (gConfigData->pFaxConfig && gConfigData->pFaxConfig->InboundProfile) {

            if (SendMessage(hwndProfileList,
                            CB_SELECTSTRING,
                            (WPARAM) -1,
                            (LPARAM) gConfigData->pFaxConfig->InboundProfile) == CB_ERR)
            {
                SendMessage(hwndProfileList, CB_SETCURSEL, 0, 0);
            }

            CheckDlgButton( hDlg, IDC_ALLOW_EMAIL, BST_CHECKED );

        } else {

            SendMessage(hwndProfileList, CB_SETCURSEL, 0, 0);
            CheckDlgButton( hDlg, IDC_ALLOW_EMAIL, BST_UNCHECKED );
            EnableWindow( GetDlgItem( hDlg, IDC_DEST_PROFILENAME_STATIC ), FALSE );
            EnableWindow( GetDlgItem( hDlg, IDC_DEST_PROFILENAME ), FALSE );
        }

        return TRUE;

    case WM_COMMAND:

        if (HIWORD(wParam) == CBN_SELCHANGE && lParam == (LPARAM)hwndProfileList) {
            SetChangedFlag(hDlg, GENERAL_PAGE, TRUE);
        }

        if (HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == IDC_ALLOW_EMAIL) {
            if (IsDlgButtonChecked( hDlg, IDC_ALLOW_EMAIL )) {

                EnableWindow( GetDlgItem( hDlg, IDC_DEST_PROFILENAME_STATIC ), TRUE );
                EnableWindow( GetDlgItem( hDlg, IDC_DEST_PROFILENAME ), TRUE );

            } else {

                EnableWindow( GetDlgItem( hDlg, IDC_DEST_PROFILENAME_STATIC ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDC_DEST_PROFILENAME ), FALSE );

            }

            SetChangedFlag(hDlg, GENERAL_PAGE, TRUE);
        }

        return TRUE;

    case WM_NOTIFY:

        if (((LPNMHDR) lParam)->code == PSN_APPLY && GetChangedFlag(GENERAL_PAGE)) {

            LPTSTR  pInboundProfile;
            BOOL    success = FALSE;
            INT     index;
            TCHAR   buffer[MAX_STRING_LEN];

            if ((index = SendMessage(hwndProfileList, CB_GETCURSEL, 0, 0)) != CB_ERR) {

                if (IsDlgButtonChecked( hDlg, IDC_ALLOW_EMAIL )) {
                    SendMessage(hwndProfileList, CB_GETLBTEXT, index, (LPARAM) buffer);
                } else {
                    buffer[0] = 0;
                }

                pInboundProfile = gConfigData->pFaxConfig->InboundProfile;
                gConfigData->pFaxConfig->InboundProfile = buffer;

                success = SaveFaxDeviceAndConfigInfo(hDlg, GENERAL_PAGE);

                gConfigData->pFaxConfig->InboundProfile = pInboundProfile;
            }

            if (success) {

                SetChangedFlag(hDlg, GENERAL_PAGE, FALSE);
                return PSNRET_NOERROR;

            } else {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, RECEIVE_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\mapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    This file implements wrappers for all mapi apis.
    The wrappers are necessary because mapi does not
    implement unicode and this code must be non-unicode.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1996

--*/

#include "faxcpl.h"

#include <mapiwin.h>
#include <mapix.h>

static HMODULE MapiMod = NULL;
static LPMAPIADMINPROFILES MapiAdminProfiles = NULL;
static LPMAPIINITIALIZE MapiInitialize = NULL;
static LPMAPIUNINITIALIZE MapiUnInitialize = NULL;
static LPMAPIFREEBUFFER pMAPIFreeBuffer = NULL;
static LPPROFADMIN lpProfAdmin;

BOOL isMapiEnabled = FALSE;


static
LPWSTR
AnsiStringToUnicodeString(
    LPSTR AnsiString,
    LPWSTR UnicodeString
    )
{
    DWORD Count;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        return NULL;
    }

    return UnicodeString;
}


static
LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString,
    LPSTR AnsiString
    )
{
    DWORD Count;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        return NULL;
    }

    return AnsiString;
}

VOID
FreeSRowSet(
    LPSRowSet prws
    )
{
    ULONG irw;

    if (!prws) {
        return;
    }

    for(irw = 0; irw < prws->cRows; irw++) {
        pMAPIFreeBuffer( prws->aRow[irw].lpProps );
    }

    pMAPIFreeBuffer( prws );
}


ULONG
MLCRelease(
    LPUNKNOWN punk
    )
{
    return (punk) ? punk->lpVtbl->Release(punk) : 0;
}


BOOL
ValidateProp(
    LPSPropValue pval,
    ULONG ulPropTag
    )
{
    if (pval->ulPropTag != ulPropTag) {
        pval->ulPropTag = ulPropTag;
        pval->Value.lpszA = "???";
        return TRUE;
    }

    return FALSE;
}

BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;


    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        if (pval[2].Value.b) {
            //
            // this is the default profile
            //
            AnsiStringToUnicodeString( pval[0].Value.lpszA, ProfileName );
            rVal = TRUE;
            break;
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}

BOOL
InitializeMapi(
    VOID
    )
{
    MAPIINIT_0 MapiInit;

    //
    // load the mapi dll
    //

    MapiMod = LoadLibrary( TEXT("mapi32.dll") );
    if (!MapiMod) {
        return FALSE;
    }

    //
    // get the addresses of the mapi functions that we need
    //

    MapiAdminProfiles = (LPMAPIADMINPROFILES) GetProcAddress( MapiMod, "MAPIAdminProfiles" );
    MapiInitialize = (LPMAPIINITIALIZE) GetProcAddress( MapiMod, "MAPIInitialize" );
    MapiUnInitialize = (LPMAPIUNINITIALIZE) GetProcAddress( MapiMod, "MAPIUninitialize" );
    pMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress( MapiMod, "MAPIFreeBuffer" );
    if (!MapiAdminProfiles || !MapiInitialize || !MapiUnInitialize || !pMAPIFreeBuffer) {
        return FALSE;
    }

    //
    // initialize mapi for our calls
    //

    MapiInit.ulVersion = 0;
    MapiInit.ulFlags = 0;

    if (MapiInitialize( &MapiInit )) {
        return FALSE;
    }

    //
    // get the admin profile object
    //

    if (MapiAdminProfiles( 0, &lpProfAdmin )) {
        MapiUnInitialize();
        FreeLibrary(MapiMod);
        return FALSE;
    }

    return TRUE;
}


VOID
ShutdownMapi(
    VOID
    )
{
    if (isMapiEnabled) {

        MapiUnInitialize();
        FreeLibrary(MapiMod);

        isMapiEnabled = FALSE;
    }
}


BOOL
GetMapiProfiles(
    HWND hwnd
    )
{
    BOOL rVal = FALSE;
    HMODULE MapiMod = NULL;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;


    //
    // get the mapi table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles and put the name
    // of each profile in the combo box
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;

        SendMessageA(
            hwnd,
            CB_ADDSTRING,
            0,
            (LPARAM) pval[0].Value.lpszA
            );

    }

    rVal = TRUE;

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\sendopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendopts.c

Abstract:

    Functions for handling events in the "Send Options" tab of
    the fax server configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"


//
// Information about the fax device list view on "Send Options" page
//

static COLUMNINFO faxDeviceListViewColumnInfo[] = {

    { COLUMN_DEVICE_NAME, 2 },
    { COLUMN_TSID, 1 },
    { 0, 0 },
};



VOID
DoInitSendOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Perform one-time initialization of "Send Options" property page

Arguments:

    hDlg - Window handle to the "Send Options" property page

Return Value:

    NONE

--*/

{
    //
    // Maximum length for various text fields in the dialog
    //

    static INT textLimits[] = {

        IDC_TSID,               21,
        IDC_ARCHIVE_DIRECTORY,  MAX_ARCHIVE_DIR,
        0,
    };

    LimitTextFields(hDlg, textLimits);

    //
    // Connect to the fax service and retrieve the list of fax devices
    //

    GetFaxDeviceAndConfigInfo();

    //
    // Initialize the dialog appearance
    //

    if (gConfigData->configType != FAXCONFIG_SERVER) {

        EnableWindow(GetDlgItem(hDlg, IDC_NEW_PRINTER), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_PRINTER), FALSE);
    }
}



VOID
ToggleArchiveControls(
    HWND    hDlg
    )

/*++

Routine Description:

    Enable/disable archive directory edit box and browse button
    depending on whether archive outgoing fax checkbox is checked

Arguments:

    hDlg - Window handle to the "Send Options" property page

Return Value:

    NONE

--*/

{
    BOOL    enabled = (IsDlgButtonChecked(hDlg, IDC_ARCHIVE_CHECKBOX) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_ARCHIVE_DIRECTORY), enabled);
    EnableWindow(GetDlgItem(hDlg, IDC_BROWSE_DIR), enabled && gConfigData->pServerName == NULL);
}



VOID
DoActivateSendOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the "Send Options" property page is activated

Arguments:

    hDlg - Window handle to the "Send Options" property page

Return Value:

    NONE

--*/

{
    //
    // Controls on the "Send Options" page which may be enabled or disabled
    //

    static INT  sendOptionsCtrls[] = {

        IDC_FAX_DEVICE_LIST,
        IDC_TSID,
        IDC_ARCHIVE_CHECKBOX,
        IDC_ARCHIVE_DIRECTORY,
        IDC_BROWSE_DIR,
        0,
    };

    BOOL                enabled = FALSE;
    LPTSTR              pPortName = NULL;
    BOOL                devListInSync;
    HWND                hwndLV;
    LPTSTR              pArchiveDir;
    INT                 index;


    //
    // Redisplay the fax device list if it's out-of-sync
    //

    hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST);

    if (! (devListInSync = IsFaxDeviceListInSync(SEND_OPTIONS_PAGE))) {

        InitFaxDeviceListView(hwndLV, LV_HASCHECKBOX, faxDeviceListViewColumnInfo);
        SetFaxDeviceListInSync(SEND_OPTIONS_PAGE);

        for (index=0; index < gConfigData->cDevices; index++) {

            if (gConfigData->pDevInfo[index].Flags & FPF_SEND) {

                CheckListViewItem(hwndLV, index);
            }
        }

    }

    SetChangedFlag(hDlg, SEND_OPTIONS_PAGE, FALSE);

    Verbose(("Updating 'Send Options' page ...\n"));

    //
    // Discount rate period
    //

    InitTimeControl(hDlg, IDC_TC_CHEAP_BEGIN, &gConfigData->pFaxConfig->StartCheapTime);
    InitTimeControl(hDlg, IDC_TC_CHEAP_END, &gConfigData->pFaxConfig->StopCheapTime);

    //
    // Archive directory
    //

    pArchiveDir = gConfigData->pFaxConfig->ArchiveDirectory;

    CheckDlgButton(
        hDlg,
        IDC_ARCHIVE_CHECKBOX,
        gConfigData->pFaxConfig->ArchiveOutgoingFaxes ? BST_CHECKED : BST_UNCHECKED
        );

    MySetDlgItemText(hDlg, IDC_ARCHIVE_DIRECTORY, pArchiveDir ? pArchiveDir : TEXT(""));

    enabled = TRUE;

    //
    // Disable or enable the controls depending on whether the user
    // has privilege to perform printer administration.
    //

    EnableControls(hDlg, sendOptionsCtrls, enabled);
    EnableTimeControl(hDlg, IDC_TC_CHEAP_BEGIN, enabled);
    EnableTimeControl(hDlg, IDC_TC_CHEAP_END, enabled);

    if (enabled) {
        ToggleArchiveControls(hDlg);
    }
}



BOOL
DoSaveSendOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Send Options" property page

Arguments:

    hDlg - Handle to the "Send Options" property page

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define FAIL_SAVE_SEND_OPTIONS(err) { errorId = err; goto ExitSaveSendOptions; }

{
    INT             errorId = 0;
    LPTSTR          pPortName = NULL;
    FAX_TIME        beginTime, endTime;
    INT             archiveFlag;
    TCHAR           archiveDir[MAX_PATH];

    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Send Options' page ...\n"));

    if (! GetChangedFlag(SEND_OPTIONS_PAGE)) {
        return TRUE;
    }

    //
    // Save discount rate period and archive directory information
    //

    GetTimeControlValue(hDlg, IDC_TC_CHEAP_BEGIN, &beginTime);
    GetTimeControlValue(hDlg, IDC_TC_CHEAP_END, &endTime);

    archiveFlag = IsDlgButtonChecked(hDlg, IDC_ARCHIVE_CHECKBOX);

    if (! GetDlgItemText(hDlg, IDC_ARCHIVE_DIRECTORY, archiveDir, MAX_PATH)) {

        if (archiveFlag) {
            FAIL_SAVE_SEND_OPTIONS(IDS_MISSING_ARCHIVEDIR);
        }

        archiveDir[0] = NUL;
    }

    gConfigData->pFaxConfig->StartCheapTime = beginTime;
    gConfigData->pFaxConfig->StopCheapTime = endTime;
    gConfigData->pFaxConfig->ArchiveOutgoingFaxes = archiveFlag;

    if (gConfigData->pFaxConfig->ArchiveDirectory) {
        MemFree( gConfigData->pFaxConfig->ArchiveDirectory );
        gConfigData->pFaxConfig->ArchiveDirectory = NULL;
    }

    gConfigData->pFaxConfig->ArchiveDirectory = DuplicateString( archiveDir );

ExitSaveSendOptions:

    MemFree(pPortName);

    //
    // Display a message box if an error is encountered
    //

    if (errorId != 0) {

        DisplayMessageDialog(hDlg, 0, 0, errorId);
        return FALSE;
    }

    //
    // Save the fax device information if this is the last modified page
    //

    return SaveFaxDeviceAndConfigInfo(hDlg, SEND_OPTIONS_PAGE);
}



VOID
DoChangeTSID(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the user changes sending station identifier (TSID)

Arguments:

    hDlg - Handle to the "Send Options" property page

Return Value:

    NONE

--*/

{
    TCHAR   buffer[MAX_STRING_LEN];
    INT     index = -1;
    HWND    hwndLV;

    if (! (hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)))
        return;

    if (! GetDlgItemText(hDlg, IDC_TSID, buffer, MAX_STRING_LEN))
        buffer[0] = NUL;

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

        Assert(index < gConfigData->cDevices);

        MemFree(gConfigData->pDevInfo[index].TSID);
        gConfigData->pDevInfo[index].TSID = DuplicateString(buffer);
    }
}



VOID
DoChangeSendDeviceSel(
    HWND    hDlg,
    HWND    hwndLV
    )

/*++

Routine Description:

    Process selection change events in the fax device list

Arguments:

    hDlg - Window handle to the "Send Options" property page
    hwndLV - Handle to the fax device list

Return Value:

    NONE

--*/

{
    LPTSTR      tsid = NULL;
    INT         index;

    //
    // Find the common attributes shared by selected devices
    //

    if ((index = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) != -1) {

        Assert(index < gConfigData->cDevices);
        tsid = gConfigData->pDevInfo[index].TSID;
        EnableWindow(GetDlgItem(hDlg, IDC_TSID), TRUE);

        while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

            Assert(index < gConfigData->cDevices);

            if (! tsid ||
                ! gConfigData->pDevInfo[index].TSID ||
                _tcscmp(tsid, gConfigData->pDevInfo[index].TSID) != EQUAL_STRING)
            {
                tsid = NULL;
                break;
            }
        }
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_TSID), FALSE);
    }

    MySetDlgItemText(hDlg, IDC_TSID, tsid ? tsid : TEXT(""));
}



VOID
ToggleFaxDeviceForSend(
    HWND    hwndLV,
    INT     index
    )

/*++

Routine Description:

    Toggle a fax device for sending

Arguments:

    hwndLV - Handle to the fax device list view
    index - Specifies the fax device to be toggled

Return Value:

    NONE

--*/

{
    if (IsListViewItemChecked(hwndLV, index)) {

        UncheckListViewItem(hwndLV, index);
        gConfigData->pDevInfo[index].Flags &= ~FPF_SEND;

    } else {

        CheckListViewItem(hwndLV, index);
        gConfigData->pDevInfo[index].Flags |= FPF_SEND;

        //
        // NOTE: Since we allow at most one fax device for sending on workstation
        // configuration, here we must make sure to disable all other fax devices.
        //

        if (gConfigData->configType == FAXCONFIG_WORKSTATION) {

            INT count = ListView_GetItemCount(hwndLV);

            while (count-- > 0) {

                if (count != index) {

                    UncheckListViewItem(hwndLV, count);
                    gConfigData->pDevInfo[count].Flags &= ~FPF_SEND;
                }
            }
        }
    }
}



BOOL
HandleSendListViewMessage(
    HWND    hDlg,
    LPNMHDR pNMHdr
    )

/*++

Routine Description:

    Handle notification events from the fax device list

Arguments:

    hDlg - Window handle to the "Send Options" property page
    pNMHdr - Points to an NMHDR structure

Return Value:

    TRUE if any change was made to the fax device list
    FALSE otherwise

--*/

{
    LV_HITTESTINFO  hitTestInfo;
    DWORD           msgPos;
    INT             index;
    NM_LISTVIEW    *pnmlv;
    HWND            hwndLV = pNMHdr->hwndFrom;

    switch (pNMHdr->code) {

    case NM_CLICK:

        //
        // Figure out which item (if any) was clicked on
        //

        if (! IsWindowEnabled(hwndLV))
            break;

        msgPos = GetMessagePos();
        hitTestInfo.pt.x = LOWORD(msgPos);
        hitTestInfo.pt.y = HIWORD(msgPos);
        MapWindowPoints(HWND_DESKTOP, hwndLV, &hitTestInfo.pt, 1 );

        index = ListView_HitTest(hwndLV, &hitTestInfo);

        if (index != -1 && (hitTestInfo.flags & LVHT_ONITEMSTATEICON)) {

            //
            // Toggle between checked and unchecked state
            //

            ToggleFaxDeviceForSend(hwndLV, index);
            return TRUE;
        }
        break;

    case LVN_KEYDOWN:

        //
        // Use space key to toggle check boxes
        //

        if (! IsWindowEnabled(hwndLV))
            break;

        if (((LV_KEYDOWN *) pNMHdr)->wVKey == VK_SPACE) {

            index = ListView_GetNextItem(hwndLV, -1,  LVNI_ALL | LVNI_SELECTED);

            if (index != -1) {

                ToggleFaxDeviceForSend(hwndLV, index);
                return TRUE;
            }
        }
        break;

    case LVN_ITEMCHANGED:

        //
        // Update the TSID field when the currently selected fax device has changed
        //

        pnmlv = (NM_LISTVIEW *) pNMHdr;

        if ((pnmlv->uChanged & LVIF_STATE) != 0 &&
            (pnmlv->uOldState & LVIS_SELECTED) != (pnmlv->uNewState & LVIS_SELECTED))
        {
            Verbose(("Selection change: %d\n", pnmlv->iItem));
            DoChangeSendDeviceSel(hDlg, hwndLV);
        }

        break;
    }

    return FALSE;
}



BOOL
SendOptionsProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Send Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;
    BOOL    result;
    LPNMHDR pNMHdr;

    switch (message) {

    case WM_INITDIALOG:

        DoInitSendOptions(hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_TC_CHEAP_BEGIN+TC_HOUR:
        case IDC_TC_CHEAP_BEGIN+TC_MINUTE:
        case IDC_TC_CHEAP_BEGIN+TC_AMPM:

            //
            // Handle user actions inside the time control
            //

            result = HandleTimeControl(hDlg, message, wParam, lParam,
                                       IDC_TC_CHEAP_BEGIN,
                                       cmdId - IDC_TC_CHEAP_BEGIN);
            break;

        case IDC_TC_CHEAP_END+TC_HOUR:
        case IDC_TC_CHEAP_END+TC_MINUTE:
        case IDC_TC_CHEAP_END+TC_AMPM:

            result = HandleTimeControl(hDlg, message, wParam, lParam,
                                       IDC_TC_CHEAP_END,
                                       cmdId - IDC_TC_CHEAP_END);
            break;

        case IDC_ARCHIVE_CHECKBOX:

            ToggleArchiveControls(hDlg);
            break;

        case IDC_ARCHIVE_DIRECTORY:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_CHANGE || insideSetDlgItemText)
                return TRUE;

            break;

        case IDC_TSID:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

            case EN_CHANGE:

                if (! insideSetDlgItemText) {

                    DoChangeTSID(hDlg);
                    break;
                }

                return TRUE;

            case EN_KILLFOCUS:

                UpdateFaxDeviceListViewColumns(GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST),
                                               faxDeviceListViewColumnInfo,
                                               1);

            default:

                return TRUE;
            }

            break;

        case IDC_BROWSE_DIR:

            if (! DoBrowseForDirectory(hDlg, IDC_ARCHIVE_DIRECTORY, IDS_ARCHIVE_DIR))
                return TRUE;

            break;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, SEND_OPTIONS_PAGE, TRUE);
        return TRUE;

    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLOR:

        //
        // Deal with color changes in various time control fields
        //

        if ((result = HandleTimeControl(hDlg, message, wParam, lParam, IDC_TC_CHEAP_BEGIN, TRUE)) ||
            (result = HandleTimeControl(hDlg, message, wParam, lParam, IDC_TC_CHEAP_END,   TRUE)))
        {
            return result;
        }
        break;

    case WM_NOTIFY:

        pNMHdr = (NMHDR *) lParam;

        if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)) {

            if (HandleSendListViewMessage(hDlg, pNMHdr))
                SetChangedFlag(hDlg, SEND_OPTIONS_PAGE, TRUE);

        } else switch (pNMHdr->code) {

        case PSN_SETACTIVE:

            DoActivateSendOptions(hDlg);
            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            if (! DoSaveSendOptions(hDlg)) {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;

            } else {

                SetChangedFlag(hDlg, SEND_OPTIONS_PAGE, FALSE);
                return PSNRET_NOERROR;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, SEND_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\priority.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    priority.c

Abstract:

    Functions for handling events in the "Device Priority" tab of
    the fax server configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        05/06/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"



VOID
DoActivateDevicePriority(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the "Device Priority" property page is activated

Arguments:

    hDlg - Window handle to the "Device Priority" property page

Return Value:

    NONE

--*/

{
    //
    // Information about the fax device list view
    //

    static COLUMNINFO faxDeviceListViewColumnInfo[] = {

        { COLUMN_DEVICE_NAME, 1 },
        { 0, 0 },
    };

    HWND    hwndLV;

    //
    // Reinitialize the fax device list view if necessary
    //

    if (!IsFaxDeviceListInSync(DEVICE_PRIORITY_PAGE) &&
        (hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)))
    {
        InitFaxDeviceListView(hwndLV, 0, faxDeviceListViewColumnInfo);
    }

    SetFaxDeviceListInSync(DEVICE_PRIORITY_PAGE);
}



BOOL
DoSaveDevicePriority(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Device Priority" property page

Arguments:

    hDlg - Handle to the "Device Priority" property page

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT index;

    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Receive Options' page ...\n"));

    if (! GetChangedFlag(DEVICE_PRIORITY_PAGE))
        return TRUE;

    //
    // Assign priority to fax devices: smaller number corresponds to lower priority
    //

    for (index=0; index < gConfigData->cDevices; index++)
        gConfigData->pDevInfo[index].Priority = gConfigData->cDevices - index + 1;

    //
    // Save the fax device information if this is the last modified page
    //

    gConfigData->priorityChanged = TRUE;
    return SaveFaxDeviceAndConfigInfo(hDlg, DEVICE_PRIORITY_PAGE);
}



VOID
DoChangeDevicePriority(
    HWND    hDlg,
    INT     direction
    )

/*++

Routine Description:

    Increment or decrement the priority of current selected fax device

Arguments:

    hDlg - Handle to the "Device Priority" property page
    direction - Whether to increment or decrement the device priority
        -1 to increment device priority
         1 to decrement device priority

Return Value:

    NONE

--*/

{
    HWND    hwndLV;
    INT     index, newIndex, nItems;

    //
    // Get the index of the currently selected item and
    // count the total number of items in the list view
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)) == NULL ||
        (nItems = ListView_GetItemCount(hwndLV)) == -1 ||
        (index = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) == -1)
    {
        return;
    }

    //
    // Calculate the new item index
    //

    Assert(nItems <= gConfigData->cDevices && index < nItems);

    if ((newIndex = index + direction) >= 0 && newIndex < nItems) {

        CONFIG_PORT_INFO_2 portInfo;

        portInfo = gConfigData->pDevInfo[index];
        gConfigData->pDevInfo[index] = gConfigData->pDevInfo[newIndex];
        gConfigData->pDevInfo[newIndex] = portInfo;

        gConfigData->faxDeviceSyncFlag = 0;
        DoActivateDevicePriority(hDlg);

        //
        // Keep the original fax device selected
        //

        ListView_SetItemState(hwndLV,
                              newIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED);
    }
}



BOOL
DevicePriorityProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Device Priority" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT cmdId;

    switch (message) {

    case WM_INITDIALOG:

        GetFaxDeviceAndConfigInfo();

        SendMessage(GetDlgItem(hDlg, IDC_MOVEUP),
                    BM_SETIMAGE,
                    IMAGE_ICON,
                    (WPARAM) LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_ARROWUP)));

        SendMessage(GetDlgItem(hDlg, IDC_MOVEDOWN),
                    BM_SETIMAGE,
                    IMAGE_ICON,
                    (LPARAM) LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_ARROWDOWN)));
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_MOVEUP:
        case IDC_MOVEDOWN:

            DoChangeDevicePriority(hDlg, (cmdId == IDC_MOVEUP) ? -1 : 1);
            break;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, DEVICE_PRIORITY_PAGE, TRUE);
        return TRUE;

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

        case PSN_SETACTIVE:

            DoActivateDevicePriority(hDlg);
            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            if (! DoSaveDevicePriority(hDlg)) {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;

            } else {

                SetChangedFlag(hDlg, DEVICE_PRIORITY_PAGE, FALSE);
                return PSNRET_NOERROR;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, DEVICE_PRIORITY_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\recvopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    recvopts.c

Abstract:

    Functions for handling events in the "Receive Options" tab of
    the fax server configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"

//
// Information about the fax device list view on "Receive Options" page
//

static COLUMNINFO faxDeviceListViewColumnInfo[] = {

    { COLUMN_DEVICE_NAME, 2 },
    { COLUMN_CSID, 1 },
    { 0, 0 },
};



VOID
EnumMapiProfiles(
    HWND hwnd
    )
/*++

Routine Description:

    Put the mapi profiles in the combo box

Arguments:

    hwnd - window handle to mapi profiles combo box

Return Value:

    NONE

--*/
{
    LPTSTR MapiProfiles;

    MapiProfiles = gConfigData->pMapiProfiles;

    while (MapiProfiles && *MapiProfiles) {
        SendMessage(
            hwnd,
            CB_ADDSTRING,
            0,
            (LPARAM) MapiProfiles
            );
        MapiProfiles += _tcslen(MapiProfiles) + 1;
    }
}



VOID
DoInitRecvOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Perform one-time initialization of "Receive Options" property page

Arguments:

    hDlg - Window handle to the "Receive Options" property page

Return Value:

    NONE

--*/

{
    HWND    hwnd;
    TCHAR   buffer[MAX_STRING_LEN];

    //
    // Maximum length for various text fields in the dialog
    //

    static INT textLimits[] = {

        IDC_CSID,               21,
        IDC_DEST_DIRPATH,       MAX_ARCHIVE_DIR,
        IDC_DEST_RINGS,         3,
        0,
    };

    GetMapiProfiles();

    LimitTextFields(hDlg, textLimits);

    if (gConfigData->pMapiProfiles && (hwnd = GetDlgItem(hDlg, IDC_DEST_PROFILENAME))){

        EnumMapiProfiles(hwnd);

        LoadString(ghInstance, IDS_DEFAULT_PROFILE, buffer, MAX_STRING_LEN);

        SendMessage(hwnd, CB_INSERTSTRING, 0, (LPARAM) buffer);
    }

    //
    // Initialize the list of destination printers
    //

    if (hwnd = GetDlgItem(hDlg, IDC_DEST_PRINTERLIST)) {

        PPRINTER_INFO_2 pPrinterInfo2, pSaved;
        DWORD           cPrinters, dwFlags;

        dwFlags = gConfigData->pServerName ?
                    PRINTER_ENUM_NAME :
                    (PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS);

        pPrinterInfo2 = MyEnumPrinters(gConfigData->pServerName, 2, &cPrinters, dwFlags);

        if (pSaved = pPrinterInfo2) {

            //
            // Filtering out fax printers from the list
            //

            for ( ; cPrinters--; pPrinterInfo2++) {

                if (_tcsicmp(pPrinterInfo2->pDriverName, FAX_DRIVER_NAME) != EQUAL_STRING)
                    SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) pPrinterInfo2->pPrinterName);
            }

            MemFree(pSaved);
        }

        //
        // The first choice is always the system default printer
        //

        LoadString(ghInstance, IDS_DEFAULT_PRINTER, buffer, MAX_STRING_LEN);
        SendMessage(hwnd, CB_INSERTSTRING, 0, (LPARAM) buffer);
    }

    //
    // Connect to the fax service and retrieve the list of fax devices
    //

    GetFaxDeviceAndConfigInfo();

}



//
// Data structure and constants used for comparing two fax devices
//

typedef struct {

    PCONFIG_PORT_INFO_2 pDevInfo;
    DWORD            match;

} MATCHINFO, *PMATCHINFO;

#define MATCH_DEST_PRINTER      0x0001
#define MATCH_DEST_DIR          0x0002
#define MATCH_DEST_EMAIL        0x0004
#define MATCH_DEST_MAILBOX      0x0008
#define MATCH_DEST_PRINTERNAME  0x0010
#define MATCH_DEST_DIRPATH      0x0020
#define MATCH_DEST_PROFILENAME  0x0040
#define MATCH_DEST_CSID         0x0080
#define MATCH_DEST_RINGS        0x0100
#define MATCH_ALL               0x0FFF


VOID
MatchFaxDevInfo(
    PMATCHINFO       pMatchInfo,
    PCONFIG_PORT_INFO_2 pDevInfo
    )

/*++

Routine Description:

    Compare a fax device with another one and
    figure out what attributes they have in common

Arguments:

    pMatchInfo - Points to a MATCHINFO structure
    pDevInfo - Specifies the fax device to match

Return Value:

    NONE

--*/

#define MatchRoutingOption(matchFlag, routingFlag) { \
            if ((pMatchInfo->match & (matchFlag)) && \
                (pRefInfo->Mask & (routingFlag)) != (pDevInfo->Mask & (routingFlag))) \
            { \
                pMatchInfo->match &= ~(matchFlag); \
            } \
        }

#define MatchDWORDField(matchFlag, FieldName) { \
            if ((pMatchInfo->match & (matchFlag)) && \
                (pRefInfo->FieldName != pDevInfo->FieldName)) \
            { \
                pMatchInfo->match &= ~(matchFlag); \
            } \
        }

#define MatchTextField(matchFlag, pFieldName) { \
            if ((pMatchInfo->match & (matchFlag)) && \
                (! pRefInfo->pFieldName || \
                 ! pDevInfo->pFieldName || \
                 _tcsicmp(pRefInfo->pFieldName, pDevInfo->pFieldName) != EQUAL_STRING)) \
            { \
                pMatchInfo->match &= ~(matchFlag); \
            } \
        }

{
    PCONFIG_PORT_INFO_2 pRefInfo;

    //
    // Remember the first fax device as the reference
    //

    if ((pRefInfo = pMatchInfo->pDevInfo) == NULL) {

        pMatchInfo->pDevInfo = pDevInfo;
        pMatchInfo->match = MATCH_ALL;
        return;
    }

    //
    // Match each attribute in turn
    //

    MatchRoutingOption(MATCH_DEST_PRINTER, LR_PRINT);
    MatchRoutingOption(MATCH_DEST_EMAIL,   LR_EMAIL);
    MatchRoutingOption(MATCH_DEST_DIR,     LR_STORE);
    MatchRoutingOption(MATCH_DEST_MAILBOX, LR_INBOX);

    MatchTextField(MATCH_DEST_PRINTERNAME, PrinterName);
    MatchTextField(MATCH_DEST_DIRPATH,     DirStore);
    MatchTextField(MATCH_DEST_PROFILENAME, ProfileName);
    MatchTextField(MATCH_DEST_CSID,        CSID);

    MatchDWORDField(MATCH_DEST_RINGS,       Rings);
}



VOID
DoChangeRecvDeviceSel(
    HWND    hDlg,
    HWND    hwndLV
    )

/*++

Routine Description:

    Process selection change events in the fax device list

Arguments:

    hDlg - Window handle to the "Receive Options" property page
    hwndLV - Handle to the fax device list

Return Value:

    NONE

--*/

#define SetMatchedCheckBox(matchFlag, routingFlag, itemId) \
        CheckDlgButton(hDlg, itemId, \
            (match & (matchFlag)) ? \
                ((pDevInfo->Mask & (routingFlag)) ? BST_CHECKED : BST_UNCHECKED) : \
                BST_INDETERMINATE)

#define SetMatchedTextField(matchFlag, itemId, pFieldName) \
        SetDlgItemText(hDlg, itemId, \
                       ((match & (matchFlag)) && pDevInfo->pFieldName) ? \
                           pDevInfo->pFieldName : TEXT(""))

#define SetMatchedDWORDField(matchFlag, itemId, pFieldName) \
        SetDlgItemInt(hDlg, itemId, \
                       (match & matchFlag) ? pDevInfo->pFieldName : 0, FALSE)

{
    MATCHINFO        matchInfo = { NULL, 0 };
    INT              index = -1;
    DWORD            match;
    HWND             hwndList;
    PCONFIG_PORT_INFO_2 pDevInfo;

    //
    // Find the common attributes shared by selected devices
    //

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

        Assert(index < gConfigData->cDevices);
        MatchFaxDevInfo(&matchInfo, gConfigData->pDevInfo + index);
    }

    if ((pDevInfo = matchInfo.pDevInfo) == NULL)
        return;

    //
    // Display the shared attributes at the bottom of the page
    //

    match = matchInfo.match;

    SetMatchedCheckBox(MATCH_DEST_PRINTER, LR_PRINT, IDC_DEST_PRINTER);
    SetMatchedCheckBox(MATCH_DEST_EMAIL,   LR_EMAIL, IDC_DEST_EMAIL);
    SetMatchedCheckBox(MATCH_DEST_DIR,     LR_STORE, IDC_DEST_DIR);
    SetMatchedCheckBox(MATCH_DEST_MAILBOX, LR_INBOX, IDC_DEST_MAILBOX);

    if (hwndList = GetDlgItem(hDlg, IDC_DEST_PRINTERLIST)) {

        if ((match & MATCH_DEST_PRINTERNAME) && pDevInfo->PrinterName) {

            if (IsEmptyString(pDevInfo->PrinterName))
                SendMessage(hwndList, CB_SETCURSEL, 0, 0);
            else if (SendMessage(hwndList,
                                 CB_SELECTSTRING,
                                 (WPARAM) -1,
                                 (LPARAM) pDevInfo->PrinterName) == CB_ERR)
            {
                DisplayMessageDialog(hDlg,
                                     0,
                                     IDS_WARNING_DLGTITLE,
                                     IDS_NONEXISTENT_PRINTER,
                                     pDevInfo->PrinterName);
            }

        } else
            SendMessage(hwndList, CB_SETCURSEL, (WPARAM) -1, 0);
    }

    if (hwndList = GetDlgItem(hDlg, IDC_DEST_PROFILENAME)) {

        if ((match & MATCH_DEST_PROFILENAME) && pDevInfo->ProfileName) {

            if (IsEmptyString(pDevInfo->ProfileName) ||
                ! SendMessage(hwndList,
                              CB_SELECTSTRING,
                              (WPARAM) -1,
                              (LPARAM) pDevInfo->ProfileName))
            {
                SendMessage(hwndList, CB_SETCURSEL, 0, 0);
            }

        } else
            SendMessage(hwndList, CB_SETCURSEL, (WPARAM) -1, 0);
    }

    //
    // This is a real kluge. But we have no other way of telling whether
    // EN_CHANGE message is caused by user action or was caused by
    // us calling SetDlgItemText.
    //

    insideSetDlgItemText = TRUE;

    SetMatchedTextField(MATCH_DEST_DIRPATH, IDC_DEST_DIRPATH, DirStore);
    SetMatchedTextField(MATCH_DEST_CSID,    IDC_CSID,         CSID);

    SetMatchedDWORDField(MATCH_DEST_RINGS,  IDC_DEST_RINGS,   Rings);

    insideSetDlgItemText = FALSE;
}



BOOL
ValidateReceiveOptions(
    HWND    hDlg,
    INT     index
    )

/*++

Routine Description:

    Check the receive options for the specified fax device

Arguments:

    hDlg - Window handle to the "Receive Options" property page
    index - Specifies the index of the interested fax device

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCONFIG_PORT_INFO_2 pDevInfo;
    INT              errorId = 0;

    //
    // Sanity check
    //

    if (index >= gConfigData->cDevices || gConfigData->pDevInfo == NULL) {

        Assert(FALSE);
        return TRUE;
    }

    //
    // Check if the specified device is not enabled for receiving fax
    //

    pDevInfo = gConfigData->pDevInfo + index;

    if (! (pDevInfo->Flags & FPF_RECEIVE))
        return TRUE;

    if ((pDevInfo->Mask & (LR_PRINT|LR_STORE|LR_EMAIL|LR_INBOX)) == 0) {

        //
        // At least one inbound routing option must be selected
        //

        errorId = IDS_NO_INBOUND_ROUTING;

    } else if ((pDevInfo->Mask & LR_STORE) &&
               (pDevInfo->DirStore == NULL || *(pDevInfo->DirStore) == NUL))
    {
        //
        // If the "Store In Directory" option is selected,
        // a directory path must be specified.
        //

        errorId = IDS_MISSING_INBOUND_DIR;

    }

    //
    // Display an error message the receive options are invalid
    //

    if (errorId != 0) {

        DisplayMessageDialog(hDlg,
                             0,
                             IDS_INVALID_INBOUND_OPTIONS,
                             errorId,
                             pDevInfo->DeviceName);
    }

    return (errorId == 0);
}


BOOL
ValidateReceiveOptionsForSelectedDevices(
    HWND    hDlg,
    HWND    hwndLV
    )

/*++

Routine Description:

    Check if the receive options for the selected fax devices are valid

Arguments:

    hDlg - Window handle to the "Receive Options" property page
    hwndLV - Handle to the fax device list

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    INT index = -1;

    //
    // Check the receive options for each selected device
    //

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

        if (! ValidateReceiveOptions(hDlg, index))
            return FALSE;
    }

    return TRUE;
}



VOID
ToggleFaxDeviceForReceive(
    HWND    hwndLV,
    INT     index
    )

/*++

Routine Description:

    Toggle a fax device for receiving

Arguments:

    hwndLV - Handle to the fax device list view
    index - Specifies the fax device to be toggled

Return Value:

    NONE

--*/

{
    Assert(index < gConfigData->cDevices);

    if (IsListViewItemChecked(hwndLV, index)) {

        UncheckListViewItem(hwndLV, index);
        gConfigData->pDevInfo[index].Flags &= ~FPF_RECEIVE;

    } else {

        CheckListViewItem(hwndLV, index);
        gConfigData->pDevInfo[index].Flags |= FPF_RECEIVE;

    }
}



VOID
UpdateReceiveOptionControls(
    HWND    hDlg
    )

/*++

Routine Description:

    Enable/disable receive option controls

Arguments:

    hDlg - Window handle to the "Receive Options" property page

Return Value:

    NONE

--*/

{
    HWND    hwndLV;

    //
    // Check if something is selected in the fax device list view
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)) == NULL ||
        ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED) == -1)
    {
        insideSetDlgItemText = TRUE;
        SetDlgItemText(hDlg, IDC_DEST_DIRPATH, TEXT(""));
        SetDlgItemText(hDlg, IDC_CSID, TEXT(""));
        SetDlgItemInt(hDlg, IDC_DEST_RINGS, 0, FALSE);
        insideSetDlgItemText = FALSE;

        SendDlgItemMessage(hDlg, IDC_DEST_PRINTERLIST, CB_SETCURSEL, (WPARAM) -1, 0);
        SendDlgItemMessage(hDlg, IDC_DEST_PROFILENAME, CB_SETCURSEL, (WPARAM) -1, 0);

        EnableWindow(GetDlgItem(hDlg, IDC_DEST_RINGS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CSID), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_PRINTER), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_EMAIL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_DIR), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_MAILBOX), FALSE);

        CheckDlgButton(hDlg, IDC_DEST_PRINTER, BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_DEST_EMAIL, BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_DEST_DIR, BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_DEST_MAILBOX, BST_UNCHECKED);

    } else {

        EnableWindow(GetDlgItem(hDlg, IDC_CSID), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_PRINTER), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_DIR), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_EMAIL), TRUE);

        EnableWindow(GetDlgItem(hDlg, IDC_DEST_MAILBOX), gConfigData->pMapiProfiles != NULL);

        if (!GetDlgItemInt(hDlg, IDC_DEST_RINGS, NULL, FALSE)) {
            EnableWindow(GetDlgItem(hDlg, IDC_DEST_RINGS), FALSE);
        } else {
            EnableWindow(GetDlgItem(hDlg, IDC_DEST_RINGS), TRUE);
        }

    }

    EnableWindow(GetDlgItem(hDlg, IDC_DEST_PRINTERLIST),
                 IsDlgButtonChecked(hDlg, IDC_DEST_PRINTER) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_DEST_DIRPATH),
                 IsDlgButtonChecked(hDlg, IDC_DEST_DIR) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_BROWSE_DIR),
                 IsDlgButtonChecked(hDlg, IDC_DEST_DIR) == BST_CHECKED &&
                     gConfigData->pServerName == NULL);

    if (gConfigData->pMapiProfiles && IsDlgButtonChecked(hDlg, IDC_DEST_MAILBOX) == BST_CHECKED) {

        EnableWindow(GetDlgItem(hDlg, IDCSTATIC_PROFILE_NAME), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_PROFILENAME), TRUE);

    } else {

        if (gConfigData->pMapiProfiles == NULL)
            CheckDlgButton(hDlg, IDC_DEST_MAILBOX, BST_UNCHECKED);

        EnableWindow(GetDlgItem(hDlg, IDCSTATIC_PROFILE_NAME), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DEST_PROFILENAME), FALSE);
    }
}



BOOL
HandleRecvListViewMessage(
    HWND    hDlg,
    LPNMHDR pNMHdr
    )

/*++

Routine Description:

    Handle notification events from the fax device list

Arguments:

    hDlg - Window handle to the "Receive Options" property page
    pNMHdr - Points to an NMHDR structure

Return Value:

    FALSE if there is no device assigned to the current printer
    TRUE otherwise

--*/

{
    LV_HITTESTINFO  hitTestInfo;
    DWORD           msgPos;
    INT             index;
    NM_LISTVIEW    *pnmlv;
    HWND            hwndLV = pNMHdr->hwndFrom;

    switch (pNMHdr->code) {

    case NM_CLICK:

        //
        // Figure out which item (if any) was clicked on
        //

        msgPos = GetMessagePos();
        hitTestInfo.pt.x = LOWORD(msgPos);
        hitTestInfo.pt.y = HIWORD(msgPos);
        MapWindowPoints(HWND_DESKTOP, hwndLV, &hitTestInfo.pt, 1 );

        index = ListView_HitTest(hwndLV, &hitTestInfo);

        if (index == -1 || ! (hitTestInfo.flags & LVHT_ONITEMSTATEICON))
            return FALSE;

        //
        // Toggle between checked and unchecked state
        //

        ToggleFaxDeviceForReceive(hwndLV, index);
        return TRUE;

    case LVN_KEYDOWN:

        //
        // Use space key to toggle check boxes
        //

        if (((LV_KEYDOWN *) pNMHdr)->wVKey == VK_SPACE) {

            index = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED);

            if (index != -1) {

                ToggleFaxDeviceForReceive(hwndLV, index);
                return TRUE;
            }
        }
        break;

    case LVN_ITEMCHANGING:

        //
        // Validate receive options before switch to another device
        //

        pnmlv = (NM_LISTVIEW *) pNMHdr;

        if ((pnmlv->uChanged & LVIF_STATE) != 0 &&
            (pnmlv->uOldState & LVIS_SELECTED) != (pnmlv->uNewState & LVIS_SELECTED) &&
            ! ValidateReceiveOptionsForSelectedDevices(hDlg, hwndLV))
        {
            return TRUE;
        }

        break;

    case LVN_ITEMCHANGED:

        //
        // Update the contents at the bottom of the page
        // when there is a selection change
        //

        pnmlv = (NM_LISTVIEW *) pNMHdr;

        if ((pnmlv->uChanged & LVIF_STATE) != 0 &&
            (pnmlv->uOldState & LVIS_SELECTED) != (pnmlv->uNewState & LVIS_SELECTED))
        {
            Verbose(("Selection change: %d\n", pnmlv->iItem));
            DoChangeRecvDeviceSel(hDlg, hwndLV);
            UpdateReceiveOptionControls(hDlg);
        }

        break;
    }

    return FALSE;
}



VOID
DoActivateRecvOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the "Receive Options" property page is activated

Arguments:

    hDlg - Window handle to the "Receive Options" property page

Return Value:

    NONE

--*/

{
    HWND    hwndLV;
    INT     index;

    //
    // Reinitialize the fax device list view if necessary
    //

    if (!IsFaxDeviceListInSync(RECEIVE_OPTIONS_PAGE) &&
        (hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)))
    {
        InitFaxDeviceListView(hwndLV, LV_HASCHECKBOX, faxDeviceListViewColumnInfo);

        for (index=0; index < gConfigData->cDevices; index++) {

            if (gConfigData->pDevInfo[index].Flags & FPF_RECEIVE) {

                CheckListViewItem(hwndLV, index);
            }
        }
    }

    SetFaxDeviceListInSync(RECEIVE_OPTIONS_PAGE);

    if (gConfigData->configType & FAXCONFIG_WORKSTATION) {
        HideWindow( GetDlgItem( hDlg, IDC_DEST_EMAIL ) );
    }
}



BOOL
DoSaveRecvOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Receive Options" property page

Arguments:

    hDlg - Handle to the "Receive Options" property page

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT index;

    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Receive Options' page ...\n"));

    if (! GetChangedFlag(RECEIVE_OPTIONS_PAGE))
        return TRUE;

    //
    // Validate the inbound routing options for all fax devics
    //

    for (index=0; index < gConfigData->cDevices; index++) {

        if (! ValidateReceiveOptions(hDlg, index))
            return FALSE;
    }

    //
    // Save the fax device information if this is the last modified page
    //

    return SaveFaxDeviceAndConfigInfo(hDlg, RECEIVE_OPTIONS_PAGE);
}



BOOL
GetDestPrinterName(
    HWND    hwndList,
    LPTSTR  pBuffer,
    INT     cch
    )

/*++

Routine Description:

    Retrieve the name of the currently selected inbound destination printer.
    Also used to get the mapi profile name.

Arguments:

    hwndList - Specifies the inbound destination printer list box
    pBuffer - Specifies a buffer for storing the selected printer name
    cch - Size of the buffer in characters

Return Value:

    TRUE if successful
    FALSE if there is no selection or if there is an error

--*/

{
    INT     sel, length;

    pBuffer[0] = NUL;

    if (hwndList && (sel = SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR) {

        //
        // Get the current selection index. The first item is special:
        // It means to use the sytem default printer and not a specific printer name.
        //

        if ((sel == 0) ||
            (length = SendMessage(hwndList, CB_GETLBTEXTLEN, sel, 0)) != CB_ERR &&
            (length < cch) &&
            SendMessage(hwndList, CB_GETLBTEXT, sel, (LPARAM) pBuffer) != CB_ERR)
        {
            return TRUE;
        }
    }

    return FALSE;
}



VOID
DoChangeInboundRouting(
    HWND    hDlg,
    INT     itemId
    )

/*++

Routine Description:

    Called when the user changes any inbound routing options

Arguments:

    hDlg - Handle to the "Receive Options" property page
    itemId - Specifies which inbound routing option is changed

Return Value:

    NONE

--*/

{
    TCHAR   buffer[MAX_STRING_LEN];
    DWORD   dwValue;
    DWORD   routing, routingMask = 0;
    INT     index;
    HWND    hwndLV;

    if (! (hwndLV = GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)))
        return;

    //
    // Figure out the new setting of the changing item
    //

    switch (itemId) {

    case IDC_DEST_PRINTER:

        routingMask = LR_PRINT;
        break;

    case IDC_DEST_DIR:

        routingMask = LR_STORE;
        break;

    case IDC_DEST_EMAIL:

        routingMask = LR_EMAIL;
        break;

    case IDC_DEST_PRINTERLIST:

        if (! GetDestPrinterName(GetDlgItem(hDlg, IDC_DEST_PRINTERLIST), buffer, MAX_STRING_LEN))
            return;
        break;

    case IDC_DEST_MAILBOX:

        routingMask = LR_INBOX;
        break;

    case IDC_DEST_PROFILENAME:

        if (! GetDestPrinterName(GetDlgItem(hDlg, IDC_DEST_PROFILENAME), buffer, MAX_STRING_LEN))
            return;
        break;

    case IDC_DEST_DIRPATH:
    case IDC_CSID:

        if (! GetDlgItemText(hDlg, itemId, buffer, MAX_STRING_LEN))
            buffer[0] = NUL;
        break;

    case IDC_DEST_RINGS:

        dwValue = GetDlgItemInt( hDlg, itemId, NULL, FALSE );
        break;

    default:

        Assert(FALSE);
        return;
    }

    if (routingMask != 0)
        routing = IsDlgButtonChecked(hDlg, itemId) ? routingMask : 0;

    //
    // Apply the change to selected fax device(s)
    //

    index = -1;

    while ((index = ListView_GetNextItem(hwndLV, index, LVNI_ALL|LVNI_SELECTED)) != -1) {

        PCONFIG_PORT_INFO_2 pDevInfo;

        Assert(index < gConfigData->cDevices);
        pDevInfo = gConfigData->pDevInfo + index;

        if (routingMask) {

            pDevInfo->Mask &= ~routingMask;
            pDevInfo->Mask |= routing;

        } else if (itemId == IDC_DEST_RINGS) {

            pDevInfo->Rings = dwValue;

        } else {

            LPTSTR *ppStr;

            switch (itemId) {

            case IDC_DEST_PRINTERLIST:

                ppStr = &pDevInfo->PrinterName;
                break;

            case IDC_DEST_DIRPATH:

                ppStr = &pDevInfo->DirStore;
                break;

            case IDC_DEST_PROFILENAME:

                ppStr = &pDevInfo->ProfileName;
                break;

            case IDC_CSID:

                ppStr = &pDevInfo->CSID;
                break;

            default:

                Assert(FALSE);
                return;
            }

            MemFree(*ppStr);
            *ppStr = DuplicateString(buffer);
        }
    }
}



BOOL
ReceiveOptionsProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Receive Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;
    LPNMHDR pNMHdr;

    switch (message) {

    case WM_INITDIALOG:

        DoInitRecvOptions(hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_DEST_PRINTER:
        case IDC_DEST_DIR:
        case IDC_DEST_EMAIL:
        case IDC_DEST_MAILBOX:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
                return FALSE;

            CheckDlgButton(hDlg, cmdId,
               (IsDlgButtonChecked(hDlg, cmdId) == BST_CHECKED) ? BST_UNCHECKED : BST_CHECKED);

            UpdateReceiveOptionControls(hDlg);
            break;

        case IDC_BROWSE_DIR:

            if (! DoBrowseForDirectory(hDlg, IDC_DEST_DIRPATH, IDS_INBOUND_DIR))
                return TRUE;

            cmdId = IDC_DEST_DIRPATH;
            break;

        case IDC_DEST_PROFILENAME:
        case IDC_DEST_PRINTERLIST:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                return TRUE;
            break;

        case IDC_DEST_DIRPATH:
        case IDC_DEST_RINGS:

            //
            // We would like to change our internal data only after EN_KILLFOCUS.
            // But the list view control gets selection change message before
            // the edit controls get kill focus message.
            //
            //

            if (insideSetDlgItemText) {
                return TRUE;
            }

            if (cmdId == IDC_DEST_RINGS && GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE) {
                BOOL Rslt; DWORD Value;
                Value = GetDlgItemInt(hDlg, IDC_DEST_RINGS, &Rslt, FALSE);
                if (Rslt && Value == 0) {
                    SetDlgItemText(hDlg, IDC_DEST_RINGS, TEXT("") );
                    MessageBeep(0);
                    return TRUE;
                }
            }

            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_CHANGE) {
                return TRUE;
            }

            break;


        case IDC_CSID:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

            case EN_CHANGE:

                if (insideSetDlgItemText)
                    return TRUE;
                break;

            case EN_KILLFOCUS:

                UpdateFaxDeviceListViewColumns(GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST),
                                               faxDeviceListViewColumnInfo,
                                               1);

            default:

                return TRUE;
            }

            break;

        default:
            return FALSE;
        }

        DoChangeInboundRouting(hDlg, cmdId);
        SetChangedFlag(hDlg, RECEIVE_OPTIONS_PAGE, TRUE);
        return TRUE;

    case WM_NOTIFY:

        pNMHdr = (NMHDR *) lParam;

        if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_FAX_DEVICE_LIST)) {

            if (HandleRecvListViewMessage(hDlg, pNMHdr))
                SetChangedFlag(hDlg, RECEIVE_OPTIONS_PAGE, TRUE);

        } else switch (pNMHdr->code) {

        case PSN_SETACTIVE:

            DoActivateRecvOptions(hDlg);
            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            if (! DoSaveRecvOptions(hDlg)) {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;

            } else {

                SetChangedFlag(hDlg, RECEIVE_OPTIONS_PAGE, FALSE);
                return PSNRET_NOERROR;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, RECEIVE_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Declaration of resource ID constants

Environment:

        Windows NT fax configuration applet

Revision History:

        02/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// String resource IDs
//

#define IDS_QUALITY_NORMAL              262
#define IDS_QUALITY_DRAFT               263
#define IDS_ERROR_DLGTITLE              264
#define IDS_RESOLVE_LINK_FAILED         265
#define IDS_CANNOT_FIND_CPEDITOR        266
#define IDS_CANNOT_OPEN_CPEDITOR        267
#define IDS_CP_FILETYPE                 268
#define IDS_BROWSE_COVERPAGE            269
#define IDS_BAD_CP_EXTENSION            270
#define IDS_CP_DUPLICATE                271
#define IDS_NO_COVERPG_DIR              272
#define IDS_FILENAME_TOOLONG            273
#define IDS_COPY_FILE_FAILED            274
#define IDS_CREATE_LINK_FAILED          275
#define IDS_CONFIRM_DELETE              276
#define IDS_DELETE_PROMPT               277
#define IDS_DELETE_FAILED               278
#define IDS_NO_COUNTRY                  279
#define IDS_PRINTER_CHANGE_TITLE        280
#define IDS_PRINTER_CHANGE_PROMPT       281
#define IDS_NO_SEND_DEVICE              282
#define IDS_DEVICE_NAME_COLUMN          283
#define IDS_STATUS_COLUMN               284
#define IDS_NO_FAX_PRINTER              285
#define IDS_INBOUND_DIR                 286
#define IDS_DEFAULT_PRINTER             287
#define IDS_CATEGORY                    288
#define IDS_LOGGING_LEVEL               289
#define IDS_DIALING                     290
#define IDS_CSID_COLUMN                 291
#define IDS_TSID_COLUMN                 292
#define IDS_STATUS_AVAILABLE            293
#define IDS_STATUS_UNAVAILABLE          294
#define IDS_STATUS_SENDING              295
#define IDS_STATUS_RECEIVING            296
#define IDS_STATUS_ABORTING             297
#define IDS_STATUS_ROUTING              298
#define IDS_STATUS_DIALING              299
#define IDS_STATUS_COMPLETED            300
#define IDS_STATUS_HANDLED              301
#define IDS_STATUS_BUSY                 302
#define IDS_STATUS_NO_ANSWER            303
#define IDS_STATUS_BAD_ADDRESS          304
#define IDS_STATUS_NO_DIAL_TONE         305
#define IDS_STATUS_DISCONNECTED         306
#define IDS_STATUS_FATAL_ERROR          307
#define IDS_STATUS_NOT_FAX_CALL         308
#define IDS_STATUS_CALL_DELAYED         309
#define IDS_STATUS_CALL_BLACKLISTED     310
#define IDS_STATUS_SEPARATOR            311
#define IDS_LOGGING_NONE                312
#define IDS_LOGGING_MIN                 313
#define IDS_LOGGING_MED                 314
#define IDS_LOGGING_MAX                 315
#define IDS_DELETE_PRINTER_PROMPT       316
#define IDS_DELETE_PRINTER_MESSAGE      317
#define IDS_DELETE_NO_PERMISSION        318
#define IDS_DELETE_PRINTER_FAILED       319
#define IDS_ADD_PRINTER_FAILED          320
#define IDS_NO_FAX_SERVICE              321
#define IDS_INVALID_PRINTER_NAME_TITLE  322
#define IDS_INVALID_LOCAL_PRINTER_NAME  323
#define IDS_INVALID_REMOTE_PRINTER_NAME 324
#define IDS_ARCHIVE_DIR                 325
#define IDS_DIR_TOO_LONG                326
#define IDS_INVALID_INBOUND_OPTIONS     327
#define IDS_NO_INBOUND_ROUTING          328
#define IDS_MISSING_INBOUND_DIR         329
#define IDS_MISSING_PROFILE_NAME        330
#define IDS_SETPRINTERDATA_FAILED       331
#define IDS_OPENPRINTER_FAILED          332
#define IDS_SETPRINTERPORTS_FAILED      333
#define IDS_MISSING_ARCHIVEDIR          334
#define IDS_NULL_SERVICE_HANDLE         335
#define IDS_FAXSETCONFIG_FAILED         336
#define IDS_FAXSETPORT_FAILED           337
#define IDS_FAXSETLOCINFO_FAILED        338
#define IDS_DEFAULT_SHARE               339
#define IDS_DEVICE_STATUS               340
#define IDS_DEVICE_STATUS_IDLE          341
#define IDS_DEVICE_STATUS_ERROR         342
#define IDS_DEFAULT_PROFILE             343
#define IDS_PRIORITY_CHANGE_TITLE       344
#define IDS_PRIORITY_CHANGE_MESSAGE     345
#define IDS_STATUS_INITIALIZING         346
#define IDS_STATUS_OFFLINE              347
#define IDS_NO_FAXSERVER                348
#define IDS_SERVER_NOTALIVE             349
#define IDS_INVALID_SHARENAME           350
#define IDS_DEVICE_BUSY                 351
#define IDS_WARNING_DLGTITLE            352
#define IDS_NONEXISTENT_PRINTER         353
#define IDS_STATUS_ANSWERED             354
#define IDS_NO_AUTHORITY                355

//
// Dialog resource IDs
//

#define IDD_CLIENT_OPTIONS              100
#define IDD_USER_INFO                   101
#define IDD_CLIENT_COVERPG              102
#define IDD_SERVER_OPTIONS              103
#define IDD_SERVER_COVERPG              104
#define IDD_SEND_OPTIONS                105
#define IDD_RECEIVE_OPTIONS             106
#define IDD_DEVICE_STATUS               107
#define IDD_LOGGING                     108
#define IDD_DEVICE_PRIORITY             109
#define IDD_LOCAL_PRINTER               110
#define IDD_PRINTER_CONNECTION          111
#define IDD_RECEIVE_STATUS              112
#define IDD_SEND_STATUS                 113
#define IDD_SERVER_GENERAL              114
#define IDD_STATUS_OPTIONS              115

#define IDC_STATIC                      -1
#define IDC_PRINTER_LIST                300
#define IDC_NEW_PRINTER                 301
#define IDC_DELETE_PRINTER              302
#define IDC_SEND_ASAP                   303
#define IDC_SEND_AT_CHEAP               304
#define IDC_SEND_AT_TIME                305
#define IDC_PAPER_SIZE                  306
#define IDC_IMAGE_QUALITY               307
#define IDC_PORTRAIT                    308
#define IDC_LANDSCAPE                   309
#define IDC_BILLING_CODE                310
#define IDC_PRINTER_NAME                311
#define IDC_EMAIL                       312

#define IDC_TC_AT_TIME                  320
#define IDC_SEND_WHEN_HOUR              321
#define IDC_TIME_SEP                    322
#define IDC_SEND_WHEN_MINUTE            323
#define IDC_SEND_WHEN_AMPM              324
#define IDC_TIME_ARROW                  325

#define IDC_TC_CHEAP_BEGIN              330
#define IDC_CHEAP_BEGIN_HOUR            331
#define IDC_TIME_SEP1                   332
#define IDC_CHEAP_BEGIN_MINUTE          333
#define IDC_CHEAP_BEGIN_AMPM            334
#define IDC_CHEAP_BEGIN_TARROW          335

#define IDC_TC_CHEAP_END                340
#define IDC_CHEAP_END_HOUR              341
#define IDC_TIME_SEP2                   342
#define IDC_CHEAP_END_MINUTE            343
#define IDC_CHEAP_END_AMPM              344
#define IDC_CHEAP_END_TARROW            345

#define IDC_SENDER_NAME                 350
#define IDC_SENDER_FAX_NUMBER           351
#define IDC_SENDER_MAILBOX              352
#define IDC_SENDER_COMPANY              353
#define IDC_SENDER_ADDRESS              354
#define IDC_SENDER_TITLE                355
#define IDC_SENDER_DEPT                 356
#define IDC_SENDER_OFFICE_LOC           357
#define IDC_SENDER_OFFICE_TL            358
#define IDC_SENDER_HOME_TL              359
#define IDC_SENDER_BILLING_CODE         360

#define IDC_COVERPG_LIST                400
#define IDC_COVERPG_ADD                 401
#define IDC_COVERPG_NEW                 402
#define IDC_COVERPG_OPEN                403
#define IDC_COVERPG_REMOVE              404

#define IDC_TSID                        450
#define IDC_USE_SERVERCP                451
#define IDC_ARCHIVE_CHECKBOX            452
#define IDC_ARCHIVE_DIRECTORY           453

#define IDC_FAX_DEVICE_LIST             500
#define IDC_MOVEUP                      501
#define IDC_MOVEDOWN                    502

#define IDC_DEST_PRINTER                550
#define IDC_DEST_PRINTERLIST            551
#define IDC_DEST_DIR                    552
#define IDC_DEST_DIRPATH                553
#define IDC_BROWSE_DIR                  554
#define IDC_DEST_EMAIL                  555
#define IDC_DEST_MAILBOX                556
#define IDC_DEST_PROFILENAME            557
#define IDC_CSID                        558
#define IDC_ALLOW_EMAIL                 559
#define IDC_DEST_RINGS                  560
#define IDC_DEST_PROFILENAME_STATIC     561

#define IDC_NUMRETRIES                  600
#define IDC_RETRY_INTERVAL              601
#define IDC_MAXJOBLIFE                  602
#define IDC_USE_DEVICE_TSID             603
#define IDC_PRINT_BANNER                604

#define IDC_DETAILS                     650
#define IDC_REFRESH                     651

#define IDC_LOGGING_LIST                700
#define IDC_LOG_NONE                    701
#define IDC_LOG_MIN                     702
#define IDC_LOG_MED                     703
#define IDC_LOG_MAX                     704

#define IDC_DEVSTAT_DEVICE              800
#define IDC_DEVSTAT_SENDER              801
#define IDC_DEVSTAT_TO                  802
#define IDC_DEVSTAT_STARTEDAT           803
#define IDC_DEVSTAT_DOCUMENT            804
#define IDC_DEVSTAT_STATUS              805
#define IDC_DEVSTAT_FAXNUMBER           806
#define IDC_DEVSTAT_SUBMITTEDAT         807
#define IDC_DEVSTAT_PRINTEDON           808
#define IDC_DEVSTAT_TOTAL_BYTES         809
#define IDC_DEVSTAT_CURRENT_PAGE        810
#define IDC_DEVSTAT_TOTAL_PAGES         811

#define IDC_STATUS_TASKBAR              900
#define IDC_STATUS_ONTOP                901
#define IDC_STATUS_VISUAL               902
#define IDC_STATUS_SOUND                903
#define IDC_STATUS_ANSWER               904
#define IDC_STATUS_MANUAL               905

//
// Control IDs for static text and group box
//

#define IDCSTATIC_CLIENT_OPTIONS        1001
#define IDCSTATIC_FAX_PRINTERS          1002
#define IDCSTATIC_TIME_TO_SEND          1003
#define IDCSTATIC_PRINT_SETUP           1004
#define IDCSTATIC_PAPER_SIZE            1005
#define IDCSTATIC_IMAGE_QUALITY         1006
#define IDCSTATIC_ORIENTATION           1007
#define IDCSTATIC_BILLING_CODE          1008
#define IDCSTATIC_COVER_PAGE            1009
#define IDCSTATIC_PERSONALCP            1010
#define IDCSTATIC_USERINFO              1011
#define IDCSTATIC_FULLNAME              1012
#define IDCSTATIC_FAX_NUMBER_GROUP      1013
#define IDCSTATIC_COUNTRY               1014
#define IDCSTATIC_FAX_NUMBER            1015
#define IDCSTATIC_OPEN_PAREN            1016
#define IDCSTATIC_CLOSE_PAREN           1017
#define IDCSTATIC_MAILBOX               1018
#define IDCSTATIC_TITLE                 1019
#define IDCSTATIC_COMPANY               1020
#define IDCSTATIC_OFFICE                1021
#define IDCSTATIC_DEPT                  1022
#define IDCSTATIC_HOME_PHONE            1023
#define IDCSTATIC_WORK_PHONE            1024
#define IDCSTATIC_ADDRESS               1025
#define IDCSTATIC_SERVER_OPTIONS        1026
#define IDCSTATIC_RETRY_GROUP           1027
#define IDCSTATIC_NUMRETRIES            1028
#define IDCSTATIC_RETRY_INTERVAL        1029
#define IDCSTATIC_MAXJOBLIFE            1030
#define IDCSTATIC_SERVERCP              1033
#define IDCSTATIC_SEND_OPTIONS          1034
#define IDCSTATIC_FAX_DEVICES           1035
#define IDCSTATIC_TSID                  1036
#define IDCSTATIC_CHEAP_BEGIN           1037
#define IDCSTATIC_CHEAP_END             1038
#define IDCSTATIC_RECEIVE_OPTIONS       1039
#define IDCSTATIC_DEVICE_OPTIONS        1040
#define IDCSTATIC_CSID                  1041
#define IDCSTATIC_PROFILE_NAME          1042
#define IDCSTATIC_PRIORITY              1043
#define IDCSTATIC_DEVICE_STATUS         1044
#define IDCSTATIC_LOGGING               1045
#define IDCSTATIC_LOGGING_CATEGORIES    1046
#define IDCSTATIC_LOGGING_LEVEL         1047
#define IDCSTATIC_ADD_LOCAL_PRINTER     1048
#define IDCSTATIC_ADD_REMOTE_PRINTER    1049
#define IDCSTATIC_LOCATION_LIST         1050
#define IDCSTATIC_DIALING_ICON          1051
#define IDCSTATIC_USERINFO_ICON         1052
#define IDCSTATIC_SEND_ICON             1053
#define IDCSTATIC_RECEIVE_ICON          1054
#define IDCSTATIC_STATUS_ICON           1055
#define IDCSTATIC_LOGGING_ICON          1056
#define IDCSTATIC_FAXOPTS_ICON          1057
#define IDCSTATIC_COVERPAGE_ICON        1058
#define IDCSTATIC_EMAIL                 1059
#define IDCSTATIC_STATUS_OPTIONS        1060
//
// Icon resource IDs
//

#define IDI_USERINFO                    259
#define IDI_FAXOPTS                     260
#define IDI_COVERPG                     261
#define IDI_DIALING                     262
#define IDI_SEND                        263
#define IDI_RECEIVE                     264
#define IDI_PRIORITY                    265
#define IDI_STATUS                      266
#define IDI_LOGGING                     267
#define IDI_ARROWUP                     268
#define IDI_ARROWDOWN                   269
#define IDI_ARROWLEFT                   270
#define IDI_ARROWRIGHT                  271

//
// Bitmap resource IDs
//

#define IDB_CHECKSTATES                 256

#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\service.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.c

Abstract:

    Functions for restarting fax and spooler services

Environment:

	Windows NT fax configuration DLL

Revision History:

	05/28/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxcpl.h"

//
// Name of fax and spooler services
//

#define FAX_SERVICE_NAME        TEXT("Fax")
#define SPOOLER_SERVICE_NAME    TEXT("Spooler")

//
// Information about list of dependent services which we stopped
//

typedef struct {

    PVOID   pNext;
    TCHAR   serviceName[1];

} DEPENDENT_SERVICE_LIST, *PDEPENDENT_SERVICE_LIST;



BOOL
MyStartService(
    LPTSTR pServerName,
    LPTSTR pServiceName
    )

/*++

Routine Description:

    Start the specified service on the specified server and
    wait for the service to be in the running state

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine
    pServiceName - Specifies the name of the service to be started

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  serviceStatus;
    BOOL            success = FALSE;

    Verbose(("Starting service '%ws' ...\n", pServiceName));

    //
    // Find the specified service and start executing it
    //

    if ((hSvcMgr = OpenSCManager(pServerName, NULL, SC_MANAGER_ALL_ACCESS)) &&
        (hService = OpenService(hSvcMgr, pServiceName, SERVICE_ALL_ACCESS)) &&
        (StartService(hService, 0, NULL) || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING) &&
        QueryServiceStatus(hService, &serviceStatus))
    {
        while (serviceStatus.dwCurrentState != SERVICE_RUNNING) {

            DWORD checkPoint = serviceStatus.dwCheckPoint;

            Verbose(("Waiting for service '%ws' to run: state = %d\n",
                     pServiceName,
                     serviceStatus.dwCurrentState));

            Sleep(serviceStatus.dwWaitHint);

            if (!QueryServiceStatus(hService, &serviceStatus) ||
                checkPoint == serviceStatus.dwCheckPoint)
            {
                break;
            }
        }

        success = (serviceStatus.dwCurrentState == SERVICE_RUNNING);
    }

    //
    // Cleanup before returning to the caller
    //

    if (! success)
        Error(("Failed to start service '%ws': %d\n", pServiceName, GetLastError()));

    if (hService)
        CloseServiceHandle(hService);

    if (hSvcMgr)
        CloseServiceHandle(hSvcMgr);

    return success;
}



BOOL
MyStopService(
    LPTSTR  pServerName,
    LPTSTR  pServiceName,
    PDEPENDENT_SERVICE_LIST *ppDependentList
    )

/*++

Routine Description:

    Stop the specified service (as well as any services that depend on it)
    on the specified server and wait for the service to be in a non-running state

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine
    pServiceName - Specifies the name of the service to be stopped
    ppDependentList - Remember the list of dependent services which we stopped

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;
    BOOL        success = FALSE;

    Verbose(("Stopping service '%ws' ...\n", pServiceName));

    if ((hSvcMgr = OpenSCManager(pServerName, NULL, SC_MANAGER_ALL_ACCESS)) &&
        (hService = OpenService(hSvcMgr, pServiceName, SERVICE_ALL_ACCESS)))
    {
        LPENUM_SERVICE_STATUS   pEnumStatus = NULL;
        DWORD                   cb, count, index;
        SERVICE_STATUS          serviceStatus;

        //
        // Find all active services which depend on the current service
        // and call ourselves recursively to stop those services first
        //

        success = TRUE;

        if (! EnumDependentServices(hService, SERVICE_ACTIVE, NULL, 0, &cb, &count)) {

            if (GetLastError() == ERROR_MORE_DATA &&
                (pEnumStatus = (LPENUM_SERVICE_STATUS) MemAlloc(cb)) &&
                EnumDependentServices(hService, SERVICE_ACTIVE, pEnumStatus, cb, &cb, &count))
            {
                for (index=0; success && index < count; index++) {

                    success = MyStopService(pServerName,
                                            pEnumStatus[index].lpServiceName,
                                            ppDependentList);
                }
            }

            MemFree(pEnumStatus);
        }

        //
        // Stop the current service and wait for it to die
        //

        if (success) {

            ControlService(hService, SERVICE_CONTROL_STOP, &serviceStatus);

            if (success = QueryServiceStatus(hService, &serviceStatus)) {

                while (serviceStatus.dwCurrentState != SERVICE_STOPPED) {

                    DWORD   checkPoint = serviceStatus.dwCheckPoint;

                    Verbose(("Waiting for service '%ws' to stop: state = %d\n",
                             pServiceName,
                             serviceStatus.dwCurrentState));
        
                    Sleep(serviceStatus.dwWaitHint);

                    if (!QueryServiceStatus(hService, &serviceStatus) ||
                        checkPoint == serviceStatus.dwCheckPoint)
                    {
                        break;
                    }
                }

                success = (serviceStatus.dwCurrentState == SERVICE_STOPPED);
            }
        }
    }

    //
    // If the service has been successfully stopped, remember its name
    // so that we can restart it later.
    //

    if (success) {

        PDEPENDENT_SERVICE_LIST p;

        if (p = MemAlloc(offsetof(DEPENDENT_SERVICE_LIST, serviceName) +
                         SizeOfString(pServiceName)))
        {
            _tcscpy(p->serviceName, pServiceName);
            p->pNext = *ppDependentList;
            *ppDependentList = p;
        }

        success = (p != NULL);
    }

    //
    // Cleanup before returning to the caller
    //

    if (! success)
        Error(("Failed to stop service '%ws': %d\n", pServiceName, GetLastError()));

    if (hService)
        CloseServiceHandle(hService);

    if (hSvcMgr)
        CloseServiceHandle(hSvcMgr);

    return success;
}



BOOL
StartFaxService(
    LPTSTR  pServerName
    )

/*++

Routine Description:

    Start the fax service and 

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    success = FALSE;

    //
    // Start the fax service and wait for it to be in the running state
    //

    if (MyStartService(pServerName, FAX_SERVICE_NAME)) {

        HANDLE  hFaxServerEvent;

        //
        // Wait for the fax service to complete its initialization
        //

        if (hFaxServerEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("FaxServerEvent"))) {

            WaitForSingleObject(hFaxServerEvent, INFINITE);
            CloseHandle(hFaxServerEvent);
            success = TRUE;

        } else
            Error(("Couldn't open a handle to the fax service event: %d\n", GetLastError()));
    }

    return success;
}



BOOL
RestartFaxAndSpoolerServices(
    LPTSTR  pServerName
    )

/*++

Routine Description:

    Restart fax and spooler services after fax configuration settings are changed

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEPENDENT_SERVICE_LIST p, pDependents = NULL;
    BOOL result;

    //
    // Fax service must be stopped after the spooler service
    // because it's a dependent service of the spooler.
    // 
    // Start the fax and spooler services in the opposite order,
    // i.e., first start the fax service and then the spooler service.
    //

    result = MyStopService(pServerName, SPOOLER_SERVICE_NAME, &pDependents) &&
             MyStopService(pServerName, FAX_SERVICE_NAME, &pDependents) &&
             StartFaxService(pServerName);

    //
    // Start other services which we have stopped above
    //

    while (pDependents) {

        if (result)
            result = MyStartService(pServerName, pDependents->serviceName);

        p = pDependents;
        pDependents = p->pNext;
        MemFree(p);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\srvopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    srvopts.c

Abstract:

    Functions for handling events in the "Server Options" tab of
    the fax server configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"



VOID
DoInitServerOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Perform one-time initialization of "Server Options" property page

Arguments:

    hDlg - Window handle to the "Server Options" property page

Return Value:

    NONE

--*/

{
    PFAX_CONFIGURATION pFaxConfig;

    //
    // Connect to the fax service and retrieve the list of fax devices
    //

    GetFaxDeviceAndConfigInfo();

    //
    // Initialize retries characteristics and toll prefix list boxes
    //

    if (pFaxConfig = gConfigData->pFaxConfig) {

        insideSetDlgItemText = TRUE;

        SetDlgItemInt(hDlg, IDC_NUMRETRIES, pFaxConfig->Retries, FALSE);
        SetDlgItemInt(hDlg, IDC_RETRY_INTERVAL, pFaxConfig->RetryDelay, FALSE);
        SetDlgItemInt(hDlg, IDC_MAXJOBLIFE, pFaxConfig->DirtyDays, FALSE);

        insideSetDlgItemText = FALSE;

        CheckDlgButton(hDlg, IDC_PRINT_BANNER, pFaxConfig->Branding);
        CheckDlgButton(hDlg, IDC_USE_DEVICE_TSID, pFaxConfig->UseDeviceTsid);
    }
}



BOOL
DoSaveServerOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Server Options" property page

Arguments:

    hDlg - Handle to the "Server Options" property page

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAX_CONFIGURATION  pFaxConfig;
    BOOL                success;
    DWORD               value;

    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Server Options' page ...\n"));

    if (! GetChangedFlag(SERVER_OPTIONS_PAGE))
        return TRUE;

    if (pFaxConfig = gConfigData->pFaxConfig) {

        //
        // Retrieve the information in the text fields
        //

        value = GetDlgItemInt(hDlg, IDC_NUMRETRIES, &success, FALSE);

        if (success)
            pFaxConfig->Retries = value;

        value = GetDlgItemInt(hDlg, IDC_RETRY_INTERVAL, &success, FALSE);

        if (success)
            pFaxConfig->RetryDelay = value;

        value = GetDlgItemInt(hDlg, IDC_MAXJOBLIFE, &success, FALSE);

        if (success)
            pFaxConfig->DirtyDays = value;

        pFaxConfig->Branding = IsDlgButtonChecked(hDlg, IDC_PRINT_BANNER);
        pFaxConfig->UseDeviceTsid = IsDlgButtonChecked(hDlg, IDC_USE_DEVICE_TSID);
    }

    //
    // Save the fax device information if this is the last modified page
    //

    return SaveFaxDeviceAndConfigInfo(hDlg, SERVER_OPTIONS_PAGE);
}



BOOL
ServerOptionsProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Server Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

#define MAX_RETRIES         15
#define MAX_RETRY_INTERVAL  1440
#define MAX_JOBLIFE         365

{
    INT cmdId;

    switch (message) {

    case WM_INITDIALOG:

        DoInitServerOptions(hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_PRINT_BANNER:
        case IDC_USE_DEVICE_TSID:

            break;

        case IDC_NUMRETRIES:
        case IDC_RETRY_INTERVAL:
        case IDC_MAXJOBLIFE:

            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE && !insideSetDlgItemText) {

                INT     maxVal, curVal;
                BOOL    valid;
                HWND    hwndText;

                maxVal = (cmdId == IDC_NUMRETRIES) ? MAX_RETRIES :
                         (cmdId == IDC_RETRY_INTERVAL) ? MAX_RETRY_INTERVAL : MAX_JOBLIFE;

                hwndText = GetDlgItem(hDlg, cmdId);
                curVal = GetDlgItemInt(hDlg, cmdId, &valid, FALSE);

                if (curVal > maxVal) {

                    valid = FALSE;
                    curVal = maxVal;
                }

                if (! valid) {

                    MessageBeep(MB_OK);
                    insideSetDlgItemText = TRUE;
                    SetDlgItemInt(hDlg, cmdId, curVal, FALSE);
                    SendMessage(hwndText, EM_SETSEL, 0, -1);
                    insideSetDlgItemText = FALSE;
                }

                break;
            }

            return TRUE;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, SERVER_OPTIONS_PAGE, TRUE);
        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_APPLY) {

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            if (! DoSaveServerOptions(hDlg)) {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;

            } else {

                SetChangedFlag(hDlg, SERVER_OPTIONS_PAGE, FALSE);
                return PSNRET_NOERROR;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, SERVER_OPTIONS_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\servercp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    servercp.c

Abstract:

    Functions for handling events in the "Server Cover Page" tab of
    the fax client configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"
#include "coverpg.h"



VOID
DoActivateServerCoverPage(
    HWND    hDlg
    )

/*++

Routine Description:

    Called when the "Server Cover Page" property page is activated

Arguments:

    hDlg - Window handle to the "Server Cover Page" property page

Return Value:

    NONE

--*/

{
    //
    // Controls on the "Server Cover Page" page which may be enabled or disabled
    //

    static INT  servercpCtrls[] = {

        IDC_USE_SERVERCP,
        IDC_COVERPG_NEW,
        IDC_COVERPG_OPEN,
        IDC_COVERPG_ADD,
        IDC_COVERPG_REMOVE,
        0,
    };

    BOOL    enabled = FALSE;


    SetChangedFlag(hDlg, SERVER_COVERPG_PAGE, FALSE);

    Verbose(("Updating 'Server Cover Page' page ...\n"));

    //
    // Whether the user must use server-based cover pages
    //

    CheckDlgButton(hDlg, IDC_USE_SERVERCP, gConfigData->pFaxConfig->ServerCp);

    //
    // Initialize cover page controls
    //

    FreeCoverPageInfo(gConfigData->pCPInfo);
    gConfigData->pCPInfo = AllocCoverPageInfo(TRUE);
    InitCoverPageList(gConfigData->pCPInfo, hDlg);

    enabled = gConfigData->pServerName == NULL;

    //
    // Disable or enable the controls depending on whether the user
    // has privilege to perform printer administration.
    //

    EnableControls(hDlg, servercpCtrls, enabled);
}



BOOL
DoSaveServerCoverPage(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the "Server Cover Page" property page

Arguments:

    hDlg - Handle to the "Server Cover Page" property page

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Check if anything on this page was changed
    //

    Verbose(("Saving 'Server Cover Page' page ...\n"));

    if (!GetChangedFlag(SERVER_COVERPG_PAGE)) {
        return TRUE;
    }

    //
    // Whether the user must use server-based cover pages
    //

    gConfigData->pFaxConfig->ServerCp = IsDlgButtonChecked(hDlg, IDC_USE_SERVERCP) ? 1 : 0;

    return SaveFaxDeviceAndConfigInfo(hDlg, SERVER_COVERPG_PAGE);
}



BOOL
ServerCoverPageProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Server Cover Page" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    INT     cmdId;

    switch (message) {

    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:

        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_USE_SERVERCP:

            SetChangedFlag(hDlg, SERVER_COVERPG_PAGE, TRUE);
            return TRUE;

        case IDC_COVERPG_ADD:
        case IDC_COVERPG_NEW:
        case IDC_COVERPG_OPEN:
        case IDC_COVERPG_REMOVE:

            //
            // User clicked one of the buttons for managing cover page files
            //

            cmdId = (cmdId == IDC_COVERPG_REMOVE) ? CPACTION_REMOVE :
                    (cmdId == IDC_COVERPG_OPEN) ? CPACTION_OPEN :
                    (cmdId == IDC_COVERPG_NEW) ? CPACTION_NEW : CPACTION_BROWSE;

            ManageCoverPageList(hDlg,
                                gConfigData->pCPInfo,
                                GetDlgItem(hDlg, IDC_COVERPG_LIST),
                                cmdId);
            return TRUE;

        case IDC_COVERPG_LIST:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {

            case LBN_SELCHANGE:

                UpdateCoverPageControls(hDlg);
                break;

            case LBN_DBLCLK:

                //
                // Double-clicking in the cover page list is equivalent
                // to pressing the "Open" button
                //

                ManageCoverPageList(hDlg,
                                    gConfigData->pCPInfo,
                                    GetDlgItem(hDlg, cmdId),
                                    CPACTION_OPEN);
                break;
            }
            return TRUE;
        }

        break;

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

        case PSN_SETACTIVE:

            DoActivateServerCoverPage(hDlg);
            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            if (! DoSaveServerCoverPage(hDlg)) {

                SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                return PSNRET_INVALID_NOCHANGEPAGE;

            } else {

                SetChangedFlag(hDlg, SERVER_COVERPG_PAGE, FALSE);
                return PSNRET_NOERROR;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, SERVER_COVERPG_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\statopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    statopts.c

Abstract:

    Functions to handle status monitor options dialog

Environment:

        Fax configuration applet

Revision History:

        12/3/96 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"


VOID
DoInitStatusOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Initializes the Status Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/


#define InitStatusOptionsCheckBox(id, pValueName, DefaultValue) \
    CheckDlgButton( hDlg, id, GetRegistryDWord( hRegKey, pValueName, DefaultValue ));

{
    HKEY    hRegKey;



    GetFaxDeviceAndConfigInfo();

    //
    // Open the user info registry key for reading
    //

    if (! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
        return;

    //
    // Fill in the edit text fields
    //

    InitStatusOptionsCheckBox(IDC_STATUS_TASKBAR, REGVAL_TASKBAR, BST_CHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_ONTOP, REGVAL_ALWAYS_ON_TOP, BST_CHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_VISUAL, REGVAL_VISUAL_NOTIFICATION, BST_CHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_SOUND, REGVAL_SOUND_NOTIFICATION, BST_UNCHECKED);
    InitStatusOptionsCheckBox(IDC_STATUS_MANUAL, REGVAL_ENABLE_MANUAL_ANSWER, BST_UNCHECKED);

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);
}


VOID
DoSaveStatusOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the Status Options property sheet page to registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/

#define SaveStatusOptionsCheckBox(id, pValueName) \
            SaveRegistryDWord(hRegKey, pValueName, IsDlgButtonChecked(hDlg, id));

{
    HKEY                hRegKey;
    HWND                hStatWnd;
    BOOL                fSaveConfig = FALSE;

    //
    // Open the user registry key for writing and create it if necessary
    //

    if (! GetChangedFlag(STATUS_OPTIONS_PAGE) ||
        ! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
    {
        return;;
    }

    SaveStatusOptionsCheckBox(IDC_STATUS_TASKBAR, REGVAL_TASKBAR);
    SaveStatusOptionsCheckBox(IDC_STATUS_ONTOP, REGVAL_ALWAYS_ON_TOP);
    SaveStatusOptionsCheckBox(IDC_STATUS_VISUAL, REGVAL_VISUAL_NOTIFICATION);
    SaveStatusOptionsCheckBox(IDC_STATUS_SOUND, REGVAL_SOUND_NOTIFICATION);
    SaveStatusOptionsCheckBox(IDC_STATUS_MANUAL, REGVAL_ENABLE_MANUAL_ANSWER);

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);

    if (IsDlgButtonChecked( hDlg, IDC_STATUS_MANUAL ) == BST_CHECKED &&
        gConfigData->pDevInfo[0].Rings != 99) {

        gConfigData->pDevInfo[0].Rings = 99;

        fSaveConfig = TRUE;

    } else if (gConfigData->pDevInfo->Rings == 99) {

        gConfigData->pDevInfo[0].Rings = 2;

        fSaveConfig = TRUE;
    }

    if (fSaveConfig) {
        SaveFaxDeviceAndConfigInfo( hDlg, STATUS_OPTIONS_PAGE );
    }

    //
    // Notify the status app that the configuration has changed.
    // The Window Class and message in the following two lines
    // are hard coded.  If you change them, then they must also
    // be changed in the Fax Status Monitor
    //

    hStatWnd = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hStatWnd) {
        PostMessage(hStatWnd, WM_USER + 203, 0, 0);
    }
}


BOOL
StatusOptionsProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "Status Options" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    LPNMHDR lpNMHdr = (LPNMHDR) lParam;

    switch (message) {

    case WM_INITDIALOG:

        DoInitStatusOptions( hDlg );
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_STATUS_TASKBAR:
        case IDC_STATUS_ONTOP:
        case IDC_STATUS_VISUAL:
        case IDC_STATUS_SOUND:
        case IDC_STATUS_MANUAL:

            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                break;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, STATUS_OPTIONS_PAGE, TRUE);
        return TRUE;

    case WM_NOTIFY:

        switch (lpNMHdr->code) {

        case PSN_SETACTIVE:

            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveStatusOptions(hDlg);
            SetChangedFlag(hDlg, STATUS_OPTIONS_PAGE, FALSE);
            return PSNRET_NOERROR;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, STATUS_OPTIONS_PAGE);

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\util.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Misc. utility functions used by the fax configuration applet

Environment:

    Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _UTIL_H_
#define _UTIL_H_

//
// Enable or disable the Apply button in the property sheet
// depending on if any of the dialog contents was changed
//

VOID
SetChangedFlag(
    HWND    hDlg,
    INT     pageIndex,
    BOOL    changed
    );

//
// Windows NT fax driver name - currently this name cannot be
// localized so it shouldn't be put into the string resource.
//

#define FAX_DRIVER_NAME TEXT("Windows NT Fax Driver")

//
// Get a list of fax devices available on the system and
// retrieve fax configuration information from the service
//

BOOL
GetFaxDeviceAndConfigInfo(
    VOID
    );

//
// Dispose of fax device and configuration information
//

VOID
FreeFaxDeviceAndConfigInfo(
    VOID
    );

//
// Save fax device and configuration information
//

BOOL
SaveFaxDeviceAndConfigInfo(
    HWND    hDlg,
    INT     pageIndex
    );

//
// Make a duplicate of the specified character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );

//
// Enable or disable a set of controls in a dialog
//

VOID
EnableControls(
    HWND    hDlg,
    INT    *pCtrlIds,
    BOOL    enabled
    );

//
// Show or hide a set of controls in a dialog
//

VOID
ShowControls(
    HWND    hDlg,
    INT    *pCtrlIds,
    BOOL    visible
    );

//
// Limit the maximum length for a number of text fields
//

VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    );

//
// Display an error message dialog
//

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     formatStrId,
    INT     titleStrId,
    ...
    );

#define MAX_TITLE_LEN       128
#define MAX_MESSAGE_LEN     512

//
// A flag to indicate whether we're inside SetDlgItemText call.
// This is a kluge but we have no other way of telling whether
// an EN_CHANGE message is caused by user action or by us calling
// SetDlgItemText.
//

extern BOOL insideSetDlgItemText;

#define MySetDlgItemText(hDlg, itemId, msgText) { \
            insideSetDlgItemText = TRUE; \
            SetDlgItemText(hDlg, itemId, msgText); \
            insideSetDlgItemText = FALSE; \
        }

//
// Browse for a directory
//

BOOL
DoBrowseForDirectory(
    HWND    hDlg,
    INT     textFieldId,
    INT     titleStrId
    );

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    );

//
// Wrapper function for fax service API FaxEnumPorts
//

PVOID
FaxSvcEnumPorts(
    HANDLE  hFaxSvc,
    PDWORD  pcPorts
    );

//
// Wrapper function for fax service API FaxGetDeviceStatus
//

PFAX_DEVICE_STATUS
FaxSvcGetDeviceStatus(
    HANDLE  hFaxSvc,
    DWORD   DeviceId
    );

//
// Destination port names for a printer are separated by comma
//

#define PORTNAME_SEPARATOR  TEXT(',')

//
// Determine whether a list view item is checked or not
//

#define UNCHECKED_STATE INDEXTOSTATEIMAGEMASK(1)
#define CHECKED_STATE   INDEXTOSTATEIMAGEMASK(2)

#define IsListViewItemChecked(hwndLV, index) \
        (ListView_GetItemState(hwndLV, index, LVIS_STATEIMAGEMASK) == CHECKED_STATE)

#define CheckListViewItem(hwndLV, index) \
        ListView_SetItemState(hwndLV, index, CHECKED_STATE, LVIS_STATEIMAGEMASK)

#define UncheckListViewItem(hwndLV, index) \
        ListView_SetItemState(hwndLV, index, UNCHECKED_STATE, LVIS_STATEIMAGEMASK)

//
// Toggle the checkbox associated with the specified list view item
//

VOID
ToggleListViewCheckbox(
    HWND    hwndLV,
    INT     index
    );

//
// Initialize the fax device list view
//

typedef struct {

    INT     columnId;       // column identifier
    INT     columnWidth;    // relative column width

} COLUMNINFO, *PCOLUMNINFO;

VOID
InitFaxDeviceListView(
    HWND        hwndLV,
    DWORD       flags,
    PCOLUMNINFO pColumnInfo
    );

#define LV_HASCHECKBOX  0x0001

#define COLUMN_NONE         0
#define COLUMN_DEVICE_NAME  1
#define COLUMN_CSID         2
#define COLUMN_TSID         3
#define COLUMN_STATUS       4
#define MAX_COLUMNS         5

//
// Refresh columns in the fax device list view
//

VOID
UpdateFaxDeviceListViewColumns(
    HWND        hwndLV,
    PCOLUMNINFO pColumnInfo,
    INT         startColumn
    );

//
// Handle context-sensitive help in property sheet pages
//

BOOL
HandleHelpPopup(
    HWND    hDlg,
    UINT    message,
    UINT    wParam,
    LPARAM  lParam,
    INT     pageIndex
    );

//
// Assemble fax device status string
//

LPTSTR
MakeDeviceStatusString(
    DWORD   state
    );

//
// Get MAPI profiles from server
//

BOOL
GetMapiProfiles(
    VOID
    );

#endif  // !_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\userinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    userinfo.c

Abstract:

    Functions for handling events in the "User Info" tab of
    the fax client configuration property sheet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"
#include "tapiutil.h"



VOID
DoInitUserInfo(
    HWND    hDlg
    )

/*++

Routine Description:

    Initializes the User Info property sheet page with information from the registry

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    NONE

--*/

#define InitUserInfoTextField(id, pValueName) \
        SetDlgItemText(hDlg, id, GetRegistryString(hRegKey, pValueName, buffer, MAX_STRING_LEN))

{
    TCHAR   buffer[MAX_STRING_LEN];
    HKEY    hRegKey;

    //
    // Maximum length for various text fields in the dialog
    //

    static INT textLimits[] = {

        IDC_SENDER_NAME,            128,
        IDC_SENDER_FAX_NUMBER,      64,
        IDC_SENDER_MAILBOX,         64,
        IDC_SENDER_COMPANY,         128,
        IDC_SENDER_ADDRESS,         256,
        IDC_SENDER_TITLE,           64,
        IDC_SENDER_DEPT,            64,
        IDC_SENDER_OFFICE_LOC,      64,
        IDC_SENDER_OFFICE_TL,       64,
        IDC_SENDER_HOME_TL,         64,
        IDC_BILLING_CODE,           64,
        0,
    };

    LimitTextFields(hDlg, textLimits);

    //
    // Open the user info registry key for reading
    //

    if (! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
        return;

    //
    // Initialize the list of countries
    //

    insideSetDlgItemText = TRUE;

    //
    // Fill in the edit text fields
    //

    InitUserInfoTextField(IDC_SENDER_NAME, REGVAL_FULLNAME);
    InitUserInfoTextField(IDC_SENDER_FAX_NUMBER, REGVAL_FAX_NUMBER);
    InitUserInfoTextField(IDC_SENDER_MAILBOX, REGVAL_MAILBOX);
    InitUserInfoTextField(IDC_SENDER_COMPANY, REGVAL_COMPANY);
    InitUserInfoTextField(IDC_SENDER_TITLE, REGVAL_TITLE);
    InitUserInfoTextField(IDC_SENDER_ADDRESS, REGVAL_ADDRESS);
    InitUserInfoTextField(IDC_SENDER_DEPT, REGVAL_DEPT);
    InitUserInfoTextField(IDC_SENDER_OFFICE_LOC, REGVAL_OFFICE);
    InitUserInfoTextField(IDC_SENDER_HOME_TL, REGVAL_HOME_PHONE);
    InitUserInfoTextField(IDC_SENDER_OFFICE_TL, REGVAL_OFFICE_PHONE);
    InitUserInfoTextField(IDC_SENDER_BILLING_CODE, REGVAL_BILLING_CODE);

    insideSetDlgItemText = FALSE;

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);
}



VOID
DoSaveUserInfo(
    HWND    hDlg
    )

/*++

Routine Description:

    Save the information on the User Info property sheet page to registry

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    NONE

--*/

#define SaveUserInfoTextField(id, pValueName) { \
            if (! GetDlgItemText(hDlg, id, buffer, MAX_STRING_LEN)) \
                buffer[0] = NUL; \
            SaveRegistryString(hRegKey, pValueName, buffer); \
        }

{
    TCHAR               buffer[MAX_STRING_LEN];
    HKEY                hRegKey;

    //
    // Open the user registry key for writing and create it if necessary
    //

    if (! GetChangedFlag(USER_INFO_PAGE) ||
        ! (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
    {
        return;
    }

    SaveUserInfoTextField(IDC_SENDER_NAME, REGVAL_FULLNAME);
    SaveUserInfoTextField(IDC_SENDER_FAX_NUMBER, REGVAL_FAX_NUMBER);
    SaveUserInfoTextField(IDC_SENDER_MAILBOX, REGVAL_MAILBOX);
    SaveUserInfoTextField(IDC_SENDER_COMPANY, REGVAL_COMPANY);
    SaveUserInfoTextField(IDC_SENDER_TITLE, REGVAL_TITLE);
    SaveUserInfoTextField(IDC_SENDER_ADDRESS, REGVAL_ADDRESS);
    SaveUserInfoTextField(IDC_SENDER_DEPT, REGVAL_DEPT);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_LOC, REGVAL_OFFICE);
    SaveUserInfoTextField(IDC_SENDER_HOME_TL, REGVAL_HOME_PHONE);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_TL, REGVAL_OFFICE_PHONE);
    SaveUserInfoTextField(IDC_SENDER_BILLING_CODE, REGVAL_BILLING_CODE);

    //
    // Close the registry key before returning to the caller
    //

    RegCloseKey(hRegKey);
}



BOOL
UserInfoProc(
    HWND hDlg,
    UINT message,
    UINT wParam,
    LONG lParam
    )

/*++

Routine Description:

    Procedure for handling the "User Info" tab

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (message) {

    case WM_INITDIALOG:

        //
        // Perform any necessary TAPI initialization
        //

        InitTapiService();

        //
        // Initialize the text fields with information from the registry
        //

        DoInitUserInfo(hDlg);
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_SENDER_NAME:
        case IDC_SENDER_FAX_NUMBER:
        case IDC_SENDER_MAILBOX:
        case IDC_SENDER_COMPANY:
        case IDC_SENDER_ADDRESS:
        case IDC_SENDER_TITLE:
        case IDC_SENDER_DEPT:
        case IDC_SENDER_OFFICE_LOC:
        case IDC_SENDER_OFFICE_TL:
        case IDC_SENDER_HOME_TL:
        case IDC_SENDER_BILLING_CODE:

            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE && !insideSetDlgItemText)
                break;

        default:
            return FALSE;
        }

        SetChangedFlag(hDlg, USER_INFO_PAGE, TRUE);
        return TRUE;

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

        case PSN_SETACTIVE:

            break;

        case PSN_APPLY:

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveUserInfo(hDlg);
            SetChangedFlag(hDlg, USER_INFO_PAGE, FALSE);
            return PSNRET_NOERROR;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        return HandleHelpPopup(hDlg, message, wParam, lParam, USER_INFO_PAGE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\tapiutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.h

Abstract:

    Functions for working with TAPI

Environment:

	Fax configuration applet

Revision History:

	03/16/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_

//
// Perform TAPI initialization if necessary
//

BOOL
InitTapiService(
    VOID
    );

//
// Perform TAPI deinitialization if necessary
//

VOID
DeinitTapiService(
    VOID
    );

//
// Return the default country ID for the current location
//

DWORD
GetDefaultCountryID(
    VOID
    );

//
// Initialize the country list box
//

VOID
InitCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode,
    DWORD   countryId
    );

//
// Handle dialog selection changes in the country list box
//

VOID
SelChangeCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode
    );

//
// Return the country ID of the currently selected country in the list box
//

DWORD
GetCountryListBoxSel(
    HWND    hwndList
    );

//
// Return a country code corresponding to the specified country ID
//

DWORD
GetCountryCodeFromCountryID(
    DWORD   countryId
    );

#endif	// !_TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\tapiutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.c

Abstract:

    Functions for working with TAPI

Environment:

	Fax configuration applet

Revision History:

	03/16/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

NOTE:

    We are calling W-version of TAPI APIs explicitly here because
    tapi.h doesn't properly expand them to A- or W-version.
    
--*/

#include "faxcpl.h"
#include <tapi.h>


//
// Global variables used for accessing TAPI services
//

static HLINEAPP          tapiLineApp = NULL;
static DWORD             tapiVersion = TAPI_CURRENT_VERSION;
static LPLINECOUNTRYLIST pLineCountryList = NULL;



BOOL
GetCountries(
    VOID
    )

/*++

Routine Description:

    Return a list of countries from TAPI

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

NOTE:

    We cache the result of lineGetCountry here since it's incredibly slow.
    This function must be invoked inside a critical section since it updates
    globally shared information.

--*/

#define INITIAL_SIZE_ALL_COUNTRY    22000   // Initial buffer size

{
    DWORD   cbNeeded = INITIAL_SIZE_ALL_COUNTRY;
    INT     repeatCnt = 0;
    LONG    status;

    if (pLineCountryList == NULL) {

        while (TRUE) {

            //
            // Free existing buffer and allocate a new buffer of required size
            //

            MemFree(pLineCountryList);
    
            if (! (pLineCountryList = MemAlloc(cbNeeded))) {

                Error(("Memory allocation failed\n"));
                break;
            }

            //
            // Call TAPI to get the list of countries
            //

            pLineCountryList->dwTotalSize = cbNeeded;
            status = lineGetCountry(0, tapiVersion, pLineCountryList);

            //
            // Retries with a larger buffer size if our initial estimate was too small
            //

            if ((pLineCountryList->dwNeededSize > pLineCountryList->dwTotalSize) &&
                (status == NO_ERROR ||
                 status == LINEERR_STRUCTURETOOSMALL ||
                 status == LINEERR_NOMEM) &&
                (repeatCnt++ == 0))
            {
                cbNeeded = pLineCountryList->dwNeededSize + 1;
                Warning(("LINECOUNTRYLIST size: %d\n", cbNeeded));
                continue;
            }

            if (status != NO_ERROR) {

                Error(("lineGetCountry failed: %x\n", status));
                MemFree(pLineCountryList);
                pLineCountryList = NULL;

            } else
                Verbose(("Number of countries: %d\n", pLineCountryList->dwNumCountries));

            break;
        }
    }

    return pLineCountryList != NULL;
}



VOID CALLBACK
TapiLineCallback(
    DWORD   hDevice,
    DWORD   dwMessage,
    DWORD   dwInstance,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
    )

/*++

Routine Description:

    TAPI line callback function: Even though we don't actually have anything
    to do here, we must provide a callback function to keep TAPI happy.

Arguments:

    hDevice     - Line or call handle
    dwMessage   - Reason for the callback
    dwInstance  - LINE_INFO index
    dwParam1    - Callback parameter #1
    dwParam2    - Callback parameter #2
    dwParam3    - Callback parameter #3

Return Value:

    NONE

--*/

{
}



BOOL
InitTapiService(
    VOID
    )

/*++

Routine Description:

    Perform TAPI initialization if necessary

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   nLineDevs;
    LONG    status;

    if (tapiLineApp == NULL) {

        status = lineInitialize(&tapiLineApp,
                               ghInstance,
                               TapiLineCallback,
                               "Fax Configuration",
                               &nLineDevs);

        if (status != NO_ERROR) {

            Error(("lineInitialize failed: %x\n", status));
            tapiLineApp = NULL;

        } else {

            //
            // Don't call lineNegotiateAPIVersion if nLineDevs is 0.
            //

            Verbose(("Number of lines: %d\n", nLineDevs));

            if (nLineDevs > 0) {

                LINEEXTENSIONID lineExtensionID;

                status = lineNegotiateAPIVersion(tapiLineApp,
                                                 0,
                                                 TAPI_CURRENT_VERSION,
                                                 TAPI_CURRENT_VERSION,
                                                 &tapiVersion,
                                                 &lineExtensionID);

                if (status != NO_ERROR) {

                    Error(("lineNegotiateAPIVersion failed: %x\n", status));
                    tapiVersion = TAPI_CURRENT_VERSION;
                }
            }

            //
            // Get a list of countries from TAPI
            //

            GetCountries();
        }
    }

    return tapiLineApp != NULL;
}



VOID
DeinitTapiService(
    VOID
    )

/*++

Routine Description:

    Perform TAPI deinitialization if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    MemFree(pLineCountryList);
    pLineCountryList = NULL;

    if (tapiLineApp) {

        lineShutdown(tapiLineApp);
        tapiLineApp = NULL;
    }
}



LPLINECOUNTRYENTRY
FindCountry(
    DWORD   countryId
    )

/*++

Routine Description:

    Find the specified country from a list of all countries and
    return a pointer to the corresponding LINECOUNTRYENTRY structure

Arguments:

    countryId - Specifies the country ID we're interested in

Return Value:

    Pointer to a LINECOUNTRYENTRY structure corresponding to the specified country ID
    NULL if there is an error

--*/

{
    LPLINECOUNTRYENTRY  pEntry;
    DWORD               index;

    if (pLineCountryList == NULL || countryId == 0)
        return NULL;

    //
    // Look at each LINECOUNTRYENTRY structure and compare its country ID with
    // the specified country ID
    //

    pEntry = (LPLINECOUNTRYENTRY)
        ((PBYTE) pLineCountryList + pLineCountryList->dwCountryListOffset);

    for (index=0; index < pLineCountryList->dwNumCountries; index++, pEntry++) {

        if (pEntry->dwCountryID == countryId)
            return pEntry;
    }

    return NULL;
}



INT
AreaCodeRules(
    LPLINECOUNTRYENTRY  pEntry
    )

/*++

Routine Description:

    Given a LINECOUNTRYENTRY structure, determine if area code is needed in that country

Arguments:

    pEntry - Points to a LINECOUNTRYENTRY structure

Return Value:

    AREACODE_DONTNEED - Area code is not used in the specified country
    AREACODE_OPTIONAL - Area code is optional in the specified country
    AREACODE_REQUIRED - Area code is required in the specified country

--*/

#define AREACODE_DONTNEED   0
#define AREACODE_REQUIRED   1
#define AREACODE_OPTIONAL   2

{
    if ((pEntry != NULL) &&
        (pEntry->dwLongDistanceRuleSize != 0) &&
        (pEntry->dwLongDistanceRuleOffset != 0))
    {
        LPTSTR  pLongDistanceRule;

        //
        // Get the long distance rules for the specified country
        //

        Assert(pLineCountryList != NULL);

        pLongDistanceRule = (LPTSTR)
            ((PBYTE) pLineCountryList + pEntry->dwLongDistanceRuleOffset);

        //
        // Area code is required in this country
        //

        if (_tcschr(pLongDistanceRule, TEXT('F')) != NULL)
            return AREACODE_REQUIRED;

        //
        // Area code is not needed in this country
        //

        if (_tcschr(pLongDistanceRule, TEXT('I')) == NULL)
            return AREACODE_DONTNEED;
    }

    //
    // Default case: area code is optional in this country
    //

    return AREACODE_OPTIONAL;
}



VOID
UpdateAreaCodeField(
    HWND    hwndAreaCode,
    DWORD   countryId
    )

/*++

Routine Description:

    Update any area code text field associated with a country list box

Arguments:

    hwndAreaCode - Specifies the text field associated with the country list box
    countryId - Currently selected country ID

Return Value:

    NONE

--*/

{
    if (hwndAreaCode != NULL) {
    
        if (AreaCodeRules(FindCountry(countryId)) == AREACODE_DONTNEED) {
    
            SendMessage(hwndAreaCode, WM_SETTEXT, 0, (LPARAM) TEXT(""));
            EnableWindow(hwndAreaCode, FALSE);
    
        } else
            EnableWindow(hwndAreaCode, TRUE);
    }
}



VOID
InitCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode,
    DWORD   countryId
    )

/*++

Routine Description:

    Initialize the country list box

Arguments:

    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field
    countryId - Initially selected country ID

Return Value:

    NONE

--*/

#define MAX_COUNTRY_NAME    256

{
    DWORD               index;
    TCHAR               buffer[MAX_COUNTRY_NAME];
    LPLINECOUNTRYENTRY  pEntry;

    //
    // Disable redraw on the list box and reset its content
    //

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Loop through LINECOUNTRYENTRY structures and
    // add the available selections to the country list box.
    //

    if (pLineCountryList != NULL) {

        pEntry = (LPLINECOUNTRYENTRY)
            ((PBYTE) pLineCountryList + pLineCountryList->dwCountryListOffset);

        for (index=0; index < pLineCountryList->dwNumCountries; index++, pEntry++) {

            if (pEntry->dwCountryNameSize && pEntry->dwCountryNameOffset) {

                wsprintf(buffer, TEXT("%s (%d)"),
                         (PBYTE) pLineCountryList + pEntry->dwCountryNameOffset,
                         pEntry->dwCountryCode);

                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer),
                            pEntry->dwCountryID);
            }
        }
    }

    //
    // Insert None as the very first selection
    //

    LoadString(ghInstance, IDS_NO_COUNTRY, buffer, MAX_COUNTRY_NAME);
    SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) buffer);
    SendMessage(hwndList, CB_SETITEMDATA, 0, 0);

    //
    // Figure out which item in the list should be selected
    //

    if (pLineCountryList != NULL) {

        for (index=0; index <= pLineCountryList->dwNumCountries; index++) {

            if ((DWORD) SendMessage(hwndList, CB_GETITEMDATA, index, 0) == countryId)
                break;
        }

        if (index > pLineCountryList->dwNumCountries)
            index = countryId = 0;

    } else
        index = countryId = 0;

    SendMessage(hwndList, CB_SETCURSEL, index, 0);
    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    //
    // Update the associated area code text field
    //

    UpdateAreaCodeField(hwndAreaCode, countryId);
}



VOID
SelChangeCountryListBox(
    HWND    hwndList,
    HWND    hwndAreaCode
    )

/*++

Routine Description:

    Handle dialog selection changes in the country list box

Arguments:

    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field

Return Value:

    NONE

--*/

{
    UpdateAreaCodeField(hwndAreaCode, GetCountryListBoxSel(hwndList));
}



DWORD
GetCountryListBoxSel(
    HWND    hwndList
    )

/*++

Routine Description:

    Return the country ID of the currently selected country in the list box

Arguments:

    hwndList - Handle to the country list box window

Return Value:

    Currently selected country ID

--*/

{
    LONG msgResult;

    if ((msgResult = SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR ||
        (msgResult = SendMessage(hwndList, CB_GETITEMDATA, msgResult, 0)) == CB_ERR)
    {
        return 0;
    }

    return msgResult;
}



DWORD
GetCountryCodeFromCountryID(
    DWORD   countryId
    )

/*++

Routine Description:

    Return a country code corresponding to the specified country ID

Arguments:

    countryId - Specified the interested country ID

Return Value:

    Country code corresponding to the specified country ID

--*/

{
    LPLINECOUNTRYENTRY  pLineCountryEntry;

    pLineCountryEntry = FindCountry(countryId);
    return pLineCountryEntry ? pLineCountryEntry->dwCountryCode : 0;
}



DWORD
GetDefaultCountryID(
    VOID
    )

/*++

Routine Description:

    Return the default country ID for the current location

Arguments:

    NONE

Return Value:

    Default country ID

--*/

#define INITIAL_LINETRANSLATECAPS_SIZE  5000    // Initial buffer size

{
    DWORD               cbNeeded = INITIAL_LINETRANSLATECAPS_SIZE;
    DWORD               countryId = 0;
    LONG                status;
    INT                 repeatCnt = 0;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;

    if (tapiLineApp == NULL)
        return 0;

    while (TRUE) {

        //
        // Free any existing buffer and allocate a new one with larger size
        //

        MemFree(pTranslateCaps);

        if (! (pTranslateCaps = MemAlloc(cbNeeded))) {

            Error(("Memory allocation failed\n"));
            return 0;
        }

        //
        // Get the LINETRANSLATECAPS structure from TAPI
        //
    
        pTranslateCaps->dwTotalSize = cbNeeded;
        status = lineGetTranslateCaps(tapiLineApp, tapiVersion, pTranslateCaps);

        //
        // Retry if our initial estimated buffer size was too small
        //

        if ((pTranslateCaps->dwNeededSize > pTranslateCaps->dwTotalSize) &&
            (status == NO_ERROR ||
             status == LINEERR_STRUCTURETOOSMALL ||
             status == LINEERR_NOMEM) &&
            (repeatCnt++ == 0))
        {
            cbNeeded = pTranslateCaps->dwNeededSize;
            Warning(("LINETRANSLATECAPS size: %d\n", cbNeeded));
            continue;
        }

        break;
    }

    //
    // Find the current location entry
    //

    if (status != NO_ERROR) {
    
        Error(("lineGetTranslateCaps failed: %x\n", status));

    } else if (pTranslateCaps->dwLocationListSize && pTranslateCaps->dwLocationListOffset) {

        LPLINELOCATIONENTRY pLineLocationEntry;
        DWORD               index;

        pLineLocationEntry = (LPLINELOCATIONENTRY)
            ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);

        for (index=0; index < pTranslateCaps->dwNumLocations; index++, pLineLocationEntry++) {

            if (pLineLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID) {

                countryId = pLineLocationEntry->dwCountryID;
                break;
            }
        }
    }

    MemFree(pTranslateCaps);
    return countryId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\exe\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Declaration of resource ID constants

Environment:

	Windows NT fax configuration applet

Revision History:

	02/22/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// String resource IDs
//

#define IDS_FAX_REMOTE_ADMIN            256
#define IDS_REMOTE_ADMIN_FAILED         257
#define IDS_NAME_TOO_LONG               258

//
// Dialog resource IDs
//

#define IDD_SELECT_FAXSERVER            100
#define IDD_CONNECT_FAXSERVER           101

#define IDC_STATIC                      -1
#define IDC_FAXSERVER_NAME              256

//
// Icon resource IDs
//

#define IDI_FAX_REMOTE_ADMIN            256

#endif	// !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\exe\faxcfg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcfg.c

Abstract:

    Implementation of the control panel applet entry point

Environment:

        Windows NT fax configuration applet

Revision History:

        02/27/96 -davidx-
                Created it.

        05/22/96 -davidx-
                Share the same DLL with remote admin program.

        mm/dd/yy -author-
                description

--*/

#include <stdlib.h>
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <tchar.h>

#include "faxcfg.h"
#include "resource.h"


//
// Name of the remote fax server machine
//

#define MAX_NAME        (MAX_COMPUTERNAME_LENGTH+3)
#define MAX_TITLE_LEN   128
#define MAX_MESSAGE_LEN 512
#define MAX_PAGES       16

HINSTANCE       ghInstance;
INT             gFaxConfigType;
INT             gNumPages;
HPROPSHEETPAGE  ghPropSheetPages[MAX_PAGES];
TCHAR           FaxServerName[MAX_NAME];
TCHAR           TitleStr[MAX_TITLE_LEN];



VOID
DisplayErrorMessage(
    INT     msgStrId
    )

/*++

Routine Description:

    Display an error message dialog box

Arguments:

    msgStrId - Message format string resource ID

Return Value:

    NONE

--*/

{
    TCHAR   buffer[MAX_MESSAGE_LEN];

    if (! LoadString(ghInstance, msgStrId, buffer, MAX_MESSAGE_LEN))
        buffer[0] = 0;

    MessageBox(NULL, buffer, TitleStr, MB_OK | MB_ICONERROR);
}



VOID
MakeTitleString(
    LPTSTR  pServerName
    )

/*++

Routine Description:

    Compose the title string for the remote configuration dialog

Arguments:

    pServerName - Specifies the name of the remote server

Return Value:

    NONE

--*/

{
    if (! LoadString(ghInstance, IDS_FAX_REMOTE_ADMIN, TitleStr, MAX_TITLE_LEN))
        TitleStr[0] = 0;

    if (_tcslen(TitleStr) + _tcslen(pServerName) < MAX_TITLE_LEN)
        _tcscat(TitleStr, pServerName);
}



BOOL CALLBACK
GetFaxServerNameProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for prompting the user to enter a fax server name

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    Depends on message

--*/

{
    switch (uMsg) {

    case WM_INITDIALOG:

        SendDlgItemMessage(hDlg, IDC_FAXSERVER_NAME, EM_LIMITTEXT, MAX_NAME-1, 0);
        SetDlgItemText(hDlg, IDC_FAXSERVER_NAME, FaxServerName);
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_FAXSERVER_NAME:

            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                EnableWindow(GetDlgItem(hDlg, IDOK),
                             GetWindowTextLength(GetDlgItem(hDlg, IDC_FAXSERVER_NAME)) > 0);
            }
            return TRUE;

        case IDOK:

            if (GetWindowTextLength(GetDlgItem(hDlg, IDC_FAXSERVER_NAME)) > 0) {

                GetDlgItemText(hDlg, IDC_FAXSERVER_NAME, FaxServerName, MAX_NAME);
                EndDialog(hDlg, IDOK);

            } else
                MessageBeep(MB_OK);

            return TRUE;

        case IDCANCEL:

            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }

        break;
    }

    return FALSE;
}



DWORD
ConnectFaxServerThread(
    HWND    hDlg
    )

/*++

Routine Description:

    Thread proc for connecting to the remote fax server

Arguments:

    hDlg - Handle to the status dialog

Return Value:

    IDOK if successful, IDCANCEL otherwise

--*/

{
    DWORD   result = IDCANCEL;

    gFaxConfigType = FaxConfigInit(FaxServerName, FALSE);

    if (gFaxConfigType == FAXCONFIG_SERVER &&
        (gNumPages = FaxConfigGetServerPages(ghPropSheetPages, MAX_PAGES)) <= MAX_PAGES)
    {
        result = IDOK;
    }

    PostMessage(hDlg, WM_APP, result, 0);
    return result;
}



BOOL CALLBACK
ConnectFaxServerProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for connecting to the fax server

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    Depends on message

--*/

{
    HANDLE  hThread;
    DWORD   threadId;

    switch (uMsg) {

    case WM_INITDIALOG:

        SetWindowText(hDlg, TitleStr);

        if (hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) ConnectFaxServerThread,
                                   (LPVOID) hDlg,
                                   0,
                                   &threadId))
        {
            CloseHandle(hThread);
        } else
            EndDialog(hDlg, IDCANCEL);

        break;

    case WM_APP:

        EndDialog(hDlg, wParam);
        return TRUE;
    }

    return FALSE;
}



INT
wWinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )

/*++

Routine Description:

    Application entry point

Arguments:

    hInstance - Identifies the current instance of the application
    hPrevInstance - Identifies the previous instance of the application
    lpCmdLine - Specifies the command line for the application.
    nCmdShow - Specifies how the window is to be shown

Return Value:

    0

--*/

{
    PROPSHEETHEADER psh;
    BOOL            cmdlineServerName;
    BOOL            success = FALSE;

    ghInstance = hInstance;

    //
    // Check if the server name is specified on the command line
    //

    if (lpCmdLine && *lpCmdLine) {

        cmdlineServerName = TRUE;

        if (_tcslen(lpCmdLine) > MAX_NAME+2) {

            MakeTitleString(lpCmdLine);
            DisplayErrorMessage(IDS_NAME_TOO_LONG);
            return -1;

        } else
            _tcscpy(FaxServerName, lpCmdLine);

    } else
        cmdlineServerName = FALSE;

    do {

        //
        // Let the user enter the name of fax server computer
        //

        if (! cmdlineServerName &&
            DialogBox(hInstance,
                      MAKEINTRESOURCE(IDD_SELECT_FAXSERVER),
                      NULL,
                      GetFaxServerNameProc) != IDOK)
        {
            break;
        }

        MakeTitleString(FaxServerName);

        //
        // Establish connection to the fax server
        //

        gFaxConfigType = -1;

        if (DialogBox(ghInstance,
                      MAKEINTRESOURCE(IDD_CONNECT_FAXSERVER),
                      NULL,
                      ConnectFaxServerProc) == IDOK)
        {
            ZeroMemory(&psh, sizeof(psh));
            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_USEICONID;
            psh.hwndParent = NULL;
            psh.hInstance = ghInstance;
            psh.pszIcon = MAKEINTRESOURCE(IDI_FAX_REMOTE_ADMIN);
            psh.pszCaption = TitleStr;
            psh.nPages = gNumPages;
            psh.phpage = ghPropSheetPages;

            //
            // Display the property sheet
            //

            success = (PropertySheet(&psh) != -1);
        }

        if (gFaxConfigType >= 0)
            FaxConfigCleanup();

        //
        // Display an error message if the fax server
        // configuration dialog wasn't displayed
        //

        if (! success)
            DisplayErrorMessage(IDS_REMOTE_ADMIN_FAILED);

    } while (!success && !cmdlineServerName);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\dll\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Misc. utility functions used by the fax configuration applet

Environment:

        Fax configuration applet

Revision History:

        03/13/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcpl.h"
#include "forms.h"
#include "cfghelp.h"
#include <shlobj.h>
#include <mapicode.h>
#include <winsprlp.h>

//
// A flag to indicate whether we're inside SetDlgItemText call.
// This is a kluge but we have no other way of telling whether
// an EN_CHANGE message is caused by user action or by us calling
// SetDlgItemText.
//

BOOL insideSetDlgItemText = FALSE;



VOID
SetChangedFlag(
    HWND    hDlg,
    INT     pageIndex,
    BOOL    changed
    )

/*++

Routine Description:

    Enable or disable the Apply button in the property sheet
    depending on if any of the dialog contents was changed

Arguments:

    hDlg - Handle to the property page window
    pageIndex - Specifies the index of current property page
    changed - Specifies whether the Apply button should be enabled

Return Value:

    NONE

--*/

{
    HWND    hwndPropSheet;
    INT     pageMask = (1 << pageIndex);

    //
    // Enable or disable the Apply button as appropriate
    //

    hwndPropSheet = GetParent(hDlg);

    if (changed) {

        PropSheet_Changed(hwndPropSheet, hDlg);
        gConfigData->changeFlag |= pageMask;

    } else {

        gConfigData->changeFlag &= ~pageMask;

        if (gConfigData->changeFlag == 0) {

            PropSheet_UnChanged(hwndPropSheet, hDlg);
        }
    }
}


BOOL
GetMapiProfiles(
    VOID
    )
/*++

Routine Description:

    Connect to the server and get its MAPI profiles.

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if not

--*/
{
    if (gConfigData->pMapiProfiles)
        return TRUE;

    if (!FaxGetMapiProfiles(gConfigData->hFaxSvc, (LPBYTE*) &gConfigData->pMapiProfiles))
    {
        gConfigData->pMapiProfiles = NULL;
        Error(("Cannot retrieve MapiProfiles: %d\n", GetLastError()));
        return FALSE;
    }

    return TRUE;
}



PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    )

/*++

Routine Description:

    Wrapper function for spooler API EnumPrinters

Arguments:

    pServerName - Specifies the name of the print server
    level - Level of PRINTER_INFO_x structure
    pcPrinters - Returns the number of printers enumerated
    dwFlags - Flag bits passed to EnumPrinters

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cb;

    if (! EnumPrinters(dwFlags, pServerName, level, NULL, 0, &cb, pcPrinters) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cb)) &&
        EnumPrinters(dwFlags, pServerName, level, pPrinterInfo, cb, &cb, pcPrinters))
    {
        return pPrinterInfo;
    }

    Error(("EnumPrinters failed: %d\n", GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}



LPTSTR
MakePortNameString(
    VOID
    )

/*++

Routine Description:

    Compose a port name string consisting of all available fax devices

Arguments:

    NONE

Return Value:

    Pointer to a list of comma-separated port names
    NULL if there is an error

--*/

{
    LPTSTR  pPortName, p;
    INT     index, cb;

    //
    // Connect to the fax service and retrieve the list of fax devices
    //

    GetFaxDeviceAndConfigInfo();

    //
    // Figure out the total size of port name string
    //

    for (index=cb=0; index < gConfigData->cDevices; index++)
        cb += SizeOfString(gConfigData->pDevInfo[index].DeviceName);

    if (cb == 0 || !(p = pPortName = MemAlloc(cb)))
        return NULL;

    //
    // Compose the port name string
    //

    for (index=0; index < gConfigData->cDevices; index++) {

        if (p != pPortName)
            *p++ = PORTNAME_SEPARATOR;

        _tcscpy(p, gConfigData->pDevInfo[index].DeviceName);
        p += _tcslen(p);
    }

    return pPortName;
}



BOOL
CheckFaxServerType(
    HWND    hDlg,
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Make sure the print server has fax server software installed

Arguments:

    hDlg - Handle to the currently active property page
    pPrinterName - Specifies the name of the shared printer

Return Value:

    TRUE if the fax server software is installed
    FALSE otherwise

--*/

{
    HANDLE  hServer;
    LPTSTR  p, pNoRemoteDrivers;
    INT     status = 0;

    //
    // Derived the server name from the share name
    //

    Assert(_tcsncmp(pPrinterName, TEXT("\\\\"), 2) == EQUAL_STRING);
    p = pPrinterName + 2;

    if (p = _tcschr(p, TEXT(PATH_SEPARATOR))) {

        *p = NUL;

        if (OpenPrinter(pPrinterName, &hServer, NULL)) {


            if (pNoRemoteDrivers = GetPrinterDataStr(hServer, SPLREG_NO_REMOTE_PRINTER_DRIVERS)) {

                if (_tcsstr(pNoRemoteDrivers, DRIVER_NAME) != NULL)
                    status = IDS_NO_FAXSERVER;

                MemFree(pNoRemoteDrivers);
            }

            ClosePrinter(hServer);

        } else
            status = IDS_SERVER_NOTALIVE;

        *p = TEXT(PATH_SEPARATOR);

    } else
        status = IDS_INVALID_SHARENAME;

    if (status != 0)
        DisplayMessageDialog(hDlg, 0, 0, status);

    return (status == 0);
}



PVOID
FaxSvcEnumPorts(
    HANDLE hFaxSvc,
    PDWORD pcPorts
    )

/*++

Routine Description:

    Wrapper function for fax service API FaxEnumPorts

Arguments:

    hFaxSvc - Specifies a coneection handle to the fax service
    DWORD - Specifies the level of FAX_PORT_INFO structure desired
    pcPorts - Returns the number of devices managed by the fax service

Return Value:

    Pointer to an array of FAX_PORT_INFO_x structures
    NULL if there is an error

--*/

{
    PVOID pSvcPortInfo = NULL;


    if (!FaxEnumPorts(hFaxSvc, (PFAX_PORT_INFO*) &pSvcPortInfo, pcPorts)) {
        Error(("FaxEnumPorts failed: %d\n", GetLastError()));
        return NULL;
    }

    return pSvcPortInfo;
}



BOOL
GetFaxDeviceAndConfigInfo(
    VOID
    )

/*++

Routine Description:

    Get a list of fax devices available on the system and
    retrieve fax configuration information from the service

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAX_PORT_INFO      pSvcPortInfo;
    PFAX_PORT_INFO      pSvcPort;
    PCONFIG_PORT_INFO_2 pDevInfo;
    DWORD               index;
    DWORD               cPorts;
    DWORD               cb;
    HANDLE              FaxPortHandle;
    LPBYTE              RoutingInfo;


    Verbose(("Enumerating fax ports ...\n"));
    Assert(ValidConfigData(gConfigData));

    if (gConfigData->pDevInfo)
        return TRUE;

    //
    // Allocate memory to hold information about fax devices
    //

    Assert(gConfigData->hFaxSvc != NULL);
    Assert(gConfigData->cDevices == 0);

    if (! (pSvcPortInfo = FaxSvcEnumPorts(gConfigData->hFaxSvc, &cPorts)) ||
        ! (gConfigData->pDevInfo = pDevInfo = MemAllocZ(sizeof(CONFIG_PORT_INFO_2) * cPorts)))
    {
        FaxFreeBuffer(pSvcPortInfo);
        return FALSE;
    }

    //
    // Collect information about each fax device. Here we're depending on the fact that
    // fax devices are enumerated in reverse priority order, i.e. the lowest priority
    // device is enumerated first.
    //

    Verbose(("Available fax devices:\n"));

    for (index=0; index < cPorts; index++, pDevInfo++) {

        pSvcPort = &pSvcPortInfo[cPorts - index - 1];

        Verbose(( "  %ws\n", pSvcPort->DeviceName ));

        pDevInfo->SizeOfStruct  = pSvcPort->SizeOfStruct;
        pDevInfo->DeviceId      = pSvcPort->DeviceId;
        pDevInfo->State         = pSvcPort->State;
        pDevInfo->Flags         = pSvcPort->Flags;
        pDevInfo->Rings         = pSvcPort->Rings;
        pDevInfo->Priority      = pSvcPort->Priority;
        pDevInfo->DeviceName    = DuplicateString( pSvcPort->DeviceName );
        pDevInfo->CSID          = DuplicateString( pSvcPort->Csid);
        pDevInfo->TSID          = DuplicateString( pSvcPort->Tsid);
        pDevInfo->Mask          = 0;
        pDevInfo->ProfileName   = NULL;
        pDevInfo->PrinterName   = NULL;
        pDevInfo->DirStore      = NULL;

        //
        // open the fax port for query so we can get the routing info
        //

        if (FaxOpenPort(gConfigData->hFaxSvc, pDevInfo->DeviceId, PORT_OPEN_QUERY, &FaxPortHandle )) {

            //
            // get the store dir
            //

            if (FaxGetRoutingInfo( FaxPortHandle, REGVAL_RM_FOLDER_GUID, &RoutingInfo, &cb )) {
                if (*((LPDWORD)RoutingInfo)) {
                    pDevInfo->Mask |= LR_STORE;
                    pDevInfo->DirStore = DuplicateString( (LPWSTR)(RoutingInfo+sizeof(DWORD)) );
                }

                FaxFreeBuffer( RoutingInfo );
            }

            //
            // get the printer name
            //

            if (FaxGetRoutingInfo( FaxPortHandle, REGVAL_RM_PRINTING_GUID, &RoutingInfo, &cb )) {
                if (*((LPDWORD)RoutingInfo)) {
                    pDevInfo->Mask |= LR_PRINT;
                    pDevInfo->PrinterName = DuplicateString( (LPWSTR)(RoutingInfo+sizeof(DWORD)) );
                }

                FaxFreeBuffer( RoutingInfo );
            }

            //
            // get the email profile name
            //

            if (FaxGetRoutingInfo( FaxPortHandle, REGVAL_RM_EMAIL_GUID, &RoutingInfo, &cb )) {
                if (*((LPDWORD)RoutingInfo)) {
                    pDevInfo->Mask |= LR_EMAIL;
                    pDevInfo->ProfileName = DuplicateString( (LPWSTR)(RoutingInfo+sizeof(DWORD)) );
                }

                FaxFreeBuffer( RoutingInfo );
            }

            //
            // get the inbox profile name
            //

            if (FaxGetRoutingInfo( FaxPortHandle, REGVAL_RM_INBOX_GUID, &RoutingInfo, &cb )) {
                if (*((LPDWORD)RoutingInfo)) {
                    pDevInfo->Mask |= LR_INBOX;
                    MemFree( pDevInfo->ProfileName );
                    pDevInfo->ProfileName = DuplicateString( (LPWSTR)(RoutingInfo+sizeof(DWORD)) );
                }

                FaxFreeBuffer( RoutingInfo );
            }

            FaxClose( FaxPortHandle );
        }

        gConfigData->cDevices++;
    }

    //
    // Retrieve fax configuration information from the service
    //

    Assert( gConfigData->pFaxConfig == NULL );

    if (!FaxGetConfiguration(gConfigData->hFaxSvc, &gConfigData->pFaxConfig)) {
        Error(("Cannot retrieve fax configuration information: %d\n", GetLastError()));
        gConfigData->pFaxConfig = NULL;
    }

    //
    // Retrieve the logging categories
    //

    Assert( gConfigData->pFaxLogging == NULL );

    if (!FaxGetLoggingCategories( gConfigData->hFaxSvc, &gConfigData->pFaxLogging, &gConfigData->NumberCategories )) {
        Error(("Cannot retrieve fax logging category information: %d\n", GetLastError()));
        gConfigData->pFaxLogging = NULL;
    }
}



BOOL
SaveFaxDeviceAndConfigInfo(
    HWND    hDlg,
    INT     pageIndex
    )

/*++

Routine Description:

    Save fax device and configuration information

Arguments:

    hDlg - Handle to the currently active property page
    pageIndex - Specifies the currently active page index

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define FAIL_SAVE_FAX_CONFIG(err) { errorId = err; goto ExitSaveFaxConfig; }

{
    PCONFIG_PORT_INFO_2 pDevInfo;
    FAX_PORT_INFO       SvcPort;
    DWORD               ec;
    INT                 index = 0;
    INT                 errorId = 0;
    DWORD               cb;


    //
    // Check if we're on the last page that has settable fax configuration info
    //

    if ((gConfigData->changeFlag & CONFIGPAGE_MASK) != (1 << pageIndex)) {
        return TRUE;
    }

    if (gConfigData->hFaxSvc == NULL) {
        FAIL_SAVE_FAX_CONFIG(IDS_NULL_SERVICE_HANDLE);
    }

    //
    // Save fax configuration information
    //

    if (gConfigData->pFaxConfig &&
        ! FaxSetConfiguration(gConfigData->hFaxSvc, gConfigData->pFaxConfig))
    {
        ec = GetLastError();
        Error(("FaxSetConfiguration failed: %d\n", ec));
        FAIL_SAVE_FAX_CONFIG((ec == ERROR_ACCESS_DENIED ? IDS_NO_AUTHORITY : IDS_FAXSETCONFIG_FAILED));
    }

    //
    // Save fax device information
    // NOTE: Here, we're calling FaxSetPort on every device which may be
    // a little redundant. But it shouldn't hurt anything.
    //

    pDevInfo = gConfigData->pDevInfo;

    for (index=0; index < gConfigData->cDevices; index++, pDevInfo++) {

        HANDLE FaxPortHandle;
        LPBYTE RoutingInfo;

        if (!FaxOpenPort(gConfigData->hFaxSvc, pDevInfo->DeviceId, PORT_OPEN_MODIFY, &FaxPortHandle )) {
            DisplayMessageDialog(hDlg, 0, 0, IDS_DEVICE_BUSY, pDevInfo->DeviceName);
            return FALSE;
        }

        SvcPort.SizeOfStruct    = pDevInfo->SizeOfStruct;
        SvcPort.DeviceId        = pDevInfo->DeviceId;
        SvcPort.State           = pDevInfo->State;
        SvcPort.Flags           = pDevInfo->Flags;
        SvcPort.Rings           = pDevInfo->Rings;
        SvcPort.Priority        = pDevInfo->Priority;

        SvcPort.DeviceName      = pDevInfo->DeviceName;
        SvcPort.Tsid            = pDevInfo->TSID;
        SvcPort.Csid            = pDevInfo->CSID;

        if (! FaxSetPort(FaxPortHandle, &SvcPort)) {

            ec = GetLastError();
            Error(("FaxSetPort failed: %d\n", ec));
            FAIL_SAVE_FAX_CONFIG((ec == ERROR_ACCESS_DENIED ? IDS_NO_AUTHORITY : IDS_FAXSETPORT_FAILED));
        }

        //
        // change the routing information
        //

        cb = 4096;
        RoutingInfo = (LPBYTE) MemAllocZ( cb );
        if (!RoutingInfo) {
            Error(("Memory allocation failed: %d\n", GetLastError()));
            goto ExitSaveFaxConfig;
        }

        //
        // set the store dir
        //

        *((LPDWORD)RoutingInfo) = (pDevInfo->Mask & LR_STORE) > 0;
        if (pDevInfo->Mask & LR_STORE) {
            _tcscpy( (LPTSTR) (RoutingInfo+sizeof(DWORD)), pDevInfo->DirStore );
        }

        if (!FaxSetRoutingInfo( FaxPortHandle, REGVAL_RM_FOLDER_GUID, RoutingInfo, cb )) {
            Error(("FaxSetRoutingInfo failed: %d\n", GetLastError()));
        }

        //
        // set the printer name
        //

        *((LPDWORD)RoutingInfo) = (pDevInfo->Mask & LR_PRINT) > 0;
        if (pDevInfo->Mask & LR_PRINT) {
            _tcscpy( (LPTSTR) (RoutingInfo+sizeof(DWORD)), pDevInfo->PrinterName ? pDevInfo->PrinterName : TEXT("") );
        }

        if (!FaxSetRoutingInfo( FaxPortHandle, REGVAL_RM_PRINTING_GUID, RoutingInfo, cb )) {
            Error(("FaxSetRoutingInfo failed: %d\n", GetLastError()));
        }

        //
        // set the email profile name
        //

        *((LPDWORD)RoutingInfo) = (pDevInfo->Mask & LR_EMAIL) > 0;
        if (pDevInfo->Mask & LR_EMAIL) {
            _tcscpy( (LPTSTR) (RoutingInfo+sizeof(DWORD)), pDevInfo->ProfileName ? pDevInfo->ProfileName : TEXT("") );
        }

        if (!FaxSetRoutingInfo( FaxPortHandle, REGVAL_RM_EMAIL_GUID, RoutingInfo, cb )) {
            Error(("FaxSetRoutingInfo failed: %d\n", GetLastError()));
        }

        //
        // set the inbox profile name
        //

        *((LPDWORD)RoutingInfo) = (pDevInfo->Mask & LR_INBOX) > 0;
        if (pDevInfo->Mask & LR_INBOX) {
            _tcscpy( (LPTSTR) (RoutingInfo+sizeof(DWORD)), pDevInfo->ProfileName ? pDevInfo->ProfileName : TEXT("") );
        }

        if (!FaxSetRoutingInfo( FaxPortHandle, REGVAL_RM_INBOX_GUID, RoutingInfo, cb )) {
            Error(("FaxSetRoutingInfo failed: %d\n", GetLastError()));
        }

        MemFree( RoutingInfo );

        FaxClose( FaxPortHandle );
    }

    //
    // save the logging categories
    //

    if (!FaxSetLoggingCategories( gConfigData->hFaxSvc, gConfigData->pFaxLogging, gConfigData->NumberCategories )) {
        Error(("Cannot change fax logging category information: %d\n", GetLastError()));
    }

ExitSaveFaxConfig:

    //
    // If an error was encountered, display a message box and return FALSE.
    // Otherwise, return TRUE to indicate success.
    //

    if (errorId != 0) {

        DisplayMessageDialog(hDlg, 0, 0, errorId);
        return FALSE;
    }

    if (gConfigData->priorityChanged) {

        DisplayMessageDialog(hDlg,
                             MB_OK | MB_ICONINFORMATION,
                             IDS_PRIORITY_CHANGE_TITLE,
                             IDS_PRIORITY_CHANGE_MESSAGE);

        gConfigData->priorityChanged = FALSE;
    }

    return TRUE;
}



VOID
FreeFaxDeviceAndConfigInfo(
    VOID
    )

/*++

Routine Description:

    Dispose of fax device and configuration information

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    PCONFIG_PORT_INFO_2 pDevInfo = gConfigData->pDevInfo;

    while (gConfigData->cDevices > 0) {

        MemFree(pDevInfo->DeviceName);
        MemFree(pDevInfo->TSID);
        MemFree(pDevInfo->PrinterName);
        MemFree(pDevInfo->DirStore);
        MemFree(pDevInfo->ProfileName);
        MemFree(pDevInfo->CSID);

        gConfigData->cDevices--;
        pDevInfo++;
    }

    MemFree(gConfigData->pDevInfo);
    gConfigData->pDevInfo = NULL;
    gConfigData->cDevices = 0;

    FaxFreeBuffer(gConfigData->pFaxConfig);
    gConfigData->pFaxConfig = NULL;

    FaxFreeBuffer(gConfigData->pMapiProfiles);
    gConfigData->pMapiProfiles = NULL;
}



LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the specified character string

Arguments:

    pSrcStr - Specifies the source string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPTSTR  pDestStr;
    INT     size;

    if (pSrcStr == NULL)
        return NULL;

    size = SizeOfString(pSrcStr);

    if (pDestStr = MemAlloc(size))
        CopyMemory(pDestStr, pSrcStr, size);
    else
        Error(("Couldn't duplicate string: %ws\n", pSrcStr));

    return pDestStr;
}



VOID
EnableControls(
    HWND    hDlg,
    INT    *pCtrlIds,
    BOOL    enabled
    )

/*++

Routine Description:

    Enable or disable a set of controls in a dialog

Arguments:

    hwnd - Specifies the handle to the dialog window
    pCtrlIds - Array of control IDs to be enabled or disabled (0 terminated)
    enabled - Whether to enable or disable the specified controls

Return Value:

    NONE

--*/

{
    while (*pCtrlIds) {

        EnableWindow(GetDlgItem(hDlg, *pCtrlIds), enabled);
        pCtrlIds++;
    }
}



VOID
ShowControls(
    HWND    hDlg,
    INT    *pCtrlIds,
    BOOL    visible
    )

/*++

Routine Description:

    Show or hide a set of controls in a dialog

Arguments:

    hwnd - Specifies the handle to the dialog window
    pCtrlIds - Array of control IDs to be shown or hidden (0 terminated)
    visible - Whether to show or hide the specified controls

Return Value:

    NONE

--*/

{
    INT nCmdShow = visible ? SW_SHOW : SW_HIDE;

    while (*pCtrlIds) {

        ShowWindow(GetDlgItem(hDlg, *pCtrlIds), nCmdShow);
        pCtrlIds++;
    }
}



VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}



INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    type - Specifies the type of message box to be displayed
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    Same as the return value from MessageBox

--*/

{
    LPTSTR  pTitle, pFormat, pMessage;
    INT     result;
    va_list ap;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_DLGTITLE;

        LoadString(ghInstance, titleStrId, pTitle, MAX_TITLE_LEN);

        //
        // Load message format string resource
        //

        LoadString(ghInstance, formatStrId, pFormat, MAX_STRING_LEN);

        //
        // Compose the message string
        //

        va_start(ap, formatStrId);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (type == 0)
            type = MB_OK | MB_ICONERROR;

        result = MessageBox(hwndParent, pMessage, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}



VOID
ToggleListViewCheckbox(
    HWND    hwndLV,
    INT     index
    )

/*++

Routine Description:

    Toggle the checkbox associated with the specified list view item

Arguments:

    hwndLV - Handle to the list view control
    index - Specifies the index of the interested item

Return Value:

    NONE

--*/

{
    UINT    state;

    if (IsListViewItemChecked(hwndLV, index))
        state = UNCHECKED_STATE;
    else
        state = CHECKED_STATE;

    ListView_SetItemState(hwndLV, index, state, LVIS_STATEIMAGEMASK);
}



VOID
InitFaxDeviceListView(
    HWND        hwndLV,
    DWORD       flags,
    PCOLUMNINFO pColumnInfo
    )

/*++

Routine Description:

    Initialize the fax device list view

Arguments:

    hwndLV - Handle to the fax device list view
    flags - Miscellaneous flag bits
    pColumnInfo - Specifies columns to be displayed and their relative widths
        ID for the 1st column, relative width for the 1st column
        ID for the 2nd column, relative width for the 2nd column
        ...
        0, 0

Return Value:

    NONE

--*/

{
    //
    // Column header string resource IDs
    //

    static  INT columnHeaderIDs[MAX_COLUMNS] = {
        0,
        IDS_DEVICE_NAME_COLUMN,
        IDS_CSID_COLUMN,
        IDS_TSID_COLUMN,
        IDS_STATUS_COLUMN,
    };

    INT         index, nColumns, widthDenom, lvWidth;
    RECT        rect;
    LV_COLUMN   lvc;
    LV_ITEM     lvi;
    TCHAR       buffer[MAX_TITLE_LEN];

    //
    // Count the number of columns
    //

    if (hwndLV == NULL)
        return;

    nColumns = widthDenom = 0;

    while (pColumnInfo[nColumns].columnId) {

        widthDenom += pColumnInfo[nColumns].columnWidth;
        nColumns++;
    }

    Assert(nColumns > 0 && nColumns <= MAX_COLUMNS);
    Assert(pColumnInfo[0].columnId == COLUMN_DEVICE_NAME);

    lvc.mask = LVCF_TEXT;
    lvc.pszText = buffer;
    lvc.cchTextMax = MAX_TITLE_LEN;

    if (ListView_GetColumn(hwndLV, 0, &lvc) && ! IsEmptyString(buffer)) {

        //
        // The columns have already be inserted
        //

        ListView_DeleteAllItems(hwndLV);

    } else {

        //
        // This is the first time and the list view is not initialized
        // Insert the specified columns into the list view
        //

        GetClientRect(hwndLV, &rect);
        lvWidth = rect.right - rect.left;

        //
        // Insert a column of check boxes if requested
        //

        if (flags & LV_HASCHECKBOX) {

            HBITMAP     hbmp;
            HIMAGELIST  himl;

            if (hbmp = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_CHECKSTATES))) {

                if (himl = ImageList_Create(16, 16, TRUE, 2, 0)) {

                    ImageList_AddMasked(himl, hbmp, RGB(255, 0, 0));
                    ListView_SetImageList(hwndLV, himl, LVSIL_STATE);

                } else
                    Error(("LoadBitmap failed: %d\n", GetLastError()));

                DeleteObject(hbmp);

            } else
                Error(("LoadBitmap failed: %d\n", GetLastError()));
        }

        //
        // Insert list view columns
        //

        ZeroMemory(&lvc, sizeof(lvc));

        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.pszText = buffer;

        for (index=0; index < nColumns; index++) {

            lvc.cx = lvWidth * pColumnInfo[index].columnWidth / widthDenom;
            lvc.iSubItem = index;

            if (index == nColumns-1)
                lvc.cx -= GetSystemMetrics(SM_CXVSCROLL);

            LoadString(ghInstance,
                       columnHeaderIDs[pColumnInfo[index].columnId],
                       buffer,
                       MAX_TITLE_LEN);

            if (ListView_InsertColumn(hwndLV, index, &lvc) == -1)
                Error(("ListView_InsertColumn failed\n"));
        }
    }

    //
    // Insert list view items list view content
    //

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.iSubItem = 0;
    lvi.mask = LVIF_STATE | LVIF_TEXT;

    if (flags & LV_HASCHECKBOX) {

        lvi.state = UNCHECKED_STATE;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
    }

    for (index = 0; index < gConfigData->cDevices; index ++) {

        //
        // The first column is always the device name
        //

        lvi.iItem = index;
        lvi.pszText = gConfigData->pDevInfo[index].DeviceName;

        if (ListView_InsertItem(hwndLV, &lvi) == -1) {

            Error(("ListView_InsertItem failed\n"));
            break;
        }
    }

    //
    // Display the remaining columns
    //

    UpdateFaxDeviceListViewColumns(hwndLV, pColumnInfo, 1);

    //
    // The initial selection is the first fax device in the list
    //

    ListView_SetItemState(hwndLV, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
}



LPTSTR
MakeDeviceStatusString(
    DWORD   state
    )

/*++

Routine Description:

    Assemble fax device status string

Arguments:

    state - Current state of the fax device

Return Value:

    Pointer to the device status string, NULL if there is an error

--*/

{
    static struct _STATEBITINFO {

        DWORD   bitFlag;
        INT     stringId;

    } stateBitInfo[] = {

        FPS_AVAILABLE,          IDS_STATUS_AVAILABLE,
        FPS_UNAVAILABLE,        IDS_STATUS_UNAVAILABLE,
        FPS_SENDING,            IDS_STATUS_SENDING,
        FPS_RECEIVING,          IDS_STATUS_RECEIVING,
        FPS_ABORTING,           IDS_STATUS_ABORTING,
        FPS_ROUTING,            IDS_STATUS_ROUTING,
        FPS_DIALING,            IDS_STATUS_DIALING,
        FPS_COMPLETED,          IDS_STATUS_COMPLETED,
        FPS_HANDLED,            IDS_STATUS_HANDLED,
        FPS_BUSY,               IDS_STATUS_BUSY,
        FPS_NO_ANSWER,          IDS_STATUS_NO_ANSWER,
        FPS_BAD_ADDRESS,        IDS_STATUS_BAD_ADDRESS,
        FPS_NO_DIAL_TONE,       IDS_STATUS_NO_DIAL_TONE,
        FPS_DISCONNECTED,       IDS_STATUS_DISCONNECTED,
        FPS_FATAL_ERROR,        IDS_STATUS_FATAL_ERROR,
        FPS_NOT_FAX_CALL,       IDS_STATUS_NOT_FAX_CALL,
        FPS_CALL_DELAYED,       IDS_STATUS_CALL_DELAYED,
        FPS_CALL_BLACKLISTED,   IDS_STATUS_CALL_BLACKLISTED,
        FPS_INITIALIZING,       IDS_STATUS_INITIALIZING,
        FPS_OFFLINE,            IDS_STATUS_OFFLINE,
        FPS_ANSWERED,           IDS_STATUS_ANSWERED
    };

    LPTSTR  pBuffer, p;
    INT     index, count, statusLen, separatorLen;
    BOOL    appendSeparator = FALSE;
    TCHAR   separator[MAX_TITLE_LEN];

    //
    // Load the string that's used separated status fields
    //

    if (! LoadString(ghInstance, IDS_STATUS_SEPARATOR, separator, MAX_TITLE_LEN))
        _tcscpy(separator, TEXT(", "));

    separatorLen = _tcslen(separator);

    //
    // Calculate how much space we need
    //

    count = sizeof(stateBitInfo) / sizeof(struct _STATEBITINFO);

    for (index=statusLen=0; index < count; index++) {

        if ((state & stateBitInfo[index].bitFlag) == stateBitInfo[index].bitFlag) {

            TCHAR   buffer[MAX_TITLE_LEN];
            INT     length;

            length = LoadString(ghInstance,
                                stateBitInfo[index].stringId,
                                buffer,
                                MAX_TITLE_LEN);

            if (length == 0) {

                Error(("LoadString failed: %d\n", GetLastError()));
                return NULL;
            }

            statusLen += (length + separatorLen);
        }
    }

    //
    // Assemble the status string
    //

    if (p = pBuffer = MemAllocZ((statusLen + 1) * sizeof(TCHAR))) {

        for (index=0; index < count; index++) {

            if ((state & stateBitInfo[index].bitFlag) == stateBitInfo[index].bitFlag) {

                if (appendSeparator) {

                    _tcscpy(p, separator);
                    p += separatorLen;
                    appendSeparator = FALSE;
                }

                statusLen = LoadString(ghInstance,
                                       stateBitInfo[index].stringId,
                                       p,
                                       MAX_TITLE_LEN);

                if (statusLen > 0) {

                    p += statusLen;
                    appendSeparator = TRUE;

                } else
                    Error(("LoadString failed: %d\n", GetLastError()));
            }
        }
    }

    return pBuffer;
}



VOID
UpdateFaxDeviceListViewColumns(
    HWND        hwndLV,
    PCOLUMNINFO pColumnInfo,
    INT         startColumn
    )

/*++

Routine Description:

    Refresh columns in the fax device list view

Arguments:

    hwndLV - Handle to the fax device list view
    pColumnInfo - Specifies columns to be redisplayed
    startColumn - Specifies the first column index

Return Value:

    NONE

--*/

{
    LPTSTR  pBuffer, pColumnStr;
    LV_ITEM lvi;
    INT     item, nItems, column, nColumns;

    //
    // Count the number of items in the list view
    //

    if ((hwndLV == NULL) ||
        (nItems = ListView_GetItemCount(hwndLV)) < 0 ||
        (nItems > gConfigData->cDevices))
    {
        return;
    }

    //
    // Count the total number of columns
    //

    for (nColumns=0; pColumnInfo[nColumns].columnId; nColumns++)
        NULL;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT;

    //
    // Go through each item in the list view
    //

    for (item=0; item < nItems; item++) {

        PCONFIG_PORT_INFO_2 pDevInfo = gConfigData->pDevInfo + item;

        lvi.iItem = item;

        //
        // Go through each column for every list view item
        //

        for (column=startColumn; column < nColumns; column++) {

            pBuffer = pColumnStr = NULL;

            switch (pColumnInfo[column].columnId) {

            case COLUMN_CSID:

                pColumnStr = pDevInfo->CSID;
                break;

            case COLUMN_TSID:

                pColumnStr = pDevInfo->TSID;
                break;

            case COLUMN_STATUS:

                pBuffer = pColumnStr = MakeDeviceStatusString(pDevInfo->State);
                break;

            default:

                Assert(FALSE);
                break;
            }

            lvi.iSubItem = column;
            lvi.pszText = pColumnStr ? pColumnStr : TEXT("");

            if (! ListView_SetItem(hwndLV, &lvi))
                Error(("ListView_SetItem failed\n"));

            MemFree(pBuffer);
        }
    }
}



INT
BrowseCallbackProc(
    HWND    hwnd,
    UINT    uMsg,
    LPARAM  lParam,
    LPARAM  lpData
   )

/*++

Routine Description:

    Callback function for SHBrowseForFolder

Arguments:

    hwnd - Handle to the browse dialog box
    uMsg - Identifying the reason for the callback
    lParam - Message parameter
    lpData - Application-defined value given in BROWSEINFO.lParam

Return Value:

    0

--*/

{
    if (uMsg == BFFM_INITIALIZED)
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);

    return 0;
}



BOOL
DoBrowseForDirectory(
    HWND    hDlg,
    INT     textFieldId,
    INT     titleStrId
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    textFieldId - Specifies the text field adjacent to the Browse button
    titleStrId - Specifies the title to be displayed in the browse window

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    TCHAR           buffer[MAX_PATH];
    TCHAR           title[MAX_TITLE_LEN];
    VOID            SHFree(LPVOID);
    BOOL            result = FALSE;

    BROWSEINFO bi = {

        hDlg,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS,
        BrowseCallbackProc,
        (LPARAM) buffer,
    };

    if (! LoadString(ghInstance, titleStrId, title, MAX_TITLE_LEN))
        title[0] = NUL;

    if (! GetDlgItemText(hDlg, textFieldId, buffer, MAX_PATH))
        buffer[0] = NUL;

    if (pidl = SHBrowseForFolder(&bi)) {

        if (SHGetPathFromIDList(pidl, buffer)) {

            if (_tcslen(buffer) > MAX_ARCHIVE_DIR)
                DisplayMessageDialog(hDlg, 0, 0, IDS_DIR_TOO_LONG);
            else {

                MySetDlgItemText(hDlg, textFieldId, buffer);
                result = TRUE;
            }
        }

        SHFree(pidl);
    }

    return result;
}



BOOL
HandleHelpPopup(
    HWND    hDlg,
    UINT    message,
    UINT    wParam,
    LPARAM  lParam,
    INT     pageIndex
    )

/*++

Routine Description:

    Handle context-sensitive help in property sheet pages

Arguments:

    hDlg, message, wParam, lParam - Parameters passed to the dialog procedure
    pageIndex - Specifies the index of the current property sheet page

Return Value:

    TRUE if the message is handle, FALSE otherwise

--*/

{
    static LPDWORD  arrayHelpIDs[MAX_PAGES] = {

        clientOptionsHelpIDs,
        personalCoverPageHelpIDs,
        userInfoHelpIDs,

        serverOptionsHelpIDs,
        serverCoverPageHelpIDs,
        sendOptionsHelpIDs,
        receiveOptionsHelpIDs,
        devicePriorityHelpIDs,
        deviceStatusHelpIDs,
        loggingHelpIDs,
        NULL,
        statusMonitorHelpIDs
    };

    Assert(pageIndex >= 0 && pageIndex < MAX_PAGES);

    if (message == WM_HELP) {

        WinHelp(((LPHELPINFO) lParam)->hItemHandle,
                FAXCFG_HELP_FILENAME,
                HELP_WM_HELP,
                (DWORD) arrayHelpIDs[pageIndex]);

    } else {

        WinHelp((HWND) wParam,
                FAXCFG_HELP_FILENAME,
                HELP_CONTEXTMENU,
                (DWORD) arrayHelpIDs[pageIndex]);
    }

    return TRUE;
}



PFAX_DEVICE_STATUS
FaxSvcGetDeviceStatus(
    HANDLE hFaxSvc,
    DWORD DeviceId
    )

/*++

Routine Description:

    Wrapper function for fax service API FaxGetDeviceStatus

Arguments:

    hFaxSvc - Specifies a coneection handle to the fax service
    DeviceId - Specifies the ID of the interested device

Return Value:

    Pointer to a FAX_DEVICE_STATUS structure,
    NULL if there is an error

--*/

{
    PBYTE           pFaxStatus = NULL;
    HANDLE          FaxPortHandle = NULL;


    if ((hFaxSvc == NULL) ||
        FaxOpenPort(hFaxSvc, DeviceId, PORT_OPEN_QUERY, &FaxPortHandle) == FALSE ||
        !FaxGetDeviceStatus(FaxPortHandle, (PFAX_DEVICE_STATUS*)&pFaxStatus))
    {
        Error(("FaxGetDeviceStatus failed: %d\n", GetLastError()));
        pFaxStatus = NULL;
    }

    if (FaxPortHandle) {
        FaxClose( FaxPortHandle );
    }

    return (PFAX_DEVICE_STATUS) pFaxStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\wrapper\resource.h ===
#define IDS_FAX_SERVER          101
#define IDS_FAX_CLIENT          102
#define IDS_FAX_WORKSTATION     103

#define IDI_FAX                 201
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\dumpqueue\dumpqueue.c ===
#include <windows.h>
#include <wchar.h>

#include "faxsvc.h"
#include "faxutil.h"

#define QUEUE_SEARCH       L"*.fqe"
#define QUEUE_DIR          L"Microsoft\\Windows NT\\MSFax\\queue"

#define BUFFER_SIZE         4096

BYTE Buffer[BUFFER_SIZE];

WCHAR * JobTypeStrings[] = {
    L"Unknown",
    L"Send",
    L"Receive",
    L"Routing"
};

WCHAR * JobScheduleStrings[] = {
    L"Now",
    L"Specific Time",
    L"Discount Period"
};

int 
_cdecl
wmain(
    INT Argc,
    WCHAR *Argv[]
    )
{
        
    
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    PJOB_QUEUE_FILE JobQueue = (PJOB_QUEUE_FILE) &Buffer[0];
    HANDLE FileHandle;
    WCHAR QueueDir[MAX_PATH];

    if (!GetSpecialPath(CSIDL_COMMON_APPDATA,QueueDir)) {
       return FALSE;
    }

    ConcatenatePaths(QueueDir,QUEUE_DIR);
    
    SetCurrentDirectory( QueueDir );

    FindHandle = FindFirstFile( QUEUE_SEARCH, &FindData );

    if (FindHandle != INVALID_HANDLE_VALUE) {
        
        do {
            wprintf( L"Queue FileName %s\n", FindData.cFileName );

            FileHandle = CreateFile(
                            FindData.cFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );

            if (FileHandle != INVALID_HANDLE_VALUE) {
                DWORD BytesRead;
                
                ReadFile(
                    FileHandle,
                    &Buffer[0],
                    BUFFER_SIZE,
                    &BytesRead,
                    NULL
                    );

                if (BytesRead > 0) {
                    
                    wprintf (L"Unique Id %d\n", JobQueue->UniqueId );
                    wprintf (L"Job Type - %s\n", JobTypeStrings[JobQueue->JobType] );
                    wprintf (L"Tiff FileName %s\n", Buffer + (DWORD) JobQueue->FileName );
                    wprintf (L"Retries %d\n", JobQueue->SendRetries );
                    wprintf (L"Schedule Action - %s\n", JobScheduleStrings[JobQueue->ScheduleAction] );

                    if (JobQueue->ScheduleAction == JSA_SPECIFIC_TIME) {
                        SYSTEMTIME SystemTime;
                        FILETIME LocalFileTime;

                        WCHAR TimeBuffer[128];

                        FileTimeToLocalFileTime( (LPFILETIME) &JobQueue->ScheduleTime, &LocalFileTime );

                        FileTimeToSystemTime( &LocalFileTime, &SystemTime );

                        GetDateFormat(
                            LOCALE_SYSTEM_DEFAULT,
                            0,
                            &SystemTime,
                            NULL,
                            TimeBuffer,
                            sizeof(TimeBuffer)
                            );
                        
                        wprintf( L"Schedule Date - %s    ", TimeBuffer );
                        
                        GetTimeFormat(
                            LOCALE_SYSTEM_DEFAULT,
                            0,
                            &SystemTime,
                            NULL,
                            TimeBuffer,
                            sizeof(TimeBuffer)
                            );
                        
                        wprintf( L"Schedule Time - %s\n", TimeBuffer );
                        
                        wprintf( L"Schedule Quadword %I64x\n", JobQueue->ScheduleTime );
                    }
                }
                CloseHandle( FileHandle );
                
                wprintf( L"\n\n" );
            }
            
        } while ( FindNextFile( FindHandle, &FindData  ));

    }
    
    return 1;
}

#if 0
#define JSA_NOW                 0
#define JSA_SPECIFIC_TIME       1
#define JSA_DISCOUNT_PERIOD     2

//
// job type defines
//

#define JT_UNKNOWN                  0
#define JT_SEND                     1
#define JT_RECEIVE                  2
#define JT_ROUTING                  3

//
// job status defines
//

#define JS_PENDING                  0x00000000
#define JS_INPROGRESS               0x00000001
#define JS_DELETING                 0x00000002
#define JS_FAILED                   0x00000004
#define JS_PAUSED                   0x00000008
#define JS_NOLINE                   0x00000010

typedef struct _JOB_QUEUE_FILE {
    DWORD               SizeOfStruct;               // size of this structure
    DWORDLONG           UniqueId;                   //
    DWORD               JobType;                    // job type, see JT defines
    LPTSTR              FileName;                   //
    LPTSTR              QueueFileName;              //
    LPTSTR              UserName;                   //
    LPTSTR              RecipientNumber;            // recipient fax number
    LPTSTR              RecipientName;              // recipient name
    LPTSTR              Tsid;                       // transmitter's id
    LPTSTR              SenderName;                 // sender name
    LPTSTR              SenderCompany;              // sender company
    LPTSTR              SenderDept;                 // sender department
    LPTSTR              BillingCode;                // billing code
    LPTSTR              DeliveryReportAddress;      //
    LPTSTR              DocumentName;               //
    DWORD               DeliveryReportType;         //
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    DWORDLONG           ScheduleTime;               // schedule time in 64bit version
    BOOL                BroadcastJob;               // is this a broadcast fax job?
    DWORDLONG           BroadcastOwner;             // unique id of the broadcast owner
    DWORD               SendRetries;                // number of times send attempt has been made
    DWORD               FaxRouteSize;
    PFAX_ROUTE          FaxRoute;
    DWORD               CountFaxRouteFiles;         // count of files to be routed
    DWORD               FaxRouteFileGuid;           // offset array of GUID's
    DWORD               FaxRouteFiles;              // offset to a multi-sz of filenames
    DWORD               CountFailureInfo;           // number of ROUTE_FAILURE_INFO structs that follow
    ROUTE_FAILURE_INFO  RouteFailureInfo[1];        // array of ROUTE_FAILURE_INFO structs
} JOB_QUEUE_FILE, *PJOB_QUEUE_FILE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abctbl.h ===
/***********************************************************************
 *
 *  _ABCTBL.H
 *
 *  Header file for code in ABCTBL.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  BookMark structure
 */

#define MAX_BOOKMARKS	10

#define BK_PEGGEDTOEND      ((ULONG)0x00000001)

typedef struct _ABCBK
{

    ULONG       ulFlags;            /*  Flags */
	FILETIME	filetime;			/*  Time of file when bookmark created */
	ULONG		ulPosition;			/*  Position of record in file */
	ABCREC		abcrec;				/*  Record associated with this bookmark */

} ABCBK, *LPABCBK;

#define CBABCBK sizeof(ABCBK)

/*
 *   Function Prototypes
 */

/*
 *  Reuses methods:
 *		ROOT_QueryInterface
 *		ROOT_AddRef
 *		ROOT_GetLastError
 *		IVTROOT_RegisterNotification
 */

#undef	INTERFACE
#define INTERFACE	struct _IVTABC

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IVTABC_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IVTABC_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IVTABC_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPITABLE_METHODS(IMPL)
};

/*
 *  _IVTABC is the structure returned to the client when
 *  the contents table is retrieved from the ab container
 *  object (ABCONT.C).
 *
 *  The first thing in the structure must be a jump table
 *  with all the IMAPITable methods in it.
 *
 */
typedef struct _IVTABC
{
	const IVTABC_Vtbl FAR * lpVtbl;

	/*
	 *  Need to be the same as other objects
	 *  since this object reuses methods from
	 *  other objects.
	 */

    FAB_IUnkWithLogon;

	/*
	 *  Private data
	 */

	/*  The list of active columns */
	LPSPropTagArray lpPTAColSet;

	/*  HANDLE of file that I'm browsing... */
	HANDLE hFile;

	/*  FILETIME time the file was last changed */
	FILETIME filetime;

	/*  Size of file */
	ULONG ulMaxPos;

	/*  Current position in file */
	ULONG ulPosition;

	/*  BookMark array... */
	LPABCBK rglpABCBK[MAX_BOOKMARKS];

	/*
	 *  Restriction stuff
	 */

	ULONG ulRstrDenom;

	/*  Partial Name to match */
	LPTSTR lpszPartialName;

	/*  2 bit arrays of what's been checked, and what (of them) matches */
	BYTE *rgChecked;
	BYTE *rgMatched;

	ULONG	ulConnectMic;
	UINT	cAdvise;							/* Count of registered notifications */
	LPMAPIADVISESINK * parglpAdvise;	/* Registered notifications */
	FTG	ftg;								/* Idle function tag */
	LPTSTR	lpszFileName;


} IVTABC, *LPIVTABC;

#define CBIVTABC sizeof(IVTABC)



/*
 *  Record for PR_INSTANCE_KEY.  Need enough information to find the record quickly as
 *  well as determine if the record is still valid.
 */
typedef struct _abcrecinstance
{
	ULONG ulRecordPosition;
	FILETIME filetime;
	TCHAR rgchzFileName[1];  /* Get's sized accordingly */

} ABCRecInstance, FAR * LPABCRecInstance;

/*
 *  Private macros
 */

/* Counts the number of bits in a byte */
#define CBitsB(b, cbits) {                               \
                                                         \
		cbits = 0;                                       \
		                                                 \
		cbits = ((b)   & 0x55) + ((b>>1) & 0x55);        \
		cbits = (cbits & 0x33) + ((cbits>>2) & 0x33);    \
		cbits = (cbits & 0x0f) + (cbits>>4);             \
	}




/*
 *	Functions prototypes
 */

// Creates a new IVTAbc object
HRESULT
NewIVTAbc (LPVOID * lppIVTAbc, LPABPLOGON lpABPLogon, LPABCNT lpABC);

// Internal functions
HRESULT     HrOpenFile(LPIVTABC lpIVTAbc);
void        FreeANRBitmaps(LPIVTABC lpIVTAbc);
HRESULT     HrValidateEntry (LPIVTABC lpIVTAbc, ULONG ulNewPos);
BOOL        FNameMatch (LPIVTABC lpIVTAbc, LPTSTR rgchDisplayName);
BOOL        FMatched (LPIVTABC lpIVTAbc, ULONG ulNewPos);
BOOL        FChecked (LPIVTABC lpIVTAbc, ULONG ulNewPos);


/*
 *  Default column set
 */
enum {  ivalvtPR_DISPLAY_NAME,
        ivalvtPR_ENTRYID,
        ivalvtPR_ADDRTYPE,
        ivalvtPR_EMAIL_ADDRESS,
        ivalvtPR_OBJECT_TYPE,
        ivalvtPR_DISPLAY_TYPE,
		ivalvtPR_INSTANCE_KEY,
        cvalvtMax };



/*
 *  Externs defined for use in the three table modules
 */

extern const IVTABC_Vtbl vtblIVTABC;
extern const LPSPropTagArray ptagaivtabcColSet;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\config\wrapper\faxcfgst.c ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

#include "faxutil.h"
#include "faxreg.h"
#include "resource.h"


BOOL
IsUserAdmin(
    VOID
    );



BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;


    if (Installed == NULL || InstallType == NULL) {
        return FALSE;
    }

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SETUP,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open setup registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSize = sizeof(DWORD);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED,
        0,
        &RegType,
        (LPBYTE) Installed,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query installed registry value, ec=0x%08x"), rVal ));
        *Installed = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALL_TYPE,
        0,
        &RegType,
        (LPBYTE) InstallType,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install type registry value, ec=0x%08x"), rVal ));
        *InstallType = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED_PLATFORMS,
        0,
        &RegType,
        (LPBYTE) InstalledPlatforms,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install platforms mask registry value, ec=0x%08x"), rVal ));
        *InstalledPlatforms = 0;
    }

    RegCloseKey( hKey );

    return TRUE;
}



INT
wWinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )

/*++

Routine Description:

    Application entry point

Arguments:

    hInstance - Identifies the current instance of the application
    hPrevInstance - Identifies the previous instance of the application
    lpCmdLine - Specifies the command line for the application.
    nCmdShow - Specifies how the window is to be shown

Return Value:

    0

--*/

{
    DWORD Installed;
    DWORD InstallType;
    DWORD InstalledPlatforms;
    WCHAR Str[64];
    WCHAR Cmd[128];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;



    if (!GetInstallationInfo( &Installed, &InstallType, &InstalledPlatforms )) {
        goto error_exit;
    }

    if (!Installed) {
        goto error_exit;
    }

    Str[0] = 0;

    if (InstallType & FAX_INSTALL_SERVER) {

        if (IsUserAdmin()) {
            LoadString( hInstance, IDS_FAX_SERVER, Str, sizeof(Str) );
        } else {
            LoadString( hInstance, IDS_FAX_CLIENT, Str, sizeof(Str) );
        }

    } else if (InstallType & FAX_INSTALL_WORKSTATION) {

        LoadString( hInstance, IDS_FAX_WORKSTATION, Str, sizeof(Str) );

    } else if (InstallType & FAX_INSTALL_NETWORK_CLIENT) {

        LoadString( hInstance, IDS_FAX_WORKSTATION, Str, sizeof(Str) );

    } else {

        goto error_exit;

    }

    if (!Str[0]) {
        goto error_exit;
    }

    swprintf( Cmd, L"rundll32 shell32.dll,Control_RunDLL faxcfg.cpl,%s", Str );

    GetStartupInfo( &si );

    if (!CreateProcess(
        NULL,
        Cmd,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi
        ))
    {
        goto error_exit;
    }

    return 0;

error_exit:
    MessageBeep( MB_ICONEXCLAMATION );
    Sleep( 3000 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abctbl1.c ===
/***********************************************************************
 *
 *  ABCTBL1.C
 *
 *  Contents Table
 *
 *  The contents table associated with this provider.  It's file based.
 *  The format of the .FAB file is in ABP.H.
 *
 *  This implementation of IMAPITable is retrieved by calling the
 *  GetContentsTable() method of the Microsoft At Work Fax ABP's single
 *  directory (see abcont.c).
 *
 *  There are a few interesting features in this implementation.  First
 *  it's implemented on a flat file (.FAB).  Second, it actually supports
 *  an implementation of ANR (Ambiguous Name Resolution).  And lastly, it
 *  supports FindRow (limited to prefix searching on display names).
 *
 *  This is the minimum set of restrictions that the provider MUST support.
 *  It MUST have an ANR implementation and support prefix (downward) searching
 *  on whatever the contents table is sorted on (in this case PR_DISPLAY_NAME).
 *
 *  The browsing of a flat file is done a record at a time.  It's never
 *  completely read into memory.  It only reads records from the file when
 *  it absolutely has to (like in QueryRows).  The advantage to this is
 *  a low memory footprint and the ability to browse rather large files
 *  with decent performance.
 */
/*
 *  ANR is also supported in this implementation.  In the code will often
 *  be 'if' statements making two different code paths between the restricted
 *  and unrestricted version.  The restrictions rely on a couple of
 *  bit arrays.  Each bit corresponds (in order) to the records in the .FAB
 *  file.  One bit array, rgChecked, says whether or not a record in the
 *  .FAB file has actually been compared to the restriction.  It's initially
 *  set to all 0s - which means that none of the records have been checked.
 *  The second bit array, rgMatched, says whether or not the particular
 *  record matches the current restriction.  This array is initialized to all
 *  1s - which says that all the records in the .FAB file match the current
 *  restriction.  The reason for this is for the fraction returned in
 *  QueryPosition--By assuming that all the rows match and only updating
 *  the array when something doesn't match, the fraction returned in
 *  QueryPosition will get larger and has the effect of making the thumb-bar
 *  on a listbox implemented on top of this table to scroll down as you go
 *  down the list.
 *
 *  As a row is about to be read it is checked to see if it's been compared
 *  to the current restriction.  If it has then to determine whether or not
 *  to actually read the record and build the row we just look at the matched
 *  bit array.  If it doesn't match we go on to the next record and check
 *  again.  If it does match we read the record and build the row.
 *
 *  Only if it hasn't been checked do we actually go and read the row and
 *  compare it to the current restriction, setting the rgChecked and
 *  rgMatched bits accordingly.
 *
 *  In this implementation the ANR comparison rules are as follows:
 *  (See FNameMatch for the actual code to do this)
 *
 *    A 'word' is defined as any substring separated by separators.
 *    The separators are defined as ',', ' ', and '-'.
 *    A restriction is said to match a display name iff all the words
 *    in the restriction are all prefixes of words in the display name.
 *
 *    For example, a restriction of "b d" will match:
 *     "Barney Donovan"
 *     "Donovan, Barney"
 *     "Danielle Blumenthal"
 *    But will not match:
 *     "Darby Opal"
 *     "Ben Masters"
 *
 *  Other providers can do whatever matching they want with the ANR
 *  restriction.  For example, soundex or additional field comparisons (like
 *  email addresses).  A good (and fast) implementation will differentiate
 *  your provider from others in a positive way.
 *
 *  FindRow's implementation effectively handles prefix searching on display
 *  names (PR_DISPLAY_NAME).  It does this by binary searching the .FAB file.
 *  The only tricky part is knowing when to stop.  Basically you want to stop
 *  on the first name in the list that matches the restriction.  It's easy to
 *  do linearly, but a little more trick with a binary search.  This
 *  implementation is a reasonable example.
 *
 *
 *  This table has only the following columns:
 */

#include "faxab.h"

const SizedSPropTagArray(cvalvtMax, tagaivtabcColSet) =
{
    cvalvtMax,
    {
        PR_DISPLAY_NAME_A,
        PR_ENTRYID,
        PR_ADDRTYPE,
        PR_EMAIL_ADDRESS_A,
        PR_OBJECT_TYPE,
        PR_DISPLAY_TYPE,
        PR_INSTANCE_KEY
    }
};
const LPSPropTagArray ptagaivtabcColSet = (LPSPropTagArray) &tagaivtabcColSet;

/*
 *
 *  The following routines are implemented in the files abctbl2.c and abctbl3.c:
 *
 *
 *      IVTABC_Release
 *      IVTABC_GetStatus
 *      IVTABC_SetColumns
 *      IVTABC_QueryColumns
 *      IVTABC_GetRowCount
 *      IVTABC_SeekRow
 *      IVTABC_SeekRowApprox
 *      IVTABC_QueryPosition
 *      IVTABC_FindRow
 *      IVTABC_Restrict
 *      IVTABC_CreateBookmark
 *      IVTABC_FreeBookmark
 *      IVTABC_SortTable
 *      IVTABC_QuerySortOrder
 *      IVTABC_QueryRows
 *      IVTABC_Abort
 *      IVTABC_ExpandRow
 *      IVTABC_CollapseRow
 *      IVTABC_WaitForCompletion
 *      IVTABC_GetCollapseState
 *      IVTABC_SetCollapseState
 *
 *
 *  This file (abctbl1.c) has all the utility functions used throughout this
 *  objects methods.  They are the following:
 *
 *      HrNewIVTAbc()
 *      HrValidateEntry()
 *      FChecked()
 *      FMatched()
 *      FNameMatch()
 *      HrOpenFile()
 *      fIVTAbcIdleRoutine()
 *      FreeANRBitmaps()
 *
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *      1.1.94          MAPI                            Original source from MAPI sample AB Provider
 *      3.7.94          Yoram Yaacovi           Update to MAPI build 154
 *      3.11.94         Yoram Yaacovi           Update to use Fax AB include files
 *      8.1.94          Yoram Yaacovi           Update to MAPI 304 + file name change to abctbl1.c
 *      11.7.94         Yoram Yaacovi           Update to MAPI 318 (added PR_INSTANCE_KEY)
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  vtbl filled in here.
 */

const IVTABC_Vtbl vtblIVTABC =
{

    IVTABC_QueryInterface,
    (IVTABC_AddRef_METHOD *)        ROOT_AddRef,
    IVTABC_Release,
    (IVTABC_GetLastError_METHOD *)  ROOT_GetLastError,
    IVTABC_Advise,
    IVTABC_Unadvise,
    IVTABC_GetStatus,
    IVTABC_SetColumns,
    IVTABC_QueryColumns,
    IVTABC_GetRowCount,
    IVTABC_SeekRow,
    IVTABC_SeekRowApprox,
    IVTABC_QueryPosition,
    IVTABC_FindRow,
    IVTABC_Restrict,
    IVTABC_CreateBookmark,
    IVTABC_FreeBookmark,
    IVTABC_SortTable,
    IVTABC_QuerySortOrder,
    IVTABC_QueryRows,
    IVTABC_Abort,
    IVTABC_ExpandRow,
    IVTABC_CollapseRow,
    IVTABC_WaitForCompletion,
    IVTABC_GetCollapseState,
    IVTABC_SetCollapseState
};


/* Idle function */
FNIDLE fIVTAbcIdleRoutine;

#define     IVTABC_IDLE_INTERVAL        300L
#define     IVTABC_IDLE_PRIORITY        -2
#define     IVTABC_IDLE_FLAGS           FIROINTERVAL

/*************************************************************************
 *
 -  NewIVTAbc
 -
 *  Creates a new IMAPITable on the contents of a .FAB file.
 *
 *
 */
HRESULT
HrNewIVTAbc( LPMAPITABLE *       lppIVTAbc,
             LPABLOGON           lpABLogon,
             LPABCONT            lpABC,
             HINSTANCE           hLibrary,
             LPALLOCATEBUFFER    lpAllocBuff,
             LPALLOCATEMORE      lpAllocMore,
             LPFREEBUFFER        lpFreeBuff,
             LPMALLOC            lpMalloc
            )
{
    LPIVTABC lpIVTAbc = NULL;
    SCODE scode;
    HRESULT hResult = hrSuccess;
    ULONG ulBK, ulSize, ulSizeHigh;

    /*
     *  Allocate space for the IVTABC structure
     */

    scode = lpAllocBuff(SIZEOF(IVTABC), (LPVOID *) &lpIVTAbc);
    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);
        goto err;
    }

    lpIVTAbc->lpVtbl       = &vtblIVTABC;
    lpIVTAbc->lcInit       = 1;
    lpIVTAbc->hResult      = hrSuccess;
    lpIVTAbc->idsLastError = 0;

    lpIVTAbc->hLibrary     = hLibrary;
    lpIVTAbc->lpAllocBuff  = lpAllocBuff;
    lpIVTAbc->lpAllocMore  = lpAllocMore;
    lpIVTAbc->lpFreeBuff   = lpFreeBuff;
    lpIVTAbc->lpMalloc     = lpMalloc;
    lpIVTAbc->lpABLogon    = lpABLogon;

    lpIVTAbc->lpszFileName = NULL;
    hResult = HrLpszGetCurrentFileName(lpABLogon, &(lpIVTAbc->lpszFileName));
    if (HR_FAILED(hResult))
    {
        goto err;
    }

    lpIVTAbc->lpPTAColSet = (LPSPropTagArray) &tagaivtabcColSet;

    /*
     *  Open the .FAB file associated with this logged in session.
     *  Currently it's opened with FILE_SHARED_READ.  This has an
     *  unpleasant side-effect of not being able to modify the .FAB
     *  file while this table is active.
     *
     *  It should be OF_SHARE_DENY_NONE.  I don't have the code to
     *  handle this in this version.
     */
    if ((lpIVTAbc->hFile = CreateFile(
                lpIVTAbc->lpszFileName,
                GENERIC_READ,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL)) == INVALID_HANDLE_VALUE)
    {
        /*
         *  The file didn't open...
         */

        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
        SetErrorIDS(lpABC, hResult, IDS_CANT_OPEN_FAB);

        goto err;
    }

    /*
     *  Get the time and date stamp
     *
     */
    (void)GetFileTime(lpIVTAbc->hFile, NULL, NULL, &(lpIVTAbc->filetime));

    /*  Get the size of the file */
    if ((ulSize = GetFileSize(lpIVTAbc->hFile, &ulSizeHigh)) == 0xFFFFFFFF)
    {
        /*
         *  MAYBE I have an error
         */
        if (GetLastError() != NO_ERROR)
        {
            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
            SetErrorIDS(lpABC, hResult, IDS_FAB_FILE_ATTRIB);
            goto err;
        }

        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
        SetErrorIDS(lpABC, hResult, IDS_FAB_TOO_LARGE);
        goto err;
    }

    /*
     *  Actual number of valid positions
     */
    lpIVTAbc->ulMaxPos = (ulSize / SIZEOF(ABCREC));

    /*
     *  Check to see if it's an exact multiple of sizeof(ABCREC)
     */
    if (lpIVTAbc->ulMaxPos * SIZEOF(ABCREC) != ulSize)
    {
        /*
         *  Nope.
         */

        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
        SetErrorIDS(lpABC, hResult, IDS_FAB_CORRUPT);
        goto err;
    }

    lpIVTAbc->ulPosition = 0;

    /*  Setup bookmarks  */
    for (ulBK = 0; ulBK < MAX_BOOKMARKS; lpIVTAbc->rglpABCBK[ulBK++] = NULL);

    /*
     *  Restriction stuff
     */

    lpIVTAbc->rgChecked = NULL;
    lpIVTAbc->rgMatched = NULL;
    lpIVTAbc->lpszPartialName = NULL;

    /*
     *  Registered notification stuff
     */

    lpIVTAbc->cAdvise = 0;
    lpIVTAbc->parglpAdvise = NULL;
    lpIVTAbc->ulConnectMic = (ULONG) lpIVTAbc & 0xffffff;
    InitializeCriticalSection(&lpIVTAbc->cs);

    /*
     *  Register the idle function
     */

    lpIVTAbc->ftg = FtgRegisterIdleRoutine(
        fIVTAbcIdleRoutine,
        lpIVTAbc,
        IVTABC_IDLE_PRIORITY,
        IVTABC_IDLE_INTERVAL,
        IVTABC_IDLE_FLAGS);

    InitializeCriticalSection(&lpIVTAbc->cs);

    *lppIVTAbc = (LPVOID) lpIVTAbc;

out:


    DebugTraceResult(HrNewIVTAbc, hResult);
    return hResult;

err:
    if (lpIVTAbc)
    {
        if (lpIVTAbc->hFile != INVALID_HANDLE_VALUE)
        {
            /*
             *  Must've opened the file
             */
            CloseHandle(lpIVTAbc->hFile);
        }

        /*  Free the current .FAB file name */
        lpFreeBuff(lpIVTAbc->lpszFileName);

        /*  Free the mem */
        lpFreeBuff( lpIVTAbc );
    }

    goto out;

}

/*************************************************************************
 *
 -  HrValidateEntry
 -
 *
 *  Used in restricted lists
 *  Checks to see if a given entry at a particular location matches
 *  the active restriction.  It always modifies rgChecked, and may
 *  modify rgMatched.
 */
HRESULT
HrValidateEntry(LPIVTABC lpIVTAbc, ULONG ulNewPos)
{
    ABCREC abcrec;
    ULONG cbRead;
    HRESULT hResult;

    /*
     *  Open the file
     */
    hResult = HrOpenFile(lpIVTAbc);
    if (HR_FAILED(hResult))
    {
        DebugTraceResult(HrValidateEntry, hResult);
        return hResult;
    }

    /*
     *  Set the file position to lNewPos
     */

    (void) SetFilePointer( lpIVTAbc->hFile,
                           ulNewPos * SIZEOF(ABCREC),
                           NULL,
                           FILE_BEGIN
                          );

    /*
     *  Read in the record from the file
     */
    if ( !ReadFile( lpIVTAbc->hFile, (LPVOID) &abcrec,
                    SIZEOF(ABCREC), &cbRead, NULL)
       )
    {
        DebugTraceSc(HrValidateEntry, MAPI_E_DISK_ERROR);
        return ResultFromScode(MAPI_E_DISK_ERROR);
    }

    /*  Second check  */
    if (cbRead != SIZEOF(ABCREC))
    {
        DebugTraceSc(HrValidateEntry, MAPI_E_DISK_ERROR);
        return ResultFromScode(MAPI_E_DISK_ERROR);
    }

    /*
     *  Always set the Checked flag
     */
    lpIVTAbc->rgChecked[ulNewPos / 8] |= (((UCHAR)0x80) >> (ulNewPos % 8));

    /*
     *  See if the rgchDisplayName matches the restriction
     */
    if (!FNameMatch(lpIVTAbc, abcrec.rgchDisplayName))
    {
        /*
         *  Apparently not.  Reset the Matched flag
         */

        lpIVTAbc->ulRstrDenom--;

        lpIVTAbc->rgMatched[ulNewPos / 8] &= ~(((UCHAR)0x80) >> (ulNewPos % 8));
    }

    return hrSuccess;
}

/*************************************************************************
 *
 -  FChecked
 -
 *
 *  Returns whether or not an entry has ever been checked
 *  Just looks at the bit in the rgChecked array that corresponds with
 *  lNewPos
 *
 */
BOOL
FChecked(LPIVTABC lpIVTAbc, ULONG ulNewPos)
{
    ULONG ulT = (ULONG) (lpIVTAbc->rgChecked[ulNewPos / 8] & (((UCHAR)0x80) >> (ulNewPos % 8)));

    return (BOOL) !!ulT;
}

/*************************************************************************
 *
 -  FMatched
 -
 *
 *  Returns whether or not an entry has been matched
 *  Just checks the bit in the rgMatched array corresponding with
 *  lNewPos
 *
 */
BOOL
FMatched(LPIVTABC lpIVTAbc, ULONG ulNewPos)
{
    ULONG ulT = (lpIVTAbc->rgMatched[ulNewPos / 8] & (((UCHAR)0x80) >> (ulNewPos % 8)));

    return (BOOL) !!ulT;

}

/*************************************************************************
 *
 -  FNameMatch
 -
 *  Tries to match the rgchDisplayName with the partial name of the
 *  restriction.
 *  It tries to prefix match each partial name component (i.e. word) with
 *  each rgchDisplayName name component (i.e. word).  Only if all of them
 *  match (from the partial name) does this return TRUE.
 */
BOOL
FCharInString(LPTSTR lpsz, TCHAR ch);


BOOL
FNameMatch(LPIVTABC lpIVTAbc, LPTSTR rgchDisplayName)
{
    LPTSTR szANRSep = TEXT(", -");
    LPTSTR szANR = lpIVTAbc->lpszPartialName;
    LPTSTR pchEndSzANR = szANR + lstrlen(szANR);
    ULONG cchANRName;
    ULONG cchFullNameName;
    LPTSTR szFullNameT;
    LPTSTR szT;

    /*  If someone tries to match more than an iwMOMax-part name, the function
     *  will return fFalse.  But then if someone is trying to match a name
     *  with iwMOMax parts, chances are they weren't going to get it right
     *  anyway....
     */

#define iwMOMax 50

    WORD rgwMO[iwMOMax];
    int iwMOMac = 0;

    while (TRUE)
    {
        /*  Find the end of the partial name we're pointing at  */

        szT = szANR;
        while (!FCharInString(szANRSep, *szT))
            ++szT;
        cchANRName = szT - szANR;

        /*  Check if it matches any name in the full name  */

        szFullNameT = rgchDisplayName;
        while (TRUE)
        {
            szT = szFullNameT;

            /*  Find the length of the name in the full name  */
            /*  we're checking against.                       */

            while (!FCharInString(szANRSep, *szT))
                ++szT;
            cchFullNameName = szT - szFullNameT;

            if (cchANRName <= cchFullNameName &&
                CompareString( lcidUser,
                               NORM_IGNORECASE,
                               szANR,
                               (int) cchANRName,
                               szFullNameT,
                               (int) cchANRName) == 2 )
            {
                int iwMO;

                for (iwMO = 0; iwMO < iwMOMac; iwMO++)
                    if (rgwMO[iwMO] == (WORD) (szFullNameT - rgchDisplayName))
                        break;

                /*  We found the partial name so check the next ANR part */
                if (iwMO == iwMOMac)
                {
                    if (iwMOMac == iwMOMax - 1)
                    {
                        /*  If some user wants to match an iwMOMax part
                         *  name, chances are it wasn't going to match
                         *  anyway...
                         */
                        return FALSE;
                    }
                    rgwMO[iwMOMac++] = szFullNameT - rgchDisplayName;
                    break;
                }
            }

            /*  We didn't find the partial name this time around, so
             *  try to check the next name in the full name.
             */

            szFullNameT += cchFullNameName;

            while (*szFullNameT && FCharInString(szANRSep, *szFullNameT))
                ++szFullNameT;

            if (*szFullNameT == TEXT('\0'))
                return FALSE;   /*  We never found the partial name. */
        }

        /* We found the partial name, so check the next ANR part */

        szANR += cchANRName;
        while (*szANR && FCharInString(szANRSep, *szANR))
            ++szANR;

        if (*szANR == TEXT('\0'))
            return TRUE;        /* No more ANR to check, so we found `em all  */
    }

    /*  Not reached (we hope...)  */
    return FALSE;
}

/*
 -  HrOpenFile
 -
 *  Opens the .FAB file associated with the table and
 *  checks whether the .FAB file has changed.
 *  If it has changed, the table bookmarks and ANR bitmaps
 *  are updated and everyone on the advise list is notified.
 */
HRESULT
HrOpenFile(LPIVTABC lpIVTAbc)
{
    HRESULT hResult = hrSuccess;
    FILETIME filetime;
    ULONG ulSize, ulSizeHigh, ulMaxPos;
    LPTSTR lpszFileName = NULL;

    /*
     *  If file is not open, open it
     */
    if (lpIVTAbc->hFile == INVALID_HANDLE_VALUE)
    {

        if (!FEqualFABFiles(lpIVTAbc->lpABLogon, lpIVTAbc->lpszFileName))
        {
            /*
             *  Get the new file name
             */
            hResult = HrLpszGetCurrentFileName(lpIVTAbc->lpABLogon, &lpszFileName);
            if (HR_FAILED(hResult))
            {
                goto err;
            }

            /*
             *  Replace the old one with this
             */
            lpIVTAbc->lpFreeBuff(lpIVTAbc->lpszFileName);
            lpIVTAbc->lpszFileName = lpszFileName;

            lpszFileName = NULL;
        }


        /*
         *  File is not open so lets try to open it
         */
        lpIVTAbc->hFile = CreateFile(
            lpIVTAbc->lpszFileName,
            GENERIC_READ,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (lpIVTAbc->hFile == INVALID_HANDLE_VALUE)
        {
            /*
             *  The file didn't open...
             */
            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
            SetErrorIDS(lpIVTAbc, hResult, IDS_CANT_OPEN_FAB_FILE);
            goto err;
        }
    }

    /*
     *  Get the time and date stamp
     */
    if (!GetFileTime(lpIVTAbc->hFile, NULL, NULL, &filetime))
    {
        if (GetLastError() != NO_ERROR)
        {
            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
            SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_FILE_ATTRIB);
        }

        goto err;
    }

    /*  Get the size of the file */
    if ((ulSize = GetFileSize(lpIVTAbc->hFile, &ulSizeHigh)) == 0xFFFFFFFF)
    {
        /*
         *  MAYBE I have an error
         */
        if (GetLastError() != NO_ERROR)
        {
            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
            SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_FILE_ATTRIB);
            goto err;
        }

        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
        SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_TOO_LARGE);
        goto err;
    }

    /*
     *  Actual number of valid positions
     */
    ulMaxPos = (ulSize / SIZEOF(ABCREC));

    /*
     *  Check to see if it's an exact multiple of sizeof(ABCREC)
     */
    if (ulMaxPos * SIZEOF(ABCREC) != ulSize)
    {
        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
        SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_CORRUPT);
        goto err;
    }

    /*
     *  if the file has changed set new position, reset bookmarks etc and
     *  notify everybody on the advise list
     */
    if (CompareFileTime(&filetime, &lpIVTAbc->filetime) || ulMaxPos != lpIVTAbc->ulMaxPos)
    {
        ULONG ulBK;
        ABCREC abcrec;
        ULONG cbT;
        LPMAPIADVISESINK *ppadvise;
        ULONG cAdvises;
        NOTIFICATION notif;

        /* save new max position and filetime */
        lpIVTAbc->filetime = filetime;
        lpIVTAbc->ulMaxPos = ulMaxPos;

        /* if current position is past the end of file set it to the end */
        if (lpIVTAbc->ulPosition > lpIVTAbc->ulMaxPos)
            lpIVTAbc->ulPosition = lpIVTAbc->ulMaxPos;

        if (ulMaxPos)
        {
            SetFilePointer(lpIVTAbc->hFile, (ulMaxPos - 1)*sizeof(ABCREC), NULL, FILE_BEGIN);

            /*  Read in the record at that location  */
            if ( !ReadFile(lpIVTAbc->hFile, (LPVOID) &abcrec,
                           SIZEOF(ABCREC), &cbT, NULL)
               )
            {
                hResult = ResultFromScode(MAPI_E_DISK_ERROR);
                SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_NO_READ);

                goto err;
            }

            /* if any of the bookmarks are past the end of file
             * set the file time to current file time, the position to last
             * record and record to last record
             */
            for (ulBK = 0; ulBK < MAX_BOOKMARKS; ulBK++)
                if (lpIVTAbc->rglpABCBK[ulBK] &&
                    lpIVTAbc->rglpABCBK[ulBK]->ulPosition > lpIVTAbc->ulMaxPos)
                {
                    lpIVTAbc->rglpABCBK[ulBK]->ulPosition = ulMaxPos - 1;
                    lpIVTAbc->rglpABCBK[ulBK]->filetime = filetime;
                    lpIVTAbc->rglpABCBK[ulBK]->abcrec = abcrec;
                }

            /*
            *  Reallocate the checked&matched arrays
            */

            cbT = (lpIVTAbc->ulMaxPos) / 8 + 1; /* Number of bytes in both arrays */

            /* Reallocate ANR bitmaps */
            if (lpIVTAbc->rgChecked)
            {
                lpIVTAbc->rgChecked = lpIVTAbc->lpMalloc->lpVtbl->Realloc(
                    lpIVTAbc->lpMalloc,
                    lpIVTAbc->rgChecked,
                    cbT);
            }

            if (lpIVTAbc->rgMatched)
            {
                lpIVTAbc->rgMatched = lpIVTAbc->lpMalloc->lpVtbl->Realloc(
                    lpIVTAbc->lpMalloc,
                    lpIVTAbc->rgMatched,
                    cbT);
            }
        }
        else
        {
            /* if any of the bookmarks are past the end of file
             * set the file time to current file time, the position to the
             * beginning of the file.
             */
            for (ulBK = 0; ulBK < MAX_BOOKMARKS; ulBK++)
                if (lpIVTAbc->rglpABCBK[ulBK] &&
                    lpIVTAbc->rglpABCBK[ulBK]->ulPosition > lpIVTAbc->ulMaxPos)
                {
                    lpIVTAbc->rglpABCBK[ulBK]->ulPosition = 0;
                    lpIVTAbc->rglpABCBK[ulBK]->filetime = filetime;
                }

            /* free the ANR bitmaps */
            FreeANRBitmaps(lpIVTAbc);
        }

        /* initialize the notification */
        RtlZeroMemory(&notif, SIZEOF(NOTIFICATION));
        notif.ulEventType = fnevTableModified;
        notif.info.tab.ulTableEvent = TABLE_CHANGED;

        /* notify everyone that the table has changed */
        for( ppadvise = lpIVTAbc->parglpAdvise, cAdvises = 0;
             cAdvises < lpIVTAbc->cAdvise;
             ++ppadvise, ++cAdvises
            )
        {
            Assert(*ppadvise);
            if (ppadvise)
                (void)(*ppadvise)->lpVtbl->OnNotify(*ppadvise, 1, &notif);
        }
    }

out:

    DebugTraceResult(NewIVTAbc, hResult);
    return hResult;
err:
    lpIVTAbc->lpFreeBuff(lpszFileName);

    goto out;

}

/*************************************************************************
 *
 -  fIVTAbcIdleRoutine
 -
 *  This function called during idle time closes the .FAB file and notifies
 *  everyone on the advise list if the file name has changed
 *
 */

BOOL STDAPICALLTYPE
fIVTAbcIdleRoutine(LPVOID lpv)
{
    LPIVTABC lpIVTAbc = (LPIVTABC) lpv;

    Assert(lpv);

    /* if file is open close it  */
    if (lpIVTAbc->hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(lpIVTAbc->hFile);
        lpIVTAbc->hFile = INVALID_HANDLE_VALUE;
    }

    /* has file name has changed? */
    if (!FEqualFABFiles(lpIVTAbc->lpABLogon, lpIVTAbc->lpszFileName))
    {
        /* file name has changed so call HrOpenFile to reset bookmarks etc */
        if (!HR_FAILED(HrOpenFile(lpIVTAbc)))
        {
            /* close the file */
            CloseHandle(lpIVTAbc->hFile);
            lpIVTAbc->hFile = INVALID_HANDLE_VALUE;
        }
    }
    return TRUE;
}

/*************************************************************************
 *
 -  FreeANRBitmaps
 -
 *  Frees the two ANR bitmaps associated with this table
 *
 *
 */
void
FreeANRBitmaps(LPIVTABC lpIVTAbc)
{
    if (lpIVTAbc->rgChecked)
    {
        lpIVTAbc->lpMalloc->lpVtbl->Free(lpIVTAbc->lpMalloc, lpIVTAbc->rgChecked);
        lpIVTAbc->rgChecked = NULL;
    }

    if (lpIVTAbc->rgMatched)
    {
        lpIVTAbc->lpMalloc->lpVtbl->Free(lpIVTAbc->lpMalloc, lpIVTAbc->rgMatched);
        lpIVTAbc->rgMatched = NULL;
    }
}



/*
 *  FCharInString
 *
 *  Finds a character in a string
 */
BOOL
FCharInString(LPTSTR lpsz, TCHAR ch)
{

    while (*lpsz && *lpsz != ch)
        lpsz++;

    return (*lpsz == ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abcont.c ===
/***********************************************************************
 *
 *  ABCONT.C
 *
 *  Microsoft At Work Fax AB directory container object
 *
 *  This file contains the code for implementing the Microsoft At Work Fax AB
 *  directory container object.
 *
 *  This directory container was retrieved by OpenEntry on the entryid
 *  retrieved from the single row of the hierarchy table (IVTROOT in root.c).
 *
 *  Many things are not yet implemented in this object.  For example, no
 *  advanced search dialog, or details dialog are available.  Also the
 *  ICON to PR_DISPLAY_TYPE table isn't available.
 *
 *
 *  The following routines are implemented in this file:
 *
 *              HrNewFaxDirectory
 *      ABC_Release
 *      ABC_SaveChanges
 *      ABC_OpenProperty
 *      ABC_GetContentsTable
 *      ABC_GetHierarchyTable
 *
 *      HrGetDetailsDialog
 *
 *      HrNewABCButton
 *      ABCBUTT_QueryInterface
 *      ABCBUTT_Release
 *      ABCBUTT_Activate
 *      ABCBUTT_GetState
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *  Revision History:
 *
 *              When            Who                                     What
 *              --------        ------------------  ---------------------------------------
 *              1.1.94          MAPI                            Original source from MAPI sample AB Provider
 *              1.27.94         Yoram Yaacovi           Modifications to make it an At Work Fax ABP
 *      3.6.94                  Yoram Yaacovi           Update to MAPI build 154
 *      4.1.94                  Yoram Yaacovi           Update to MAPI and Sample AB build 157
 *      8.1.94                  Yoram Yaacovi           Update to MAPI and Sample AB build 304
 *      10.6.94                 Yoram Yaacovi           Update to MAPI and Sample AB build 313
 *                                                                                      Mainly adding a ResolveName method to ABContainer
 *              11.3.94                 Yoram Yaacovi           Update to MAPI 318.
 *
 ***********************************************************************/

#include "faxab.h"

#define PR_BUTTON_PRESS                 PROP_TAG(PT_OBJECT, 0x6603)
#define PR_FAB_FILE_TEMP_A              PROP_TAG(PT_STRING8,0x6605)
#define PR_IMPORT_FROM_FILE_A           PROP_TAG(PT_STRING8,0x6606)
#define PR_IMPORT_TO_FILE_A             PROP_TAG(PT_STRING8,0x6607)
#define PR_BUTTON_IMPORT_A              PROP_TAG(PT_STRING8,0x6608)
#define PR_IMPORT_FORMAT_A              PROP_TAG(PT_STRING8,0x6609)
#define PR_DDLBX_IMPORT_FORMATS_A       PROP_TAG(PT_STRING8,0x660a)
#define FAB_FILE_NAME_NOTIF_ID          99L

/*****************************
 ****  Notification **********
 *****************************/

typedef struct
{
    MAPIUID muid;
    ULONG   ulIdc;
}   NOTIFDATA;


NOTIFDATA notifdata = { MUIDABMAWF, IDC_DIR_FAB_FILE_NAME };

/*****************************
 ** Display Table structures *
 *****************************/

DTBLEDIT editDirFileName     =
{
    SIZEOF(DTBLEDIT),
    0,
    MAX_PATH,
    PR_FAB_FILE_TEMP_A
};

DTBLEDIT editImportFromFile  =
{
    SIZEOF(DTBLEDIT),
    0,
    MAX_PATH,
    PR_IMPORT_FROM_FILE_A
};

DTBLEDIT editImportToFile    =
{
    SIZEOF(DTBLEDIT),
    0,
    MAX_PATH,
    PR_IMPORT_TO_FILE_A
};

DTBLBUTTON buttonImport      =
{
    SIZEOF(DTBLBUTTON),
    0,
    PR_BUTTON_IMPORT_A
};

DTBLBUTTON buttonDirChange   =
{
    SIZEOF(DTBLBUTTON),
    0,
    PR_BUTTON_PRESS
};

DTBLDDLBX ddlbxImportFormats =
{
    SIZEOF(DTBLDDLBX),
    PR_DISPLAY_NAME_A,
    PR_IMPORT_FORMAT_A,
    PR_DDLBX_IMPORT_FORMATS_A
};

/* General page layout */

DTCTL rgdtctlDirGeneral[] =
{
    /* directory general propery page */
    { DTCT_PAGE,     0, NULL, 0, NULL, 0,                  &dtblpage },

    /* static controls and edit control containing fab file name */
    { DTCT_LABEL,    0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel },
    { DTCT_LABEL,    0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel },
    { DTCT_EDIT,     0, (LPBYTE)&notifdata, SIZEOF(NOTIFDATA), (LPTSTR)szFileNameFilter, IDC_DIR_FAB_FILE_NAME, &editDirFileName },

    /* push button for changing fab file */
    { DTCT_BUTTON,   0, NULL, 0, NULL, IDC_DIR_CHANGE,     &buttonDirChange },

    /* Import GroupBox */
    { DTCT_GROUPBOX, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtblgroupbox },

    // Import from file
    { DTCT_LABEL,    0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel },
    { DTCT_EDIT,     0, NULL, 0, (LPTSTR)szFileNameFilter, IDC_IMPORT_FROM_FILE, &editImportFromFile },

    // Import format
    { DTCT_LABEL,    0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel },
    { DTCT_DDLBX,    0, NULL, 0, NULL, IDC_IMPORT_FORMAT,  &ddlbxImportFormats },

    // Import into file
    { DTCT_LABEL,    0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel },
    { DTCT_EDIT,     0, NULL, 0, (LPTSTR)szFileNameFilter, IDC_IMPORT_TO_FILE, &editImportToFile },

    // Import Button
    { DTCT_BUTTON,   0, NULL, 0, NULL, IDC_IMPORT,         &buttonImport },

};


/* Display table pages for Directory */

DTPAGE rgdtpageDir[] =
{
    {
        SIZEOF(rgdtctlDirGeneral) / SIZEOF(DTCTL),
        (LPTSTR)MAKEINTRESOURCE(DirGeneralPage),
        TEXT(""),
        rgdtctlDirGeneral
    }
};



/*
 *  ABCont jump table is defined here...
 */

ABC_Vtbl vtblABC =
{
    (ABC_QueryInterface_METHOD *)    ROOT_QueryInterface,
    (ABC_AddRef_METHOD *)            ROOT_AddRef,
    (ABC_AddRef_METHOD *)            ABC_Release,
    (ABC_GetLastError_METHOD *)      ROOT_GetLastError,
    ABC_SaveChanges,
    (ABC_GetProps_METHOD *)          WRAP_GetProps,
    (ABC_GetPropList_METHOD *)       WRAP_GetPropList,
    ABC_OpenProperty,
    (ABC_SetProps_METHOD *)          WRAP_SetProps,
    (ABC_DeleteProps_METHOD *)       WRAP_DeleteProps,
    (ABC_CopyTo_METHOD *)            WRAP_CopyTo,
    (ABC_CopyProps_METHOD *)         WRAP_CopyProps,
    (ABC_GetNamesFromIDs_METHOD *)   WRAP_GetNamesFromIDs,
    (ABC_GetIDsFromNames_METHOD *)   WRAP_GetIDsFromNames,
    ABC_GetContentsTable,
    ABC_GetHierarchyTable,
    (ABC_OpenEntry_METHOD *)         ROOT_OpenEntry,
    (ABC_SetSearchCriteria_METHOD *) ROOT_SetSearchCriteria,
    (ABC_GetSearchCriteria_METHOD *) ROOT_GetSearchCriteria,
    (ABC_CreateEntry_METHOD *)       ROOT_CreateEntry,
    (ABC_CopyEntries_METHOD *)       ROOT_CopyEntries,
    (ABC_DeleteEntries_METHOD *)     ROOT_DeleteEntries,
    (ABC_ResolveNames_METHOD *)      ROOT_ResolveNames
};

static const SizedSPropTagArray(1, ABC_SPT_TMP_FAB) = {1, {PR_FAB_FILE_TEMP_A}};


/*
 *  Private functions
 */
HRESULT HrNewABCButton( LPABCNT lpABC,
                        ULONG ulInterfaceOptions,
                        ULONG ulFlags,
                        LPMAPICONTROL FAR * lppMAPICont);

HRESULT HrGetSearchDialog(LPABCNT lpABC, LPMAPITABLE * lppSearchTable);
HRESULT HrGetDetailsDialog(LPABCNT lpABC, LPMAPITABLE * lppDetailsTable);

/*************************************************************************
 *
 -  HrNewFaxDirectory
 -
 *  Creates a Directory container object.
 *
 *
 */

/*
 *  Properties that are initially set on this object
 */
enum {  ivalabcPR_DISPLAY_TYPE = 0,
        ivalabcPR_OBJECT_TYPE,
        ivalabcPR_ENTRYID,
        ivalabcPR_RECORD_KEY,
        ivalabcPR_SEARCH_KEY,
        ivalabcPR_DISPLAY_NAME,
        ivalabcPR_CONTAINER_FLAGS,
        ivalabcPR_FAB_FILE,
        ivalabcPR_FAB_FILE_TEMP,
        ivalabcPR_IMPORT_FROM_FILE,
        ivalabcPR_IMPORT_TO_FILE,
        ivalabcPR_IMPORT_FORMAT,
        cvalabcMax };

HRESULT
HrNewFaxDirectory( LPABCONT *          lppABC,
                   ULONG *             lpulObjType,
                   LPABLOGON           lpABLogon,
                   LPCIID              lpInterface,
                   HINSTANCE           hLibrary,
                   LPALLOCATEBUFFER    lpAllocBuff,
                   LPALLOCATEMORE      lpAllocMore,
                   LPFREEBUFFER        lpFreeBuff,
                   LPMALLOC            lpMalloc )
{
    HINSTANCE      hInst;
    HRESULT        hResult = hrSuccess;
    LPABCNT        lpABC = NULL;
    SCODE          sc;
    LPPROPDATA     lpPropData = NULL;
    SPropValue     spv[cvalabcMax];
    MAPIUID *      lpMuidLogon;
    LPTSTR         lpszFileName;
#ifdef UNICODE
    CHAR           szAnsiFileName[ MAX_PATH ];
#endif
    ULONG          ulPropAccess = IPROP_CLEAN|IPROP_READWRITE; /* READWRITE is redundant */
    DIR_ENTRYID    eidRoot =   { {0, 0, 0, 0},
                                 MUIDABMAWF,
                                 MAWF_VERSION,
                                 MAWF_DIRECTORY
                                };

    /*  Do I support this interface?? */
    if (lpInterface)
    {
        if (memcmp(lpInterface, &IID_IABContainer,   SIZEOF(IID)) &&
            memcmp(lpInterface, &IID_IMAPIContainer, SIZEOF(IID)) &&
            memcmp(lpInterface, &IID_IMAPIProp,      SIZEOF(IID)) &&
            memcmp(lpInterface, &IID_IUnknown,       SIZEOF(IID)))
        {
            DebugTraceSc(HrNewSampDirectory, MAPI_E_INTERFACE_NOT_SUPPORTED);
            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        }
    }

    /*
     *  Allocate space for the directory container structure
     */

    sc = lpAllocBuff( SIZEOF(ABCNT), (LPVOID *) & lpABC);

    if (sc != SUCCESS_SUCCESS)
    {
        DebugTraceSc( HrNewFaxDirectory, sc );
        hResult = ResultFromScode( sc );
        goto err;
    }

    lpABC->lpVtbl = &vtblABC;
    lpABC->lcInit = 1;
    lpABC->hResult = hrSuccess;
    lpABC->idsLastError = 0;

    lpABC->hLibrary = hLibrary;
    lpABC->lpAllocBuff = lpAllocBuff;
    lpABC->lpAllocMore = lpAllocMore;
    lpABC->lpFreeBuff = lpFreeBuff;
    lpABC->lpMalloc = lpMalloc;

    lpABC->lpABLogon = lpABLogon;
    lpABC->lpTDatDetails = NULL;

    // Get the instance handle, so that I can get the display strings off the resource file
    hInst = lpABC->hLibrary;

    /*
     *  Create lpPropData
     */

    sc = CreateIProp( (LPIID) &IID_IMAPIPropData,
                              lpAllocBuff,
                              lpAllocMore,
                              lpFreeBuff,
                              lpMalloc,
                              &lpPropData
                             );

    if (FAILED(sc))
    {
        DebugTraceSc(HrNewFaxDirectory, sc);
        hResult=ResultFromScode (sc);
        goto err;
    }

    /*
     *  initialize the muid in the entry id
     */
    lpMuidLogon = LpMuidFromLogon(lpABLogon);
    eidRoot.muidID = *lpMuidLogon;


    /*
     *  Set up initial set of properties associated with this
     *  container.
     */

    spv[ivalabcPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    spv[ivalabcPR_DISPLAY_TYPE].Value.l   = DT_NOT_SPECIFIC;

    spv[ivalabcPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    spv[ivalabcPR_OBJECT_TYPE].Value.l   = MAPI_ABCONT;

    spv[ivalabcPR_ENTRYID].ulPropTag     = PR_ENTRYID;
    spv[ivalabcPR_ENTRYID].Value.bin.cb  = SIZEOF(DIR_ENTRYID);
    spv[ivalabcPR_ENTRYID].Value.bin.lpb = (LPBYTE) &eidRoot;

    spv[ivalabcPR_RECORD_KEY].ulPropTag     = PR_RECORD_KEY;
    spv[ivalabcPR_RECORD_KEY].Value.bin.cb  = SIZEOF(DIR_ENTRYID);
    spv[ivalabcPR_RECORD_KEY].Value.bin.lpb = (LPBYTE) &eidRoot;

    spv[ivalabcPR_SEARCH_KEY].ulPropTag     = PR_SEARCH_KEY;
    spv[ivalabcPR_SEARCH_KEY].Value.bin.cb  = SIZEOF(DIR_ENTRYID);
    spv[ivalabcPR_SEARCH_KEY].Value.bin.lpb = (LPBYTE) &eidRoot;


    // MAPI is not UNICODE for this one...
    spv[ivalabcPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME_A;

    // MAPI 304 sample AB
    // GenerateContainerDN(lpABLogon, szBuf);
    // spv[ivalabcPR_DISPLAY_NAME].Value.LPSZ = szBuf;
    if ( (sc = lpAllocMore( MAX_DISPLAY_NAME,
                            (LPVOID) lpABC,
                            (LPVOID *) & spv[ivalabcPR_DISPLAY_NAME].Value.lpszA)) != SUCCESS_SUCCESS)
    {
        hResult = ResultFromScode( sc );
        goto err;
    }
    else
    {
        // Load the strings
        // A display name longer than MAX_DISPLAY_NAME will be truncated
        // MAPI is not UNICODE for this attribute
        LoadStringA( hInst,
                     IDS_APP_NAME,
                     spv[ivalabcPR_DISPLAY_NAME].Value.lpszA,
                     MAX_DISPLAY_NAME
                    );
    }


    spv[ivalabcPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    spv[ivalabcPR_CONTAINER_FLAGS].Value.l   = AB_RECIPIENTS;

    /*
     *  Get the current .FAB file name from our logon object
     */
    hResult = HrLpszGetCurrentFileName(lpABLogon, &lpszFileName);
    if (HR_FAILED(hResult))
    {
        goto err;
    }

    // MAPI ==>  NO UNICODE FOR YOU!  <MAPI Doesn't like UNICODE>

#ifdef UNICODE
    spv[ivalabcPR_FAB_FILE].ulPropTag          = PR_FAB_FILE_A;
    szAnsiFileName[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, lpszFileName, -1, szAnsiFileName, ARRAYSIZE(szAnsiFileName), NULL, NULL );
    spv[ivalabcPR_FAB_FILE].Value.lpszA        = szAnsiFileName;

    spv[ivalabcPR_FAB_FILE_TEMP].ulPropTag     = PR_FAB_FILE_TEMP_A;
    spv[ivalabcPR_FAB_FILE_TEMP].Value.lpszA   = szAnsiFileName;

    spv[ivalabcPR_IMPORT_FROM_FILE].ulPropTag   = PR_IMPORT_FROM_FILE_A;
    spv[ivalabcPR_IMPORT_FROM_FILE].Value.lpszA = "";

    spv[ivalabcPR_IMPORT_TO_FILE].ulPropTag    = PR_IMPORT_TO_FILE_A;
    spv[ivalabcPR_IMPORT_TO_FILE].Value.lpszA  = szAnsiFileName;
#else
    spv[ivalabcPR_FAB_FILE].ulPropTag          = PR_FAB_FILE_A;
    spv[ivalabcPR_FAB_FILE].Value.lpszA        = (LPSTR)lpszFileName;

    spv[ivalabcPR_FAB_FILE_TEMP].ulPropTag     = PR_FAB_FILE_TEMP_A;
    spv[ivalabcPR_FAB_FILE_TEMP].Value.lpszA   = (LPSTR)lpszFileName;

    spv[ivalabcPR_IMPORT_FROM_FILE].ulPropTag   = PR_IMPORT_FROM_FILE_A;
    spv[ivalabcPR_IMPORT_FROM_FILE].Value.lpszA = "";

    spv[ivalabcPR_IMPORT_TO_FILE].ulPropTag    = PR_IMPORT_TO_FILE_A;
    spv[ivalabcPR_IMPORT_TO_FILE].Value.lpszA  = (LPSTR)lpszFileName;
#endif

    spv[ivalabcPR_IMPORT_FORMAT].ulPropTag     = PR_IMPORT_FORMAT_A;
    spv[ivalabcPR_IMPORT_FORMAT].Value.lpszA   = "Your Favorite PIM";


    /*
     *   Set the default properties
     */
    hResult = lpPropData->lpVtbl->SetProps( lpPropData,
                                            cvalabcMax,
                                            spv,
                                            NULL
                                           );

    /*
     *  No longer need this buffer
     */
    lpFreeBuff(lpszFileName);

    if (HR_FAILED(hResult))
    {
        DebugTraceSc( HrNewFaxDirectory, sc );
        goto err;
    }

    lpPropData->lpVtbl->HrSetPropAccess( lpPropData,
                                         (LPSPropTagArray) &ABC_SPT_TMP_FAB,
                                         &ulPropAccess
                                        );

    InitializeCriticalSection( &lpABC->cs );

    lpABC->lpPropData = (LPMAPIPROP)lpPropData;
    *lppABC           = (LPABCONT)lpABC;
    *lpulObjType      = MAPI_ABCONT;

out:

    DebugTraceResult(HrNewFaxDirectory, hResult);
    return hResult;

err:
    /*
     *  free the ABContainer object
     */
    lpFreeBuff( lpABC );

    /*
     *  free the property storage object
     */
    if (lpPropData)
        lpPropData->lpVtbl->Release(lpPropData);

    goto out;
}

/***************************************************
 *
 *  The actual ABContainer methods
 */

/* --------
 * IUnknown
 */
/*************************************************************************
 *
 *
 -  ABC_QueryInterface
 -
 *
 *      Uses the ROOT method
 *
 */

/*************************************************************************
 *
 -  ABC_AddRef
 -
 *
 *      Uses the ROOT method
 *
 */

/**************************************************
 *
 -  ABC_Release
 -
 *      Decrement lpInit.
 *              When lcInit == 0, free up the lpABC structure
 *
 */

STDMETHODIMP_(ULONG)
ABC_Release(LPABCNT lpABC)
{

    long lcInit;

    /*
     *  Check to see if it has a jump table
     */
    if (IsBadReadPtr(lpABC, SIZEOF(ABCNT)))
    {
        /*
         *  No jump table found
         */
        return 1;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABC->lpVtbl != &vtblABC)
    {
        /*
         *  Not my jump table
         */
        return 1;
    }

    EnterCriticalSection(&lpABC->cs);
    lcInit = --lpABC->lcInit;
    LeaveCriticalSection(&lpABC->cs);

    if (lcInit == 0)
    {

        /*
         *  Get rid of the lpPropData
         */
        if (lpABC->lpPropData)
            lpABC->lpPropData->lpVtbl->Release(lpABC->lpPropData);

        /*
         *  Get rid of the details table
         */
        if (lpABC->lpTDatDetails)
            lpABC->lpTDatDetails->lpVtbl->Release(lpABC->lpTDatDetails);

        /*
         *  Destroy the critical section for this object
         */

        DeleteCriticalSection(&lpABC->cs);

        /*
         *  Set the Jump table to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */
        lpABC->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpABC->lpFreeBuff(lpABC);
        return 0;
    }

    return lpABC->lcInit;

}

/* ---------
 * IMAPIProp
 */

/*
 *  GetLastError - use ROOT's
 *
 *
 */

/*************************************************************************
 *
 -  ABC_SaveChanges
 -
 *  This is used to save changes associated with the search dialog
 *  in order to get the advanced search restriction and to save changes
 *  associated with the container details dialog.
 *
 */
SPropTagArray SPT_FAB_FILE =
{
    1,
    {
        PR_FAB_FILE_TEMP_A
    }
};

STDMETHODIMP
ABC_SaveChanges (LPABCNT lpABC, ULONG ulFlags)
{

    HRESULT         hResult    = hrSuccess;
    ULONG           ulCount;
    LPSPropValue    lpspv      = NULL;
    ULONG FAR *     rgulAccess = NULL;
    ULONG           ulAccess   = IPROP_CLEAN|IPROP_READWRITE; /* READWRITE is redundant */
    LPSPropTagArray lpspt      = (LPSPropTagArray) &ABC_SPT_TMP_FAB;
    LPPROPDATA      lpPropData = (LPPROPDATA) lpABC->lpPropData;
#ifdef UNICODE
    WCHAR           szFileName[ MAX_PATH ];
#endif

    /*
     *  Check to see if it has a jump table
     */
    if (IsBadReadPtr(lpABC, sizeof(ABCNT)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);
        return hResult;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABC->lpVtbl != &vtblABC)
    {
        /*
         *  Not my jump table
         */
        hResult = ResultFromScode(E_INVALIDARG);
        return hResult;
    }

    EnterCriticalSection(&lpABC->cs);

    /*
     *  Check to see if anyone has dirtied the PR_FAB_FILE_TEMP
     */
    lpPropData->lpVtbl->HrGetPropAccess( lpPropData, (LPSPropTagArray *) &lpspt, &rgulAccess);

    if (!rgulAccess || !((*rgulAccess) & IPROP_DIRTY))
    {
        /*
         *  No, nothing to update then head on out
         */

        goto ret;
    }

    /*
     *  Go ahead and set back to being clean
     */
    (void )lpPropData->lpVtbl->HrSetPropAccess( lpPropData, (LPSPropTagArray) lpspt, &ulAccess);

    /*
     *  Get the temporary fab file name
     */
    hResult = lpPropData->lpVtbl->GetProps(
                  lpPropData,
                  &SPT_FAB_FILE,
                  0,      // ansi
                  &ulCount,
                  &lpspv);

    if (HR_FAILED(hResult))
    {
        goto ret;
    }


    if (lpspv->ulPropTag != PR_FAB_FILE_TEMP_A)
    {
        /*
         *  There's no reason this property shouldn't be there.
         */
        hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);
        goto ret;
    }

    /*
     *  Save the new name back into the object as PR_FAB_FILE
     */
    lpspv->ulPropTag = PR_FAB_FILE_A;

    hResult = lpPropData->lpVtbl->SetProps(
                  lpPropData,
                  1,            // ANSI
                  lpspv, NULL);

    if (HR_FAILED(hResult))
    {
        /*
         *  Do nothing...  So I couldn't save it away this time...
         */
        hResult = hrSuccess;
        goto ret;
    }

    /*
     *  Update every other object that needs this new information
     */
#ifdef UNICODE
    szFileName[0] = 0;
    MultiByteToWideChar( CP_ACP, 0, lpspv->Value.lpszA, -1, szFileName, ARRAYSIZE(szFileName) );
    hResult = HrReplaceCurrentFileName(lpABC->lpABLogon, szFileName);
#else
    hResult = HrReplaceCurrentFileName(lpABC->lpABLogon, lpspv->Value.LPSZ);
#endif


ret:

    LeaveCriticalSection(&lpABC->cs);

    lpABC->lpFreeBuff(lpspv);
    lpABC->lpFreeBuff(rgulAccess);
    DebugTraceResult(ABC_SaveChanges, hResult);
    return hResult;
}


/*************************************************************************
 *
 -  ABC_OpenProperty
 -
 *  This method allows the opening of the following object:
 *
 *  PR_BUTTON_PRESS  :-  Gets the MAPIControl object associated
 *                       with the button on this container's details.
 *  PR_DETAILS_TABLE :-  Gets the display table associated with
 *                       the details for this container.
 *  PR_SEARCH        :-  Gets the advanced search object associated with
 *                       this container.
 *  PR_CONTAINER_CONTENTS  :-  Same as GetContentsTable()
 *  PR_CONTAINER_HIERARCHY :-  Same as GetHierarchyTable()
 *
 */
STDMETHODIMP
ABC_OpenProperty( LPABCNT lpABC,
                  ULONG ulPropTag,
                  LPCIID lpiid,
                  ULONG ulInterfaceOptions,
                  ULONG ulFlags,
                  LPUNKNOWN * lppUnk
                 )
{

    HRESULT hResult;


    /*
     *  Check to see if it has a jump table
     */
    if (IsBadReadPtr(lpABC, SIZEOF(ABCNT)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode( E_INVALIDARG );

        DebugTraceResult( ABC_OpenProperty, hResult );
        goto out;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABC->lpVtbl != &vtblABC)
    {
        /*
         *  Not my jump table
         */
        hResult = ResultFromScode( E_INVALIDARG );

        DebugTraceResult(ABC_OpenProperty, hResult);
        goto out;
    }

    if (IsBadWritePtr(lppUnk, sizeof(LPUNKNOWN)))
    {
        /*
         *  Got to be able to return an object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        /*
         *  An interface ID is required for this call.
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *      check for unknown flags
     */
    if (ulFlags & ~(MAPI_DEFERRED_ERRORS | MAPI_CREATE | MAPI_MODIFY))
    {
        hResult = ResultFromScode (MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(ABC_OpenProperty, hResult);
        goto out;
    }

    /*
     *  Check for flags we can't support
     */

    if (ulFlags & (MAPI_CREATE|MAPI_MODIFY))
    {
        hResult = ResultFromScode (E_ACCESSDENIED);

        DebugTraceResult(ABC_OpenProperty, hResult);
        goto out;
    }


    if (ulInterfaceOptions & ~MAPI_UNICODE)
    {
        /*
         *  Only UNICODE flag should be set for any of the objects that might
         *  be returned from this object.
         */

        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
        hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH);
        DebugTraceArg( ABC_OpenProperty, "bad character width" );
        goto out;

    }

    /*
     *  Details for this directory entry
     */

    if ( (ulPropTag == PR_DETAILS_TABLE)      ||
         (ulPropTag == PR_BUTTON_PRESS)       ||
         (ulPropTag == PR_CONTAINER_CONTENTS) ||
         (ulPropTag == PR_CONTAINER_HIERARCHY)||
         (ulPropTag == PR_SEARCH)
        )
    {

        /*
         *  Check to see if they're expecting a table interface
         */
        if ( (ulPropTag != PR_BUTTON_PRESS) &&
             (ulPropTag != PR_SEARCH) &&
             memcmp(lpiid, &IID_IMAPITable, sizeof(IID))
            )
        {
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto out;
        }

        switch (ulPropTag)
        {

        case PR_BUTTON_PRESS:
        {
            /*
             *  Check to see if they're expecting a generic control interface
             */
            if (memcmp( lpiid, &IID_IMAPIControl, SIZEOF(IID) ))
            {
                hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
                goto out;
            }

            hResult = HrNewABCButton( lpABC,
                                      ulInterfaceOptions,
                                      ulFlags,
                                      (LPMAPICONTROL FAR *) lppUnk
                                     );

            break;
        }


        case PR_DETAILS_TABLE:
        {
            hResult = HrGetDetailsDialog(lpABC, (LPMAPITABLE *) lppUnk);
            break;
        }

        case PR_SEARCH:
        {
            /*
             *  Check to see if they're expecting a generic control interface
             */
            if (memcmp(lpiid, &IID_IMAPIContainer, SIZEOF(IID)))
            {
                hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
                goto out;
            }

            hResult = HrNewSearch( (LPMAPICONTAINER *) lppUnk,
                                   lpABC->lpABLogon,
                                   lpiid,
                                   lpABC->hLibrary,
                                   lpABC->lpAllocBuff,
                                   lpABC->lpAllocMore,
                                   lpABC->lpFreeBuff,
                                   lpABC->lpMalloc
                                  );
            break;
        }

        case PR_CONTAINER_CONTENTS:
        {
            hResult = ABC_GetContentsTable( lpABC, 0, (LPMAPITABLE *) lppUnk);
            break;
        }

        case PR_CONTAINER_HIERARCHY:
        {
            hResult = ABC_GetHierarchyTable( lpABC, 0, (LPMAPITABLE *) lppUnk);
            break;
        }

        default:
            break;
        }
    }
    else
    {
        hResult = ResultFromScode (MAPI_E_NO_SUPPORT);
    }

out:

    DebugTraceResult(ABC_OpenProperty, hResult);
    return hResult;
}



/*************************************************************************
 *
 -  ABC_GetContentsTable
 -
 *
 *  Retrieves the IMAPITable that has the contents of this container.
 *  The big one!
 */
STDMETHODIMP
ABC_GetContentsTable( LPABCNT lpABC,
                      ULONG ulFlags,
                      LPMAPITABLE * lppTable
                     )
{

    HRESULT hResult;

    /*
     *  Validate parameters
     */


    /*
     *  Check to see if it's large enough to be this object
     */
    if (IsBadReadPtr(lpABC, SIZEOF(ABCNT)))
    {
        /*
         *  Not large enough to be this object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABC->lpVtbl != &vtblABC)
    {
        /*
         *  Not my jump table
         */
        hResult = ResultFromScode (E_INVALIDARG);
        goto out;
    }

    /*
     *  Check lppTable to validate its writability
     */
    if (IsBadWritePtr (lppTable, SIZEOF(LPMAPITABLE)))
    {
        hResult = ResultFromScode (E_INVALIDARG);
        goto out;
    }

    /*
     *  Check flags
     */
    if (ulFlags & ~(MAPI_UNICODE|MAPI_DEFERRED_ERRORS|MAPI_ASSOCIATED))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    /*
     *  Certain flags are not supported
     */
    if (ulFlags & (MAPI_ASSOCIATED))
    {
        hResult = ResultFromScode(MAPI_E_NO_SUPPORT);
        goto out;
    }

    if ( ulFlags & MAPI_UNICODE )
    {
        DebugTraceArg( ABC_GetContentsTable, "Bad character width" );
        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        goto out;
    }

    /*
     *  Create the new Contents table
     */
    hResult = HrNewIVTAbc( lppTable,
                           lpABC->lpABLogon,
                           (LPABCONT) lpABC,
                           lpABC->hLibrary,
                           lpABC->lpAllocBuff,
                           lpABC->lpAllocMore,
                           lpABC->lpFreeBuff,
                           lpABC->lpMalloc
                          );

out:

    DebugTraceResult(ABC_GetContentsTable, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  ABC_GetHierarchyTable
 -
 *
 *  There is no hierarchy table associated with this object.
 *
 */
STDMETHODIMP
ABC_GetHierarchyTable( LPABCNT lpABC,
                       ULONG ulFlags,
                       LPMAPITABLE * lppTable
                      )
{
    HRESULT hResult;
    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpABC, offsetof(ABCNT, lpVtbl)+SIZEOF(ABC_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        hResult = MakeResult(E_INVALIDARG);
        DebugTraceResult(ABC_HierarchyTable, hResult);
        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpABC->lpVtbl,
        offsetof(ABC_Vtbl, GetHierarchyTable)+SIZEOF(ABC_GetHierarchyTable_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = MakeResult(E_INVALIDARG);
        DebugTraceResult(ABC_HierarchyTable, hResult);
        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ABC_GetHierarchyTable != lpABC->lpVtbl->GetHierarchyTable)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ABC_HierarchyTable, hResult);
        return hResult;
    }

    /*
     *  See if I can set the return variable
     */
    if (IsBadWritePtr(lppTable, SIZEOF(LPMAPITABLE)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check flags:
     *    The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS
     */

    if (ulFlags & ~(CONVENIENT_DEPTH | MAPI_DEFERRED_ERRORS))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    /*
     *  We don't support this method on this object
     */
    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:


    DebugTraceResult(ABC_GetHierarchyTable, hResult);
    return hResult;
}

/*
 *  OpenEntry() <- uses ROOT's
 */

/*
 *  SetSearchCriteria() <- uses ROOT's
 */

/*
 *  GetSearchCriteria() <- uses ROOT's
 */

/*
 *  ABC_CreateEntry() <- uses ROOT's
 */

/*
 *  ABC_CopyEntries() <- uses ROOT's
 */

/*
 *  ABC_DeleteEntries() <- uses ROOT's
 */

/**********************************************************************
 *
 *  Private functions
 */

/*
 -  HrGetDetailsDialog
 -
 *  Builds a display table for this directory.
 */

HRESULT
HrGetDetailsDialog(LPABCNT lpABC, LPMAPITABLE * lppDetailsTable)
{
    HRESULT hResult;

        /* Create a display table */
    if (!lpABC->lpTDatDetails)
    {

        /* Create a display table */
        hResult = BuildDisplayTable(
            lpABC->lpAllocBuff,
            lpABC->lpAllocMore,
            lpABC->lpFreeBuff,
            lpABC->lpMalloc,
            lpABC->hLibrary,
            SIZEOF(rgdtpageDir) / SIZEOF(DTPAGE),
            rgdtpageDir,
            0,
            lppDetailsTable,
            &lpABC->lpTDatDetails);
    }
    else
    {
        hResult = lpABC->lpTDatDetails->lpVtbl->HrGetView(
            lpABC->lpTDatDetails,
            NULL,
            NULL,
            0,
            lppDetailsTable);
    }

    DebugTraceResult(HrGetDetailsDialog, hResult);
    return hResult;
}


/*
 *  Button object for this directory's details dialog
 */

ABCBUTT_Vtbl vtblABCBUTT =
{
    ABCBUTT_QueryInterface,
    (ABCBUTT_AddRef_METHOD *) ROOT_AddRef,
    ABCBUTT_Release,
    (ABCBUTT_GetLastError_METHOD *) ROOT_GetLastError,
    ABCBUTT_Activate,
    ABCBUTT_GetState
};


HRESULT
HrNewABCButton( LPABCNT lpABC,
                ULONG ulInterfaceOptions,
                ULONG ulFlags,
                LPMAPICONTROL FAR * lppMAPICont
               )
{
    LPABCBUTT lpABCButt = NULL;
    SCODE scode;

    /*
     *  Creates a the object behind the button control in the directory
     *  details dialog...
     */

    scode = lpABC->lpAllocBuff(SIZEOF(ABCBUTT),(LPVOID *) &lpABCButt);

    if (FAILED(scode))
    {
        DebugTraceSc(HrNewABCButton, scode);
        return ResultFromScode(scode);
    }

    lpABCButt->lpVtbl = &vtblABCBUTT;
    lpABCButt->lcInit = 1;
    lpABCButt->hResult = hrSuccess;
    lpABCButt->idsLastError = 0;

    lpABCButt->hLibrary    = lpABC->hLibrary;
    lpABCButt->lpAllocBuff = lpABC->lpAllocBuff;
    lpABCButt->lpAllocMore = lpABC->lpAllocMore;
    lpABCButt->lpFreeBuff  = lpABC->lpFreeBuff;
    lpABCButt->lpMalloc    = lpABC->lpMalloc;
    lpABCButt->lpABC       = lpABC;

    lpABC->lpVtbl->AddRef(lpABC);

    InitializeCriticalSection(&lpABCButt->cs);

    *lppMAPICont = (LPMAPICONTROL) lpABCButt;

    return hrSuccess;
}

/*************************************************************************
 *
 *
 -  ABCBUTT_QueryInterface
 -
 *
 *  Allows QI'ing to IUnknown and IMAPIControl.
 *
 *
 */
STDMETHODIMP
ABCBUTT_QueryInterface( LPABCBUTT lpABCButt,
                        REFIID lpiid,
                        LPVOID FAR * lppNewObj
                       )
{

    HRESULT hResult = hrSuccess;

    /*      Minimally validate the lpABCButt parameter */

    if (IsBadReadPtr(lpABCButt, SIZEOF(ABCBUTT)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (lpABCButt->lpVtbl != &vtblABCBUTT)
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Check the other parameters */

    if (!lpiid || IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, (UINT) SIZEOF(LPVOID)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*      See if the requested interface is one of ours */

    if ( memcmp (lpiid, &IID_IUnknown,     SIZEOF(IID)) &&
         memcmp (lpiid, &IID_IMAPIControl, SIZEOF(IID))
        )
    {
        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */
        hResult = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

        /*      We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpABCButt->cs);
    ++lpABCButt->lcInit;
    LeaveCriticalSection(&lpABCButt->cs);

    *lppNewObj = lpABCButt;

out:

    DebugTraceResult(ABCBUTT_QueryInterface, hResult);
    return hResult;
}


/*
 -  ABCBUTT_Release
 -
 *  Releases and cleans up this object
 */
STDMETHODIMP_(ULONG)
ABCBUTT_Release(LPABCBUTT lpABCButt)
{
    long lcInit;

    /*  Minimally validate the lpABCButt parameter */

    if (IsBadReadPtr(lpABCButt, SIZEOF(ABCBUTT)))
    {
        return 1;
    }

    if (lpABCButt->lpVtbl != &vtblABCBUTT)
    {
        return 1;
    }

    EnterCriticalSection(&lpABCButt->cs);
    lcInit = --lpABCButt->lcInit;
    LeaveCriticalSection(&lpABCButt->cs);

    if (lcInit == 0)
    {

        /*
         *  Release my parent
         */
        lpABCButt->lpABC->lpVtbl->Release(lpABCButt->lpABC);

        /*
         *  Destroy the critical section for this object
         */

        DeleteCriticalSection(&lpABCButt->cs);

        /*
         *  Set the Jump table to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */
        lpABCButt->lpVtbl = NULL;

        /*
         *  Free the object
         */

        lpABCButt->lpFreeBuff(lpABCButt);
        return 0;
    }

    return lcInit;

}

/*
 -  ABCBUTT_Activate
 -
 *
 *  Activates this control.  In this case, it brings up the common file browsing
 *  dialog and allows the user to pick a different .SAB file.
 *
 *  Note that if all is successful it sends a display table notification.  The UI
 *  will respond to this by updating the particular control that was said to have
 *  changed in the notification.
 */
STDMETHODIMP
ABCBUTT_Activate( LPABCBUTT lpABCButt,
                  ULONG     ulFlags,
                  ULONG     ulUIParam
                 )
{
    HRESULT         hResult = hrSuccess;
    OPENFILENAME    openfilename;
    TCHAR           szFileName[MAX_PATH];
    TCHAR           szDirName[MAX_PATH];
    SPropValue      sProp;
    LPSPropValue    lpspv = NULL;
    ULONG           ulCount,ich;
#ifdef UNICODE
    CHAR            szAnsiFileName[ MAX_PATH ];
#endif

    /*  Minimally validate the lpABCButt parameter */

    if (IsBadReadPtr(lpABCButt, SIZEOF(ABCBUTT)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (lpABCButt->lpVtbl != &vtblABCBUTT)
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }


    if (ulFlags)
    {
        /*
         *  No flags defined for this method
         */
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }


    /*
     *  First, get the old FAB file name so that it shows up in the
     *  choose file dialog
     */

    hResult = lpABCButt->lpABC->lpPropData->lpVtbl->GetProps(
                  lpABCButt->lpABC->lpPropData,
                  &SPT_FAB_FILE,
                  0,              /* ansi */
                  &ulCount,
                  &lpspv);

    if (HR_FAILED(hResult))
    {
        goto out;
    }

    if (lpspv->ulPropTag != PR_FAB_FILE_TEMP_A)
    {
        /*
         *  Property wasn't there...
         */
        hResult = ResultFromScode(MAPI_E_CORRUPT_DATA);

        goto out;
    }

#ifdef UNICODE
    szFileName[0] = 0;
    MultiByteToWideChar( CP_ACP, 0, lpspv->Value.lpszA, -1, szFileName, ARRAYSIZE(szFileName) );
#else
    lstrcpy(szFileName, lpspv->Value.lpszA);
#endif

    szDirName[0] = TEXT('\0');


    /* get the path name */
    // MAPI --> NO UNICODE FOR YOU!  (These must be ANSI)
    for (ich = lstrlenA(lpspv->Value.lpszA) - 1; ich >= 0; ich--)
    {
        if (lpspv->Value.lpszA[ich] == '\\')
        {
            lpspv->Value.lpszA[ich] = '\0';
            break;
        }
        else if (lpspv->Value.lpszA[ich] == ':')
        {
            lpspv->Value.lpszA[ich + 1] = '\0';
            break;
        }
    }

#ifdef UNICODE
    szDirName[0] = 0;
    MultiByteToWideChar( CP_ACP, 0, lpspv->Value.lpszA, -1, szDirName, ARRAYSIZE(szDirName) );
#else
    lstrcpy(szDirName, lpspv->Value.lpszA);
#endif

    /*
     *  Get the user to select one
     */
    openfilename.lStructSize       = SIZEOF(OPENFILENAME);
    openfilename.hwndOwner         = (HWND) ulUIParam;
    openfilename.hInstance         = 0;     /* Ignored */
    openfilename.lpstrFilter       = TEXT("Microsoft Fax Address Book files\0*.fab\0\0");
    openfilename.lpstrCustomFilter = NULL;
    openfilename.nMaxCustFilter    = 0;
    openfilename.nFilterIndex      = 0;
    openfilename.lpstrFile         = szFileName;
    openfilename.nMaxFile          = MAX_PATH;
    openfilename.lpstrFileTitle    = NULL;
    openfilename.nMaxFileTitle     = 0;
    openfilename.lpstrInitialDir   = szDirName;
    openfilename.lpstrTitle        = TEXT("Microsoft Fax Address Book");
    openfilename.Flags             = OFN_FILEMUSTEXIST |
                                     OFN_HIDEREADONLY  |
                                     OFN_NOCHANGEDIR;
    openfilename.nFileOffset       = 0;
    openfilename.nFileExtension    = 0;
    openfilename.lpstrDefExt       = TEXT("fab");
    openfilename.lCustData         = 0;
    openfilename.lpfnHook          = NULL;
    openfilename.lpTemplateName    = NULL;

    /*
     *  Call up the common dialog
     */
    if (!GetOpenFileName( &openfilename ))
    {
        hResult = hrSuccess;
        goto out;
    }

    /*
     *      Save FAB FileName into the container object
     */

    sProp.ulPropTag  = PR_FAB_FILE_TEMP_A;
#ifdef UNICODE
    szAnsiFileName[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, szFileName, -1, szAnsiFileName, ARRAYSIZE(szAnsiFileName), NULL, NULL );
    sProp.Value.lpszA = szAnsiFileName;
#else
    sProp.Value.lpszA = szFileName;
#endif

    hResult = lpABCButt->lpABC->lpPropData->lpVtbl->SetProps(
                                    lpABCButt->lpABC->lpPropData,
                                    1,      // ansi
                                    &sProp,
                                    NULL);
    if (HR_FAILED(hResult))
    {
        goto out;
    }


    /*
     *      Notify the details table so that everyone with a view open
     *  will get notified
     */
    if (lpABCButt->lpABC->lpTDatDetails)
    {
            sProp.ulPropTag         = PR_CONTROL_ID;
            sProp.Value.bin.lpb     = (LPBYTE)&notifdata;
            sProp.Value.bin.cb      = SIZEOF(NOTIFDATA);

        hResult = lpABCButt->lpABC->lpTDatDetails->lpVtbl->HrNotify(
                          lpABCButt->lpABC->lpTDatDetails,
                          0,
                          1,
                          &sProp);
    }

out:
    lpABCButt->lpFreeBuff(lpspv);
    DebugTraceResult(ABCBUTT_Activate, hResult);
    return hResult;
}

/*
 -  ABCBUTT_GetState
 -
 *  Says whether this control should appear enabled or not at this time.
 *
 */
STDMETHODIMP
ABCBUTT_GetState( LPABCBUTT     lpABCButt,
                  ULONG         ulFlags,
                  ULONG *       lpulState
                 )
{
    HRESULT hResult = hrSuccess;

    /*  Minimally validate the lpABCButt parameter */

    if (IsBadReadPtr(lpABCButt, SIZEOF(ABCBUTT)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (lpABCButt->lpVtbl != &vtblABCBUTT)
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lpulState, SIZEOF(ULONG)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ulFlags)
    {
        /*
         *  No flags defined for this method
         */
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    /*
     *  Means that at this time this button should appear enabled.
     */
    *lpulState = MAPI_ENABLED;

out:
    DebugTraceResult(ABCBUTT_GetState, hResult);
    return hResult;
}

#undef _FAXAB_ABCONT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abcont.h ===
/***********************************************************************
 *
 *  _ABCONT.H
 *
 *  Header file for code in ABCONT.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/



/*  Function prototypes */

/*
 *  Reuses methods:
 *		ROOT_QueryInterface
 *		ROOT_AddRef
 *		ROOT_GetLastError
 *		WRAP_GetProps
 *		WRAP_GetPropList
 *		WRAP_SetProps
 *		WRAP_DeleteProps
 *		WRAP_CopyTo
 *		WRAP_CopyProps
 *		WRAP_GetNamesFromIDs
 *		WRAP_GetIDsFromNames
 *		ROOT_OpenEntry
 *		ROOT_SetSearchCriteria
 *		ROOT_GetSearchCriteria
 *		ROOT_CreateEntry
 *		ROOT_CopyEntries
 *		ROOT_DeleteEntries
 */

#undef	INTERFACE
#define INTERFACE	struct _ABCNT

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ABC_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAPICONTAINER_METHODS(IMPL)
		MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ABC_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAPICONTAINER_METHODS(IMPL)
		MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABC_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IMAPICONTAINER_METHODS(IMPL)
	MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _ABCNT
{
    const ABC_Vtbl FAR * lpVtbl;

    FAB_Wrapped;

	/* details display table */
	LPTABLEDATA	lpTDatDetails;

} ABCNT, *LPABCNT;

#define CBABC	sizeof(ABCNT)

/*
 *
 *  Declaration of button control on Directory Details
 *
 */


#undef	INTERFACE
#define	INTERFACE	struct _ABCBUTT

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,ABCBUTT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPICONTROL_METHODS(IMPL)

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_TYPEDEF(type,method,ABCBUTT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPICONTROL_METHODS(IMPL)

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(ABCBUTT_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPICONTROL_METHODS(IMPL)
};

/*
 *  Creates a new directory container object (see ABCONT.C)
 */
HRESULT 
HrNewFaxDirectory(  LPABCONT *          lppABC,
                    ULONG *             lpulObjType,
                    LPABLOGON           lpABPLogon,
                    LPCIID              lpInterface,
                    HINSTANCE           hLibrary,
                    LPALLOCATEBUFFER    lpAllocBuff,
                    LPALLOCATEMORE      lpAllocMore,
                    LPFREEBUFFER        lpFreeBuff,
                    LPMALLOC            lpMalloc );


/*
 * Button interface for buttons in the address book container UI
 */

typedef struct _ABCBUTT
{
	ABCBUTT_Vtbl FAR * lpVtbl;

	/*
	 *  Need to be the same as other objects
	 *  since this object reuses methods from
	 *  other objects.
	 */
								   
    FAB_IUnknown;

    /*
     *  My parent container object
     */
    LPABCNT     lpABC;

	/*  Private data */

} ABCBUTT, *LPABCBUTT;

#define CBABCBUTT	sizeof(ABCBUTT)

/*
 *  Declaration of IMAPIContainer object implementation
 *  Code for this is in ABSEARCH.C
 */
#undef  INTERFACE
#define INTERFACE   struct _ABSRCH

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABSRCH_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        MAPI_IMAPIPROP_METHODS(IMPL)
        MAPI_IMAPICONTAINER_METHODS(IMPL)
        MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABSRCH_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        MAPI_IMAPIPROP_METHODS(IMPL)
        MAPI_IMAPICONTAINER_METHODS(IMPL)
        MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABSRCH_)
{
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
};



/*
 *  Structure for the 'this'
 */

typedef struct _ABSRCH
{
    const ABSRCH_Vtbl FAR * lpVtbl;

    FAB_Wrapped;

    /*  Private data */

    LPSPropValue lpRestrictData;
    
} ABSRCH, *LPABSRCH;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abctbl2.c ===
/***********************************************************************
 *
 *  ABCTBL2.C
 *
 *  Contents Table - Part 2.
 *
 *
 *  The following routines are implemented in this file.
 *
 *
 *      IVTABC_SeekRow
 *      IVTABC_SeekRowApprox
 *      IVTABC_GetRowCount
 *      IVTABC_QueryPosition
 *      IVTABC_FindRow
 *      IVTABC_Restrict
 *      IVTABC_QueryRows
 *
 *
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *      1.1.94          MAPI                            Original source from MAPI sample AB Provider
 *      3.7.94          Yoram Yaacovi           Update to MAPI build 154
 *      3.11.94         Yoram Yaacovi           Update to use Fax AB include files
 *      8.1.94          Yoram Yaacovi           Update to MAPI 304
 *      11.7.94         Yoram Yaacovi           Update to MAPI 318 (PR_INSTANCE_KEY)
 *
 ***********************************************************************/

#include "faxab.h"


/*************************************************************************
 *
 -  IVTABC_SeekRow
 -
 *
 *  Tries to seek an appropriate number of rows.
 *
 *
 */
STDMETHODIMP
IVTABC_SeekRow( LPIVTABC lpIVTAbc,
                BOOKMARK bkOrigin,
                LONG lRowCount,
                LONG * lplRowsSought
               )
{
    LONG lNewPos;
    LONG lMoved;
    LONG lDelta;
    LONG lLast;
    HRESULT hResult = hrSuccess;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SeekRow, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SeekRow, hResult);
        return hResult;
    }

    /*
     *  Check the out parameter for writability (if requested)
     */
    if (lplRowsSought &&
        IsBadWritePtr(lplRowsSought, SIZEOF(LONG)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SeekRow, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);



    if (bkOrigin == BOOKMARK_BEGINNING)
    {
        lNewPos = 0;

    }
    else if (bkOrigin == BOOKMARK_CURRENT)
    {
        lNewPos = lpIVTAbc->ulPosition;

    }
    else if (bkOrigin == BOOKMARK_END)
    {
        lNewPos = lpIVTAbc->ulMaxPos;

    }
    else
    {
        ULONG ulBK = (ULONG) bkOrigin - 3;
        LPABCBK lpABCBK = NULL;

        /*
         *  See if it's out of range
         */
        if (ulBK < 0 || ulBK >= MAX_BOOKMARKS)
        {
            /*
             *  bad book mark, it's an error, so...
             */
            hResult = ResultFromScode(E_INVALIDARG);

            goto out;
        }

        if (!(lpABCBK = lpIVTAbc->rglpABCBK[ulBK]))
        {
            /*
             *  bookmark has not been allocated
             */
            hResult = ResultFromScode(MAPI_E_INVALID_BOOKMARK);

            goto out;
        }

        /* Not validating existing bookmark  */
        lNewPos = lpABCBK->ulPosition;
    }

    /*
     *  Figure out what endpoint to use and what direction to go to
     *  get there.
     */
    if (lRowCount < 0)
    {
        lLast = 0;
        lDelta = -1;
    }
    else
    {
        lLast = lpIVTAbc->ulMaxPos;
        lDelta = 1;
    }

    /*
     *  While there's rows to seek ...
     */
    lMoved = 0;
    while( (lNewPos != lLast) && (lMoved != lRowCount) )
    {
        lNewPos += lDelta;

        /*
         *  Unrestricted list is easy: just seek.  Also, if the next
         *  'row' is the end of the table, just go there; don't want
         *  to check it against any restriction.
         */
        if ( (!lpIVTAbc->lpszPartialName) || (lNewPos == (LONG) lpIVTAbc->ulMaxPos))
        {
            lMoved += lDelta;
        }

        /*
         *  Otherwise, deal with the restricted list:  only count
         *  the row if it's in the restriction.
         */
        else
        {
            if (!FChecked(lpIVTAbc, (ULONG) lNewPos))
            {
                hResult = HrValidateEntry(lpIVTAbc, (ULONG) lNewPos);

                if (HR_FAILED(hResult))
                {
                    goto out;
                }
            }

            if (FMatched(lpIVTAbc, (ULONG) lNewPos))
            {
                lMoved += lDelta;
            }
        }
    }

    if (lplRowsSought)
        *lplRowsSought = lMoved;

    lpIVTAbc->ulPosition = lNewPos;

out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_SeekRow, hResult);
    return hResult;

}

/*************************************************************************
 *
 -  IVTABC_SeekRowApprox
 -
 *  Tries to set the position of the table according to the approximate
 *  position passed in.
 *
 *
 */
STDMETHODIMP
IVTABC_SeekRowApprox( LPIVTABC lpIVTAbc,
                      ULONG ulNumerator,
                      ULONG ulDenominator
                     )
{
    HRESULT hResult = hrSuccess;
    ULONG iByte;
    BYTE bCount;
    ULONG ulPos = 0;
    ULONG ulCount = 0;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SeekRowApprox, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SeekRowApprox, hResult);
        return hResult;
    }

    /*
     *  0 denominator is not allowed
     */
    if (!ulDenominator)
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SeekRowApprox, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);


    if (ulNumerator >= ulDenominator)
    {
        /*  We're at the end of the list */
        lpIVTAbc->ulPosition = lpIVTAbc->ulMaxPos;

        hResult = hrSuccess;
        goto out;
    }

    /*
     *  Since I'm using muldiv() which takes ints/longs, I should shift right
     *  so that I don't incorrectly call it.
     *  I'm really just checking to see if the sign bit is set...
     */

    if (((long)ulNumerator < 0) || ((long)ulDenominator < 0))
    {
        ulNumerator >>= 1;
        ulDenominator >>= 1;
    }

    if (!lpIVTAbc->lpszPartialName)
    {
        /*
         *  The NON-Restriction method
         */

        lpIVTAbc->ulPosition = MULDIV(lpIVTAbc->ulMaxPos, ulNumerator, ulDenominator);

        hResult = hrSuccess;
        goto out;
    }

    /*
     *  Restriction method
     */

    /*  Figure out % of which corresponds with numerator. */
    ulCount = MULDIV(lpIVTAbc->ulRstrDenom, ulNumerator, ulDenominator);

    /*  Count bits in rgMatched until I match numerator */

    for (iByte = 0; iByte < (lpIVTAbc->ulMaxPos / 8); iByte++)
    {
        CBitsB(lpIVTAbc->rgMatched[iByte], bCount); /* <-- MACRO  */
        ulPos += (ULONG) bCount;

        if (ulPos >= ulCount)
        {
            ulPos -= bCount;    /* Go back a byte */
            break;
        }
    }

    /*  My current position is there. */
    lpIVTAbc->ulPosition = iByte * 8;


out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_SeekRowApprox, hResult);
    return hResult;

}

/*************************************************************************
 *
 -  IVTABC_GetRowCount
 -
 *
 *  If there's a restriction applied, I don't necessarily know how many
 *  rows there are...
 */

STDMETHODIMP
IVTABC_GetRowCount( LPIVTABC lpIVTAbc,
                    ULONG ulFlags,
                    ULONG * lpulCount
                   )
{
    HRESULT hResult;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetRowCount, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetRowCount, hResult);
        return hResult;
    }

    /*
     *  Check the out parameters for writability
     */
    if (IsBadWritePtr(lpulCount, sizeof(ULONG)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetRowCount, hResult);
        return hResult;
    }

    if (ulFlags & ~TBL_NOWAIT)
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(IVTABC_GetRowCount, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);

    /*
     *  If there's no restriction, you can actually calculate this..
     */
    if (!lpIVTAbc->lpszPartialName)
    {

        /*
         *  Number of actual rows
         */
        *lpulCount = lpIVTAbc->ulMaxPos;
        hResult = hrSuccess;
        goto out;
    }

    /*
     *  There's no way that I can tell how many actual entries there
     *  are without counting them.  That takes way too long, so we give
     *  the client our best guess.
     */

    *lpulCount = lpIVTAbc->ulRstrDenom;

    /*
     *  Then we warn the client that this count may not be accurate
     */

    hResult = ResultFromScode(MAPI_W_APPROX_COUNT);

out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_GetRowCount, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  IVTABC_QueryPosition
 -
 *  Figures out the current fractional position
 *
 *
 *
 */
STDMETHODIMP
IVTABC_QueryPosition( LPIVTABC lpIVTAbc,
                      ULONG * lpulRow,
                      ULONG * lpulNumerator,
                      ULONG * lpulDenominator
                     )
{
    HRESULT hResult = hrSuccess;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryPosition, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryPosition, hResult);
        return hResult;
    }

    /*
     *  Check the out parameters for writability
     */
    if ( IsBadWritePtr(lpulRow,           SIZEOF(ULONG))
        || IsBadWritePtr(lpulNumerator,   SIZEOF(ULONG))
        || IsBadWritePtr(lpulDenominator, SIZEOF(ULONG))
       )
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryPosition, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);


    /*  ...I don't have a restriction  */
    if (!lpIVTAbc->lpszPartialName)
    {
        *lpulRow = lpIVTAbc->ulPosition;

        *lpulNumerator = lpIVTAbc->ulPosition;
        *lpulDenominator = lpIVTAbc->ulMaxPos;
    }
    else
    {
        BYTE bCount = 0;
        BYTE bFrag;
        ULONG iByte;

        /*
         *  Zero out fraction
         */
        *lpulNumerator = 0;

        /*
         *  Set denominator that we've been keeping track of.
         */
        *lpulDenominator = (lpIVTAbc->ulRstrDenom ? lpIVTAbc->ulRstrDenom : 1);

        /*
         *  Handle corner case - we're at the beginning of the list...
         */
        if (lpIVTAbc->ulPosition == 0)
        {
            *lpulRow = 0;
            goto out;
        }

        /*
         *  Calculate Numerator
         *  We use the rgMatched bit array and count the bits up to
         *  our current position (lpIVTAbc->ulPosition).
         *
         */
        for (iByte = 0; iByte < (lpIVTAbc->ulPosition / 8); iByte++)
        {
            CBitsB(lpIVTAbc->rgMatched[iByte], bCount); /* <-- MACRO  */
            *lpulNumerator += (ULONG) bCount;
        }
        /*  Count the fragment  */
        bFrag = lpIVTAbc->rgMatched[iByte];
        bFrag = bFrag >> (8 - (lpIVTAbc->ulPosition % 8));

        CBitsB(bFrag, bCount);
        *lpulNumerator += (ULONG) bCount;

        /*
         *  Good guess here...
         */
        *lpulRow = *lpulNumerator;

    }

out:

    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_QueryPosition, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  IVTABC_FindRow
 -
 *
 *  Prefix searches to find a row
 *
 *
 */
STDMETHODIMP
IVTABC_FindRow( LPIVTABC lpIVTAbc,
                LPSRestriction lpRestriction,
                BOOKMARK bkOrigin,
                ULONG ulFlags
               )
{
    HRESULT hResult = hrSuccess;

    ULONG cbRead;
    ABCREC abcrec;
    LONG lpos;
    ULONG fFound = FALSE;
    LPTSTR szPrefix;
    int nCmpResult;

    ULONG ulCurMin;
    ULONG ulCurMac;
    ULONG ulPosT;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_FindRow, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_FindRow, hResult);
        return hResult;
    }

    /*
     *  Check flags
     */
    if (ulFlags & ~DIR_BACKWARD)
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(IVTABC_FindRow, hResult);
        return hResult;
    }

    /*
     *  I don't go backwards, yet.
     */
    if (ulFlags & DIR_BACKWARD)
    {
        hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

        DebugTraceResult(IVTABC_FindRow, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);

    /*
     *  Open the file
     */
    hResult = HrOpenFile(lpIVTAbc);
    if (HR_FAILED(hResult))
    {
        goto out;
    }

    /*
     *  initialize
     */
    ulCurMin = lpIVTAbc->ulPosition;
    ulCurMac = lpIVTAbc->ulMaxPos;

    /*
     *  I handle two type of restrictions:
     *              prefix searching on Display Names
     *              Finding a row based on it's instance key
     */

    /*
     *  The restriction looks like:
     *
     *  +-----------------
     *  | RES_PROPERTY
     *  +-----------------
     *  | RELOP_GE
     *  +-----------------
     *  | PR_DISPLAY_NAME
     *  +-----------------
     *  | LPSPropVal   -----+
     *  +-----------------  |
     *                      |   +-------------------------
     *                      +-->| PR_DISPLAY_NAME
     *                          +-------------------------
     *                          | 0 <-- for alignment (don't care)
     *                          +-------------------------
     *                          | lpszA <-- prefix for display name
     *                          +-------------------------
     *
     *
     *                              -OR-
     *
     *  Find a row based on it's instance key
     *
     *  +-----------------
     *  | RES_PROPERTY
     *  +-----------------
     *  | RELOP_EQ
     *  +-----------------
     *  | PR_INSTANCE_KEY
     *  +-----------------
     *  | LPSPropVal   -----+
     *  +-----------------  |
     *                      |   +-------------------------
     *                      +-->| PR_INSTANCE_KEY
     *                          +-------------------------
     *                          |     | cbInstanceKey
     *                          + bin +-------------------
     *                          |     | lpbInstanceKey
     *                          +-------------------------
     *
     *
     *  If it doesn't look like one of these, return MAPI_E_TOO_COMPLEX.
     */

    /*
     *  Both restrictions require this one
     */
    if (lpRestriction->rt != RES_PROPERTY)
    {
        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

        goto out;
    }

    /*
     *  Look for Instance Key first - it's easiest to handle
     */
    if (lpRestriction->res.resProperty.relop == RELOP_EQ)
    {
        LPABCRecInstance lpABCRecInstance;

        if (lpRestriction->res.resProperty.ulPropTag != PR_INSTANCE_KEY)
        {
            /*
             *  Clearly something we don't recognize
             */
            hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

            goto out;
        }

        /*
         *  Crack the bin part of this restriction and
         *  see if we can still find our way back to this
         *  record - quickly...
         */
        lpABCRecInstance = (LPABCRecInstance) lpRestriction->res.resProperty.lpProp->Value.bin.lpb;

        /*
         *  First check to see that we're browsing the same file
         */
        if (lstrcmp(lpABCRecInstance->rgchzFileName, lpIVTAbc->lpszFileName))
        {
            /*
             *  Nope, different names, return not found and leave our position alone...
             */
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            goto out;
        }

        /*
         *  Ok, so we think we're browsing the same file.  Has it been modified since the
         *  last time we looked?
         */
        if (memcmp(&(lpABCRecInstance->filetime), &(lpIVTAbc->filetime), SIZEOF(FILETIME)))
        {
            /*
             *  Nope, they're different, so no guarantees here...
             */
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            goto out;
        }

        /*
         *  Now, I feel pretty confident about this instance key.  Just set my current position
         *  and go for it.
         */
        lpIVTAbc->ulPosition = lpABCRecInstance->ulRecordPosition;

        /* Done */
        goto out;

    }

    /*
     *  Now we're looking for prefix searching on display name
     */
    if (lpRestriction->res.resProperty.relop != RELOP_GE)
    {
        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

        goto out;
    }

    if (lpRestriction->res.resProperty.ulPropTag != PR_DISPLAY_NAME_A)
    {
        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

        goto out;
    }

    szPrefix = lpRestriction->res.resProperty.lpProp->Value.LPSZ;

    if (bkOrigin == BOOKMARK_BEGINNING)
    {
        ulCurMin = 0;

    }
    else if (bkOrigin == BOOKMARK_END)
    {
        ulCurMin = lpIVTAbc->ulMaxPos;

    }
    else if (bkOrigin != BOOKMARK_CURRENT)
    {
        ULONG ulBK = (ULONG) bkOrigin - 3;
        LPABCBK lpABCBK = NULL;

        /*
         *  See if it's out of range
         */
        if (ulBK < 0 || ulBK >= MAX_BOOKMARKS)
        {
            /*
             *  bad book mark, it's an error, so...
             */
            hResult = ResultFromScode(E_INVALIDARG);

            goto out;
        }

        if (!(lpABCBK = lpIVTAbc->rglpABCBK[ulBK]))
        {
            /*
             *  bookmark has not been allocated
             */
            hResult = ResultFromScode(MAPI_E_INVALID_BOOKMARK);

            goto out;
        }

        /*  Not validating existing bookmark  */
        ulCurMin = lpABCBK->ulPosition;
    }

    while (ulCurMin < ulCurMac)
    {
        /*
         *  Look for a row which matches the table restriction (if any).
         */
        ulPosT = (ulCurMin + ulCurMac) / 2;

        lpos = (long)((long)ulPosT * (long)SIZEOF(ABCREC));

        SetFilePointer(lpIVTAbc->hFile, lpos, NULL, FILE_BEGIN);

        /*  Read in the record at that location  */
        if ( !ReadFile(lpIVTAbc->hFile, (LPVOID) &abcrec,
                       SIZEOF(ABCREC), &cbRead, NULL)
           )
        {
            hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_NO_READ);

            goto out;
        }

        /*
         *  I want case insensitive comparisons here...
         */
        nCmpResult = lstrcmpi(szPrefix, abcrec.rgchDisplayName);

        if (nCmpResult > 0)
        {
            ulCurMin = ulPosT + 1;
        }
        else
        {
            ulCurMac = ulPosT;
            if ( !lpIVTAbc->lpszPartialName ||
                 FNameMatch(lpIVTAbc, abcrec.rgchDisplayName)
               )
            {
                fFound = TRUE;
            }
        }
    }

    /*
     *  If I didn't find a row, return MAPI_E_NOT_FOUND.
     */
    if (!fFound)
    {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);

        goto out;
    }

    /*
     *  Otherwise, set the current position to the row found.
     */
    lpIVTAbc->ulPosition = ulCurMac;

out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_FindRow, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  IVTABC_Restrict
 -
 *
 *      Should just support ANR type restrictions...
 */
STDMETHODIMP
IVTABC_Restrict( LPIVTABC lpIVTAbc,
                 LPSRestriction lpRestriction,
                 ULONG ulFlags
                )
{
    LPTSTR szT = NULL;
    LPTSTR lpszTNew = NULL;
    ULONG cbTB = 0;
    BYTE bFilter = 0;
    SCODE scode;
    HRESULT hResult = hrSuccess;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check flags
     */
    if (ulFlags & ~(TBL_NOWAIT|TBL_BATCH))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        goto out;
    }

    /*
     *  I only handle ANR type restrictions
     */

    /*
     *  Check to see if they're resetting the restrictions
     */
    if (!lpRestriction)
    {
        EnterCriticalSection(&lpIVTAbc->cs);

        if (lpIVTAbc->lpszPartialName)
            (*(lpIVTAbc->lpFreeBuff)) (lpIVTAbc->lpszPartialName);
        lpIVTAbc->lpszPartialName = NULL;

        FreeANRBitmaps(lpIVTAbc);

        LeaveCriticalSection(&lpIVTAbc->cs);

        return hrSuccess;
    }

    /*
     *  The restriction must look like:
     *
     *
     *  +--------------
     *  | RES_PROPERTY
     *  +--------------
     *  | RELOP_EQ
     *  +--------------
     *  | PR_ANR
     *  +--------------
     *  | LPSPropVal ---+
     *  +-------------- |
     *                  |   +-------------------------
     *                  +-->| PR_ANR
     *                      +-------------------------
     *                      | 0 <-- for alignment (don't care)
     *                      +-------------------------
     *                      | lpszA <-- string to ANR on
     *                      +-------------------------
     *
     *
     *
     *  If it doesn't look like this, return MAPI_E_TOO_COMPLEX.
     *
     */

    if (lpRestriction->rt != RES_PROPERTY)
    {
        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

        goto out;
    }

    if (lpRestriction->res.resProperty.relop != RELOP_EQ)
    {
        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

        goto out;
    }

    if (lpRestriction->res.resProperty.ulPropTag != PR_ANR)
    {
        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX);

        goto out;
    }

    /*
     *  NULL string is not defined - it's a bad restriction
     */
    if (!lpRestriction->res.resProperty.lpProp->Value.LPSZ)
    {
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }


    szT = lpRestriction->res.resProperty.lpProp->Value.LPSZ;

    /*
     *  Skip over leading spaces
     */

    while (*szT == TEXT(' '))
        szT++;

    /*
     *  Empty string is not defined - it's a bad restriction
     */
    if (*szT == TEXT('\0'))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }


    /*
     *  Copy the string for the partial name
     */

    scode = lpIVTAbc->lpAllocBuff((lstrlen(szT) + 1)*SIZEOF(TCHAR), (LPVOID *) &lpszTNew);
    if (FAILED(scode))
    {
        /*
         *  Memory error
         */

        hResult = ResultFromScode(scode);
        goto out;
    }
    lstrcpy(lpszTNew, szT);


    EnterCriticalSection(&lpIVTAbc->cs);


    /*
     *  Clear up any old restriction
     */

    if (lpIVTAbc->lpszPartialName)
        lpIVTAbc->lpFreeBuff(lpIVTAbc->lpszPartialName);

    lpIVTAbc->lpszPartialName = lpszTNew;

    FreeANRBitmaps(lpIVTAbc);


    /*
     *  Allocate enough bits for the checked&matched arrays
     */
    cbTB = (lpIVTAbc->ulMaxPos) / 8 + 1;    /* Number of bytes in both arrays */

    lpIVTAbc->rgChecked = lpIVTAbc->lpMalloc->lpVtbl->Alloc(
        lpIVTAbc->lpMalloc,
        cbTB);

    if (lpIVTAbc->rgChecked == NULL)
    {
        lpIVTAbc->lpFreeBuff(lpIVTAbc->lpszPartialName);
        lpIVTAbc->lpszPartialName = NULL;

        hResult = ResultFromScode(scode);

        LeaveCriticalSection(&lpIVTAbc->cs);
        goto out;
    }

    lpIVTAbc->rgMatched = lpIVTAbc->lpMalloc->lpVtbl->Alloc(
        lpIVTAbc->lpMalloc,
        cbTB);

    if (lpIVTAbc->rgMatched == NULL)
    {
        (*(lpIVTAbc->lpFreeBuff)) (lpIVTAbc->lpszPartialName);
        lpIVTAbc->lpszPartialName = NULL;

        lpIVTAbc->lpMalloc->lpVtbl->Free(lpIVTAbc->lpMalloc, lpIVTAbc->rgChecked);
        lpIVTAbc->rgChecked = NULL;

        hResult = ResultFromScode(scode);

        LeaveCriticalSection(&lpIVTAbc->cs);
        goto out;
    }

    /*
     *  Initialize the checked array with 0's
     */

    FillMemory(lpIVTAbc->rgChecked, (UINT) cbTB, 0x00);

    /*
     *  Initialize the matched array with 1's
     *  [we assume that if you haven't checked it, it matches]
     */

    FillMemory(lpIVTAbc->rgMatched, (UINT) cbTB, 0xFF);

    /*
     *  Fill in the end bits so we don't have to worry about them
     *  later
     */
    bFilter = (0xFF >> (lpIVTAbc->ulMaxPos % 8));

    /*  Checked end bits should be 1 */
    lpIVTAbc->rgChecked[cbTB - 1] = bFilter;

    /*  Matched end bits should be 0 */
    lpIVTAbc->rgMatched[cbTB - 1] = ~bFilter;

    /*
     *  Set the currenly known total number of rows
     *  that match the restriction.
     */

    lpIVTAbc->ulRstrDenom = lpIVTAbc->ulMaxPos;

    LeaveCriticalSection(&lpIVTAbc->cs);

out:

    DebugTraceResult(IVTABC_Restrict, hResult);
    return hResult;

}



/*************************************************************************
 *
 -  IVTABC_QueryRows
 -
 *  Attempts to retrieve ulRowCount rows from the .FAB file.  Even in the
 *  restricted case.
 *
 *
 */
STDMETHODIMP
IVTABC_QueryRows( LPIVTABC lpIVTAbc,
                  LONG lRowCount,
                  ULONG ulFlags,
                  LPSRowSet * lppRows
                 )
{
    SCODE scode;
    HRESULT hResult = hrSuccess;
    LPSRowSet lpRowSet = NULL;
    LPSPropValue lpRow = NULL;
    int cbSizeOfRow;
    int cRows, iRow;
    int cCols;
    DWORD cbRead;
    ABCREC abcrec;
    ULONG ulOrigPosition;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryRows, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryRows, hResult);
        return hResult;
    }

    /*
     *  Check the out parameter for writability
     */
    if (IsBadWritePtr(lppRows, SIZEOF(LPSRowSet)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryRows, hResult);
        return hResult;
    }

    /*
     *  Never valid to ask for 0 rows
     */
    if (!lRowCount)
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryRows, hResult);
        return hResult;
    }

    /*  //$ MM2 Hack!  Won't Read backwards for TR2 */
    if (lRowCount < 0)
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryRows, hResult);
        return hResult;
    }

    /*
     *  Check the flags
     */
    if (ulFlags & ~TBL_NOADVANCE)
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(IVTABC_QueryRows, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);

    /*
     *  Open the file
     */
    hResult = HrOpenFile(lpIVTAbc);
    if (HR_FAILED(hResult))
    {
        goto out;
    }

    ulOrigPosition = lpIVTAbc->ulPosition;

    /*
     *  Calculate # of rows that will be read.
     */
    cRows = (int)lpIVTAbc->ulMaxPos - (int)lpIVTAbc->ulPosition;
    cRows = (cRows < (int)lRowCount ? cRows : (int)lRowCount);

    /*
     *  Allocate array for SRowSet
     */

    scode = lpIVTAbc->lpAllocBuff(sizeof(ULONG) + cRows * SIZEOF(SRow),
                                        (LPVOID *) &lpRowSet);
    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);

        goto out;
    }

    /*
     *  Initialize - so we can clean up later if we have to...
     */
    lpRowSet->cRows = cRows;

    for( iRow = 0; iRow < cRows; iRow++ )
    {
        lpRowSet->aRow[iRow].lpProps = NULL;
    }



    /*
     *  Seek to correct position in file
     */
    (void) SetFilePointer( lpIVTAbc->hFile,
                           lpIVTAbc->ulPosition * SIZEOF(ABCREC),
                           NULL,
                           FILE_BEGIN
                          );

    /*
     *  Read each row from the file
     */
    for (iRow = 0; iRow < cRows; iRow++)
    {

        /*  The only properties available are:
         *
         *  PR_DISPLAY_NAME, PR_ENTRYID, PR_ADDRTYPE, PR_EMAIL_ADDRESS,
         *  PR_OBJECT_TYPE, PR_DISPLAY_TYPE
         */

        /*
         *  Handle restricted lists
         */
        if (lpIVTAbc->lpszPartialName)
        {
            ULONG ulPos = lpIVTAbc->ulPosition;

next:
            if (ulPos == lpIVTAbc->ulMaxPos)
            {
                break;
            }

            if (!FChecked(lpIVTAbc, ulPos))
            {
                hResult = HrValidateEntry(lpIVTAbc, ulPos);
                if (HR_FAILED(hResult))
                {
                    goto err;
                }
            }

            if (!FMatched(lpIVTAbc, ulPos))
            {
                ulPos++;
                goto next;
            }

            lpIVTAbc->ulPosition = ulPos;
            (void) SetFilePointer( lpIVTAbc->hFile,
                                   lpIVTAbc->ulPosition * SIZEOF(ABCREC),
                                   NULL,
                                   FILE_BEGIN
                                  );

        }

        lpIVTAbc->ulPosition++;

        /*
         *  Read in the record from the file
         */
        if ( !ReadFile( lpIVTAbc->hFile, (LPVOID) &abcrec,
                        SIZEOF(ABCREC), &cbRead, NULL)
            )
        {
            hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_NO_READ);

            goto err;
        }
        /*  Second check  */
        if ((UINT) cbRead != SIZEOF(ABCREC))
        {
            /*
             *  Should never get here.
             */
            hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_NO_READ);

            goto err;
        }

        /*  Allocate memory to start a row.
         */
        cbSizeOfRow = SIZEOF(ULONG) +
            (int)lpIVTAbc->lpPTAColSet->cValues * SIZEOF(SPropValue);

        scode = lpIVTAbc->lpAllocBuff(cbSizeOfRow, (LPVOID *) &lpRow);
        if (FAILED(scode))
        {
            hResult = ResultFromScode(scode);

            goto err;
        }

        /*
         *  Get all the data
         */
        for (cCols = 0; cCols < (int)lpIVTAbc->lpPTAColSet->cValues; cCols++)
        {
            switch (lpIVTAbc->lpPTAColSet->aulPropTag[cCols])
            {
            case PR_DISPLAY_NAME_A:
            {

                INT cch = lstrlen(abcrec.rgchDisplayName) + 1;

                lpRow[cCols].ulPropTag = PR_DISPLAY_NAME_A;
                scode = lpIVTAbc->lpAllocMore( cch,
                                               lpRow,
                                               (LPVOID *) &(lpRow[cCols].Value.lpszA)
                                              );

                if (FAILED(scode))
                {
                    lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR,
                        PROP_ID(PR_DISPLAY_NAME_A));
                    lpRow[cCols].Value.err = scode;
                }
                else
                {
#ifdef UNICODE
                    lpRow[cCols].Value.lpszA[0] = 0;
                    WideCharToMultiByte( CP_ACP, 0,
                                         abcrec.rgchDisplayName, -1,
                                         lpRow[cCols].Value.lpszA, cch,
                                         NULL, NULL
                                        );
#else
                    lstrcpy(lpRow[cCols].Value.LPSZ, abcrec.rgchDisplayName);
#endif
                }

            }
            break;

            case PR_EMAIL_ADDRESS_A:
            {

                INT cch = lstrlen(abcrec.rgchEmailAddress) + 1;

                lpRow[cCols].ulPropTag = PR_EMAIL_ADDRESS_A;
                scode = lpIVTAbc->lpAllocMore( cch,
                                               lpRow,
                                               (LPVOID *) &(lpRow[cCols].Value.lpszA)
                                              );

                if (FAILED(scode))
                {
                    lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR,
                        PROP_ID(PR_EMAIL_ADDRESS_A));
                    lpRow[cCols].Value.err = scode;
                }
                else
                {
#ifdef UNICODE
                    lpRow[cCols].Value.lpszA[0] = 0;
                    WideCharToMultiByte( CP_ACP, 0,
                                         abcrec.rgchEmailAddress, -1,
                                         lpRow[cCols].Value.lpszA, cch,
                                         NULL, NULL
                                        );
#else
                    lstrcpy(lpRow[cCols].Value.LPSZ, abcrec.rgchEmailAddress);
#endif
                }

            }
            break;


            case PR_ADDRTYPE_A:
            {
                /*
                 *  AddrType is always "MSPEER" for the FAB
                 */

                INT cch = lstrlen(lpszEMT) + 1;

                lpRow[cCols].ulPropTag = PR_ADDRTYPE_A;
                scode = lpIVTAbc->lpAllocMore( cch,
                                               lpRow,
                                               (LPVOID *) &(lpRow[cCols].Value.lpszA)
                                              );

                if (FAILED(scode))
                {
                    lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR,
                        PROP_ID(PR_ADDRTYPE_A));
                    lpRow[cCols].Value.err = scode;
                }
                else
                {
#ifdef UNICODE
                    lpRow[cCols].Value.lpszA[0] = 0;
                    WideCharToMultiByte( CP_ACP, 0,
                                         lpszEMT, -1,
                                         lpRow[cCols].Value.lpszA, cch,
                                         NULL, NULL
                                        );
#else
                    lstrcpy(lpRow[cCols].Value.LPSZ, lpszEMT);
#endif
                }

            }
            break;

            case PR_ENTRYID:
            {
                /*
                 *  Fixed sized entryid.  Basically just the .FAB file record
                 */
                LPUSR_ENTRYID lpUsrEid;

                lpRow[cCols].ulPropTag = PR_ENTRYID;
                scode = lpIVTAbc->lpAllocMore (SIZEOF(USR_ENTRYID), lpRow,
                            (LPVOID *) &(lpRow[cCols].Value.bin.lpb));

                if (FAILED(scode))
                {
                    lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR,
                        PROP_ID(PR_ENTRYID));
                    lpRow[cCols].Value.err = scode;
                }
                else
                {
                    lpUsrEid = (LPUSR_ENTRYID) lpRow[cCols].Value.bin.lpb;

                    RtlZeroMemory(lpUsrEid, SIZEOF(USR_ENTRYID));

                    /*  Size of entryid */
                    lpRow[cCols].Value.bin.cb = SIZEOF(USR_ENTRYID);

                    lpUsrEid->abFlags[0] = 0;   /*  long-term, recipient */
                    lpUsrEid->abFlags[1] = 0;
                    lpUsrEid->abFlags[2] = 0;
                    lpUsrEid->abFlags[3] = 0;
                    lpUsrEid->muid = muidABMAWF;
                    lpUsrEid->ulVersion = MAWF_VERSION;
                    lpUsrEid->ulType = MAWF_USER;
                    lpUsrEid->abcrec = abcrec;
                }

            }
            break;

            case PR_OBJECT_TYPE:
            {
                /*
                 *  MailUser
                 */

                lpRow[cCols].ulPropTag = PR_OBJECT_TYPE;
                lpRow[cCols].Value.ul = MAPI_MAILUSER;
            }
            break;

            case PR_DISPLAY_TYPE:
            {
                /*
                 *  MailUser
                 */

                lpRow[cCols].ulPropTag = PR_DISPLAY_TYPE;
                lpRow[cCols].Value.ul = DT_MAILUSER;

            }
            break;

            case PR_INSTANCE_KEY:
            {
                LPABCRecInstance lpABCRecInstance;
                UINT cbRecInstance;
                /*
                 *  Instance keys are made up of:
                 *              ulRecordPosition - current position in the file
                 *              filetime                 - current date and time stamp of file
                 *              lpszFileName     - current file that we're browsing
                 */
                lpRow[cCols].ulPropTag = PR_INSTANCE_KEY;

                cbRecInstance = SIZEOF(ABCRecInstance)+(lstrlen(lpIVTAbc->lpszFileName)+1)*SIZEOF(TCHAR);
                scode = lpIVTAbc->lpAllocMore(cbRecInstance,
                                lpRow,
                                (LPVOID) &(lpRow[cCols].Value.bin.lpb));

                if (FAILED(scode))
                {
                    lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_INSTANCE_KEY));
                    lpRow[cCols].Value.err = scode;
                }
                else
                {
                    lpABCRecInstance = (LPABCRecInstance) lpRow[cCols].Value.bin.lpb;

                    ZeroMemory(lpABCRecInstance, cbRecInstance);

                    lpRow[cCols].Value.bin.cb = (ULONG) cbRecInstance;

                    lpABCRecInstance->ulRecordPosition = lpIVTAbc->ulPosition;
                    lpABCRecInstance->filetime = lpIVTAbc->filetime;
                    lstrcpy(lpABCRecInstance->rgchzFileName, lpIVTAbc->lpszFileName);

                }
            }
            break;

            default:
            {
                lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR,
                    PROP_ID(lpIVTAbc->lpPTAColSet->aulPropTag[cCols]));
                lpRow[cCols].Value.err = MAPI_E_NOT_FOUND;
            }
            break;
            }
        }

        /*  # of columns  */
        lpRowSet->aRow[iRow].cValues = lpIVTAbc->lpPTAColSet->cValues;

        /*  Actual row of data */
        lpRowSet->aRow[iRow].lpProps = lpRow;

        lpRow = NULL;

    }

    /*
     *  it's always iRow.
     */
    lpRowSet->cRows = iRow;

    /*
     *  Handle Seeked position stuff
     */
    if (ulFlags & TBL_NOADVANCE)
    {
        /*
         *  Set it back to it's original position
         */
        lpIVTAbc->ulPosition = ulOrigPosition;
    }


    *lppRows = lpRowSet;

out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_QueryRows, hResult);
    return hResult;

err:
    /*
     *  Clean up memory...
     */

    /*  Free the row  */
    lpIVTAbc->lpFreeBuff(lpRow);

    /*  Clean up the rest of the rows  */
    FreeProws(lpRowSet);

    *lppRows = NULL;

    goto out;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abctbl3.c ===
/***********************************************************************
 *
 *  ABCTBL3.C
 *
 *  Contents Table - Part 3.
 *
 *
 *  The following routines are implemented in this file.
 *
 *
 *      IVTABC_QueryInterface
 *      IVTABC_Release
 *      IVTABC_SortTable
 *      IVTABC_QuerySortOrder
 *      IVTABC_CreateBookmark
 *      IVTABC_FreeBookmark
 *      IVTABC_ExpandRow
 *      IVTABC_ColapseRow
 *      IVTABC_WaitForCompletion
 *      IVTABC_Abort
 *      IVTABC_Advise
 *      IVTABC_Unadvise
 *      IVTABC_GetStatus
 *      IVTABC_SetColumns
 *      IVTABC_QueryColumns
 *      IVTABC_GetCollapseState,
 *      IVTABC_SetCollapseState,
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/





#include "faxab.h"

/*
 *  Default sort order set
 */
static const SizedSSortOrderSet(1, sosIVTABC) =
{
    1,
    0,
    0,
    {
        {
            PR_DISPLAY_NAME, TABLE_SORT_ASCEND
        }
    }
};




/*************************************************************************
 *
 *
 -  AVTABC_QueryInterface
 -
 *
 *
 *
 */
STDMETHODIMP
IVTABC_QueryInterface( LPIVTABC lpIVTAbc,
                       REFIID lpiid,
                       LPVOID FAR * lppNewObj
                      )
{

    HRESULT hResult = hrSuccess;

    /*  Minimally validate the lpIVTAbc parameter */

    /*
     *  Check to see if it's big enough to be this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not big enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*  Check other parameters */

    if ( IsBadReadPtr(  lpiid,     (UINT) SIZEOF(IID)) ||
         IsBadWritePtr( lppNewObj, (UINT) SIZEOF(LPVOID))
        )
    {
        DebugTraceSc(IVTABC_QueryInterface, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /*  See if the requested interface is one of ours */

    if (memcmp(lpiid, &IID_IUnknown,   SIZEOF(IID)) &&
        memcmp(lpiid, &IID_IMAPITable, SIZEOF(IID)))
    {
        *lppNewObj = NULL;      /* OLE requires zeroing the [out] parameter */
        DebugTraceSc(IVTABC_QueryInterface, E_NOINTERFACE);
        return ResultFromScode(E_NOINTERFACE);
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpIVTAbc->cs);
    ++lpIVTAbc->lcInit;
    LeaveCriticalSection(&lpIVTAbc->cs);

    *lppNewObj = lpIVTAbc;

out:
    DebugTraceResult(IVTABC_QueryInterface,hResult);
    return hResult;
}

/*************************************************************************
 *
 -  IVTABC_Release
 -
 *
 *      Decrement the reference count on this object and free it if
 *      the reference count is zero.
 *      Returns the reference count.
 */

STDMETHODIMP_(ULONG)
IVTABC_Release(LPIVTABC lpIVTAbc)
{
    ULONG ulBK;
    long lcInit;

    /*
     *  Check to see if it's big enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        return 1;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        return 1;
    }

    EnterCriticalSection(&lpIVTAbc->cs);
    lcInit = --lpIVTAbc->lcInit;
    LeaveCriticalSection(&lpIVTAbc->cs);

    if (lcInit == 0)
    {
        /*
         *  Free up the current column set
         */
        if (lpIVTAbc->lpPTAColSet != ptagaivtabcColSet)
        {
            lpIVTAbc->lpFreeBuff (lpIVTAbc->lpPTAColSet);
        }

        /*
         *  Close up the file
         */
        if (lpIVTAbc->hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(lpIVTAbc->hFile);
            lpIVTAbc->hFile = INVALID_HANDLE_VALUE;
        }

        /*
         *  Free up the file name
         */
        lpIVTAbc->lpFreeBuff(lpIVTAbc->lpszFileName);

        /*
         *  Rip through the bookmarks and free up any that are there
         */
        for (ulBK = 0; ulBK < MAX_BOOKMARKS; ulBK++)
            if (lpIVTAbc->rglpABCBK[ulBK])
            {
                (*(lpIVTAbc->lpFreeBuff)) (lpIVTAbc->rglpABCBK[ulBK]);
                lpIVTAbc->rglpABCBK[ulBK] = NULL;
            }

        /*
         *  Free up the ANR stuff, if used
         */
        lpIVTAbc->lpFreeBuff (lpIVTAbc->lpszPartialName);

        FreeANRBitmaps(lpIVTAbc);

        /*
         *  Free up the advise list, if used
         */
        if (lpIVTAbc->parglpAdvise)
            lpIVTAbc->lpMalloc->lpVtbl->Free(lpIVTAbc->lpMalloc, lpIVTAbc->parglpAdvise);

        /* Delete critical section for this object */
        DeleteCriticalSection(&lpIVTAbc->cs);

        /* Deregister the idle routine */

        DeregisterIdleRoutine(lpIVTAbc->ftg);

        /*
         *  Set the vtbl to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */
        lpIVTAbc->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpIVTAbc->lpFreeBuff(lpIVTAbc);
        return 0;
    }

    return lcInit;
}



/*
 -  IVTABC_SortTable
 -
 *  The Microsoft At Work Fax Address Book does not resort it's views.
 *
 */
STDMETHODIMP
IVTABC_SortTable( LPIVTABC lpIVTAbc,
                  LPSSortOrderSet lpSortCriteria,
                  ULONG ulFlags
                 )
{
    HRESULT hResult;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's big enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check for bad sort order set.  This is from the mapi utilities DLL.
     */
    if (FBadSortOrderSet(lpSortCriteria))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    /*
     *  Check flags
     */
    if (ulFlags & ~(TBL_ASYNC|TBL_BATCH))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }


    /*
     *  We don't support sorting this table
     */
    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:
    DebugTraceResult(IVTABC_SortTable, hResult);
    return hResult;

}

/*
 -  IVTABC_QuerySortOrder
 -
 *
 *  For this implementation there is only one sort order
 */

STDMETHODIMP
IVTABC_QuerySortOrder( LPIVTABC lpIVTAbc,
                       LPSSortOrderSet * lppSortCriteria
                      )
{
    SCODE scode;
    HRESULT hResult = hrSuccess;
    int cbSize;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check the out parameter for writability
     */
    if (IsBadWritePtr(lppSortCriteria, sizeof(LPSSortOrderSet)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        goto out;
    }

    /*  Calculate size of the structure we're gonna copy */
    cbSize = CbNewSSortOrderSet((int)sosIVTABC.cSorts);

    scode = lpIVTAbc->lpAllocBuff(cbSize, (LPVOID *) lppSortCriteria);
    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);

        goto out;
    }

    /*
     *  Copy the column set in
     */
    if (cbSize)
        memcpy(*lppSortCriteria, &sosIVTABC, cbSize);

out:

    DebugTraceResult(IVTABC_QuerySortOrder, hResult);
    return hResult;

}




/*
 -  IVTABC_CreateBookmark
 -
 *  Creates a bookmark associated with a row in a table
 *
 */
STDMETHODIMP
IVTABC_CreateBookmark( LPIVTABC lpIVTAbc,
                       BOOKMARK * lpbkPosition
                      )
{
    SCODE scode;
    HRESULT hResult = hrSuccess;
    ULONG ulBK;
    LPABCBK lpABCBK = NULL;
    ULONG cbRead = 0;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_CreateBookmark, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_CreateBookmark, hResult);
        return hResult;
    }

    /*
     *  Check the out parameter for writability
     */
    if (IsBadWritePtr(lpbkPosition, SIZEOF(BOOKMARK)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_CreateBookmark, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);


    /*
     *  Open the file
     */
    hResult = HrOpenFile(lpIVTAbc);
    if (HR_FAILED(hResult))
    {
        goto out;
    }

    /*
     *  Shortcuts first
     */
    if (lpIVTAbc->ulPosition == lpIVTAbc->ulMaxPos)
    {
        *lpbkPosition = BOOKMARK_END;
        return hrSuccess;
    }

    /*
     *  search for a blank bookmark
     */
    for (ulBK = 0; lpIVTAbc->rglpABCBK[ulBK] && ulBK < MAX_BOOKMARKS; ulBK++);

    /*  did we find any??  */
    if (ulBK == MAX_BOOKMARKS)
    {
        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);

        goto out;
    }


    scode = lpIVTAbc->lpAllocBuff (SIZEOF(ABCBK),(LPVOID *) &lpABCBK);
    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);
        goto out;
    }

    /*
     *  Fill in new bookmark
     */
    lpABCBK->filetime = lpIVTAbc->filetime;
    lpABCBK->ulPosition = lpIVTAbc->ulPosition;

    /*  Seek to position in file  */
    (void) SetFilePointer(lpIVTAbc->hFile, lpABCBK->ulPosition, NULL, FILE_BEGIN);

    /*  Read in the record at that location  */
    if (!ReadFile(lpIVTAbc->hFile,
            (LPVOID) &(lpABCBK->abcrec), SIZEOF(ABCREC), &cbRead, NULL))
    {
        goto readerror;
    }
    /*  Second check  */
    if (cbRead != sizeof(ABCREC))
    {
        goto readerror;
    }

    /*
     *  Put this in the bookmark structure
     */
    lpIVTAbc->rglpABCBK[ulBK] = lpABCBK;

    /*  Return the bookmark  */
    *lpbkPosition = ulBK + 3;

out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_CreateBookmark, hResult);
    return hResult;

readerror:
    /*
     *  Didn't get the record.
     */

    /*  Restore back to original position  */
    (void) SetFilePointer(lpIVTAbc->hFile, lpIVTAbc->ulPosition, NULL, FILE_BEGIN);

    /*  Free up the new bookmark  */
    lpIVTAbc->lpFreeBuff(lpABCBK);

    hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE);
    SetErrorIDS(lpIVTAbc, hResult, IDS_FAB_NO_READ);

    goto out;
}

/*************************************************************************
 *
 -  IVTABC_FreeBookmark
 -
 *  Frees up the given bookmark
 *
 *
 *
 */
STDMETHODIMP
IVTABC_FreeBookmark( LPIVTABC lpIVTAbc,
                     BOOKMARK bkPosition
                    )
{
    HRESULT hResult = hrSuccess;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_FreeBookmark, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_FreeBookmark, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);


    /*
     *  Don't try and free up any of the standard bookmarks
     */
    if ((bkPosition != BOOKMARK_BEGINNING) &&
        (bkPosition != BOOKMARK_CURRENT) &&
        (bkPosition != BOOKMARK_END))
    {
        ULONG ulBK = (ULONG) bkPosition - 3;

        /*
         *  See if it's in range
         */
        if (ulBK >= 0 && ulBK < MAX_BOOKMARKS)
        {
            LPABCBK lpABCBK = NULL;

            /*  If it's valid...  */
            if (lpABCBK = lpIVTAbc->rglpABCBK[ulBK])    /* '=' on purpose */
            {
                /*  ...free it up.  */

                lpIVTAbc->lpFreeBuff(lpABCBK);
                lpIVTAbc->rglpABCBK[ulBK] = NULL;
            }

        }
        else
        {
            /*
             * It's an error
             */
            hResult = ResultFromScode(E_INVALIDARG);

        }
    }

    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_FreeBookmark, hResult);
    return hResult;

}


/*************************************************************************
 *
 -  IVTABC_ExpandRow
 -
 *  Stubbed out.  This table doesn't implement catagorization.
 *
 *
 *
 */
STDMETHODIMP
IVTABC_ExpandRow( LPIVTABC lpIVTAbc,
                  ULONG cbIKey,
                  LPBYTE pbIKey,
                  ULONG ulRowCount,
                  ULONG ulFlags,
                  LPSRowSet FAR * lppRows,
                  ULONG FAR * lpulMoreRows
                 )

{
    HRESULT hResult;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_ExpandRow, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_ExpandRow, hResult);
        return hResult;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

    DebugTraceResult(IVTABC_ExpandRow, hResult);
    return hResult;

}

/*************************************************************************
 *
 -  IVTABC_CollapseRow
 -
 *  Stubbed out.  This table doesn't implement catagorization.
 *
 *
 *
 */
STDMETHODIMP
IVTABC_CollapseRow( LPIVTABC lpIVTAbc,
                    ULONG cbIKey,
                    LPBYTE pbIKey,
                    ULONG ulFlags,
                    ULONG FAR * lpulRowCount
                   )

{
    HRESULT hResult;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_CollapseRow, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_CollapseRow, hResult);
        return hResult;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

    DebugTraceResult(IVTABC_CollapseRow, hResult);
    return hResult;

}

/*************************************************************************
 *
 -  IVTABC_WaitForCompletion
 -
 *  Stubbed out.
 *
 *
 *
 */
STDMETHODIMP
IVTABC_WaitForCompletion( LPIVTABC lpIVTAbc,
                          ULONG ulFlags,
                          ULONG ulTimeout,
                          ULONG FAR * lpulTableStatus
                         )
{
    HRESULT hResult;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_WaitForCompletion, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_WaitForCompletion, hResult);
        return hResult;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

    DebugTraceResult(IVTABC_WaitForCompletion, hResult);
    return hResult;

}
/*************************************************************************
 *
 -  IVTABC_Abort
 -
 *  Nothing ever to abort...
 *
 *
 *
 */
STDMETHODIMP
IVTABC_Abort(LPIVTABC lpIVTAbc)

{
    HRESULT hResult;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_Abort, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_Abort, hResult);
        return hResult;
    }

    return hrSuccess;

}

/*************************************************************************
 *
 *
 -  IVTABC_Advise
 -
 *
 *
 *
 */
STDMETHODIMP
IVTABC_Advise( LPIVTABC lpIVTAbc,
               ULONG ulEventmask,
               LPMAPIADVISESINK lpAdviseSink,
               ULONG FAR * lpulConnection
              )
{
    HRESULT hResult = hrSuccess;
    UINT iAdvise;

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        DebugTraceSc(IVTABC_Advise, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_Advise, hResult);
        return hResult;
    }

    /*
     *  Validate the parameters
     */

    if ((ulEventmask & ~(ULONG) fnevTableModified) ||
        IsBadReadPtr(lpAdviseSink, SIZEOF(LPVOID)) ||
        IsBadReadPtr(lpAdviseSink->lpVtbl, 3 * SIZEOF(LPVOID)) ||
        IsBadWritePtr(lpulConnection, SIZEOF(ULONG)))
    {
        DebugTraceSc(IVTABC_Advise, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /* Get the Critical Section */
    EnterCriticalSection(&lpIVTAbc->cs);

    for (iAdvise = 0;
        lpIVTAbc->parglpAdvise && iAdvise < lpIVTAbc->cAdvise;
        ++iAdvise)
    {
        if (lpIVTAbc->parglpAdvise[iAdvise] == NULL)
            break;
    }

    if (iAdvise >= lpIVTAbc->cAdvise)
    {
        /*
         *   Realloc the array if it exists
         */
        if (lpIVTAbc->parglpAdvise)
        {
            lpIVTAbc->parglpAdvise = lpIVTAbc->lpMalloc->lpVtbl->Realloc(
                lpIVTAbc->lpMalloc,
                lpIVTAbc->parglpAdvise,
                (lpIVTAbc->cAdvise + 1) * SIZEOF(LPMAPIADVISESINK));
        }
        else
        {
            lpIVTAbc->parglpAdvise = lpIVTAbc->lpMalloc->lpVtbl->Alloc(
                lpIVTAbc->lpMalloc,
                (lpIVTAbc->cAdvise + 1) * SIZEOF(LPMAPIADVISESINK));
        }

        /*
         *  Could we get the desired memory?
         */
        if (lpIVTAbc->parglpAdvise == NULL)
        {
            hResult = MakeResult(E_OUTOFMEMORY);
            goto ret;
        }
    }

    lpIVTAbc->cAdvise++;

    *lpulConnection = lpIVTAbc->ulConnectMic + iAdvise;

    lpIVTAbc->parglpAdvise[iAdvise] = lpAdviseSink;

    lpAdviseSink->lpVtbl->AddRef(lpAdviseSink);

ret:
    /* leave critical section */
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_Advise, hResult);
    return hResult;
}

/*************************************************************************
 *
 *
 -  IVTABC_Unadvise
 -
 *
 *
 *
 */
STDMETHODIMP
IVTABC_Unadvise(LPIVTABC lpIVTAbc, ULONG ulConnection)
{
    LPMAPIADVISESINK padvise;
    UINT iAdvise;
    HRESULT hResult = hrSuccess;

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        DebugTraceSc(IVTABC_Unadvise, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_Unadvise, hResult);
        return hResult;
    }

    if (ulConnection - lpIVTAbc->ulConnectMic > (ULONG) lpIVTAbc->cAdvise)
    {
        DebugTraceSc(IVTABC_Unadvise, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /* Get the Critical Section */
    EnterCriticalSection(&lpIVTAbc->cs);

    iAdvise = (UINT) (ulConnection - lpIVTAbc->ulConnectMic);
    padvise = lpIVTAbc->parglpAdvise[iAdvise];
    padvise->lpVtbl->Release(padvise);
    lpIVTAbc->parglpAdvise[iAdvise] = NULL;
    lpIVTAbc->cAdvise--;

    /* leave critical section */
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_Unadvise, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  IVTABC_GetStatus
 -
 *  Returns the status of this table.  This table really isn't
 *  dynamic yet, but it could be...
 *
 *
 */
STDMETHODIMP
IVTABC_GetStatus( LPIVTABC lpIVTAbc,
                  ULONG * lpulTableStatus,
                  ULONG * lpulTableType
                 )
{
    HRESULT hResult;

    /*
     *  Parameter checking
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    /*
     *  Check the out parameters for writability
     */
    if (IsBadWritePtr(lpulTableStatus,  SIZEOF(ULONG))
        || IsBadWritePtr(lpulTableType, SIZEOF(ULONG)))
    {
        /*
         *  Bad out parameters
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    *lpulTableStatus = TBLSTAT_COMPLETE;
    *lpulTableType = TBLTYPE_DYNAMIC;

    return hrSuccess;
}

/*************************************************************************
 *
 -  IVTABC_SetColumns
 -
 *
 *  SetColumns for contents table.
 *
 */
STDMETHODIMP
IVTABC_SetColumns( LPIVTABC lpIVTAbc,
                   LPSPropTagArray lpPTAColSet,
                   ULONG ulFlags
                  )
{
    SCODE scode;
    HRESULT hResult = hrSuccess;
    int cbSizeOfColSet;
    LPSPropTagArray lpPTAColSetT;
    ULONG uliCol;

    /*
     *  Check parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_SetColumns, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    /*
     *  Check flags
     */
    if (ulFlags & ~TBL_NOWAIT)
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    /*
     *  The first element of the structure
     */
    if (IsBadReadPtr(lpPTAColSet, offsetof(SPropTagArray, aulPropTag)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    cbSizeOfColSet = CbSPropTagArray(lpPTAColSet);

    /*
     *  The rest of the structure
     */
    if (IsBadReadPtr(lpPTAColSet, cbSizeOfColSet))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    /*
     *  Verify that there are no PT_ERRORs here...
     */
    for (uliCol = 0; uliCol < lpPTAColSet->cValues; uliCol++)
    {
        if (PROP_TYPE(lpPTAColSet->aulPropTag[uliCol]) == PT_ERROR)
        {
            hResult = ResultFromScode(E_INVALIDARG);

            DebugTraceResult(IVTABC_GetStatus, hResult);
            return hResult;
        }
    }

    /*
     *  Allocate a new column set.
     */

    scode = lpIVTAbc->lpAllocBuff(cbSizeOfColSet,(LPVOID *) &lpPTAColSetT);

    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);

        DebugTraceResult(IVTABC_GetStatus, hResult);
        return hResult;
    }

    /*
     *  Copy the column set in
     */
    if (cbSizeOfColSet)
        memcpy(lpPTAColSetT, lpPTAColSet, cbSizeOfColSet);


    EnterCriticalSection(&lpIVTAbc->cs);


    if (lpIVTAbc->lpPTAColSet != ptagaivtabcColSet)
    {
        /*
         *  Free up the old column set
         */
        lpIVTAbc->lpFreeBuff(lpIVTAbc->lpPTAColSet);
    }

    lpIVTAbc->lpPTAColSet = lpPTAColSetT;


    LeaveCriticalSection(&lpIVTAbc->cs);


    return hrSuccess;

}

/*************************************************************************
 *
 -  IVTABC_QueryColumns
 -
 *
 *
 *  I always have all my columns available...  and active.
 */
STDMETHODIMP
IVTABC_QueryColumns( LPIVTABC lpIVTAbc,
                     ULONG ulFlags,
                     LPSPropTagArray FAR * lppColumns
                    )
{
    SCODE scode;
    HRESULT hResult = hrSuccess;
    int cbSizeOfColSet;

    /*
     *  Check parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryColumns, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryColumns, hResult);
        return hResult;
    }

    /*
     *  Check the out parameters for writability
     */
    if (IsBadWritePtr(lppColumns, SIZEOF(LPSPropTagArray)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(IVTABC_QueryColumns, hResult);
        return hResult;
    }

    /*
     *  Check flags
     */
    if (ulFlags & ~TBL_ALL_COLUMNS)
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(IVTABC_QueryColumns, hResult);
        return hResult;
    }


    EnterCriticalSection(&lpIVTAbc->cs);

    /*
     *  Allocate enough memory for the column set
     */
    if (ulFlags & TBL_ALL_COLUMNS)

        cbSizeOfColSet = sizeof(ULONG) +
            (int)(ptagaivtabcColSet->cValues) * SIZEOF(ULONG);
    else
        cbSizeOfColSet = sizeof(ULONG) +
            (int)lpIVTAbc->lpPTAColSet->cValues * SIZEOF(ULONG);


    scode = lpIVTAbc->lpAllocBuff (cbSizeOfColSet,(LPVOID *) lppColumns);

    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);
        goto out;
    }

    /*
     *  Copy the column set in
     */
    if (ulFlags & TBL_ALL_COLUMNS)
        memcpy(*lppColumns, ptagaivtabcColSet, cbSizeOfColSet);
    else
        memcpy(*lppColumns, lpIVTAbc->lpPTAColSet, cbSizeOfColSet);


out:
    LeaveCriticalSection(&lpIVTAbc->cs);

    DebugTraceResult(IVTABC_QueryColumns, hResult);
    return hResult;

}

/*************************************************************************
 *
 -  IVTABC_GetCollapseState
 -
 *  Stubbed out.  Only necessary if this table were to support categorization.
 *
 *
 *
 */
STDMETHODIMP
IVTABC_GetCollapseState( LPIVTABC lpIVTAbc,
                         ULONG ulFlags,
                         ULONG cbInstanceKey,
                         LPBYTE pbInstanceKey,
                         ULONG FAR * lpcbCollapseState,
                         LPBYTE FAR * lppbCollapseState
                        )
{
    SCODE sc = MAPI_E_NO_SUPPORT;
    HRESULT hResult;

    /*
     *  Check parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        sc = E_INVALIDARG;
        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        sc = E_INVALIDARG;
        goto out;
    }

    if ( IsBadReadPtr(pbInstanceKey, (UINT) cbInstanceKey))
    {
        sc = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if ( IsBadWritePtr(lpcbCollapseState, SIZEOF(ULONG)))
    {
        sc = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if ( IsBadWritePtr(lppbCollapseState, SIZEOF(LPBYTE)))
    {
        sc = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if ( ulFlags )
    {
        sc = MAPI_E_UNKNOWN_FLAGS;
    }

out:

    hResult = ResultFromScode(sc);
    DebugTraceResult(IVTABC_GetCollapseState, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  IVTABC_SetCollapseState
 -
 *  Stubbed out.  Only necessary if this table were to support categorization.
 *
 *
 *
 */
STDMETHODIMP
IVTABC_SetCollapseState( LPIVTABC lpIVTAbc,
                         ULONG ulFlags,
                         ULONG cbCollapseState,
                         LPBYTE pbCollapseState,
                         BOOKMARK FAR * lpbkLocation
                        )
{

    SCODE sc = MAPI_E_NO_SUPPORT;
    HRESULT hResult;

    /*
     *  Check parameters
     */

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpIVTAbc, SIZEOF(IVTABC)))
    {
        /*
         *  Not large enough
         */
        sc = E_INVALIDARG;
        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpIVTAbc->lpVtbl != &vtblIVTABC)
    {
        /*
         *  Not my vtbl
         */
        sc = E_INVALIDARG;
        goto out;
    }

    if ( IsBadReadPtr(pbCollapseState, (UINT) cbCollapseState))
    {
        sc = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if (IsBadWritePtr(lpbkLocation, SIZEOF(BOOKMARK)))
    {
        sc = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if ( ulFlags )
    {
        sc = MAPI_E_UNKNOWN_FLAGS;
    }

out:

    hResult = ResultFromScode(sc);
    DebugTraceResult(IVTABC_SetCollapseState, hResult);
    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\ablogon.c ===
/***********************************************************************
 *
 *  ABLOGON.C
 *
 *
 *  The Microsoft At Work Fax Address Book Provider.
 *
 *  This file has the code to implement the Microsoft At Work Fax Address Book's logon
 *  object.
 *
 *  The following routines are implemented in this file:
 *
 *  ABPLOGON_QueryInterface
 *  ABPLOGON_Release
 *  ABPLOGON_Logoff
 *  ABPLOGON_OpenEntry
 *  ABPLOGON_CompareEntryIDs
 *  ABPLOGON_Advise
 *  ABPLOGON_Unadvise
 *  ABPLOGON_OpenStatusEntry
 *  ABPLOGON_OpenTemplateID
 *  ABPLOGON_GetOneOffTable
 *  ABPLOGON_PrepareRecips
 *
 *  LpMuidFromLogon
 *  HrLpszGetCurrentFileName
 *  HrReplaceCurrentfileName
 *  GenerateContainerDN
 *  HrBuildRootHier
 *
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *  Revision History:
 *
 *      When        Who                                 What
 *      --------    ------------------  ---------------------------------------
 *      8.3.94      MAPI                                Original source from MAPI sample ABP build 304
 *      8.3.94      Yoram Yaacovi               Moved code from the FAX ABP original abp.c to here
 *      11.11.94        Yoram Yaacovi           Upgrade to MAPI 318 (PR_INSTANCE_KEY)
 *
 ***********************************************************************/


#include "faxab.h"

ABPLOGON_Vtbl vtblABPLOGON =
{
    ABPLOGON_QueryInterface,
    (ABPLOGON_AddRef_METHOD *) ROOT_AddRef,
    ABPLOGON_Release,
    (ABPLOGON_GetLastError_METHOD *) ROOT_GetLastError,
    ABPLOGON_Logoff,
    ABPLOGON_OpenEntry,
    ABPLOGON_CompareEntryIDs,
    ABPLOGON_Advise,
    ABPLOGON_Unadvise,
    ABPLOGON_OpenStatusEntry,
    ABPLOGON_OpenTemplateID,
    ABPLOGON_GetOneOffTable,
    ABPLOGON_PrepareRecips
};



/*
 -  HrNewABLogon
 -
 *
 *  Creates a new Microsoft At Work Fax AB Logon object.
 */

HRESULT
HrNewABLogon( LPABLOGON *         lppABLogon,
              LPABPROVIDER        lpABP,
              LPMAPISUP           lpMAPISup,
              LPTSTR              lpszFABFile,
              LPMAPIUID           lpmuid,
              HINSTANCE           hLibrary,
              LPALLOCATEBUFFER    lpAllocBuff,
              LPALLOCATEMORE      lpAllocMore,
              LPFREEBUFFER        lpFreeBuff,
              LPMALLOC            lpMalloc
             )
{

    SCODE sc;
    HRESULT hResult = hrSuccess;
    SPropValue rgSPVStat[6];
    LPABPLOGON lpABPLogon = NULL;
#ifdef UNICODE
    CHAR szFileName[ MAX_PATH ];
#endif

    /*
     *  Allocate space for the lpABPLogon object
     */

    sc = lpAllocBuff(SIZEOF(ABPLOGON), &lpABPLogon);
    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto out;
    }

    /*
     *  Initialize the ABPLogon object
     */

    lpABPLogon->lpVtbl = &vtblABPLOGON;

    lpABPLogon->lcInit = 1;
    lpABPLogon->hResult = hrSuccess;
    lpABPLogon->idsLastError = 0;

    lpABPLogon->hLibrary = hLibrary;

    lpABPLogon->lpMalloc = lpMalloc;
    lpABPLogon->lpAllocBuff = lpAllocBuff;
    lpABPLogon->lpAllocMore = lpAllocMore;
    lpABPLogon->lpFreeBuff = lpFreeBuff;

    lpABPLogon->lpMapiSup = lpMAPISup;
    lpABPLogon->lpABP = (LPABPROVIDER) lpABP;
    lpABPLogon->lpszFileName = lpszFABFile;
    lpABPLogon->muidID = *lpmuid;

    lpABPLogon->lpTDatRoot = NULL;
    lpABPLogon->lpTDatOO = NULL;

    /*
     *  Register my status row...
     */

    // MAPI doesn't use UNICODE for this one...

    rgSPVStat[0].ulPropTag  = PR_DISPLAY_NAME_A;
#ifdef UNICODE
    szFileName[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, lpszFABFile, -1, szFileName, ARRAYSIZE(szFileName), NULL, NULL );
    rgSPVStat[0].Value.lpszA = szFileName;
#else
    rgSPVStat[0].Value.lpszA = lpszFABFile;
#endif
    rgSPVStat[1].ulPropTag  = PR_RESOURCE_METHODS;
    rgSPVStat[1].Value.l    = 0;
    rgSPVStat[2].ulPropTag  = PR_RESOURCE_FLAGS;
    rgSPVStat[2].Value.l    = 0;
    rgSPVStat[3].ulPropTag  = PR_STATUS_CODE;
    rgSPVStat[3].Value.l    = STATUS_AVAILABLE;

    // MAPI doesn't use UNICODE for this one
    rgSPVStat[4].ulPropTag  = PR_STATUS_STRING_A;
    rgSPVStat[4].Value.lpszA = "Available";

    // MAPI doesn't use UNICODE for this one
    rgSPVStat[5].ulPropTag  = PR_PROVIDER_DISPLAY_A;
    rgSPVStat[5].Value.lpszA = "Microsoft Fax Address Book Provider";

    /*
     *  Set the Status Row for this provider,
     *  but do not allow an error from setting the
     *  status row to cause failure to Logon.
     */

    (void)lpMAPISup->lpVtbl->ModifyStatusRow(lpMAPISup,
        ARRAYSIZE(rgSPVStat), rgSPVStat, 0);

    /*
     *  AddRef the support object, because we're keeping
     *  a pointer to it in our Logon object.
     */
    lpMAPISup->lpVtbl->AddRef(lpMAPISup);

    /*
     *  AddRef our parent ABInit object
     */
    lpABP->lpVtbl->AddRef(lpABP);

    InitializeCriticalSection(&lpABPLogon->cs);

    *lppABLogon = (LPABLOGON) lpABPLogon;

out:

    DebugTraceResult(HrNewABPLogon, hResult);
    return hResult;
}


/*************************************************************************
 *
 -  ABPLOGON_QueryInterface
 -
 */
STDMETHODIMP
ABPLOGON_QueryInterface( LPABPLOGON lpABPLogon,
                         REFIID lpiid,
                         LPVOID * ppvObj
                        )
{
    if ( IsBadReadPtr(lpiid,   SIZEOF(IID)) ||
         IsBadWritePtr(ppvObj, SIZEOF(LPVOID))
        )
    {
        DebugTraceSc(ABPLOGON_QueryInterface, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /*  See if the requested interface is one of ours */

    if ( memcmp(lpiid, &IID_IUnknown, SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IABLogon, SIZEOF(IID))
        )
    {
        *ppvObj = NULL;         /* OLE requires zeroing [out] parameter on error */
        DebugTraceSc(ABPLOGON_QueryInterface, E_NOINTERFACE);
        return ResultFromScode(E_NOINTERFACE);
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpABPLogon->cs);
    ++lpABPLogon->lcInit;
    LeaveCriticalSection(&lpABPLogon->cs);

    *ppvObj = lpABPLogon;

    return hrSuccess;
}

/*
 *  Use ROOTs AddRef
 */

/*************************************************************************
 *
 -  ABPLOGON_Release
 -
 */
STDMETHODIMP_(ULONG)
ABPLOGON_Release(LPABPLOGON lpABPLogon)
{
    LONG lcInit;

    EnterCriticalSection(&lpABPLogon->cs);
    lcInit = --lpABPLogon->lcInit;
    LeaveCriticalSection(&lpABPLogon->cs);

    if (lcInit == 0)
    {
        DeleteCriticalSection(&lpABPLogon->cs);
        lpABPLogon->lpVtbl = NULL;
        lpABPLogon->lpFreeBuff(lpABPLogon);
        return (0);
    }
    return lcInit;
}

/*************************************************************************
 *
 -  ABPLOGON_Logoff
 -
 *  Logoff from this logon object.  Clean up any resources/objects that
 *  our logon object has accumulated.
 *
 *
 */
STDMETHODIMP
ABPLOGON_Logoff(LPABPLOGON lpABPLogon, ULONG ulFlags)
{

    DebugTrace("AWFXAB32(ABPLOGON_Logoff): entering\n");

#ifdef DO_WE_REALLY_NEED_TAPI
    /*
     * Let TAPI go
     */
    DeinitTAPI();
#endif

    /*
     *  Remove this logon object from the list of known
     *  logon objects associated with this initialization
     *  of this provider.
     */
    (void) RemoveLogonObject(lpABPLogon->lpABP, lpABPLogon, lpABPLogon->lpFreeBuff);

    /*
     *  No longer need to be holding on to our parent
     */
    lpABPLogon->lpABP->lpVtbl->Release(lpABPLogon->lpABP);

    /*
     *  Free up the file
     */
    lpABPLogon->lpFreeBuff(lpABPLogon->lpszFileName);

    if (lpABPLogon->lpTDatRoot)
        lpABPLogon->lpTDatRoot->lpVtbl->Release(lpABPLogon->lpTDatRoot);

    if (lpABPLogon->lpTDatOO)
        lpABPLogon->lpTDatOO->lpVtbl->Release(lpABPLogon->lpTDatOO);

    /*
     *  very last thing I should do is release the support object
     */
    lpABPLogon->lpMapiSup->lpVtbl->Release(lpABPLogon->lpMapiSup);

        DebugTrace("AWFXAB32(ABPLOGON_Logoff): leaving\n");

    return hrSuccess;
}

/*************************************************************************
 *
 -  ABPLOGON_OpenEntry
 -
 *  Creates an object with (at least) the IMAPIProp interface from an
 *  entryID.
 *
 *  There are four valid types of entryIDs handled:
 *
 *    NULL          <- return back the root container object
 *    DIR_ENTRYID   <- return back the directory container object
 *    USR_ENTRYID   <- return back the MAILUSER object
 *    OOUSER_ENTRYID <- return back the OneOff MAILUSER object
 *
 *  Note:  This call is reused for all other internal objects that support OpenEntry().
 *    Those other calls *must* check their parameters before calling this method.
 *    The only other way this method is called is via MAPI which does parameter checking
 *    for us.  The most we'll do here is assert our parameters.
 */
STDMETHODIMP
ABPLOGON_OpenEntry( LPABPLOGON lpABPLogon,
                    ULONG cbEntryID,
                    LPENTRYID lpEntryID,
                    LPCIID lpInterface,
                    ULONG ulFlags,
                    ULONG * lpulObjType,
                    LPUNKNOWN * lppUnk
                   )
{

    LPDIR_ENTRYID lpEID = (LPDIR_ENTRYID) lpEntryID;
    HRESULT hResult = hrSuccess;
    LPTSTR lpszFileName;

    /*
     *  Check the EntryID
     */

    // used to be: if (!lpEntryID)
    if (!cbEntryID)
    {
        LPABCONT lpABCont = NULL;

        /*
         *  Special case:  the root level object
         */

        NFAssertSz(!lpEntryID, "Non-NULL entry id passed with 0 cb to OpenEntry()\n");

        /*  Make this new object  */

        /*
        *  Get the current .FAB file name from our logon object
        */
        hResult = HrLpszGetCurrentFileName((LPABLOGON) lpABPLogon, &lpszFileName);
        if (HR_FAILED(hResult))
            goto out;

        // If there is a real Fax AB
        if ((fExposeFaxAB) &&
                (lpszFileName[0] != 0))

        hResult = HrNewROOT((LPABCONT *) lppUnk,
                    lpulObjType,
                    (LPABLOGON) lpABPLogon,
                    lpInterface,
                    lpABPLogon->hLibrary,
                    lpABPLogon->lpAllocBuff,
                    lpABPLogon->lpAllocMore,
                    lpABPLogon->lpFreeBuff,
                    lpABPLogon->lpMalloc);

        else
                // No Fax AB container
                return ResultFromScode (MAPI_E_INTERFACE_NOT_SUPPORTED);

        lpABPLogon->lpFreeBuff(lpszFileName);
        goto out;
    }

    /*
     *  There's an entryID there, is it mine??
     *  I need to check because I'm reusing this routine for
     *  my Container->OpenEntry call, and I can't be sure the
     *  client will always be well behaved.
     *
     *  When this routine is called from MAPI, this call is redundant.  But
     *  because I'm reusing this routine, I gotta check.
     */

    /*  Compare MAPIUIDs  */
    if (memcmp(&(((LPDIR_ENTRYID) lpEntryID)->muid), &muidABMAWF,
            SIZEOF(MAPIUID)))
    {
        /*
         *  Not mine!
         */

        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        DebugTraceResult(ABPLOGON_OpenEntry, hResult);
        goto out;
    }

    /*
     *  What object does this correspond to??
     */

    /*  I've only got two types: containers and users  */

    if (lpEID->ulType == MAWF_DIRECTORY)
    {
        LPABLOGON lpABPLogonT = NULL;

        /* entry id must have the same verson number */
        if (lpEID->ulVersion != MAWF_VERSION)
        {
            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);
            SetErrorIDS(lpABPLogon, hResult, IDS_OLD_EID);

            goto out;
        }

        /*
         *  find the correct logon object for this entryid
         */

        (void) FindLogonObject(lpABPLogon->lpABP, &lpEID->muidID, &lpABPLogonT);

        /* did we find the corresponding logon object */
        if (!lpABPLogonT)
        {
            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);
            goto out;
        }

        // If I don't have a fab file at this point, I can't open the AB container
        HrLpszGetCurrentFileName((LPABLOGON) lpABPLogonT, &lpszFileName);
        if (lpszFileName[0] == 0)
        {
            hResult = ResultFromScode (MAPI_E_NO_SUPPORT);
            DebugTraceResult(ABPLOGON_OpenEntry, hResult);
            goto out;
        }

        hResult = HrNewFaxDirectory( (LPABCONT *) lppUnk,
                                    lpulObjType,
                                    (LPABLOGON) lpABPLogonT,
                                    lpInterface,
                                    lpABPLogon->hLibrary,
                                    lpABPLogon->lpAllocBuff,
                                    lpABPLogon->lpAllocMore,
                                    lpABPLogon->lpFreeBuff,
                                    lpABPLogon->lpMalloc);
        goto out;

    }

    if (lpEID->ulType == MAWF_USER)
    {
        if (cbEntryID == (ULONG) sizeof(USR_ENTRYID))
        {
            hResult = HrNewFaxUser( (LPMAILUSER *) lppUnk,
                                    lpulObjType,
                                    cbEntryID,
                                    lpEntryID,
                                    (LPABLOGON) lpABPLogon,
                                    lpInterface,
                                    lpABPLogon->hLibrary,
                                    lpABPLogon->lpAllocBuff,
                                    lpABPLogon->lpAllocMore,
                                    lpABPLogon->lpFreeBuff,
                                    lpABPLogon->lpMalloc);

            goto out;
        }
    }


    if (lpEID->ulType == MAWF_ONEOFF)
    {
        if (cbEntryID == (ULONG) sizeof(OOUSER_ENTRYID))
        {
            hResult = HrNewFaxOOUser( (LPMAILUSER *) lppUnk,
                                        lpulObjType,
                                        cbEntryID,
                                        lpEntryID,
                                        (LPABLOGON) lpABPLogon,
                                        lpInterface,
                                        lpABPLogon->hLibrary,
                                        lpABPLogon->lpAllocBuff,
                                        lpABPLogon->lpAllocMore,
                                        lpABPLogon->lpFreeBuff,
                                        lpABPLogon->lpMalloc);


            goto out;
        }
    }

    hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);

out:
    DebugTraceResult(ABPLOGON_OpenEntry, hResult);

    return hResult;

}

/*************************************************************************
 *
 -  ABPLOGON_CompareEntryIDs
 -
 *  If the two entryids are mine and they're of the same type, then
 *  just do a binary comparison to see if they're equal.
 *
 */
STDMETHODIMP
ABPLOGON_CompareEntryIDs( LPABPLOGON lpABPLogon,
                          ULONG cbEntryID1,
                          LPENTRYID lpEntryID1,
                          ULONG cbEntryID2,
                          LPENTRYID lpEntryID2,
                          ULONG ulFlags,
                          ULONG * lpulResult
                         )
{

    LPDIR_ENTRYID lpEID1 = (LPDIR_ENTRYID) lpEntryID1;
    LPDIR_ENTRYID lpEID2 = (LPDIR_ENTRYID) lpEntryID2;
    HRESULT hResult = hrSuccess;

    /*
     *  Check to see if their MUID is mine
     */
    if ( memcmp(&(lpEID1->muid), &muidABMAWF, SIZEOF(MAPIUID)) ||
         memcmp(&(lpEID2->muid), &muidABMAWF, SIZEOF(MAPIUID))
        )
    {
        /*
         *  No recognition of these entryids.
         */

        *lpulResult = (ULONG) FALSE;
        hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);
        goto out;
    }

    /*
     *  See if the type of entryids are the same
     */
    if (lpEID1->ulType != lpEID2->ulType)
    {
        /*
         *  They're not, so they don't match
         */

        *lpulResult = (ULONG) FALSE;
        goto out;

    }

    /*
     *  See if the entryids are the same size.  They'd better be
     *  if they're the same type.
     */
    if (cbEntryID1 != cbEntryID2)
    {
        /*
         *  They're not?!?  Then I don't know these...
         */

        *lpulResult = (ULONG) FALSE;
        hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);

        goto out;
    }

    /*
     *  Check for Directory entryids
     */
    if (lpEID1->ulType == MAWF_DIRECTORY)
    {
        /*
         *  Ok, I'm dealing with directory entryids
         */

        /*
         *  Better make sure it's the right size
         */
        if (cbEntryID1 != sizeof(DIR_ENTRYID))
        {
            /*
             *  This doesn't make sense.  I don't recognize this entryid.
             */

            *lpulResult = (ULONG) FALSE;
            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);

            goto out;
        }

        /*
         *  At this point it's just a memcmp
         */
        if (memcmp(lpEID1, lpEID2, SIZEOF(DIR_ENTRYID)))
        {
            /*
             *  They're not equal
             */

            *lpulResult = (ULONG) FALSE;

            goto out;
        }

        /*
         *  They must be the same
         */

        *lpulResult = (ULONG) TRUE;

        goto out;
    }

    if (lpEID1->ulType == MAWF_USER)
    {
        /*
         *  Ok, I'm dealing with user entryids
         */

        /*
         *  Better make sure it's the right size
         */
        if (cbEntryID1 != sizeof(USR_ENTRYID))
        {
            /*
             *  This doesn't make sense.  I don't recognize this entryid.
             */

            *lpulResult = (ULONG) FALSE;
            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);

            goto out;
        }

        /*
         *  At this point it's just a memcmp
         */
        if (memcmp(lpEID1, lpEID2, SIZEOF(USR_ENTRYID)))
        {
            /*
             *  They're not equal
             */

            *lpulResult = (ULONG) FALSE;

            goto out;
        }

        /*
         *  They must be the same
         */

        *lpulResult = (ULONG) TRUE;

        goto out;
    }

    if (lpEID1->ulType == MAWF_ONEOFF)
    {
        /*
         *  Ok, I'm dealing with oneoff user entryids
         */

        /*
         *  Better make sure it's the right size
         */
        if (cbEntryID1 != SIZEOF(OOUSER_ENTRYID))
        {
            /*
             *  This doesn't make sense.  I don't recognize this entryid.
             */

            *lpulResult = (ULONG) FALSE;
            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);

            goto out;
        }

        /*
         *  At this point it's just a memcmp
         */
        if (memcmp(lpEID1, lpEID2, SIZEOF(OOUSER_ENTRYID)))
        {
            /*
             *  They're not equal
             */

            *lpulResult = (ULONG) FALSE;

            goto out;
        }

        /*
         *  They must be the same
         */

        *lpulResult = (ULONG) TRUE;

        goto out;
    }

    /*
     *  It's no entryid I know of
     */

    *lpulResult = (ULONG) FALSE;
    hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID);

out:

    DebugTraceResult(ABPLOGON_CompareEntryIDs, hResult);
    return hResult;

}

/*************************************************************************
 *
 -  ABPLOGON_OpenStatusEntry
 -
 *
 *
 *
 */
STDMETHODIMP
ABPLOGON_OpenStatusEntry( LPABPLOGON lpABPLogon,
                          LPCIID lpIID,
                          ULONG ulFlags,
                          ULONG FAR * lpulObjType,
                          LPMAPISTATUS FAR * lppEntry
                         )
{
    HRESULT hr;

    /*
     *  Validate Parameters
     */
    if ( IsBadReadPtr(lpABPLogon,      (UINT) SIZEOF(ABPLOGON))    ||
         (lpIID && IsBadReadPtr(lpIID, (UINT) SIZEOF(IID)))        ||
         IsBadWritePtr(lpulObjType,    (UINT) SIZEOF(ULONG FAR *)) ||
         IsBadWritePtr(lppEntry,       (UINT) SIZEOF(LPMAPISTATUS))
        )
    {
        DebugTraceSc(ABPLogon_OpenStatusEntry, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }


    hr = HrNewStatusObject( lppEntry,
                            lpulObjType,
                            ulFlags,
                            (LPABLOGON) lpABPLogon,
                            lpIID,
                            lpABPLogon->hLibrary,
                            lpABPLogon->lpAllocBuff,
                            lpABPLogon->lpAllocMore,
                            lpABPLogon->lpFreeBuff,
                            lpABPLogon->lpMalloc);

    DebugTraceResult(ABPLOGON_OpenStatusEntry, hr);
    return hr;
}

/*************************************************************************
 *
 -  ABPLOGON_OpenTemplateID
 -
 *
 *
 *
 */
STDMETHODIMP
ABPLOGON_OpenTemplateID( LPABPLOGON lpABPLogon,
                         ULONG cbTemplateId,
                         LPENTRYID lpTemplateId,
                         ULONG ulTemplateFlags,
                         LPMAPIPROP lpMAPIPropData,
                         LPCIID lpInterface,
                         LPMAPIPROP * lppMAPIPropNew,
                         LPMAPIPROP lpMAPIPropSibling
                        )
{
    HRESULT hResult;

    /*
     *  Validate Parameters
     */
    if ( IsBadReadPtr(lpABPLogon,      (UINT) SIZEOF(ABPLOGON))   ||
         IsBadReadPtr(lpTemplateId,    (UINT) cbTemplateId)       ||
         IsBadReadPtr(lpMAPIPropData,  (UINT) SIZEOF(LPVOID))     ||
         (lpInterface && IsBadReadPtr(lpInterface, (UINT) sizeof(IID))) ||
         IsBadWritePtr(lppMAPIPropNew, (UINT) SIZEOF(LPMAPIPROP)) ||
         (lpMAPIPropSibling && IsBadReadPtr(lpMAPIPropSibling, (UINT) SIZEOF(LPVOID)))
        )
    {
        DebugTraceSc(ABPLogon_OpenTemplateID, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    /* //$ need stronger checking here... */
    /* entryid better be right size */
    if (cbTemplateId != sizeof(OOUSER_ENTRYID) && cbTemplateId != sizeof(USR_ENTRYID))
    {
        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto out;
    }

    /*  is it my entry id compare MAPIUIDs  */
    if (memcmp(&(((LPUSR_ENTRYID) lpTemplateId)->muid), &muidABMAWF, SIZEOF(MAPIUID)))
    {
       /*
        *  Not mine!
        */
        hResult = ResultFromScode( MAPI_E_INVALID_ENTRYID );
        goto out;
    }

    /* better be a oneoff user entryid or a user entry id */
    if (((LPUSR_ENTRYID) lpTemplateId)->ulType == MAWF_ONEOFF)
    {

        hResult = HrNewOOTID( lppMAPIPropNew,
                              cbTemplateId,
                              lpTemplateId,
                              ulTemplateFlags,
                              lpMAPIPropData,
                              (LPABLOGON) lpABPLogon,
                              lpInterface,
                              lpABPLogon->hLibrary,
                              lpABPLogon->lpAllocBuff,
                              lpABPLogon->lpAllocMore,
                              lpABPLogon->lpFreeBuff,
                              lpABPLogon->lpMalloc
                             );

    }
    else if (((LPUSR_ENTRYID) lpTemplateId)->ulType == MAWF_USER)
    {
        hResult = HrNewTID( lppMAPIPropNew,
                            cbTemplateId,
                            lpTemplateId,
                            ulTemplateFlags,
                            lpMAPIPropData,
                            (LPABLOGON) lpABPLogon,
                            lpInterface,
                            lpABPLogon->hLibrary,
                            lpABPLogon->lpAllocBuff,
                            lpABPLogon->lpAllocMore,
                            lpABPLogon->lpFreeBuff,
                            lpABPLogon->lpMalloc
                           );
    }
    else
    {
        hResult = MakeResult(MAPI_E_INVALID_ENTRYID);
    }

out:

    DebugTraceResult(ABPLOGON_OpenTemplateID, hResult);
    return hResult;
}

/*
 -  ABPLOGON_GetOneOffTable
 -
 *  Returns the lists of one-offs that this providers can support creation of.
 *  This list is added to the entries gathered from all the other AB logon objects
 *  and exposed to the user as the list of things that can be created on a
 *  message.  Also this total list is available to other providers through the
 *  support method GetOneOffTable().
 *
 *  Note:  There's a bug here that if there are more than one Microsoft At Work Fax Address Books
 *  installed on a particular profile, then there will be multiple entries in the
 *  one-off table from this provider.  This can be changed to only have one one-off
 *  entry, no matter how many FABs are configured in a profile, if the one-off table
 *  was associated with the ABInit object.
 */

/*
 *  Column set for the oneoff table
 */
enum {  ivalootPR_DISPLAY_NAME = 0,
        ivalootPR_ENTRYID,
        ivalootPR_DEPTH,
        ivalootPR_SELECTABLE,
        ivalootPR_ADDRTYPE,
        ivalootPR_DISPLAY_TYPE,
        ivalootPR_INSTANCE_KEY,
        ivalootMax };

static const SizedSPropTagArray(ivalootMax, tagaColSetOOTable) =
{
    ivalootMax,
    {
        PR_DISPLAY_NAME_A,
        PR_ENTRYID,
        PR_DEPTH,
        PR_SELECTABLE,
        PR_ADDRTYPE_A,
        PR_DISPLAY_TYPE,
        PR_INSTANCE_KEY
    }
};

STDMETHODIMP
ABPLOGON_GetOneOffTable( LPABPLOGON lpABPLogon,
                         ULONG ulFlags,
                         LPMAPITABLE * lppTable
                        )
{
    SCODE       sc;
    HRESULT     hResult;
    SRow        sRow;
    SPropValue  rgsPropValue[ivalootMax];
    CHAR        displayNameString[MAX_DISPLAY_NAME];
    ULONG       ulInstanceKey = 1;
    HINSTANCE   hInst;
#ifdef UNICODE
    CHAR        szEMT[ MAX_PATH ];
#endif

    /*
     *  Validate Parameters
     */

    if ( ulFlags & ~(MAPI_UNICODE) )
    {
        DebugTraceArg( APBLOGON_GetOneOffTable, "Unknown Flags" );
        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS );
    }

    if ( ulFlags & MAPI_UNICODE )
    {
        DebugTraceArg( APBLOGON_GetOneOffTable, "UNICODE not supported" );
        return ResultFromScode( MAPI_E_BAD_CHARWIDTH );
    }

    if (    IsBadReadPtr(lpABPLogon, (UINT) SIZEOF(ABPLOGON))
         || IsBadWritePtr(lppTable,  (UINT) SIZEOF(LPMAPITABLE))
        )
    {
        DebugTraceSc(ABPLogon_GetOneOffTable, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }


    EnterCriticalSection(&lpABPLogon->cs);

    /*
     * If there's not one already associated with this logon object,
     * then create one.
     */
    if (!lpABPLogon->lpTDatOO)
    {
        /* Create a Table data object */
        sc = CreateTable(
            (LPIID) &IID_IMAPITableData,
            lpABPLogon->lpAllocBuff,
            lpABPLogon->lpAllocMore,
            lpABPLogon->lpFreeBuff,
            lpABPLogon->lpMalloc,
            0,
            PR_DISPLAY_NAME_A,
            (LPSPropTagArray) &tagaColSetOOTable,
            &(lpABPLogon->lpTDatOO));

        if (FAILED(sc))
        {
            hResult = ResultFromScode(sc);
            goto out;
        }


        // Get the instance handle, so that I can get the display strings off the resource file
        hInst = lpABPLogon->hLibrary;

        // Initialize the row
        sRow.cValues = ivalootMax;
        sRow.lpProps = rgsPropValue;

        /*
         *      Fill the table
         *
         *      we want to add two entries to the one-off table, so that we'll get:
         *
         *      Microsoft Fax
         *              Fax
         */

        // First do the 'Microsoft Fax'

        // Name of the One-Off
        rgsPropValue[ivalootPR_DISPLAY_NAME].ulPropTag  = PR_DISPLAY_NAME_A;
        LoadStringA( hInst, IDS_MAWF_NAME, displayNameString, ARRAYSIZE(displayNameString));
        rgsPropValue[ivalootPR_DISPLAY_NAME].Value.lpszA = displayNameString;

        rgsPropValue[ivalootPR_ENTRYID].ulPropTag     = PR_ENTRYID;
        rgsPropValue[ivalootPR_ENTRYID].Value.bin.cb  = SIZEOF(OOUSER_ENTRYID);
        rgsPropValue[ivalootPR_ENTRYID].Value.bin.lpb = (LPVOID) &ONEOFF_EID;

        // the hierarcy level (how far to indent a display name). I choose not to indent
        rgsPropValue[ivalootPR_DEPTH].ulPropTag = PR_DEPTH;
        rgsPropValue[ivalootPR_DEPTH].Value.l = 0;

        // Selection flags. TRUE indicates this entry ID can be used in CreateEntry() call.
        rgsPropValue[ivalootPR_SELECTABLE].ulPropTag = PR_SELECTABLE;
        rgsPropValue[ivalootPR_SELECTABLE].Value.b = TRUE;

        //  The address type that would be generated by an entry
        //  created from this template
        rgsPropValue[ivalootPR_ADDRTYPE].ulPropTag = PR_ADDRTYPE_A;
#ifdef UNICODE
        szEMT[0] = 0;
        WideCharToMultiByte( CP_ACP, 0, lpszEMT, -1, szEMT, ARRAYSIZE(szEMT), NULL, NULL );
        rgsPropValue[ivalootPR_ADDRTYPE].Value.lpszA = szEMT;
#else
        rgsPropValue[ivalootPR_ADDRTYPE].Value.LPSZ = lpszEMT;
#endif

        /*
         *  The display type associated with a recipient built with this template
         */
        rgsPropValue[ivalootPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
        rgsPropValue[ivalootPR_DISPLAY_TYPE].Value.lpszA = DT_MAILUSER;

        /*
         *  The instance key of this row in this one-off table.
         *  using 1 for this row
         */
        ulInstanceKey = 1;
        rgsPropValue[ivalootPR_INSTANCE_KEY].ulPropTag     = PR_INSTANCE_KEY;
        rgsPropValue[ivalootPR_INSTANCE_KEY].Value.bin.cb  = SIZEOF(ULONG);
        rgsPropValue[ivalootPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &ulInstanceKey;

        (void) lpABPLogon->lpTDatOO->lpVtbl->HrModifyRow(
                            lpABPLogon->lpTDatOO,
                            &sRow);

#ifdef DO_MULTI_LEVEL_ADDRESS_BOOK_STUFF
        // Now do the 'Fax'

        // Name of the One-Off
        rgsPropValue[ivalootPR_DISPLAY_NAME].ulPropTag    = PR_DISPLAY_NAME_A;
        LoadStringA(hInst, IDS_FAX_NAME, displayNameString, ARRAYSIZE(displayNameString));
        rgsPropValue[ivalootPR_DISPLAY_NAME].Value.lpszA  = displayNameString;

        // The entry ID for this template. MAPI will call OpenEntry() with this entry ID
        // RtlZeroMemory(&EntryID, sizeof(OOUSER_ENTRYID));

        rgsPropValue[ivalootPR_ENTRYID].ulPropTag     = PR_ENTRYID;
        rgsPropValue[ivalootPR_ENTRYID].Value.bin.cb  = SIZEOF(OOUSER_ENTRYID);
        rgsPropValue[ivalootPR_ENTRYID].Value.bin.lpb = (LPVOID) &ONEOFF_EID;

        // the hierarcy level (how far to indent a display name). I choose not to indent
        rgsPropValue[ivalootPR_DEPTH].ulPropTag = PR_DEPTH;
        rgsPropValue[ivalootPR_DEPTH].Value.l = 1;

        // Selection flags. TRUE indicates this entry ID can be used in CreateEntry() call.
        rgsPropValue[ivalootPR_SELECTABLE].ulPropTag = PR_SELECTABLE;
        rgsPropValue[ivalootPR_SELECTABLE].Value.b = TRUE;

        //  The address type that would be generated by an entry
        //  created from this template
        rgsPropValue[ivalootPR_ADDRTYPE].ulPropTag  = PR_ADDRTYPE_A;
#ifdef UNICODE
        rgsPropValue[ivalootPR_ADDRTYPE].Value.lpszA = szEMT;
#else
        rgsPropValue[ivalootPR_ADDRTYPE].Value.LPSZ = lpszEMT;
#endif

        /*
         *  The display type associated with a recipient built with this template
         */
        rgsPropValue[ivalootPR_DISPLAY_TYPE].ulPropTag   = PR_DISPLAY_TYPE;
        rgsPropValue[ivalootPR_DISPLAY_TYPE].Value.lpszA = DT_MAILUSER;

        /*
         *  The instance key of this row in this one-off table.
         *  using 2 for this row
         */
        ulInstanceKey = 2;
        rgsPropValue[ivalootPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
        rgsPropValue[ivalootPR_INSTANCE_KEY].Value.bin.cb = SIZEOF(ULONG);
        rgsPropValue[ivalootPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &ulInstanceKey;

        (void) lpABPLogon->lpTDatOO->lpVtbl->HrModifyRow(
                            lpABPLogon->lpTDatOO,
                            &sRow);

#endif
    }

    /*
     *  Get a view to return to the caller
     */
    hResult = lpABPLogon->lpTDatOO->lpVtbl->HrGetView(
        lpABPLogon->lpTDatOO,
        NULL,
        NULL,
        0,
        (LPMAPITABLE *) lppTable);

out:

    LeaveCriticalSection(&lpABPLogon->cs);

    DebugTraceResult(ABPLogon_GetOneOffTable, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  ABPLOGON_Advise
 -
 *  NYI
 *
 *
 */
STDMETHODIMP
ABPLOGON_Advise( LPABPLOGON lpABPLogon,
                 ULONG cbEntryID,
                 LPENTRYID lpEntryID,
                 ULONG ulEventMask,
                 LPMAPIADVISESINK lpAdviseSink,
                 ULONG FAR * lpulConnection
                )
{
    DebugTraceSc(ABPLOGON_Advise, MAPI_E_NO_SUPPORT);
    return ResultFromScode(MAPI_E_NO_SUPPORT);
}

/*************************************************************************
 *
 -  ABPLOGON_Unadvise
 -
 *  NYI
 *
 *
 */
STDMETHODIMP
ABPLOGON_Unadvise(LPABPLOGON lpABPLogon, ULONG ulConnection)
{
    DebugTraceSc(ABPLOGON_Unadvise, MAPI_E_NO_SUPPORT);
    return ResultFromScode(MAPI_E_NO_SUPPORT);
}

/*************************************************************************
 *
 -  ABPLOGON_PrepareRecips
 -
 *      Takes a list of recipients and sets values for a requested list of
 *      properties (lpPropTagArray) on each of the recipients, from the respective
 *      address book entry of the recipient. If the recipient already has
 *      some properties set on it, those that exist on the address book entry
 *      will override the one that are on the recipient. Those that do NOT
 *      exist in the address book entry will stay.
 *
 *
 */
STDMETHODIMP
ABPLOGON_PrepareRecips( LPABPLOGON lpABPLogon,
                        ULONG           ulFlags,
                        LPSPropTagArray lpPropTagArray,
                        LPADRLIST       lpRecipList
                       )
{
    HRESULT         hResult         = hrSuccess;
    UINT            iRecip;
    UINT            iProp;
    ULONG           cValues;
    LPSPropValue    lpspvUser       = NULL;
    LPSPropValue    lpNewRecip      = NULL;
    LPMAPIPROP      lpMAPIPropEntry = NULL;
    SCODE           sc              = S_OK;
    ULONG           ulObjType;
    BOOL            fUselpspvUser;

    if (!lpPropTagArray)
    {
        /*
         *  They only want us to update our entryID from ephemeral to
         *  permanent.  Since ours are already permanent, we don't need to
         *  do anything.
         */
        goto out;
    }

    /* loop through all the recipients */

    for (iRecip = 0; iRecip < lpRecipList->cEntries; iRecip++)
    {
        LPUSR_ENTRYID   lpEntryID       = NULL;
        ULONG           cbEntryID;
        LPSPropValue    lpPropVal       = NULL;
        LPSPropValue    rgpropvalsRecip = lpRecipList->aEntries[iRecip].rgPropVals;
        ULONG           cPropsRecip     = lpRecipList->aEntries[iRecip].cValues;

        /* For each recipient, find its entryid */

        lpPropVal = PpropFindProp( rgpropvalsRecip, cPropsRecip, PR_ENTRYID );

        if ( lpPropVal )
        {
            lpEntryID = (LPUSR_ENTRYID)lpPropVal->Value.bin.lpb;
            cbEntryID = lpPropVal->Value.bin.cb;
        }
        else
            continue;

        /* Is it one of ours? */

        if ( cbEntryID < CbNewENTRYID(0)
            || IsBadReadPtr( (LPVOID) lpEntryID, (UINT) cbEntryID ) )
        {
            continue;   /* no, keep looking */
        }

        if ( memcmp( &(lpEntryID->muid), &muidABMAWF, SIZEOF(MAPIUID) ) )
            continue;   /* no, keep looking */

        /* Try and open it. */

        hResult = HrNewFaxUser( (LPMAILUSER *)&lpMAPIPropEntry,
                                &ulObjType,
                                cbEntryID,
                                (LPENTRYID) lpEntryID,
                                (LPABLOGON) lpABPLogon,
                                NULL,
                                lpABPLogon->hLibrary,
                                lpABPLogon->lpAllocBuff,
                                lpABPLogon->lpAllocMore,
                                lpABPLogon->lpFreeBuff,
                                lpABPLogon->lpMalloc
                               );

        if ( HR_FAILED(hResult) )
        {
             /* Couldn't open it...; Ignore it and keep looking */

            hResult = hrSuccess;
            DebugTrace( "ABPLOGON_PrepareRecips sees a bad user entry ID\n" );
            continue;
        }

        /* Get the properties requested */

        hResult = lpMAPIPropEntry->lpVtbl->GetProps( lpMAPIPropEntry,
                lpPropTagArray,
                0, /* ansi */
                &cValues, &lpspvUser );

        /* No longer need lpMAPIPropEntry  */

        lpMAPIPropEntry->lpVtbl->Release(lpMAPIPropEntry);
        lpMAPIPropEntry = NULL;

        if (HR_FAILED(hResult))
        {
            /* Failed getting properties. Cleanup and ignore this entry */

            hResult = hrSuccess;
            continue;
        }

        hResult = hrSuccess;

        Assert(cValues == lpPropTagArray->cValues);

        /*
         *  This is the hard part.
         *  Merge the two property sets: lpspvUser and lpsPropVal.  Note that
         *  both of these sets may have the same property - chances are they do.
         *  for these conflicts, lpspvUser should be the one we get the property
         *  from.
         *
         *  Guess how big the resultant SPropValue array is, and allocate one of that
         *  size.
         */

        sc = lpABPLogon->lpAllocBuff( (cValues + cPropsRecip) * SIZEOF( SPropValue ),
                &lpNewRecip);
        if (FAILED(sc))
        {
            /*
             *  Ok, to fail the call here.  If we're running into out of memory conditions
             *  we're all in trouble.
             */

            hResult = ResultFromScode( sc );
            goto err;
        }

        /*
         *  Copy lpspvUser properties over to lpNewRecip
         *  Check each property in lpsvUser to ensure that it isn't PT_ERROR, if so
         *  find the propval in rgpropvalsRecip ( the [in] recip prop val array ),
         *  if it exists and use that property.
         */

        for (iProp = 0; iProp < cValues; iProp++)
        {
            fUselpspvUser = TRUE;

            if ( PROP_TYPE( lpspvUser[iProp].ulPropTag ) == PT_ERROR )
            {
                lpPropVal = PpropFindProp( rgpropvalsRecip, cPropsRecip,
                         lpPropTagArray->aulPropTag[iProp] );

                if ( lpPropVal )
                {
                    sc = PropCopyMore(  lpNewRecip + iProp, lpPropVal,
                            lpABPLogon->lpAllocMore, lpNewRecip );

                    fUselpspvUser = FALSE;
                }
            }

            if ( fUselpspvUser )
            {
                sc = PropCopyMore(  lpNewRecip + iProp, lpspvUser + iProp,
                        lpABPLogon->lpAllocMore, lpNewRecip );
            }

            if (FAILED(sc))
            {
                if (sc == MAPI_E_NOT_ENOUGH_MEMORY)
                {
                    hResult = MakeResult(sc);
                    goto err;
                }

                /*
                 *   Otherwise we've run into something wierd in the prop value array
                 *   like PT_UNSPECIFIED, PT_NULL, or PT_OBJECT.  In which case continue
                 *   on.
                 */
            }
        }

        /* Done with lpspvUser */

        lpABPLogon->lpFreeBuff( lpspvUser );
        lpspvUser = NULL;

        /*
         *  Copy those properties that aren't already in lpNewRecip
         *  from rgpropvalsRecip.  Don't copy over the PT_ERROR prop vals
         */
        for ( iProp = 0; iProp < cPropsRecip; iProp++ )
        {

            if ( PpropFindProp( lpNewRecip, cValues, rgpropvalsRecip[iProp].ulPropTag )
                || PROP_TYPE( rgpropvalsRecip[iProp].ulPropTag ) == PT_ERROR )
                continue;

            sc = PropCopyMore(  lpNewRecip + cValues, rgpropvalsRecip + iProp,
                    lpABPLogon->lpAllocMore, lpNewRecip );
            if ( FAILED( sc ) )
            {
                if (sc == MAPI_E_NOT_ENOUGH_MEMORY)
                {

                    hResult = ResultFromScode( sc );
                    goto err;
                }

                /*
                 *  Otherwise we've run into something wierd in the prop value array
                 *  like PT_UNSPECIFIED, PT_NULL, or PT_OBJECT.  In which case continue
                 *  on.
                 */
            }

            cValues++;
        }

        /*
         *  Replace the AdrEntry in the AdrList with this new lpNewRecip.  And
         *  don't forget the cValues!
         */

        lpRecipList->aEntries[iRecip].rgPropVals = lpNewRecip;
        lpRecipList->aEntries[iRecip].cValues    = cValues;

        /* Finally, free up the old AdrEntry. */

        lpABPLogon->lpFreeBuff( rgpropvalsRecip );

    }
out:

    DebugTraceResult( ABPLOGON_PrepareRecips, hResult );
    return hResult;

err:

    lpABPLogon->lpFreeBuff( lpspvUser );
    goto out;
}


/*************************************************************************
 *  LpMuidFromLogon -
 *    Returns the particular ABPLOGON object's unique identifier.
 *
 */

LPMAPIUID
LpMuidFromLogon(LPABLOGON lpABLogon)
{
    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon;

    AssertSz(!IsBadReadPtr(lpABPLogon, SIZEOF(ABPLOGON)), "Bad logon object!\n");

    return (&(lpABPLogon->muidID));
}


/*************************************************************************
 *  HrLpszGetCurrentFileName -
 *    Returns a copy of the current .FAB file pointed to by this logon object.
 *
 */

HRESULT
HrLpszGetCurrentFileName(LPABLOGON lpABLogon, LPTSTR * lppszFileName)
{
    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon;
    SCODE sc;
    HRESULT hResult = hrSuccess;

    AssertSz(!IsBadReadPtr(lpABPLogon, SIZEOF(ABPLOGON)), "FAB: Bad logon object!\n");
    AssertSz(!IsBadWritePtr(lppszFileName, SIZEOF(LPTSTR)), "FAB: Bad dest string!\n");

    EnterCriticalSection(&lpABPLogon->cs);

    sc = lpABPLogon->lpAllocBuff( (lstrlen(lpABPLogon->lpszFileName)+1)*SIZEOF(TCHAR), lppszFileName);
    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto ret;
    }

    lstrcpy( *lppszFileName, lpABPLogon->lpszFileName);

ret:
    LeaveCriticalSection(&lpABPLogon->cs);

    DebugTraceResult(HrLpszGetCurrentFileName, hResult);
    return hResult;
}

/*
 *  HrReplaceCurrentFileName -
 *    Replaces the current file name associated with this logon object and tries
 *    to save it all away in the profile.
 */

HRESULT
HrReplaceCurrentFileName(LPABLOGON lpABLogon, LPTSTR lpszNewFile)
{
    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon;
    HRESULT hResult = hrSuccess;
    LPPROFSECT lpProfSect = NULL;
    LPTSTR lpstrT;
    SCODE sc;
    SPropValue rgspv[1];
#ifdef UNICODE
    CHAR szAnsiFileName[ MAX_PATH ];
#endif

    AssertSz(!IsBadReadPtr(lpABPLogon, SIZEOF(ABPLOGON)), "Bad logon object!\n");

    EnterCriticalSection(&lpABPLogon->cs);

    /*
     *  FAB file name has changed have to update profile and objects
     */
    if (lstrcmp(lpszNewFile, lpABPLogon->lpszFileName))
    {

        /*
         *  Open the private profile section...
         */
        hResult = lpABPLogon->lpMapiSup->lpVtbl->OpenProfileSection(
                          lpABPLogon->lpMapiSup,
                          NULL,
                          MAPI_MODIFY,
                          &lpProfSect);

        if (HR_FAILED(hResult))
        {
            /*
             *  Shouldn't get here, but in case I do, just...
             */
            goto ret;
        }

        /*
         *  Save the new name back into the profile
         */
        rgspv[0].ulPropTag  = PR_FAB_FILE_A;
#ifdef UNICODE
        szAnsiFileName[0] = 0;
        WideCharToMultiByte( CP_ACP, 0, lpszNewFile, -1, szAnsiFileName, ARRAYSIZE(szAnsiFileName), NULL, NULL );
        rgspv[0].Value.lpszA = szAnsiFileName;
#else
        rgspv[0].Value.LPSZ = lpszNewFile;
#endif

        /*
         *  Don't care if I can save it in the profile or not.
         *  Saving it's a nice to have, but absolutely required
         *  for operation of this particular provider.
         */
        (void) lpProfSect->lpVtbl->SetProps(
                       lpProfSect,
                       1,   // ansi
                       rgspv,
                       NULL);

        lpProfSect->lpVtbl->Release(lpProfSect);

        /*
         *  Allocate and copy this new one
         */

        sc = lpABPLogon->lpAllocBuff( (lstrlen(lpszNewFile)+1)*SIZEOF(TCHAR), &lpstrT);
        if (FAILED(sc))
        {
            hResult = ResultFromScode(sc);
            goto ret;
        }

        lstrcpy( lpstrT, lpszNewFile );

        /*
         *  Free up the old one...
         */
        lpABPLogon->lpFreeBuff(lpABPLogon->lpszFileName);

        /*
         *  Put in the new one.
         */
        lpABPLogon->lpszFileName = lpstrT;

        /*
         *  Update the hierarchy table
         */
        hResult = HrBuildRootHier((LPABLOGON)lpABPLogon, NULL);
    }

ret:
    LeaveCriticalSection(&lpABPLogon->cs);

    DebugTraceResult(HrReplaceCurrentFileName, hResult);
    return hResult;
}

/*
 *  GenerateContainerDN -
 *      Common code for generating the display name of the single
 *      container exposed from this logon object.
 */
#ifdef SAB      // from sample AB
void
GenerateContainerDN(LPABLOGON lpABLogon, LPTSTR lpszName)
{

    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon;
    LPTSTR lpszFileName;
    int ich;

    AssertSz(!IsBadReadPtr(lpABPLogon, SIZEOF(ABPLOGON)), "Bad logon object!\n");


    EnterCriticalSection(&lpABPLogon->cs);

    lpszFileName = lpABPLogon->lpszFileName;

    // get the filename without the path
    for (ich = lstrlen(lpszFileName) - 1; ich >= 0; ich--)
    {
        if (lpszFileName[ich] == TEXT('\\'))
            break;
    }

    // skip past the backslash
    ich++;

    wsprintf(lpszName, TEXT("FAB using %s"), lpszFileName + ich);

    LeaveCriticalSection(&lpABPLogon->cs);
}

#else   // Fax AB
void
GenerateContainerDN(HINSTANCE hInst, LPTSTR lpszName)
{

    LoadString (hInst, IDS_ADDRESS_BOOK_ROOT_CONT, lpszName, MAX_DISPLAY_NAME);

}
#endif

/*
 -  HrBuildRootHier
 -
 *
 *  Builds up the root hierarchy for the Microsoft At Work Fax Address Book.
 *
 *
 */
enum {  ivalPR_DISPLAY_NAME = 0,
        ivalPR_ENTRYID,
        ivalPR_DEPTH,
        ivalPR_OBJECT_TYPE,
        ivalPR_DISPLAY_TYPE,
        ivalPR_CONTAINER_FLAGS,
        ivalPR_INSTANCE_KEY,
        ivalPR_AB_PROVIDER_ID,
        cvalMax };

static const SizedSPropTagArray(cvalMax, tagaRootColSet) =
{
    cvalMax,
    {
        PR_DISPLAY_NAME_A,
        PR_ENTRYID,
        PR_DEPTH,
        PR_OBJECT_TYPE,
        PR_DISPLAY_TYPE,
        PR_CONTAINER_FLAGS,
        PR_INSTANCE_KEY,
        PR_AB_PROVIDER_ID
    }
};

HRESULT
HrBuildRootHier(LPABLOGON lpABLogon, LPMAPITABLE * lppMAPITable)
{
    HRESULT     hResult;
    SCODE       sc;
    SRow        sRow;
    SPropValue  rgsPropValue[cvalMax];
    ULONG       ulInstanceKey = 1;
    TCHAR       szBuf[MAX_PATH];
#ifdef UNICODE
    CHAR        szAnsiBuf[MAX_PATH];
#endif
    HINSTANCE   hInst;
    LPABPLOGON  lpABPLogon = (LPABPLOGON) lpABLogon;
    DIR_ENTRYID eidRoot =   {   {0, 0, 0, 0},
                                MUIDABMAWF,
                                MAWF_VERSION,
                                MAWF_DIRECTORY };


    EnterCriticalSection(&lpABPLogon->cs);

    hInst = lpABPLogon->hLibrary;

    /*
     *  See if we have a TaD yet
     */
    if (!lpABPLogon->lpTDatRoot)
    {
        /* Create a Table Data object */
        if ( sc = CreateTable((LPIID) &IID_IMAPITableData,
                        lpABPLogon->lpAllocBuff,
                        lpABPLogon->lpAllocMore,
                        lpABPLogon->lpFreeBuff,
                        lpABPLogon->lpMalloc,
                        0,
                        PR_ENTRYID,
                        (LPSPropTagArray) &tagaRootColSet,
                        &(lpABPLogon->lpTDatRoot))
            )
        {
            hResult = ResultFromScode(sc);
            goto out;
        }
    }
    /* Constants */

    sRow.cValues = cvalMax;
    sRow.lpProps = rgsPropValue;

    /* First, the Display Name stuff*/

    rgsPropValue[ivalPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME_A;
#ifdef SAB
    GenerateContainerDN((LPABLOGON) lpABPLogon, szBuf);
#else
    GenerateContainerDN(hInst, szBuf);
#endif
#ifdef UNICODE
    szAnsiBuf[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, szBuf, -1, szAnsiBuf, ARRAYSIZE(szAnsiBuf), NULL, NULL );
    rgsPropValue[ivalPR_DISPLAY_NAME].Value.lpszA = szAnsiBuf;
#else
    rgsPropValue[ivalPR_DISPLAY_NAME].Value.lpszA = szBuf;
#endif

    /*
     *  For each FAB logon object associated with it's init object,
     *  we have a unique MAPIUID.  It's the only thing that distinguishes
     *  one FAB entryid from another in the merged hierarchy table that
     *  MAPI generates.
     */

    rgsPropValue[ivalPR_ENTRYID].ulPropTag = PR_ENTRYID;
    eidRoot.muidID = lpABPLogon->muidID;
    rgsPropValue[ivalPR_ENTRYID].Value.bin.cb  = SIZEOF(DIR_ENTRYID);
    rgsPropValue[ivalPR_ENTRYID].Value.bin.lpb = (LPVOID) &eidRoot;

    rgsPropValue[ivalPR_DEPTH].ulPropTag = PR_DEPTH;
    rgsPropValue[ivalPR_DEPTH].Value.l   = 0;

    rgsPropValue[ivalPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    rgsPropValue[ivalPR_OBJECT_TYPE].Value.l   = MAPI_ABCONT;

    rgsPropValue[ivalPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    rgsPropValue[ivalPR_DISPLAY_TYPE].Value.l   = DT_NOT_SPECIFIC;

    rgsPropValue[ivalPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    rgsPropValue[ivalPR_CONTAINER_FLAGS].Value.l   = AB_RECIPIENTS | AB_UNMODIFIABLE;

    rgsPropValue[ivalPR_INSTANCE_KEY].ulPropTag     = PR_INSTANCE_KEY;
    rgsPropValue[ivalPR_INSTANCE_KEY].Value.bin.cb  = SIZEOF(ULONG);
    rgsPropValue[ivalPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &ulInstanceKey;

    rgsPropValue[ivalPR_AB_PROVIDER_ID].ulPropTag     = PR_AB_PROVIDER_ID;
    rgsPropValue[ivalPR_AB_PROVIDER_ID].Value.bin.cb  = SIZEOF(MAPIUID);
    rgsPropValue[ivalPR_AB_PROVIDER_ID].Value.bin.lpb = (LPBYTE) &muidABMAWF;

    hResult = lpABPLogon->lpTDatRoot->lpVtbl->HrModifyRow( lpABPLogon->lpTDatRoot, &sRow );

    if (HR_FAILED(hResult))
        goto out;


    /*
     *  Check to see if they want a view returned as well
     */
    if (lppMAPITable)
    {
        /* Get a view from the Table data object */
        hResult =
            lpABPLogon->lpTDatRoot->lpVtbl->HrGetView(
                    lpABPLogon->lpTDatRoot,
                    NULL,
                    NULL,
                    0,
                    lppMAPITable);
    }

out:

    LeaveCriticalSection(&lpABPLogon->cs);

    DebugTraceResult(HrBuildRootHier, hResult);
    return hResult;
}



/*
 *  Checks to see if the file passed in is still the actual file that
 *  should be browsed.
 */
BOOL
FEqualFABFiles( LPABLOGON lpABLogon,
                LPTSTR lpszFileName)
{
    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon;
    BOOL fEqual;

    AssertSz(!IsBadReadPtr(lpABPLogon, SIZEOF(ABPLOGON)), "Bad logon object!\n");

    EnterCriticalSection(&lpABPLogon->cs);

    fEqual = !lstrcmp( lpszFileName, lpABPLogon->lpszFileName );

    LeaveCriticalSection(&lpABPLogon->cs);

    return fEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abguid.c ===
/*
 *	ABGUID.C
 *	
 *	Defines GUIDs for use in smpabXX.dll.
 */


#define USES_IID_IMAPITableData
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPITable
#define USES_IID_IMAPIControl
#define USES_IID_IABProvider
#define USES_IID_IABLogon
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIStatus

#ifdef WIN32	/* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Daytona; Chicago needs it */
#define _INC_OLE /* Keep Chicago from including OLE1 */
#include <windows.h>
#include <ole2.h>
#endif
#endif

#ifdef WIN16
#include <compobj.h>
#endif

#define INITGUID
#include <initguid.h>

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);

#include "mapiguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abp.c ===
/***********************************************************************
 *
 *  ABP.C
 *
 *
 *  The Microsoft At Work Fax Address Book Provider.
 *  This file contains the routines that handle the ABPJump table.
 *
 *  The following routines are implemented in this file:
 *
 *  ABProviderInit
 *  ABP_QueryInterface
 *  ABP_Release
 *  ABP_Shutdown
 *  ABP_Logon
 *
 *  ServiceEntry
 *  HrOpenSingleProvider
 *
 *  RemoveLogonObject
 *  FindLogonObject
 *  ScLoadString
 *
 *  Globals defined in this file:
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *  Revision History:
 *
 * When        Who                 What
 * --------    ------------------  ---------------------------------------
 * 1.1.94      MAPI                Original source from MAPI sample AB Provider
 * 1.27.94     Yoram Yaacovi       Modifications to make it an At Work Fax ABP
 * 3.5.94      Yoram Yaacovi       Update to MAPI build 154
 * 4.1.94      Yoram Yaacovi       Update to MAPI and sample AB build 157
 * 8.1.94      Yoram Yaacovi       Update to MAPI and sample AB build 306
 *
 ***********************************************************************/

#define _FAXAB_ABP
#include "faxab.h"

/*
 *  Prototypes for the functions in this file, most of which I return
 *  in the jump table returned from ABProviderInit().
 */

ABPROVIDERINIT  ABProviderInit;
MSGSERVICEENTRY FABServiceEntry;
HRESULT         HrOpenSingleProvider( LPPROVIDERADMIN lpAdminProviders,
                                      LPPROFSECT FAR *lppProfSect
                                     );
void            LoadIniParams(void);

/*
 *  The jump table returned from ABProviderInit().
 */
ABP_Vtbl vtblABP =
{
   ABP_QueryInterface,
   (ABP_AddRef_METHOD *) ROOT_AddRef,
   ABP_Release,
   ABP_Shutdown,
   ABP_Logon
};

/*************************************************************************
 *
 -  ABProviderInit
 -
 *  Initializes this provider.  Returns a jump table that contains the
 *  addresses of the rest of the functions.
 *
 */

HRESULT STDMAPIINITCALLTYPE
ABProviderInit (
           HINSTANCE           hLibrary,
           LPMALLOC            lpMalloc,
           LPALLOCATEBUFFER    lpAllocBuff,
           LPALLOCATEMORE      lpAllocMore,
           LPFREEBUFFER        lpFreeBuff,
           ULONG               ulFlags,
           ULONG               ulMAPIVersion,
           ULONG FAR *         lpulABVersion,
           LPABPROVIDER FAR *  lppABProvider)
{
    HRESULT hResult = hrSuccess;
    LPABP lpABP;
    SCODE scode;

    //DebugBreak();

    DebugTrace("AWFXAB32(ABProviderInit): entering\n");
    // Get registry settings
    LoadIniParams();

#ifdef DEBUG
     if (fDebugTrap)
            DebugBreak();
#endif

    /*
     *  Check the version
     */
    if (ulMAPIVersion < CURRENT_SPI_VERSION)
    {
        /*
         *  MAPI's version is too old.
         */

        /*
         *  See if they understand my version
         */

        *lpulABVersion = CURRENT_SPI_VERSION;

        DebugTraceSc(ABProviderInit, MAPI_E_VERSION);
        return ResultFromScode(MAPI_E_VERSION);
    }

   /*
    *  Allocate memory for this Init Object
    */
    scode = lpAllocBuff (SIZEOF(ABP), &lpABP);
    if (FAILED(scode))
    {
       /*
        *  Out of memory
        */
        DebugTraceSc(ABProviderInit, scode);
        return ResultFromScode(scode);
    }

    /*
     *  Initialize the idle engine that MAPI supplies.  This is most useful
     *  when browsing the .FAB file.  See ABCTBLn.C.
     */

    if (MAPIInitIdle( NULL )==-1)
    {
        hResult = ResultFromScode(E_FAIL);
        goto err;
    }

   /*
    *  Hold on to the lpMalloc
    */
    if (lpMalloc)
        lpMalloc->lpVtbl->AddRef(lpMalloc);

    lpABP->lpVtbl   = &vtblABP;
    lpABP->lcInit   = 1;
    lpABP->hLibrary = hLibrary;

    lpABP->lpMalloc = lpMalloc;
    lpABP->lpAllocBuff = lpAllocBuff;
    lpABP->lpAllocMore = lpAllocMore;
    lpABP->lpFreeBuff  = lpFreeBuff;
    lpABP->lpObjectList= NULL;

    InitializeCriticalSection(&lpABP->cs);

    *lppABProvider = (LPABPROVIDER)lpABP;
    *lpulABVersion = CURRENT_SPI_VERSION;

    /*
     *  Get our Locale Identifier
     */
    lcidUser = GetUserDefaultLCID();


out:
    DebugTraceResult(ABProviderInit, hResult);
    return hResult;

err:
    lpFreeBuff(lpABP);

    goto out;
}


/*
 *  The Init Object's methods implementation
 */


/**********************************************************************
 -  ABP_QueryInterface
 -
 *  Supports QI'ing to IUnknown and IABProvider
 *
 *  Note that for all the methods of IABProvider that parameter validation
 *  is unnecessary.  This is because MAPI is handling all the parameters
 *  being passed in.
 *  At best you can assert your parameters.
 */
STDMETHODIMP
ABP_QueryInterface (LPABP lpABP, REFIID lpiid, LPVOID *ppvObj)
{
    DebugTrace("AWFXAB32(ABP_QueryInterface): entering\n");

    /*  See if the requested interface is one of ours */

    if ( memcmp (lpiid, &IID_IUnknown, SIZEOF (IID)) &&
         memcmp (lpiid, &IID_IABProvider, SIZEOF (IID))
        )
    {
        *ppvObj = NULL; /* OLE requires zeroing [out] parameter on error */
        DebugTraceSc(ABP_QueryInterface, E_NOINTERFACE);
        return ResultFromScode (E_NOINTERFACE);
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpABP->cs);
    ++lpABP->lcInit;
    LeaveCriticalSection(&lpABP->cs);

    *ppvObj = lpABP;

    return hrSuccess;
}

/*
 *  Use ROOTs AddRef
 */

/*************************************************************************
 *
 -  ABP_Release
 -
 *  Releases and cleans up this object
 */
STDMETHODIMP_(ULONG)
ABP_Release (LPABP lpABP)
{
    long lcInit;

    DebugTrace("AWFXAB32(ABP_Release): entering\n");

    EnterCriticalSection(&lpABP->cs);
    lcInit = --lpABP->lcInit;
    LeaveCriticalSection(&lpABP->cs);

    if (lcInit == 0)
    {
        DeleteCriticalSection(&lpABP->cs);

        lpABP->lpVtbl = NULL;
        lpABP->lpFreeBuff(lpABP);
        return (0);
    }
    return lcInit;
}

/**********************************************************************
 -  ABP_Shutdown
 -
 *  Informs this provider that MAPI is done with it.
 *
 *
 */
STDMETHODIMP
ABP_Shutdown (LPABP lpABP, ULONG FAR *lpulFlags)
{
    DebugTrace("AWFXAB32(ABP_Shutdown): entering\n");

    MAPIDeinitIdle();

    if (lpABP->lpMalloc)
    {
        lpABP->lpMalloc->lpVtbl->Release(lpABP->lpMalloc);
        lpABP->lpMalloc = NULL;
    }

    return hrSuccess;
}



/*************************************************************************
 *
 -  ABP_Logon
 -
 *  Create a logon object and return it to MAPI.
 *
 */
/*
 *  The PropTagArray used to retrieve logon properties
 */
enum {  ivallogonPR_FAB_FILE=0,
        ivallogonPR_FAB_UID,
        cvallogonMax };

static const SizedSPropTagArray(cvallogonMax, tagaFABLogonProps) =
{
    cvallogonMax,
    {
        PR_FAB_FILE_A,
        PR_FAB_UID
    }
};

STDMETHODIMP
ABP_Logon( LPABP             lpABP,
           LPMAPISUP         lpMAPISup,
           ULONG             ulUIParam,
           LPTSTR            lpszProfileName,
           ULONG             ulFlags,
           ULONG FAR *       lpulpcbSecurity,
           LPBYTE FAR *      lppbSecurity,
           LPMAPIERROR FAR * lppMapiError,
           LPABLOGON FAR *   lppABPLogon
          )
{
    LPABLOGON    lpABLogon = NULL;
    HRESULT      hResult = hrSuccess;
    SCODE        scode;
    LPPROFSECT   lpProfSect = NULL;
    LPSPropValue lpsPropVal = NULL;
    ULONG        cValues = 0;
    TCHAR        szFileName[MAX_PATH];
    LPTSTR       lpstrT = NULL;
    BOOL         fUINeeded;
    BOOL         fNeedMAPIUID = FALSE;
    MAPIUID      muidID;
    LPOBJECTLIST lpObjectList;
    LPTSTR       lpszAppName=NULL;
#ifdef UNICODE
    CHAR         szAnsiFileName[ MAX_PATH ];
#endif

#ifdef EXTENDED_DEBUG
    MessageBox((HWND) ulUIParam, TEXT("ABP_Logon: entering"), TEXT("awfxab debug message"), MB_OK);
#endif

    DebugTrace("AWFXAB32(ABP_Logon): entering\n");

    szFileName[0] =  TEXT('\0');

    *lppMapiError = NULL;

    if ( ulFlags & MAPI_UNICODE )
    {
        DebugTraceArg( ABP_Logon, "Bad Character width" );
        return ResultFromScode( MAPI_E_BAD_CHARWIDTH );
    }

    /*
     *  Get the name of my browse file from the profile section
     */

    /*  Open the section for my provider */
    hResult = lpMAPISup->lpVtbl->OpenProfileSection( lpMAPISup,
                                                     NULL,
                                                     MAPI_MODIFY,
                                                     &lpProfSect
                                                    );

    if (HR_FAILED(hResult))
        goto out;

    /*  Get the property containing the Fax AB file name. */
    hResult = lpProfSect->lpVtbl->GetProps( lpProfSect,
                                            (LPSPropTagArray)&tagaFABLogonProps,
                                            0,   // ANSI
                                            &cValues,
                                            &lpsPropVal
                                           );

    if (HR_FAILED(hResult))
        goto out;

#ifdef DEBUG
    /*  The only expected return code is MAPI_E_NOT_FOUND. */
    if (hResult != hrSuccess)
    {
        if (GetScode (hResult) != MAPI_W_ERRORS_RETURNED)
        {
            DebugTrace("AWFXAB32(ABP_Logon): got unexpected hResult: ");
            DebugTraceResult(ProfileGetProps, hResult);
        }
        else if (lpsPropVal[0].Value.err != MAPI_E_NOT_FOUND)
        {
            DebugTrace("AWFXAB32(ABP_Logon): got unexpected scode: ");
            DebugTraceSc(ProfileGetProps, lpsPropVal[0].Value.err);
        }
    }
#endif

    /*  Ignore warnings from reading the property. */
    hResult = hrSuccess;

    /* copy the Fax Address Book file name */
    if (lpsPropVal[0].ulPropTag==PR_FAB_FILE_A)
    {
        UINT cch = lstrlenA(lpsPropVal[0].Value.lpszA);

        if (cch >= MAX_PATH)
            cch = MAX_PATH-1;

        if (cch)
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, 0, lpsPropVal[0].Value.lpszA, -1, szFileName, ARRAYSIZE(szFileName) );
#else
            memcpy(szFileName, lpsPropVal[0].Value.lpszA, cch);
#endif

        szFileName[cch] = TEXT('\0');
    }
    else
    {
        DebugTrace("AWFXAB32(ABP_Logon): PR_FAB_FILE not found\n");
    }

    /* copy the fab uid */
    if (lpsPropVal[1].ulPropTag==PR_FAB_UID)
    {
        memcpy(&muidID,lpsPropVal[1].Value.bin.lpb, SIZEOF(MAPIUID));
    }
    else
    {
        DebugTrace("AWFXAB32(ABP_Logon): PR_FAB_UID not found\n");
        fNeedMAPIUID = TRUE;
    }

   /*  Discard GetProps() return data, if any. */
   lpABP->lpFreeBuff (lpsPropVal);

   /*
    *  (UI needed unless the file name is good and file exists.)
    *
    *       in Fax, the AB is not exposed, so there is never a UI
    *       If you insist on using a fax AB, you can set the name in the registry
    */

    fUINeeded = TRUE;

    if (szFileName[0] != 0)
    {
        /* Verify the file exists. */

        HANDLE hFile = CreateFile (
                szFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle (hFile);

            fUINeeded = FALSE;
        }
    }

    // Am I allowed to bring up UI ?
    if (ulFlags & AB_NO_DIALOG)
        fUINeeded = FALSE;

    // If the registry flag does not allow to expose the fax AB UI, don't allow it, no
    // matter what happened earlier
    if (!fExposeFaxAB)
        fUINeeded = FALSE;

    /*
     *  if the sab file name was not found in the profile or the sab file
     *  does not exist we have to get the user to pick another one and
     *  save back into the profile
     */

    if (fUINeeded)
    {
        OPENFILENAME openfilename;
        SPropValue sProp[1];

        /*
         *  Can't bring up UI unless the client allows it
         */
        if (ulFlags & AB_NO_DIALOG)
        {
            hResult = ResultFromScode (MAPI_E_LOGON_FAILED);
            goto out;
        }

        /*
         *  Get the user to select a file
         */
        openfilename.lStructSize       = SIZEOF(OPENFILENAME);
        openfilename.hwndOwner         = (HWND) ulUIParam;
        openfilename.hInstance         = 0; /* Ignored */
        openfilename.lpstrFilter       = TEXT("Microsoft Fax Address Book files\0*.fab\0\0");
        openfilename.lpstrCustomFilter = NULL;
        openfilename.nMaxCustFilter    = 0;
        openfilename.nFilterIndex      = 0;
        openfilename.lpstrFile         = szFileName;
        openfilename.nMaxFile          = MAX_PATH;
        openfilename.lpstrFileTitle    = NULL;
        openfilename.nMaxFileTitle     = 0;
        openfilename.lpstrInitialDir   = NULL;
        openfilename.lpstrTitle        = TEXT("Microsoft Fax Address Book");
        openfilename.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
        openfilename.nFileOffset       = 0;
        openfilename.nFileExtension    = 0;
        openfilename.lpstrDefExt       = TEXT("fab");
        openfilename.lCustData         = 0;
        openfilename.lpfnHook          = NULL;
        openfilename.lpTemplateName    = NULL;

        /*
         *  Call up the common dialog
         */
        if (!GetOpenFileName (&openfilename))
        {
#ifdef DEBUG
            DWORD dwT;
            dwT = CommDlgExtendedError();
#endif /* DEBUG */

            // next two lines not needed for fax AB. an empty fax AB is valid.
            // hResult = ResultFromScode (MAPI_E_LOGON_FAILED);
            // goto out;
        }

        /*
         *  Set the fab file name property value
         */
        sProp[0].ulPropTag  = PR_FAB_FILE_A;
#ifdef UNICODE
        WideCharToMultiByte( CP_ACP, 0, szFileName, -1, szAnsiFileName, ARRAYSIZE(szAnsiFileName), NULL, NULL );
        sProp[0].Value.lpszA = szAnsiFileName;
#else
        sProp[0].Value.lpszA = szFileName;
#endif

        /*
         *  Save the fab file into the profile
         */
        if (hResult = lpProfSect->lpVtbl->SetProps(lpProfSect, 1, sProp, NULL))
        {
            /*
             *  Do nothing...  So I couldn't save it away this time...
             */
            DebugTraceResult("ABP_Logon got unexpected result on SetProps\n", hResult);
            hResult = hrSuccess;
        }
    }   // if (fUINeeded)

    /*
     *  if the uid was not found we have to generate a new muid for the
     *  PR_SAB_ID property and save it back into the profile
     */

    if (fNeedMAPIUID)
    {
        SPropValue sProp[1];

        /*
         *  Get a new fab uid
         */
        hResult=lpMAPISup->lpVtbl->NewUID(lpMAPISup,&muidID);
        if (HR_FAILED(hResult))
        {
            DebugTraceResult(NewUID, hResult);
            goto out;
        }

        /*
         *  Set the fab uid property value
         */
        sProp[1].ulPropTag = PR_FAB_UID;
        sProp[1].Value.bin.cb = SIZEOF(MAPIUID);
        sProp[1].Value.bin.lpb = (LPBYTE)&muidID;

        /*
         *  Save the sab uid into the profile
         */
        if (hResult = lpProfSect->lpVtbl->SetProps(lpProfSect, 1, sProp, NULL))
        {
            /*
             *  Do nothing...  So I couldn't save it away this time...
             */
            DebugTraceResult("ABP_Logon got unexpected result on SetProps\n", hResult);
            hResult = hrSuccess;
        }
    }       // if (fNeedMAPIUID)

    /*
     *  Allocate space for keeping the file name in the ABLogon object
     */

    if (scode = lpABP->lpAllocBuff((lstrlen(szFileName)+1)*SIZEOF(TCHAR), &lpstrT))
    {
        hResult = ResultFromScode (scode);
        goto out;
    }
    lstrcpy (lpstrT, szFileName);

    hResult = HrNewABLogon( &lpABLogon,
                            (LPABPROVIDER) lpABP,
                            lpMAPISup,
                            lpstrT,
                            &muidID,
                            lpABP->hLibrary,
                            lpABP->lpAllocBuff,
                            lpABP->lpAllocMore,
                            lpABP->lpFreeBuff,
                            lpABP->lpMalloc
                           );
    if (HR_FAILED(hResult))
    {
        goto out;
    }

    /*
     *  Allocate space for another object list item
     */

    if (scode = lpABP->lpAllocBuff( sizeof(OBJECTLIST), &lpObjectList))
    {
        hResult = ResultFromScode(scode);
        goto out;
    }

    /*
     *  add logon object to list
     */

    /* Get the Critical Section */
    EnterCriticalSection(&lpABP->cs);

    /* add logon object to begining of providers object list */
    lpObjectList->lpObject = (LPVOID) lpABLogon;
    lpObjectList->lppNext = lpABP->lpObjectList;

    /* insert new logon object into the head of the providers object list */
    lpABP->lpObjectList = lpObjectList;

    /* leave critical section */
    LeaveCriticalSection(&lpABP->cs);


    /*
     *  Register my MAPIUID for this provider,
     *  but do not allow an error from setting the
     *  MAPIUID to cause failure to Logon.
     */

    (void)lpMAPISup->lpVtbl->SetProviderUID(lpMAPISup,
                  (LPMAPIUID) &muidABMAWF, 0);

#ifdef DO_WE_REALLY_NEED_TAPI
    /*
     *      TAPI
     *
     *      everything seems OK. get TAPI initialized
     */
    scode = ScLoadString( IDS_APP_NAME,
                          MAX_PATH,
                          lpABP->lpAllocBuff,
                          lpABP->hLibrary,
                          &lpszAppName
                         );

    InitTAPI(lpABP->hLibrary, (HWND) ulUIParam, lpszAppName);

    // Make sure we have the required location information handy
    // bring up mini-dial helper if not
    InitLocationParams((HWND) ulUIParam);
#endif

    lpABP->lpFreeBuff(lpszAppName);

    // return the object to the caller
    *lppABPLogon = lpABLogon;

out:
    if (lpProfSect)
        lpProfSect->lpVtbl->Release(lpProfSect);

    if (hResult)
    {
        lpABP->lpFreeBuff(lpstrT);

        Assert(lpABLogon == NULL);

        /* Verify we don't return warnings at this time. */
        Assert(HR_FAILED(hResult));
    }

    DebugTraceResult(ABP_Logon, hResult);
    return hResult;
}

/*************************************************************************
 -
 -      RemoveLogonObject
 -
 *  Removes a particular logon object from the list of logon objects
 *  that's kept track of in the IABProvider object
 */
void
RemoveLogonObject( LPABPROVIDER lpABProvider,
                   LPVOID lpvABLogon,
                   LPFREEBUFFER lpFreeBuff
                  )
{

    LPOBJECTLIST *lppObjectList;
    LPOBJECTLIST lpObjectListT;
    LPABP lpABP = (LPABP) lpABProvider;

#if defined DEBUG
    BOOL fFound = FALSE;

#endif

    /* Get the Critical Section */
    EnterCriticalSection(&lpABP->cs);

    /*
     *  remove this logon object from the provider init objects list
     *  of logon objects
     */
    lppObjectList = &(lpABP->lpObjectList);

    while (*lppObjectList)
    {
        /* is this the logon object? */
        if ((*lppObjectList)->lpObject == lpvABLogon)
        {
            /* save next list item */
            lpObjectListT = (*lppObjectList)->lppNext;

            /* free the object list item */
            lpFreeBuff(*lppObjectList);

            /* delete object from the list */
            *lppObjectList = lpObjectListT;

#if defined DEBUG
            fFound = TRUE;
#endif
            break;
        }

        lppObjectList = &(*lppObjectList)->lppNext;
    }

    /* leave critical section */
    LeaveCriticalSection(&lpABP->cs);

#if defined DEBUG
    AssertSz(fFound, "Logon object not found on providers object list");
#endif

    return;
}


/*************************************************************************
 -
 -      FindLogonObject
 -
 *  Finds a particular logon object by its muid.
 */
void
FindLogonObject( LPABPROVIDER lpABProvider,
                 LPMAPIUID lpMuidToFind,
                 LPABLOGON * lppABLogon
                )
{
    LPABP lpABP = (LPABP) lpABProvider;
    LPABLOGON lpABLogonT = NULL;
    LPOBJECTLIST lpObjectList = NULL;
    LPMAPIUID lpMuidLogon = NULL;

    Assert(!IsBadReadPtr(lpABP, SIZEOF(ABP)));
    Assert(!IsBadReadPtr(lpMuidToFind, SIZEOF(MAPIUID)));
    Assert(!IsBadReadPtr(lppABLogon, SIZEOF(LPABLOGON)));

    /* Get the Critical Section */
    EnterCriticalSection(&lpABP->cs);

    *lppABLogon = NULL;

    for (lpObjectList = lpABP->lpObjectList;
        lpObjectList; lpObjectList = lpObjectList->lppNext)
    {
        lpABLogonT = (LPABLOGON) lpObjectList->lpObject;

        lpMuidLogon = LpMuidFromLogon(lpABLogonT);

        if (memcmp((LPVOID) lpMuidLogon, (LPVOID) lpMuidToFind, SIZEOF(MAPIUID)) == 0)
        {
            *lppABLogon = lpABLogonT;
            break;
        }
    }

    /* leave critical section */
    LeaveCriticalSection(&lpABP->cs);
}



/*************************************************************************
 *
 -  FABServiceEntry
 -
 *  This funtion is used by MAPI to configure the Sample Address Book.
 *  It's a lot like ABP_Logon, except that it doesn't return a logon object
 *  and it can be passed in its configuration information (as defined in
 *  smpab.h) from MAPI so that no UI is required.
 *
 *  lppMapiError        a pointer to a MAPI error structure which allows
 *                                              the provider to return extended error info to MAPI
 */
STDAPI
FABServiceEntry(
   HINSTANCE       hInstance,
   LPMALLOC        lpMalloc,
   LPMAPISUP       lpMAPISup,
   ULONG           ulUIParam,
   ULONG           ulFlags,
   ULONG           ulContext,
   ULONG           cValues,
   LPSPropValue    lpProps,
   LPPROVIDERADMIN lpAdminProviders,
   LPMAPIERROR FAR *lppMapiError)
{
    OPENFILENAME     openfilename;
    TCHAR            szFileName[MAX_PATH];
    HRESULT          hResult=hrSuccess;
    SPropValue       sProp[cvallogonMax];
    LPSPropValue     lpsPropVal = NULL;
    ULONG            ulCount = 0;
    LPALLOCATEBUFFER lpAllocBuff;
    LPALLOCATEMORE   lpAllocMore;
    LPFREEBUFFER     lpFreeBuff;
    MAPIUID          muid;
    LPPROFSECT       lpProf = NULL;
    BOOL             fFABFound=FALSE;        // No fab file name yet
    BOOL             fUIDFound=FALSE;        // No fab uid yet
    BOOL             fNeedMAPIUID = FALSE;
    ULONG            uliProp;
#ifdef UNICODE
    CHAR             szAnsiFileName[ MAX_PATH ];
#endif
#ifdef EXTENDED_DEBUG
   TCHAR             szTempBuf[256];
#endif

    //DebugBreak();

    DebugTrace("AWFXAB32(ServiceEntry): entering\n");

    // Get registry settings
    LoadIniParams();

#ifdef DEBUG
    if (fDebugTrap)
            DebugBreak();
#endif

    /*
     * Parameter validation
     */

    // check the support object
    if (IsBadReadPtr(lpMAPISup, SIZEOF(LPMAPISUP)))
    {
        DebugTraceSc(ServiceEntry, E_INVALIDARG);
        return ResultFromScode(E_INVALIDARG);
    }

    if ( ulFlags & MAPI_UNICODE )
    {
        DebugTraceArg( ServiceEntry, "Bad character width" );
        return ResultFromScode( MAPI_E_BAD_CHARWIDTH );
    }

#ifdef EXTENDED_DEBUG
    switch (ulContext) {

    case MSG_SERVICE_DELETE:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_DELETE called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    case MSG_SERVICE_INSTALL:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_INSTALL called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    case MSG_SERVICE_UNINSTALL:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_UNINSTALL called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    case MSG_SERVICE_CREATE:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_CREATE called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    case MSG_SERVICE_CONFIGURE:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_CONFIGURE called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    case MSG_SERVICE_PROVIDER_CREATE:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_PROVIDER_CREATE called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    case MSG_SERVICE_PROVIDER_DELETE:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry MSG_SERVICE_PROVIDER_DELETE called!"), TEXT("awfxab debug message"), MB_OK);
        break;

    default:
        MessageBox((HWND) ulUIParam, TEXT("ServiceEntry unknown called!"), TEXT("awfxab debug message"), MB_OK);
        break;
    }
#endif

    /*
     *  Check what to do
     */
    if ( ulContext==MSG_SERVICE_DELETE ||
         ulContext==MSG_SERVICE_INSTALL ||
         ulContext==MSG_SERVICE_UNINSTALL
        )
    {
       return hrSuccess;
    }

    // Only supporting MSG_SERVICE_CONFIGURE and MSG_SERVICE_CREATE
    if ( ulContext!=MSG_SERVICE_CONFIGURE &&
         ulContext!=MSG_SERVICE_CREATE
        )
    {
        DebugTrace("ServiceEntry unsupported context\n");
        return ResultFromScode(MAPI_E_NO_SUPPORT);
    }

    /*  Get the memory allocation routines we'll be needing. */
    hResult = lpMAPISup->lpVtbl->GetMemAllocRoutines( lpMAPISup,
                      &lpAllocBuff,
                      &lpAllocMore,
                      &lpFreeBuff
                     );
    if (hResult)
    {
        DebugTraceResult (MAPISUP::GetMemAllocRoutines, hResult);
        goto out;
    }

    /* Open the profile section associated with our provider */
    hResult = HrOpenSingleProvider(lpAdminProviders, &lpProf);
    if (hResult)
    {
        DebugTrace ("AWFXAB32(ServiceEntry): Unable to open the profile.");
        goto out;
    }

#ifdef EXTENDED_DEBUG
    wsprintf (szTempBuf, TEXT("ServiceEntry: HrOpenSingleProvider succeeded. hResult=0x%08lx\n"), (ULONG) hResult);
    MessageBox( (HWND)ulUIParam,
                szTempBuf,
                TEXT("awfxab Debug Message"),
                MB_ICONINFORMATION
               );
#endif

    // No file name for now
    szFileName[0] = TEXT('\0');

    /*
     *      Now looking for the two properties I need:
     *      PR_FAB_FILE
     *      PR_FAB_UID
     *
     *      they can either be:
     *      1. in the lpProps passed to ServiceEntry
     *      2. in my profile section
     *      3. be requested from the user through a UI
     */

    // see if these properties exist on the profile
    hResult = lpProf->lpVtbl->GetProps( lpProf,
                                        (LPSPropTagArray)&tagaFABLogonProps,
                                        ulFlags & MAPI_UNICODE,
                                        &ulCount,
                                        &lpsPropVal
                                       );

    // If the GetProps fail, I'm dump some debug messages, but it's OK to continue.
    // Can still get the props from the ServiceEntry input parameter or from UI
    if (hResult!=hrSuccess)
    {
#ifdef DEBUG
        /*  The only expected return code is MAPI_E_NOT_FOUND. */
        if (GetScode (hResult) != MAPI_W_ERRORS_RETURNED)
        {
            DebugTrace("AWFXAB32(ServiceEntry): got unexpected hResult: ");
            DebugTraceResult(ProfileGetProps, hResult);
        }
        else if (lpsPropVal[0].Value.err != MAPI_E_NOT_FOUND)
        {
            DebugTrace("AWFXAB32(ServiceEntry): got unexpected scode: ");
            DebugTraceSc(ProfileGetProps, lpsPropVal[0].Value.err);
        }
#endif
        /*  Ignore errors/warnings from reading the property. */
        hResult = hrSuccess;
        // These two should be false anyway at this point
        fFABFound  = FALSE;
        fUIDFound = FALSE;
    }

    /************************
     ***  PR_FAB_FILE  ******
     ************************/

    /*
     *      1. Check the lpProps (cValues) passed to ServiceEntry
     */

    // First, look for the fab file property in the config props that were passed to
    // ServiceEntry. So I am not really looking at what I got in the above GetProps yet

    for (uliProp=0; uliProp < cValues; uliProp++)
    {
        if (PROP_ID(lpProps[uliProp].ulPropTag)==PROP_ID(PR_FAB_FILE_A))
            // This is the fab file property
            break;
    }

    // If the fab file property was found (must be found, isn't it ?) and it has a
    // non-error value, get the fab filename from it
    if ((uliProp < cValues) && (PROP_TYPE(lpProps[uliProp].ulPropTag)!=PT_ERROR))
    {
        ULONG cch = lstrlenA(lpProps[uliProp].Value.lpszA);

        if (cch >= MAX_PATH)
            cch = MAX_PATH-1;

        if (cch)
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, 0, lpProps[uliProp].Value.lpszA, -1, szFileName, ARRAYSIZE(szFileName) );
#else
            memcpy(szFileName, lpProps[uliProp].Value.LPSZ, (size_t)cch*SIZEOF(TCHAR));
#endif

        szFileName[cch] = TEXT('\0');

        // got my FAB file. Might be "". No need for UI for that
        fFABFound = TRUE;

    }

    /*
     *      2. Now the properties I got from the profile (if any)
     */

    // no fab file name in the input properties. Look in the profile properties
    else if ( (PROP_ID(lpsPropVal[0].ulPropTag)  == PROP_ID(PR_FAB_FILE_A)) &&
              (PROP_TYPE(lpsPropVal[0].ulPropTag)!= PT_ERROR)
             )
    {
        ULONG cch = lstrlenA(lpsPropVal[0].Value.lpszA);

        if (cch >= MAX_PATH)
            cch = MAX_PATH-1;

        if (cch)
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, 0, lpProps[0].Value.lpszA, -1, szFileName, ARRAYSIZE(szFileName) );
#else
            memcpy(szFileName, lpsPropVal[0].Value.LPSZ, (size_t)cch*SIZEOF(TCHAR));
#endif

        szFileName[cch] = TEXT('\0');
        fFABFound = TRUE;
    }
    else
    {
        fFABFound = FALSE;
    }

    /*
     *  3. Last resort: UI
     */
    if (fExposeFaxAB)
    {
        if (!fFABFound || (ulFlags & UI_SERVICE))
        {
            openfilename.lStructSize       = SIZEOF(OPENFILENAME);
            openfilename.hwndOwner         = (HWND) ulUIParam;
            openfilename.hInstance         = 0; /* Ignored */
            openfilename.lpstrFilter       = TEXT("Microsoft Fax Address Book files\0*.fab\0\0");
            openfilename.lpstrCustomFilter = NULL;
            openfilename.nMaxCustFilter    = 0;
            openfilename.nFilterIndex      = 0;
            openfilename.lpstrFile         = szFileName;
            openfilename.nMaxFile          = MAX_PATH;
            openfilename.lpstrFileTitle    = NULL;
            openfilename.nMaxFileTitle     = 0;
            openfilename.lpstrInitialDir   = NULL;
            openfilename.lpstrTitle        = TEXT("Pick a Microsoft Fax Address Book file");
            openfilename.Flags             = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR | OFN_HIDEREADONLY;
            openfilename.nFileOffset       = 0;
            openfilename.nFileExtension    = 0;
            openfilename.lpstrDefExt       = TEXT("fab");
            openfilename.lCustData         = 0;
            openfilename.lpfnHook          = NULL;
            openfilename.lpTemplateName    = NULL;


            // This hides the fax address book. define FAXAB_YES to expose it.
            // No Fax address book, unless it's hardcoded into the profile
            /*
             *  Call up the common dialog
             */

            if (!GetOpenFileName (&openfilename))
            {
                // user pressed cancel
                // CHECK: This means we do not have a fab file. Shouldn't I return
                // some kind of an error ? The SAB doesn't.
                goto out;
            }
        }
    }

    /*
     *  Set the file name property
     */

    sProp[ivallogonPR_FAB_FILE].ulPropTag  = PR_FAB_FILE_A;
#ifdef UNICODE
    WideCharToMultiByte( CP_ACP, 0, szFileName, -1, szAnsiFileName, ARRAYSIZE(szAnsiFileName), NULL, NULL );
    sProp[ivallogonPR_FAB_FILE].Value.lpszA = szAnsiFileName;
#else
    sProp[ivallogonPR_FAB_FILE].Value.lpszA = szFileName;
#endif

    /*  if no properties were found then we're configuring for the
     *  first time and so we have to generate a new muid for the
     *  PR_FAB_ID property
     */

    /************************
     ***  PR_FAB_UID  ******
     ************************/

    /*
     *      1. Check the lpProps (cValues) passed to ServiceEntry
     */

    for (uliProp=0; uliProp < cValues; uliProp++)
    {
      if (PROP_ID(lpProps[uliProp].ulPropTag)==PROP_ID(PR_FAB_UID))
          break;

    }

    if ( (uliProp < cValues) && (PROP_TYPE(lpProps[uliProp].ulPropTag)!=PT_ERROR))
    {
        memcpy(&muid,lpProps[uliProp].Value.bin.lpb,SIZEOF(MAPIUID));
        fUIDFound = TRUE;
    }

    /*
     *      2. Now the properties I got from the profile (if any)
     */

    else if ( (PROP_ID(lpsPropVal[1].ulPropTag)   == PROP_ID(PR_FAB_UID)) &&
              (PROP_TYPE(lpsPropVal[1].ulPropTag) != PT_ERROR)
             )
    {
        memcpy(&muid,lpsPropVal[1].Value.bin.lpb,SIZEOF(MAPIUID));
        fUIDFound = TRUE;
    }
    else
    {
        /* need to generate a uid */
        fUIDFound = FALSE;
    }

    /*  Discard GetProps() return data, if any. */
    if (lpsPropVal)
        lpFreeBuff (lpsPropVal);


    /*
     *      3. Last resort: generate a UID
     */

    if (!fUIDFound)
    {
        hResult = lpMAPISup->lpVtbl->NewUID(lpMAPISup,&muid);
        if (HR_FAILED(hResult))
        {
            /*
             *  Can't get a uid so just leave
             */
            goto out;
        }
    }

    /*
     *  Set the id property
     */

    sProp[ivallogonPR_FAB_UID].ulPropTag = PR_FAB_UID;
    sProp[ivallogonPR_FAB_UID].Value.bin.cb = SIZEOF(MAPIUID);
    sProp[ivallogonPR_FAB_UID].Value.bin.lpb = (LPBYTE) &muid;

    /*
     *  Save the file name and the id back into the profile
     */

    hResult=lpProf->lpVtbl->SetProps( lpProf,
                                      cvallogonMax,
                                      sProp,
                                      NULL
                                     );

    if (HR_FAILED(hResult))
    {
        /*
         *  Do nothing...  So I couldn't save it away this time...
         */
        DebugTrace("AWFXAB32(ServiceEntry): could not SetProps in profile\n");
        hResult = hrSuccess;
    }


out:

    if (lpProf)
        lpProf->lpVtbl->Release(lpProf);

    DebugTraceResult(ServiceEntry, hResult);
    return hResult;
}

/*************************************************************************
 -  HrOpenSingleProvider
 -
 *  Opens the profile section associated with this provider.
 *
 *  If the ServiceEntry() function exported from a provider had
 *  more than 1 section associated with it, this is where you'd get the chance
 *  to get all of them.
 */

static SizedSPropTagArray(1, tagaProviderTable) =
{
    1,
    {
        PR_PROVIDER_UID
    }
};

HRESULT
HrOpenSingleProvider( LPPROVIDERADMIN lpAdminProviders,
                      LPPROFSECT FAR * lppProfSect
                     )
{
    HRESULT hResult;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet lpRows = NULL;
    LPSPropValue lpProp;

    hResult = lpAdminProviders->lpVtbl->GetProviderTable( lpAdminProviders,
                                                          0,
                                                          &lpTable
                                                         );
    if (HR_FAILED(hResult))
        goto out;

    hResult = lpTable->lpVtbl->SetColumns(lpTable, (LPSPropTagArray) &tagaProviderTable, 0);
    if (HR_FAILED(hResult))
        goto out;

    hResult = lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpRows);
    if (HR_FAILED(hResult))
        goto out;

    if (lpRows->cRows == 0)
    {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto out;
    }

    lpProp = lpRows->aRow[0].lpProps;

    hResult = lpAdminProviders->lpVtbl->OpenProfileSection(
                      lpAdminProviders,
                      (LPMAPIUID) lpProp->Value.bin.lpb,
                      NULL,
                      MAPI_MODIFY,
                      lppProfSect);

out:
    FreeProws(lpRows);

    if (lpTable)
        lpTable->lpVtbl->Release(lpTable);

    DebugTraceResult(HrOpenSingleProvider, hResult);
    return hResult;
}



/*
 -  ScLoadString
 -
 *  Loads a string from a resource.  It will optionally allocate the string if
 *  a allocation function is passed in.  Otherwise it assumes that the *lppsz
 *  is already allocated.
 */

SCODE ScLoadString( UINT                ids,
                    ULONG               ulcch,
                    LPALLOCATEBUFFER    lpAllocBuff,
                    HINSTANCE           hLibrary,
                    LPTSTR *            lppsz
                   )
{
    SCODE sc = S_OK;
    int iRet;

    /*
     *  Assert parameters
     */
    Assert((lpAllocBuff ? !IsBadCodePtr((FARPROC) lpAllocBuff):TRUE));
    Assert(ids!=0);

    if (lpAllocBuff)
    {
        sc = lpAllocBuff(ulcch*SIZEOF(TCHAR), lppsz);
        if (FAILED(sc))
        {
            goto out;
        }
    }
#ifdef DEBUG
    else
    {
        Assert(!IsBadWritePtr(*lppsz, (UINT) ulcch*SIZEOF(TCHAR)));
    }
#endif /* DEBUG */

    iRet = LoadString( hLibrary,
                       ids,
                       *lppsz,
                       (UINT)ulcch
                      );

    if (!iRet)
    {
        DebugTrace("AWFXAB32(ScLoadString): LoadString() failed...\n");
        sc = E_FAIL;
        goto out;
    }
out:

    DebugTraceSc(ScLoadString, sc);
    return sc;
}

/*************************************************************************
 *
 -  LoadIniParams
 -
 *  Loads any paramters I need from the registry
 *
 */
void LoadIniParams(void)
{

    //fExposeFaxAB = TRUE;
#if 0
    fExposeFaxAB = GetInitializerInt( HKEY_CURRENT_USER,
                                      TEXT("Address Book Provider"),
                                      TEXT("ExposeFaxAB"),
                                      FALSE,
                                      TEXT("Software\\Microsoft\\At Work Fax")
                                     );

    fDebugTrap = GetInitializerInt(   HKEY_CURRENT_USER,
                                      TEXT("Address Book Provider"),
                                      TEXT("DebugTrap"),
                                      FALSE,
                                      TEXT("Software\\Microsoft\\At Work Fax")
                                     );
#endif
}

#undef _FAXAB_ABP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abeid.h ===
/***********************************************************************
 *
 *  _ENTRYID.H
 *
 *  Header file describing internal structure of EntryIDs returned
 *  by this provider.
 *
 *  Defines structure of records in .FAB files.
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/


/*
 *  Defines of various entryid types
 */
#define MAWF_DIRECTORY  0x00000000
#define MAWF_USER               0x00000001
#define MAWF_UNKNOWN    0x00000002
#define MAWF_ONEOFF             0x00000003

/*
 *  The version of this ABPs entryids
 */
#define MAWF_VERSION    0x000000001

/*
 *  The FAX Address Book Provider MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
/***** the Fax AB uid is in ..\..\h\entryid.h ******/

/*
 *  Directory entry id structure
 *
 *  This entryid is permanent.
 */
typedef struct _dir_entryid
{

        BYTE abFlags[4];
        MAPIUID muid;
        ULONG ulVersion;
        ULONG ulType;
        MAPIUID muidID;

} DIR_ENTRYID, *LPDIR_ENTRYID;

#define CBDIR_ENTRYID sizeof(DIR_ENTRYID)

/*
 *  Browse record
 *
 *  The .FAB files are made up of the following records.
 */

#define DISPLAY_NAME_SIZE               30              // Size of display name field in record
#define FAX_NUMBER_SIZE                 50              // Size of Fax number field in record
#define COUNTRY_ID_SIZE                 5               // Size of Fax machine field in record

#pragma pack(4)
typedef struct _ABCREC
{

        TCHAR rgchDisplayName[DISPLAY_NAME_SIZE + 1];
        TCHAR rgchEmailAddress[FAX_NUMBER_SIZE + 1];
        TCHAR rgchCountryID[COUNTRY_ID_SIZE + 1];

} ABCREC, *LPABCREC;
#pragma pack()

#define CBABCREC  sizeof(ABCREC)

/*
 *  Mail user entry id structure
 *
 *  This entryid is permanent.
 */
#pragma pack(4)
typedef struct _usr_entryid
{

        BYTE abFlags[4];
        MAPIUID muid;
        ULONG ulVersion;
        ULONG ulType;
        ABCREC abcrec;

} USR_ENTRYID, *LPUSR_ENTRYID;
#pragma pack()

#define CBUSR_ENTRYID sizeof(USR_ENTRYID)


/*
 *  One-Off entry ID
 */
/* #pragma pack(4)
typedef struct _ONEOFFREC
{

        char displayName[DISPLAY_NAME_SIZE + 1];
        char emailAddress[FAX_NUMBER_SIZE + 1];
        char rgchCountryID[COUNTRY_ID_SIZE + 1];

} ONEOFFREC, *LPONEOFFREC;
*/
#pragma pack()

#define CBONEOFFREC  sizeof(ONEOFFREC)

/*
 *  One-Off entry ID  structure
 *
 *  This entryid is permanent.
 */
#pragma pack(4)
typedef struct _oneoff_entryid
{

        BYTE abFlags[4];
        MAPIUID muid;
        ULONG ulVersion;
        ULONG ulType;
//      ONEOFFREC oneOffRec;

} OOUSER_ENTRYID, *LPOOUSER_ENTRYID;
#pragma pack()

#define CBOOUSER_ENTRYID sizeof(OOUSER_ENTRYID)

/*
 *  Template ID entry ID  structure
 *
 *  This entryid is permanent.
 */
#pragma pack(4)
typedef struct _tid_entryid
{

        BYTE abFlags[4];
        MAPIUID muid;
        ULONG ulVersion;
        ULONG ulType;

} TEMPLATEID_ENTRYID, *LPTEMPLATEID_ENTRYID;
#pragma pack()

#define CBTEMPLATEID_ENTRYID sizeof(TEMPLATEID_ENTRYID)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\absearch.c ===
/***********************************************************************
 *
 *  ABSEARCH.C
 *
 *  Sample AB directory container Search object
 *
 *  This file contains the code for implementing the Sample AB
 *  directory container search object.  Also known as advanced
 *  search.
 *
 *  This search object was retrieved by OpenProperty on PR_SEARCH on the
 *  AB directory found in ABCONT.C.
 *
 *  The following routines are implemented in this file:
 *
 *      HrNewSearch
 *      ABSRCH_Release
 *      ABSRCH_SaveChanges
 *      ABSRCH_OpenProperty
 *      ABSRCH_GetSearchCriteria
 *
 *      HrGetSearchDialog
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

#include "faxab.h"

/*
 *  Proptags used only in this module
 */
#define PR_ANR_STRING_A PROP_TAG(PT_STRING8,0x6602)


/* Display table control structures for the Search property sheet. */

/*
 *  The Sample AB exposes an 'advanced' search dialog.  The following
 *  structures define it's layout.
 */

/*
 *  The edit control that will have the name to be search for on it.
 */
#define MAX_SEARCH_NAME                 50

DTBLEDIT editSearchName =
{
    SIZEOF(DTBLEDIT),
    0,
    MAX_SEARCH_NAME,
    PR_ANR_STRING_A
};

/*
 *  Display table pages for Search property sheet
 */
DTCTL rgdtctlSearchGeneral[] =
{

    /*
     *  Defines the name of this Pane.
     */
    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &dtblpage},

    /* group box control */
    {DTCT_GROUPBOX, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtblgroupbox},

    /* control and edit control */
    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel},
    {DTCT_EDIT, DT_EDITABLE, NULL, 0, (LPTSTR)szNoFilter, IDC_SEARCH_NAME, &editSearchName},
};

/*
 *  Actual definition of the set of pages that make up this advanced search
 *  dialog.
 */
DTPAGE rgdtpageSearch[] =
{
    {
        ARRAYSIZE(rgdtctlSearchGeneral),
        (LPTSTR) MAKEINTRESOURCE(SearchGeneralPage),
        TEXT(""),
        rgdtctlSearchGeneral
    }
};

/*
 *  ABSearch vtbl is filled in here.
 */
ABSRCH_Vtbl vtblABSRCH =
{
    (ABSRCH_QueryInterface_METHOD *)        ROOT_QueryInterface,
    (ABSRCH_AddRef_METHOD *)                ROOT_AddRef,
    ABSRCH_Release,
    (ABSRCH_GetLastError_METHOD *)          ROOT_GetLastError,
    ABSRCH_SaveChanges,
    (ABSRCH_GetProps_METHOD *)              WRAP_GetProps,
    (ABSRCH_GetPropList_METHOD *)           WRAP_GetPropList,
    ABSRCH_OpenProperty,
    (ABSRCH_SetProps_METHOD *)              WRAP_SetProps,
    (ABSRCH_DeleteProps_METHOD *)           WRAP_DeleteProps,
    (ABSRCH_CopyTo_METHOD *)                WRAP_CopyTo,
    (ABSRCH_CopyProps_METHOD *)             WRAP_CopyProps,
    (ABSRCH_GetNamesFromIDs_METHOD *)       WRAP_GetNamesFromIDs,
    (ABSRCH_GetIDsFromNames_METHOD *)       WRAP_GetIDsFromNames,
    (ABSRCH_GetContentsTable_METHOD *)      ROOT_GetContentsTable,
    (ABSRCH_GetHierarchyTable_METHOD *)     ABC_GetHierarchyTable,
    (ABSRCH_OpenEntry_METHOD *)             ROOT_OpenEntry,
    (ABSRCH_SetSearchCriteria_METHOD *)     ROOT_SetSearchCriteria,
    ABSRCH_GetSearchCriteria,
};



HRESULT HrGetSearchDialog(LPABSRCH lpABSearch, LPMAPITABLE * lppSearchTable);

/*
 -  HrNewSearch
 -
 *  Creates an advanced search object
 *
 *
 */


/*
 *  Properties that are initially set on this object
 */
enum {  ivalabsrchPR_ANR_STRING = 0,
        cvalabsrchMax };

HRESULT
HrNewSearch( LPMAPICONTAINER *   lppABSearch,
             LPABLOGON           lpABLogon,
             LPCIID              lpInterface,
             HINSTANCE           hLibrary,
             LPALLOCATEBUFFER    lpAllocBuff,
             LPALLOCATEMORE      lpAllocMore,
             LPFREEBUFFER        lpFreeBuff,
             LPMALLOC            lpMalloc
            )
{
    HRESULT hResult = hrSuccess;
    LPABSRCH lpABSearch = NULL;
    SCODE sc;
    LPPROPDATA lpPropData = NULL;
    SPropValue spv[cvalabsrchMax];

    /*  Do I support this interface?? */
    if (lpInterface)
    {
        if ( memcmp(lpInterface, &IID_IMAPIContainer, SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IMAPIProp,      SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IUnknown,       SIZEOF(IID))
           )
        {
            DebugTraceSc(HrNewSearch, MAPI_E_INTERFACE_NOT_SUPPORTED);
            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        }
    }

    /*
     *  Allocate space for the directory container structure
     */

    sc = lpAllocBuff( SIZEOF(ABSRCH), (LPVOID *) &lpABSearch );

    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto err;
    }

    lpABSearch->lpVtbl = &vtblABSRCH;
    lpABSearch->lcInit = 1;
    lpABSearch->hResult = hrSuccess;
    lpABSearch->idsLastError = 0;

    lpABSearch->hLibrary = hLibrary;
    lpABSearch->lpAllocBuff = lpAllocBuff;
    lpABSearch->lpAllocMore = lpAllocMore;
    lpABSearch->lpFreeBuff = lpFreeBuff;
    lpABSearch->lpMalloc = lpMalloc;

    lpABSearch->lpABLogon = lpABLogon;
    lpABSearch->lpRestrictData = NULL;

    /*
     *  Create property storage object
     */

    sc = CreateIProp((LPIID) &IID_IMAPIPropData,
                 lpAllocBuff,
                 lpAllocMore,
                 lpFreeBuff,
                 lpMalloc,
                 &lpPropData);

    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto err;
    }

    spv[ivalabsrchPR_ANR_STRING].ulPropTag   = PR_ANR_STRING_A;
    spv[ivalabsrchPR_ANR_STRING].Value.lpszA = "";

    /*
     *   Set the default properties
     */
    hResult = lpPropData->lpVtbl->SetProps(lpPropData,
                      cvalabsrchMax,
                      spv,
                      NULL);

    InitializeCriticalSection(&lpABSearch->cs);

    lpABSearch->lpPropData = (LPMAPIPROP) lpPropData;
    *lppABSearch = (LPMAPICONTAINER) lpABSearch;

out:

    DebugTraceResult(HrNewSearch, hResult);
    return hResult;

err:
    /*
     *  free the ABContainer object
     */
    lpFreeBuff( lpABSearch );

    /*
     *  free the property storage object
     */
    if (lpPropData)
        lpPropData->lpVtbl->Release(lpPropData);

    goto out;
}


/*
 -  ABSRCH_Release
 -
 *  Decrement lcInit.
 *      When lcInit == 0, free up the lpABSearch structure
 *
 */

STDMETHODIMP_(ULONG)
ABSRCH_Release(LPABSRCH lpABSearch)
{

    long lcInit;

    /*
     *  Check to see if it has a jump table
     */
    if (IsBadReadPtr(lpABSearch, SIZEOF(ABSRCH)))
    {
        /*
         *  No jump table found
         */
        return 1;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABSearch->lpVtbl != &vtblABSRCH)
    {
        /*
         *  Not my jump table
         */
        return 1;
    }

    EnterCriticalSection(&lpABSearch->cs);
    lcInit = --lpABSearch->lcInit;
    LeaveCriticalSection(&lpABSearch->cs);

    if (lcInit == 0)
    {

        /*
         *  Get rid of the lpPropData
         */
        if (lpABSearch->lpPropData)
            lpABSearch->lpPropData->lpVtbl->Release(lpABSearch->lpPropData);

        /*
         *  Free up the restriction data
         */
        lpABSearch->lpFreeBuff(lpABSearch->lpRestrictData);

        /*
         *  Destroy the critical section for this object
         */

        DeleteCriticalSection(&lpABSearch->cs);

        /*
         *  Set the Jump table to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */
        lpABSearch->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpABSearch->lpFreeBuff(lpABSearch);
        return 0;
    }

    return lpABSearch->lcInit;

}


/*
 -  ABSRCH_SaveChanges
 -
 *  This is used to save changes associated with the search dialog
 *  in order to get the advanced search restriction and to save changes
 *  associated with the container details dialog.
 *
 */
SPropTagArray tagaANR_INT =
{
    1,
    {
        PR_ANR_STRING_A
    }
};

STDMETHODIMP
ABSRCH_SaveChanges(LPABSRCH lpABSearch, ULONG ulFlags)
{
    HRESULT hResult;
    ULONG ulCount;
    LPSPropValue lpspv = NULL;
    LPPROPDATA lpPropData = (LPPROPDATA) lpABSearch->lpPropData;

    /*
     *  Check to see if it has a jump table
     */
    if (IsBadReadPtr(lpABSearch, SIZEOF(ABSRCH)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);
        return hResult;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABSearch->lpVtbl != &vtblABSRCH)
    {
        /*
         *  Not my jump table
         */
        hResult = ResultFromScode(E_INVALIDARG);
        return hResult;
    }


    EnterCriticalSection(&lpABSearch->cs);

    /*
     *  Is there a PR_ANR_STRING??
     */
    hResult = lpPropData->lpVtbl->GetProps(lpPropData,
        &tagaANR_INT,
        0,      /* ansi */
        &ulCount,
        &lpspv);
    if (HR_FAILED(hResult))
    {
        goto ret;
    }

    if ((lpspv->ulPropTag == PR_ANR_STRING_A) && (lpspv->Value.lpszA != '\0'))
    {
        /*
         * save away the information to build up the new restriction
         */

        /*  Free any existing data */
        if (lpABSearch->lpRestrictData)
        {
            lpABSearch->lpFreeBuff(lpABSearch->lpRestrictData);
        }

        lpABSearch->lpRestrictData = lpspv;
        lpspv = NULL;
    }

ret:

    LeaveCriticalSection(&lpABSearch->cs);

    lpABSearch->lpFreeBuff(lpspv);
    DebugTraceResult(ABSRCH_SaveChanges, hResult);
    return hResult;
}

/*************************************************************************
 *
 -  ABSRCH_OpenProperty
 -
 *
 *  This method allows the opening of the following object:
 *
 *  PR_DETAILS_TABLE        :-  Gets the display table associated with
 *                              the advanced search dialog.
 */
STDMETHODIMP
ABSRCH_OpenProperty( LPABSRCH lpABSearch,
                     ULONG ulPropTag,
                     LPCIID lpiid,
                     ULONG ulInterfaceOptions,
                     ULONG ulFlags,
                     LPUNKNOWN * lppUnk
                    )
{
    HRESULT hResult;

    /*
     *  Check to see if it's big enough to be this object
     */
    if (IsBadReadPtr(lpABSearch, SIZEOF(ABSRCH)))
    {
        /*
         *  Not big enough to be this object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpABSearch->lpVtbl != &vtblABSRCH)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }


    if (IsBadWritePtr(lppUnk, SIZEOF(LPUNKNOWN)))
    {
        /*
         *  Got to be able to return an object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        /*
         *  An interface ID is required for this call.
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  check for unknown flags
     */
    if (ulFlags & ~(MAPI_DEFERRED_ERRORS | MAPI_CREATE | MAPI_MODIFY))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    /*
     *  Check for flags we can't support
     */

    if (ulFlags & (MAPI_CREATE|MAPI_MODIFY))
    {
        hResult = ResultFromScode(E_ACCESSDENIED);
        goto out;
    }

    if (ulInterfaceOptions & ~MAPI_UNICODE)
    {
        /*
         *  Only UNICODE flag should be set for any of the objects that might
         *  be returned from this object.
         */

        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
            hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
            DebugTraceArg( ABSRCH_OpenProperty, "bad character width" );
            goto out;
    }

    /*
     *  Details for this Search object
     */

    if (ulPropTag == PR_DETAILS_TABLE)
    {
        if (!memcmp(lpiid, &IID_IMAPITable, SIZEOF(IID)))
        {
            hResult = HrGetSearchDialog(lpABSearch, (LPMAPITABLE *) lppUnk);

            goto out;
        }

    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:

    DebugTraceResult(ABSRCH_OpenProperty, hResult);
    return hResult;


}

/*
 -  ABSRCH_GetSearchCriteria
 -
 *  Generates the restriction associated with the data from
 *  the advanced search dialog.  This restriction is subsequently
 *  applied to the contents table retrieved from this container.
 */
STDMETHODIMP
ABSRCH_GetSearchCriteria( LPABSRCH lpABSearch,
                          ULONG   ulFlags,
                          LPSRestriction FAR * lppRestriction,
                          LPENTRYLIST FAR * lppContainerList,
                          ULONG FAR * lpulSearchState
                         )
{
    HRESULT hResult = hrSuccess;
    SCODE sc;
    LPSRestriction lpRestriction = NULL;
    LPSPropValue lpPropANR = NULL;
    LPSTR  lpszPartNameA;
    LPSTR  lpszRestrNameA;

    /*
     *  Check to see if it's large enough to be my object
     */
    if (IsBadReadPtr(lpABSearch, SIZEOF(ABSRCH)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpABSearch->lpVtbl != &vtblABSRCH)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }

    /*
     *  Check out parameters
     */

    if ( ulFlags & ~(MAPI_UNICODE) )
    {
        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS );

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }

    if ( ulFlags & MAPI_UNICODE )
    {
            DebugTraceArg( ABSRCH_GetSearchCriteria, "bad character width" );
            return ResultFromScode( MAPI_E_BAD_CHARWIDTH );
    }

    if (IsBadWritePtr(lppRestriction, SIZEOF(LPSRestriction)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }

    if (lpulSearchState && IsBadWritePtr(lpulSearchState, SIZEOF(ULONG)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }

    if (lppContainerList && IsBadWritePtr(lppContainerList, SIZEOF(LPENTRYLIST)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }


    if (!lpABSearch->lpRestrictData)
    {
        hResult = ResultFromScode(MAPI_E_NOT_INITIALIZED);

        if (lppRestriction)
            *lppRestriction = NULL;

        if (lppContainerList)
            *lppContainerList = NULL;

        if (lpulSearchState)
            *lpulSearchState = 0L;

        DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
        return hResult;
    }

    /*
     *  Entering state dependant section
     */
    EnterCriticalSection(&lpABSearch->cs);

    /*
     *  Ok, now build up a restriction using lpRestrictData (an LPSPropValue)
     */

    sc = lpABSearch->lpAllocBuff(SIZEOF(SRestriction), &lpRestriction);
    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto err;
    }

    sc = lpABSearch->lpAllocMore(SIZEOF(SPropValue), lpRestriction, &lpPropANR);
    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto err;

    }

    lpszRestrNameA = lpABSearch->lpRestrictData->Value.lpszA;

    sc = lpABSearch->lpAllocMore( lstrlenA(lpszRestrNameA)+1,
                                  lpRestriction,
                                  &lpszPartNameA
                                 );
    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto err;
    }

    lstrcpyA(lpszPartNameA, lpszRestrNameA);

    lpPropANR->ulPropTag = PR_ANR_A;
    lpPropANR->Value.lpszA = lpszPartNameA;

    lpRestriction->rt = RES_PROPERTY;
    lpRestriction->res.resProperty.relop = RELOP_EQ;
    lpRestriction->res.resProperty.ulPropTag = PR_ANR_A;
    lpRestriction->res.resProperty.lpProp = lpPropANR;

    *lppRestriction = lpRestriction;

    /*
     *  The returned SearchState is set to 0 because none
     *  of the defined states match what's going on.
     */
    if (lpulSearchState)
        *lpulSearchState = 0;

out:
    LeaveCriticalSection(&lpABSearch->cs);

    DebugTraceResult(ABSRCH_GetSearchCriteria, hResult);
    return hResult;

err:
    lpABSearch->lpFreeBuff(lpRestriction);

    goto out;
}

/*
 -  HrGetSearchDialog
 -
 *
 *  Builds a display table for the search dialog.
 */

HRESULT
HrGetSearchDialog(LPABSRCH lpABSearch, LPMAPITABLE * lppSearchTable)
{
    HRESULT hResult;

    /* Create a display table */
    hResult = BuildDisplayTable(
                      lpABSearch->lpAllocBuff,
                      lpABSearch->lpAllocMore,
                      lpABSearch->lpFreeBuff,
                      lpABSearch->lpMalloc,
                      lpABSearch->hLibrary,
                      ARRAYSIZE(rgdtpageSearch),
                      rgdtpageSearch,
                      0,
                      lppSearchTable,
                      NULL);

    DebugTraceResult(ABSRCH_GetSearchDialog, hResult);
    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abuser.h ===
/***********************************************************************
 *
 *  _ABUSER.H
 *
 *  Header file for code in ABUSER.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Function prototypes
 *
 *  Reuses methods:
 *		ROOT_QueryInterface
 *		ROOT_AddRef
 *		ROOT_GetLastError
 *		ROOT_Reserved
 */
	
#undef	INTERFACE
#define INTERFACE	struct _ABUSER

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ABU_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAILUSER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ABU_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAILUSER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABU_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IMAILUSER_METHODS(IMPL)
};

typedef struct _ABUSER
{
	ABU_Vtbl FAR * lpVtbl;

    FAB_Wrapped;

	/*
	 *	 Table used for country codes drop down list
	 */
	LPTABLEDATA	lpTDatDDListBox;


} ABUSER, *LPABUSER;

#define CBABUSER	sizeof(ABUSER)

/*
 *  Creates a new Mail User object  (see ABUSER.C)
 */
HRESULT
HrNewFaxUser(   LPMAILUSER *        lppMAPIPropEntry,
                ULONG *             lpulObjectType,
                ULONG               cbEntryID,
                LPENTRYID           lpEntryID,
                LPABLOGON           lpABPLogon,
                LPCIID              lpInterface,
                HINSTANCE           hLibrary,
                LPALLOCATEBUFFER    lpAllocBuff,
                LPALLOCATEMORE      lpAllocMore,
                LPFREEBUFFER        lpFreeBuff,
                LPMALLOC            lpMalloc );

HRESULT	HrBuildDDLBXCountriesTable(LPABUSER lpABUser);

// country list structure
#define COUNTRY_NAME_SIZE		50
typedef struct tagCOUNTRIESLIST           
{
	TCHAR	szDisplayName[COUNTRY_NAME_SIZE+1];
	DWORD	dwValue;
} COUNTRIESLIST, *LPCOUNTRIESLIST;


// Entry ID for the DD list box table
typedef struct _options_entryid
{
	BYTE 	abFlags[4];
	MAPIUID muid;
	ULONG 	ulVersion;
	ULONG 	ulType;
	ULONG 	ulRowNumber;
} OPTIONS_ENTRYID, *LPOPTIONS_ENTRYID;

#define CBOPTIONS_ENTRYID sizeof(OPTIONS_ENTRYID)


/*
 *
 *  Declaration of a button interface for various button controls
 *
 */


#undef	INTERFACE
#define	INTERFACE	struct _ABUBUTT

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,ABUBUTT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPICONTROL_METHODS(IMPL)

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_TYPEDEF(type,method,ABUBUTT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPICONTROL_METHODS(IMPL)

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(ABUBUTT_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPICONTROL_METHODS(IMPL)
};

typedef struct _ABUBUTT
{
	ABUBUTT_Vtbl FAR * lpVtbl;

	/*
	 *  Need to be the same as other objects
	 *  since this object reuses methods from
	 *  other objects.
	 */
								   
    FAB_IUnkWithLogon;

	/*  Private data */

	// The property tag associated with this button
	ULONG ulPropTag;


} ABUBUTT, *LPABUBUTT;

#define CBABUBUTT	sizeof(ABUBUTT)

/*
 * Create a button of the type above (ABUSER.C)
 */
HRESULT
HrNewABUserButton( LPMAPICONTROL * lppMAPICont,
            LPABLOGON           lpABLogon,
            HINSTANCE           hLibrary,
            LPALLOCATEBUFFER    lpAllocBuff,
            LPALLOCATEMORE      lpAllocMore,
            LPFREEBUFFER        lpFreeBuff,
            LPMALLOC            lpMalloc,
 			ULONG				ulPropTag);

#ifdef	__cplusplus
}		/* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abuser.c ===
/***********************************************************************
 *
 *  ABUSER.C
 *
 *      Microsoft At Work Fax AB Mail User object
 *      This file contains the code for implementing the Microsoft At Work Fax AB
 *      Mail user.
 *
 *  The mail user has a read-only interface.  Hence a few of the methods
 *  will always return MAPI_E_NO_ACCESS.  Certain aspects of this
 *  implementation are not implemented, such as retrieving the display
 *  table in order to build up a details screen in the UI.  For the most
 *  part, however, this interface has enough to retrieve enough properties
 *  to actually send mail.
 *
 *  An important thing that's not implemented in this version is the
 *  verification of the entryid to see if it's still valid.  In most
 *  mail systems, you would want to check to see if a particular recipient
 *  still exists before actually trying to send mail to that recipient.
 *
 *  The following routines are implemented in this file:
 *
 *
 *  HrHrNewFaxUser
 *  ABU_QueryInterface
 *  ABU_Release
 *  ABU_OpenProperty
 *  HrBuildListBoxTable
 *  HrBuildDDListboxTable
 *  HrBuildComboBoxTable
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *      1.1.94          MAPI                            Original source from MAPI sample AB Provider
 *      1.27.94         Yoram Yaacovi           Modifications to make it an At Work Fax ABP
 *      3.7.94          Yoram Yaacovi           Update to MAPI build 154
 *      8.3.94          Yoram Yaacovi           Update to MAPI build 304 and new Fax AB spec
 *      11.11.94        Yoram Yaacovi           Update to MAPI 318
 *
 ***********************************************************************/

#include "faxab.h"
#ifdef UNICODE
#include <wchar.h>
#else
#include <stdio.h>
#endif
#define _FAXAB_ABUSER


/*
 *  Private functions
 */

/*****************************
 ** Display Table structures *
 *****************************/

// Cover page name of the user
DTBLEDIT
editUserDisplayName =
{
    SIZEOF(DTBLEDIT),
    0,
    MAX_DISPLAY_NAME,
    PR_FAX_CP_NAME_A
};

// The area code component of the email address (fax number)
DTBLEDIT
editUserAreaCode =
{
    SIZEOF(DTBLEDIT),
    0,
    AREA_CODE_SIZE,
    PR_AREA_CODE_A
};

// The number component of the email address (fax number)
DTBLEDIT
editUserTelNumber =
{
    SIZEOF(DTBLEDIT),
    0,
    TELEPHONE_NUMBER_SIZE,
    PR_TEL_NUMBER_A
};

// The country codes list box
DTBLDDLBX
ddlbxCountryCodes =
{
    SIZEOF(DTBLDDLBX),
    PR_DISPLAY_NAME_A,
    PR_COUNTRY_ID,
    PR_DDLBX_COUNTRIES_TABLE
};

// Description the the Fax AB pane in MAPI dialog description language
static DTCTL rgdtctlUserGeneral[] =
{
    /* general property page */
    { DTCT_PAGE,    0, NULL, 0, NULL,       0, &dtblpage },

    /* cover page name static control and edit control */
    { DTCT_LABEL,   0, NULL, 0, NULL,       IDC_RECIP_DISPLAY_NAME_LABEL, &dtbllabel },
    { DTCT_EDIT,    0, NULL, 0, (LPTSTR)szNoFilter, IDC_RECIP_DISPLAY_NAME, &editUserDisplayName },

    /* Country codes label and drop down list box */
    { DTCT_LABEL,   0, NULL, 0, NULL,       IDC_RECIP_COUNTRY_CODE_LABEL, &dtbllabel },
    { DTCT_DDLBX,   0, NULL, 0, NULL,       IDC_RECIP_COUNTRY_CODE, &ddlbxCountryCodes },

    /* Area code and fax number label */
    { DTCT_LABEL,   0, NULL, 0, NULL,       IDC_RECIP_FAX_NUMBER_LABEL,     &dtbllabel },

    /* area code edit control */
    { DTCT_EDIT,    0, NULL, 0, (LPTSTR)szDigitsOnlyFilter, IDC_RECIP_FAX_NUMBER_AREA_CODE, &editUserAreaCode },

    /* Fax number static control and edit control */
    { DTCT_LABEL,   0, NULL, 0, NULL,               IDC_RECIP_FAX_NUMBER_LABEL2, &dtbllabel },
    { DTCT_EDIT,    0, NULL, 0, (LPTSTR)szDigitsOnlyFilter, IDC_RECIP_FAX_NUMBER, &editUserTelNumber}
};

#if defined (RECIP_OPTIONS)

// User options property page. currently not implemented
DTCTL rgdtctlUserOptions[] =
{
    /* options property page */
    { DTCT_PAGE,  0, NULL, 0, NULL, 0, &dtblpage },

    /* static control and listbox */
    { DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, &dtbllabel },
};

#endif

/* Display table pages */
/* shared with oouser.c */

static DTPAGE rgdtpageUser[] =
{
    {
        ARRAYSIZE(rgdtctlUserGeneral),
        (LPTSTR)MAKEINTRESOURCE(MAWFRecipient),
        TEXT(""),
        rgdtctlUserGeneral
    },

#if defined (RECIP_OPTIONS)

    {
        ARRAYSIZE(rgdtctlUserOptions),
        (LPTSTR)MAKEINTRESOURCE(UserOptionsPage),
        TEXT(""),
        rgdtctlUserOptions
    }

#endif
};

WORD sizeof_rgdtpageUser = SIZEOF(rgdtpageUser);


/*
 *  ABUser jump table is defined here...
 */

ABU_Vtbl vtblABU =
{

     ABU_QueryInterface,
    (ABU_AddRef_METHOD *)           ROOT_AddRef,
     ABU_Release,
    (ABU_GetLastError_METHOD *)     ROOT_GetLastError,
    (ABU_SaveChanges_METHOD *)      WRAP_SaveChanges,
    (ABU_GetProps_METHOD *)         WRAP_GetProps,
    (ABU_GetPropList_METHOD *)      WRAP_GetPropList,
     ABU_OpenProperty,
    (ABU_SetProps_METHOD *)         WRAP_SetProps,
    (ABU_DeleteProps_METHOD *)      WRAP_DeleteProps,
    (ABU_CopyTo_METHOD *)           WRAP_CopyTo,
    (ABU_CopyProps_METHOD *)        WRAP_CopyProps,
    (ABU_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs,
    (ABU_GetIDsFromNames_METHOD *)  WRAP_GetIDsFromNames,
};

enum {  ivalusrPR_DISPLAY_TYPE = 0,
        ivalusrPR_OBJECT_TYPE,
        ivalusrPR_ENTRYID,
        ivalusrPR_RECORD_KEY,
        ivalusrPR_DISPLAY_NAME,
        ivalusrPR_TRANSMITABLE_DISPLAY_NAME,
        ivalusrPR_FAX_CP_NAME,
        ivalusrPR_EMAIL_ADDRESS,
        ivalusrPR_ADDRTYPE,
        ivalusrPR_SEARCH_KEY,
        ivalusrPR_AREA_CODE,
        ivalusrPR_TEL_NUMBER,
        ivalusrPR_COUNTRY_ID,
        ivalusrPR_TEMPLATEID,
        cvalusrMax };




/*************************************************************************
 *
 -  HrNewFaxUser
 -
 *  Creates the IMAPIProp associated with a mail user.
 *
 *
 */
HRESULT
HrNewFaxUser(  LPMAILUSER *        lppMAPIPropEntry,
               ULONG *             lpulObjType,
               ULONG               cbEntryID,
               LPENTRYID           lpEntryID,
               LPABLOGON           lpABPLogon,
               LPCIID              lpInterface,
               HINSTANCE           hLibrary,
               LPALLOCATEBUFFER    lpAllocBuff,
               LPALLOCATEMORE      lpAllocMore,
               LPFREEBUFFER        lpFreeBuff,
               LPMALLOC            lpMalloc )
{
    LPABUSER lpABUser = NULL;
    SCODE sc;
    HRESULT hr = hrSuccess;
    LPPROPDATA lpPropData = NULL;
    SPropValue spv[cvalusrMax];
    ULONG cbT = 0;
    LPBYTE lpbT = NULL;
    LPSTR lpszEMA = NULL;
    PARSEDTELNUMBER sParsedFaxAddr;
    DWORD dwCountryID;
#ifdef UNICODE
    CHAR szAnsiDisplayName[ MAX_PATH ];
    CHAR szAnsiEmailAddress[ MAX_PATH ];
    CHAR szAnsiTelNumber[ 50 ];
    CHAR szAnsiAreaCode[ 5 ];
    CHAR szAnsiEMT[ 25 ];
#endif


    /*  Do I support this interface?? */
    if (lpInterface)
    {
        if ( memcmp(lpInterface, &IID_IMailUser, SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IMAPIProp, SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IUnknown,  SIZEOF(IID))
            )
        {
            DebugTraceSc(HrNewSampUser, MAPI_E_INTERFACE_NOT_SUPPORTED);
            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        }
    }
    /*
     *  Allocate space for the ABUSER structure
     */
    sc = lpAllocBuff( SIZEOF(ABUSER), (LPVOID *) & lpABUser);

    if (FAILED(sc))
    {
        hr = ResultFromScode (sc);
        goto err;
    }

    lpABUser->lpVtbl = &vtblABU;
    lpABUser->lcInit = 1;
    lpABUser->hResult = hrSuccess;
    lpABUser->idsLastError = 0;

    lpABUser->hLibrary = hLibrary;
    lpABUser->lpAllocBuff = lpAllocBuff;
    lpABUser->lpAllocMore = lpAllocMore;
    lpABUser->lpFreeBuff = lpFreeBuff;
    lpABUser->lpMalloc = lpMalloc;

    lpABUser->lpABLogon = lpABPLogon;
    lpABUser->lpTDatDDListBox = NULL;

    /*
     *  Create lpPropData
     */

    sc = CreateIProp( (LPIID) &IID_IMAPIPropData,
                      lpAllocBuff,
                      lpAllocMore,
                      lpFreeBuff,
                      lpMalloc,
                      &lpPropData
                     );

    if (FAILED(sc))
    {
            hr = ResultFromScode (sc);
            goto err;
    }

    /*
     *  Set up initial set of properties associated with this
     *  container.
     */

    /*
     *  Easy ones first
     */

    spv[ivalusrPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    spv[ivalusrPR_DISPLAY_TYPE].Value.l   = DT_MAILUSER;

    spv[ivalusrPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    spv[ivalusrPR_OBJECT_TYPE].Value.l   = MAPI_MAILUSER;

    spv[ivalusrPR_ENTRYID].ulPropTag     = PR_ENTRYID;
    spv[ivalusrPR_ENTRYID].Value.bin.cb  = SIZEOF(USR_ENTRYID);
    spv[ivalusrPR_ENTRYID].Value.bin.lpb = (LPBYTE) lpEntryID;

    /*
     *  Now the calculated props
     */

    spv[ivalusrPR_RECORD_KEY].ulPropTag     = PR_RECORD_KEY;
    spv[ivalusrPR_RECORD_KEY].Value.bin.cb  = SIZEOF(USR_ENTRYID);
    spv[ivalusrPR_RECORD_KEY].Value.bin.lpb = (LPBYTE) lpEntryID;

    spv[ivalusrPR_DISPLAY_NAME].ulPropTag   = PR_DISPLAY_NAME_A;
#ifdef UNICODE
    szAnsiDisplayName[0] = 0;
    WideCharToMultiByte( CP_ACP, 0,
                         ((LPUSR_ENTRYID) lpEntryID)->abcrec.rgchDisplayName, -1,
                         szAnsiDisplayName, ARRAYSIZE(szAnsiDisplayName),
                         NULL, NULL
                        );
    spv[ivalusrPR_DISPLAY_NAME].Value.lpszA = szAnsiDisplayName;
#else
    spv[ivalusrPR_DISPLAY_NAME].Value.lpszA = ((LPUSR_ENTRYID) lpEntryID)->abcrec.rgchDisplayName;
#endif

    /* Should always be the same as PR_DISPLAY_NAME */
    spv[ivalusrPR_TRANSMITABLE_DISPLAY_NAME].ulPropTag   = PR_TRANSMITABLE_DISPLAY_NAME_A;
#ifdef UNICODE
    spv[ivalusrPR_TRANSMITABLE_DISPLAY_NAME].Value.lpszA = szAnsiDisplayName;
#else
    spv[ivalusrPR_TRANSMITABLE_DISPLAY_NAME].Value.LPSZ  = ((LPUSR_ENTRYID) lpEntryID)->abcrec.rgchDisplayName;
#endif

    // Make the cover page name identical to the display name
    spv[ivalusrPR_FAX_CP_NAME].ulPropTag  = PR_FAX_CP_NAME_A;
#ifdef UNICODE
    spv[ivalusrPR_FAX_CP_NAME].Value.lpszA = szAnsiDisplayName;
#else
    spv[ivalusrPR_FAX_CP_NAME].Value.LPSZ = ((LPUSR_ENTRYID)lpEntryID)->abcrec.rgchDisplayName;
#endif

    spv[ivalusrPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS_A;
#ifdef UNICODE
    szAnsiEmailAddress[0] = 0;
    WideCharToMultiByte( CP_ACP, 0,
                         ((LPUSR_ENTRYID) lpEntryID)->abcrec.rgchEmailAddress, -1,
                         szAnsiEmailAddress, ARRAYSIZE(szAnsiEmailAddress),
                         NULL, NULL
                        );

    spv[ivalusrPR_EMAIL_ADDRESS].Value.lpszA = szAnsiEmailAddress;
    lpszEMA = szAnsiEmailAddress;
#else
    spv[ivalusrPR_EMAIL_ADDRESS].Value.LPSZ = ((LPUSR_ENTRYID) lpEntryID)->abcrec.rgchEmailAddress;
    lpszEMA = ((LPUSR_ENTRYID) lpEntryID)->abcrec.rgchEmailAddress;
#endif

    spv[ivalusrPR_ADDRTYPE].ulPropTag  = PR_ADDRTYPE_A;
#ifdef UNICODE
    szAnsiEMT[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, lpszEMT, -1, szAnsiEMT, ARRAYSIZE(szAnsiEMT), NULL, NULL );
    spv[ivalusrPR_ADDRTYPE].Value.lpszA = szAnsiEMT;
#else
    spv[ivalusrPR_ADDRTYPE].Value.LPSZ = lpszEMT;
#endif

    /*
     *  Build the search key...
     */
    /*  Search keys for mailable recipients that have email addresses are
     *  defined as "EmailType':'EmailAddress\0".  We do the +2 for the ':' and
     *  '\0'.
     */
#ifdef UNICODE
    cbT = lstrlenA(lpszEMA) + lstrlenA(szAnsiEMT) + 2;
#else
    cbT = lstrlen(lpszEMA) + lstrlen(lpszEMT) + 2;
#endif

    sc = lpAllocBuff( cbT, (LPVOID *) &lpbT );
    if (FAILED(sc))
    {
        hr = ResultFromScode(sc);
        goto err;
    }
#ifdef UNICODE
    lstrcpyA((LPSTR) lpbT, szAnsiEMT);
#else
    lstrcpyA((LPSTR) lpbT, lpszEMT);
#endif
    lstrcatA((LPSTR) lpbT, ":");
    lstrcatA((LPSTR) lpbT, lpszEMA);
    CharUpperBuffA((LPSTR) lpbT, (UINT) cbT);

    spv[ivalusrPR_SEARCH_KEY].ulPropTag     = PR_SEARCH_KEY;
    spv[ivalusrPR_SEARCH_KEY].Value.bin.cb  = cbT;
    spv[ivalusrPR_SEARCH_KEY].Value.bin.lpb = lpbT;

    // Need to decode the email address into "displayable" components
    // and set them on the object so that MAPI can display
    // Country code is stored separately in the address book.

    DecodeFaxAddress((LPTSTR)((LPUSR_ENTRYID)lpEntryID)->abcrec.rgchEmailAddress, &sParsedFaxAddr);
    // EncodeFaxAddress(tempString, &sParsedFaxAddr);

    /*
     * Now set the "displayable" components on the user object
     */

    spv[ivalusrPR_TEL_NUMBER].ulPropTag     = PR_TEL_NUMBER_A;
#ifdef UNICODE
    szAnsiTelNumber[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, sParsedFaxAddr.szTelNumber, -1, szAnsiTelNumber, ARRAYSIZE(szAnsiTelNumber), NULL, NULL );
    spv[ivalusrPR_TEL_NUMBER].Value.lpszA   = szAnsiTelNumber;
#else
    spv[ivalusrPR_TEL_NUMBER].Value.LPSZ    = sParsedFaxAddr.szTelNumber;
#endif

    // Country ID/code brings some trouble. I need the country ID, but it
    // might be that it is not in the FAB. If it's not, I need to try my
    // best on getting the country ID from the country code
    spv[ivalusrPR_COUNTRY_ID].ulPropTag     = PR_COUNTRY_ID;

#ifdef UNICODE
    dwCountryID = (DWORD) wcstol(((LPUSR_ENTRYID)lpEntryID)->abcrec.rgchCountryID,NULL,10);
#else
    dwCountryID = (DWORD) atol(((LPUSR_ENTRYID)lpEntryID)->abcrec.rgchCountryID);
#endif
    if (dwCountryID == 0)
    {
        // no country code in the FAB
        // GetCountryID will return 1 (U.S.) for country ID in case of error
        // GetCountryID((DWORD) atol(sParsedFaxAddr.szCountryCode), &dwCountryID);
        // This should work just the same since country code should map into a country
        // ID (actually into several. Best I can do is get the first country that
        // uses this country code. Could analyze area codes, ask the user, etc....
#ifdef UNICODE
        dwCountryID = (DWORD) wcstol(sParsedFaxAddr.szCountryCode,NULL,10);
#else
        dwCountryID = (DWORD) atol(sParsedFaxAddr.szCountryCode);
#endif
    }

    spv[ivalusrPR_COUNTRY_ID].Value.ul      = dwCountryID;

    // if no area code in the address, and it's not a 'no country' thing, get the
    // area code of the current location
    if ((!lstrcmp(sParsedFaxAddr.szAreaCode, TEXT(""))) && (dwCountryID != 0))
    {
        lstrcpy(sParsedFaxAddr.szAreaCode, (LPCTSTR) GetCurrentLocationAreaCode());
    }

    spv[ivalusrPR_AREA_CODE].ulPropTag      = PR_AREA_CODE_A;
#ifdef UNICODE
    szAnsiAreaCode[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, sParsedFaxAddr.szAreaCode, -1, szAnsiAreaCode, ARRAYSIZE(szAnsiAreaCode), NULL, NULL );
    spv[ivalusrPR_AREA_CODE].Value.lpszA    = szAnsiAreaCode;
#else
    spv[ivalusrPR_AREA_CODE].Value.LPSZ     = sParsedFaxAddr.szAreaCode;
#endif

    /*
     *  Note that we're using our entryID for our templateID.
     *  This is a really simple way to implement templateIDs.
     *  (See TID.C)
     */
    spv[ivalusrPR_TEMPLATEID].ulPropTag = PR_TEMPLATEID;
    spv[ivalusrPR_TEMPLATEID].Value.bin.cb = SIZEOF(USR_ENTRYID);
    spv[ivalusrPR_TEMPLATEID].Value.bin.lpb = (LPBYTE) lpEntryID;

    /*
     *   Set the default properties
     */
    hr = lpPropData->lpVtbl->SetProps( lpPropData,
                                       cvalusrMax,
                                       spv,
                                       NULL
                                      );

    if (HR_FAILED(hr))
    {
        goto err;
    }

    /*
     *  Although this object is basically read only, we wanted to show
     *  an example of how the check-boxes and other controls on the
     *  "Options" pane work.  If we had set this objet to be read only,
     *  the values behind those controls would have been static.
     */
    (void)lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READWRITE);

    lpABUser->lpPropData = (LPMAPIPROP) lpPropData;

    InitializeCriticalSection(&lpABUser->cs);

    *lppMAPIPropEntry = (LPVOID) lpABUser;
    *lpulObjType = MAPI_MAILUSER;

out:
    lpFreeBuff(lpbT);

    DebugTraceResult(HrNewSampUser, hr);
    return hr;

err:

    if (lpPropData)
            lpPropData->lpVtbl->Release(lpPropData);

    lpFreeBuff(lpABUser);

    goto out;

}

/***************************************************
 *
 *  The actual ABContainer methods
 */

/* --------
 * IUnknown
 */
/*************************************************************************
 *
 *
 -  ABU_QueryInterface
 -
 *
 *  This method is reused in TID.C, OOTID.C, and ABOOSER.C.  Hence the
 *  difference in checking of the 'this' pointer from other methods within
 *  this object.
 */

STDMETHODIMP
ABU_QueryInterface( LPABUSER lpABUser,
                    REFIID lpiid,
                    LPVOID FAR * lppNewObj
                   )
{

    HRESULT hr = hrSuccess;

    /*      Minimally check the lpABUer interface
     *  Can't do any more extensive checking that this because this method is reused
     *  in OOUSER.C.
     */

    if (IsBadReadPtr(lpABUser, offsetof(ABUSER, lpVtbl)+SIZEOF(ABU_Vtbl *)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadReadPtr(lpABUser->lpVtbl,
                     offsetof(ABU_Vtbl, QueryInterface)+SIZEOF(ABU_QueryInterface_METHOD *)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ABU_QueryInterface != lpABUser->lpVtbl->QueryInterface)
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }


    /*  Validate other parameters */

    if (IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, SIZEOF(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }


    /*  See if the requested interface is one of ours */

    if ( memcmp(lpiid, &IID_IUnknown,  SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMAPIProp, SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMailUser, SIZEOF(IID))
        )
    {
        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */
        hr = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpABUser->cs);
    ++lpABUser->lcInit;
    LeaveCriticalSection(&lpABUser->cs);

    *lppNewObj = lpABUser;

out:

    DebugTraceResult(ABU_QueryInterface, hr);
    return hr;
}

/*
 *  Use ROOTs - no need duplicating code
 *
 *  ROOT_AddRef
 */

/**************************************************
 *
 -  ABU_Release
 -
 *              Decrement lpInit.
 *              When lcInit == 0, free up the lpABUser structure
 *
 */
STDMETHODIMP_(ULONG)
ABU_Release (LPABUSER lpABUser)
{

    LONG lcInit;
    /*
     *  Check to see if it's big enough to hold this object
     */
    if (IsBadReadPtr(lpABUser, SIZEOF(ABUSER)))
    {
        /*
         *  Not large enough
         */
        return 1;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpABUser->lpVtbl != &vtblABU)
    {
        /*
         *  Not my vtbl
         */
        return 1;
    }

    EnterCriticalSection(&lpABUser->cs);
    lcInit = --lpABUser->lcInit;
    LeaveCriticalSection(&lpABUser->cs);

    if (lcInit == 0)
    {

        /*
         *  Get rid of the lpPropData
         */

        lpABUser->lpPropData->lpVtbl->Release(lpABUser->lpPropData);

        /*
         *  Get rid of the country codes table
         */

        if (lpABUser->lpTDatDDListBox)
            lpABUser->lpTDatDDListBox->lpVtbl->Release(lpABUser->lpTDatDDListBox);

        /*
         *  Destroy the critical section for this object
         */

        DeleteCriticalSection(&lpABUser->cs);

        /*
         *  Set the vtbl to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */

        lpABUser->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpABUser->lpFreeBuff( lpABUser );
        return 0;
    }

    return lcInit;

}

/* ---------
 * IMAPIProp
 */

/*
 *  GetLastError - use ROOTs
 *
 *
 */



/*************************************************************************
 *
 -  ABU_OpenProperty
 -
 *
 *      This is how we get the display table associated with this users
 *  details screen.
 */
STDMETHODIMP
ABU_OpenProperty( LPABUSER lpABUser,
                  ULONG ulPropTag,
                  LPCIID lpiid,
                  ULONG ulInterfaceOptions,
                  ULONG ulFlags,
                  LPUNKNOWN * lppUnk
                 )
{

    HRESULT hResult;

    /*
     *  Check to see if it's big enough to hold this object
     */
    if (IsBadReadPtr(lpABUser, SIZEOF(ABUSER)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpABUser->lpVtbl != &vtblABU)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }

    if (IsBadWritePtr(lppUnk, SIZEOF(LPUNKNOWN)))
    {
        /*
         *  Got to be able to return an object
         */
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }

    if (IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        /*
         *  An interface ID is required for this call.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }

    if (ulFlags & ~(MAPI_CREATE|MAPI_MODIFY|MAPI_DEFERRED_ERRORS))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }

    if (ulInterfaceOptions & ~MAPI_UNICODE )
    {
        /*
         *  Only the Unicode flag should be set for any of the objects that might
         *  be returned from this object.
         */

        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }

    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
            hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH);
            DebugTraceResult(ABU_OpenProperty, hResult);
            return hResult;

    }

    if (ulFlags & MAPI_CREATE)
    {
        hResult = ResultFromScode(E_ACCESSDENIED);

        DebugTraceResult(ABU_OpenProperty, hResult);
        return hResult;
    }


    // If the caller is trying to open a table property and is not expecting a table interface..
    switch (ulPropTag)
    {
    case PR_DETAILS_TABLE:
    case PR_DDLBX_COUNTRIES_TABLE:
        if (memcmp( lpiid, &IID_IMAPITable, SIZEOF(IID) ))
        {
            // ... we will abort right here
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto out;
        }
        break;

    default:
        break;
    }

    EnterCriticalSection(&lpABUser->cs);

    /*  Now lets handle the requested property */

    switch (ulPropTag)
    {

    case PR_DETAILS_TABLE:

        /* Looking for the display table*/

        /* Create a display table */

        hResult = BuildDisplayTable( lpABUser->lpAllocBuff,
                                     lpABUser->lpAllocMore,
                                     lpABUser->lpFreeBuff,
                                     lpABUser->lpMalloc,
                                     lpABUser->hLibrary,
                                     ARRAYSIZE(rgdtpageUser),
                                     rgdtpageUser,
                                     0,
                                     (LPMAPITABLE*)lppUnk,
                                     NULL
                                    );

        // if error, will just report the hResult to the caller
        break;

    case PR_DDLBX_COUNTRIES_TABLE:

        // This table is not changing dynamically. No need to rebuild if already built.
        if (!lpABUser->lpTDatDDListBox)
        {
            hResult = HrBuildDDLBXCountriesTable(lpABUser);
            if (HR_FAILED(hResult))
                    goto out;
        }

        Assert(lpABUser->lpTDatDDListBox);

        /* Get a view from the TAD*/
        hResult = lpABUser->lpTDatDDListBox->lpVtbl->HrGetView(
                          lpABUser->lpTDatDDListBox,
                          NULL,
                          NULL,
                          0,
                          (LPMAPITABLE *) lppUnk);

        break;

    default:
        hResult = ResultFromScode(MAPI_E_NO_SUPPORT);
        break;

    }

out:

    LeaveCriticalSection(&lpABUser->cs);

    DebugTraceResult(ABU_OpenProperty, hResult);
    return hResult;

}

/**********************************************************************
 *
 *  Private functions
 */

/****************************************************************************

    FUNCTION:   SortCountriesList

    PURPOSE:    prepares (for qsort) and sorts a countries list returned by TAPI,
                by country name (TAPI returns a list sorted by the country ID)

    PARAMETERS: [in] lpLineCountryList - the list of countries retuned by TAPI
                [out] lpCountriesList - a sorted list country names/IDs structures

****************************************************************************/
void
SortCountriesList(
    HINSTANCE         hInst,
    LPLINECOUNTRYLIST lpLineCountryList,
    LPCOUNTRIESLIST   lpCountriesList
    )
{
    LPLINECOUNTRYENTRY lprgLineCountryEntry = NULL;
    ULONG country;

    //
    // Create a "no country" entry
    //
    LoadString( hInst, IDS_NONE, lpCountriesList[0].szDisplayName, MAX_DISPLAY_NAME);
    lpCountriesList[0].dwValue = 0;

    //
    // Point to the first country in the structure
    //
    lprgLineCountryEntry =
        (LPLINECOUNTRYENTRY)((LPBYTE)(lpLineCountryList)
        + lpLineCountryList->dwCountryListOffset);

    //
    // Loop through LINECOUNTRYENTRY structures and add to the array
    //
    for (country=0; country < lpLineCountryList->dwNumCountries; country++)
    {
        if ((lprgLineCountryEntry[country].dwCountryNameSize != 0) &&
            (lprgLineCountryEntry[country].dwCountryNameOffset != 0L))
        {

            LPTSTR szCountryName = (LPTSTR)((LPBYTE) lpLineCountryList + lprgLineCountryEntry[country].dwCountryNameOffset);
            DWORD dwCountryID = lprgLineCountryEntry[country].dwCountryID;
            DWORD dwCountryCode = lprgLineCountryEntry[country].dwCountryCode;

            //
            // Create a "country-name (area-code)" string
            //
#ifdef UNICODE
            _snwprintf(
#else
            _snprintf(
#endif
                lpCountriesList[country+1].szDisplayName,
                COUNTRY_NAME_SIZE,
                TEXT("%s (%d)"),
                szCountryName,
                dwCountryCode
                );

            lpCountriesList[country+1].dwValue = dwCountryID;
        }
    }

    //
    // now sort the array by the country name
    //
    qsort(
        lpCountriesList,
        lpLineCountryList->dwNumCountries + 1,
        SIZEOF(COUNTRIESLIST),
#ifdef UNICODE
        _wcsicmp
#else
        _mbsicmp
#endif
        );
}


/****************************************************************************

    FUNCTION:   HrBuildDDLBXCountriesTable

    PURPOSE:    builds a country codes table to use by MAPI to display the
                                countries list box

        PARAMETERS:     [in] lpABUser - the user object

        RETURNS:        hResult

****************************************************************************/
enum {  ivallbxPR_DISPLAY_NAME = 0,
        ivallbxPR_ENTRYID,
        ivallbxPR_DISPLAY_TYPE,
        ivallbxPR_COUNTRY_ID,
        cvallbxMax };

const SizedSPropTagArray(cvallbxMax, tagaColSetCountries) =
{
    cvallbxMax,
    {
        PR_DISPLAY_NAME_A,
        PR_ENTRYID,
        PR_DISPLAY_TYPE,
        PR_COUNTRY_ID,
    }
};

OPTIONS_ENTRYID OptionsEntryID=
{
        {0,     0, 0, 0},
        MUIDABMAWF,
        MAWF_VERSION,
        MAWF_UNKNOWN,
        0
};


HRESULT
HrBuildDDLBXCountriesTable(LPABUSER lpABUser)
{
    SCODE           sc;
    HRESULT         hResult;
    SPropValue rgsPropValue[cvallbxMax];
    SRow            sRow;
    TCHAR           szDisplay[100];
    ULONG           country;
    HINSTANCE       hInst;
    LPLINECOUNTRYLIST  lpLineCountryList    = NULL;     // TAPI
    LPLINECOUNTRYENTRY lprgLineCountryEntry = NULL;     // TAPI
    LPCOUNTRIESLIST    lpCountriesList      = NULL;     // Mine
#ifdef UNICODE
    CHAR            szAnsiDisplay[100];
#endif

    // get the instance, so I can load strings from the resource file
    hInst = lpABUser->hLibrary;

    /* Create a TaD*/
    sc = CreateTable( (LPIID)&IID_IMAPITableData,
                      lpABUser->lpAllocBuff,
                      lpABUser->lpAllocMore,
                      lpABUser->lpFreeBuff,
                      lpABUser->lpMalloc,
                      0,
                      PR_DISPLAY_NAME_A,
                      (LPSPropTagArray)&tagaColSetCountries,
                      &(lpABUser->lpTDatDDListBox)
                     );

    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto out;
    }

    // constants
    sRow.cValues = cvallbxMax;
    sRow.lpProps = rgsPropValue;

    rgsPropValue[ivallbxPR_DISPLAY_NAME].ulPropTag  = PR_DISPLAY_NAME_A;
#ifdef UNICODE
    szAnsiDisplay[0] = 0;
    rgsPropValue[ivallbxPR_DISPLAY_NAME].Value.lpszA = szAnsiDisplay;
#else
    szDisplay[0] = 0;
    rgsPropValue[ivallbxPR_DISPLAY_NAME].Value.lpszA = szDisplay;
#endif

    /*
     *  For this release of MAPI the following two properties are required
     *  for all listboxes exposed in any details dialog.  This requirement is
     *  scheduled to be removed before ship
     */
    rgsPropValue[ivallbxPR_ENTRYID].ulPropTag = PR_ENTRYID;
    rgsPropValue[ivallbxPR_ENTRYID].Value.bin.lpb = (LPBYTE) &OptionsEntryID;
    rgsPropValue[ivallbxPR_ENTRYID].Value.bin.cb = CBOPTIONS_ENTRYID;

    rgsPropValue[ivallbxPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    rgsPropValue[ivallbxPR_DISPLAY_TYPE].Value.l = 0;  /*  There are no defines for this yet */


    rgsPropValue[ivallbxPR_COUNTRY_ID].ulPropTag = PR_COUNTRY_ID;

    /*
     *      Create the country list
     */

    // get the country info structure from TAPI
    if (!GetCountry(0, &lpLineCountryList))
        goto out;


    //
    // allocate a buffer for the country names and IDs
    // the allocation here is a best guess and could be wrong
    //
    sc = lpABUser->lpAllocBuff(
                    (lpLineCountryList->dwNumCountries+1) * sizeof(COUNTRIESLIST),
                    (LPVOID *) & lpCountriesList);

    if (FAILED(sc))
    {
        hResult = ResultFromScode (sc);
        goto out;
    }

    SortCountriesList(hInst, lpLineCountryList, lpCountriesList);

    // lpCountriesList now points to the sorted list of countries
    for (country=0; country < (lpLineCountryList->dwNumCountries + 1); country++)
    {
        OptionsEntryID.ulRowNumber = country;
        szDisplay[0] = 0;
        lstrcpy(szDisplay, lpCountriesList[country].szDisplayName);
#ifdef UNICODE
        szAnsiDisplay[0] = 0;
        WideCharToMultiByte( CP_ACP, 0, szDisplay, -1, szAnsiDisplay, ARRAYSIZE(szAnsiDisplay), NULL, NULL );
#endif
        rgsPropValue[ivallbxPR_COUNTRY_ID].Value.ul = lpCountriesList[country].dwValue;

        hResult = lpABUser->lpTDatDDListBox->lpVtbl->HrModifyRow(
                        lpABUser->lpTDatDDListBox,
                        &sRow);

        if (HR_FAILED(hResult))
        {
            /*
             *  Mask errors here...
             *  We want to do this because it's probibly still a valid
             *  table data object that I can get views from.  Most likely
             *  just some of the rows will be missing...
             */
            hResult = hrSuccess;
            break;
        }
    }

    /*
     *  get rid of any warnings
     */
    hResult = hrSuccess;

out:
    // Free the buffer
    // Buffer was allocated by GetCountry using my alllocation function
    if (lpLineCountryList)
        LocalFree( lpLineCountryList );
    lpABUser->lpFreeBuff(lpCountriesList);
    DebugTraceResult(HrBuildDDLBXCountriesTable, hResult);
    return hResult;
}




/*******************************************************
 *
 * The button Interface
 *
 *******************************************************/

// The General button methods
ABUBUTT_Vtbl vtblABUBUTT =
{
    ABUBUTT_QueryInterface,
    (ABUBUTT_AddRef_METHOD *)       ROOT_AddRef,
    ABUBUTT_Release,
    (ABUBUTT_GetLastError_METHOD *) ROOT_GetLastError,
    ABUBUTT_Activate,
    ABUBUTT_GetState
};

HRESULT
HrNewABUserButton( LPMAPICONTROL * lppMAPICont,
                   LPABLOGON           lpABLogon,
                   HINSTANCE           hLibrary,
                   LPALLOCATEBUFFER    lpAllocBuff,
                   LPALLOCATEMORE      lpAllocMore,
                   LPFREEBUFFER        lpFreeBuff,
                   LPMALLOC            lpMalloc,
                   ULONG               ulPropTag
                  )
{
    LPABUBUTT lpABUButt = NULL;
    SCODE scode;

    /*
     *  Creates a the object behind the button
     */

    if ((scode = lpAllocBuff( SIZEOF (ABUBUTT),
                              (LPVOID *) & lpABUButt)) != SUCCESS_SUCCESS
       )
    {
        DebugTraceSc(HrNewABUserButton, scode);
        return ResultFromScode (scode);
    }

    lpABUButt->lpVtbl = &vtblABUBUTT;
    lpABUButt->lcInit = 1;
    lpABUButt->hResult = hrSuccess;
    lpABUButt->idsLastError = 0;

    lpABUButt->hLibrary    = hLibrary;
    lpABUButt->lpAllocBuff = lpAllocBuff;
    lpABUButt->lpAllocMore = lpAllocMore;
    lpABUButt->lpFreeBuff  = lpFreeBuff;
    lpABUButt->lpMalloc    = lpMalloc;

    lpABUButt->lpABLogon = lpABLogon;

    // So that I'll know later which button this object refers to
    // currently not used. Will use only if more than one button on the template
    lpABUButt->ulPropTag = ulPropTag;

    /*
     *  I need my parent object to stay around while this object
     *  does so that I can get to it in my Activate() method.
     *  To do this just AddRef() it.
     */
    // lpABC->lpVtbl->AddRef(lpABC);

    InitializeCriticalSection(&lpABUButt->cs);

    *lppMAPICont = (LPMAPICONTROL) lpABUButt;

    return hrSuccess;
}

/*************************************************************************
 *
 *
 -  ABUBUTT_QueryInterface
 -
 *
 *  Allows QI'ing to IUnknown and IMAPIControl.
 *
 */
STDMETHODIMP
ABUBUTT_QueryInterface( LPABUBUTT lpABUButt,
                        REFIID lpiid,
                        LPVOID FAR * lppNewObj
                       )
{

    HRESULT hResult = hrSuccess;

    /*  Minimally validate the lpABUButt parameter */

    if (IsBadReadPtr(lpABUButt, SIZEOF(ABUBUTT)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (lpABUButt->lpVtbl != &vtblABUBUTT)
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Check the other parameters */

    if (!lpiid || IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, (UINT) SIZEOF(LPVOID)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  See if the requested interface is one of ours */

    if ( memcmp(lpiid, &IID_IUnknown,     SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMAPIControl, SIZEOF(IID))
        )
    {
        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */
        hResult = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpABUButt->cs);
    ++lpABUButt->lcInit;
    LeaveCriticalSection(&lpABUButt->cs);

    *lppNewObj = lpABUButt;

out:

    DebugTraceResult(ABUBUTT_QueryInterface, hResult);
    return hResult;
}

/*
 -  ABUBUTT_Release
 -
 *  Releases and cleans up this object
 */
STDMETHODIMP_(ULONG)
ABUBUTT_Release(LPABUBUTT lpABUButt)
{
    long lcInit;

    /*  Minimally validate the lpABUButt parameter */

    if (IsBadReadPtr(lpABUButt, SIZEOF(ABUBUTT)))
    {
        return 1;
    }

    if (lpABUButt->lpVtbl != &vtblABUBUTT)
    {
        return 1;
    }

    EnterCriticalSection(&lpABUButt->cs);
    lcInit = --lpABUButt->lcInit;
    LeaveCriticalSection(&lpABUButt->cs);

    if (lcInit == 0)
    {

        /*
         *  Release my parent
         */
        // lpABUButt->lpABC->lpVtbl->Release(lpABUButt->lpABC);

        /*
         *  Destroy the critical section for this object
         */

        DeleteCriticalSection(&lpABUButt->cs);

        /*
         *  Set the Jump table to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */
        lpABUButt->lpVtbl = NULL;

        /*
         *  Free the object
         */

        lpABUButt->lpFreeBuff(lpABUButt);
        return 0;
    }

    return lcInit;

}


/*************************************************************************
 *
 *
 -  ABUBUTT_Activate
 -
 *      Called when the user presses the button
 *
 *
 */
STDMETHODIMP
ABUBUTT_Activate( LPABUBUTT lpABUButt,
                  ULONG     ulFlags,
                  ULONG     ulUIParam
                 )
{
    SCODE sc = SUCCESS_SUCCESS;

    switch (lpABUButt->ulPropTag)
    {
    default:
        DebugTraceSc(ABUBUTT_Activate, lpABUButt->ulPropTag);
        return ResultFromScode (E_FAIL);
    }

    return hrSuccess;

}

/*************************************************************************
 *
 *
 -  ABUBUTT_GetState
 -
 *      Called by the client to find out if the button is enabled or disabled.
 *
 *
 */
STDMETHODIMP
ABUBUTT_GetState( LPABUBUTT lpABUButt,
                  ULONG     ulFlags,
                  ULONG *   lpulState )
{
    switch (lpABUButt->ulPropTag)
    {
    default:
        DebugTraceSc(ABUBUTT_GetState, lpABUButt->ulPropTag);
        return ResultFromScode (E_FAIL);
    }

    return hrSuccess;
}
#undef _FAXAB_ABUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\abp.h ===
/***********************************************************************
 *
 *  _ABP.H
 *
 *  Header file for code in ABP.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  Used to keep track of all objects created on this session
 */

typedef struct _object
{
	struct _object *lppNext;
	LPVOID lpObject;

} OBJECTLIST, *LPOBJECTLIST;

#define CBOBJECTLIST sizeof(OBJECTLIST)


/*
 *  Declaration of IABProvider object implementation
 */

#undef  INTERFACE
#define INTERFACE struct _ABP

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ABP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IABPROVIDER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ABP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IABPROVIDER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABP_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IABPROVIDER_METHODS(IMPL)
};


/*
 *  Definition of the init object
 */
typedef struct _ABP {
	ABP_Vtbl FAR *		lpVtbl;

    FAB_IUnknown;

	/*
     * list of logon objects 
	 */
	LPOBJECTLIST  lpObjectList;   

} ABP, FAR *LPABP;

#define CBABP sizeof(ABP)


/*
 *  utility functions that allow access to data stored in the Init object (ABP.C)
 */
void
RemoveLogonObject(LPABPROVIDER lpABProvider, LPVOID lpvABLogon, LPFREEBUFFER lpFreeBuff);

void
FindLogonObject(LPABPROVIDER lpABProvider, LPMAPIUID lpMuidToFind, LPABLOGON * lppABLogon);

/*
 *  Internal utility functions that allow access to data stored in the logon object
 */

/*
 *  Declaration of IABLogon object implementation
 */

#undef  INTERFACE
#define INTERFACE struct _ABPLOGON

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ABPLOGON_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IABLOGON_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ABPLOGON_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IABLOGON_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABPLOGON_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IABLOGON_METHODS(IMPL)
};


/*
 *  Definition of the logon object
 */
typedef struct _ABPLOGON {

	ABPLOGON_Vtbl FAR *		lpVtbl;

    FAB_IUnknown;

	/*
	 *  Private structure
	 */
    LPABPROVIDER lpABP;

	// LPOBJECTLIST lpObjectList;	/* List of objects in this session */
	LPTSTR lpszFileName;		/* Name of file that is browsed */
	MAPIUID	muidID;				/* UID for this logon object */
	LPMAPISUP lpMapiSup;		/* MAPI Support object - gotten via ABPLogon */
	// HWND hWnd;					// Window handle the AB provider can use

	/*
	 *  Table Data for canned tables
	 */

	/*  Root hierarchy  */
	LPTABLEDATA lpTDatRoot;

	/*  One Off Table  */
	LPTABLEDATA lpTDatOO;

	/*  Container Display Table  */
	// LPTABLEDATA lpTDatCDT;

	/*  Advanced search display table */
	// LPTABLEDATA lpABCSearchTbl;

	/* List box selections table */
	// LPTABLEDATA lpLBTable;

} ABPLOGON, FAR *LPABPLOGON;

#define CBABPLOGON sizeof(ABPLOGON)



/*
 *  Creates a new ABPLogon object  (see ABLOGON.C)
 */
HRESULT
HrNewABLogon(   LPABLOGON *         lppABLogon,
                LPABPROVIDER        lpABP,
                LPMAPISUP           lpMAPISup,
                LPTSTR               lpszSABFile,
                LPMAPIUID           lpmuid,
                HINSTANCE           hLibrary,
                LPALLOCATEBUFFER    lpAllocBuff,
                LPALLOCATEMORE      lpAllocMore,
                LPFREEBUFFER        lpFreeBuff,
                LPMALLOC            lpMalloc );

LPMAPIUID
LpMuidFromLogon(LPABLOGON lpABLogon);

HRESULT
HrLpszGetCurrentFileName(LPABLOGON lpABLogon, LPTSTR * lppszFileName);

HRESULT
HrReplaceCurrentFileName(LPABLOGON lpABLogon, LPTSTR lpstrT);

BOOL
FEqualFABFiles( LPABLOGON lpABLogon, LPTSTR lpszFileName);

/*
 *  Creates a new ROOT container object  (see ROOT.C)
 */
HRESULT
HrNewROOT(LPABCONT *        lppROOT,
          ULONG *           lpulObjType,
          LPABLOGON         lpABPLogon,
          LPCIID            lpInterface,
          HINSTANCE         hLibrary,
          LPALLOCATEBUFFER  lpAllocBuff,
          LPALLOCATEMORE    lpAllocMore,
          LPFREEBUFFER      lpFreeBuff,
          LPMALLOC          lpMalloc );

/*
 *  Creates the search object associated with the SampDirectory (see ABSEARCH.C)
 */
HRESULT
HrNewSearch(LPMAPICONTAINER *   lppABSearch,
            LPABLOGON           lpABLogon,
            LPCIID              lpInterface,
            HINSTANCE           hLibrary,
            LPALLOCATEBUFFER    lpAllocBuff,
            LPALLOCATEMORE      lpAllocMore,
            LPFREEBUFFER        lpFreeBuff,
            LPMALLOC            lpMalloc );

/*
 *	Macro version of IsEqualGUID
 */
// #define IsEqualGUID(g1, g2)		(memcmp((g1), (g2), sizeof(GUID)) == 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\awrc32.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by awfax32.rc
//
#define MAWF_MESSAGE                    100
#define MAWF_DELIVERY                   101
#define MAWF_DEVICE                     102
#define MAWF_SENDER                     103
#define MAWF_SETTIME                    104
#define MAWF_PERMESSAGE                                 105
#define MAWF_PRINTED_MESSAGE                    106
#define MAWF_DELIVERY_CHEAP                             107
#define MAWF_SELECTDRIVE                                108
#define MAWF_SECURITY                                   109
#define MAWF_DEVICE_ADD                                 110
// #define MAWF_WIZARD                                          111
#define MAWF_TOLL_LIST                  112
#define MAWF_W_NOT_IMPLEMENTED          102
#define MAWF_W_MUST_SELECT_ITEM         104
#define MAWF_W_RESBAD                   105
#define MAWF_W_TAPI_REINIT              113
#define MAWF_W_NO_MODEM                 114
#define MAWF_W_TAPI_LINE_CLOSE          115
#define MAWF_W_TAPI_LOC_NOT_FOUND       116
#define MAWF_W_MUST_BE_NUMBER           117
#define MAWF_W_PROFILE_CORRUPTED        202
#define MAWF_W_NO_REQUIRED_PROPS        203
#define MAWF_W_CP_FILEEXISTS            204
#define MAWF_W_CP_FILE_IN_WIN           205
#define MAWF_W_CPE_STILL_RUNS           206
#define MAWF_W_SENDER_NAME              207
#define MAWF_W_SENDER_NUMBER            208
#define MAWF_W_FAX_DEVICE               209
#define MAWF_W_NO_SHARE_FOLDER          210
#define MAWF_W_MUST_SENDER_NAME         211
#define MAWF_W_MUST_FAX_NUMBER          212
#define MAWF_W_NO_FAX_DEVICE            213
#define MAWF_W_LMI_DLL_LOAD_FAIL        214
#define MAWF_W_CFG_DLL_LOAD_FAIL        215
#define MAWF_W_LMI_ADD_FAILED           216
#define MAWF_W_CANT_REMOVE_LOCAL_MODEM  217
#define MAWF_W_LMI_REMOVE_FAILED        218
#define MAWF_W_SHARE_NAME_TRUNC         220
#define MAWF_W_NO_SHARE_USERS           221
#define MAWF_W_OLD_VERSION                              222
#define MAWF_W_CREATE_PROFILE                   223
#define MAWF_E_GENERIC                  500
#define MAWF_E_MAPI_DLL_LOAD_FAIL       501
#define MAWF_E_MAPI_LOGON_FAIL          502
#define MAWF_E_MAPI_LOGOFF_FAIL         503
#define MAWF_E_NO_MEM                   504
#define MAWF_E_WRONG_WINDOWS_VERSION    507
#define MAWF_E_MAWF_DLL_LOAD_FAIL       509
#define MAWF_E_FILE_NOT_FOUND           511
#define MAWF_E_UNKNOWN                  512
#define MAWF_E_TAPI_CONFIG_DLG          514
#define MAWF_E_TAPI_LOC_CORRUPT         515
#define MAWF_E_TAPI_CANT_INIT           516
#define MAWF_E_MORE_THAN_ONE_INSTANCE   601
#define MAWF_E_CP_FILECOPY              602
#define MAWF_E_INVALID_SHARE_NAME       603
#define MAWF_E_BAD_SHARE_FOLDER         604
#define MAWF_E_CANT_SHARE               605
#define MAWF_E_DUP_SHARE                606
#define IDH_NO_CONTEXT                  998
#define IDH_COMM_GROUPBOX               999
#define IDS_MAWF_NAME                   1000
#define IDS_AWF_NAME                    1001
#define IDS_FAX_NAME                    1002
#define IDS_INFORMATION_MESSAGE         1003
#define IDS_WARNING_MESSAGE             1004
#define IDS_CRITICAL_MESSAGE            1005
#define IDS_HELP_FILE_NAME              1006
#define IDS_CPE_FILE_NAME               1008
#define IDS_TAPI_LINE_NAME              1010
#define IDS_TAPI_ADDRESS_NAME           1011
#define IDS_TAPI_CC_UNKNOWN             1012
#define IDS_NONE                        1014
#define IDS_DEFAULT_COUNTRY_ID          1015
#define IDS_DEV_NAMES                           1016
#define IDS_QA_NAMES                            1017
#define IDS_PMBLD_NAMES                                 1018
#define IDS_APP_NAME                    1050
#define IDS_CFG_INI_FILE_NAME           1051
#define IDS_MODULE_NAME                 1052
#define IDS_NO_MODEM                    1053
#define IDS_ACTIVE_FAX_LABEL            1054
#define IDS_LOCATION_LABEL              1055
#define IDS_TOLL_DLG_OVH_TEXT                   1056
#define IDS_TOLL_DLG_CUR_LB_LABEL               1057
#define IDS_TOLL_DLG_XXXX                               1058
#define M_SEND_WHEN_START               1120
#define IDS_SEND_WHEN_HOUR              1121
#define IDS_SEND_WHEN_MINUTE            1122
#define M_SEND_WHEN_END                 1123
#define M_PAPER_SIZE_START              1130
#define IDS_PAPER_US_LETTER             1131
#define IDS_PAPER_US_LEGAL              1132
#define IDS_PAPER_A4                    1133
#define IDS_PAPER_B4                    1134
#define M_PAPER_SIZE_END                1135
#define IDS_DEFAULT_PAPER_SIZE_METRIC   1138
#define IDS_DEFAULT_PAPER_SIZE_US               1139
#define M_IMAGE_QUALITY_START           1140
#define IDS_QUALITY_BEST                1141
#define IDS_QUALITY_STANDARD            1142
#define IDS_QUALITY_FINE                1143
#define IDS_300DPI                      1144
#define M_IMAGE_QUALITY_END             1145
#define M_CHEAP_BEGIN_START             1150
#define IDS_CHEAP_BEGIN_HOUR            1151
#define IDS_CHEAP_BEGIN_MINUTE          1152
#define M_CHEAP_BEGIN_END               1153
#define M_CHEAP_END_START               1160
#define IDS_CHEAP_END_HOUR              1161
#define IDS_CHEAP_END_MINUTE            1162
#define M_CHEAP_END_END                 1163
#define M_NUM_OF_RINGS_START            1180
#define IDS_NUM_OF_RINGS_2              1181
#define IDS_NUM_OF_RINGS_3              1182
#define IDS_NUM_OF_RINGS_4              1183
#define IDS_NUM_OF_RINGS_5              1184
#define IDS_NUM_OF_RINGS_6              1185
#define IDS_NUM_OF_RINGS_7              1186
#define IDS_NUM_OF_RINGS_8              1187
#define IDS_NUM_OF_RINGS_9              1188
#define IDS_NUM_OF_RINGS_10             1189
#define M_NUM_OF_RINGS_END              1190
#define M_FAX_DEVICES_START             1192
#define IDS_PC_FAX                      1193
#define IDS_FAX_SERVER                  1194
#define M_FAX_DEVICES_END               1195
#define IDS_IFAX_MACHINE                1196
#define M_COVER_PAGE_START              1200
#define IDS_MSC_CPFILEEXT               1201
#define IDS_MSC_COMDLGPAT               1202
#define IDS_MSC_COMDLGTITLE             1203
#define IDS_DEFAULT_COVER_PAGE          1204
#define M_COVER_PAGE_END                1205
#define M_SHARE_DIR_START               1210
#define IDS_SHARE_COMDLGTITLE           1211
#define IDS_SHARE_COMDLGPAT             1212
#define IDS_SHARE_PATH                  1213
#define IDS_SHARE_COMMENT               1214
#define IDS_DEFAULT_SHARE_NAME                  1215
#define M_SHARE_DIR_END                 1216
#define IDS_HELP_FILENAME                               1220
#define IDS_CPE_FILENAME                                1221
#define IDS_DEFAULT_RETRIES                             1230
#define IDS_MAX_RETRIES                                 1231
#define IDS_DEFAULT_TIME_BET_RETRIES    1232
#define IDI_FAXCFG_ICON                 1301
#define IDI_DIALING_ICON                1302
#define IDI_USER_ICON                   1303
#define IDI_MODEM_ICON                  1304
#define IDI_MESSAGE_ICON                1305
#define CONTROLS_START                  2000
#define IDC_SEND_AS_GROUPBOX            2000
#define IDC_SEND_BEST_AVAIL             2001
#define IDC_SEND_AS_EMAIL               2002
#define IDC_SEND_AS_FAX                 2003
#define IDC_SEND_ASAP                   2004
#define IDC_SEND_AT_CHEAP               2005
#define IDC_SEND_AT_TIME                2006
#define IDC_SET_CHEAP_TIME              2007
#define IDC_SEND_WHEN_HOUR              2008
#define IDC_TIME_SEP                    2009
#define IDC_SEND_WHEN_MINUTE            2010
#define IDC_SEND_WHEN_AMPM              2011
#define IDC_TIME_ARROW                  2012
#define IDC_BILLING_CODE_LABEL          2015
#define IDC_BILLING_CODE                2016
#define IDC_MORE_OPTIONS                2017
#define IDC_TIME_BORDER                 2018
#define IDC_PRINTED_FORMAT_OPTIONS      2019
#define IDC_DELIVERY                    2021
#define IDC_SECURITY                    2022
#define IDC_GENERAL                     2023
#define IDC_CP_INCLUDE                  2030
#define IDC_CP_BEGIN_MSG_ON             2031
#define IDC_CP_OPEN                     2032
#define IDC_CP_LIST                     2033
#define IDC_CP_NEW                      2034
#define IDC_CP_BROWSE                   2035
#define IDC_CP_SET_DEFAULT              2036
#define IDC_SET_TIME                    2037
#define IDC_COVER_PAGE_GROUPBOX         2038
#define IDC_SEND_WHEN_GROUPBOX          2039
#define IDC_OVH_TEXT                    2040
#define IDC_IPMDOC                                              2041
#define IDC_MODEM_SETTINGS              2101
#define IDC_MODEM_ADD                   2102
#define IDC_MODEM_REMOVE                2103
#define IDC_AVAIL_FAX_DEVICES           2104
#define IDC_AVAIL_FAX_DEVICES_LIST      2105
#define IDC_MODEM_SET_ACTIVE            2106
#define IDC_MODEM_SHARE_GROUPBOX        2110
#define IDC_MODEM_SHARE_CHECKBOX        2111
#define IDC_SHARE_REQUIRE_PASSWD        2112
#define IDC_WORK_OFFLINE                2113
#define IDC_SHARE_NAME                  2114
#define IDC_SHARE_NAME_LABEL            2115
#define IDC_SHARE_PASSWD                2116
#define IDC_FAXMODEM_GROUPBOX           2117
#define IDC_SHARE_PROPERTIES            2118
#define IDC_AVAIL_FAX_DEVICES_LABEL     2119
#define IDC_SHARE_TEXT                  2120
#define IDC_MODEM_OVH_TEXT              2121
#define IDC_SHARE_PATHNAME              2122
#define MAWFRecipient                   2200
#define IDC_RECIP_DISPLAY_NAME_LABEL    2201
#define IDC_RECIP_DISPLAY_NAME          2202
#define IDC_RECIP_FAX_NUMBER_GROUPBOX   2203
#define IDC_RECIP_COUNTRY_CODE_LABEL    2204
#define IDC_RECIP_COUNTRY_CODE          2205
#define IDC_RECIP_FAX_NUMBER_LABEL      2206
#define IDC_RECIP_FAX_NUMBER_AREA_CODE  2207
#define IDC_RECIP_FAX_NUMBER_LABEL2     2208
#define IDC_RECIP_FAX_NUMBER            2209
#define IDC_RECIP                       2212
#define IDC_PAPER_SIZE_LABEL            2301
#define IDC_PAPER_SIZE                  2302
#define IDC_PAPER_PORTRAIT              2303
#define IDC_PAPER_LANDSCAPE             2304
#define IDC_IMAGE_QUALITY_LABEL         2305
#define IDC_IMAGE_QUALITY               2306
#define IDC_ORIENTATION_LABEL           2307
#define IDC_MUST_RENDER_ATTACH          2308
#define IDC_RETRIES_GROUPBOX            2401
#define IDC_NUMBER_OF_RETRIES_LABEL     2403
#define IDC_NUMBER_OF_RETRIES           2404
#define IDC_TIME_BET_RETRIES_LABEL1     2405
#define IDC_TIME_BET_RETRIES            2406
#define IDC_TIME_BET_RETRIES_LABEL2     2407
#define IDC_DEVELOPERS_NAMES            2408
#define IDC_DEVELOPERS_BUTTON           2409
#define IDC_DIALING_INFO_LABEL          2410
#define IDC_DIALING_INFO                2411
#define IDC_EDIT_TOLL_LIST_LABEL        2413
#define IDC_DIALING_GROUPBOX            2414
#define IDC_EDIT_TOLL_LIST              2415
#define IDC_RD_NOENCRYPT                2501
#define IDC_RD_KEYENCRYPT               2502
#define IDC_RD_PWDENCRYPT               2503
#define IDC_CK_DIGSIG                   2504
#define IDC_TXT_KEYENCRYPT              2505
#define IDC_TXT_DIGSIG                  2506
#define IDC_GRP_ENCRYPTMETHOD           2507
#define IDC_TOLL_LIST_ADD               2601
#define IDC_TOLL_LIST_REMOVE            2602
#define IDC_TOLL_LIST_ALL_LB            2603
#define IDC_TOLL_LIST_CURRENT_LB        2604
#define IDC_TOLL_LIST_ADD_ALL                   2605
#define IDC_TOLL_LIST_REMOVE_ALL                2606
#define IDC_TOLL_LIST_ALL_LB_LABEL      2607
#define IDC_TOLL_LIST_CURRENT_LB_LABEL  2608
#define IDC_RECIP_FAX_PRIMARY           2901
#define IDC_RECIP_FAX_ALTERNATE         2902
#define IDC_USE_ALTERNATE               2903
#define IDC_RECIP_MACHINE_TYPE          2905
#define IDC_SENDER_NAME_LABEL           3101
#define IDC_SENDER_NAME                 3102
#define IDC_SENDER_ADDR_GROUPBOX        3105
#define IDC_SENDER_COUNTRY_CODE_LABEL   3108
#define IDC_SENDER_COUNTRY_CODE         3109
#define IDC_SENDER_FAX_NUMBER_LABEL     3110
#define IDC_SENDER_FAX_NUMBER_AREA_CODE 3111
#define IDC_SENDER_FAX_NUMBER_LABEL2    3112
#define IDC_SENDER_FAX_NUMBER           3113
#define IDC_SENDER_COMPANY_LABEL        3115
#define IDC_SENDER_COMPANY              3116
#define IDC_SENDER_ADDRESS_LABEL        3117
#define IDC_SENDER_ADDRESS              3118
#define IDC_SENDER_TITLE_LABEL          3119
#define IDC_SENDER_TITLE                3120
#define IDC_SENDER_DEPT_LABEL           3121
#define IDC_SENDER_DEPT                 3122
#define IDC_SENDER_OFFICE_LOC_LABEL     3123
#define IDC_SENDER_OFFICE_LOC           3124
#define IDC_SENDER_OFFICE_TL_LABEL      3125
#define IDC_SENDER_OFFICE_TL            3126
#define IDC_SENDER_HOME_TL_LABEL        3127
#define IDC_SENDER_HOME_TL              3128
#define IDC_SENDER_OVH_TEXT             3129
#define IDC_SENDER_FAX_NUMBER_LABEL1    3130
#define IDC_START_CHEAP_RATES_LABEL     3301
#define IDC_CHEAP_BEGIN_TBORDER         3302
#define IDC_CHEAP_BEGIN_HOUR            3303
#define IDC_TIME_SEP1                   3304
#define IDC_CHEAP_BEGIN_MINUTE          3305
#define IDC_CHEAP_BEGIN_AMPM            3306
#define IDC_CHEAP_BEGIN_TARROW          3307
#define IDC_END_CHEAP_RATES_LABEL       3308
#define IDC_CHEAP_END_TBORDER           3309
#define IDC_CHEAP_END_HOUR              3310
#define IDC_TIME_SEP2                   3311
#define IDC_CHEAP_END_MINUTE            3312
#define IDC_CHEAP_END_AMPM              3313
#define IDC_CHEAP_END_TARROW            3314
#define IDC_WIZARD_INFO_TEXT            3401
#define IDC_WIZARD_DONE_TEXT            3402
#define IDC_WIZARD_CLICK_NEXT           3403
#define IDC_ANSWER_OVH_TEXT             3410
#define IDC_ANSWER_MODE_AUTO            3411
#define IDC_ANSWER_MODE_NO              3412
#define IDC_NUMBER_OF_RINGS             3414
#define IDC_ANSWER_YES_TEXT1            3415
#define IDC_ANSWER_NO_TEXT                  3416
#define IDC_ANSWER_YES_TEXT2            3417
#define IDC_ANSWER_YES_TEXT3            3418
#define IDC_DEVTYPE_OVH_TEXT                    3419
#define IDC_DEVTYPE_LOCAL                               3420
#define IDC_DEVTYPE_OTHER                               3421
#define IDC_DEVTYPE_LOCAL_TEXT                  3422
#define IDC_DEVTYPE_OTHER_TEXT                  3423
#define IDC_DRIVE_LIST                  3501
#define IDC_DRIVE_LIST_LABEL            3502
#define IDC_ADD_FAX_LIST                3601
#define IDC_ADD_FAX_LIST_LABEL          3602
#define IDC_HAVE_DISK                   3603
#define IDC_DISPLAY_NAME                3605
#define CONTROLS_END                    3606
#define M_SAVE_NAMES_START              4000
#define IDS_SN_PRODUCT_NAME             4000
#define IDS_SN_SEND_AS                  4001
#define IDS_SN_BILLING_CODE             4002
#define IDS_SN_INCLUDE_COVER_PAGE       4003
#define IDS_SN_BGN_MSG_ON_COVER         4004
#define IDS_SN_CHEAP_TIME_BEGIN_HOUR    4005
#define IDS_SN_CHEAP_TIME_BEGIN_MINUTE  4006
#define IDS_SN_CHEAP_TIME_END_HOUR      4007
#define IDS_SN_CHEAP_TIME_END_MINUTE    4008
#define IDS_SN_NUMBER_RETRIES           4009
#define IDS_SN_MINUTES_BETWEEN_RETRIES  4010
#define IDS_SN_PRINT_ORIENTATION        4011
#define IDS_SN_PAPER_SIZE               4012
#define IDS_SN_IMAGE_QUALITY            4013
#define IDS_SN_SEND_WHEN_TYPE           4014
#define IDS_SN_NOT_EARLIER_HOUR         4015
#define IDS_SN_NOT_EARLIER_MINUTE       4016
#define IDS_SN_PROFILE_VERSION          4017
#define IDS_SN_PREV_BILLING_CODES       4018
#define IDS_SN_DEFAULT_COVER_PAGE       4019
#define IDS_SN_BILLING_CODE_DWORD       4020
#define IDS_SN_LOG_ENABLE               4021
#define IDS_SN_LOG_NUM_OF_CALLS         4022
#define IDS_SN_DISPLAY_PROGRESS         4023
#define IDS_SN_EMBED_LINKED_OBJECTS     4024
#define IDS_SN_TAPI_LOC_ID              4025
#define IDS_SN_SENDER_NAME              4026
#define IDS_SN_SENDER_EMAIL_ADDR        4027
#define IDS_SN_SPEAKER_MODE             4028
#define IDS_SN_ANSWER_MODE              4029
#define IDS_SN_ANSWER_NUM_RINGS         4030
#define IDS_SN_SENDER_STATION_ID        4031
#define IDS_SN_ACTIVE_FAX_MODEM         4032
#define IDS_SN_ENABLE_RECIPIENT_OPTIONS 4033
#define IDS_SN_MUST_RENDER_ATTACH       4034
#define IDS_SN_CALLING_CARD             4035
#define IDS_SN_ACTIVE_MODEM_TYPE        4036
#define IDS_SN_WORK_OFFLINE             4037
#define IDS_SN_SHARE_DEVICE             4038
#define IDS_SN_SHARE_NAME               4039
#define IDS_SN_SENDER_COMPANY           4040
#define IDS_SN_SENDER_TITLE             4041
#define IDS_SN_SENDER_ADDRESS           4042
#define IDS_SN_SENDER_DEPT              4043
#define IDS_SN_SENDER_OFFICE_LOC        4044
#define IDS_SN_SENDER_HOME_TL           4045
#define IDS_SN_SENDER_OFFICE_TL         4046
#define IDS_SN_SENDER_COUNTRY_ID        4047
#define IDS_SN_NETFAX_DEVICES           4048
#define IDS_SN_SHARE_PATHNAME           4049
#define M_SAVE_NAMES_END                4050
#define IDH_OVR_MESSAGE                 5001
#define IDH_OVR_DIALING                 5002
#define IDH_OVR_MODEM                   5003
#define IDH_OVR_SENDER                  5004
#define IDC_STATIC                      -1
#define IDC_STATIC_CONTROL              0xffff

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        125
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         3660
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\entryid.h ===
/***************************************************************************

    Name      : entryid.h

    Comment   : Entry ID values for Microsoft At Work FAX

    Functions : none

    Created   : 03/01/94

    Author    : Bruce J Kelley

    Contribs  :

    Comments  :

***************************************************************************/

// Provider UUID's
//
// Use uuidgen.exe to generate new UUID's.
//
// At Work Fax Transport:
// 65BA6B50-1756-101B-BA6B-00001B15D43F
#define AWFAXPUID {0x65,0xBA,0x6B,0x50,0x17,0x56,0x10,0x1B,0xBA,0x6B,0x00,0x00,0x1B,0x15,0xD4,0x3F}
// At Work Fax Transport: for the Message Options profile section
// ED3DF040-FD96-1069-BDF0-00AA004A82CB
#define AWFAXPMSGUID {0xED,0x3D,0xF0,0x40,0xFD,0x96,0x10,0x69,0xBD,0xF0,0x00,0xAA,0x00,0x4A,0x82,0xCB}
// Microsoft Fax Address Book Provider MAPIUID
#define MUIDABMAWF {0x66,0x47,0x10,0xc0,0xfc,0xc4,0x10,0x1a,0x87,0x10,0x08,0x00,0x2b,0x2d,0xc5,0xb7}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\faxab.h ===
/*
 -  FAXAB . H
 -
 *  Purpose:
 *      Header file for the Microsoft At Work Fax Address Book.
 *
 *      Yoram Yaacovi, 1/94
 */

/*
 * Windows headers
 */

#ifdef WIN95
#undef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00010004
#endif

#ifdef WIN32
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Daytona; Chicago needs it */
#endif
#include <windows.h>
#include <windowsx.h>
#include <limits.h>
#include <memory.h>
#include <commdlg.h>
#include <string.h>
#include <mbstring.h>
#define itoa _itoa  // MSVCNT libs export _itoa, not itoa.

/*
 * MAPI headers
 */
#include <mapiwin.h>
#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
#include <mapiguid.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapival.h>

/*
 * TAPI headers
 */
#include <tapi.h>

/*
 * At Work Fax common headers
 */
#include <awfaxab.rh>
#include <awrc32.h>
#include <property.h>                   // At Work Fax MAPI properties
//#include <uiutil.h>                     // At Work Fax UI (awfxcg32.dll) exports
//#include <mem.h>                        // At Work Fax UI (awfxcg32.dll) memory handling
#include <debug.h>                      // At Work Fax UI (awfxcg32.dll) debug macros and functions
#include <entryid.h>                    // At Work Fax various entry IDs

/*
 * Macros
 */
#define SIZEOF(x) sizeof(x)
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))


/*********************************************
 **** Common address book objects members ****
 *********************************************/

/*
 *  IUnknown base members
 */
#define FAB_IUnknown                    \
    LONG                lcInit;         \
    HRESULT             hResult;        \
    UINT                idsLastError;   \
    HINSTANCE           hLibrary;       \
    LPALLOCATEBUFFER    lpAllocBuff;    \
    LPALLOCATEMORE      lpAllocMore;    \
    LPFREEBUFFER        lpFreeBuff;     \
    LPMALLOC            lpMalloc;       \
    CRITICAL_SECTION    cs

#define FAB_IUnkWithLogon               \
    FAB_IUnknown;                       \
    LPABLOGON           lpABLogon

#define FAB_Wrapped                     \
    FAB_IUnkWithLogon;                  \
    LPMAPIPROP          lpPropData

/*
 * At Work Fax AB headers
 */
#include "wrap.h"
#include "tblwrap.h"
#include "abp.h"
#include "abeid.h"
#include "abcont.h"
#include "abctbl.h"
#include "root.h"
#include "status.h"
#include "abuser.h"
#include "oouser.h"
#include "tid.h"
#include "ootid.h"


/**** Constants ***/

#define STRING_MAX                      256             // Maximum size of string in the
                                                        //      resource file string table or in the .ini file
#define SEL_STRING_MAX                  50              // Maximum size of string for drop-down box selections

// Maximum sizes for various properties
#define MAX_DISPLAY_NAME                150             // Maximum size of display names (??)
#define MAX_ADDRTYPE                    25              // Maximum size of address type (??)
#define MAX_EMAIL_ADDRESS               MAX_PATH // Maximum size of an email addr (fax #)
#define MAX_MACHINE_CAPS                30               // Maximum size for fax capability string
#define MAX_SEARCH_NAME                 50

// Display Table stuff
#define GROUPBOX_TEXT_SIZE              40
#define LABEL_TEXT_SIZE                 40
#define BUTTON_TEXT_SIZE                25
#define TAB_TEXT_SIZE                   15

// TAPI-ish defines
#define COUNTRY_CODE_SIZE               10
#define AREA_CODE_SIZE                  10
#define TELEPHONE_NUMBER_SIZE   50
#define ROUTING_NAME_SIZE               150
#define CANONICAL_NUMBER_SIZE   (10+COUNTRY_CODE_SIZE+AREA_CODE_SIZE+TELEPHONE_NUMBER_SIZE+ROUTING_NAME_SIZE)

typedef struct tagPARSEDTELNUMBER
{
    TCHAR  szCountryCode[COUNTRY_CODE_SIZE+1];               // country code
    TCHAR  szAreaCode[AREA_CODE_SIZE+1];                     // area code
    TCHAR  szTelNumber[TELEPHONE_NUMBER_SIZE+1];             // telephone number
    TCHAR  szRoutingName[ROUTING_NAME_SIZE+1];               // routing name within the tel number destination
} PARSEDTELNUMBER, *LPPARSEDTELNUMBER;

BOOL   EncodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);
BOOL   DecodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);

/*
 * Function pointer prototypes for fax config functions
 */
typedef BOOL (* PFN_DECODE_FAX_ADDRESS)(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);
typedef BOOL (* PFN_ENCODE_FAX_ADDRESS)(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);


#ifdef RADIO_BUTTON
#define RADIO_BUTTON_1_RETURN_VALUE     1
#define RADIO_BUTTON_2_RETURN_VALUE     2
#define RADIO_BUTTON_3_RETURN_VALUE     3
#define RADIO_BUTTON_4_RETURN_VALUE     4
#endif

/****************************************
*********    Properties    **************
****************************************/

// CHECK: Move to property.h ?
// #define EFAX_PR_OPTIONS_BASE 0x6600

/*
 *  Prop Tag associated with my szFileName in the profile
 */
#define PR_FAB_FILE_A                   PROP_TAG(PT_STRING8,0x6600)
#define PR_FAB_UID                      PROP_TAG(PT_BINARY,0x6601)

/****** Display table related properties ******/

// Drop Down list box for country codes
#define PR_DDLBX_COUNTRIES_TABLE        PROP_TAG(PT_OBJECT,0x6603)

// Template Buttons
#define PR_DIAL_HELPER_BUTTON           PROP_TAG(PT_OBJECT,0x6604)
#define PR_ADVANCED_BUTTON              PROP_TAG(PT_OBJECT,0x6605)
#define PR_DIAL_LONG_DISTANCE           PROP_TAG(PT_BOOLEAN,0x6606)

// Address components properties moved to property.h. They are
// now used by chicago\security\chicago.c
// 0x6607-0x660a
// PR_COUNTRY_ID
// PR_AREA_CODE
// PR_TEL_NUMBER

#define PR_PREVIOUS_CP_NAME_A           PROP_TAG(PT_STRING8,0x660b)

/******
 ****** Cross program Globals
 ******/

#ifdef _FAXAB_ABP

LCID lcidUser;                          // The Local Identifier
MAPIUID muidABMAWF = MUIDABMAWF;        // This provider's MAPIUID
// HINSTANCE hInst;                       // This provider instance
LPTSTR lpszEMT = TEXT("FAX");           // This provider's Email Type
BOOL fDebugTrap = FALSE;                // Deubg trap flag
BOOL fExposeFaxAB = FALSE;              // Whether or not to expose the Fax AB
/*
 *  structures and filters defined for display tables
 */

DTBLLABEL    dtbllabel          = { sizeof(DTBLLABEL),          0 };
DTBLPAGE     dtblpage           = { sizeof(DTBLPAGE), 0, 0,     0 };
DTBLGROUPBOX dtblgroupbox       = { sizeof(DTBLGROUPBOX),       0 };
CHAR szNoFilter[]              = "*";
CHAR szDigitsOnlyFilter[]      = "[0-9]";
CHAR szTelephoneNumberFilter[] = "[0-9\\-\\. ,\\|AaBbCcDdPpTtWw\\*#!@\\$\\?;]";
CHAR szAddrTypeFilter[]        = "[~:]";
CHAR szFileNameFilter[]        = "[~   \\\\]"; /* ends up [~<space><tab>\\] */


/*
 *  Standard column set is straight from the spec of required columns
 *  for Display Tables
 */

static const SizedSPropTagArray(8, DetInitColSet) =
{
    8,
    {
        PR_ROWID,
        PR_XPOS,
        PR_DELTAX,
        PR_YPOS,
        PR_DELTAY,
        PR_CONTROL_TYPE,
        PR_CONTROL_FLAGS,
        PR_CONTROL_STRUCTURE
    }
};

#else
extern LCID          lcidUser;
extern MAPIUID       muidABMAWF;
// extern HINSTANCE     hInst;
extern LPTSTR        lpszEMT;
extern BOOL          fDebugTrap;
extern BOOL          fExposeFaxAB;
extern DTBLLABEL     dtbllabel;
extern DTBLPAGE      dtblpage;
extern DTBLGROUPBOX  dtblgroupbox;
extern CHAR          szNoFilter[];
extern CHAR          szDigitsOnlyFilter[];
extern CHAR          szTelephoneNumberFilter[];
extern CHAR          szAddrTypeFilter[];
extern CHAR          szFileNameFilter[]; // ends up [~\\]
extern SPropTagArray DetInitColSet;

#endif // _FAXAB_ABP

/****************************************
****** Common functions prototypes ******
****************************************/

/*
 *  Creates a new contents table object
 */
HRESULT
HrNewIVTAbc (LPMAPITABLE *      lppIVTAbc,
             LPABLOGON          lpABLogon,
             LPABCONT           lpABC,
             HINSTANCE          hLibrary,
             LPALLOCATEBUFFER   lpAllocBuff,
             LPALLOCATEMORE     lpAllocMore,
             LPFREEBUFFER       lpFreeBuff,
             LPMALLOC           lpMalloc );

/*
 *  Creates/Updates the SAB's root hierarchy
 */
HRESULT
HrBuildRootHier(LPABLOGON lpABLogon, LPMAPITABLE * lppMAPITable);


/*
 *  Sets an error string associated with a particular hResult on an object.
 *  It's used in conjunction with the method GetLastError.
 */
VOID SetErrorIDS (LPVOID lpObject, HRESULT hResult, UINT ids);


/*
 *  Loads a string from a resource.  Optionally allocates room for the string
 *  if lpAllocBuff is not NULL.  See ABP.C.
 */
SCODE ScLoadString( UINT                ids,
                    ULONG               ulcch,
                    LPALLOCATEBUFFER    lpAllocBuff,
                    HINSTANCE           hLibrary,
                    LPTSTR *             lppsz);

/*
 *  Calls TAPI to get current location area code and returns a pointer
 *  to a string for it.
 */
LPTSTR
GetCurrentLocationAreaCode( void );

/*
 *  Calls TAPI to get current location country id
 */
DWORD
GetCurrentLocationCountryID( void );

/* ***************************************************************************
 * GetCountry
 *
 * - gets the a country or a country list from TAPI
 *
 * Parameters:  dwReqCountryID - a TAPI country ID. 0 for all countries
 *
 * Returns: TRUE on success, FALSE on failure.  *lppLineCountryList must
 *          be freed with LocalFree.
 */
BOOL
GetCountry( DWORD dwReqCountryID,
            LPLINECOUNTRYLIST *lppLineCountryList
           );


/* ***************************************************************************
 * GetCountryCode
 *
 * - gets a country code when given a country ID
 *
 * Parameters:  dwReqCountryID  - a TAPI country ID
 *              lpdwCountryCode - an address of a DWORD in which to store the country code
 *
 * Returns: TRUE on success, FALSE on failure.
 */

BOOL
GetCountryCode( DWORD dwReqCountryID,
                DWORD *lpdwCountryCode
               );


/****************************************************************************
    FUNCTION:   MakeMessageBox

    PURPOSE:    Gets resource string and displays an error message box.

    PARAMETERS: hInst      - Instnace of the caller (for getting strings)
                hWnd       - Handle to parent window
                ulResult   - Result/Status code
                             0:              information message
                             100-499:        warning message
                             500 and up:     error message
                idString   - Resource ID of message in StringTable
                fStyle     - style of the message box

    RETURNS:    the return value from MessageBox() function

****************************************************************************/
int
MakeMessageBox( HINSTANCE hInst,
                HWND hWnd,
                DWORD ulResult,
                UINT idString,
                UINT fStyle,
                ...
               );


/* ***************************************************************************
 * EncodeFaxAddress
 *
 * - encodes fax address components into the format name@+country-code (area-code) fax-number
 *
 * Parameters:  lpszFaxAddr     - address of a buffer in which to fill the encoded fax number
 *              lpParsedFaxAddr - an address of a PARSEDTELNUMBER structure which contains
 *                                the components of the address that need to be encoded
 *
 * Returns: TRUE on success, FALSE on failure.
 *
 * CHECK: will need localization
 */

BOOL EncodeFaxAddress( LPTSTR lpszFaxAddr,
                       LPPARSEDTELNUMBER lpParsedFaxAddr
                      );


/* ***************************************************************************
 * DecodeFaxAddress
 *
 * - parses a fax address of the format name@+country-code (area-code) fax-number
 *
 * Parameters:  lpszFaxAddr - a Fax address in the above format
 *                            lpParsedFaxAddr - an address of a PARSEDTELNUMBER structure in which to
 *                            fill the parsed information
 *
 * Returns: TRUE on success, FALSE on failure.
 *              success:        full address
 *                              no routing name
 *                              no area code
 *              failure:        no '+country-code '
 *                              no telephone number
 *
 * CHECK: will need localization
 */

BOOL DecodeFaxAddress( LPTSTR lpszFaxAddr,
                       LPPARSEDTELNUMBER lpParsedFaxAddr
                      );

#ifdef DO_WE_REALLY_NEED_TAPI
/* ***************************************************************************
 * InitTAPI
 *
 * initializes TAPI by calling lineInitialize. enumerates all the available
 * lines to set up pt_lpVdts->lprgLineInfo. also opens up each available line for
 * monitoring. sets up pt_lpVdts->iLineCur and pt_lpVdts->iAddrCur by checking the
 * preferred line/address name stored in the ini file  against the available
 * line/address names.
 *
 * Parameters:  hInst       - the instance of the calling module
 *              hWnd        - window handle for UI
 *              lpszAppName - the name of the calling module
 *
 * returns NO_ERROR if success and the corresponding error code otherwise.
 */

DWORD
InitTAPI( HINSTANCE hInst,
          HWND hWnd,
          LPTSTR lpszAppName
         );


/****************************************************************************
 *  DeinitTAPI
 *
 *  frees up the memory allocated, closes all the lines we have opened for
 *  monitoring and calls lineShutDown to disconnect from TAPI.
 */

BOOL DeinitTAPI();

//
typedef struct _TagPTGData
{
        CRITICAL_SECTION csInstance;        // Critical section ro control access to hInst
        WORD wInvocationFlags;              // MAWFSettingsDialog invocation flags
        HINSTANCE hInst;                    // DLL instance
        HWND hWnd;                          // Application main window
        LPPROPSTORAGE lpPropStorage;        // Profile Section pointer
        tThreadParam threadParam;           // parameter passed to the wait-for-app thread
        TCHAR szDefCoverPage[MAX_PATH];     // the default cover page file name
        MEMALLOCATIONS  *lpMemAllocations;  // pointer to the allocations array
        DEVICETYPE aDeviceTypes[NUMBER_OF_DEVICE_TYPES];    // the device types array
        WORD cDeviceTypes;                      // number of device types
        PARSEDMODEM aDevices[NUMBER_OF_DEVICES];    // The devices array
        WORD iDeviceIndex;                  // index (in the aDevices) of the active fax device
        WORD cDevices;                      // number of devices in the aDevices array
        NONTAPIDEVICE aNonTAPIDevices[NUMBER_OF_DEVICES];   // the non-TAPI devices array
        WORD iLastDeviceAdded;              // type of the last device added
        HWND hAddModemDlg;                  // handle of the DeviceAdd dialog
        HWND hDeviceListDlg;                // handle of the dialog that contains the device list
        LPDTS lpVdts;                       // TAPI info structure
        LPMALLOC lpMalloc;                  // IMalloc memory allocator

} PTGDATA, *LPPTGDATA;

/*********************************
******   Constants   *************
*********************************/

#define NOT_SIGNED                      FALSE   // for SetDlgItemInt()
#define MAPI_ERROR_MAX                  30

#define MAX_SENDER_NAME_SIZE            255     // maximum size fo the sender name
#define MAX_BILLING_CODE_SIZE           8       // Maximum size of billing code
#define MAX_NUMBER_OF_BILLING_CODES     10      // Maximum number of billing codes in prev list
#define NUMBER_OF_MV_STRINGS            20      // Maximum number of strings in a multi value property
#define NUMBER_OF_DEVICES               20      // Maximum # of devices I can handle
#define NUMBER_OF_DEVICE_TYPES          20      // Maximum # of devices types I can handle
#define NUM_OF_PROPERTIES               70      // Number of properties
#define SIZE_OF_PROP_STRINGS            1000    // Size of buffer allocated for ALL string properties
#define SIZE_OF_PROP_SAVE_NAMES         400     // Size of buffer allocated for the property save names
#define NUM_OF_MAWF_PROPERTY_PAGES      4       // Number of At Work Fax Property Sheet pages
#define MAWF_SHORT                      1       // Display one page MAWF property sheet
#define MAWF_FULL                       NUM_OF_MAWF_PROPERTY_PAGES  // Display all pages MAWF property sheet
#define INIT_BUF_SIZE                   1024
#define szAWKey "Software\\Microsoft\\At Work Fax"


// this should only happen if the thread did not have private storage, and
// an attempt to allocate one failed
#define CHECK_THREAD_STORAGE_POINTER(ptr,func,result) \
        if (!(ptr))                         \
        {                                   \
           Assert((ptr));                  \
           DEBUG_TRACE("%s: bad thread storage pointer. thread %x\n", (func), GetCurrentThreadId()); \
           return ((result));                   \
        }


#define pt_csInstance       lpPTGData->csInstance           // per-thread critical section (for hInst)
#define pt_wInvocationFlags lpPTGData->wInvocationFlags     // per-thread invocation flags
#define pt_hInst            lpPTGData->hInst                // per-thread instance handle
#define pt_hWnd             lpPTGData->hWnd                 // per-thread main window handle
#define pt_lpPropStorage    lpPTGData->lpPropStorage        // per-thread property storage object
#define pt_threadParam      lpPTGData->threadParam          // per-thread CPE thread parameters
#define pt_szDefCoverPage   lpPTGData->szDefCoverPage       // per-thread default cover page
#define pt_lpMemAllocations lpPTGData->lpMemAllocations     // per-thread memory allocations tracker
#define pt_aDeviceTypes     lpPTGData->aDeviceTypes         // per-thread device types list
#define pt_cDeviceTypes     lpPTGData->cDeviceTypes         // per-thread # of device types
#define pt_aDevices         lpPTGData->aDevices             // per-thread fax devices list
#define pt_cDevices         lpPTGData->cDevices             // per-thread # of fax devices
#define pt_iDeviceIndex     lpPTGData->iDeviceIndex         // per-thread current fax device index
#define pt_aNonTAPIDevices  lpPTGData->aNonTAPIDevices      // per-thread non-TAPI devices array
#define pt_iLastDeviceAdded lpPTGData->iLastDeviceAdded     // per-thread type of last device added
#define pt_hAddModemDlg     lpPTGData->hAddModemDlg         // per-thread AddModem dlg handle
#define pt_hDeviceListDlg   lpPTGData->hDeviceListDlg       // per-thread device list dlg handle
#define pt_lpVdts           lpPTGData->lpVdts               // per-thread TAPI state
#define pt_lpMalloc         lpPTGData->lpMalloc

#endif  // DO_WE_REALLY_NEED_TAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\debug.c ===
// ----------------------------------------------------------------------------
// debug.c
//
// Microsoft At Work Fax Debugging Utilities
//
// Copyright (C) 1993 Microsoft Corporation
// ----------------------------------------------------------------------------
/* Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *      3.17.94         MAPI                            Original source from MAPI mapidbg.c
 *      3.17.94         Yoram Yaacovi           Modifications to overcome compobj.h problems
 *      3.7.94          Yoram Yaacovi           Update to MAPI build 154
 *      12.1.94         Yoram Yaacovi           Added DebugLog()
 *
 ***********************************************************************/

#include <windows.h>
#include <stdio.h>
#include <time.h>
//#include "faxcfg.h"
#include "mapi.h"
#include "mapidbg.h"
#include "mapidefs.h"
#include "mapicode.h"
#ifdef DEBUG

/*
 *
 *      From current\src\mapi\inc\_memcpy.h
 *
 *      MemCopy()
 *
 *      A much safer version of memcpy that checks the value of the byte
 *      count before calling the memcpy() function.  This macro is only built
 *      into the 16 bit non-debug builds.
 */

#ifndef __MEMCPY_H_
#define __MEMCPY_H_

#define MemCopy(_dst,_src,_cb)  memcpy(_dst,_src,(size_t)(_cb))

#endif



#if defined(WIN16) || defined(WIN32)
static BOOL fTraceEnabled       = -1;
static BOOL fLogTraceEnabled    = -1;
static BOOL fAssertLeaks        = -1;

static TCHAR szKeyTraceEnabled[]    = TEXT("DebugTrace");
static TCHAR szKeyLogTraceEnabled[] = TEXT("DebugTraceLog");
static TCHAR szKeyDebugTrap[]       = TEXT("DebugTrap");
static TCHAR szKeyExtendedDebug[]   = TEXT("ExtendedDebug");
static TCHAR szKeyUseVirtual[]      = TEXT("VirtualMemory");
static TCHAR szKeyAssertLeaks[]     = TEXT("AssertLeaks");
static TCHAR szKeyCheckOften[]      = TEXT("CheckHeapOften");
static TCHAR szSectionDebug[]       = TEXT("General");
static TCHAR szDebugIni[]           = TEXT("MAWFDBG.INI");
#endif


// ExtendedDebug --------------------------------------------------------------
BOOL ExtendedDebug(void)
{
        return (GetPrivateProfileInt(szSectionDebug, szKeyExtendedDebug,
                0, szDebugIni));
}

// DebugTrap --------------------------------------------------------------
void DebugTrap(void)
{
        if (GetPrivateProfileInt(szSectionDebug, szKeyDebugTrap,
                0, szDebugIni))

                DebugBreak();
}

// DebugLog --------------------------------------------------------------

void DebugLog(LPSTR szString)
{
        FILE *logfile;

        // open a log file for appending. create if does not exist
        if ((logfile = fopen ("c:\\uilog.txt", "a+")) != NULL)
        {
                fwrite (szString, 1, strlen(szString), logfile);
                fclose(logfile);
        }
}


// DebugOutputFn --------------------------------------------------------------

void DebugOutputFn(char *psz)
{
#if defined(_MAC)

        OutputDebugString(psz);

#else

        char *  pszBeg;
        char *  pszEnd;
        char    szBuf[3];

#if defined(WIN16) || defined(WIN32)
        if (fTraceEnabled == -1)
        {
                fTraceEnabled = GetPrivateProfileInt(szSectionDebug, szKeyTraceEnabled,
                        0, szDebugIni);
        }

        if (!fTraceEnabled)
                return;

        if (fLogTraceEnabled == -1)
        {
                fLogTraceEnabled =
                        GetPrivateProfileInt(szSectionDebug, szKeyLogTraceEnabled, 0, szDebugIni);
        }

#endif

        for (pszBeg = psz; pszBeg && *pszBeg; pszBeg = pszEnd) {
                pszEnd = strchr(pszBeg, '\n');

                if (pszEnd) {
                        MemCopy(szBuf, pszEnd, 3);
                        if (pszEnd > pszBeg && *(pszEnd - 1) != '\r')
                                strcpy(pszEnd, "\r\n");
                        else
                                *(pszEnd + 1) = 0;
                }

                if (fLogTraceEnabled)
                        DebugLog(pszBeg);
                else
                        OutputDebugStringA(pszBeg);

                if (pszEnd) {
                        MemCopy(pszEnd, szBuf, 3);
                        pszEnd += 1;
                }
        }
#endif
}

// DebugTrapFn ----------------------------------------------------------------

#if defined(WIN32) && defined(THREAD_MSG_BOX)

typedef struct {
        char *          sz1;
        char *          sz2;
        UINT            rgf;
        int                     iResult;
} MBContext;

DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
        pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
                pmbc->rgf | MB_SETFOREGROUND);
        return(0);
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
        HANDLE          hThread;
        DWORD           dwThreadId;
        MBContext       mbc;

        mbc.sz1         = sz1;
        mbc.sz2         = sz2;
        mbc.rgf         = rgf;
        mbc.iResult = IDRETRY;

        hThread = CreateThread(NULL, 0,
                (PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &mbc, 0, &dwThreadId);

        if (hThread != NULL) {
                WaitForSingleObject(hThread, INFINITE);
                CloseHandle(hThread);
        }

        return(mbc.iResult);
}
#else
#define MessageBoxFn(sz1, sz2, rgf)             MessageBoxA(NULL, sz1, sz2, rgf)
#endif

int __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
        char    sz[512];
        va_list vl;

        #if defined(WIN16) || defined(WIN32)
        int             id;
        #endif

        strcpy(sz, "++++ MAWF Debug Trap (");
        _strdate(sz + strlen(sz));
        strcat(sz, " ");
        _strtime(sz + strlen(sz));
        strcat(sz, ")\n");
        DebugOutputFn(sz);

        va_start(vl, pszFormat);
        wvsprintfA(sz, pszFormat, vl);
        va_end(vl);

        wsprintfA(sz + strlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

        DebugOutputFn(sz);

        #if defined(DOS)
        _asm { int 3 }
        #endif

        #if defined(WIN16) || defined(WIN32)
        // Hold down control key to prevent MessageBox
        if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
        {
                id = MessageBoxFn(sz, "Microsoft At Work Fax Debug Trap",
                                MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_TASKMODAL |
                                (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3));

                if (id == IDABORT)
                        *((LPBYTE)NULL) = 0;
                else if (id == IDRETRY)
                        DebugBreak();
        }
        #endif

        return(0);
}

// ExtendedDebugTraceFn ---------------------------------------------------------------

int __cdecl ExtendedDebugTraceFn(char *pszFormat, ...)
{
        char    sz[512];
        int             fAutoLF = 0;
        va_list vl;

        if (ExtendedDebug())
        {
                if (*pszFormat == '~') {
                        pszFormat += 1;
                        fAutoLF = 1;
                }

                va_start(vl, pszFormat);
                wvsprintfA(sz, pszFormat, vl);
                va_end(vl);

                if (fAutoLF)
                        strcat(sz, "\n");

                DebugOutputFn(sz);
        }

        return(0);
}

// DebugTraceFn ---------------------------------------------------------------

int __cdecl DebugTraceFn(char *pszFormat, ...)
{
        char    sz[512];
        char    sz1[512];
        int             fAutoLF = 0;
        va_list vl;
        HINSTANCE hInst=NULL; // this really needs to be a parameter

        if (*pszFormat == '~') {
                pszFormat += 1;
                fAutoLF = 1;
        }

        va_start(vl, pszFormat);
        wvsprintfA(sz, pszFormat, vl);
        va_end(vl);

        if (fAutoLF)
                strcat(sz, "\n");

        strcpy(sz1, sz);

        DebugOutputFn(sz1);

        return(0);
}


// SCODE & PropTag decoding ---------------------------------------------------

typedef struct
{
        char *                  psz;
        unsigned long   ulPropTag;
} PT;

typedef struct
{
        char *  psz;
        SCODE   sc;
} SC;

#define Pt(_ptag)       {#_ptag, _ptag}
#define Sc(_sc)         {#_sc, _sc}

#if !defined(DOS)
static PT rgpt[] = {
/*
 * Property types
 */
    Pt(PT_UNSPECIFIED),
    Pt(PT_NULL),
    Pt(PT_I2),
    Pt(PT_LONG),
    Pt(PT_R4),
    Pt(PT_DOUBLE),
    Pt(PT_CURRENCY),
    Pt(PT_APPTIME),
    Pt(PT_ERROR),
    Pt(PT_BOOLEAN),
    Pt(PT_OBJECT),
    Pt(PT_I8),
    Pt(PT_STRING8),
    Pt(PT_UNICODE),
    Pt(PT_SYSTIME),
    Pt(PT_CLSID),
    Pt(PT_BINARY),
    Pt(PT_TSTRING),
    Pt(PT_MV_I2),
    Pt(PT_MV_LONG),
    Pt(PT_MV_R4),
    Pt(PT_MV_DOUBLE),
    Pt(PT_MV_CURRENCY),
    Pt(PT_MV_APPTIME),
    Pt(PT_MV_SYSTIME),
    Pt(PT_MV_STRING8),
    Pt(PT_MV_BINARY),
    Pt(PT_MV_UNICODE),
    Pt(PT_MV_CLSID),
    Pt(PT_MV_I8)
};

#define cpt (sizeof(rgpt) / sizeof(PT))

static SC rgsc[] = {

/* FACILITY_NULL error codes from OLE */

                                        Sc(S_OK),
                                        Sc(S_FALSE),

                                        Sc(E_UNEXPECTED),
                                        Sc(E_NOTIMPL),
                                        Sc(E_OUTOFMEMORY),
                                        Sc(E_INVALIDARG),
                                        Sc(E_NOINTERFACE),
                                        Sc(E_POINTER),
                                        Sc(E_HANDLE),
                                        Sc(E_ABORT),
                                        Sc(E_FAIL),
                                        Sc(E_ACCESSDENIED),

/* General errors (used by more than one MAPI object) */

                                        Sc(MAPI_E_NO_SUPPORT),
                                        Sc(MAPI_E_BAD_CHARWIDTH),
                                        Sc(MAPI_E_STRING_TOO_LONG),
                                        Sc(MAPI_E_UNKNOWN_FLAGS),
                                        Sc(MAPI_E_INVALID_ENTRYID),
                                        Sc(MAPI_E_INVALID_OBJECT),
                                        Sc(MAPI_E_OBJECT_CHANGED),
                                        Sc(MAPI_E_OBJECT_DELETED),
                                        Sc(MAPI_E_BUSY),
                                        Sc(MAPI_E_NOT_ENOUGH_DISK),
                                        Sc(MAPI_E_NOT_ENOUGH_RESOURCES),
                                        Sc(MAPI_E_NOT_FOUND),
                                        Sc(MAPI_E_VERSION),
                                        Sc(MAPI_E_LOGON_FAILED),
                                        Sc(MAPI_E_SESSION_LIMIT),
                                        Sc(MAPI_E_USER_CANCEL),
                                        Sc(MAPI_E_UNABLE_TO_ABORT),
                                        Sc(MAPI_E_NETWORK_ERROR),
                                        Sc(MAPI_E_DISK_ERROR),
                                        Sc(MAPI_E_TOO_COMPLEX),
                                        Sc(MAPI_E_BAD_COLUMN),
                                        Sc(MAPI_E_EXTENDED_ERROR),
                                        Sc(MAPI_E_COMPUTED),

/* MAPI base function and status object specific errors and warnings */

                                        Sc(MAPI_E_END_OF_SESSION),
                                        Sc(MAPI_E_UNKNOWN_ENTRYID),
                                        Sc(MAPI_E_MISSING_REQUIRED_COLUMN),

/* Property specific errors and warnings */

                                        Sc(MAPI_E_BAD_VALUE),
                                        Sc(MAPI_E_INVALID_TYPE),
                                        Sc(MAPI_E_TYPE_NO_SUPPORT),
                                        Sc(MAPI_E_UNEXPECTED_TYPE),
                                        Sc(MAPI_E_TOO_BIG),

                                        Sc(MAPI_W_ERRORS_RETURNED),

/* Table specific errors and warnings */

                                        Sc(MAPI_E_UNABLE_TO_COMPLETE),
                                        Sc(MAPI_E_TABLE_EMPTY),
                                        Sc(MAPI_E_TABLE_TOO_BIG),
                                        Sc(MAPI_E_INVALID_BOOKMARK),

                                        Sc(MAPI_W_POSITION_CHANGED),
                                        Sc(MAPI_W_APPROX_COUNT),

/* Transport specific errors and warnings */

                                        Sc(MAPI_E_WAIT),
                                        Sc(MAPI_E_CANCEL),
                                        Sc(MAPI_E_NOT_ME),

                                        Sc(MAPI_W_CANCEL_MESSAGE),

/* Message Store, Folder, and Message specific errors and warnings */

                                        Sc(MAPI_E_CORRUPT_STORE),
                                        Sc(MAPI_E_NOT_IN_QUEUE),
                                        Sc(MAPI_E_NO_SUPPRESS),
                                        Sc(MAPI_E_COLLISION),
                                        Sc(MAPI_E_NOT_INITIALIZED),
                                        Sc(MAPI_E_NON_STANDARD),
                                        Sc(MAPI_E_NO_RECIPIENTS),
                                        Sc(MAPI_E_SUBMITTED),
                    Sc(MAPI_E_HAS_FOLDERS),
                    Sc(MAPI_E_HAS_MESSAGES),
                    Sc(MAPI_E_FOLDER_CYCLE),

/* Address Book specific errors and warnings */

                                        Sc(MAPI_E_AMBIGUOUS_RECIP)

                                        };

#define csc (sizeof(rgsc) / sizeof(SC))
#endif

char * __cdecl
SzDecodeScodeFn(SCODE sc)
{
        static char rgch[64];

        #if !defined(DOS)
        int isc;
        for (isc = 0; isc < csc; ++isc)
                if (sc == rgsc[isc].sc)
                        return rgsc[isc].psz;
        #endif

        wsprintfA (rgch, "%08lX", sc);
        return rgch;
}


#else   // no DEBUG

typedef long SCODE;
// need to define empty functions for DEF file resolution
BOOL ExtendedDebug(void)
{
        return FALSE;
}
void DebugTrap(void)
{
}
int __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
        return 0;
}
int __cdecl DebugTraceFn(char *pszFormat, ...)
{
        return 0;
}
int __cdecl ExtendedDebugTraceFn(char *pszFormat, ...)
{
        return 0;
}
char * __cdecl SzDecodeScodeFn(SCODE sc)
{
        return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\debug.h ===
/*
 -  DEBUG.H
 -
 *      Debug-related definitions
 *
 *		Yoram Yaacovi, 11/93
 *		Taken from MAPI 1.0 sources
 *
 */

/*
 *	 Trace Macros ------------------------------------------------------------
 *	
 *		DebugTrace			Use for arbitrary formatted output. It 
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceResult	Shorthand for error tracing with an
 *							HRESULT. Arguments are the name of the
 *							function (not quoted) and the HRESULT.
 *		DebugTraceSc		Shorthand for error tracing with an
 *							SCODE. Arguments are the name of the
 *							function (not quoted) and the SCODE.
 *		DebugTraceArg		Shorthand for invalid parameter
 *							tracing. Arguments are the name of the
 *							function (not quoted) and a quoted
 *							string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define SzDecodeScode(_sc)	SzDecodeScodeFn(_sc)
#else
#define IFTRACE(x)			0
#define DebugTrace			1?0:DebugTraceFn
#define SzDecodeScode(_sc)	(0)
#endif

#define DebugTraceResult(f,hr)							IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)								IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)								IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define	DebugTraceLine()								IFTRACE(DebugTraceFn("File %s, Line %i	\n",__FILE__,__LINE__))

#define TraceSz(psz)									IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)								IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)								IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)							IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)						IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
/*
 *	 Assert Macros ---------------------------------------------------------
 *	
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.  OK'ing an assert traps
 *						into the debugger.
 *	
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *	
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 *	
 *		NF asserts		A NF (Non-Fatal) assert works like an Assert(), but
 *						continues instead of trapping into the debugger when
 *						OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()											IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)										IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)									IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)								IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)							IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))

#define Assert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)									IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)								IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)							IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))

#define SideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)								((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)							((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)						((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)

#define NFAssert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)								IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)							IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)				IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))

#define NFSideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)							((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)						((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)			((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)

#if defined (DEBUG)
#define	DEBUG_TRACE	DebugTraceFn
#define	EXTENDED_DEBUG_TRACE ExtendedDebugTraceFn
#else
#define DEBUG_TRACE
#define EXTENDED_DEBUG_TRACE
#endif

// Prototypes for debug functions in debug.c
#if !defined (__MAPIDBG_H_)
void			DebugTrap(void);
int __cdecl		DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int __cdecl		DebugTraceFn(char *pszFormat, ...);
int __cdecl		ExtendedDebugTraceFn(char *pszFormat, ...);
char * __cdecl	SzDecodeScodeFn(SCODE sc);
#endif
BOOL ExtendedDebug(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\ootid.c ===
/***********************************************************************
 *
 *  OOTID.C
 *
 *      Microsoft At Work Fax Address Book OneOff Template ID  object
 *      This file contains the code for implementing the Microsoft At Work Fax AB
 *      TID object.
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 *      Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *                      MAPI                Original source from MAPI(154) sample AB Provider
 *      3.7.94          Yoram Yaacovi       Modifications to make it an At Work Fax ABP
 *      4.2.94          Yoram Yaacovi       Update to MAPI and sample AB 157
 *      8.7.94          Yoram Yaacovi       Update to MAPI and sample AB 304
 *      8.24.94         Yoram Yaacovi       Added OpenProperty and Release to support ddlbx and buttons in the one-off template
 *
 ***********************************************************************/

#include "faxab.h"

/*
 *  External functions
 */

HRESULT
NewABUserButton(LPROOT, ULONG, ULONG, ULONG, LPMAPICONTROL FAR *);
void LoadIniParams(void);

/*
 *  OOTID jump table is defined here...
 */

static const OOTID_Vtbl vtblOOTID =
{
    (OOTID_QueryInterface_METHOD *)     ABU_QueryInterface,
    (OOTID_AddRef_METHOD *)             WRAP_AddRef,
    OOTID_Release,
    (OOTID_GetLastError_METHOD *)       WRAP_GetLastError,
    OOTID_SaveChanges,
    (OOTID_GetProps_METHOD *)           WRAP_GetProps,
    (OOTID_GetPropList_METHOD *)        WRAP_GetPropList,
    OOTID_OpenProperty,
    OOTID_SetProps,
    (OOTID_DeleteProps_METHOD *)        WRAP_DeleteProps,
    (OOTID_CopyTo_METHOD *)             WRAP_CopyTo,
    (OOTID_CopyProps_METHOD *)          WRAP_CopyProps,
    (OOTID_GetNamesFromIDs_METHOD *)    WRAP_GetNamesFromIDs,
    (OOTID_GetIDsFromNames_METHOD *)    WRAP_GetIDsFromNames,
};

// enum and property tag array for getting the properties
enum {  ivalootidPR_COUNTRY_ID,
        ivalootidPR_AREA_CODE,
        ivalootidPR_TEL_NUMBER,
        ivalootidPR_EMAIL_ADDRESS,
        ivalootidPR_FAX_CP_NAME,
        ivalootidMax };

static const SizedSPropTagArray(ivalootidMax,pta)=
{
    ivalootidMax,
    {
        PR_COUNTRY_ID,
        PR_AREA_CODE_A,
        PR_TEL_NUMBER_A,
        PR_EMAIL_ADDRESS_A,
        PR_FAX_CP_NAME_A,
    }
};


/*************************************************************************
 *
 -  HrNewOOTID
 -
 *  Creates the OOTID object associated with a mail user.
 *
 *
 */
HRESULT
HrNewOOTID( LPMAPIPROP *        lppMAPIPropNew,
            ULONG               cbTemplateId,
            LPENTRYID           lpTemplateId,
            ULONG               ulTemplateFlags,
            LPMAPIPROP          lpPropData,
            LPABLOGON           lpABPLogon,
            LPCIID              lpInterface,
            HINSTANCE           hLibrary,
            LPALLOCATEBUFFER    lpAllocBuff,
            LPALLOCATEMORE      lpAllocMore,
            LPFREEBUFFER        lpFreeBuff,
            LPMALLOC            lpMalloc
           )
{
    LPOOTID         lpOOTID;
    SCODE           sc;
    HRESULT         hResult = hrSuccess;
    LPMAILUSER      lpABOOUser = NULL;
    ULONG           ulObjType;
    LPSPropValue    lpspv=NULL;
    ULONG           ulcValues;
    PARSEDTELNUMBER sParsedFaxAddr={{TEXT("")},{TEXT("")},{TEXT("")},{TEXT("")}};

    /*
     *      Create the one-off object corresponding to the template id
     */
    hResult = HrNewFaxOOUser( &lpABOOUser,
                              &ulObjType,
                              cbTemplateId,
                              lpTemplateId,
                              lpABPLogon,
                              lpInterface,
                              hLibrary,
                              lpAllocBuff,
                              lpAllocMore,
                              lpFreeBuff,
                              lpMalloc
                             );
    if (HR_FAILED(hResult))
    {
            goto err;
    }

    /*
     *      Allocate space for the OOTID structure
     */
    sc = lpAllocBuff(SIZEOF(OOTID), (LPVOID *) & lpOOTID);
    if (FAILED(sc))
    {
        DebugTrace("NewOOTID() - AllocBuffer failed %s\n",SzDecodeScode(sc));
        hResult = ResultFromScode (sc);
        goto err;
    }

    /*
     *  Initialize the OOTID structure
     */

    lpOOTID->lpVtbl       = &vtblOOTID;
    lpOOTID->lcInit       = 1;
    lpOOTID->hResult      = hrSuccess;
    lpOOTID->idsLastError = 0;
    lpOOTID->hLibrary     = hLibrary;
    lpOOTID->lpAllocBuff  = lpAllocBuff;
    lpOOTID->lpAllocMore  = lpAllocMore;
    lpOOTID->lpFreeBuff   = lpFreeBuff;
    lpOOTID->lpMalloc     = lpMalloc;
    lpOOTID->lpABLogon    = lpABPLogon;
    lpOOTID->lpPropData   = lpPropData;
    lpOOTID->lpABUser     = lpABOOUser;
    lstrcpy(lpOOTID->szPreviousCPName, TEXT(""));
    /*
     *      First time creation - must set the address type and template id.
     */
    if (ulTemplateFlags==FILL_ENTRY)
    {
        ULONG ulCount;
        LPSPropValue lpspv = NULL;
        /*
         *  Copy all the properties from my object to the propdata
         *      These properties were set on the oouser object when it was created
         *      (by HrNewFaxOOUser calling into oouser.c)
         */
        hResult = lpABOOUser->lpVtbl->GetProps( lpABOOUser,
                                                NULL,
                                                0,      /* ansi */
                                                &ulCount,
                                                &lpspv
                                               );

        if (FAILED(hResult))
                goto err;

        hResult = lpPropData->lpVtbl->SetProps( lpPropData,
                                                ulCount,
                                                lpspv,
                                                NULL
                                               );

        lpFreeBuff(lpspv);

        if (FAILED(hResult))
                goto err;
    }

    // entry already exists in the PAB
    else
    {
        LPTSTR  lpszCanonical=NULL;

        /*
         *  Get the properties that make up the email address from the
         *  mapiprop object
         */
        hResult = lpOOTID->lpPropData->lpVtbl->GetProps( lpOOTID->lpPropData,
                                                         (LPSPropTagArray) &pta,
                                                         0,      /* ansi */
                                                         &ulcValues,
                                                         &lpspv
                                                        );

        // see if the tel number component of the email address exists on the object
        // if it doesn't, and there is a PR_EMAIL_ADDRESS,
        // create the address components from the email address
        if ( (PROP_TYPE(lpspv[ivalootidPR_TEL_NUMBER].ulPropTag) == PT_ERROR) &&
             (PROP_TYPE(lpspv[ivalootidPR_EMAIL_ADDRESS].ulPropTag) != PT_ERROR)
            )
        {
#ifdef UNICODE
            WCHAR szTmp[ MAX_PATH ];
            CHAR  szAnsiTelNumber[ 100 ];
            CHAR  szAnsiAreaCode[ 5 ];

            szTmp[0] = 0;
            MultiByteToWideChar( CP_ACP, 0, lpspv[ivalootidPR_EMAIL_ADDRESS].Value.lpszA, -1, szTmp, ARRAYSIZE(szTmp) );
            DecodeFaxAddress(szTmp, &sParsedFaxAddr);
#else
            DecodeFaxAddress(lpspv[ivalootidPR_EMAIL_ADDRESS].Value.LPSZ, &sParsedFaxAddr);
#endif

            lpspv[ivalootidPR_TEL_NUMBER].ulPropTag  = PR_TEL_NUMBER_A;
#ifdef UNICODE
            szAnsiTelNumber[0] = 0;
            WideCharToMultiByte( CP_ACP, 0, sParsedFaxAddr.szTelNumber, -1, szAnsiTelNumber, ARRAYSIZE(szAnsiTelNumber), NULL, NULL );
            lpspv[ivalootidPR_TEL_NUMBER].Value.lpszA = szAnsiTelNumber;
#else
            lpspv[ivalootidPR_TEL_NUMBER].Value.LPSZ = sParsedFaxAddr.szTelNumber;
#endif

            lpspv[ivalootidPR_AREA_CODE].ulPropTag  = PR_AREA_CODE_A;
#ifdef UNICODE
            szAnsiAreaCode[0] = 0;
            WideCharToMultiByte( CP_ACP, 0, sParsedFaxAddr.szAreaCode, -1, szAnsiAreaCode, ARRAYSIZE(szAnsiAreaCode), NULL, NULL );
            lpspv[ivalootidPR_AREA_CODE].Value.lpszA = szAnsiAreaCode;
#else
            lpspv[ivalootidPR_AREA_CODE].Value.LPSZ = sParsedFaxAddr.szAreaCode;
#endif

            // CHECK: may need to get country id from country code
            lpspv[ivalootidPR_COUNTRY_ID].ulPropTag = PR_COUNTRY_ID;
#ifdef UNICODE
            lpspv[ivalootidPR_COUNTRY_ID].Value.l   = (DWORD) wcstol(sParsedFaxAddr.szCountryCode,NULL,0);
#else
            lpspv[ivalootidPR_COUNTRY_ID].Value.l   = (DWORD) atol(sParsedFaxAddr.szCountryCode);
#endif

        }

        // save the starting (previous) cover page name, so that at SaveChanges time,
        // I can see if the user changed it
        if (PROP_TYPE(lpspv[ivalootidPR_FAX_CP_NAME].ulPropTag) != PT_ERROR)
        {
#ifdef UNICODE
            lpOOTID->szPreviousCPName[0] = 0;
            MultiByteToWideChar( CP_ACP, 0, lpspv[ivalootidPR_FAX_CP_NAME].Value.lpszA, -1, lpOOTID->szPreviousCPName, ARRAYSIZE(lpOOTID->szPreviousCPName) );
#else
            lstrcpy(lpOOTID->szPreviousCPName, lpspv[ivalootidPR_FAX_CP_NAME].Value.LPSZ);
#endif
        }


        /* free the buffer */
        lpOOTID->lpFreeBuff(lpspv);

        if (HR_FAILED(hResult))
        {
            DebugTrace("HrNewOOTID: SetProps failed %s\n",SzDecodeScode(GetScode(hResult)));
            goto err;
        }

    }

    /*
     *  AddRef lpPropData so we can use it after we return
     */

    (void)lpPropData->lpVtbl->AddRef(lpPropData);

    InitializeCriticalSection(&lpOOTID->cs);

    *lppMAPIPropNew = (LPVOID) lpOOTID;

out:

    DebugTraceResult(HrNewOOTID, hResult);
    return hResult;

err:

    if (lpABOOUser)
        lpABOOUser->lpVtbl->Release(lpABOOUser);

    lpFreeBuff(lpOOTID);
    goto out;

}

/*********************************************************************
 *********************************************************************
 *
 *  The OOTID IMAPIProp methods
 *
 */

STDMETHODIMP_(ULONG) OOTID_Release(LPOOTID lpOOTID)
{
    LONG lcInit;

    /*
     * Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpOOTID, sizeof(OOTID)))
    {
        /*
         *  I'm not looking at an object that I expect to be.
         */
        return 1;
    }

    /*
     *  Check to see that it's TIDs vtbl
     */
    if (lpOOTID->lpVtbl != &vtblOOTID)
    {
        /*
         *  It's big enough but it's got the wrong vtbl.
         */
        return 1;
    }

    /*
     *  Release the mapi property object
     */
    lpOOTID->lpPropData->lpVtbl->Release( lpOOTID->lpPropData );

    EnterCriticalSection(&lpOOTID->cs);
    lcInit = --lpOOTID->lcInit;
    LeaveCriticalSection(&lpOOTID->cs);

    if (lcInit == 0)
    {
        /*
         *  Release the ABUser object
         */
        lpOOTID->lpABUser->lpVtbl->Release( lpOOTID->lpABUser );

        /*
         *  Clean up the critical section
         */
        DeleteCriticalSection(&lpOOTID->cs);

        /*
         * Need to free the object
         */
        lpOOTID->lpFreeBuff(lpOOTID);
        return 0;
    }

    return lcInit;
}

/*****************************************************************************
     SetProps
 *****************************************************************************/
STDMETHODIMP
OOTID_SetProps( LPOOTID lpOOTID,
                ULONG cValues,
                LPSPropValue lpPropArray,
                LPSPropProblemArray * lppProblems
               )
{
    enum {  ivalspPR_DISPLAY_NAME = 0,
            ivalspMax };
    ULONG i;
    SPropValue spv[ivalspMax];
    HRESULT hResult=hrSuccess;

    /* Validate the object */

    if ( FBadUnknown(lpOOTID) ||
         IsBadWritePtr(lpOOTID, SIZEOF(lpOOTID)) ||
         IsBadReadPtr(lpOOTID->lpVtbl, offsetof(OOTID_Vtbl, SetProps)) ||
         OOTID_SetProps != lpOOTID->lpVtbl->SetProps
        )
    {
        DebugTrace("OOTID_SetProps -> E_INVALIDARG\n");
        return ResultFromScode(E_INVALIDARG);
    }

    for (i=0; i < cValues; i++)
    {
        // see if one of the set properties is PR_FAX_CP_NAME_A
        if (lpPropArray[i].ulPropTag == PR_FAX_CP_NAME_A)
        {
            // The cover page name is copied into the display name
            spv[ivalspPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME_A;
            spv[ivalspPR_DISPLAY_NAME].Value.lpszA = lpPropArray[i].Value.lpszA;
            // set PR_DISPLAY_NAME
            hResult = lpOOTID->lpPropData->lpVtbl->SetProps( lpOOTID->lpPropData,
                                                             ivalspMax,
                                                             spv,
                                                             NULL
                                                            );

            if (HR_FAILED(hResult))
            {
                DebugTrace("OOTID_SetProps: SetProps on PR_DISPLAY_NAME failed %s\n",
                                        SzDecodeScode(GetScode(hResult)));
                goto out;
            }

        }
    }

out:
    // now set the properties I was asked to save
    return hResult=lpOOTID->lpPropData->lpVtbl->SetProps( lpOOTID->lpPropData,
                                                          cValues,
                                                          lpPropArray,
                                                          lppProblems
                                                         );
}
/*
 *      These properties are used and set by the one off dialog.
 *  These properties combined make up a valid email address and display name
 */

// enum and property tag array for getting the properties
enum {  ivalootidgPR_DISPLAY_NAME = 0,
        ivalootidgPR_FAX_CP_NAME,
        ivalootidgPR_COUNTRY_ID,
        ivalootidgPR_AREA_CODE,
        ivalootidgPR_TEL_NUMBER,
        ivalootidgPR_GIVEN_NAME,
        ivalootidgPR_SURNAME,
        ivalootidgPR_EMAIL_ADDRESS,
        ivalootidgMax };

static const SizedSPropTagArray(ivalootidgMax,ptag)=
{
    ivalootidgMax,
    {
        PR_DISPLAY_NAME_A,
        PR_FAX_CP_NAME_A,
        PR_COUNTRY_ID,
        PR_AREA_CODE_A,
        PR_TEL_NUMBER_A,
        PR_GIVEN_NAME_A,
        PR_SURNAME_A,
        PR_EMAIL_ADDRESS_A,
    }
};

// enum for setting the created properties
enum {  /*ivalootidsPR_DISPLAY_NAME = 0,
        ivalootidsPR_FAX_CP_NAME,*/
        ivalootidsPR_EMAIL_ADDRESS = 0,
        ivalootidsPR_PRIMARY_FAX_NUMBER,
        ivalootidsMax };


/*****************************************************************************
     SaveChanges
 *****************************************************************************/
STDMETHODIMP
OOTID_SaveChanges( LPOOTID lpOOTID,
                   ULONG   ulFlags
                  )
{
    HRESULT         hResult;
    LPSPropValue    lpspv=NULL;
    SPropValue      spv[ivalootidsMax];
    ULONG           ulcValues;
    BOOL            bDispName=FALSE;
    BOOL            bFirstName=FALSE;
    BOOL            bSurName=FALSE;
    BOOL            bCPName=FALSE;
    PARSEDTELNUMBER sParsedFaxAddr={{TEXT("")},{TEXT("")},{TEXT("")},{TEXT("")}};
    ULONG           dwCountryCode=0;
    TCHAR           szEncodedFaxAddress[CANONICAL_NUMBER_SIZE];
    LPSTR           lpszCanonical=NULL;
#ifdef UNICODE
    CHAR            szAnsiFaxAddr[CANONICAL_NUMBER_SIZE];
#endif

    /*
     *  Check to see if it is big enough to be my object
     */
    if (IsBadReadPtr(lpOOTID, SIZEOF(OOTID)))
    {
        /*
         *  Not big enough
         */
        return MakeResult(E_INVALIDARG);
    }

    /*
     *  Check to see that it's OOTIDs vtbl
     */
    if (lpOOTID->lpVtbl != &vtblOOTID)
    {
        /*
         *  vtbl not ours
         */
        return MakeResult(E_INVALIDARG);
    }


    /*
     *  Get the properties that make up the email address from the
     *  mapiprop object
     */
    hResult = lpOOTID->lpPropData->lpVtbl->GetProps( lpOOTID->lpPropData,
                                                     (LPSPropTagArray) &ptag,
                                                     0,      /* ansi */
                                                     &ulcValues,
                                                     &lpspv
                                                    );

    /*
     *  Abort in failure. Nothing to do without an email address
     */
    if (FAILED(hResult))
    {
        DebugTrace("OOTID_SaveChanges: GetProps failed %s\n",SzDecodeScode(GetScode(hResult)));
        goto err;
    }

    /***************************/
    /****** display name *******/
    /***************************/

    /*
     *      Need to make the display name
     *      I believe there must be either a PR_DISPLAY_NAME or a PR_FAX_CP_NAME. If there isn't,
     *      I'll make one out of the first and last name
     */

#ifdef OLD_CODE
    // Set the tags
    spv[ivalootidsPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME_A;
    spv[ivalootidsPR_FAX_CP_NAME].ulPropTag  = PR_FAX_CP_NAME_A;

    // Set the props to the exact value I got from GetProps
    spv[ivalootidsPR_DISPLAY_NAME_A].Value.lpszA =  lpspv[ivalootidgPR_DISPLAY_NAME].Value.lpszA;
    spv[ivalootidsPR_FAX_CP_NAME_A].Value.lpszA  =  lpspv[ivalootidgPR_FAX_CP_NAME].Value.lpszA;

    if ( (PROP_TYPE(lpspv[ivalootidgPR_DISPLAY_NAME_A].ulPropTag) != PT_ERROR) &&
         lstrlenA(lpspv[ivalootidgPR_DISPLAY_NAME].Value.lpszA)
        )
    {
        bDispName = TRUE;
    }

    if ( (PROP_TYPE(lpspv[ivalootidgPR_FAX_CP_NAME].ulPropTag) != PT_ERROR) &&
         lstrlenA(lpspv[ivalootidgPR_FAX_CP_NAME].Value.lpszA))
    {
        bCPName = TRUE;
    }

    // Can't find PR_GIVEN_NAME anywhere in the MAPI or Mail world for now
    if ( (PROP_TYPE(lpspv[ivalootidgPR_GIVEN_NAME].ulPropTag) != PT_ERROR) &&
         lstrlenA(lpspv[ivalootidgPR_GIVEN_NAME].Value.lpszA))
    {
        bFirstName = TRUE;
    }

    if ( (PROP_TYPE(lpspv[ivalootidgPR_SURNAME].ulPropTag) != PT_ERROR) &&
         lstrlenA(lpspv[ivalootidgPR_SURNAME].Value.lpszA))
    {
        bSurName = TRUE;
    }

#ifdef EXTENDED_DEBUG
    {
        TCHAR msg[256];

        wsprintf(msg, TEXT("Display name: %s\nCover page name: %s\nGiven name: %s\nSurname: %s\n"),
                         (bDispName ? lpspv[ivalootidgPR_DISPLAY_NAME].Value.LPSZ : TEXT("")),
                         (bCPName ? lpspv[ivalootidgPR_FAX_CP_NAME].Value.LPSZ : TEXT("")),
                         (bFirstName ? lpspv[ivalootidgPR_GIVEN_NAME].Value.LPSZ : TEXT("")),
                         (bSurName ? lpspv[ivalootidgPR_SURNAME].Value.LPSZ : TEXT("")));

        MessageBox(HWND_DESKTOP, msg, TEXT("Debug Message"), MB_OK);

    }
#endif

    /*
            The cases:

            (1) No PR_DISPLAY_NAME, but there is PR_GIVEN_NAME or PR_SURNAME: this is the
                creation of the entry, and the user entered first/last name in addition
                    to cover page name. Don't override PR_DISPLAY_NAME with PR_FAX_CP_NAME. Exchange
                    will use PR_GIVEN_NAME and PR_SURNAME to create PR_DISPLAY_NAME
            (2)     No PR_DISPLAY_NAME, and also PR_GIVEN_NAME or PR_SURNAME: this is the
                creation of the entry, and the user did not enter first/last name.
                Override PR_DISPLAY_NAME with PR_FAX_CP_NAME.
            (3) There is a PR_DISPLAY_NAME, and the user has changed the PR_FAX_CP_NAME: this
                is not a first time entry. The user selected to edit the template, and changed
                    the cover page name. We are assuming he wants to reflect these changes into
                    the display name. There were some CompuServe complaints on not doing this.
            (4) There is a PR_DISPLAY_NAME, and the user did not change the PR_FAX_CP_NAME: this
                is not a first time entry. The user selected to edit the template, but did not
                    change the cover page name. We are not overriding the display name in this
                    case, thus providing a way for the user to have a display name different from
                    the cover page name
    */

    if (!bDispName)
    {
        if (bFirstName || bSurName)
        // (1)
        {
        }
        else
        // (2)
        {
            // The cover page name is copied into the display name
            spv[ivalootidsPR_DISPLAY_NAME].Value.lpszA =
                    lpspv[ivalootidgPR_FAX_CP_NAME].Value.lpszA;
        }

    }
    else
    {
#ifdef UNICODE
        CHAR szAnsiPrevName[ MAX_PATH ];

        szAnsiPrevName[0] = 0;
        WideCharToMultiByte( CP_ACP, 0, lpOOTID->szPreviousName, -1, szAnsiPrevName, ARRAYSIZE(szAnsiPrevName), NULL, NULL );
        if (lstrcmpA(lpspv[ivalootidgPR_FAX_CP_NAME_A].Value.lpszA, szAnsiPrevName))
#else
        if (lstrcmp(lpspv[ivalootidgPR_FAX_CP_NAME_A].Value.lpszA, lpOOTID->szPreviousCPName))
#endif
        // (3)
        {
            // The cover page name is copied into the display name
            spv[ivalootidsPR_DISPLAY_NAME].Value.lpszA =
                    lpspv[ivalootidgPR_FAX_CP_NAME].Value.lpszA;
        }
        else
        // (4)
        {
        }
    }
#endif

    /***************************/
    /****** email address ******/
    /***************************/

    // Now do the email address
    // initialize the email address prop value
    spv[ivalootidsPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS_A;

    // if there is already an email address, and no fax number, this entry
    // is not created from the UI (which requires a fax number)
    // Generate the address components from the email address
    if ( (PROP_TYPE(lpspv[ivalootidgPR_EMAIL_ADDRESS].ulPropTag) != PT_ERROR) &&
         (lpspv[ivalootidgPR_EMAIL_ADDRESS].Value.lpszA) &&
         (lstrlenA(lpspv[ivalootidgPR_EMAIL_ADDRESS].Value.lpszA)) &&
         (PROP_TYPE(lpspv[ivalootidgPR_TEL_NUMBER].ulPropTag) == PT_ERROR)
        )
    {
        spv[ivalootidsPR_EMAIL_ADDRESS].Value.lpszA =
                lpspv[ivalootidgPR_EMAIL_ADDRESS].Value.lpszA;
    }
    // no email address. must compute from properties.
    else
    {
        // Is there a fax number ?
        if ( (PROP_TYPE(lpspv[ivalootidgPR_TEL_NUMBER].ulPropTag) != PT_ERROR) &&
             (lpspv[ivalootidgPR_TEL_NUMBER].Value.lpszA) &&
             (lstrlenA(lpspv[ivalootidgPR_TEL_NUMBER].Value.lpszA))
            )
        {
            // truncate if necessary. note that the MAPI dialog should limit the user
            // to this number of characters anyway
#ifdef UNICODE
            sParsedFaxAddr.szTelNumber[0] = 0;
            MultiByteToWideChar( CP_ACP, 0,
                                 lpspv[ivalootidgPR_TEL_NUMBER].Value.lpszA, -1,
                                 sParsedFaxAddr.szTelNumber,
                                 ARRAYSIZE(sParsedFaxAddr.szTelNumber)
                                );
#else
            lstrcpyn( sParsedFaxAddr.szTelNumber,
                      lpspv[ivalootidgPR_TEL_NUMBER].Value.lpszA,
                      ARRAYSIZE(sParsedFaxAddr.szTelNumber)
                     );
#endif
        }
        else
        {
            // must have at least a fax number
            // this field is required in my MAPI dialog, so I should never get here
            DebugTrace("OOTID_SaveChanges: No PR_FAX_NUMBER (or invalid) on the object\n");
            goto err;
        }

        // Country Code
        if (PROP_TYPE(lpspv[ivalootidgPR_COUNTRY_ID].ulPropTag) != PT_ERROR)
        {
            if (!GetCountryCode(lpspv[ivalootidgPR_COUNTRY_ID].Value.ul, &dwCountryCode))
            {
                // Use none
                dwCountryCode = 0;
            }

#ifdef UNICODE
            {
                CHAR szTemp[ARRAYSIZE(sParsedFaxAddr.szCountryCode)];

                itoa(dwCountryCode, szTemp, COUNTRY_CODE_SIZE);
                MultiByteToWideChar( CP_ACP, 0,
                                     szTemp, -1,
                                     sParsedFaxAddr.szCountryCode,
                                     ARRAYSIZE(sParsedFaxAddr.szCountryCode)
                                    );
            }
#else
            itoa(dwCountryCode, sParsedFaxAddr.szCountryCode, COUNTRY_CODE_SIZE);
#endif

        }

        // Area Code
        if ( (PROP_TYPE(lpspv[ivalootidgPR_AREA_CODE].ulPropTag) != PT_ERROR) &&
             (lpspv[ivalootidgPR_AREA_CODE].Value.lpszA)
            )
        {
            // if we ended up with a 0 as the area code (error or internal extension,
            // this won't be a canonical number and I don't need the area code.
            // truncate if necessary
            if (dwCountryCode != 0)
            {
#ifdef UNICODE
                sParsedFaxAddr.szAreaCode[0] = 0;
                MultiByteToWideChar( CP_ACP, 0,
                                     lpspv[ivalootidgPR_AREA_CODE].Value.lpszA,
                                     -1,
                                     sParsedFaxAddr.szAreaCode,
                                     ARRAYSIZE(sParsedFaxAddr.szAreaCode)
                                    );
#else
                lstrcpyn( sParsedFaxAddr.szAreaCode,
                          lpspv[ivalootidgPR_AREA_CODE].Value.LPSZ,
                          ARRAYSIZE(sParsedFaxAddr.szAreaCode)
                         );
#endif
            }

        }

        // Construct the canonical number from the components
        EncodeFaxAddress(szEncodedFaxAddress, &sParsedFaxAddr);

#ifdef UNICODE
        szAnsiFaxAddr[0] = 0;
        WideCharToMultiByte( CP_ACP, 0, szEncodedFaxAddress, -1, szAnsiFaxAddr, ARRAYSIZE(szAnsiFaxAddr), NULL, NULL );
        spv[ivalootidsPR_EMAIL_ADDRESS].Value.lpszA = szAnsiFaxAddr;
#else
        spv[ivalootidsPR_EMAIL_ADDRESS].Value.LPSZ = szEncodedFaxAddress;
#endif

    }

    // now use the same fax number, but w/o the mailbox, to set the
    // primary fax property on the telephone pane
    spv[ivalootidsPR_PRIMARY_FAX_NUMBER].ulPropTag = PR_PRIMARY_FAX_NUMBER_A;

    // don't want the mailbox for this
    lpszCanonical = _mbsrchr(spv[ivalootidsPR_EMAIL_ADDRESS].Value.lpszA, '+');
    if (lpszCanonical)
        spv[ivalootidsPR_PRIMARY_FAX_NUMBER].Value.lpszA = lpszCanonical;
    else
        spv[ivalootidsPR_PRIMARY_FAX_NUMBER].Value.lpszA = "";

    /***************************/
    /******   toll list   ******/
    /***************************/

    /* set the email address property value */
    hResult= lpOOTID->lpPropData->lpVtbl->SetProps( lpOOTID->lpPropData,
                                                    ivalootidsMax,
                                                    spv,
                                                    NULL
                                                   );

    if (HR_FAILED(hResult))
    {
            DebugTrace("OOTID_SaveChanges: SetProps failed %s\n",SzDecodeScode(GetScode(hResult)));
            goto err;
    }

    hResult = lpOOTID->lpPropData->lpVtbl->SaveChanges( lpOOTID->lpPropData,
                                                        ulFlags
                                                       );

err:
    /* free the buffer */
    lpOOTID->lpFreeBuff(lpspv);

    DebugTraceResult(OOTID_SaveChanges,hResult);
    return hResult;
}

/*
 -  OOTID_OpenProperty
 -
 *  This is needed to support the countries table and dial helper button on the one-off
 *      template. If the one-off template would only have edit controls nad checkboxes, I
 *      could call the wrapper object OpenProperty.
 *
 */

STDMETHODIMP
OOTID_OpenProperty( LPOOTID     lpOOTID,
                    ULONG       ulPropTag,
                    LPCIID      lpiid,
                    ULONG       ulInterfaceOptions,
                    ULONG       ulFlags,
                    LPUNKNOWN * lppUnk
                   )
{

    HRESULT hResult;

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpOOTID, SIZEOF(OOTID)))
    {
        /*
         *  No vtbl found
         */
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Check to see that it's TIDs vtbl
     */
    if (lpOOTID->lpVtbl != &vtblOOTID)
    {
        /*
         *  It's big enough but it's got the wrong vtbl.
         */
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Don't want to check any other parameters here.
     *  Calls down to wrapped objects will do this for
     *  me.
     */

    switch (ulPropTag)
    {
    // For now, I just call the underlying (my) user object method to handle, which
    // means the template ID does not do anything.

    case PR_DETAILS_TABLE:
    case PR_DDLBX_COUNTRIES_TABLE:
    case PR_DIAL_HELPER_BUTTON:
    {
        hResult =  lpOOTID->lpABUser->lpVtbl->OpenProperty(
                                lpOOTID->lpABUser,
                                ulPropTag,
                                lpiid,
                                ulInterfaceOptions,
                                ulFlags,
                                lppUnk);
        break;

    }

    default:
    {
        hResult =  lpOOTID->lpPropData->lpVtbl->OpenProperty(
                                lpOOTID->lpPropData,
                                ulPropTag,
                                lpiid,
                                ulInterfaceOptions,
                                ulFlags,
                                lppUnk);
        break;
    }
    }

    DebugTraceResult(OOTID_OpenProperty, hResult);
    return hResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\ootid.h ===
/***********************************************************************
 *
 *  _OOTID.H
 *
 *  Header file for code in OOTID.C
 *
 *  Copyright 1992, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

//
//  Function prototypes
//

#undef	INTERFACE
#define INTERFACE	struct _OOTID

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, OOTID_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, OOTID_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(OOTID_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _OOTID {

    const OOTID_Vtbl * lpVtbl;

    FAB_Wrapped;
    
    /*
     *  Private data
     */

	// The underlying one-off user object
    LPMAILUSER  lpABUser;

	// the previous (starting) cover page name
	TCHAR szPreviousCPName[256];

} OOTID, *LPOOTID;

#define CBOOTID sizeof(OOTID)

/*
 *	prototypes for functions in ootid.c
 */
HRESULT
HrNewOOTID (LPMAPIPROP *        lppMAPIPropNew,
            ULONG               cbTemplateId,
            LPENTRYID           lpTemplateId,
            ULONG               ulTemplateFlags,
            LPMAPIPROP          lpPropData,
            LPABLOGON           lpABPLogon,
            LPCIID              lpInterface,
            HINSTANCE           hLibrary,
            LPALLOCATEBUFFER    lpAllocBuff,
            LPALLOCATEMORE      lpAllocMore,
            LPFREEBUFFER        lpFreeBuff,
            LPMALLOC            lpMalloc );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\oouser.c ===
/***********************************************************************
 *
 *  OOUSER.C
 *
 *      Microsoft At Work Fax AB One Off Mail User object
 *      This file contains the code for implementing the Microsoft At Work Fax AB
 *      One Off Mail user.
 *
 *  Copyright 1992, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *      Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *                      MAPI                Original source from MAPI(154) sample AB Provider
 *      3.7.94          Yoram Yaacovi       Modifications to make it an At Work Fax ABP
 *      3.17.94         Yoram Yaacovi       Update to MAPI build 154
 *      4.8.94          Yoram Yaacovi       Update to MAPI build 158. Made edit boxes editable
 *      4.12.94         Yoram Yaacovi       Most props are now set on the OOTID (ootid.c) object
 *                                            instead of the OOUSER object.
 *      8.8.94          Yoram Yaacovi       Updated to MAPI 304 and new spec
 *
 ***********************************************************************/

#define _FAXAB_OOUSER
#include "faxab.h"


/*
 *  External functions
 */

/*
 *      Display table control structures for the OneOff property sheet.
 */

/*
 *      Control definitions in abuser.c
 */

extern DTBLEDIT         editUserDisplayName;
extern DTBLEDIT         editUserAreaCode;
extern DTBLEDIT         editUserTelNumber;
extern DTBLDDLBX        ddlbxCountryCodes;


/*
 *      General Property Page definition
 *
 *      Should be kept in sync with the one for an AB user in abuser.c
 *      Could not use the same because of some fields that need to be editable
 *      here, and read-only for an AB user
 */

// extern DTCTL rgdtctlUserGeneral[];
// extern WORD sizeof_rgdtpageUserGeneral;
// extern DTPAGE rgdtpageUser[];
// extern WORD sizeof_rgdtpageUser;

// Description the the Fax AB pane in MAPI dialog description language
static DTCTL rgdtctlOOUserGeneral[] =
{
    /* general property page */
    { DTCT_PAGE,    0, NULL, 0, NULL,               0, &dtblpage },

    /* cover page name static control and edit control */
    { DTCT_LABEL,   0, NULL, 0, NULL,               IDC_RECIP_DISPLAY_NAME_LABEL, &dtbllabel },
    { DTCT_EDIT,    DT_REQUIRED | DT_EDITABLE | DT_ACCEPT_DBCS | DT_SET_IMMEDIATE,
      NULL, 0, (LPTSTR)szNoFilter, IDC_RECIP_DISPLAY_NAME, &editUserDisplayName },

    /* Country codes label and drop down list box */
    { DTCT_LABEL,   0, NULL, 0, NULL,               IDC_RECIP_COUNTRY_CODE_LABEL, &dtbllabel },
    { DTCT_DDLBX,   DT_EDITABLE, NULL, 0,   NULL, IDC_RECIP_COUNTRY_CODE, &ddlbxCountryCodes },

    /* Area code and fax number label */
    { DTCT_LABEL,   0, NULL, 0, NULL,               IDC_RECIP_FAX_NUMBER_LABEL,     &dtbllabel },

    /* area code edit control */
    { DTCT_EDIT,    DT_EDITABLE, NULL, 0, (LPTSTR)szDigitsOnlyFilter, IDC_RECIP_FAX_NUMBER_AREA_CODE,       &editUserAreaCode },

    /* Fax number static control and edit control */
    { DTCT_LABEL,   0, NULL, 0, NULL,               IDC_RECIP_FAX_NUMBER_LABEL2, &dtbllabel },
    { DTCT_EDIT,    DT_REQUIRED | DT_EDITABLE, NULL, 0, (LPTSTR)szDigitsOnlyFilter, IDC_RECIP_FAX_NUMBER, &editUserTelNumber}
};

/*
 *      The OneOff property sheet definition
 *      Currently using exactly the same layout as the AB user dialog
 *      with some fields editable here and read-only for an AB user
 */
static DTPAGE rgdtpageOOUser[] =
{
    {
        ARRAYSIZE(rgdtctlOOUserGeneral),
        (LPTSTR)MAKEINTRESOURCE(MAWFRecipient),
        TEXT(""),
        rgdtctlOOUserGeneral
    },
};


/*
 *  ABOOUser jump table is defined here...
 */
ABOOUSER_Vtbl vtblABOOUSER =
{
    (ABOOUSER_QueryInterface_METHOD *)  ABU_QueryInterface,
    (ABOOUSER_AddRef_METHOD *)          WRAP_AddRef,
     ABOOUSER_Release,
    (ABOOUSER_GetLastError_METHOD *)    WRAP_GetLastError,
    (ABOOUSER_SaveChanges_METHOD *)     WRAP_SaveChanges,
    (ABOOUSER_GetProps_METHOD *)        WRAP_GetProps,
    (ABOOUSER_GetPropList_METHOD *)     WRAP_GetPropList,
     ABOOUSER_OpenProperty,
    (ABOOUSER_SetProps_METHOD *)        WRAP_SetProps,
    (ABOOUSER_DeleteProps_METHOD *)     WRAP_DeleteProps,
    (ABOOUSER_CopyTo_METHOD *)          WRAP_CopyTo,
    (ABOOUSER_CopyProps_METHOD *)       WRAP_CopyProps,
    (ABOOUSER_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs,
    (ABOOUSER_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames,
};


enum {  ivalusrPR_DISPLAY_TYPE = 0,
        ivalusrPR_OBJECT_TYPE,
        ivalusrPR_ADDRTYPE,
        ivalusrPR_COUNTRY_ID,
        ivalusrPR_AREA_CODE,
#ifdef INIT_TEL_NUMBER
        ivalusrPR_TEL_NUMBER,
#endif
        ivalusrPR_TEMPLATEID,
        cvalusrMax };

/*************************************************************************
 *
 -  HrNewFaxOOUser
 -
 *  Creates the IMAPIProp associated with a one off mail user.
 *
 *
 */
HRESULT
HrNewFaxOOUser( LPMAILUSER *        lppMAPIPropEntry,
                ULONG *             lpulObjType,
                ULONG               cbEntryID,
                LPENTRYID           lpEntryID,
                LPABLOGON           lpABPLogon,
                LPCIID              lpInterface,
                HINSTANCE           hLibrary,
                LPALLOCATEBUFFER    lpAllocBuff,
                LPALLOCATEMORE      lpAllocMore,
                LPFREEBUFFER        lpFreeBuff,
                LPMALLOC            lpMalloc
               )
{
    LPABOOUSER      lpABOOUser = NULL;
    SCODE           sc;
    HRESULT         hr = hrSuccess;
    LPPROPDATA      lpPropData = NULL;
    SPropValue      spv[cvalusrMax];
#ifdef UNICODE
    CHAR            szAnsiAreaCode[ AREA_CODE_SIZE ];
    CHAR            szEMT[ MAX_PATH ];
#endif


    /*  Do I support this interface?? */
    if (lpInterface)
    {
        if ( memcmp(lpInterface, &IID_IMailUser, SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IMAPIProp, SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IUnknown,  SIZEOF(IID))
            )
        {
            DebugTraceSc(HrNewSampOOUser, MAPI_E_INTERFACE_NOT_SUPPORTED);
            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        }
    }

    /*
     *  Allocate space for the ABOOUser structure
     */
    sc = lpAllocBuff(SIZEOF(ABOOUSER), (LPVOID *) & lpABOOUser);

    if (FAILED(sc))
    {
        hr = ResultFromScode (sc);
        DebugTraceResult(NewFaxUser, hr);
        goto err;
    }

    lpABOOUser->lpVtbl          = &vtblABOOUSER;
    lpABOOUser->lcInit          = 1;
    lpABOOUser->hResult         = hrSuccess;
    lpABOOUser->idsLastError    = 0;
    lpABOOUser->hLibrary        = hLibrary;
    lpABOOUser->lpAllocBuff     = lpAllocBuff;
    lpABOOUser->lpAllocMore     = lpAllocMore;
    lpABOOUser->lpFreeBuff      = lpFreeBuff;
    lpABOOUser->lpMalloc        = lpMalloc;
    lpABOOUser->lpABLogon       = lpABPLogon;
    lpABOOUser->lpTDatDDListBox = NULL;

    /*
     *  Create lpPropData
     */

    sc = CreateIProp( (LPIID) &IID_IMAPIPropData,
                      lpAllocBuff,
                      lpAllocMore,
                      lpFreeBuff,
                      lpMalloc,
                      &lpPropData
                     );

    if (FAILED(sc))
    {
        hr = ResultFromScode (sc);
        goto err;
    }

    /*
     *  Set up the initial set of properties
     */

    spv[ivalusrPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    spv[ivalusrPR_DISPLAY_TYPE].Value.l   = DT_MAILUSER;

    spv[ivalusrPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    spv[ivalusrPR_OBJECT_TYPE].Value.l   = MAPI_MAILUSER;

    spv[ivalusrPR_ADDRTYPE].ulPropTag  = PR_ADDRTYPE_A;
#ifdef UNICODE
    szEMT[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, lpszEMT, -1, szEMT, ARRAYSIZE(szEMT), NULL, NULL );
    spv[ivalusrPR_ADDRTYPE].Value.lpszA = szEMT;
#else
    spv[ivalusrPR_ADDRTYPE].Value.LPSZ = lpszEMT;
#endif

    spv[ivalusrPR_TEMPLATEID].ulPropTag     = PR_TEMPLATEID;
    spv[ivalusrPR_TEMPLATEID].Value.bin.cb  = SIZEOF(OOUSER_ENTRYID);
    spv[ivalusrPR_TEMPLATEID].Value.bin.lpb = (LPBYTE) lpEntryID;

    spv[ivalusrPR_COUNTRY_ID].ulPropTag     = PR_COUNTRY_ID;
/*
        spv[ivalusrPR_COUNTRY_ID].Value.ul      = 1;    // U.S.;
*/

    spv[ivalusrPR_COUNTRY_ID].Value.ul = GetCurrentLocationCountryID();

    // display the area code of the current location
    spv[ivalusrPR_AREA_CODE].ulPropTag  = PR_AREA_CODE_A;
#ifdef UNICODE
    szAnsiAreaCode[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, GetCurrentLocationAreaCode(), -1, szAnsiAreaCode, ARRAYSIZE(szAnsiAreaCode), NULL, NULL );
    spv[ivalusrPR_AREA_CODE].Value.lpszA = szAnsiAreaCode;
#else
    spv[ivalusrPR_AREA_CODE].Value.lpszA = GetCurrentLocationAreaCode();
#endif

#ifdef INIT_TEL_NUMBER
    // initialize the fax number, so that it won't be PT_ERROR
    spv[ivalusrPR_TEL_NUMBER].ulPropTag  = PR_TEL_NUMBER_A;
    spv[ivalusrPR_TEL_NUMBER].Value.lpszA = (LPSTR) "";
#endif

    /*
     *  Note that we're using our entryID for our templateID.
     *  This is a really simple way to implement templateIDs.
     *  (See TID.C)
     */

    /*
     *   Set the default properties
     */
    hr = lpPropData->lpVtbl->SetProps( lpPropData,
                                       cvalusrMax,
                                       spv,
                                       NULL
                                      );

    if (HR_FAILED(hr))
    {
        DebugTraceResult(NewFaxOOUser, hr);
        goto err;
    }

    (void) lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READWRITE);

    lpABOOUser->lpPropData = (LPMAPIPROP) lpPropData;

    InitializeCriticalSection(&lpABOOUser->cs);

    *lppMAPIPropEntry = (LPVOID) lpABOOUser;
    *lpulObjType = MAPI_MAILUSER;

out:
    DebugTraceResult(HrNewSampOOUser, hr);
    return hr;

err:
    if (lpPropData)
            lpPropData->lpVtbl->Release(lpPropData);

    lpFreeBuff( lpABOOUser );

    goto out;
}

/***************************************************
 *
 *  The actual ABOOUser methods
 */

/**************************************************
 *
 -  ABOOUSER_Release
 -
 *              Decrement lpInit.
 *              When lcInit == 0, free up the lpABOOUser structure
 *
 */
STDMETHODIMP_(ULONG)
ABOOUSER_Release (LPABOOUSER lpABOOUser)
{

    LONG lcInit;
    /*
     *  Check to see if it's big enough to hold this object
     */
    if (IsBadReadPtr(lpABOOUser, SIZEOF(ABOOUSER)))
    {
        /*
         *  Not large enough
         */
        return 1;
    }

    /*
     *  Check to see that it's the correct vtbl
     */
    if (lpABOOUser->lpVtbl != &vtblABOOUSER)
    {
        /*
         *  Not my vtbl
         */
        return 1;
    }

    EnterCriticalSection(&lpABOOUser->cs);
    lcInit = --lpABOOUser->lcInit;
    LeaveCriticalSection(&lpABOOUser->cs);

    if (lcInit == 0)
    {

        /*
         *  Get rid of the lpPropData
         */

        lpABOOUser->lpPropData->lpVtbl->Release(lpABOOUser->lpPropData);

        /*
         *  Get rid of the country codes table
         */

        if (lpABOOUser->lpTDatDDListBox)
            lpABOOUser->lpTDatDDListBox->lpVtbl->Release(lpABOOUser->lpTDatDDListBox);

        /*
         *  Destroy the critical section for this object
         */

        DeleteCriticalSection(&lpABOOUser->cs);

        /*
         *  Set the vtbl to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */

        lpABOOUser->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpABOOUser->lpFreeBuff( lpABOOUser );
        return 0;
    }

    return lcInit;

}

/*************************************************************************
 *
 -  ABOOUSER_OpenProperty
 -
 *
 *      This is how we get the display table associated with this users
 *  details screen.
 */
STDMETHODIMP
ABOOUSER_OpenProperty( LPABOOUSER  lpABOOUser,
                       ULONG       ulPropTag,
                       LPCIID      lpiid,
                       ULONG       ulInterfaceOptions,
                       ULONG       ulFlags,
                       LPUNKNOWN * lppUnk)
{
    LPMAPITABLE lpDisplayTable=NULL;

    /*
     *  Since the default is that we do not support opening this
     *  object, we can initialize our hResult here.
     */
    HRESULT hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

    /*
     *  Check to see if it can be pointing to the right structure.
     */
    if (IsBadReadPtr(lpABOOUser, SIZEOF(ABOOUSER)))
    {
        /*
         *  Not big enough to be my object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that it's got the correct vtbl
     */
    if (lpABOOUser->lpVtbl != &vtblABOOUSER)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadReadPtr(lpiid, SIZEOF(IID)))
    {
        /*
         *  Interfaces are required on this method.
         */
        hResult = ResultFromScode(E_ACCESSDENIED);
        goto out;
    }

    if (ulInterfaceOptions & ~MAPI_UNICODE )
    {
        /*
         *  Only UNICODE flag should be set for any of the objects that might
         *  be returned from this object.
         */
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
            hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
            goto out;
    }

    if (ulFlags & ~(MAPI_CREATE|MAPI_MODIFY|MAPI_DEFERRED_ERRORS))
    {
        /*
         *  Don't understand the flags that were passed in
         */
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }


    if (ulFlags & MAPI_CREATE)
    {
        /*
         *  Don't support creating any sub-objects
         */
        hResult = ResultFromScode(E_ACCESSDENIED);
        goto out;
    }

    if (IsBadWritePtr(lppUnk, SIZEOF(LPUNKNOWN)))
    {
        /*
         *  Got to be able to return an object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    // If the caller is trying to open a table property and is not expecting a table interface..
    switch (ulPropTag)
    {
    case PR_DETAILS_TABLE:
    case PR_DDLBX_COUNTRIES_TABLE:
        if (memcmp( lpiid, &IID_IMAPITable, SIZEOF(IID) ))
        {
            // ... we will abort right here
            hResult = ResultFromScode(E_NOINTERFACE);
            goto out;
        }
        break;

    default:
        break;
    }

    /*  Check to see if I need a display table*/

    switch (ulPropTag)
    {

    case PR_DETAILS_TABLE:

        /* Looking for the display table*/

/*      // Going to use the AB user display array, but make all editable
        // fields editable

        for (i=0; i < (sizeof_rgdtpageUserGeneral / sizeof(DTCTL)); i++)
                if ((rgdtctlUserGeneral[i].ulCtlType == DTCT_EDIT) ||
                        (rgdtctlUserGeneral[i].ulCtlType == DTCT_DDLBX))

*/

        /* Create a display table */

        hResult = BuildDisplayTable( lpABOOUser->lpAllocBuff,
                                     lpABOOUser->lpAllocMore,
                                     lpABOOUser->lpFreeBuff,
                                     lpABOOUser->lpMalloc,
                                     lpABOOUser->hLibrary,
                                     ARRAYSIZE(rgdtpageOOUser),
                                     rgdtpageOOUser,
                                     0,
                                     &lpDisplayTable,
                                     NULL
                                    );

#ifdef WRAP_TABLE
        HrNewTableWrap(&lpDisplayTable);
#endif

        *lppUnk = (LPUNKNOWN) lpDisplayTable;

        if (HR_FAILED(hResult))
        {
            goto out;
        }

        /*
         * We're succeeding. Ensure our hResult is set properly
         */

        hResult = hrSuccess;
        break;

    case PR_DDLBX_COUNTRIES_TABLE:

        // This table is not changing dynamically. No need to rebuild if already built.
        if (!lpABOOUser->lpTDatDDListBox)
        {
            hResult = HrBuildDDLBXCountriesTable((LPABUSER) lpABOOUser);
            if (HR_FAILED(hResult))
                    goto out;
        }

        Assert(lpABOOUser->lpTDatDDListBox);

        /* Get a view from the TAD*/
        hResult = lpABOOUser->lpTDatDDListBox->lpVtbl->HrGetView(
                          lpABOOUser->lpTDatDDListBox,
                          NULL,
                          NULL,
                          0,
                          (LPMAPITABLE *) lppUnk);

        break;

    default:
        hResult = ResultFromScode(MAPI_E_NO_SUPPORT);
        break;

    }

out:

    DebugTraceResult(ABOOUSER_OpenProperty, hResult);
    return hResult;

}

/**********************************************************************
 *
 *  Private functions
 */


#undef _FAXAB_OOUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!ifndef FAXROOT
FAXROOT=$(PROJECT_ROOT)\fax
!endif

NOUNICODE=1

!include $(FAXROOT)\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows

USE_MSVCRT=1
DLLDEF=..\faxab.def

TARGETLIBS=\
    $(SDK_LIB_PATH)\user32.lib     \
    $(SDK_LIB_PATH)\kernel32.lib   \
    $(SDK_LIB_PATH)\gdi32.lib      \
    $(SDK_LIB_PATH)\advapi32.lib   \
    $(SDK_LIB_PATH)\comdlg32.lib   \
    $(SDK_LIB_PATH)\tapi32.lib     \
    $(SDK_LIB_PATH)\mapi32.lib     \
    $(SDK_LIB_PATH)\ole32.lib      \
    $(SDK_LIB_PATH)\uuid.lib       \

INCLUDES=\
    $(INCLUDES);\
    ..\;\
    $(BASEDIR)\private\exchange\mapi\h

SOURCES=\
    ..\abcont.c    \
    ..\abctbl1.c   \
    ..\abctbl2.c   \
    ..\abctbl3.c   \
    ..\abguid.c    \
    ..\ablogon.c   \
    ..\abp.c       \
    ..\absearch.c  \
    ..\abuser.c    \
    ..\ootid.c     \
    ..\oouser.c    \
    ..\root.c      \
    ..\status.c    \
    ..\tid.c       \
    ..\wrap.c      \
    ..\debug.c     \
    ..\util.c      \
    ..\awfaxab.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\root.h ===
/***********************************************************************
 *
 *  _ROOT.H
 *
 *  Header file for code in ROOT.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer for ROOT object.  (i.e. ABPOpenEntry() with an
 *  lpEntryID of NULL).
 */

#undef	INTERFACE
#define INTERFACE	struct _ROOT

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ROOT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAPICONTAINER_METHODS(IMPL)
		MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ROOT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAPICONTAINER_METHODS(IMPL)
		MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ROOT_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IMAPICONTAINER_METHODS(IMPL)
	MAPI_IABCONTAINER_METHODS(IMPL)
};

/*
 *  The structure behind the 'this' pointer
 */
typedef struct _ROOT
{
    const ROOT_Vtbl FAR *   lpVtbl;

    FAB_Wrapped;
    
} ROOT, *LPROOT;

#define CBROOT	sizeof(ROOT)

/*
 *  Creates a new ROOT container object  (see ROOT.C)
 */

HRESULT
HrNewROOT(LPABCONT *        lppROOT,
          ULONG *           lpulObjType,
          LPABLOGON         lpABPLogon,
          LPCIID            lpInterface,
          HINSTANCE         hLibrary,
          LPALLOCATEBUFFER  lpAllocBuff,
          LPALLOCATEMORE    lpAllocMore,
          LPFREEBUFFER      lpFreeBuff,
          LPMALLOC          lpMalloc );



/*
 *  Sets an error string associated with a particular hResult on an object.
 *  I't used in conjunction with the method GetLastError.
 */
VOID ROOT_SetErrorSz (LPVOID lpObject, HRESULT hResult, LPTSTR lpszError);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\root.c ===
/***********************************************************************
 *
 *  ROOT.C
 *
 *
 *  Sample AB Root object
 *      - This file contains the code for implementing the Sample AB
 *      root object and the hierarchy table.
 *
 *  The Root container object is returned via an ABPOpenEntry() with a
 *  0-sized entryid.  It only has a limited set of properties available on
 *  it.  The most useful method on it is GetHierarchyTable() which returns
 *  the root hierarchy associated with this provider.
 *
 *  The hierarchy table has only a single row in it.  The row represents the
 *  single .FAB file which this provider browses.  If a provider wanted to
 *  browse many different lists, it would have multiple rows.
 *
 *  The following routines are implemented in this file:
 *
 *
 *    To implement the Root container object:
 *
 *      HrNewROOT
 *      SetErrorSz
 *      ROOT_QueryInterface
 *      ROOT_AddRef
 *      ROOT_Release
 *      ROOT_GetLastError
 *      ROOT_SaveChanges
 *      ROOT_OpenProperty
 *      ROOT_GetContentsTable
 *      ROOT_GetHierarchyTable
 *      ROOT_OpenEntry
 *      ROOT_CreateEntry
 *      ROOT_CopyEntries
 *      ROOT_DeleteEntries
 *      ROOT_ResolveNames
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *  Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *      1.1.94          MAPI                            Original source from MAPI sample AB Provider
 *      1.27.94         Yoram Yaacovi           Modifications to make it an At Work Fax ABP
 *      3.6.94          Yoram Yaacovi           Update to MAPI build 154
 *      8.3.94          Yoram Yaacovi           Incorporated MAPI 304 changes
 *      10.3.94         Yoram Yaacovi           Incorporated MAPI 313 changes, mainly added ResolveNames
 *      11.4.94         Yoram Yaacovi           Incorporated MAPI 318 changes
 *
 ***********************************************************************/

#define _FAXAB_ROOT
#include "faxab.h"

/*
 *  Defined in ABP.C
 */
extern MAPIUID  muidABMAWF;

/*
 *  Root vtbl is filled in here
 */
static const ROOT_Vtbl vtblROOT =
{
    ROOT_QueryInterface,
    ROOT_AddRef,
    ROOT_Release,
    ROOT_GetLastError,
    ROOT_SaveChanges,
    (ROOT_GetProps_METHOD *)        WRAP_GetProps,
    (ROOT_GetPropList_METHOD *)     WRAP_GetPropList,
    ROOT_OpenProperty,
    (ROOT_SetProps_METHOD *)        WRAP_SetProps,
    (ROOT_DeleteProps_METHOD *)     WRAP_DeleteProps,
    (ROOT_CopyTo_METHOD *)          WRAP_CopyTo,
    (ROOT_CopyProps_METHOD *)       WRAP_CopyProps,
    (ROOT_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs,
    (ROOT_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames,
    ROOT_GetContentsTable,
    ROOT_GetHierarchyTable,
    ROOT_OpenEntry,
    ROOT_SetSearchCriteria,
    ROOT_GetSearchCriteria,
    ROOT_CreateEntry,
    ROOT_CopyEntries,
    ROOT_DeleteEntries,
    ROOT_ResolveNames
};


/*
 *  Default properties in this object
 */
enum {  ivalPR_DISPLAY_TYPE = 0,
        ivalPR_OBJECT_TYPE,
        ivalPR_ENTRYID,
        ivalPR_RECORD_KEY,
        ivalPR_SEARCH_KEY,
        ivalPR_DISPLAY_NAME,
        ivalPR_CONTAINER_FLAGS,
        cvalMax };

/*
 -  HrNewROOT
 -
 *  Creates a new Root Container object.  This object is created
 *  when an lpABLogon::OpenEntry() is called with a 0-sized entryid.
 *
 *
 */
HRESULT
HrNewROOT( LPABCONT *        lppROOT,
           ULONG *           lpulObjType,
           LPABLOGON         lpABPLogon,
           LPCIID            lpInterface,
           HINSTANCE         hLibrary,
           LPALLOCATEBUFFER  lpAllocBuff,
           LPALLOCATEMORE    lpAllocMore,
           LPFREEBUFFER      lpFreeBuff,
           LPMALLOC          lpMalloc
          )
{
    LPROOT lpROOT = NULL;
    SCODE scode;
    LPPROPDATA lpPropData = NULL;
    SPropValue spv[cvalMax];
    HRESULT hResult;
#ifdef UNICODE
    CHAR szAnsiDisplayName[MAX_ROOT_NAME];
#endif
    TCHAR szDisplayName[MAX_ROOT_NAME];
    LPTSTR pszDisplayName = (LPTSTR) szDisplayName;
    SCODE sc;
    DIR_ENTRYID eidRoot =   {   {0, 0, 0, 0},
                                MUIDABMAWF,
                                MAWF_VERSION,
                                MAWF_DIRECTORY };

    /*  Do I support this interface?? */
    if (lpInterface)
    {
        if ( memcmp(lpInterface, &IID_IUnknown,       SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IMAPIProp,      SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IMAPIContainer, SIZEOF(IID)) &&
             memcmp(lpInterface, &IID_IABContainer,   SIZEOF(IID))
            )
        {
            DebugTraceSc(HrNewROOT, MAPI_E_INTERFACE_NOT_SUPPORTED);
            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        }
    }
    /*
     *  Allocate space for the ROOT structure
     */
    scode = lpAllocBuff( SIZEOF(ROOT), (LPVOID *) &lpROOT );
    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);
        goto err;
    }

    lpROOT->lpVtbl = &vtblROOT;
    lpROOT->lcInit = 1;
    lpROOT->hResult = hrSuccess;
    lpROOT->idsLastError = 0;

    lpROOT->hLibrary = hLibrary;
    lpROOT->lpAllocBuff = lpAllocBuff;
    lpROOT->lpAllocMore = lpAllocMore;
    lpROOT->lpFreeBuff = lpFreeBuff;
    lpROOT->lpMalloc = lpMalloc;

    lpROOT->lpABLogon = lpABPLogon;

    /*
     *  Create a property storage object
     */

    scode = CreateIProp( (LPIID) &IID_IMAPIPropData,
                         lpAllocBuff,
                         lpAllocMore,
                         lpFreeBuff,
                         lpMalloc,
                         &lpPropData
                        );

    if (FAILED(scode))
    {
        hResult = ResultFromScode(scode);
        goto err;
    }

    /*
     *  Set up initial set of properties associated with this
     *  container.
     */

    spv[ivalPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    spv[ivalPR_DISPLAY_TYPE].Value.l    = 0;           /* undefined for now */

    spv[ivalPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    spv[ivalPR_OBJECT_TYPE].Value.l   = MAPI_ABCONT;

    spv[ivalPR_ENTRYID].ulPropTag     = PR_ENTRYID;
    spv[ivalPR_ENTRYID].Value.bin.cb  = SIZEOF(DIR_ENTRYID);
    spv[ivalPR_ENTRYID].Value.bin.lpb = (LPBYTE) &eidRoot;

    spv[ivalPR_RECORD_KEY].ulPropTag     = PR_RECORD_KEY;
    spv[ivalPR_RECORD_KEY].Value.bin.cb  = SIZEOF(DIR_ENTRYID);
    spv[ivalPR_RECORD_KEY].Value.bin.lpb = (LPBYTE) &eidRoot;

    spv[ivalPR_SEARCH_KEY].ulPropTag     = PR_SEARCH_KEY;
    spv[ivalPR_SEARCH_KEY].Value.bin.cb  = sizeof(DIR_ENTRYID);
    spv[ivalPR_SEARCH_KEY].Value.bin.lpb = (LPBYTE) &eidRoot;

    sc = ScLoadString(  IDS_ADDRESS_BOOK_ROOT_CONT,
                        MAX_ROOT_NAME,
                        NULL,
                        hLibrary,
                        (LPTSTR *) &pszDisplayName
                       );
    if (FAILED(sc))
    {
        hResult = ResultFromScode(sc);
        goto out;
    }

    spv[ivalPR_DISPLAY_NAME].ulPropTag  = PR_DISPLAY_NAME_A;
#ifdef UNICODE
    WideCharToMultiByte( CP_ACP, 0, szDisplayName, -1, szAnsiDisplayName, ARRAYSIZE(szAnsiDisplayName), NULL, NULL );
    spv[ivalPR_DISPLAY_NAME].Value.lpszA = szAnsiDisplayName;
#else
    spv[ivalPR_DISPLAY_NAME].Value.lpszA = szDisplayName;
#endif

    spv[ivalPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    spv[ivalPR_CONTAINER_FLAGS].Value.l   = AB_SUBCONTAINERS;

    /*
     *   Set the default properties
     */
    hResult = lpPropData->lpVtbl->SetProps( lpPropData,
                                            cvalMax,
                                            spv,
                                            NULL
                                           );

    if (HR_FAILED(hResult))
    {
        goto err;
    }

    (void) lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpROOT->lpPropData = (LPMAPIPROP) lpPropData;

    InitializeCriticalSection(&lpROOT->cs);


    *lpulObjType = MAPI_ABCONT;
    *lppROOT = (LPVOID) lpROOT;

out:
    DebugTraceResult(HrNewROOT, hResult);
    return hResult;

err:
    /*
     *  free the root object
     */
    lpFreeBuff (lpROOT);

    /*
     *  free the prop data
     */
    if (lpPropData)
        lpPropData->lpVtbl->Release(lpPropData);

    goto out;

}

/*************************************************************************
 *
 *
 -  SetErrorIDS
 -
 *  Handles remembering the last error string associated with an object.
 *  This string is retrieved by the method GetLastError()
 *
 *
 */

VOID
SetErrorIDS(LPVOID lpObject, HRESULT hResult, UINT ids)
{
    ((LPROOT) lpObject)->hResult = hResult;
    ((LPROOT) lpObject)->idsLastError = ids;
}

/*
 -  ROOT_QueryInterface
 -
 *  Supports QI'ing to IUnknown, IMAPIProp, IMAPIContainer, and IABContainer.
 *
 */
STDMETHODIMP
ROOT_QueryInterface( LPROOT lpROOT,
                     REFIID lpiid,
                     LPVOID FAR * lppNewObj
                    )
{

    HRESULT hr = hrSuccess;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
                     offsetof(ROOT_Vtbl, QueryInterface)+SIZEOF(ROOT_QueryInterface_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_QueryInterface != lpROOT->lpVtbl->QueryInterface)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Check other parameters */

    if ( IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)) ||
         IsBadWritePtr(lppNewObj, (UINT) SIZEOF(LPVOID))
        )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  See if the requested interface is one of ours */

    if ( memcmp(lpiid, &IID_IUnknown,       SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMAPIProp,      SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMAPIContainer, SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IABContainer,   SIZEOF(IID)))
    {
        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */
        hr = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpROOT->cs);
    ++lpROOT->lcInit;
    LeaveCriticalSection(&lpROOT->cs);

    *lppNewObj = lpROOT;

out:

    DebugTraceResult(ROOT_QueryInterface, hr);
    return hr;
}

/**************************************************
 *
 -  ROOT_AddRef
 -
 *      Increment lcInit
 *
 */

STDMETHODIMP_(ULONG) ROOT_AddRef(LPROOT lpROOT)
{
    LONG lcInit;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        return 1;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
                     offsetof(ROOT_Vtbl, AddRef)+SIZEOF(ROOT_AddRef_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */
        return 1;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_AddRef != lpROOT->lpVtbl->AddRef)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        return 1;
    }

    EnterCriticalSection(&lpROOT->cs);
    lcInit = ++lpROOT->lcInit;
    LeaveCriticalSection(&lpROOT->cs);

    return lcInit;
}

/**************************************************
 *
 -  ROOT_Release
 -
 *      Decrement lcInit.
 *      When lcInit == 0, free up the lpROOT structure
 *
 */

STDMETHODIMP_(ULONG) ROOT_Release(LPROOT lpROOT)
{

    LONG lcInit;

    /*
     *  Check to see if it can be a ROOT object
     */
    if (IsBadReadPtr(lpROOT, SIZEOF(ROOT)))
    {
        /*
         *  Not large enough
         */
        return 1;
    }

    /*
     *  Check to see that it's ROOTs vtbl
     */
    if (lpROOT->lpVtbl != &vtblROOT)
    {
        /*
         *  Not my jump table
         */
        return 1;
    }

    EnterCriticalSection(&lpROOT->cs);
    lcInit = --lpROOT->lcInit;
    LeaveCriticalSection(&lpROOT->cs);

    if (lcInit == 0)
    {

        /*
         *  Delete our critical section
         */

        DeleteCriticalSection(&lpROOT->cs);

        /*
         *  Set the vtbl to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */
        lpROOT->lpVtbl = NULL;

        /*
         *  free the property storage object
         */
        if (lpROOT->lpPropData)
            lpROOT->lpPropData->lpVtbl->Release(lpROOT->lpPropData);

        /*
         *  Free the object
         */

        lpROOT->lpFreeBuff(lpROOT);
        return 0;
    }

    return lcInit;
}

/*
 -  ROOT_GetLastError
 -
 *      Returns a string associated with the last hResult
 *  returned by the ROOT object.
 *
 */

STDMETHODIMP
ROOT_GetLastError(  LPROOT lpROOT,
                    HRESULT hError,
                    ULONG ulFlags,
                    LPMAPIERROR FAR * lppMapiError )
{
    SCODE scode;
    HRESULT hResult=hrSuccess;
    LPTSTR   lpszMessage = NULL;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        hResult = MakeResult(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
        offsetof(ROOT_Vtbl, GetLastError)+SIZEOF(ROOT_GetLastError_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = MakeResult(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_GetLastError != lpROOT->lpVtbl->GetLastError)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ROOT_GetLastError, hResult);
        return hResult;
    }

    /*
     *  Validate ulFlags
     */
    if (ulFlags & ~MAPI_UNICODE)
    {
        /*
         * Unknown flag
         */
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        DebugTraceResult(ROOT_GetLastError, hResult);
        return hResult;
    }

    /*
     *  NOTE:  We don't handle UNICODE yet.  Everything is
     *  assumed to be working in 8-bit char mode.
     */
    if (ulFlags & MAPI_UNICODE)
    {
        hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH);
        DebugTraceResult(ROOT_GetLastError, hResult);
        return hResult;
    }

    /*
     *  Validate lppMapiError.
     */
    if (IsBadWritePtr(lppMapiError, SIZEOF(LPMAPIERROR)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ROOT_GetLastError, hResult);
        return hResult;
    }

    EnterCriticalSection(&lpROOT->cs);

    if ((hError != hrSuccess) && (hError == lpROOT->hResult))
    {
        scode = lpROOT->lpAllocBuff( SIZEOF( MAPIERROR ), lppMapiError );
        if ( FAILED( scode ) )
        {
            hResult = ResultFromScode(scode);
            goto ret;
        }

        RtlZeroMemory( *lppMapiError, SIZEOF( MAPIERROR ) );

        (*lppMapiError)->ulVersion = MAPI_ERROR_VERSION;

        /*
         *  Get the MAPI Allocated string associated with the last error
         */
        scode = ScLoadString(lpROOT->idsLastError,
                             MAX_ERROR_STRING_LENGTH,
                             lpROOT->lpAllocBuff,
                             lpROOT->hLibrary,
                             &lpszMessage);
        if ( FAILED( scode) )
        {
            hResult = ResultFromScode(scode);
            goto ret;
        }

        scode = lpROOT->lpAllocMore( (lstrlen( lpszMessage ) + 1)*SIZEOF(TCHAR),
                                     *lppMapiError,
                                     &(*lppMapiError)->lpszError
                                    );
        if ( FAILED( scode ) )
        {
            hResult = ResultFromScode(scode);
            goto ret;
        }

        lstrcpy( (*lppMapiError)->lpszError, lpszMessage );

    }
    else
    {
        *lppMapiError = NULL;
    }

ret:
    if ( hResult )
    {
        lpROOT->lpFreeBuff( *lppMapiError );
        *lppMapiError = NULL;
    }

    lpROOT->lpFreeBuff( lpszMessage );
    LeaveCriticalSection(&lpROOT->cs);

    return hResult;
}

/*
 -  ROOT_SaveChanges
 -
 *  Can't save changes on this object.
 *
 *
 */
STDMETHODIMP
ROOT_SaveChanges(LPROOT lpROOT, ULONG ulFlags)
{

    HRESULT hResult;

    /*
     *  Check to see if it's large enough to be this object
     */
    if (IsBadReadPtr(lpROOT, SIZEOF(ROOT)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that it's ROOTs vtbl
     */
    if (lpROOT->lpVtbl != &vtblROOT)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ulFlags & ~(KEEP_OPEN_READONLY|KEEP_OPEN_READONLY|FORCE_SAVE))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }


    hResult = ResultFromScode(E_ACCESSDENIED);

out:
    DebugTraceResult(ROOT_SaveChanges, hResult);
    return hResult;

}

/*
 -  ROOT_OpenProperty
 -
 *
 *  For this object I only need to support opening the hierarchy table.
 *
 */
STDMETHODIMP
ROOT_OpenProperty(  LPROOT lpROOT,
                    ULONG ulPropTag,
                    LPCIID lpiid,
                    ULONG ulInterfaceOptions,
                    ULONG ulFlags,
                    LPUNKNOWN * lppUnk)
{

    HRESULT hResult;

    /*
     *  Check to see if it's large enough to be this object
     */
    if (IsBadReadPtr(lpROOT, SIZEOF(ROOT)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that it's ROOTs vtbl
     */
    if (lpROOT->lpVtbl != &vtblROOT)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppUnk, SIZEOF(LPUNKNOWN)))
    {
        /*
         *  Got to be able to return an object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        /*
         *  An interface ID is required for this call.
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ulFlags & ~(MAPI_CREATE|MAPI_MODIFY|MAPI_DEFERRED_ERRORS))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

    }

    if (ulInterfaceOptions & ~MAPI_UNICODE)
    {
        /*
         *  Only UNICODE flag should be set for any of the objects that might
         *  be returned from this object.
         */

        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        goto out;
    }

    if (ulFlags & MAPI_CREATE)
    {
        hResult = ResultFromScode(E_ACCESSDENIED);
        goto out;
    }

    if (IsBadWritePtr(lppUnk, SIZEOF(LPUNKNOWN)))
    {
        /*
         *  Got to be able to return an object
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)))
    {
        /*
         *  An interface ID is required for this call.
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ulFlags & ~(MAPI_CREATE|MAPI_MODIFY|MAPI_DEFERRED_ERRORS))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if (ulInterfaceOptions)
    {
        /*
         *  No flags should be set for any of the objects that might
         *  be returned from this object.
         */

        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if (ulFlags & MAPI_CREATE)
    {
        hResult = ResultFromScode(E_ACCESSDENIED);
        goto out;
    }


    switch (ulPropTag)
    {

    case PR_CONTAINER_HIERARCHY:
    {
        /*
         *  Check to see if they're expecting a IMAPITable object
         */
        if (memcmp(lpiid, &IID_IMAPITable, SIZEOF(IID)))
        {
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto out;
        }

        hResult = ROOT_GetHierarchyTable(lpROOT, 0, (LPMAPITABLE *) lppUnk);

        goto out;
    }

    default:
        break;

    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:

    DebugTraceResult(ROOT_OpenProperty, hResult);
    return hResult;

}

/*************************************************************************
 *
 *
 -  ROOT_GetContentsTable
 -
 *  There are no contents in the root
 *
 *
 *
 */
STDMETHODIMP
ROOT_GetContentsTable(  LPROOT lpROOT,
                        ULONG ulFlags,
                        LPMAPITABLE * lppTable)
{

    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        hResult = MakeResult(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
        offsetof(ROOT_Vtbl, GetContentsTable)+SIZEOF(ROOT_GetContentsTable_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = MakeResult(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_GetContentsTable != lpROOT->lpVtbl->GetContentsTable)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ROOT_GetContentsTable, hResult);
        return hResult;
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_ASSOCIATED|MAPI_UNICODE))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if ( ulFlags & MAPI_UNICODE )
    {
        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        goto out;
    }

    if (!IsBadWritePtr(lppTable, SIZEOF(LPMAPITABLE)))
    {
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:
    DebugTraceResult(ROOT_GetContentsTable, hResult);
    return hResult;

}

/*
 -  ROOT_GetHierarchyTable
 -
 *  Returns the table with just one entry in it.
 *
 *
 *
 */
STDMETHODIMP
ROOT_GetHierarchyTable( LPROOT lpROOT,
                        ULONG ulFlags,
                        LPMAPITABLE * lppTable)
{

    HRESULT hResult = hrSuccess;

    /*
     *  Validate parameters
     */

    /*
     *  Check to see if it's large enough to be this object
     */
    if (IsBadReadPtr(lpROOT, SIZEOF(ROOT)))
    {
        /*
         *  Not large enough
         */
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ROOT_GetHierarchyTable, hResult);
        return hResult;
    }

    /*
     *  Check to see that it's ROOTs vtbl
     */
    if (lpROOT->lpVtbl != &vtblROOT)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ROOT_GetHierarchyTable, hResult);
        return hResult;
    }

    /*
     *  See if I can set the return variable
     */
    if (IsBadWritePtr(lppTable, SIZEOF(LPMAPITABLE)))
    {
        hResult = ResultFromScode(E_INVALIDARG);

        DebugTraceResult(ROOT_GetHierarchyTable, hResult);
        return hResult;
    }

    /*
     *  Check flags:
     *    The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS
     */

    if (ulFlags & ~(CONVENIENT_DEPTH | MAPI_DEFERRED_ERRORS))
    {
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);

        DebugTraceResult(ROOT_GetHierarchyTable, hResult);
        return hResult;
    }

    /*
     *  Since we only have one item in our hierarchy table, CONVENIENT_DEPTH
     *  is equivalent to any other depth level (>1).  So, just ignore the
     *  flag.  MAPI_DEFERRED_ERROR is fine.  We don't ever defer errors.
     */

    /*
     *  Create a View Table for the hierarchy.
     */
    hResult = HrBuildRootHier(lpROOT->lpABLogon, lppTable);

    DebugTraceResult(ROOT_GetHierarchyTable, hResult);
    return hResult;

}

/*
 -  ROOT_OpenEntry
 -
 *  Check parameters and use our logon object's OpenEntry method.
 */
STDMETHODIMP
ROOT_OpenEntry( LPROOT lpROOT,
                ULONG cbEntryID,
                LPENTRYID lpEntryID,
                LPCIID lpInterface,
                ULONG ulFlags,
                ULONG * lpulObjType,
                LPUNKNOWN * lppUnk
               )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  No vtbl found
         */
        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
        offsetof(ROOT_Vtbl, OpenEntry)+SIZEOF(ROOT_OpenEntry_METHOD *)))
    {
        /*
         *  vtbl cannot hold this method
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that it's the correct method
     */
    if (ROOT_OpenEntry != lpROOT->lpVtbl->OpenEntry)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check the entryID
     */
    if ( cbEntryID &&
         (cbEntryID < (ULONG) SIZEOF(ENTRYID) ||
         IsBadReadPtr(lpEntryID, (UINT) cbEntryID))
        )
    {
        /*
         *  Malformed entryID
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (lpInterface && IsBadReadPtr(lpInterface, SIZEOF(IID)))
    {
        /*
         *  malformed interface id
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS))
    {
        /*
         *  Flags are set that I have no idea about
         */
        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if (IsBadWritePtr(lpulObjType, SIZEOF(ULONG)))
    {
        /*
         *  Can't return an object type
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppUnk, SIZEOF(LPUNKNOWN)))
    {
        /*
         *  Can't return an object
         */

        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    hResult = lpROOT->lpABLogon->lpVtbl->OpenEntry(lpROOT->lpABLogon,
                      cbEntryID,
                      lpEntryID,
                      lpInterface,
                      ulFlags,
                      lpulObjType,
                      lppUnk);

out:

    DebugTraceResult(ROOT_OpenEntry, hResult);
    return hResult;

}

/*
 -  ROOT_SetSearchCriteria
 -
 *
 *  Not implemented for this object
 */
STDMETHODIMP
ROOT_SetSearchCriteria( LPROOT lpROOT,
                        LPSRestriction lpRestriction,
                        LPENTRYLIST lpContainerList,
                        ULONG ulSearchFlags
                       )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        hResult = MakeResult(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
        offsetof(ROOT_Vtbl, SetSearchCriteria)+SIZEOF(ROOT_SetSearchCriteria_METHOD *)))
    {
        /*
         *  vtbl not large enough to support this method
         */

        hResult = MakeResult(E_INVALIDARG);

        goto out;
    }

    /*
     *  Check to see that it's the correct method
     */
    if (ROOT_SetSearchCriteria != lpROOT->lpVtbl->SetSearchCriteria)
    {
        /*
         *  Not my vtbl
         */
        hResult = ResultFromScode(E_INVALIDARG);
        goto out;
    }



    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:
    DebugTraceResult(ROOT_SetSearchCriteria, hResult);
    return hResult;
}

/*
 -  ROOT_GetSearchCriteria
 -
 *
 *  Not implemented for this object
 *
 */
STDMETHODIMP
ROOT_GetSearchCriteria( LPROOT lpROOT,
                        ULONG ulFlags,
                        LPSRestriction FAR * lppRestriction,
                        LPENTRYLIST FAR * lppContainerList,
                        ULONG FAR * lpulSearchState
                       )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  Not large enough
         */
        hResult = MakeResult(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
        offsetof(ROOT_Vtbl, GetSearchCriteria)+SIZEOF(ROOT_GetSearchCriteria_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = MakeResult(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_GetSearchCriteria != lpROOT->lpVtbl->GetSearchCriteria)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        hResult = ResultFromScode(E_INVALIDARG);
        DebugTraceResult(ROOT_GetSearchCriteria, hResult);
        return hResult;
    }

    if ( ulFlags & ~(MAPI_UNICODE) )
    {
        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS );

        return hResult;

    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

    DebugTraceResult(ROOT_GetSearchCriteria, hResult);
    return hResult;
}

/*
 -  ROOT_CreateEntry
 -
 *  New entries cannot be created in the root
 *
 */
STDMETHODIMP
ROOT_CreateEntry( LPROOT lpROOT,
                  ULONG cbEntryID,
                  LPENTRYID lpEntryID,
                  ULONG ulCreateFlags,
                  LPMAPIPROP FAR * lppMAPIPropEntry
                 )
{

    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  No vtbl found
         */
        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
                     offsetof(ROOT_Vtbl, CreateEntry)+SIZEOF(ROOT_CreateEntry_METHOD *)))
    {
        /*
         *  vtbl not large enough to hold this method
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_CreateEntry != lpROOT->lpVtbl->CreateEntry)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:
    DebugTraceResult(ROOT_CreateEntry, hResult);
    return hResult;

}

/*
 -  ROOT_CopyEntries
 -
 *  Entries cannot be copied into the root
 *
 *
 *
 */
STDMETHODIMP
ROOT_CopyEntries( LPROOT lpROOT,
                  LPENTRYLIST lpEntries,
                  ULONG ulUIParam,
                  LPMAPIPROGRESS lpProgress,
                  ULONG ulFlags
                 )
{

    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  No vtbl found
         */
        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
                     offsetof(ROOT_Vtbl, CopyEntries)+SIZEOF(ROOT_CopyEntries_METHOD *)))
    {
        /*
         *  vtbl not large enough to hold this method
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_CopyEntries != lpROOT->lpVtbl->CopyEntries)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);


out:
    DebugTraceResult(ROOT_CopyEntries, hResult);
    return hResult;

}

/*
 -  ROOT_DeleteEntries
 -
 *  Entries cannot be deleted from the root
 *
 *
 *
 */
STDMETHODIMP
ROOT_DeleteEntries( LPROOT lpROOT,
                    LPENTRYLIST lpEntries,
                    ULONG ulFlags)
{

    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  No vtbl found
         */
        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
                     offsetof(ROOT_Vtbl, DeleteEntries)+SIZEOF(ROOT_DeleteEntries_METHOD *)))
    {
        /*
         *  vtbl not large enough to hold this method
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_DeleteEntries != lpROOT->lpVtbl->DeleteEntries)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:
    DebugTraceResult(ROOT_DeleteEntries, hResult);
    return hResult;
}

/*
 -  ROOT_ResolveNames
 -
 *  No special case handling of resolving names within this container
 *
 *
 *
 */
STDMETHODIMP
ROOT_ResolveNames(  LPROOT          lpROOT,
                    LPSPropTagArray lptagaColSet,
                    ULONG           ulFlags,
                    LPADRLIST       lpAdrList,
                    LPFlagList      lpFlagList )
{

    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+SIZEOF(ROOT_Vtbl *)))
    {
        /*
         *  No vtbl found
         */
        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpROOT->lpVtbl,
                     offsetof(ROOT_Vtbl, ResolveNames)+SIZEOF(ROOT_ResolveNames_METHOD *)))
    {
        /*
         *  vtbl not large enough to hold this method
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    /*
     *  Check to see if the method is the same
     */
    if (ROOT_ResolveNames != lpROOT->lpVtbl->ResolveNames)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = MakeResult(E_INVALIDARG);
        goto out;
    }

    hResult = ResultFromScode(MAPI_E_NO_SUPPORT);

out:
    DebugTraceResult(ROOT_ResolveNames, hResult);
    return hResult;
}
#undef _FAXAB_ROOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\oouser.h ===
/***********************************************************************
 *
 *  _ABOOUSER.H
 *
 *  Header file for code in ABOOUSER.C
 *
 *  Copyright 1992, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

/*
 * the one-off user object
 */	
#undef	INTERFACE
#define INTERFACE	struct _ABOOUSER

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ABOOUSER_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAILUSER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ABOOUSER_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IMAILUSER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABOOUSER_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IMAILUSER_METHODS(IMPL)
};

typedef struct _ABOOUSER
{
	ABOOUSER_Vtbl FAR * lpVtbl;


    FAB_Wrapped;

	// Table for a drop down list control
	LPTABLEDATA	lpTDatDDListBox;

} ABOOUSER, *LPABOOUSER;

#define CBABOOUSER	sizeof(ABOOUSER)

/*
 *  Function prototypes
 *
 */
/* Functions in oouser.c */
HRESULT
HrNewFaxOOUser (LPMAILUSER *        lppMAPIPropEntry,
                ULONG *             lpulObjType,
                ULONG               cbEntryID,
                LPENTRYID           lpEntryID,
                LPABLOGON           lpABPLogon,
                LPCIID              lpInterface,
                HINSTANCE           hLibrary,
                LPALLOCATEBUFFER    lpAllocBuff,
                LPALLOCATEMORE      lpAllocMore,
                LPFREEBUFFER        lpFreeBuff,
                LPMALLOC            lpMalloc );
HRESULT	HrBuildDDLBXRecipCapsTable(LPABUSER lpABUser);

#ifdef _FAXAB_OOUSER
OOUSER_ENTRYID ONEOFF_EID =
{
	0,  // | MAPI_NOTRECIP;  /*  long-term, recipient */
	0,
	0,
	0,
	MUIDABMAWF,
	MAWF_VERSION,
	MAWF_ONEOFF,
/*
	{{0},				// Display Name
	 {0},				// Email Address
	 {"FAX"}, 			// Address Type
	 {0}				// Machine capabilities
	} 
*/
};
#else
OOUSER_ENTRYID ONEOFF_EID;
#endif

#ifdef	__cplusplus
}		/* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\property.h ===
/***************************************************************************

        Name      : property.h

        Comment   : Defines the properties used by Microsoft Fax

        Created   : 10/93, from the list of WFW fax properties

        Author(s) : Bruce Kelley and Yoram Yaacovi

        Contribs  :

        Changes   : 8/2/95: documented

        Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.

***************************************************************************/
/*
    @doc    EXTERNAL    MAPI Properties    OVERVIEW

    @topic  Overview of MAPI Properties | Below you will find the list of properties that were
            defined and are being used by Microsoft Fax. These properties
            are defined in the MAPI respective ranges.<nl>
                         <nl>
                         <t PR_AREA_CODE>,<nl>
                         <t PR_ATTACH_SIGNATURE>,<nl>
                         <t PR_COUNTRY_ID>,<nl>
                         <t PR_FAX_ACTIVE_MODEM_NAME>,<nl>
                         <t PR_FAX_BGN_MSG_ON_COVER>,<nl>
                         <t PR_FAX_BILLING_CODE>,<nl>
                         <t PR_FAX_BILLING_CODE_DWORD>,<nl>
                         <t PR_FAX_CALL_CARD_NAME>,<nl>
                         <t PR_FAX_CHEAP_BEGIN_HOUR>,<nl>
                         <t PR_FAX_CHEAP_BEGIN_MINUTE>,<nl>
                         <t PR_FAX_CHEAP_END_HOUR>,<nl>
                         <t PR_FAX_CHEAP_END_MINUTE>,<nl>
                         <t PR_FAX_COVER_PAGE_BODY>,<nl>
                         <t PR_FAX_CP_NAME>,<nl>
                         <t PR_FAX_DEFAULT_COVER_PAGE>,<nl>
                         <t PR_FAX_DELIVERY_FORMAT>,<nl>
                         <t PR_FAX_DISPLAY_PROGRESS>,<nl>
                         <t PR_FAX_EMBED_LINKED_OBJECTS>,<nl>
                         <t PR_FAX_ENABLE_RECIPIENT_OPTIONS>,<nl>
                         <t PR_FAX_ENCRYPTION_KEY>,<nl>
                         <t PR_FAX_FAXJOB>,<nl>
                         <t PR_FAX_IMAGE>,<nl>
                         <t PR_FAX_IMAGE_QUALITY>,<nl>
                         <t PR_FAX_INCLUDE_COVER_PAGE>,<nl>
                         <t PR_FAX_LMI_CUSTOM_OPTION>,<nl>
                         <t PR_FAX_LOGO_STRING>,<nl>
                         <t PR_FAX_LOG_ENABLE>,<nl>
                         <t PR_FAX_LOG_NUM_OF_CALLS>,<nl>
                         <t PR_FAX_MAX_TIME_TO_WAIT>,<nl>
                         <t PR_FAX_MINUTES_BETWEEN_RETRIES>,<nl>
                         <t PR_FAX_MUST_RENDER_ALL_ATTACH>,<nl>
                         <t PR_FAX_NETFAX_DEVICES>,<nl>
                         <t PR_FAX_NOT_EARLIER_DATE>,<nl>
                         <t PR_FAX_NOT_EARLIER_HOUR>,<nl>
                         <t PR_FAX_NOT_EARLIER_MINUTE>,<nl>
                         <t PR_FAX_NUMBER_RETRIES>,<nl>
                         <t PR_FAX_PAPER_SIZE>,<nl>
                         <t PR_FAX_PREVIOUS_STATE>,<nl>
                         <t PR_FAX_PREV_BILLING_CODES>,<nl>
                         <t PR_FAX_PRINT_HEADER>,<nl>
                         <t PR_FAX_PRINT_ORIENTATION>,<nl>
                         <t PR_FAX_PRINT_TO_NAME>,<nl>
                         <t PR_FAX_PRINT_TO_PAGES>,<nl>
                         <t PR_FAX_PRODUCT_NAME>,<nl>
                         <t PR_FAX_PROFILE_VERSION>,<nl>
                         <t PR_FAX_RBA_DATA>,<nl>
                         <t PR_FAX_RECIP_CAPABILITIES>,<nl>
                         <t PR_FAX_SECURITY_RECEIVED>,<nl>
                         <t PR_FAX_SECURITY_SEND>,<nl>
                         <t PR_FAX_SENDER_COUNTRY_ID>,<nl>
                         <t PR_FAX_SENDER_EMAIL_ADDRESS>,<nl>
                         <t PR_FAX_SENDER_NAME>,<nl>
                         <t PR_FAX_SEND_WHEN_TYPE>,<nl>
                         <t PR_FAX_SHARE_DEVICE>,<nl>
                         <t PR_FAX_SHARE_NAME>,<nl>
                         <t PR_FAX_SHARE_PATHNAME>,<nl>
                         <t PR_FAX_TAPI_LOC_ID>,<nl>
                         <t PR_FAX_WORK_OFF_LINE>,<nl>
                         <t PR_HOP_INDEX>,<nl>
                         <t PR_MESSAGE_TYPE>,<nl>
                         <t PR_POLLTYPE>,<nl>
                         <t PR_POLL_RETRIEVE_PASSWORD>,<nl>
                         <t PR_POLL_RETRIEVE_SENDME>,<nl>
                         <t PR_POLL_RETRIEVE_TITLE>,<nl>
                         <t PR_RECIP_INDEX>,<nl>
                         <t PR_RECIP_VOICENUM>,<nl>
                         <t PR_TEL_NUMBER>

    @xref <nl>
        <t MAPI Property Ranges>,<nl>
        <t Microsoft Fax Property Ranges>,<nl>
        <t Microsoft Fax Address Type>,<nl>
        <t Microsoft Fax Options>,<nl>
        <t Fax Address Book Internal Properties>,<nl>
        <t Scheduling Properties>,<nl>
        <t Retry Properties>,<nl>
        <t Cover Page Properties>,<nl>
        <t Delivery Format Properties>,<nl>
        <t Fax Transport Identification Properties>,<nl>
        <t Fax Internal Properties>,<nl>
        <t Fax Billing Code Properties>,<nl>
        <t Fax Logging Properties>,<nl>
        <t Fax Security Properties>,<nl>
        <t Fax Poll Retrieval Properties>,<nl>
        <t Miscellaneous IFAX Properties>
*/

#define TRANSPORT_ENVELOPE_BASE             0x4000
#define TRANSPORT_RECIP_BASE                0x5800
#define USER_NON_TRANSMIT_BASE              0x6000
#define PROVIDER_INTERNAL_NON_TRANSMIT_BASE 0x6600
#define MESSAGE_CLASS_CONTENT_BASE          0x6800
#define MESSAGE_CLASS_NON_TRANSMIT_BASE     0x7C00

/*
    @doc EXTERNAL   PROPERTIES

    @subtopic  MAPI Property Ranges | The list below was taken from
            mapitags.h in the MAPI SDK. It represents the property ranges
            as defined by MAPI.

        From            To      Kind of property<nl>
        ----------------------------------------------------------<nl>
        0001    0BFF    MAPI_defined envelope property<nl>
        0C00    0DFF    MAPI_defined per-recipient property<nl>
        0E00    0FFF    MAPI_defined non-transmittable property<nl>
        1000    2FFF    MAPI_defined message content property<nl>
        3000    3FFF    MAPI_defined property (usually not message or
                       recipient)<nl>
        4000    57FF    Transport-defined envelope property<nl>
        5800    5FFF    Transport-defined per-recipient property<nl>
        6000    65FF    User-defined non-transmittable property<nl>
        6600    67FF    Provider-defined internal non-transmittable
                        property<nl>
        6800    7BFF    Message class-defined content property<nl>
        7C00    7FFF    Message class-defined non-transmittable
                        property<nl>
        8000    FFFE    User-defined Name-to-id mapped property<nl>

        The 3000-3FFF range is further subdivided as follows:<nl>

        From            To      Kind of property<nl>
        ------------------------------------------------------------<nl>
        3000    33FF    Common property such as display name, entry ID<nl>
        3400    35FF    Message store object<nl>
        3600    36FF    Folder or AB container<nl>
        3700    38FF    Attachment<nl>
        3900    39FF    Address book object<nl>
        3A00    3BFF    Mail user<nl>
        3C00    3CFF    Distribution list<nl>
        3D00    3DFF    Profile section<nl>
        3E00    3FFF    Status object

    @subtopic  Microsoft Fax Property Ranges | Microsoft Fax further defines
            property ranges within the MAPI property ranges in which the
            fax properties are defined. Some offset off the MAPI property
            range was used to reduce the possibility of collision with
            properties defined by other MAPI transports.<nl>

            EFAX_MESSAGE_BASE:<nl>
                         Starting property ID for fax message properties<nl>

                         EFAX_RECIPIENT_BASE:<nl>
                         Starting property ID for fax recipient properties<nl>

            EFAX_OPTIONS_BASE:<nl>
                         Starting property ID for fax properties (options) which
                         are not transmittable. These properties are used for fax
                         setup and are not message or recipient related.
                         Example: current active fax device.
*/

#define EFAX_MESSAGE_BASE      TRANSPORT_ENVELOPE_BASE + 0x500
#define EFAX_RECIPIENT_BASE    TRANSPORT_RECIP_BASE + 0x100
#define EFAX_OPTIONS_BASE      PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x100

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic  Microsoft Fax Address Type | Microsoft Fax's address type is "FAX".
            It has major importance, in the sense that the Microsoft Fax
            transport will only handle recipients that have this address
            type in their PR_ADDRTYPE.
*/
#define EFAX_ADDR_TYPE                      "FAX"

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic  Microsoft Fax Options | Microsoft Fax defines some properties
                 that control the way the fax product operates. These properties
                 are mostly fax configuration properties and are stored in the
                 fax transport section in the MAPI profile.<nl>
                 <nl>
                 <t PR_FAX_ACTIVE_MODEM_NAME><nl>
                 <t PR_FAX_WORK_OFF_LINE><nl>
                 <t PR_FAX_SHARE_DEVICE><nl>
                 <t PR_FAX_SHARE_NAME><nl>
                 <t PR_FAX_SENDER_COUNTRY_ID><nl>
                 <t PR_FAX_NETFAX_DEVICES><nl>
                 <t PR_FAX_SHARE_PATHNAME><nl>
                 <t Scheduling Properties><nl>
                 <t Retry Properties><nl>
                 <t Cover Page Properties><nl>
                 <t Delivery Format Properties><nl>
                 <t PR_FAX_BGN_MSG_ON_COVER><nl>
                 <t PR_FAX_TAPI_LOC_ID><nl>
                 <t Fax Security Properties><nl>
                 <t Fax Poll Retrieval Properties>
*/

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRODUCT_NAME |
        Name of the fax product. Used for profile validity
        verification.
    @comm Settable through UI: Yes
*/
#define PR_FAX_PRODUCT_NAME     PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x0))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_ACTIVE_MODEM_NAME |
        Name of the currently active faxing device. There can be
        only one active fax device at a time.  The name has the
        following format:<nl>
                <lt>name-or-identifier<gt>:<lt>DLL-name<gt><nl>
                                 <nl>
        Where:<nl>
                <lt>name-or-identifier<gt> is the name of the active
                    device.  The name can be anything, and is
                    meaningful only for the LMI provider that
                    handles this device.<nl>
                                 <nl>
                <lt>DLL-name<gt> is the name of the DLL that handles
                    this device. This DLL must export the LMI
                    interface. See the LMI doc for details.<nl>
    @ex When the active device is a netfax device, the
        name will be something like: |
                    \\faxserver\netfax:awnfax32.dll
    @comm Settable through UI: Yes
*/
#define PR_FAX_ACTIVE_MODEM_NAME            PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x1))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_WORK_OFF_LINE |
        If TRUE, the Microsoft Fax transport will work offline,
        i.e. it will not kick off the LMI provider for the active
        fax device.
    @comm Settable through UI: No
*/
#define PR_FAX_WORK_OFF_LINE                PROP_TAG(PT_BOOLEAN, (EFAX_OPTIONS_BASE + 0x2))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SHARE_DEVICE |
        If TRUE, the user selected to share his active fax
        device so that others can fax through it.
    @comm Settable through UI: Yes
*/
#define PR_FAX_SHARE_DEVICE                 PROP_TAG(PT_BOOLEAN, (EFAX_OPTIONS_BASE + 0x3))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SHARE_NAME |
        If sharing is enabled, this is the name of the share
        that users will use to connect and send faxes through
        the active fax device on this machine.
    @comm Settable through UI: Yes
*/
#define PR_FAX_SHARE_NAME                   PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x4))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SENDER_COUNTRY_ID |
        This property is used internally by the fax
        configuration code to store the country ID of the sender.
        There is no guarantee that this property will have the
        appropriate country ID in the profile.
    @comm Settable through UI: No
*/
#define PR_FAX_SENDER_COUNTRY_ID            PROP_TAG(PT_LONG,    (EFAX_OPTIONS_BASE + 0x5))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NETFAX_DEVICES |
        The name of this property is somewhat misleading. This
        property is a MAPI multi-value property that stores the
        names of the "other" devices the user added to his list
        of available devices. These "other" devices include,
        but are not limited to, netfax devices.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NETFAX_DEVICES               PROP_TAG(PT_MV_STRING8, (EFAX_OPTIONS_BASE + 0x6))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SHARE_PATHNAME |
        Pathname of the shared fax directory on the sharing
        machine. Don't confuse this with the share name,
        PR_FAX_SHARE_NAME; this is the full pathname to the
        shared directory on the sharing machine, and not the
        name clients will use to connect to this share.
    @comm Settable through UI: No
*/
#define PR_FAX_SHARE_PATHNAME               PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x7))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PROFILE_VERSION |
        The version of the Microsoft Fax transport section in
        the MAPI profile.  Set to 0x00000001 in Windows 95.
    @comm Settable through UI: No
*/
#define PR_FAX_PROFILE_VERSION              PROP_TAG(PT_LONG, (EFAX_OPTIONS_BASE + 0x8))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic  Fax Address Book Internal Properties | These properties
        are used internally by the fax address book provider to
        store the components of a fax address in the wrapped
        fax address book entry.<nl>
        <t PR_COUNTRY_ID><nl>
        <t PR_AREA_CODE><nl>
        <t PR_TEL_NUMBER>
    @comm These should probably have been offsets off EFAX_OPTIONS_BASE, but it's
        too late to change now.
    @comm Settable through UI: Yes<nl>
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_COUNTRY_ID |
        The user's return fax number country code.
    @comm Settable through UI: Yes
*/
#define PR_COUNTRY_ID                       PROP_TAG(PT_LONG,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x7)
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_AREA_CODE |
        The user's return fax number area code.
    @comm Settable through UI: Yes
*/
#define PR_AREA_CODE_A                      PROP_TAG(PT_STRING8,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x8)
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_TEL_NUMBER |
        The user's return fax number.
    @comm Settable through UI: Yes
*/
#define PR_TEL_NUMBER_A                     PROP_TAG(PT_STRING8,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x9)

//
// Non-Transmittable message properties
//

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Scheduling Properties | These properties are used to specify
        the cheap times or the time to send.  The hour goes in the HOUR
        property, the MINUTE goes into the MINUTE property.  If you set
        PR_FAX_CHEAP_BEGIN_* you must also set PR_FAX_CHEAP_END_*.
        PR_FAX_NOT_EARLIER_DATE is currently not used.  Setting
        PR_FAX_SEND_WHEN_TYPE determines which of these properties to
        use.  If it is set to SEND_ASAP or is absent, they are all
        ignored.  If it is set to SEND_CHEAP, we will use the
        PR_FAX_CHEAP_* properties.  If it is set to SEND_AT_TIME, we
        will use PR_FAX_NOT_EARLIER_*.<nl>
            <t PR_FAX_CHEAP_BEGIN_HOUR><nl>
            <t PR_FAX_CHEAP_BEGIN_MINUTE><nl>
            <t PR_FAX_CHEAP_END_HOUR><nl>
            <t PR_FAX_CHEAP_END_MINUTE><nl>
            <t PR_FAX_NOT_EARLIER_HOUR><nl>
            <t PR_FAX_NOT_EARLIER_MINUTE><nl>
            <t PR_FAX_NOT_EARLIER_DATE>
     @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_BEGIN_HOUR |
        The hour portion of start of the "cheap times" interval beginning time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_BEGIN_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_BEGIN_MINUTE |
        The minute portion of start of the "cheap times" interval beginning time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_BEGIN_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x2))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_END_HOUR |
        The hour portion of start of the "cheap times" interval ending time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_END_HOUR               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x3))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_END_MINUTE |
        The minute portion of start of the "cheap times" interval ending time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_END_MINUTE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x4))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NOT_EARLIER_HOUR |
        The hour portion of start of the "send at" time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NOT_EARLIER_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x5))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NOT_EARLIER_MINUTE |
        The minute portion of start of the "send at" time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NOT_EARLIER_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x6))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NOT_EARLIER_DATE |
        The date portion of start of the "send at" time.
    @comm Settable through UI: Not Yet
    @comm This feature is not yet implemented.
*/
#define PR_FAX_NOT_EARLIER_DATE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x7))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Retry Properties | These properties specify the retry
        behavior if the dialed fax number is busy.<nl>
        <t PR_FAX_NUMBER_RETRIES><nl>
        <t PR_FAX_MINUTES_BETWEEN_RETRIES>
    @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NUMBER_RETRIES |
        The number of times to retry a busy fax number.  If 0, only one attempt will
        be made before an NDR is generated.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NUMBER_RETRIES               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x8))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_MINUTES_BETWEEN_RETRIES |
        The number of minutes to wait before retrying a busy fax number.
    @comm Settable through UI: Yes
*/
#define PR_FAX_MINUTES_BETWEEN_RETRIES      PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x9))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Cover Page Properties | These properties specify cover page
        behavior.<nl>
        <t PR_FAX_INCLUDE_COVER_PAGE><nl>
        <t PR_FAX_COVER_PAGE_BODY><nl>
        <t PR_FAX_BGN_MSG_ON_COVER><nl>
        <t PR_FAX_DEFAULT_COVER_PAGE>
    @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_INCLUDE_COVER_PAGE |
        If set to TRUE, we will include a cover page IF this fax is sent as Not Editable.
    @comm Settable through UI: Yes
*/
#define PR_FAX_INCLUDE_COVER_PAGE           PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0xA))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_COVER_PAGE_BODY |
        This property is obsolete.
    @comm Settable through UI: No
*/
#define PR_FAX_COVER_PAGE_BODY              PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xB))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LOGO_STRING |
        This property is obsolete.
*/
#define PR_FAX_LOGO_STRING_A                PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0xC))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Delivery Format Properties | These properties override the
        default delivery format behavior.<nl>
        <t PR_FAX_DELIVERY_FORMAT><nl>
        <t PR_FAX_PRINT_ORIENTATION><nl>
        <t PR_FAX_PAPER_SIZE><nl>
        <t PR_FAX_IMAGE_QUALITY>
*/

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_DELIVERY_FORMAT |
        Determines whether this fax should be sent SEND_EDITABLE,
        SEND_PRINTED or SEND_BEST.
    @xref <t PR_FAX_DELIVERY_FORMAT Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_DELIVERY_FORMAT              PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0xD))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_ORIENTATION |
        Determines the orientation for the message body and for attachments
        which don't have their own idea what orientation to print in.
    @xref <t PR_FAX_PRINT_ORIENTATION Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_PRINT_ORIENTATION            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xE))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PAPER_SIZE |
        Determines what size page should be rendered.
    @xref <t PR_FAX_PAPER_SIZE Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_PAPER_SIZE                   PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xF))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_IMAGE_QUALITY |
        Determines the image quality to render, ie, Standard (100x200),
        Fine (200x200), or 300 Dpi.
    @xref <t PR_FAX_IMAGE_QUALITY Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_IMAGE_QUALITY                PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x10))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Transport Identification Properties | These properties
        set the identification of the sender on the message.
        These properties should not be modified outside of the transport.<nl>
        <t PR_FAX_SENDER_NAME><nl>
        <t PR_FAX_SENDER_EMAIL_ADDRESS>
    @comm Settable through UI: Indirectly
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SENDER_NAME |
         This message property identifies Microsoft Fax transport's idea of the
         sender of the message.  This property is copied from the profile's
         PR_SENDER_NAME and is the display name of the sender.
         This property should not be modified outside of the transport.
    @comm Settable through UI: Indirectly
*/
#define PR_FAX_SENDER_NAME_A                PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x11))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SENDER_EMAIL_ADDRESS |
         This message property identifies Microsoft Fax transport's idea of the
         sender of the message.  This property is copied from the profile's
         PR_SENDER_EMAIL_ADDRESS and is the fax address (number) of the sender.
         This property should not be modified outside of the transport.
    @comm Settable through UI: Indirectly
*/
#define PR_FAX_SENDER_EMAIL_ADDRESS_A       PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x12))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LMI_CUSTOM_OPTION |
        This property allows a block of data to be sent directly from the MAPI
        client down to the LMI provider.  This is specifically designed to allow
        for communication from an LMI custom property page to communicate it's
        per-message settings to the LMI.  See the LMI help file for more
        information.
    @comm Settable through UI: No
*/
#define PR_FAX_LMI_CUSTOM_OPTION            PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x13))
/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Internal Properties | These two properties are internal to
    the fax transport and should not be modified.<nl>
        <t PR_FAX_PREVIOUS_STATE><nl>
        <t PR_FAX_FAXJOB>
    Settable through UI: No
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PREVIOUS_STATE |
        This property is internal to the fax transport and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_PREVIOUS_STATE               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x14))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_FAXJOB |
        This property maintains the current state of a sent fax.
        It is removed when the job has been sent or NDR'd.
        This property is internal to the fax transport and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_FAXJOB                       PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x15))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Billing Code Properties | A billing code can be associated
        with a message.  This feature is not yet implemented.<nl>
        <t PR_FAX_BILLING_CODE><nl>
        <t PR_FAX_PREV_BILLING_CODES><nl>
        <t PR_FAX_BILLING_CODE_DWORD>

    @comm Settable through UI: Not Yet.
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_BILLING_CODE |
        A billing code can be associated with a message. This property contains
                the ASCII equivalent of PR_FAX_BILLING_CODE_DWORD and might be dropped in
                future.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_BILLING_CODE_A               PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x16))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PREV_BILLING_CODES |
        This is property is for internal use and is subject to change in the future.
        It is a multi-value MAPI property that contains the list of the last 10
        billing codes that the user used.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_PREV_BILLING_CODES           PROP_TAG(PT_MV_STRING8, (EFAX_MESSAGE_BASE + 0x17))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_BGN_MSG_ON_COVER |
        Set TRUE if the message should start on the cover page.  This is ignored
        if there is no cover page generated.  All Rich Text formatting of the message
        body is lost when this feature is used.
    @comm Settable through UI: Yes
*/
#define PR_FAX_BGN_MSG_ON_COVER             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x18))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SEND_WHEN_TYPE |
        Defines how the fax should be scheduled in concert with the Fax
        Scheduling Properties.
    @comm Settable through UI: Yes
*/
#define PR_FAX_SEND_WHEN_TYPE               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x19))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_DEFAULT_COVER_PAGE |
        Defines which cover page template to use.  Must contain the
        full pathname of the file.
    @comm Settable through UI: Yes
*/
#define PR_FAX_DEFAULT_COVER_PAGE_A         PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x1A))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_MAX_TIME_TO_WAIT |
        Maximum Time to wait for connection (seconds).
        This property is obsolete.
*/
#define PR_FAX_MAX_TIME_TO_WAIT             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1B))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Logging Properties | Define behavior of call logging
        feature.
        This feature is not yet implemented.<nl>
        <t PR_FAX_LOG_ENABLE><nl>
        <t PR_FAX_LOG_NUM_OF_CALLS>
    @comm Settable through UI: Not Yet
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LOG_ENABLE |
        Turn on or off the call logging feature.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_LOG_ENABLE                   PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1C))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LOG_NUM_OF_CALLS |
        The number of calls that call logging should keep track of.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_LOG_NUM_OF_CALLS             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1D))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_DISPLAY_PROGRESS |
        This property is not used at this time.
*/
// Display call progress
#define PR_FAX_DISPLAY_PROGRESS             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1E))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_EMBED_LINKED_OBJECTS |
        This property is set TRUE if the transport should convert linked
        objects to static objects before sending.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_EMBED_LINKED_OBJECTS         PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1F))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_TAPI_LOC_ID |
        This property is used to store the TAPI location ID associated with
                this profile. It is currently not used, i.e. we always use the default
                TAPI location
    @comm Settable through UI: No
*/
#define PR_FAX_TAPI_LOC_ID                  PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x20))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_MUST_RENDER_ALL_ATTACH |
        This property is not used at this time.
*/
#define PR_FAX_MUST_RENDER_ALL_ATTACH       PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x21))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_ENABLE_RECIPIENT_OPTIONS |
        This property is set TRUE if per-recipient options are desired.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_ENABLE_RECIPIENT_OPTIONS     PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x22))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CALL_CARD_NAME |
        This property defines what calling card should be used for this call.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_CALL_CARD_NAME_A             PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x24))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_TO_NAME |
        This property defines the RBA data stream placed on the message
        or attachment.  It is internal to Microsoft Fax and should not
        be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_PRINT_TO_NAME_A              PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x25))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Security Properties |
        ??? <nl>
        <t PR_FAX_SECURITY_SEND><nl>
        <t PR_FAX_SECURITY_RECEIVED><nl>
        <t PR_ATTACH_SIGNATURE><nl>
        <t PR_FAX_ENCRYPTION_KEY>
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SECURITY_SEND |
        ???
    @comm Settable through UI: ??
*/
#define PR_FAX_SECURITY_SEND                PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x26))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SECURITY_RECEIVED |
        ???
    @comm Settable through UI: ??
*/
#define PR_FAX_SECURITY_RECEIVED            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x27))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_RBA_DATA |
        This property defines the RBA data stream placed on a print-to-fax
        message.  It is internal to Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_RBA_DATA                     PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x28))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Poll Retrieval Properties | These properties define the
        behavior of a poll retrieve request.  If <t PR_POLL_RETRIEVE_SENDME>
        is SENDME_DEFAULT the default document will be polled from the
        dialed fax.  Otherwise, we will poll for the document named in
        <t PR_POLL_RETRIEVE_TITLE> with the optional password specified in
        <t PR_POLL_RETRIEVE_PASSWORD>.  <t PR_POLLTYPE> is obsolete.
    @xref <t PR_POLL_RETRIEVE_SENDME Values>
    @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLL_RETRIEVE_SENDME |
      If this property contains <t SENDME_DEFAULT>, the default document will be polled
      from the dialed fax number.  Otherwise we will poll for the document named in
      <t PR_POLL_RETRIEVE_TITLE> with the optional password specified in
      <t PR_POLL_RETRIEVE_PASSWORD>.
    @xref <t PR_POLL_RETRIEVE_SENDME Values>
    @comm Settable through UI: Yes
*/
#define PR_POLL_RETRIEVE_SENDME             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x29))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLL_RETRIEVE_TITLE |
        Contains the title of the document to retrive in a polling call.
    @comm Settable through UI: Yes
*/
#define PR_POLL_RETRIEVE_TITLE              PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x30))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLL_RETRIEVE_PASSWORD |
        Contains the password to use in a polling call.
    @comm Settable through UI: Yes
*/
#define PR_POLL_RETRIEVE_PASSWORD           PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x31))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLLTYPE |
        This property is obsolete.
    @comm Settable through UI: No
*/
#define PR_POLLTYPE                         PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x32))


/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_MESSAGE_TYPE |
        This property is used by the poll server.
    @comm This feature is not yet implemented.
*/
#define PR_MESSAGE_TYPE                     PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x33))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_ATTACH_SIGNATURE |
        This property contains the encrypted digital signature for an attachment.
    @comm Settable through UI: Indirectly
*/
#define PR_ATTACH_SIGNATURE                 PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x34))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_TO_PAGES |
        This property is set during the Print-to-Fax operation and contains the
        number of pages printed for use on the cover page.  This is internal to
        Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_PRINT_TO_PAGES               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x35))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_IMAGE |
        This property is set on an incoming linearized image message and contains
        the image data prior to conversion to RBA.  This property is internal to
        Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_IMAGE                        PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x36))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_HEADER |
        This property controls branding of G3 faxed pages.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_PRINT_HEADER                 PROP_TAG(PT_BOOLEAN,  (EFAX_MESSAGE_BASE + 0x37))


/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_BILLING_CODE_DWORD |
        This is the DWORD representation of the billing code. This
                is the representation that will be tacked to a message.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_BILLING_CODE_DWORD           PROP_TAG(PT_LONG, (EFAX_MESSAGE_BASE + 0x38))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Miscellaneous IFAX Properties | These Non-Transmittable
        Mail-User properties are internal to Microsoft Fax or are
        obsolete.  Do not use or rely on them.<nl>
        <t PR_FAX_RECIP_CAPABILITIES><nl>
        <t PR_FAX_CP_NAME><nl>
        <t PR_RECIP_INDEX><nl>
        <t PR_HOP_INDEX><nl>
        <t PR_RECIP_VOICENUM>
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_RECIP_CAPABILITIES |
        May be set on a received fax if the sender sent it.
        This is currently only sent by IFAX.
    @comm Settable through UI: No
*/
#define PR_FAX_RECIP_CAPABILITIES           PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x0))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CP_NAME |
        This property is not currently used by Microsoft Fax.
    @comm Settable through UI: No
*/
#define PR_FAX_CP_NAME                      PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_W                    PROP_TAG(PT_UNICODE, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_A                    PROP_TAG(PT_STRING8, (EFAX_RECIPIENT_BASE + 0x1))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_RECIP_INDEX |
        This recipient property is internal to Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_RECIP_INDEX                      PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x2))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_HOP_INDEX |
        This recipient property is internal to Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_HOP_INDEX                        PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x3))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_RECIP_VOICENUM |
        This recipient property may be set on a received fax if the sender sent it.
        It contains the voice phone number associated with that recipient.
    @comm Settable through UI: No
*/
#define PR_RECIP_VOICENUM                   PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x4))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_ENCRYPTION_KEY |
        ???
    @comm Settable through UI: Indirectly
*/
#define PR_FAX_ENCRYPTION_KEY               PROP_TAG(PT_BINARY,  (EFAX_RECIPIENT_BASE + 0x5))


/**********************************************************************************

   Property Values Section

***********************************************************************************/

//
// LOGON Properties
//
// Properties we store in the Profile.
//
// The following is used to access the properties in the logon array.
// If you add a property to the profile, you should increment this number!
#define MAX_LOGON_PROPERTIES                10

// Other logon properties:
//  PR_SENDER_NAME                          - in mapitags.h
//  PR_SENDER_EMAIL_ADDRESS                 - in mapitags.h (this file)

#define NUM_SENDER_PROPS            3       // How many sender ID properties?

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_DELIVERY_FORMAT Values |
            Values for <t PR_FAX_DELIVERY_FORMAT>:
    @emem   SEND_BEST | Use best available. (May be determined at call time if recipient
            capabilities are not yet cached.)  Editable format will be preferred if the
            receiver is capable of receiving editable format. This is the default value.
    @emem   SEND_EDITABLE | Send as email.  If recipient is not capable, NDR.
    @emem   SEND_PRINTED | Send as FAX image.
*/
#define SEND_BEST                  0
#define SEND_EDITABLE              1
#define SEND_PRINTED               2
#define DEFAULT_SEND_AS            SEND_BEST

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_SEND_WHEN_TYPE Values |
            Values for <t PR_FAX_SEND_WHEN_TYPE>:
    @emem   SEND_ASAP | Send as soon as possible.  (This is the default value.)
    @emem   SEND_CHEAP | Use the cheap times to determine when to send.  These are
            specified in <t PR_FAX_CHEAP_BEGIN_HOUR>, <t PR_FAX_CHEAP_BEGIN_MINUTE>,
            <t PR_FAX_CHEAP_END_HOUR> and <t PR_FAX_CHEAP_END_MINUTE>.
    @emem   SEND_AT_TIME | Send at the time specified in <t PR_FAX_NOT_EARLIER_HOUR> and
            <t PR_FAX_NOT_EARLIER_MINUTE>.
*/
#define SEND_ASAP                  0
#define SEND_CHEAP                 1
#define SEND_AT_TIME               2
#define DEFAULT_SEND_AT            SEND_ASAP

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_PAPER_SIZE Values |
            Values for <t PR_FAX_PAPER_SIZE>:
    @emem   PAPER_US_LETTER | US Letter size.
    @emem   PAPER_US_LEGAL  | US Legal size.
    @emem   PAPER_A4 | Metric A4 paper size.
    @emem   PAPER_B4 | Metric B4 paper size.
    @emem   PAPER_A4 | Metric A3 paper size.
*/
#define PAPER_US_LETTER            0       // US Letter page size
#define PAPER_US_LEGAL             1
#define PAPER_A4                   2
#define PAPER_B4                   3
#define PAPER_A3                   4
// "real" default page size is in a resource string depending on U.S. vs metric
#define DEFAULT_PAPER_SIZE      PAPER_US_LETTER     // Default page size

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_PRINT_ORIENTATION Values |
            Values for <t PR_FAX_PRINT_ORIENTATION>:
    @emem   PRINT_PORTRAIT | Portrait printing.  (This is the default value.)
    @emem   PAPER_LANDSCAPE | Landscape printing.
*/
// Print Orientation
// PR_FAX_PRINT_ORIENTATION
#define PRINT_PORTRAIT             0       // Protrait printing
#define PRINT_LANDSCAPE            1
#define DEFAULT_PRINT_ORIENTATION  PRINT_PORTRAIT

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_IMAGE_QUALITY Values |
            Values for <t PR_FAX_IMAGE_QUALITY>:
    @emem   IMAGE_QUALITY_BEST     | Best available based upon cached capabilities.
    @emem   IMAGE_QUALITY_STANDARD | Standard fax quality.  (About 100 x 200 dpi)
    @emem   IMAGE_QUALITY_FINE     | Fine fax quality.  (About 200 dpi)
    @emem   IMAGE_QUALITY_300DPI   | 300 DPI resolution.
    @emem   IMAGE_QUALITY_400DPI   | 400 DPI resolution.
*/
#define IMAGE_QUALITY_BEST         0
#define IMAGE_QUALITY_STANDARD     1
#define IMAGE_QUALITY_FINE         2
#define IMAGE_QUALITY_300DPI       3
#define IMAGE_QUALITY_400DPI       4
#define DEFAULT_IMAGE_QUALITY      IMAGE_QUALITY_BEST

// Modem specific property values are obsolete
// PR_FAX_SPEAKER_VOLUME
#define NUM_OF_SPEAKER_VOL_LEVELS  4   // Number of speaker volume levels
#define DEFAULT_SPEAKER_VOLUME     2   // Default speaker volume level
#define SPEAKER_ALWAYS_ON          2   // Speaker mode: always on
#define SPEAKER_ON_UNTIL_CONNECT   1   // speaker on unitl connected
#define SPEAKER_ALWAYS_OFF         0   // Speaker off
#define DEFAULT_SPEAKER_MODE       SPEAKER_ON_UNTIL_CONNECT   // Default speaker mode

// PR_FAX_ANSWER_MODE
#define NUM_OF_RINGS                3
#define ANSWER_NO                  0
#define ANSWER_MANUAL               1
#define ANSWER_AUTO                 2
#define DEFAULT_ANSWER_MODE         ANSWER_NO

// Blind Dial
#define DEFAULT_BLIND_DIAL         3
// Comma Delay
#define DEFAULT_COMMA_DELAY            2
// Dial Tone Wait
#define DEFAULT_DIAL_TONE_WAIT     30
// Hangup Delay
#define DEFAULT_HANGUP_DELAY       60

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_POLL_RETRIEVE_SENDME Values |
            Values for <t PR_POLL_RETRIVE_SENDME>:
    @emem   SENDME_DEFAULT      | Poll for the default document
    @emem   SENDME_DOCUMENT     | Poll for the document named in
                                  <t PR_POLL_RETRIEVE_TITLE>.
*/
#define SENDME_DEFAULT              0
#define SENDME_DOCUMENT             1

// PR_POLLTYPE is obsolete
#define POLLTYPE_REQUEST            1
#define POLLTYPE_STORE              2

// Line ID (depends on the value in PR_FAX_ACTIVE_MODEM_TYPE)
// PR_FAX_ACTIVE_MODEM
#define    NO_MODEM                    0xffffffff  // To show no modem is selected

// PR_FAX_TAPI_LOC_ID
#define    NO_LOCATION                 0xffffffff  // No TAPI location
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\status.c ===
/***********************************************************************
 *
 *  STATUS.C
 *
 *
 *  The Microsoft At Work Fax Address Book Provider.
 *  This file contains the methods that implement the status object.
 *
 *  The following routines are implemented in this file:
 *
 *      HrNewStatusObject()
 *      ABS_QueryInterface()
 *      ABS_Release()
 *      ABS_ValidateState()
 *      ABS_SettingsDialog()
 *      ABS_ChangePassword()
 *      ABS_FlushQueues()
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

#include "faxab.h"


/*
 *  AB Status vtbl filled in here
 */

static const ABS_Vtbl vtblABS =
{

    ABS_QueryInterface,
    (ABS_AddRef_METHOD *)           ROOT_AddRef,
    ABS_Release,
    (ABS_GetLastError_METHOD *)     ROOT_GetLastError,
    (ABS_SaveChanges_METHOD *)      WRAP_SaveChanges,
    (ABS_GetProps_METHOD *)         WRAP_GetProps,
    (ABS_GetPropList_METHOD *)      WRAP_GetPropList,
    (ABS_OpenProperty_METHOD *)     WRAP_OpenProperty,
    (ABS_SetProps_METHOD *)         WRAP_SetProps,
    (ABS_DeleteProps_METHOD *)      WRAP_DeleteProps,
    (ABS_CopyTo_METHOD *)           WRAP_CopyTo,
    (ABS_CopyProps_METHOD *)        WRAP_CopyProps,
    (ABS_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs,
    (ABS_GetIDsFromNames_METHOD *)  WRAP_GetIDsFromNames,
    ABS_ValidateState,
    ABS_SettingsDialog,
    ABS_ChangePassword,
    ABS_FlushQueues
};

/*************************************************************************
 *
 -  HrNewStatusObject
 -
 *  Creates the Status object associated with a particular FAB logon object
 *
 *
 */
HRESULT
HrNewStatusObject( LPMAPISTATUS *      lppABS,
                   ULONG *             lpulObjType,
                   ULONG               ulFlags,
                   LPABLOGON           lpABLogon,
                   LPCIID              lpIID,
                   HINSTANCE           hLibrary,
                   LPALLOCATEBUFFER    lpAllocBuff,
                   LPALLOCATEMORE      lpAllocMore,
                   LPFREEBUFFER        lpFreeBuff,
                   LPMALLOC            lpMalloc
                  )
{
    LPABSTATUS lpABS = NULL;
    SCODE sc;
    HRESULT hr = hrSuccess;
    LPPROPDATA lpPropData = NULL;
    SPropValue spv[6];
    LPTSTR lpszFileName;
#ifdef UNICODE
    CHAR szAnsiFileName[ MAX_PATH ];
#endif


    /*
     *
     */
    if ( lpIID &&
         (memcmp(lpIID, &IID_IMAPIStatus, SIZEOF(IID)) &&
          memcmp(lpIID, &IID_IMAPIProp, SIZEOF(IID)) &&
          memcmp(lpIID, &IID_IUnknown, SIZEOF(IID))
         )
        )
    {
        DebugTraceSc(HrNewStatusObject, E_NOINTERFACE);
        return ResultFromScode(E_NOINTERFACE);
    }

    /*
     *  Allocate space for the ABSTATUS structure
     */
    sc = lpAllocBuff( SIZEOF(ABSTATUS), (LPVOID *) &lpABS );

    if (FAILED(sc))
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    lpABS->lpVtbl = &vtblABS;
    lpABS->lcInit = 1;
    lpABS->hResult = hrSuccess;
    lpABS->idsLastError = 0;

    lpABS->hLibrary = hLibrary;
    lpABS->lpAllocBuff = lpAllocBuff;
    lpABS->lpAllocMore = lpAllocMore;
    lpABS->lpFreeBuff = lpFreeBuff;
    lpABS->lpMalloc = lpMalloc;

    lpABS->lpABLogon = lpABLogon;

    /*
     *  Create lpPropData
     */

    sc = CreateIProp( (LPIID) &IID_IMAPIPropData,
                      lpAllocBuff,
                      lpAllocMore,
                      lpFreeBuff,
                      lpMalloc,
                      &lpPropData
                     );

    if (FAILED(sc))
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    /*
     *  Set up initial set of properties associated with this
     *  status object.
     */

    /*
     *  Register my status row...
     */
    hr = HrLpszGetCurrentFileName(lpABLogon, &lpszFileName);
    if (HR_FAILED(hr))
    {
        goto err;
    }

    spv[0].ulPropTag  = PR_DISPLAY_NAME_A;
#ifdef UNICODE
    szAnsiFileName[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, lpszFileName, -1, szAnsiFileName, ARRAYSIZE(szAnsiFileName), NULL, NULL );
    spv[0].Value.lpszA = szAnsiFileName;
#else
    spv[0].Value.LPSZ = lpszFileName;
#endif

    spv[1].ulPropTag = PR_RESOURCE_METHODS;
    spv[1].Value.l = 0;

    spv[2].ulPropTag = PR_RESOURCE_FLAGS;
    spv[2].Value.l = 0;

    spv[3].ulPropTag = PR_STATUS_CODE;
    spv[3].Value.l = STATUS_AVAILABLE;

    spv[4].ulPropTag = PR_STATUS_STRING_A;
    spv[4].Value.lpszA = "Available";

    spv[5].ulPropTag = PR_PROVIDER_DISPLAY_A;
    spv[5].Value.lpszA = "Microsoft Fax Address Book Provider";

    /*
     *   Set the default properties
     */
    hr = lpPropData->lpVtbl->SetProps( lpPropData,
                                       ARRAYSIZE(spv),
                                       spv,
                                       NULL
                                      );

    /*
     *  Done with the current file name
     */
    lpFreeBuff(lpszFileName);

    if (HR_FAILED(hr))
    {
        goto err;
    }

    (void) lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpABS->lpPropData = (LPMAPIPROP) lpPropData;

    InitializeCriticalSection(&lpABS->cs);

    *lpulObjType = MAPI_STATUS;
    *lppABS = (LPMAPISTATUS) lpABS;

out:

    DebugTraceResult(HrNewStatusObject, hr);
    return hr;

err:
    if (lpPropData)
        lpPropData->lpVtbl->Release(lpPropData);

    lpFreeBuff( lpABS );

    goto out;

}

/*************************************************************************
 *
 *
 -  ABS_QueryInterface
 -
 *  This method would allow this object to return a different interface than
 *  the current one.  This object need only support IMAPIStatus and any interface
 *  it derives from.
 *
 */
STDMETHODIMP
ABS_QueryInterface( LPABSTATUS lpABS,
                    REFIID lpiid,
                    LPVOID FAR * lppNewObj
                   )
{

    HRESULT hr = hrSuccess;
    /*
     *  Check to see if lpABS is what we expect
     */
    if ( IsBadReadPtr(lpABS, SIZEOF(ABSTATUS)) ||
         lpABS->lpVtbl != &vtblABS
        )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Validate other parameters */

    if ( IsBadReadPtr(lpiid, (UINT) SIZEOF(IID)) ||
         IsBadWritePtr(lppNewObj, SIZEOF(LPVOID))
       )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  See if the requested interface is one of ours */

    if ( memcmp(lpiid, &IID_IUnknown, SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMAPIProp, SIZEOF(IID)) &&
         memcmp(lpiid, &IID_IMAPIStatus, SIZEOF(IID))
        )
    {
        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */
        hr = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

    /*  We'll do this one. Bump the usage count and return a new pointer. */

    EnterCriticalSection(&lpABS->cs);

    ++lpABS->lcInit;

    LeaveCriticalSection(&lpABS->cs);

    *lppNewObj = lpABS;

out:

    DebugTraceResult(ABS_QueryInterface, hr);
    return hr;
}

/**************************************************
 *
 -  ABS_Release
 -
 *      Decrement lpInit.
 *      When lcInit == 0, free up the lpABS structure
 *
 */
STDMETHODIMP_(ULONG) ABS_Release(LPABSTATUS lpABS)
{
    LONG lcInit;

    /*
     *  Check to see if lpABS is what we expect
     */
    if (IsBadReadPtr(lpABS, SIZEOF(ABSTATUS)))
    {
        /*
         *  No jump table found
         */
        return 1;
    }

    /*
     *  Check to see that it's the correct jump table
     */
    if (lpABS->lpVtbl != &vtblABS)
    {
        /*
         *  Not my jump table
         */
        return 1;
    }

    EnterCriticalSection(&lpABS->cs);

    lcInit = --lpABS->lcInit;

    LeaveCriticalSection(&lpABS->cs);

    if (lcInit == 0)
    {

        /*
         *  Get rid of the lpPropData
         */

        lpABS->lpPropData->lpVtbl->Release(lpABS->lpPropData);

        /*
         *  Delete the critical section
         */

        DeleteCriticalSection(&lpABS->cs);

        /*
         *  Set the Jump table to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */

        lpABS->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpABS->lpFreeBuff( lpABS );
        return 0;
    }

    return lcInit;

}


/**********************************************************************
 *
 -  ABS_ValidateState
 -
 *  Since I did not set any flags for the property PR_RESOURCE_METHODS
 *  I don't have to support this method.
 *
 */

STDMETHODIMP
ABS_ValidateState( LPABSTATUS lpABS,
                   ULONG ulUIParam,
                   ULONG ulFlags
                  )
{
    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);
    /*
     *  Check to see if lpABS is what we expect
     */
    if ( IsBadReadPtr(lpABS, SIZEOF(ABSTATUS)) ||
         lpABS->lpVtbl != &vtblABS
        )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Validate other parameters */
    if (ulFlags & ~(SUPPRESS_UI
                    | REFRESH_XP_HEADER_CACHE
                    | PROCESS_XP_HEADER_CACHE
                    | FORCE_XP_CONNECT
                    | FORCE_XP_DISCONNECT
                    | CONFIG_CHANGED))
    {
        hr = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

out:
    DebugTraceResult(ABS_ValidateState, hr);
    return hr;
}


/**********************************************************************
 *
 -  ABS_SettingsDialog
 -
 *  Since I did not set any flags for the property PR_RESOURCE_METHODS
 *  I don't have to support this method.
 *
 */
STDMETHODIMP
ABS_SettingsDialog( LPABSTATUS lpABS,
                    ULONG ulUIParam,
                    ULONG ulFlags
                   )
{
    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);
    /*
     *  Check to see if lpABS is what we expect
     */
    if ( IsBadReadPtr(lpABS, SIZEOF(ABSTATUS)) ||
         lpABS->lpVtbl != &vtblABS
        )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Validate other parameters */
    if (ulFlags & ~(UI_READONLY))
    {
        hr = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

out:
    DebugTraceResult(ABS_SettingsDialog, hr);
    return hr;
}


/**********************************************************************
 *
 -  ABS_ChangePassword
 -
 *  Since I did not set any flags for the property PR_RESOURCE_METHODS
 *  I don't have to support this method.
 *
 *  Note:   in the parameter validation below I chose only check the first 15
 *          characters of the passwords.  This was arbitrary.
 */
STDMETHODIMP
ABS_ChangePassword( LPABSTATUS lpABS,
                    LPTSTR lpOldPass,
                    LPTSTR lpNewPass,
                    ULONG ulFlags
                   )
{
    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);
    /*
     *  Check to see if lpABS is what we expect
     */
    if ( IsBadReadPtr(lpABS, SIZEOF(ABSTATUS)) ||
         lpABS->lpVtbl != &vtblABS
        )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Validate other parameters */

    if (ulFlags & ~(MAPI_UNICODE))
    {
        hr = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

    if ( ulFlags & MAPI_UNICODE )
    {
        // UNICODE is currently not supported by the sample AB

        hr = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        goto out;
    }

    if (ulFlags)
    {
        /*
         *  We're checking UNICODE strings
         */
        if (IsBadStringPtrW((LPWSTR) lpOldPass, (UINT) 15) ||
            IsBadStringPtrW((LPWSTR) lpNewPass, (UINT) 15))
        {

            hr = ResultFromScode(E_INVALIDARG);
            goto out;
        }
    }
    else
    {
        /*
         *  We're not checking UNICODE strings
         */
        if (IsBadStringPtrA((LPSTR) lpOldPass, (UINT) 15) ||
            IsBadStringPtrA((LPSTR) lpNewPass, (UINT) 15))
        {

            hr = ResultFromScode(E_INVALIDARG);
            goto out;
        }
    }

out:
    DebugTraceResult(ABS_ChangePassword, hr);
    return hr;
}


/**********************************************************************
 *
 -  ABS_FlushQueues
 -
 *  Since I did not set any flags for the property PR_RESOURCE_METHODS
 *  I don't have to support this method.
 *
 */
STDMETHODIMP
ABS_FlushQueues( LPABSTATUS lpABS,
                 ULONG ulUIParam,
                 ULONG cbTargetTransport,
                 LPENTRYID lpTargetTransport,
                 ULONG ulFlags
                )
{
    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT);
    /*
     *  Check to see if lpABS is what we expect
     */
    if (IsBadReadPtr(lpABS, SIZEOF(ABSTATUS)) || lpABS->lpVtbl != &vtblABS )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    /*  Validate other parameters */

    if ( cbTargetTransport &&
         ((cbTargetTransport < (ULONG) SIZEOF (ENTRYID)) ||
           IsBadReadPtr(lpTargetTransport, (UINT) cbTargetTransport)
          )
        )
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (ulFlags & ~(FLUSH_NO_UI
                    | FLUSH_UPLOAD
                    | FLUSH_DOWNLOAD
                    | FLUSH_FORCE))
    {
        hr = ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
        goto out;
    }

out:
    DebugTraceResult(ABS_FlushQueues, hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\status.h ===
#ifdef __cplusplus
extern "C" {
#endif
	
/*
 *  Declaration of IMAPIStatus object implementation
 */
#undef  INTERFACE
#define INTERFACE   struct _ABSTATUS

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABS_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        MAPI_IMAPIPROP_METHODS(IMPL)
        MAPI_IMAPISTATUS_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABS_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        MAPI_IMAPIPROP_METHODS(IMPL)
        MAPI_IMAPISTATUS_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ABS_)
{
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPISTATUS_METHODS(IMPL)
};


/*
 *  The actual definition of the structure behind the 'this' pointer for this object
 */
typedef struct _ABSTATUS
{
    const ABS_Vtbl FAR * lpVtbl;

    FAB_Wrapped;
    
} ABSTATUS, *LPABSTATUS;



#define CBABSTATUS	sizeof(ABSTATUS)

/*
 *  Creates a new status object for this provider (see STATUS.C)
 */
HRESULT 
HrNewStatusObject(LPMAPISTATUS *    lppABS,
                ULONG *             lpulObjType,
                ULONG               ulFlags,
                LPABLOGON           lpABPLogon,
                LPCIID              lpInterface,
                HINSTANCE           hLibrary,
                LPALLOCATEBUFFER    lpAllocBuff,
                LPALLOCATEMORE      lpAllocMore,
                LPFREEBUFFER        lpFreeBuff,
                LPMALLOC            lpMalloc );

#ifdef	__cplusplus
}		/* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\tblwrap.h ===
/***********************************************************************
 *
 *  TBLWRAP.H
 *
 *  the table wrapper (tblwrap.c) header
 */

#undef	INTERFACE
#define INTERFACE	struct _IVTWRAP

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IVTWRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IVTWRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IVTWRAP_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPITABLE_METHODS(IMPL)
};

typedef struct _IVTWRAP {

    const IVTWRAP_Vtbl * lpVtbl;

	FAB_IUnknown;

	LPMAPITABLE lpWrappedTable;
	    
} IVTWRAP, *LPIVTWRAP;

#define CBIVTWRAP sizeof(IVTWRAP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\tid.c ===
/***********************************************************************
 *
 *  TID.C
 *
 *      Microsoft At Work Fax Address Book Template ID  object
 *      This file contains the code for implementing the Microsoft At Work Fax AB
 *      TID object.
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *                              MAPI                            Original source from MAPI(154) sample AB Provider
 *      3.7.94          Yoram Yaacovi           Modifications to make it an At Work Fax ABP
 *      8.7.94          Yoram Yaacovi           Update for MAPI 304
 *
 ***********************************************************************/

#define _FAXAB_TID
#include "faxab.h"

/*
 *  TID jump table is defined here...
 */

static const TID_Vtbl vtblTID =
{
    (TID_QueryInterface_METHOD *)   WRAP_QueryInterface,
    (TID_AddRef_METHOD *)           WRAP_AddRef,
    TID_Release,
    (TID_GetLastError_METHOD *)     WRAP_GetLastError,
    (TID_SaveChanges_METHOD *)      WRAP_SaveChanges,
    (TID_GetProps_METHOD *)         WRAP_GetProps,
    (TID_GetPropList_METHOD *)      WRAP_GetPropList,
    TID_OpenProperty,
    (TID_SetProps_METHOD *)         WRAP_SetProps,
    (TID_DeleteProps_METHOD *)      WRAP_DeleteProps,
    (TID_CopyTo_METHOD *)           WRAP_CopyTo,
    (TID_CopyProps_METHOD *)        WRAP_CopyProps,
    (TID_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs,
    (TID_GetIDsFromNames_METHOD *)  WRAP_GetIDsFromNames,
};

/*************************************************************************
 *
 -  HrNewTID
 -
 *  Creates the TID object associated with a mail user.
 *
 *
 */
HRESULT
HrNewTID( LPMAPIPROP *       lppMAPIPropNew,
          ULONG              cbTemplateId,
          LPENTRYID          lpTemplateId,
          ULONG              ulTemplateFlags,
          LPMAPIPROP         lpPropData,
          LPABLOGON          lpABPLogon,
          LPCIID             lpInterface,
          HINSTANCE          hLibrary,
          LPALLOCATEBUFFER   lpAllocBuff,
          LPALLOCATEMORE     lpAllocMore,
          LPFREEBUFFER       lpFreeBuff,
          LPMALLOC           lpMalloc
         )
{
    LPTID           lpTID;
    SCODE           sc;
    HRESULT         hr = hrSuccess;
    LPMAILUSER      lpABUser;
    ULONG ulObjType;

    /*
     *      Create the user object corresponding to the template id
     */
    hr = HrNewFaxUser( &lpABUser,
                       &ulObjType,
                       cbTemplateId,
                       lpTemplateId,
                       lpABPLogon,
                       lpInterface,
                       hLibrary,
                       lpAllocBuff,
                       lpAllocMore,
                       lpFreeBuff,
                       lpMalloc
                      );

    if (HR_FAILED(hr))
    {
            goto err;
    }

    /*
     *      Allocate space for the TID structure
     */
    sc = lpAllocBuff(SIZEOF(TID), (LPVOID *) & lpTID);

    if (FAILED(sc))
    {
        DebugTrace("NewTID() - AllocBuffer failed %s\n",SzDecodeScode(sc));
        hr = ResultFromScode (sc);
        goto err;
    }

    /*
     *  Initailize the TID structure
     */

    lpTID->lpVtbl       = &vtblTID;
    lpTID->lcInit       = 1;
    lpTID->hResult      = hrSuccess;
    lpTID->idsLastError = 0;
    lpTID->hLibrary     = hLibrary;
    lpTID->lpAllocBuff  = lpAllocBuff;
    lpTID->lpAllocMore  = lpAllocMore;
    lpTID->lpFreeBuff   = lpFreeBuff;
    lpTID->lpMalloc     = lpMalloc;
    lpTID->lpABLogon    = lpABPLogon;
    lpTID->lpPropData   = lpPropData;
    lpTID->lpABUser     = lpABUser;

    /*
     *      First time creation - must set the address type and template id.
     */
    if (ulTemplateFlags & FILL_ENTRY)
    {
        ULONG ulCount;
        LPSPropValue lpspv = NULL;
        /*
         *  Copy all the properties from my object to the propdata
         */
        hr = lpABUser->lpVtbl->GetProps( lpABUser,
                                         NULL,
                                         0,      /* ansi */
                                         &ulCount,
                                         &lpspv
                                        );

        if (FAILED(hr))
                goto err;

        hr = lpPropData->lpVtbl->SetProps( lpPropData,
                                           ulCount,
                                           lpspv,
                                           NULL
                                          );

        lpFreeBuff(lpspv);

        if (FAILED(hr))
                goto err;
    }

    /*
     *      AddRef lpPropData so we can use it after we return
     */

    (void)lpPropData->lpVtbl->AddRef(lpPropData);

    InitializeCriticalSection(&lpTID->cs);

    *lppMAPIPropNew = (LPVOID) lpTID;


out:
    DebugTraceResult(NewTID, hr);
    return hr;
err:


    if (lpABUser)
        lpABUser->lpVtbl->Release(lpABUser);

    lpFreeBuff(lpTID);

        goto out;
}

/*********************************************************************
 *********************************************************************
 *
 *  The TID IMAPIProp methods
 *
 */

STDMETHODIMP_(ULONG) TID_Release(LPTID lpTID)
{
    LONG lcInit;

    /*
     * Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpTID, SIZEOF(TID)))
    {
        /*
         *  I'm not looking at an object that I expect to be.
         */
        return 1;
    }

    /*
     *  Check to see that it's TIDs vtbl
     */
    if (lpTID->lpVtbl != &vtblTID)
    {
        /*
         *  It's big enough but it's got the wrong vtbl.
         */
        return 1;
    }

    /*
     *  Release the mapi property object
     */
    lpTID->lpPropData->lpVtbl->Release( lpTID->lpPropData );

    EnterCriticalSection(&lpTID->cs);
    lcInit = --lpTID->lcInit;
    LeaveCriticalSection(&lpTID->cs);

    if (lcInit == 0)
    {
        /*
         *  Release the ABUser object
         */
        lpTID->lpABUser->lpVtbl->Release( lpTID->lpABUser );

        /*
         *  Clean up the critical section
         */
        DeleteCriticalSection(&lpTID->cs);

        /*
         * Need to free the object
         */
        lpTID->lpFreeBuff(lpTID);
        return 0;
    }

    return lcInit;
}



/*
 -  TID_OpenProperty
 -
 *  Satisfies the object that are needed to support the "Options" details pane
 *  associated with the MailUser object from ABUSER.C.
 *
 *  Note:  We are masking error strings that might be possible to get from the
 *  lpABUser object.  Since (for the most part) the only errors that can be returned
 *  from this object are resource failure types, it wouldn't be of much use to the
 *  user.
 */

STDMETHODIMP
TID_OpenProperty( LPTID       lpTID,
                  ULONG       ulPropTag,
                  LPCIID      lpiid,
                  ULONG       ulInterfaceOptions,
                  ULONG       ulFlags,
                  LPUNKNOWN * lppUnk
                 )
{

    HRESULT hResult;

    /*
     *  Check to see if it's large enough to hold this object
     */
    if (IsBadReadPtr(lpTID, SIZEOF(TID)))
    {
        /*
         *  No vtbl found
         */
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Check to see that it's TIDs vtbl
     */
    if (lpTID->lpVtbl != &vtblTID)
    {
        /*
         *  It's big enough but it's got the wrong vtbl.
         */
        return ResultFromScode(E_INVALIDARG);
    }

    if ( ulInterfaceOptions & ~MAPI_UNICODE )
    {
        DebugTraceArg( TID_OpenProperty, "unknown flags" );
        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS );
    }

    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
        DebugTraceArg( TID_OpenProperty, "bad character width" );
        return ResultFromScode( MAPI_E_BAD_CHARWIDTH );
    }

    /*
     *  Don't want to check any other parameters here.
     *  Calls down to wrapped objects will do this for
     *  me.
     */

    switch (ulPropTag)
    {
        // For now, I just call the underlying (my) user object method to handle, which
        // means the template ID does not do anything.

        case PR_DETAILS_TABLE:
        case PR_DDLBX_COUNTRIES_TABLE:
        case PR_DIAL_HELPER_BUTTON:
        {
            hResult =  lpTID->lpABUser->lpVtbl->OpenProperty(
                                    lpTID->lpABUser,
                                    ulPropTag,
                                    lpiid,
                                    ulInterfaceOptions,
                                    ulFlags,
                                    lppUnk);
            break;

        }

        default:
        {
            hResult =  lpTID->lpPropData->lpVtbl->OpenProperty(
                                    lpTID->lpPropData,
                                    ulPropTag,
                                    lpiid,
                                    ulInterfaceOptions,
                                    ulFlags,
                                    lppUnk);
            break;
        }
    }

    DebugTraceResult(TID_OpenProperty, hResult);
        return hResult;

}
#undef  _FAXAB_TID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\tid.h ===
/***********************************************************************
 *
 *  _TID.H
 *
 *  Header file for code in TID.C
 *
 *  Copyright 1992, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

//
//  Function prototypes
//

#undef	INTERFACE
#define INTERFACE	struct _TID

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, TID_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, TID_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(TID_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _TID {

	const TID_Vtbl * lpVtbl;

    FAB_Wrapped;
    
    /*
     *  Private data
     */
    LPMAILUSER  lpABUser;


} TID, *LPTID;

#define CBTID sizeof(TID)

/*
 * Creates a new templateID object that's associated with
 * a FAB mailuser object.
 */
HRESULT
HrNewTID (  LPMAPIPROP *        lppMAPIPropNew,
            ULONG               cbTemplateId,
            LPENTRYID           lpTemplateId,
            ULONG               ulTemplateFlags,
            LPMAPIPROP          lpMAPIPropData,
            LPABLOGON           lpABPLogon,
            LPCIID              lpInterface,
            HINSTANCE           hLibrary,
            LPALLOCATEBUFFER    lpAllocBuff,
            LPALLOCATEMORE      lpAllocMore,
            LPFREEBUFFER        lpFreeBuff,
            LPMALLOC            lpMalloc );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\util.c ===
/*
 -  util.c
 -
 *      Microsoft At Work Fax Messaging Address Book
 *
 *              Revision History:
 *
 *              When            Who                                     What
 *              --------        ------------------  ---------------------------------------
 *              7.24.96         Rick Turner             ported from old code in fax tree
 *
 */
/* ***************************************************************************/

/* inculde files */

#include "faxab.h"

/*******************************
 ****   Utility Functions   ****
 *******************************/

// ***************************************************************************
// GetCurrentLocationAreaCode                                                *
// Get the area code for the current location                                *
// returns: the area code of the current location or "" if error             *
//

TCHAR g_szAreaCode[ AREA_CODE_SIZE ];
DWORD g_dwTlsIndex;                  // index for private thread storage



LPTSTR GetCurrentLocationAreaCode()
{
    LPLINETRANSLATECAPS lpLineTransCaps;
    DWORD lResult, dwNumLocs;
    LPLINELOCATIONENTRY lplle, lplleCur;

    g_szAreaCode[0] = 0;

    /* allocate buffer */
    lpLineTransCaps = (LPLINETRANSLATECAPS)LocalAlloc(LPTR, 1024 );
    if (!lpLineTransCaps)
    {
        goto err;
    }

    lpLineTransCaps->dwTotalSize = 1024;

    /* try to get TranslateCaps */
    lResult = lineGetTranslateCaps( NULL, TAPI_CURRENT_VERSION, lpLineTransCaps);
    if (lResult != NO_ERROR)
    {
        goto err;
    }

    /* reallocate buffer if not big enough */
    while (lpLineTransCaps->dwNeededSize > lpLineTransCaps->dwTotalSize)
    {
        DWORD lcbNeeded = lpLineTransCaps->dwNeededSize;

        LocalFree(lpLineTransCaps);
        lpLineTransCaps = (LPLINETRANSLATECAPS)LocalAlloc(LPTR, lcbNeeded);
        if (!lpLineTransCaps)
        {
            goto err;
        }

        lpLineTransCaps->dwTotalSize = lcbNeeded;

        /* try one more time */
        lResult = lineGetTranslateCaps( NULL, TAPI_CURRENT_VERSION, lpLineTransCaps);
        if (lResult != NO_ERROR)
        {
            goto err;
        }
    } /* while */


    dwNumLocs = lpLineTransCaps->dwNumLocations;

    // get the name and area code of the current location
    lplle = (LPLINELOCATIONENTRY)((LPBYTE)(lpLineTransCaps) + lpLineTransCaps->dwLocationListOffset);
    lplleCur = lplle;
    while (dwNumLocs-- && lplleCur->dwPermanentLocationID != lpLineTransCaps->dwCurrentLocationID)
        ++lplleCur;

    // Save the current location information
    lstrcpyn( g_szAreaCode,
              (LPTSTR)((LPBYTE)(lpLineTransCaps) + lplleCur->dwCityCodeOffset),
              min(ARRAYSIZE(g_szAreaCode),lplleCur->dwCityCodeSize)
             );

    LocalFree( lpLineTransCaps );
    return g_szAreaCode;


err:
    if (lpLineTransCaps != NULL)
        LocalFree(lpLineTransCaps);

    return NULL;

} /* GetCurrentLocationAreaCode */


// ***************************************************************************
// GetCurrentLocationCountryID                                               *
// Get the area code for the current location                                *
// returns: the country ID for the current location or 0 if error
//

DWORD GetCurrentLocationCountryID()
{
    LPLINETRANSLATECAPS lpLineTransCaps;
    DWORD lResult, dwNumLocs, dwCountryID;
    LPLINELOCATIONENTRY lplle, lplleCur;

    /* allocate buffer */
    lpLineTransCaps = (LPLINETRANSLATECAPS)LocalAlloc(LPTR, 1024 );
    if (!lpLineTransCaps)
    {
        goto err;
    }

    lpLineTransCaps->dwTotalSize = 1024;

    /* try to get TranslateCaps */
    lResult = lineGetTranslateCaps( NULL, TAPI_CURRENT_VERSION, lpLineTransCaps);
    if (lResult != NO_ERROR)
    {
        goto err;
    }

    /* reallocate buffer if not big enough */
    while (lpLineTransCaps->dwNeededSize > lpLineTransCaps->dwTotalSize)
    {
        DWORD lcbNeeded = lpLineTransCaps->dwNeededSize;

        LocalFree(lpLineTransCaps);
        lpLineTransCaps = (LPLINETRANSLATECAPS)LocalAlloc(LPTR, lcbNeeded);
        if (!lpLineTransCaps)
        {
            goto err;
        }

        lpLineTransCaps->dwTotalSize = lcbNeeded;

        /* try one more time */
        lResult = lineGetTranslateCaps( NULL, TAPI_CURRENT_VERSION, lpLineTransCaps);
        if (lResult != NO_ERROR)
        {
            goto err;
        }
    } /* while */


    dwNumLocs = lpLineTransCaps->dwNumLocations;

    // get the name and area code of the current location
    lplle = (LPLINELOCATIONENTRY)((LPBYTE)(lpLineTransCaps) + lpLineTransCaps->dwLocationListOffset);
    lplleCur = lplle;
    while (dwNumLocs-- && lplleCur->dwPermanentLocationID != lpLineTransCaps->dwCurrentLocationID)
        ++lplleCur;


    dwCountryID = lplleCur->dwCountryID;

    LocalFree( lpLineTransCaps );
    return dwCountryID;


err:
    if (lpLineTransCaps != NULL)
        LocalFree(lpLineTransCaps);

    return 0;

} /* GetCurrentLocationCountryID */


/* ***************************************************************************
 * GetCountry
 *
 * - gets the a country or a country list from TAPI
 *
 * Parameters:  dwReqCountryID - a TAPI country ID. 0 for all countries
 *
 * Returns: TRUE on success, FALSE on failure.
 */

#define SIZE_OF_ONE_COUNTRY_BUFFER      150     // current number is 110
#define SIZE_OF_ALL_COUNTRIES_BUFFER    17000   // current number is 15694

BOOL GetCountry(DWORD dwReqCountryID, LPLINECOUNTRYLIST *lppLineCountryList)
{
    ULONG   ulMemNeeded;
    WORD    i;
    LONG    lError = NO_ERROR;
    LPLINECOUNTRYLIST       lpLineCountryList = NULL;
    BOOL    bResult = TRUE;

    // See what size of a buffer I need to allocate
    ulMemNeeded = (dwReqCountryID ? SIZE_OF_ONE_COUNTRY_BUFFER : SIZE_OF_ALL_COUNTRIES_BUFFER);

    // Try to allocate buffer and call lineGetCountry twice
    // If this does not work, allocate a buffer of the size
    // requested by TAPI and try again
    for (i=0; i < 2; i++)
    {
        // Allocate memory for the LINECOUNTRYLIST structure
        lpLineCountryList = (LPLINECOUNTRYLIST)LocalAlloc( LPTR, ulMemNeeded );
        if (!lpLineCountryList)
        {
            DEBUG_TRACE("GetCountry: could not alloc buffer(%d) for LPLINECOUNTRYLIST\n", i);
            goto err;
        }

        // Set the size of the provided buffer for TAPI
        lpLineCountryList->dwTotalSize = ulMemNeeded;

        // Get the country inofmration for the requested country
        lError = lineGetCountry(dwReqCountryID, TAPI_CURRENT_VERSION, lpLineCountryList);

        // I give up if error and it's not because the structure passed in was too small
        if ( (lError != NO_ERROR) &&
             (lError != LINEERR_STRUCTURETOOSMALL) &&
             // Remove next line after TAPI fixes bug
             (lError != LINEERR_NOMEM)
            )
        {
            DEBUG_TRACE("GetCountry: lineGetCountry returned error %lx\n", lError);
            goto err;
        }

        // If I didn't get it all, free the buffer and try again with bigger size buffer
        if (lpLineCountryList->dwNeededSize > lpLineCountryList->dwTotalSize)
        {
            // +1 is due to TAPI bug. Exactly won't work
            ulMemNeeded = lpLineCountryList->dwNeededSize+1;
            LocalFree(lpLineCountryList);
        }
        else    // got it
            break;
    }

    // should have valid lpLineCountryList here
    if (lError != NO_ERROR)
        goto err;

    DEBUG_TRACE("GetCountry: %lx of the buffer used\n", lpLineCountryList->dwUsedSize);

out:
    *lppLineCountryList = lpLineCountryList;
    return bResult;

err:
    // Free the buffer
    if (lpLineCountryList)
        LocalFree( lpLineCountryList );
    lpLineCountryList = NULL;
    bResult = FALSE;
    goto out;

} /* GetCountry */



/* ***************************************************************************
 * GetCountryCode
 *
 * - gets a country code when given a country ID
 *
 * Parameters:  dwReqCountryID  - a TAPI country ID
 *              lpdwCountryCode - an address of a DWORD in which to store the country code
 *
 * Returns: TRUE on success, FALSE on failure.
 */

BOOL GetCountryCode(DWORD dwReqCountryID, DWORD *lpdwCountryCode)
{
    ULONG   country;
    LPLINECOUNTRYLIST  lpLineCountryList = NULL;
    LPLINECOUNTRYENTRY lprgLineCountryEntry = NULL;
    BOOL    bResult = FALSE;

    // Get the country info structure from TAPI
    if (!GetCountry(dwReqCountryID, &lpLineCountryList))
        goto out;

    // Point to the first country in the structure
    lprgLineCountryEntry =
        (LPLINECOUNTRYENTRY)((LPBYTE)(lpLineCountryList)
        + lpLineCountryList->dwCountryListOffset);

    // Loop through LINECOUNTRYENTRY structures and look for the country ID.
    for (country=0; country < lpLineCountryList->dwNumCountries; country++)
        if ( (lprgLineCountryEntry[country].dwCountryNameSize != 0) &&
             (lprgLineCountryEntry[country].dwCountryNameOffset != 0)
            )
        {
            DWORD dwCountryCode = lprgLineCountryEntry[country].dwCountryCode;
            DWORD dwCountryID = lprgLineCountryEntry[country].dwCountryID;

            // If this is the requested country, get its country code
            if (dwCountryID == dwReqCountryID)
            {
                *lpdwCountryCode = dwCountryCode;
                bResult = TRUE;
                break;
            }

        }

out:
    // Free the buffer
    if (lpLineCountryList)
        LocalFree( lpLineCountryList );

    if (!bResult)
        *lpdwCountryCode = 1;           // U.S.

    return bResult;

} /* GetCountryCode */




/****************************************************************************
    FUNCTION:   MakeMessageBox

    PURPOSE:    Gets resource string and displays an error message box.

    PARAMETERS: hInst      - Instnace of the caller (for getting strings)
                hWnd       - Handle to parent window
                ulResult   - Result/Status code
                             0:              information message
                             100-499:        warning message
                             500 and up:     error message
                idString   - Resource ID of message in StringTable
                fStyle     - style of the message box

    RETURNS:    the return value from MessageBox() function

****************************************************************************/
int MakeMessageBox(HINSTANCE hInst, HWND hWnd, DWORD ulResult, UINT idString, UINT fStyle, ...)
{
    va_list va;
    TCHAR szMessage[512]=TEXT("");
    TCHAR szTempBuf[400];
    TCHAR szTitle[128];
    TCHAR szAppName[MAX_PATH];

    // Get the application name from the resource file
    LoadString (hInst, IDS_APP_NAME, szAppName, MAX_PATH);

    // Do the title: 0: information message, 100-499: warning, 500 and up: critical (real error)
    // Also, if an error msg, load the standard MAWF error message
    if (ulResult == 0)
    {
        lstrcpy(szMessage, TEXT(""));
        LoadString (hInst, IDS_INFORMATION_MESSAGE, szTempBuf, 128);
    }

    else    // Error or warning

    {
        if ((ulResult >= 100) && (ulResult < 500))
        {
            // Warning
            lstrcpy(szMessage, TEXT(""));
            LoadString (hInst, IDS_WARNING_MESSAGE, szTempBuf, 128);
        }

        else    // Error
        {
            // If an error msg, load the standard MAWF error message
            LoadString (hInst, MAWF_E_GENERIC, szMessage, 64);
            LoadString (hInst, IDS_CRITICAL_MESSAGE, szTempBuf, 128);
        }
    }

    // Add a 'Microsoft At Work Fax' to the title
    lstrcpy(szTitle, szAppName);
    lstrcat(szTitle, TEXT(": "));
    lstrcat(szTitle, szTempBuf);

    // If there is a string ID, load the string from the resource file
    if (idString)
    {
        TCHAR szFormat[400];

        // Point to the first optional parameter. fStyle is the last required parameter
        va_start(va, fStyle);
        LoadString (hInst, idString, szFormat, 255);
        wvsprintf(szTempBuf, szFormat, va);
        va_end(va);
        lstrcat (szMessage, szTempBuf);
    }

    return(MessageBox (hWnd, szMessage, szTitle, fStyle));
}


/* ***************************************************************************
 * EncodeFaxAddress
 *
 * - encodes fax address components into the format name@+country-code (area-code) fax-number
 *
 * Parameters:  lpszFaxAddr     - address of a buffer in which to fill the encoded fax number
 *              lpParsedFaxAddr - an address of a PARSEDTELNUMBER structure which contains
 *                                the components of the address that need to be encoded
 *
 * Returns: TRUE on success, FALSE on failure.
 *
 * CHECK: will need localization
 */

BOOL EncodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr)
{

    // somewhat validate parameters
    if (!lpszFaxAddr)
        return FALSE;
    if (!lpParsedFaxAddr)
        return FALSE;

    // initialize the encoded string to an empty string
    lstrcpy(lpszFaxAddr, TEXT(""));

    // start with routing name and @, if any
    if ((lpParsedFaxAddr->szRoutingName) && (lstrlen(lpParsedFaxAddr->szRoutingName) != 0))
    {
        lstrcat(lpszFaxAddr, lpParsedFaxAddr->szRoutingName);
        lstrcat(lpszFaxAddr, TEXT("@"));
    }

    // must have a country code
    if (lpParsedFaxAddr->szCountryCode)
    {
        // if the country code is not 0, start an canonical address
        // a 0 country code is a special case, and address generated won't be canonincal
        if ( (lstrlen(lpParsedFaxAddr->szCountryCode) != 0) &&
             (lstrcmp(lpParsedFaxAddr->szCountryCode, TEXT("0")))
            )
        {
            lstrcat(lpszFaxAddr, TEXT("+"));
            lstrcat(lpszFaxAddr, lpParsedFaxAddr->szCountryCode);
            lstrcat(lpszFaxAddr, TEXT(" "));
        }
    }
    else
    {
        goto err;
    }

    // area code is optional
    if ((lpParsedFaxAddr->szAreaCode) && (lstrlen(lpParsedFaxAddr->szAreaCode) != 0))
    {
        lstrcat(lpszFaxAddr, TEXT("("));
        lstrcat(lpszFaxAddr, lpParsedFaxAddr->szAreaCode);
        lstrcat(lpszFaxAddr, TEXT(")"));
        lstrcat(lpszFaxAddr, TEXT(" "));
    }

    // must have a telephone number
    if ((lpParsedFaxAddr->szTelNumber) && (lstrlen(lpParsedFaxAddr->szTelNumber) != 0))
    {
        lstrcat(lpszFaxAddr, lpParsedFaxAddr->szTelNumber);
    }
    else
    {
        goto err;
    }
#ifdef UNICODE
    {
        CHAR szDebug[ MAX_PATH ];

        szDebug[0] = 0;
        WideCharToMultiByte( CP_ACP, 0, lpszFaxAddr, -1, szDebug, ARRAYSIZE(szDebug), NULL, NULL );
        DEBUG_TRACE("EncodeFaxAddress: Canonical number: %s\n", szDebug);
    }
#else
    DEBUG_TRACE("EncodeFaxAddress: Canonical number: %s\n", lpszFaxAddr);
#endif
    return TRUE;

err:
    lstrcpy(lpszFaxAddr, TEXT(""));
    return FALSE;

} /* EncodeFaxAddress */


/* ***************************************************************************
 * DecodeFaxAddress
 *
 * - parses a fax address of the format name@+country-code (area-code) fax-number
 *
 * Parameters:  lpszFaxAddr - a Fax address in the above format
 *                            lpParsedFaxAddr - an address of a PARSEDTELNUMBER structure in which to
 *                            fill the parsed information
 *
 * Returns: TRUE on success, FALSE on failure.
 *              success:        full address
 *                              no routing name
 *                              no area code
 *              failure:        no '+country-code '
 *                              no telephone number
 *
 * CHECK: will need localization
 */

enum tAddrComp {error, country_code, area_code, tel_number};

BOOL DecodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr)
{
    TCHAR szTempBuf[sizeof(PARSEDTELNUMBER)] = {TEXT("")};
    BOOL fRoutingNameAllowed = TRUE;
    BOOL fAreaCodeAllowed = TRUE;
    BOOL bResult = FALSE;
    LPTSTR lpszTempBuf = szTempBuf;
    enum tAddrComp nWhatStarted = tel_number;
    WORD i;

    // somewhat validate parameters
    if (!lpszFaxAddr)
        return FALSE;
    if (!lpParsedFaxAddr)
        return FALSE;

    // Initialize to empty string values
    lstrcpy(lpParsedFaxAddr->szCountryCode, TEXT(""));
    lstrcpy(lpParsedFaxAddr->szAreaCode, TEXT(""));
    lstrcpy(lpParsedFaxAddr->szTelNumber, TEXT(""));
    lstrcpy(lpParsedFaxAddr->szRoutingName, TEXT(""));

    // if the string empty, nothing to do
    // (else, even if I don't find any "special" charachters in the string,
    //  I'll stash whatever is in there into the telephone number)
    if (!lstrlen(lpszFaxAddr))
        return TRUE;

    // Scan once through the address. disallow fields as you progress
    for (i=0; lpszFaxAddr[i] != 0; i++)
    {
        switch (lpszFaxAddr[i])
        {
        case TEXT('@'):       // maybe the end of a mailbox name string, or just a @ in the name
            if (fRoutingNameAllowed)
            {
                LPTSTR lpszTemp;

                // is this the last @ in the number string ?
#ifdef UNICODE
                lpszTemp = wcschr(lpszFaxAddr, TEXT('@'));
#else
                lpszTemp = _mbsrchr(lpszFaxAddr, TEXT('@'));
#endif
                if (lpszTemp == &(lpszFaxAddr[i]))
                {
                    // end of mailbox name. beginning of "real" canonical number
                    lstrcpy(lpParsedFaxAddr->szRoutingName, szTempBuf);
                    lpszTempBuf = szTempBuf;
                }
                else
                {
                    // not the end of the mailbox name yet. just continue.
                    *(lpszTempBuf++) = lpszFaxAddr[i];
                    *(lpszTempBuf) = 0;
                }
            }

            break;

        case TEXT('+'):
            // next thing in the string should be the country code
            // if there is a '+', I do not allow @ sign to be interpreted as a special character
            fRoutingNameAllowed = FALSE;
            lpszTempBuf = szTempBuf;
            nWhatStarted = country_code;
            break;

        case TEXT('-'):
            switch (nWhatStarted)
            {
                case country_code:
                    lstrcpy(lpParsedFaxAddr->szCountryCode, szTempBuf);
                    lpszTempBuf = szTempBuf;
                    nWhatStarted = area_code;
                    lstrcpy(szTempBuf, TEXT(""));
                    break;

                case area_code:
                    lstrcpy (lpParsedFaxAddr->szAreaCode, szTempBuf);
                    lpszTempBuf = szTempBuf;
                    nWhatStarted = tel_number;
                    break;

                default:        // for any other character, store in a temp buffer
                    *(lpszTempBuf++) = lpszFaxAddr[i];
                    *(lpszTempBuf) = 0;
                    break;
            }
            break;

        case TEXT('('):
            // next thing in the string should be the area code
            if (fAreaCodeAllowed)
            {
                lpszTempBuf = szTempBuf;
                nWhatStarted = area_code;
            }
            break;

        case TEXT(')'):
            // copy without the ()
            if ((fAreaCodeAllowed) && (nWhatStarted == area_code))
            {
                lstrcpy(lpParsedFaxAddr->szAreaCode, szTempBuf);
                // advance beyond the space that follows the ')'
                i++;
                lpszTempBuf = szTempBuf;
                nWhatStarted = tel_number;
                fAreaCodeAllowed = FALSE;
            }
            break;

        case TEXT(' '):
            // this ends something
            if (nWhatStarted == country_code)
            {
                lstrcpy(lpParsedFaxAddr->szCountryCode, szTempBuf);
                lpszTempBuf = szTempBuf;
                nWhatStarted = tel_number; // may be overriden be area code, if any
                // if next character is not '(', I disallow area code
                if (lpszFaxAddr[i+1] != '(')
                        fAreaCodeAllowed = FALSE;
                break;
            }
            else if (nWhatStarted == area_code)
            {
                // should not happen
                DEBUG_TRACE("DecodeFaxAddress: bad address. space in area code\n");
                return FALSE;
            }
            else;
            // Spaces are allowed in the mailbox or the phone number,
            // so I fall through to the default case

        default:        // for any other character, store in a temp buffer
            *(lpszTempBuf++) = lpszFaxAddr[i];
            *(lpszTempBuf) = 0;
            break;
        }       // switch (lpszFaxAddr[i])

    }       // for

    // End of address string. Last component must be the telephone number
    if (nWhatStarted == tel_number)
    {
        lstrcpy(lpParsedFaxAddr->szTelNumber, szTempBuf);
        bResult = TRUE;
    }
    else
    {
        // we also get here on empty input string
        bResult = FALSE;
    }

    return bResult;

} /* DecodeFaxAddress */

#ifdef DO_WE_REALLY_NEED_TAPI
/****************************************************************************

    FUNCTION:   DoThreadAttach()

    PURPOSE:    does the thread attach (DLL_THREAD_ATTACH) actions

    PARAMETERS: [in/out] lppPTGData - address where to put the thread's private
                                      storage pointer

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL DoThreadAttach(LPPTGDATA *lppPTGData)
{
    LPPTGDATA lpPTGData=NULL;

    // initialize the TLS index for this thread
    lpPTGData = (LPPTGDATA) LocalAlloc(LPTR, sizeof(PTGDATA));
    if (lpPTGData)
    {
        TlsSetValue(dwTlsIndex, lpPTGData);
    }
    else
    {
        DEBUG_TRACE("DoThreadAttach: LocalAlloc() failed for thread %x\n", GetCurrentThreadId());
        goto error;
    }

    /*
     *      initilialize the per-thread data
     */

    RtlZeroMemory((PVOID) lpPTGData, sizeof(PTGDATA));

    // initialize the critical section that is used to control access to hInst
    // to make sure this thread does not call us again
    InitializeCriticalSection(&(pt_csInstance));

    // initialize allocations array
    if (!InitAllocations())
    {
        DEBUG_TRACE("DoThreadAttach: InitAllocations failed\n");
        goto error;
    }

    // allocate and initialize the TAPI state structure
    if (MAWFAllocBuff(SIZEOF(DTS), &pt_lpVdts))
    {
        DEBUG_TRACE("DoThreadAttach: allocation of vdts failed\n");
        goto error;
    }

    RtlZeroMemory((PVOID) pt_lpVdts, SIZEOF(DTS));
    pt_lpVdts->dwCurrentLocationID = (DWORD)-1;

    lpPTGData->iLastDeviceAdded=LINEID_NONE; // what kind of device was last added

    *lppPTGData = lpPTGData;
    return TRUE;

error:
    *lppPTGData = NULL;
    return FALSE;
}



/****************************************************************************

    FUNCTION:   GetThreadStoragePointer()

    PURPOSE:    gets the private storage pointer for a thread, allocating one
                if it does not exist (i.e. the thread didn't go through LibMain
                THREAD_ATTACH)

    PARAMETERS: none

    RETURNS:    a pointer to the thread's private storage
                NULL, if there was a failure (usually memory allocation failure)

****************************************************************************/
LPPTGDATA GetThreadStoragePointer()
{
    LPPTGDATA lpPTGData=TlsGetValue(dwTlsIndex);

    // if the thread does not have a private storage, it did not go through
    // THREAD_ATTACH and we need to do this here.

    if (!lpPTGData)
    {
        DEBUG_TRACE("GetThreadStoragePointer: no private storage for this thread %x\n",
                                GetCurrentThreadId());
        if (!DoThreadAttach(&lpPTGData))
                lpPTGData = NULL;
    }

    return lpPTGData;

}


/* ***************************************************************************
 * InitTAPI
 *
 * initializes TAPI by calling lineInitialize. enumerates all the available
 * lines to set up pt_lpVdts->lprgLineInfo. also opens up each available line for
 * monitoring. sets up pt_lpVdts->iLineCur and pt_lpVdts->iAddrCur by checking the
 * preferred line/address name stored in the ini file  against the available
 * line/address names.
 *
 * Parameters:  hInst       - the instance of the calling module
 *              hWnd        - window handle for UI
 *              lpszAppName - the name of the calling module
 *
 * returns NO_ERROR if success and the corresponding error code otherwise.
 */

DWORD
InitTAPI( HINSTANCE hInst,
          HWND hWnd,
          LPTSTR lpszAppName
         )
{
    LONG lResult;
    LONG lResultLine = NO_ERROR;
    DWORD iLine, iLineVoiceFirst = (DWORD)-1;

#ifdef LINE_ADDRESSES
    DWORD iAddr, cAddr;
    LPLINEADDRESSCAPS lpAddrCaps = NULL;
    CHAR szPreferedAddress[cchAddrNameMac];
#endif

    LPPTGDATA lpPTGData = GetThreadStoragePointer();
    CHECK_THREAD_STORAGE_POINTER(lpPTGData, "InitTAPI", LINEERR_NOMEM);

    /***************************************
     ********* initialize tapi *************
     ***************************************/

    DEBUG_TRACE("InitTAPI: thread %x is initializing\n", GetCurrentThreadId());
    DEBUG_TRACE("InitTAPI: cRefCount is %d\n", pt_lpVdts->cRefCount);

    // see if this thread already initialized TAPI
    if (pt_lpVdts->cRefCount)
    {
        lResult = NO_ERROR;
        goto LDone;
    }

    if ((lResult = TAPIBasicInit(hInst, hWnd, lpszAppName)) != NO_ERROR)
            goto LDone;

    /***************************************
     ********* initialize lines ************
     ***************************************/

    // initialize pt_lpVdts->lpgrLineInfo and open each available line for
    //  monitoring

    // allocate buffer for storing LINEINFO for all the available lines
    pt_lpVdts->lprgLineInfo = (LPLINEINFO)_fmalloc(SIZEOF(LINEINFO)*(int)pt_lpVdts->cLines);
    if (pt_lpVdts->lprgLineInfo == NULL)
    {
        lResult = LINEERR_NOMEM;
                goto LDone;
    }
    _fmemset(pt_lpVdts->lprgLineInfo,0,SIZEOF(LINEINFO)*(int)pt_lpVdts->cLines);

    // init pt_lpVdts->lprgLineInfo and open each line to get its caps
    // also count the fax lines
    pt_lpVdts->cFaxLines = 0;
    for (iLine = 0; iLine < pt_lpVdts->cLines; ++iLine)
    {
        // Open the line and get its capabilities, including its name
        lResult = GetCachedLineInfo(iLine);
        if (lResult != NO_ERROR)
        {
            // something went wrong with initializing a line that TAPI told me
            // should be OK
            // I save the lResult (but doing nothing with it for now)
            // and continue with other lines. This line does not get enumerated.
            lResultLine = lResult;
            // this does not mean InitTAPI failed
            lResult = NO_ERROR;
            continue;
            // goto LDone;
        }

        if ( (iLineVoiceFirst == (DWORD)-1) &&
             pt_lpVdts->lprgLineInfo[iLine].fIsVoiceLine
            )
        {
            iLineVoiceFirst = iLine;
        }

        // if it's a fax line, count it in
        if (pt_lpVdts->lprgLineInfo[iLine].fIsVoiceLine)
                // CHECK: && fIsFaxDevice))
        {
            pt_lpVdts->cFaxLines++;
        }

    } // for

    // No reason to proceed if no Fax lines
    if (pt_lpVdts->cFaxLines == 0)
    {
        /* no voice line, too bad */
        lResult = ERROR_NO_LINES;
        pt_lpVdts->iLineCur = NO_MODEM;
        goto LDone;
    }
    // If no current line and there is a voice line, set the current line to be this voice line
    // This code is probably not needed, as I later (InitLineDeviceLB()) set the current line
    // from the profile
    else if (pt_lpVdts->iLineCur == NO_MODEM)
    {
        pt_lpVdts->iLineCur = iLineVoiceFirst;
    }

#ifdef LINE_ADDRESSES
    /* **************************************************/
    /* init pt_lpVdts->iAddrCur */

    // Set the line address to a default value of 0 (the only one currently supported)
    pt_lpVdts->iAddrCur = 0;

    // allocate buffer for the lineGetAddressCaps calls
    if ((lpAddrCaps = (LPLINEADDRESSCAPS)_fmalloc(lcbAddrDevCapsInitial))
            == NULL)
    {
        lResult = LINEERR_NOMEM;
        goto LDone;
    }
    lpAddrCaps->dwTotalSize = lcbAddrDevCapsInitial;

    // enumerate all the available addresses to match szPreferedAddress with
    // an address name
    cAddr = pt_lpVdts->lprgLineInfo[pt_lpVdts->iLineCur].cAddr;
    for (iAddr = 0; iAddr < cAddr; ++iAddr)
    {
        char szAddrName[cchAddrNameMac];
        LPTSTR lpszAddrName;

                // get address capability info
        lResult = lineGetAddressCaps( pt_lpVdts->hApp,
                                      pt_lpVdts->iLineCur,
                                      iAddr,
                                      tapiVersionCur,
                                      0,
                                      lpAddrCaps
                                     );
        if (lResult != NO_ERROR)
            goto LDone;

        // reallocate buffer if not big enough
        while (lpAddrCaps->dwNeededSize > lpAddrCaps->dwTotalSize)
        {
            DWORD lcbNeeded = lpAddrCaps->dwNeededSize;

            _ffree(lpAddrCaps);
            if ((lpAddrCaps = (LPLINEADDRESSCAPS)_fmalloc((size_t)lcbNeeded))
                    == NULL)
            {
                lResult = LINEERR_NOMEM;
                goto LDone;
            }
            lpAddrCaps->dwTotalSize = lcbNeeded;

            /* try it one more time */
            lResult = lineGetAddressCaps( pt_lpVdts->hApp,
                                          pt_lpVdts->iLineCur,
                                          iAddr,
                                          tapiVersionCur,
                                          0,
                                          lpAddrCaps
                                         );
            if (lResult != NO_ERROR)
                goto LDone;
        } /* while */

        /* get the address's name */
        if (lpAddrCaps->dwAddressSize > 0)
            lpszAddrName = (LPTSTR)((LPBYTE)(lpAddrCaps)+lpAddrCaps->dwAddressOffset);
        else
        {
                /* use default name */
            TCHAR szAddrFormat[32];

            LoadString( hInst,
                        IDS_TAPI_LINE_NAME,
                        szAddrFormat,
                        ARRAYSIZEf(szAddrFormat)
                       );
            wsprintf(szAddrName,szAddrFormat,iAddr);
            lpszAddrName = (LPTSTR)szAddrName;
        } /* else */

        if (lstrcmpi(lpszAddrName,szPreferedAddress) == 0)
        {
            pt_lpVdts->iAddrCur = iAddr;
            break;
        } /* if */
    } /* for */
#endif  // #ifdef LINE_ADDRESSES

    lResult = NO_ERROR;

LDone:
    // free up memory allocated

#ifdef LINE_ADDRESSES
    if (lpAddrCaps)
        _ffree(lpAddrCaps);
#endif

    // if InitTAPI succeeded, bump up the ref count
    if ( (lResult == NO_ERROR) ||
         (lResult == ERROR_NO_LINES)
        )
    {
        pt_lpVdts->cRefCount++;
    }
    // else, free unneeded memory
    else if (pt_lpVdts->lprgLineInfo)
    {
        _ffree(pt_lpVdts->lprgLineInfo);
        pt_lpVdts->lprgLineInfo = NULL;
    }

    return lResult;

} /* InitTAPI */


/****************************************************************************
 *  DeinitTAPI
 *
 *  frees up the memory allocated, closes all the lines we have opened for
 *  monitoring and calls lineShutDown to disconnect from TAPI.
 */

BOOL DeinitTAPI()
{
    LPPTGDATA lpPTGData = GetThreadStoragePointer();
    CHECK_THREAD_STORAGE_POINTER(lpPTGData, "DeinitTAPI", 0xffffffff);

    DEBUG_TRACE("DeinitTAPI: thread %x is deinitializing\n", GetCurrentThreadId());

    // if ref count is already 0, unbalanced calls, do nothing
    if (!(pt_lpVdts->cRefCount))
            return TRUE;

    // don't want to deinit if ref count is still > 0
    if (--pt_lpVdts->cRefCount)
            return TRUE;

    /* never mind if lineInitialize failed in the first place */
    if (!pt_lpVdts->fLineInited)
        return TRUE;

    /* unregister STAPI */
    FRegisterSimpleTapi(FALSE);

    /* closes all the open lines and free pt_lpVdts->lprgLineInfo */
    if (pt_lpVdts->lprgLineInfo)
    {
        DWORD iLine;

        for (iLine = 0; iLine < pt_lpVdts->cLines; ++iLine)
        {
            DEBUG_TRACE( "Thread %x,DeinitTAPI: looking to close line %x...\n",
                         GetCurrentThreadId(),
                         iLine
                        );
            if (pt_lpVdts->lprgLineInfo[iLine].dwAPIVersion == 0)
                continue;
            lineClose(pt_lpVdts->lprgLineInfo[iLine].hLine);
            DEBUG_TRACE( "Thread %x,DeinitTAPI: line %x is closed\n",
                         GetCurrentThreadId(),
                         iLine
                        );
        } /* for */

        _ffree(pt_lpVdts->lprgLineInfo);
    } /* if */

    /* disconnect from TAPI */
    lineShutdown(pt_lpVdts->hApp);

    pt_lpVdts->hInst = NULL;

    return TRUE;

} /* DeinitTAPI */
#endif // DO_WE_REALLY_NEED_TAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\wrap.h ===
//
//  Function prototypes
//
//  Those not mentioned use ROOT_methods


#undef	INTERFACE
#define INTERFACE	struct _WRAP

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, WRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, WRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WRAP_)
{
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _WRAP {

    WRAP_Vtbl * lpVtbl;

    FAB_Wrapped;
    
} WRAP, *LPWRAP;

#define CBWRAP sizeof(WRAP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ab\wrap.c ===
/***********************************************************************
 *
 *  WRAP.C
 *
 *  Sample Address Book Wrap object
 *  This file contains the code for implementing the Sample AB
 *  WRAP object.
 *
 *  This file contains methods with "default" actions for objects which
 *  expose IUnknown and/or IMAPIProp.  These "default" actions are to call
 *  the appropriate method of a "wrapped" object that is a member of this
 *  object.  Various methods in this file are used throughout this sample
 *  provider and are especially useful with the objects that implement template
 *  ids (see TID.C and OOTID.C).
 *
 *  Copyright 1992, 1993, 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

#include "faxab.h"

/*********************************************************************
 *
 *  The actual Wrapped IMAPIProp methods
 *
 */

STDMETHODIMP
WRAP_QueryInterface( LPWRAP lpWRAP,
                     REFIID lpiid,
                     LPVOID * lppNewObj
                    )
{
    HRESULT hr;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, QueryInterface)+SIZEOF(WRAP_QueryInterface_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */
        return ResultFromScode(E_INVALIDARG);
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_QueryInterface != lpWRAP->lpVtbl->QueryInterface)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        return ResultFromScode(E_INVALIDARG);
    }

    EnterCriticalSection(&lpWRAP->cs);
    /*  Call the internal prop interface */

    hr = lpWRAP->lpPropData->lpVtbl->QueryInterface( lpWRAP->lpPropData,
                                                     lpiid,
                                                     lppNewObj
                                                    );

    /*  If this object is successful in QI'ing and it returns exactly the
     *  same object, then I need to AddRef my own "wrapper" object so that
     *  my release code works correctly AND replace the *lppNewObj with the
     *  "wrapper" object.
     */
    if (!HR_FAILED(hr) && (lpWRAP->lpPropData == *lppNewObj))
    {
        ++lpWRAP->lcInit;
        *lppNewObj = lpWRAP;
    }

    LeaveCriticalSection(&lpWRAP->cs);

    return hr;

}

STDMETHODIMP_(ULONG) WRAP_AddRef(LPWRAP lpWRAP)
{
    ULONG ulRet;
    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        return 1;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, AddRef)+SIZEOF(WRAP_AddRef_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */
        return 1;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_AddRef != lpWRAP->lpVtbl->AddRef)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        return 1;
    }

    EnterCriticalSection(&lpWRAP->cs);
    ++lpWRAP->lcInit;

    /*  Call the internal prop interface */

    ulRet = lpWRAP->lpPropData->lpVtbl->AddRef(lpWRAP->lpPropData);

    LeaveCriticalSection(&lpWRAP->cs);

    return ulRet;
}

STDMETHODIMP_(ULONG) WRAP_Release(LPWRAP lpWRAP)
{
    long lcInit;
    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        return 1;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, Release)+SIZEOF(WRAP_Release_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */
        return 1;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_Release != lpWRAP->lpVtbl->Release)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */
        return 1;
    }


    EnterCriticalSection(&lpWRAP->cs);

    /*
     *  Release the imapiprop object
     */

    lpWRAP->lpPropData->lpVtbl->Release(
        lpWRAP->lpPropData);

    lcInit = --lpWRAP->lcInit;

    LeaveCriticalSection(&lpWRAP->cs);

    if (lcInit == 0)
    {

        /*
         *  Get rid of my critical section
         */
        DeleteCriticalSection(&lpWRAP->cs);

        /*
         *  Set the Jump table to NULL.  This way the client will find out
         *  real fast if it's calling a method on a released object.  That is,
         *  the client will crash.  Hopefully, this will happen during the
         *  development stage of the client.
         */

        lpWRAP->lpVtbl = NULL;

        /*
         *  Need to free the object
         */

        lpWRAP->lpFreeBuff(lpWRAP);
        return 0;
    }

    return lcInit;
}

STDMETHODIMP
WRAP_GetLastError( LPWRAP lpWRAP,
                   HRESULT hError,
                   ULONG ulFlags,
                   LPMAPIERROR FAR * lppMapiError
                  )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
        offsetof(WRAP_Vtbl, GetLastError)+SIZEOF(WRAP_GetLastError_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_GetLastError != lpWRAP->lpVtbl->GetLastError)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    if ( ulFlags & ~MAPI_UNICODE )
    {
            hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS );
            return hResult ;
    }

#ifndef UNICODE
    if ( ulFlags & MAPI_UNICODE )
    {
        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        return hResult;
    }
#endif

    return lpWRAP->lpPropData->lpVtbl->GetLastError( lpWRAP->lpPropData,
                                                     hError,
                                                     ulFlags,
                                                     lppMapiError
                                                    );
}

/* IProperty */

STDMETHODIMP
WRAP_SaveChanges( LPWRAP lpWRAP,
                  ULONG ulFlags
                 )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, SaveChanges)+SIZEOF(WRAP_SaveChanges_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_SaveChanges != lpWRAP->lpVtbl->SaveChanges)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    hResult = lpWRAP->lpPropData->lpVtbl->SaveChanges( lpWRAP->lpPropData,
                                                       ulFlags
                                                      );

    return hResult;

}

STDMETHODIMP
WRAP_GetProps( LPWRAP lpWRAP,
               LPSPropTagArray lpPropTagArray,
               ULONG ulFlags,
               ULONG * lpcValues,
               LPSPropValue * lppPropArray
              )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, GetProps)+SIZEOF(WRAP_GetProps_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_GetProps != lpWRAP->lpVtbl->GetProps)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    if ( ulFlags & ~(MAPI_UNICODE) )
    {
        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS );

        return hResult;

    }

#ifndef UNICODE
    if ( ulFlags & MAPI_UNICODE )
    {
        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        return hResult;
    }
#endif

    return lpWRAP->lpPropData->lpVtbl->GetProps( lpWRAP->lpPropData,
                                                 lpPropTagArray,
                                                 ulFlags,
                                                 lpcValues,
                                                 lppPropArray
                                                );

}

STDMETHODIMP
WRAP_GetPropList( LPWRAP lpWRAP,
                  ULONG ulFlags,
                  LPSPropTagArray * lppPropTagArray
                 )
{
    HRESULT hResult = hrSuccess;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, GetPropList)+SIZEOF(WRAP_GetPropList_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_GetPropList != lpWRAP->lpVtbl->GetPropList)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    if ( ulFlags & ~(MAPI_UNICODE) )
    {
        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS );

        return hResult;

    }

#ifndef UNICODE
    if ( ulFlags & MAPI_UNICODE )
    {
            hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
            return hResult;
    }
#endif

    return lpWRAP->lpPropData->lpVtbl->GetPropList( lpWRAP->lpPropData,
                                                    ulFlags,
                                                    lppPropTagArray
                                                   );

}

STDMETHODIMP
WRAP_OpenProperty( LPWRAP lpWRAP,
                   ULONG ulPropTag,
                   LPCIID lpiid,
                   ULONG ulInterfaceOptions,
                   ULONG ulFlags,
                   LPUNKNOWN * lppUnk
                  )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, OpenProperty)+SIZEOF(WRAP_OpenProperty_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_OpenProperty != lpWRAP->lpVtbl->OpenProperty)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }


    if ( ulInterfaceOptions & ~MAPI_UNICODE )
    {
            hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS );
            return hResult;
    }

#ifndef UNICODE
    if ( ulInterfaceOptions & MAPI_UNICODE )
    {
        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH );
        return hResult;
    }
#endif

    hResult = lpWRAP->lpPropData->lpVtbl->OpenProperty( lpWRAP->lpPropData,
                                                        ulPropTag,
                                                        lpiid,
                                                        ulInterfaceOptions,
                                                        ulFlags,
                                                        lppUnk
                                                       );

    return hResult;

}

STDMETHODIMP
WRAP_SetProps( LPWRAP lpWRAP,
               ULONG cValues,
               LPSPropValue lpPropArray,
               LPSPropProblemArray * lppProblems
              )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, SetProps)+SIZEOF(WRAP_SetProps_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_SetProps != lpWRAP->lpVtbl->SetProps)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    return lpWRAP->lpPropData->lpVtbl->SetProps( lpWRAP->lpPropData,
                                                 cValues,
                                                 lpPropArray,
                                                 lppProblems
                                                );

}

STDMETHODIMP
WRAP_DeleteProps( LPWRAP lpWRAP,
                  LPSPropTagArray lpPropTagArray,
                  LPSPropProblemArray * lppProblems
                 )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, DeleteProps)+SIZEOF(WRAP_DeleteProps_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_DeleteProps != lpWRAP->lpVtbl->DeleteProps)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    return lpWRAP->lpPropData->lpVtbl->DeleteProps( lpWRAP->lpPropData,
                                                    lpPropTagArray,
                                                    lppProblems
                                                   );

}

STDMETHODIMP
WRAP_CopyTo( LPWRAP lpWRAP,
             ULONG ciidExclude,
             LPCIID rgiidExclude,
             LPSPropTagArray lpExcludeProps,
             ULONG ulUIParam,
             LPMAPIPROGRESS lpProgress,
             LPCIID lpInterface,
             LPVOID lpDestObj,
             ULONG ulFlags,
             LPSPropProblemArray FAR * lppProblems
            )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, CopyTo)+SIZEOF(WRAP_CopyTo_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_CopyTo != lpWRAP->lpVtbl->CopyTo)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    return lpWRAP->lpPropData->lpVtbl->CopyTo( lpWRAP->lpPropData,
                                               ciidExclude,
                                               rgiidExclude,
                                               lpExcludeProps,
                                               ulUIParam,
                                               lpProgress,
                                               lpInterface,
                                               lpDestObj,
                                               ulFlags,
                                               lppProblems
                                              );
}

STDMETHODIMP
WRAP_CopyProps( LPWRAP lpWRAP,
                LPSPropTagArray lpIncludeProps,
                ULONG ulUIParam,
                LPMAPIPROGRESS lpProgress,
                LPCIID lpInterface,
                LPVOID lpDestObj,
                ULONG ulFlags,
                LPSPropProblemArray FAR * lppProblems
               )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, CopyProps)+SIZEOF(WRAP_CopyProps_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_CopyProps != lpWRAP->lpVtbl->CopyProps)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    return lpWRAP->lpPropData->lpVtbl->CopyProps( lpWRAP->lpPropData,
                                                  lpIncludeProps,
                                                  ulUIParam,
                                                  lpProgress,
                                                  lpInterface,
                                                  lpDestObj,
                                                  ulFlags,
                                                  lppProblems
                                                 );
}

STDMETHODIMP
WRAP_GetNamesFromIDs( LPWRAP lpWRAP,
                      LPSPropTagArray * lppPropTags,
                      LPGUID lpPropSetGuid,
                      ULONG ulFlags,
                      ULONG * lpcPropNames,
                      LPMAPINAMEID ** lpppPropNames
                     )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, GetNamesFromIDs)+SIZEOF(WRAP_GetNamesFromIDs_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_GetNamesFromIDs != lpWRAP->lpVtbl->GetNamesFromIDs)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    return lpWRAP->lpPropData->lpVtbl->GetNamesFromIDs( lpWRAP->lpPropData,
                                                        lppPropTags,
                                                        lpPropSetGuid,
                                                        ulFlags,
                                                        lpcPropNames,
                                                        lpppPropNames
                                                        );
}

STDMETHODIMP
WRAP_GetIDsFromNames( LPWRAP lpWRAP,
                      ULONG cPropNames,
                      LPMAPINAMEID * lppPropNames,
                      ULONG ulFlags,
                      LPSPropTagArray * lppPropTags
                     )
{
    HRESULT hResult;

    /*
     *  Check to see if it has a lpVtbl object member
     */
    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+SIZEOF(WRAP_Vtbl *)))
    {
        /*
         *  No jump table found
         */
        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see that the Vtbl is large enough to include this method
     */
    if (IsBadReadPtr(lpWRAP->lpVtbl,
                     offsetof(WRAP_Vtbl, GetIDsFromNames)+SIZEOF(WRAP_GetIDsFromNames_METHOD *)))
    {
        /*
         *  Jump table not derived from IUnknown
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    /*
     *  Check to see if the method is the same
     */
    if (WRAP_GetIDsFromNames != lpWRAP->lpVtbl->GetIDsFromNames)
    {
        /*
         *  Wrong object - the object passed doesn't have this
         *  method.
         */

        hResult = ResultFromScode(E_INVALIDARG);

        return hResult;
    }

    return lpWRAP->lpPropData->lpVtbl->GetIDsFromNames( lpWRAP->lpPropData,
                                                        cPropNames,
                                                        lppPropNames,
                                                        ulFlags,
                                                        lppPropTags
                                                       );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ext\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxext.h"
#include "faxhelp.h"
#include "resource.h"


extern HINSTANCE hInstance;


VOID
AddCoverPagesToList(
    HWND        hwndList,
    LPSTR       pDirPath,
    BOOL        ServerCoverPage
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a listbox

Arguments:

    hwndList        - Handle to a list window
    pDirPath        - Directory to look for coverpage files
    ServerCoverPage - TRUE if the dir contains server cover pages

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    CHAR            filename[MAX_PATH];
    CHAR            CpName[MAX_PATH];
    HANDLE          hFindFile;
    LPSTR           pFilename;
    LPSTR           pExtension;
    INT             listIndex;
    INT             dirLen;
    INT             fileLen;
    INT             flags = CPFLAG_LINK;
    INT             Cnt = 2;


    //
    // Copy the directory path to a local buffer
    //

    if (pDirPath == NULL || pDirPath[0] == 0) {
        return;
    }

    if ((dirLen = strlen( pDirPath )) >= MAX_PATH - MAX_FILENAME_EXT - 1) {
        return;
    }

    strcpy( filename, pDirPath );
    if (filename[dirLen] !=  '\\')  {
        filename[dirLen] = '\\';
        filename[dirLen+1] = '\0';
        dirLen++;
    }

    //
    // Go through the following loop twice:
    //  Once to add the files with .ncp extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //

    while( Cnt ) {

        //
        // Generate a specification for the files we're interested in
        //

        pFilename = &filename[dirLen];
        *pFilename = TEXT('*');
        strcpy( pFilename+1, ServerCoverPage ? CP_FILENAME_EXT : (flags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT );

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile( filename, &findData );

        if (hFindFile != INVALID_HANDLE_VALUE) {

            do {

                //
                // Exclude directories and hidden files
                //

                if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY)) {
                    continue;
                }

                //
                // Make sure we have enough room to store the full pathname
                //

                if ((fileLen = strlen( findData.cFileName)) <= MAX_FILENAME_EXT ) {
                    continue;
                }

                if (fileLen + dirLen >= MAX_PATH) {
                    continue;
                }

                //
                // If we're chasing links, make sure the link refers to
                // a cover page file.
                //

                if (!ServerCoverPage && (flags & CPFLAG_LINK)) {

                    strcpy( pFilename, findData.cFileName );

                    if (!IsCoverPageShortcut(filename)) {
                        continue;
                    }
                }

                //
                // Don't display the filename extension
                //

                if (pExtension = strrchr(findData.cFileName,'.')) {
                    *pExtension = NULL;
                }

                //
                // Add the cover page name to the list window
                //

                strcpy( CpName, findData.cFileName );
                if ( ! ServerCoverPage )
                {
                   char szPersonal[30];
                   LoadString( hInstance, IDS_PERSONAL, szPersonal, 30 );
                   strcat( CpName, (char *) " " );
                   strcat( CpName, szPersonal );
                }

                listIndex = (INT)SendMessage(
                    hwndList,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) CpName
                    );

                if (listIndex != LB_ERR) {
                    SendMessage( hwndList, LB_SETITEMDATA, listIndex, ServerCoverPage );
                }

            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;
        Cnt -= 1;
        if (ServerCoverPage) {
            Cnt -= 1;
        }

    }
}


LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    )
{
    DWORD LineTransCapsSize;
    LONG Rslt = ERROR_SUCCESS;


    //
    // allocate the initial linetranscaps structure
    //

    LineTransCapsSize = sizeof(LINETRANSLATECAPS) + 4096;
    *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
    if (!*LineTransCaps) {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

    Rslt = lineGetTranslateCaps(
        NULL,
        0x00020000,
        *LineTransCaps
        );
    if (Rslt != 0) {
        goto exit;
    }

    if ((*LineTransCaps)->dwNeededSize > (*LineTransCaps)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransCapsSize = (*LineTransCaps)->dwNeededSize;

        MemFree( *LineTransCaps );

        *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
        if (!*LineTransCaps) {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

        Rslt = lineGetTranslateCaps(
            NULL,
            0x00020000,
            *LineTransCaps
            );

        if (Rslt != 0) {
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *LineTransCaps );
        *LineTransCaps = NULL;
    }

    return Rslt;
}

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    )

/*++

Routine Description:

    Dialog procedure for the fax mail transport configuration

Arguments:

    hDlg        - Window handle for this dialog
    message     - Message number
    wParam      - Parameter #1
    lParam      - Parameter #2

Return Value:

    TRUE    - Message was handled
    FALSE   - Message was NOT handled

--*/

{
    static LPLINETRANSLATECAPS LineTransCaps = NULL;
    static LPLINELOCATIONENTRY LineLocation = NULL;
    static PFAXXP_CONFIG FaxConfig;
    static HWND hwndListPrn;
    static HWND hwndListCov;
    static HWND hwndListLoc;
    static BOOL LocalPrinter;
    static const DWORD faxextHelpIDs[] = {

        IDC_PRINTER_LIST,           IDH_FMA_FAX_PRINTERS,
        IDC_USE_COVERPAGE,          IDH_FMA_INCLUDE_COVER_PAGE,
        IDC_COVERPAGE_LIST,         IDH_FMA_COVER_PAGES,
        IDC_DIALING_LOCATION,       IDH_FMA_DIALING_LOCATION,
        IDC_STATIC_DIALING_LOCATION,IDH_FMA_DIALING_LOCATION,
        IDC_STATIC_COVERPAGE_GRP,   IDH_FMA_COVER_PAGES,
        IDC_STATIC_COVERPAGE,       IDH_FMA_COVER_PAGES,
        IDC_STATIC_PRINTER_LIST,    IDH_FMA_FAX_PRINTERS,
        IDC_STATIC,                 (ULONG)IDH_INACTIVE,
        0,                          0
    };

    PPRINTER_INFO_2 PrinterInfo;
    DWORD CountPrinters;
    DWORD Selection = 0;
    BOOL Match;
    CHAR Buffer[256];
    CHAR CpDir[MAX_PATH];
    LPSTR p;
    DWORD i;
    DWORD_PTR j;
    HANDLE hFax;
    PFAX_CONFIGURATION pFaxConfiguration;
    DWORD dwPermanentLocationID = 0;
    LPSTR pLocationName = NULL;


    switch( message ) {
        case WM_INITDIALOG:
            FaxConfig = (PFAXXP_CONFIG) lParam;
            //
            // defer the server CP check to this point so we don't fire up fax service
            // unless we really need this property
            //
            if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) ){
                if (FaxGetConfiguration(hFax,&pFaxConfiguration) ){
                    FaxConfig->ServerCpOnly = pFaxConfiguration->ServerCp;
                    FaxFreeBuffer(pFaxConfiguration);
                }
                FaxClose(hFax);
            }

            hwndListPrn = GetDlgItem( hDlg, IDC_PRINTER_LIST );
            hwndListCov = GetDlgItem( hDlg, IDC_COVERPAGE_LIST );
            hwndListLoc = GetDlgItem( hDlg, IDC_DIALING_LOCATION );

            Buffer[0] = 0;
            PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
            Match = FALSE;
            if (PrinterInfo) {
                for (i=0,j=0; i<CountPrinters; i++) {
                    if (strcmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                        SendMessage( hwndListPrn, CB_ADDSTRING, 0, (LPARAM) PrinterInfo[i].pPrinterName );
                        if (FaxConfig->PrinterName && strcmp( PrinterInfo[i].pPrinterName, FaxConfig->PrinterName ) == 0) {
                            Match = TRUE;
                            if (PrinterInfo[i].pServerName) {
                                strcpy( Buffer, PrinterInfo[i].pServerName );
                            }
                        }
                        j += 1;
                    }
                }
                if (j == 0) {
                    //
                    // no fax printers
                    //
                    goto cp;
                }
                if (!Match) {
                    MemFree( FaxConfig->PrinterName );
                    FaxConfig->PrinterName = StringDup( PrinterInfo[0].pPrinterName );
                }
                MemFree( PrinterInfo );
                SendMessage( hwndListPrn, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) FaxConfig->PrinterName );
                PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig->PrinterName, 2 );
                if (PrinterInfo && (PrinterInfo->Attributes & PRINTER_ATTRIBUTE_LOCAL)) {
                    LocalPrinter = TRUE;
                } else {
                    LocalPrinter = FALSE;
                }
                MemFree( PrinterInfo );
            }
cp:
            if (FaxConfig->UseCoverPage) {
                CheckDlgButton( hDlg, IDC_USE_COVERPAGE, BST_CHECKED );
            } else {
                EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
            }

            GetServerCpDir( Buffer[0] ? Buffer : NULL, CpDir, sizeof(CpDir) );
            AddCoverPagesToList( hwndListCov, CpDir, TRUE );


            if (!FaxConfig->ServerCpOnly) {
                GetClientCpDir( CpDir, sizeof(CpDir) );
                AddCoverPagesToList( hwndListCov, CpDir, FALSE );
            }

            Selection = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, 0, (LPARAM) FaxConfig->CoverPageName );
            if (Selection == LB_ERR) {
                Selection = 0;
            }
            SendMessage( hwndListCov, LB_SETCURSEL, (WPARAM) Selection, 0 );

            MyLineGetTransCaps( &LineTransCaps );
            if (LineTransCaps && LineTransCaps->dwLocationListSize && LineTransCaps->dwLocationListOffset) {
                LineLocation = (LPLINELOCATIONENTRY) ((LPBYTE)LineTransCaps + LineTransCaps->dwLocationListOffset);
                for (i=0; i<LineTransCaps->dwNumLocations; i++) {
                    if (LineLocation[i].dwLocationNameSize && LineLocation[i].dwLocationNameOffset) {
                        j = SendMessage(
                            hwndListLoc,
                            CB_ADDSTRING,
                            0,
                            (LPARAM) (LPSTR) ((LPBYTE)LineTransCaps + LineLocation[i].dwLocationNameOffset)
                            );
                        SendMessage(
                            hwndListLoc,
                            CB_SETITEMDATA,
                            j,
                            (LPARAM) LineLocation[i].dwPermanentLocationID
                            );

                        if (LineLocation[i].dwPermanentLocationID == LineTransCaps->dwCurrentLocationID) {
                            pLocationName = (LPSTR) ((LPBYTE)LineTransCaps + LineLocation[i].dwLocationNameOffset);
                        }
                    }
                }
                if (pLocationName) {
                    SendMessage( hwndListLoc, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) pLocationName );
                }
            }

            if (!LocalPrinter) {
                EnableWindow( hwndListLoc, FALSE );
            }

            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                if (LOWORD(wParam) == IDC_USE_COVERPAGE) {
                    if (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED) {
                        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), TRUE  );
                    } else {
                        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
                    }
                    return FALSE;
                }
            }

            if (HIWORD(wParam) == LBN_SELCHANGE && LOWORD(wParam) == IDC_PRINTER_LIST) {
                Selection = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                SendMessage( hwndListPrn, CB_GETLBTEXT, Selection, (LPARAM) Buffer );
                PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( Buffer, 2 );
                if (PrinterInfo && (PrinterInfo->Attributes & PRINTER_ATTRIBUTE_LOCAL)) {
                    LocalPrinter = TRUE;
                } else {
                    LocalPrinter = FALSE;
                }
                EnableWindow( hwndListLoc, LocalPrinter );

                SendMessage( hwndListCov, LB_RESETCONTENT, 0, 0 );




                GetServerCpDir( PrinterInfo ? PrinterInfo->pServerName : NULL, CpDir, sizeof(CpDir) );
                AddCoverPagesToList( hwndListCov, CpDir, TRUE );

                //
                // check if the server name has changed
                // (so we can update the "server CP only" flag)
                //
                BOOL ServerNameChange = FALSE;
                if (FaxConfig->ServerName) {
                    if (PrinterInfo && PrinterInfo->pServerName) {
                        if (strcmp(FaxConfig->ServerName,PrinterInfo->pServerName) != 0) {
                            MemFree(FaxConfig->ServerName);
                            FaxConfig->ServerName = StringDup(PrinterInfo->pServerName);
                            ServerNameChange = TRUE;
                        }
                    } else {
                        MemFree(FaxConfig->ServerName);
                        FaxConfig->ServerName = NULL;
                        ServerNameChange = TRUE;
                    }
                } else if (PrinterInfo && PrinterInfo->pServerName) {
                    FaxConfig->ServerName = StringDup(PrinterInfo->pServerName);
                    ServerNameChange = TRUE;
                }

                if (ServerNameChange) {
                    HANDLE hFax;
                    PFAX_CONFIGURATION pFaxConfiguration;

                    FaxConfig->ServerCpOnly = FALSE;
                    if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) ){
                        if (FaxGetConfiguration(hFax,&pFaxConfiguration) ){
                            FaxConfig->ServerCpOnly = pFaxConfiguration->ServerCp;
                            FaxFreeBuffer(pFaxConfiguration);
                        }
                        FaxClose(hFax);
                    }
                }


                if (! FaxConfig->ServerCpOnly) {
                    GetClientCpDir( CpDir, sizeof(CpDir) );
                    AddCoverPagesToList( hwndListCov, CpDir, FALSE );
                }

                SendMessage( hwndListCov, LB_SETCURSEL, 0, 0 );
                MemFree( PrinterInfo );
            }

            switch (wParam) {
                case IDOK :
                    FaxConfig->UseCoverPage = IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED;
                    Selection = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                    SendMessage( hwndListPrn, CB_GETLBTEXT, Selection, (LPARAM) Buffer );
                    MemFree( FaxConfig->PrinterName );
                    FaxConfig->PrinterName = StringDup( Buffer );
                    Selection = (DWORD)SendMessage( hwndListCov, LB_GETCURSEL, 0, 0 );
                    SendMessage( hwndListCov, LB_GETTEXT, Selection, (LPARAM) Buffer );
                    MemFree( FaxConfig->CoverPageName );

                    // Local cover page files are presented with the string " (Personal)"
                    // appended to the base of the cover page file name. Note the presence
                    // of a space character. The following code segment removes that string
                    // if it is present, before setting the CoverPageName member of FaxConfig.

                    p = strstr( Buffer, (const char *) " (" );

                    if ( p != NULL )
                    {
                       *p = (CHAR) '\0';
                    }

                    FaxConfig->CoverPageName = StringDup( Buffer );
                    FaxConfig->ServerCoverPage = (INT)SendMessage( hwndListCov, LB_GETITEMDATA, Selection, 0 );
                    Selection = (DWORD)SendMessage( hwndListLoc, CB_GETCURSEL, 0, 0 );
                    if (Selection >= 0 && LineTransCaps) {
                        dwPermanentLocationID = (DWORD) SendMessage( hwndListLoc, CB_GETITEMDATA, Selection, 0);
                        if (dwPermanentLocationID != LineTransCaps->dwCurrentLocationID) {
                            lineSetCurrentLocation( NULL, dwPermanentLocationID );
                        }
                    }
                    if (LineTransCaps) {
                        MemFree( LineTransCaps );
                    }

                    EndDialog( hDlg, IDOK );
                    break;

                case IDCANCEL:
                    MemFree( LineTransCaps );
                    EndDialog( hDlg, IDCANCEL );
                    break;
            }
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:

            FAXWINHELP( message, wParam, lParam, faxextHelpIDs );
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ext\resource.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Fax client extension resource header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#define IDC_STATIC                      -1
#define IDC_PRINTER_LIST               201
#define IDC_USE_COVERPAGE              202
#define IDC_COVERPAGE_LIST             203
#define IDC_DIALING_LOCATION           204
#define IDC_STATIC_DIALING_LOCATION    205
#define IDC_STATIC_COVERPAGE_GRP       206
#define IDC_STATIC_COVERPAGE           207
#define IDC_STATIC_PRINTER_LIST        208

#define FAX_CONFIG_DIALOG              501

#define IDB_EXTBTN                     801
#define IDI_FAX                        802

#define IDS_MSGBOXCAPTION              900
#define IDS_NOFAXADDR                  901
#define IDS_FAX_ATTRIBUTES_MENU        902
#define IDS_FAX_ATTRIBUTES_TOOLTIP     903
#define IDS_FAX_ATTRIBUTES_CUST        904
#define IDS_PERSONAL                   905
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ext\faxext.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#define INITGUID
#define USES_IID_IExchExt
#define USES_IID_IExchExtAdvancedCriteria
#define USES_IID_IExchExtAttachedFileEvents
#define USES_IID_IExchExtCommands
#define USES_IID_IExchExtMessageEvents
#define USES_IID_IExchExtPropertySheets
#define USES_IID_IExchExtSessionEvents
#define USES_IID_IExchExtUserEvents
#define USES_IID_IMAPIFolder
#define USES_IID_IProfAdmin
#define USES_IID_IProfSect
#define USES_IID_IMAPISession
#define USES_PS_PUBLIC_STRINGS
#define USES_IID_IDistList

#include "faxext.h"
#include <initguid.h>


HINSTANCE hInstance;




BOOL WINAPI
DllMain(
    HINSTANCE  hinstDLL,
    DWORD  fdwReason,
    LPVOID  lpvReserved
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        hInstance = hinstDLL;
        HeapInitialize( NULL, MapiMemAlloc, MapiMemFree, HEAPINIT_NO_VALIDATION | HEAPINIT_NO_STRINGS );
    }
    if (fdwReason == DLL_PROCESS_DETACH) {
    }
    return TRUE;
}


BOOL
VerifyDistributionList(
    LPEXCHEXTCALLBACK pmecb,
    DWORD EntryIdSize,
    LPENTRYID EntryId
    )
{
    HRESULT hr = S_OK;
    LPMAPISESSION Session = NULL;
    LPDISTLIST DistList = NULL;
    DWORD ObjType = 0;
    LPMAPITABLE DistTable = NULL;
    LPSRowSet DistRows = NULL;
    LPSPropValue Dist = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;


    hr = pmecb->GetSession( &Session, NULL );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = Session->OpenEntry(
        EntryIdSize,
        EntryId,
        &IID_IDistList,
        MAPI_DEFERRED_ERRORS,
        &ObjType,
        (LPUNKNOWN *) &DistList
        );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = DistList->GetContentsTable(
        MAPI_DEFERRED_ERRORS,
        &DistTable
        );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = HrQueryAllRows( DistTable, NULL, NULL, NULL, 0, &DistRows );
    if (FAILED(hr)) {
        goto exit;
    }

    for (i=0; i<DistRows->cRows; i++) {
        Dist = DistRows->aRow[i].lpProps;
        for (j=0; j<DistRows->aRow[i].cValues; j++) {
            if (Dist[j].ulPropTag == PR_ADDRTYPE) {
                if (strcmp( Dist[j].Value.LPSZ, "FAX" ) == 0) {
                    FaxAddress = TRUE;
                }
            }
        }
    }

exit:
    if (Session) {
        Session->Release();
    }
    if (DistList) {
        DistList->Release();
    }
    if (DistTable) {
        MemFree( DistTable );
    }
    if (DistRows) {
        FreeProws( DistRows );
    }

    return FaxAddress;
}


HRESULT
EnableMenuAndToolbar(
    LPEXCHEXTCALLBACK pmecb,
    HWND hwndToolbar,
    DWORD CmdId
    )
{
    HRESULT hr = S_OK;
    LPADRLIST AdrList = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;
    HMENU hMenu;
    LPENTRYID EntryId = NULL;
    DWORD EntryIdSize;

    OutputDebugString( TEXT("-----------------------\nEnableMenuAndToolbar called\n") );

    hr = pmecb->GetRecipients( &AdrList );
    if (FAILED(hr)) {
        OutputDebugString( TEXT("GetRecipients failed\n") );
        goto exit;
    }

    if (AdrList) {
        for (i=0; i<AdrList->cEntries; i++) {
            EntryId = NULL;
            for (j=0; j<AdrList->aEntries[i].cValues; j++) {
                if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ENTRYID) {
                    EntryId = (LPENTRYID) AdrList->aEntries[i].rgPropVals[j].Value.bin.lpb;
                    EntryIdSize = AdrList->aEntries[i].rgPropVals[j].Value.bin.cb;
                } else
                if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ADDRTYPE) {
                    if (strcmp( AdrList->aEntries[i].rgPropVals[j].Value.LPSZ, "FAX" ) == 0) {
                        FaxAddress = TRUE;
                    } else
                    if ((strcmp( AdrList->aEntries[i].rgPropVals[j].Value.LPSZ, "MAPIPDL" ) == 0) && (EntryId)) {
                        FaxAddress = VerifyDistributionList( pmecb, EntryIdSize, EntryId );
                    }
                }
            }
        }
    }

    hr = pmecb->GetMenu( &hMenu );

    if (FaxAddress) {
        OutputDebugString( TEXT("Enabling menu\n") );
        EnableMenuItem( hMenu, CmdId, MF_BYCOMMAND | MF_ENABLED );
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, (WPARAM) CmdId, MAKELONG(TRUE,0) );
    } else {
        OutputDebugString( TEXT("Disabling menu\n") );
        EnableMenuItem( hMenu, CmdId, MF_BYCOMMAND | MF_GRAYED );
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, (WPARAM) CmdId, MAKELONG(FALSE,0) );
    }

exit:
    MemFree( AdrList );
    return hr;
}


HRESULT
GetFaxConfig(
    LPEXCHEXTCALLBACK pmecb,
    PFAXXP_CONFIG FaxConfig
    )
{
    HRESULT hr = S_OK;
    LPMAPISESSION lpSession = NULL;
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    LPSPropValue pProps = NULL;
    LPSERVICEADMIN lpServiceAdmin = NULL;
    LPPROVIDERADMIN lpProviderAdmin = NULL;
    LPMAPITABLE ptblSvc = NULL;
    LPSRowSet pSvcRows = NULL;
    LPSPropValue pSvc = NULL;
    DWORD i,j;
    BOOL FoundIt = FALSE;
    LPBYTE FaxXpGuid = NULL;
    MAPIUID FaxGuid = FAX_XP_GUID;


    hr = pmecb->GetSession( &lpSession, NULL );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpSession->AdminServices( 0, &lpServiceAdmin );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpServiceAdmin->GetMsgServiceTable( 0, &ptblSvc );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = HrQueryAllRows( ptblSvc, NULL, NULL, NULL, 0, &pSvcRows );
    if (FAILED(hr)) {
        goto exit;
    }

    for (i=0; i<pSvcRows->cRows; i++) {
        pSvc = pSvcRows->aRow[i].lpProps;
        for (j=0; j<pSvcRows->aRow[i].cValues; j++) {
            if (pSvc[j].ulPropTag == PR_SERVICE_NAME) {
                if (_stricmp( pSvc[j].Value.LPSZ, "MSFAX XP" ) == 0) {
                    FoundIt = TRUE;
                }
            }
            if (pSvc[j].ulPropTag == PR_SERVICE_UID) {
                FaxXpGuid = pSvc[j].Value.bin.lpb;
            }
        }
        if (FoundIt) {
            break;
        }
    }

    if (!FoundIt) {
        goto exit;
    }

    hr = lpServiceAdmin->AdminProviders( (LPMAPIUID) FaxXpGuid, 0, &lpProviderAdmin );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpProviderAdmin->OpenProfileSection(
        &FaxGuid,
        NULL,
        0,
        &pProfileObj
        );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = pProfileObj->GetProps(
        (LPSPropTagArray) &sptFaxProps,
        0,
        &PropCount,
        &pProps
        );
    if (FAILED(hr)) {
        goto exit;
    }

    FaxConfig->PrinterName = StringDup( pProps[PROP_FAX_PRINTER_NAME].Value.LPSZ );
    FaxConfig->CoverPageName = StringDup( pProps[PROP_COVERPAGE_NAME].Value.LPSZ );
    FaxConfig->UseCoverPage = pProps[PROP_USE_COVERPAGE].Value.ul;
    FaxConfig->ServerCoverPage = pProps[PROP_SERVER_COVERPAGE].Value.ul;
    CopyMemory( &FaxConfig->FontStruct, pProps[PROP_FONT].Value.bin.lpb, pProps[PROP_FONT].Value.bin.cb );

    FaxConfig->ServerName = GetServerName(FaxConfig->PrinterName);
    FaxConfig->ServerCpOnly = FALSE;

//
// nice idea, but we need to postpone this till we actually open the dialog so
// we don't force the fax service to startup everytime we compose a message.
//
#if 0
    HANDLE hFax;
    PFAX_CONFIGURATION pFaxConfiguration;

    if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) ){
        if (FaxGetConfiguration(hFax,&pFaxConfiguration) ){
            FaxConfig->ServerCpOnly = pFaxConfiguration->ServerCp;
            FaxFreeBuffer(pFaxConfiguration);
        }
        FaxClose(hFax);
    }
#endif

exit:

    if (pSvcRows) {
        FreeProws( pSvcRows );
    }
    if (pProps) {
        MAPIFreeBuffer( pProps );
    }
    if (pProfileObj) {
        pProfileObj->Release();
    }
    if (ptblSvc) {
        ptblSvc->Release();
    }
    if (lpProviderAdmin) {
        lpProviderAdmin->Release();
    }
    if (lpServiceAdmin) {
        lpServiceAdmin->Release();
    }
    if (lpSession) {
        lpSession->Release();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    FUNCTION: ExchEntryPoint
//
//    Parameters - none
//
//    Purpose
//    The entry point which Exchange calls.
//
//    Return Value
//    Pointer to Exchange Extension Object
//
//    Comments
//    This is called for each context entry.  Create a new MyExchExt object
//    every time so each context will get its own MyExchExt interface.
//
LPEXCHEXT CALLBACK ExchEntryPoint(void)
{
    LPEXCHEXT pExt;
    __try {
        pExt = new MyExchExt;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pExt = NULL;
    }

    return pExt;

}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::MyExchExt()
//
//    Parameters - none
//
//    Purpose
//    Constructor. Initialize members and create supporting interface objects
//
//    Comments
//    Each context of Exchange gets its own set of interface objects.
//    Furthermore, interface objects per context are kept track of by Exchange
//    and the interface methods are called in the proper context.
//
MyExchExt::MyExchExt ()
{
    m_cRef = 1;
    m_context = 0;

    m_pExchExtCommands = new MyExchExtCommands;
    m_pExchExtUserEvents = new MyExchExtUserEvents;

    // in MyExchExtUserEvents methods I need a reference to MyExchExt
    m_pExchExtUserEvents->SetIExchExt( this );
}


///////////////////////////////////////////////////////////////////////////////
//  IExchExt virtual member functions implementation
//

///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Called by Exchage to request for interfaces
//
//    Return Value
//    S_OK  -- interface is supported and returned in ppvObj pointer
//    E_NOINTERFACE -- interface is not supported and ppvObj is NULL
//
//    Comments
//    Exchange client calls QueryInterface for each object.  Only
//    Need to support objects that apply to the extension.  QueryInterface
//    is called onces for each IID for each context.  We support two
//    contexts in this example so QueryInterface is called twice for
//    each IID.
//
STDMETHODIMP
MyExchExt::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if ( (IID_IUnknown == riid) || (IID_IExchExt == riid) ) {

        *ppvObj = (LPUNKNOWN) this;

    } else if ( IID_IExchExtCommands == riid) {

        if (!m_pExchExtCommands) {
            hr = E_UNEXPECTED;
        } else {
            *ppvObj = (LPUNKNOWN)m_pExchExtCommands;
            m_pExchExtCommands->SetContext( m_context );
        }

    } else if ( IID_IExchExtUserEvents == riid) {

        *ppvObj = (LPUNKNOWN)m_pExchExtUserEvents;
        m_pExchExtUserEvents->SetContext( m_context );

    } else {

        hr = E_NOINTERFACE;

    }

    if (NULL != *ppvObj) {
        ((LPUNKNOWN)*ppvObj)->AddRef();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::Install()
//
//    Parameters
//    peecb     -- pointer to Exchange Extension callback function
//    eecontext -- context code at time of being called.
//    ulFlags   -- flag to say if install is for modal or not
//
//    Purpose
//    Called once for each new contexted that is entered.  Proper version
//    number is checked here.
//
//    Return Value
//    S_OK -- object supported in the requested context
//    S_FALSE -- object is not supported in teh requested context
//
//    Comments
//
STDMETHODIMP
MyExchExt::Install(
    LPEXCHEXTCALLBACK pmecb,
    ULONG mecontext,
    ULONG ulFlags
    )
{
    ULONG ulBuildVersion;
    HRESULT hr;

    m_context = mecontext;

    // make sure this is the right version
    pmecb->GetVersion( &ulBuildVersion, EECBGV_GETBUILDVERSION );

    if (EECBGV_BUILDVERSION_MAJOR != (ulBuildVersion & EECBGV_BUILDVERSION_MAJOR_MASK)) {
        return S_FALSE;
    }

    switch (mecontext) {
        case EECONTEXT_SENDNOTEMESSAGE:
            hr = S_OK;
            break;

        default:
            hr = S_FALSE;
            break;
    }

    return hr;
}


MyExchExtCommands::MyExchExtCommands()
{
    m_cRef = 0;
    m_context = 0;
    m_cmdid = 0;
    m_itbb = 0;
    m_itbm = 0;
    m_hWnd = 0;
    m_hwndToolbar = NULL;
    memset(&FaxConfig,0,sizeof(FaxConfig));
}


MyExchExtCommands::~MyExchExtCommands()
{
    MemFree( FaxConfig.PrinterName );
    MemFree( FaxConfig.CoverPageName );
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Exchange Client does not call IExchExtCommands::QueryInterface().
//    So return nothing.
//
//    Return Value - none
//

STDMETHODIMP
MyExchExtCommands::QueryInterface(
    REFIID riid,
    LPVOID FAR * ppvObj
    )
{
    *ppvObj = NULL;
    if ( (riid == IID_IExchExtCommands) || (riid == IID_IUnknown) ) {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::InstallCommands()
//
//    Parameters
//    pmecb  -- Exchange Callback Interface
//    hWnd   -- window handle to main window of context
//    hMenu  -- menu handle to main menu of context
//    lptbeArray -- array of toolbar button entries
//    ctbe   -- count of button entries in array
//    ulFlags -- reserved
//
//    Purpose
//    This function is called when commands are installed for each context
//    the extension services.
//
//    Return Value
//    S_FALSE means the commands have been handled.
//
//    Comments
//    The hWnd and hMenu are in context.  If the context is for the SENDNOTE
//    dialog, then the hWnd is the window handle to the dialog and the hMenu is
//    the main menu of the dialog.
//
//    Call ResetToolbar so that Exchange will show it's toolbar
//


STDMETHODIMP
MyExchExtCommands::InstallCommands(
    LPEXCHEXTCALLBACK pmecb,
    HWND hWnd,
    HMENU hMenu,
    UINT FAR * pcmdidBase,
    LPTBENTRY lptbeArray,
    UINT ctbe,
    ULONG ulFlags
    )
{
    HRESULT hr = S_FALSE;
    TCHAR MenuItem[64];


    if (m_context == EECONTEXT_SENDNOTEMESSAGE) {

        int tbindx;
        HMENU hMenu;

        pmecb->GetMenuPos( EECMDID_ToolsCustomizeToolbar, &hMenu, NULL, NULL, 0 );
        AppendMenu( hMenu, MF_SEPARATOR, 0, NULL );
        LoadString( hInstance, IDS_FAX_ATTRIBUTES_MENU, MenuItem, 64);
        AppendMenu( hMenu, MF_BYPOSITION | MF_STRING, *pcmdidBase, MenuItem );

        m_hWnd = hWnd;
        m_cmdid = *pcmdidBase;
        (*pcmdidBase)++;

        for (tbindx = ctbe-1; (int) tbindx > -1; --tbindx) {
            if (lptbeArray[tbindx].tbid == EETBID_STANDARD) {
                m_hwndToolbar = lptbeArray[tbindx].hwnd;
                m_itbb = lptbeArray[tbindx].itbbBase++;
                break;
            }
        }

        if (m_hwndToolbar) {
            TBADDBITMAP tbab;

            tbab.hInst = hInstance;
            tbab.nID = IDB_EXTBTN;
            m_itbm = (INT)SendMessage( m_hwndToolbar, TB_ADDBITMAP, 1, (LPARAM)&tbab );

//            EnableMenuAndToolbar( pmecb, m_hwndToolbar, m_cmdid );
            ResetToolbar( EETBID_STANDARD, 0 );
        }
        GetFaxConfig( pmecb, &FaxConfig );
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::DoCommand()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//
//    Purpose7
//    This method is called by Exchange for each WM_COMMAND is sent to the
//    window in context.
//
//    Return Value
//    S_OK if command is handled
//    S_FALSE if command is not handled
//
//    Comments
//    Use this function to either respond to the command item (menu or toolbar)
//    added or modify an existing command in Exchange.  Return S_OK to let
//    Exchange know the command was handled.  Return S_OK on commands you are
//    taking over from Exchange.  Return S_FALSE to let Exchange know you want
//    it to carry out its command, even if you modify its action.
//

STDMETHODIMP
MyExchExtCommands::DoCommand(
    LPEXCHEXTCALLBACK pmecb,
    UINT cmdid
    )
{
    HRESULT hr = S_OK;
    HWND hwnd = NULL;
    INT_PTR Rslt;
    LPMESSAGE pMessage = NULL;
    LPMDB pMDB = NULL;
    LPSPropProblemArray lpProblems = NULL;
    SPropValue MsgProps[4];
    LPSPropTagArray MsgPropTags = NULL;
    MAPINAMEID NameIds[NUM_FAX_MSG_PROPS];
    MAPINAMEID *pNameIds[NUM_FAX_MSG_PROPS] = {&NameIds[0], &NameIds[1], &NameIds[2], &NameIds[3]};
    LPADRLIST AdrList = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;
    LPENTRYID EntryId = NULL;
    DWORD EntryIdSize;

    if (m_cmdid != cmdid) {
        return S_FALSE;
    }

    hr = pmecb->GetRecipients( &AdrList );
    if (FAILED(hr)) {
        goto exit;
    }

    if (AdrList) {
        for (i=0; i<AdrList->cEntries; i++) {
            EntryId = NULL;
            for (j=0; j<AdrList->aEntries[i].cValues; j++) {
                if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ENTRYID) {
                    EntryId = (LPENTRYID) AdrList->aEntries[i].rgPropVals[j].Value.bin.lpb;
                    EntryIdSize = AdrList->aEntries[i].rgPropVals[j].Value.bin.cb;
                } else
                if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ADDRTYPE) {
                    if (strcmp( AdrList->aEntries[i].rgPropVals[j].Value.LPSZ, "FAX" ) == 0) {
                        FaxAddress = TRUE;
                    } else
                    if ((strcmp( AdrList->aEntries[i].rgPropVals[j].Value.LPSZ, "MAPIPDL" ) == 0) && (EntryId)) {
                        FaxAddress = VerifyDistributionList( pmecb, EntryIdSize, EntryId );
                    }
                }
            }
        }
    }

    hr = pmecb->GetWindow( &hwnd );
    if (FAILED(hr)) {
        goto exit;
    }

    if (!FaxAddress) {
        TCHAR CaptionString[1024];
        TCHAR MessageString[1024];

        LoadString( hInstance, IDS_MSGBOXCAPTION, &CaptionString[0], 1024 );
        LoadString( hInstance, IDS_NOFAXADDR, &MessageString[0], 1024 );

        Rslt = MessageBox( hwnd, MessageString, CaptionString, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL );
        goto exit;
    }

    Rslt = DialogBoxParam(
        hInstance,
        MAKEINTRESOURCE(FAX_CONFIG_DIALOG),
        hwnd,
        ConfigDlgProc,
        (LPARAM) &FaxConfig
        );
    if (Rslt == IDOK) {

        hr = pmecb->GetObject( &pMDB, (LPMAPIPROP *) &pMessage );
        if (FAILED(hr)) {
            goto exit;
        }

        NameIds[MSGPI_FAX_PRINTER_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_PRINTER_NAME].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_PRINTER_NAME].Kind.lpwstrName = MSGPS_FAX_PRINTER_NAME;

        NameIds[MSGPI_FAX_COVERPAGE_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_COVERPAGE_NAME].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_COVERPAGE_NAME].Kind.lpwstrName = MSGPS_FAX_COVERPAGE_NAME;

        NameIds[MSGPI_FAX_USE_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_USE_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_USE_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_USE_COVERPAGE;

        NameIds[MSGPI_FAX_SERVER_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_SERVER_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_SERVER_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_SERVER_COVERPAGE;

        hr = pMessage->GetIDsFromNames( NUM_FAX_MSG_PROPS, pNameIds, MAPI_CREATE, &MsgPropTags );
        if (FAILED(hr)) {
            goto exit;
        }

        MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME] = PROP_TAG( PT_TSTRING, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME] = PROP_TAG( PT_TSTRING, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE]) );

        MsgProps[MSGPI_FAX_PRINTER_NAME].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME];
        MsgProps[MSGPI_FAX_COVERPAGE_NAME].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME];
        MsgProps[MSGPI_FAX_USE_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE];
        MsgProps[MSGPI_FAX_SERVER_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE];

        MsgProps[MSGPI_FAX_PRINTER_NAME].Value.LPSZ = FaxConfig.PrinterName;
        MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.LPSZ = FaxConfig.CoverPageName;
        MsgProps[MSGPI_FAX_USE_COVERPAGE].Value.ul   = FaxConfig.UseCoverPage;
        MsgProps[MSGPI_FAX_SERVER_COVERPAGE].Value.ul   = FaxConfig.ServerCoverPage;

        hr = pMessage->SetProps( NUM_FAX_MSG_PROPS, MsgProps, &lpProblems );
        if (FAILED(hr)) {
            goto exit;
        }
        if (lpProblems) {
            hr = MAPI_E_NOT_FOUND;
            goto exit;
        }

    }

exit:

    if (AdrList) {
        MemFree( AdrList );
    }
    if (MsgPropTags) {
        MemFree( MsgPropTags );
    }
    if (lpProblems) {
        MemFree( lpProblems );
    }
    if (pMessage) {
        pMessage->Release();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::InitMenu()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//
//    Purpose
//    This method is called by Exchange when the menu of context is about to
//    be activated.  See WM_INITMENU in the Windows API Reference for more
//    information.
//
//    Return Value - none
//

STDMETHODIMP_(VOID)
MyExchExtCommands::InitMenu(
    LPEXCHEXTCALLBACK pmecb
    )
{
    return;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::Help()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//    cmdid -- command id
//
//    Purpose
//    Respond when user presses F1 while custom menu item is selected.
//
//    Return Value
//    S_OK -- recognized the command and provided help
//    S_FALSE -- not our command and we didn't provide help
//

STDMETHODIMP MyExchExtCommands::Help(
    LPEXCHEXTCALLBACK pmecb,
    UINT cmdid
    )
{
    return S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryHelpText()
//
//    Parameters
//    cmdid -- command id corresponding to menu item activated
//    ulFlags -- identifies either EECQHT_STATUS or EECQHT_TOOLTIP
//    psz -- pointer to buffer to be populated with text to display
//    cch -- count of characters available in psz buffer
//
//    Purpose
//    Exchange calls this function each time it requires to update the status
//    bar text or if it is to display a tooltip on the toolbar.
//
//    Return Value
//    S_OK to indicate our command was handled
//    S_FALSE to tell Exchange it can continue with its function
//

STDMETHODIMP
MyExchExtCommands::QueryHelpText(
    UINT cmdid,
    ULONG ulFlags,
    LPTSTR psz,
    UINT cch
    )
{
    HRESULT hr;
    TCHAR HelpText[64];

    LoadString(hInstance,IDS_FAX_ATTRIBUTES_TOOLTIP,HelpText,64);

    if (cmdid == m_cmdid) {
        if (ulFlags == EECQHT_STATUS) {
            lstrcpyn( psz, HelpText, cch );
        }

        if (ulFlags == EECQHT_TOOLTIP) {
            lstrcpyn( psz, HelpText, cch );
        }

        hr = S_OK;
    } else {
        hr = S_FALSE;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryButtonInfo()
//
//    Parameters
//    tbid    -- toolbar identifier
//    itbb    -- toolbar button index
//    ptbb    -- pointer to toolbar button structure -- see TBBUTTON structure
//    lpsz    -- point to string describing button
//    cch     -- maximum size of lpsz buffer
//    ulFlags -- EXCHEXT_UNICODE may be specified
//
//    Purpose
//    For Exchange to find out about toolbar button information.
//
//    Return Value
//    S_FALSE - not our button
//    S_OK    - we filled information about our button
//
//    Comments
//    Called for every button installed for toolbars when IExchExtCommands
//    is installed for each context. The lpsz text is used when the Customize
//    Toolbar dialog is displayed.  The text will be displayed next to the
//    button.
//

STDMETHODIMP MyExchExtCommands::QueryButtonInfo(
    ULONG tbid,
    UINT itbb,
    LPTBBUTTON ptbb,
    LPTSTR lpsz,
    UINT cch,
    ULONG ulFlags
    )
{
    HRESULT hr = S_FALSE;
    TCHAR CustText[64];

    LoadString(hInstance,IDS_FAX_ATTRIBUTES_CUST,CustText,64);

    if (m_itbb == itbb) {
        ptbb->iBitmap = m_itbm;
        ptbb->idCommand = m_cmdid;
        ptbb->fsState = TBSTATE_ENABLED;
        ptbb->fsStyle = TBSTYLE_BUTTON;
        ptbb->dwData = 0;
        ptbb->iString = -1;
        lstrcpyn( lpsz, CustText , cch );
        hr = S_OK;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::ResetToolbar()
//
//    Parameters
//    tbid
//    ulFlags
//
//    Purpose
//
//    Return Value  S_OK always
//
STDMETHODIMP
MyExchExtCommands::ResetToolbar(
    ULONG tbid,
    ULONG ulFlags
    )
{
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//  IExchExtUserEvents virtual member functions implementation
//

///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Exchange Client does not call IExchExtUserEvents::QueryInterface().
//    So return nothing.
//
//    Return Value - none
//

STDMETHODIMP
MyExchExtUserEvents::QueryInterface(
    REFIID riid,
    LPVOID FAR * ppvObj
    )
{
    *ppvObj = NULL;
    if (( riid == IID_IExchExtUserEvents) || (riid == IID_IUnknown) ) {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::OnSelectionChange()
//
//    Parameters
//    pmecb  -- pointer to Exchange Callback Object
//
//
//    Purpose
//    This function is called when the selection in the UI is changed.
//
//    Return Value - none
//
//    Comments
//    OnSelectionChange is called whenever the selection changes either within
//    a pane or is changed between panes.
//

STDMETHODIMP_(VOID)
MyExchExtUserEvents::OnSelectionChange(
    LPEXCHEXTCALLBACK pmecb
    )
{
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::OnObjectChange()
//
//    Parameters
//    pmecb  -- pointer to Exchange Callback Object
//
//
//    Purpose
//    This function is called when the selection in the UI is to a different
//    of object on the left pane.
//
//    Return Value - none
//
//    Comments
//    OnObjectChange is called whenever the selection is changed between
//    objects in the left pane only.  Change in selection between folders,
//    subfolders or container object in the left pane will be reflected with a
//    call to OnObjectChange.  Change in selection between objects (messages,
//    subfolders) in the right pane will not call OnObjectChange, only
//    OnSelectionChange.
//

STDMETHODIMP_(VOID)
MyExchExtUserEvents::OnObjectChange(
    LPEXCHEXTCALLBACK pmecb
    )
{
}




LPSTR
GetServerName(
    LPSTR PrinterName
    )

/*++

Routine Description:

    retrieve the servername given a printer name

Arguments:

    PrinterName - Identifies the printer in question
    

Return Value:

    Pointer to a string, NULL if there is an error

--*/
{
    PPRINTER_INFO_2 PrinterInfo = NULL;
    LPSTR ServerName = NULL;

    if (!PrinterName) {
        goto exit;
    }

    if (!(PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter(PrinterName,2))) {
        goto exit;
    }

    if (PrinterInfo->pServerName) {
        ServerName = StringDup(PrinterInfo->pServerName);
    }
    

exit:
    if (PrinterInfo) {
        MemFree(PrinterInfo);
    }    

    return ServerName;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ext\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This module contains utility routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxext.h"


//
// globals
//

BOOL oleInitialized;

LPSTR Platforms[] =
{
    "Windows NT x86",
    "Windows NT R4000",
    "Windows NT Alpha_AXP",
    "Windows NT PowerPC"
};



LPVOID
MapiMemAlloc(
    DWORD Size
    )

/*++

Routine Description:

    Memory allocator.

Arguments:

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID ptr;
    HRESULT hResult;

    hResult = MAPIAllocateBuffer( Size, &ptr );
    if (hResult) {
        ptr = NULL;
    } else {
        ZeroMemory( ptr, Size );
    }

    return ptr;
}


VOID
MapiMemFree(
    LPVOID ptr
    )

/*++

Routine Description:

    Memory de-allocator.

Arguments:

    ptr     - Pointer to the memory block.

Return Value:

    None.

--*/

{
    if (ptr) {
        MAPIFreeBuffer( ptr );
    }
}


PVOID
MyGetPrinter(
    LPSTR   PrinterName,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    HANDLE hPrinter;
    PBYTE pPrinterInfo = NULL;
    DWORD cbNeeded;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {
        return NULL;
    }

    if (!GetPrinter( hPrinter, level, NULL, 0, &cbNeeded ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = (PBYTE) MemAlloc( cbNeeded )) &&
        GetPrinter( hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded ))
    {
        ClosePrinter( hPrinter );
        return pPrinterInfo;
    }

    ClosePrinter( hPrinter );
    MemFree( pPrinterInfo );
    return NULL;
}


LPSTR
RemoveLastNode(
    LPTSTR Path
    )

/*++

Routine Description:

    Removes the last node from a path string.

Arguments:

    Path    - Path string.

Return Value:

    Pointer to the path string.

--*/

{
    DWORD i;

    if (Path == NULL || Path[0] == 0) {
        return Path;
    }

    i = strlen(Path)-1;
    if (Path[i] == '\\') {
        Path[i] = 0;
        i -= 1;
    }

    for (; i>0; i--) {
        if (Path[i] == '\\') {
            Path[i+1] = 0;
            break;
        }
    }

    return Path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\ext\faxext.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxext.h

Abstract:

    Fax exchange client extension header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#ifndef _FAXEXT_H_
#define _FAXEXT_H_

#include <windows.h>
#include <winspool.h>
#include <mapiwin.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapicode.h>
#include <mapival.h>
#include <mapiwz.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapiform.h>
#include <mapiguid.h>
#include <richedit.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <exchext.h>
#include <tapi.h>
#include <tchar.h>
#include <stdio.h>
#include <winfax.h>

#include "resource.h"
#include "faxmapip.h"
#include "faxreg.h"
#include "faxutil.h"

#define FAXUTIL_DEBUG
#define FAXUTIL_MEM
#define FAXUTIL_STRING
#define FAXUTIL_SUITE
#define FAXUTIL_REG
#include <faxutil.h>


#define FAX_DRIVER_NAME                     "Windows NT Fax Driver"
#define LNK_FILENAME_EXT                    ".lnk"
#define CP_FILENAME_EXT                     ".cov"
#define MAX_FILENAME_EXT                    4
#define CPFLAG_LINK                         0x0100



LPVOID
MapiMemAlloc(
    DWORD Size
    );

VOID
MapiMemFree(
    LPVOID ptr
    );

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    );

PVOID
MyGetPrinter(
    LPSTR   PrinterName,
    DWORD   level
    );

LPSTR
GetServerName(
    LPSTR   PrinterName
    );


class MyExchExt;
class MyExchExtCommands;
class MyExchExtUserEvents;

extern "C"
{
    LPEXCHEXT CALLBACK ExchEntryPoint(void);
}

class MyExchExt : public IExchExt
{

 public:
    MyExchExt ();
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                    () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                    () { ULONG ulCount = --m_cRef;
                         if (!ulCount) { delete this; }
                         return ulCount;};
    STDMETHODIMP Install (LPEXCHEXTCALLBACK pmecb,
                        ULONG mecontext, ULONG ulFlags);


 private:
    ULONG m_cRef;
    UINT  m_context;

    MyExchExtUserEvents * m_pExchExtUserEvents;
    MyExchExtCommands * m_pExchExtCommands;
};

class MyExchExtCommands : public IExchExtCommands
{
 public:
    MyExchExtCommands();
    ~MyExchExtCommands();
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                    () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                    () { ULONG ulCount = --m_cRef;
                         if (!ulCount) { delete this; }
                         return ulCount;};
    STDMETHODIMP InstallCommands(LPEXCHEXTCALLBACK pmecb,
                                HWND hwnd, HMENU hmenu,
                                UINT FAR * cmdidBase, LPTBENTRY lptbeArray,
                                UINT ctbe, ULONG ulFlags);
    STDMETHODIMP DoCommand(LPEXCHEXTCALLBACK pmecb, UINT mni);
    STDMETHODIMP_(VOID) InitMenu(LPEXCHEXTCALLBACK pmecb);
    STDMETHODIMP Help(LPEXCHEXTCALLBACK pmecb, UINT mni);
    STDMETHODIMP QueryHelpText(UINT mni, ULONG ulFlags, LPTSTR sz, UINT cch);
    STDMETHODIMP QueryButtonInfo(ULONG tbid, UINT itbb, LPTBBUTTON ptbb,
                                LPTSTR lpsz, UINT cch, ULONG ulFlags);
    STDMETHODIMP ResetToolbar(ULONG tbid, ULONG ulFlags);

    inline VOID SetContext
                (ULONG eecontext) { m_context = eecontext; };
    inline UINT GetCmdID() { return m_cmdid; };

    inline HWND GetToolbarHWND() { return m_hwndToolbar; }

 private:
    ULONG m_cRef;          //
    ULONG m_context;       //
    UINT  m_cmdid;         // cmdid for menu extension command
    UINT  m_itbb;          // toolbar index
    HWND  m_hwndToolbar;   // toolbar window handle
    UINT  m_itbm;          //
    HWND  m_hWnd;          //
    FAXXP_CONFIG FaxConfig;
};


class MyExchExtUserEvents : public IExchExtUserEvents
{
 public:
    MyExchExtUserEvents() { m_cRef = 0; m_context = 0;
                            m_pExchExt = NULL; };
    STDMETHODIMP QueryInterface
                (REFIID                     riid,
                 LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                () { ULONG ulCount = --m_cRef;
                     if (!ulCount) { delete this; }
                     return ulCount;};

    STDMETHODIMP_(VOID) OnSelectionChange(LPEXCHEXTCALLBACK pmecb);
    STDMETHODIMP_(VOID) OnObjectChange(LPEXCHEXTCALLBACK pmecb);

    inline VOID SetContext
                (ULONG eecontext) { m_context = eecontext; };
    inline VOID SetIExchExt
                (MyExchExt * pExchExt) { m_pExchExt = pExchExt; };

 private:
    ULONG m_cRef;
    ULONG m_context;

    MyExchExt * m_pExchExt;

};

#endif // _FAXEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\gwinst\gwsetup.c ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>

#include "dapi.h"


DWORD SyntaxData[] =
{
    0x80000002,    //
    0x0000001c,    // emit the proxy prefix
    0x00000002,    //
    0x6701001E,    // emit the fax address
    0x80000002,    //
    0x00000024,    // emit the proxy suffix
    0x00000000,    // HALT
    '[XAF',        //
    '\0\0\0\0',    //
    '\0]\0\0'      //
};

DWORD AddressData[] =
{
    0x00000001, 0x00000006, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000008, 0x00000000,
    0x00000000, 0x00000000, 0x000000E0, 0x00000007,
    0x0000003C, 0x0000000C, 0x0000000C, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x000000F2,
    0x00000047, 0x000000A0, 0x0000000C, 0x0000000C,
    0x00000001, 0x00000006, 0x3001001E, 0x00000100,
    0x00000112, 0x00000007, 0x0000003C, 0x0000001E,
    0x0000000C, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000116, 0x00000047, 0x000000A0,
    0x0000001E, 0x0000000C, 0x00000001, 0x00000002,
    0x6701001E, 0x00000050, 0x00000134, 0x0000000C,
    0x0000003C, 0x00000064, 0x0000000C, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x0000013A,
    0x00650047, 0x0065006E, 0x00610072, 0x0020006C,
    0x00260000, 0x00690044, 0x00700073, 0x0061006C,
    0x00200079, 0x0061004E, 0x0065006D, 0x0020003A,
    0x002A0000, 0x00260000, 0x00610046, 0x00200078,
    0x00640041, 0x00720064, 0x00730065, 0x003A0073,
    0x00000020, 0x0020002A, 0x00000000
};




VOID
AddValue(
    PATT_VALUE Value,
    DAPI_DATA_TYPE DataType,
    LPBYTE DataValue,
    DWORD DataSize
    )
{
    Value->DapiType          = DataType;
    Value->Value.lpBinary    = (LPBYTE) DataValue;
    Value->size              = DataSize;
    Value->pNextValue        = NULL;
}


VOID
AddStringValue(
    PATT_VALUE Value,
    LPSTR String
    )
{
    AddValue(
        Value,
        DAPI_STRING8,
        String,
        strlen(String)
        );
}


VOID
AddBinaryValue(
    PATT_VALUE Value,
    LPBYTE BinaryData,
    DWORD BinaryDataSize
    )
{
    AddValue(
        Value,
        DAPI_BINARY,
        BinaryData,
        BinaryDataSize
        );
}



int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    DAPI_PARMS  dp;
    DAPI_HANDLE dh;
    PDAPI_EVENT de;
    DAPI_ENTRY  enA;
    ATT_VALUE   vlA[32];
    DAPI_ENTRY  enV;
    ATT_VALUE   vlV[32];
    CHAR        BasePoint[128];



    sprintf( BasePoint, "/O=%s/OU=%s/cn=Configuration/cn=Addressing/cn=Address-Templates/cn=409", argv[1], argv[2] );

    dp.dwDAPISignature      = DAPI_SIGNATURE;
    dp.dwFlags              = 0;
    dp.pszDSAName           = NULL;
    dp.pszBasePoint         = BasePoint;
    dp.pszContainer         = NULL;
    dp.pszNTDomain          = NULL;
    dp.pszCreateTemplate    = NULL;
    dp.pAttributes          = NULL;

    de = DAPIStart( &dh, &dp );
    if (de) {
        printf( "could not start DAPI\n" );
        return -1;
    }

    enA.unAttributes        = 3;
    enA.ulEvalTag           = VALUE_ARRAY;
    enA.rgEntryValues       = vlA;

    AddStringValue( &vlA[0], "Obj-Class"   );
    AddStringValue( &vlA[1], "Mode"        );
    AddStringValue( &vlA[2], "Common-Name" );

    enV.unAttributes        = 3;
    enV.ulEvalTag           = VALUE_ARRAY;
    enV.rgEntryValues       = vlV;

    AddStringValue( &vlV[0], "Address-Template" );
    AddStringValue( &vlV[1], "Update"           );
    AddStringValue( &vlV[2], "FAX"              );

    de = DAPIWrite( dh, DAPI_WRITE_UPDATE, &enA, &enV, NULL, NULL, NULL );
    if (de) {
        printf( "could not write to DAPI #1\n" );
        return -1;
    }

    enA.unAttributes        = 7;
    enA.ulEvalTag           = VALUE_ARRAY;
    enA.rgEntryValues       = vlA;

    AddStringValue( &vlA[0], "Obj-Class"                   );
    AddStringValue( &vlA[1], "Mode"                        );
    AddStringValue( &vlA[2], "Admin-Display-Name"          );
    AddStringValue( &vlA[3], "Common-Name"                 );
    AddStringValue( &vlA[4], "Address-Type"                );
    AddStringValue( &vlA[5], "Address-Syntax"              );
    AddStringValue( &vlA[6], "Address-Entry-Display-Table" );

    enV.unAttributes        = 7;
    enV.ulEvalTag           = VALUE_ARRAY;
    enV.rgEntryValues       = vlV;

    AddStringValue( &vlV[0], "Address-Template"                        );
    AddStringValue( &vlV[1], "Update"                                  );
    AddStringValue( &vlV[2], "Fax Address"                             );
    AddStringValue( &vlV[3], "FAX"                                     );
    AddStringValue( &vlV[4], "FAX"                                     );
    AddBinaryValue( &vlV[5], (LPBYTE) SyntaxData,  sizeof(SyntaxData)  );
    AddBinaryValue( &vlV[6], (LPBYTE) AddressData, sizeof(AddressData) );

    de = DAPIWrite( dh, DAPI_WRITE_UPDATE, &enA, &enV, NULL, NULL, NULL );
    if (de) {
        printf( "could not write to DAPI #2\n" );
        return -1;
    }

    DAPIEnd( dh );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\inc\faxmapip.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxmapi.h

Abstract:

    Contains common fax mapi stuff.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

//
// 4.0;D:\nt\private\fax\faxext32\obj\i386\faxext32.dll;1;00000100000000
//
// \registry\machine\software\microsoft\exchange\client\extensions
//     FaxExtensions = 4.0;d:\winnt\system32\faxext32.dll;1;00000100000000
//

#define FAX_XP_GUID { 0x61, 0x85, 0x0a, 0x80, 0x0a, 0x47, 0x11, 0xd0, 0x88, 0x77, 0x0, 0xa0, 0x4, 0xff, 0x31, 0x28 }

#define MSGPS_FAX_PRINTER_NAME              L"FAX_PRINTER_NAME"
#define MSGPS_FAX_COVERPAGE_NAME            L"FAX_COVERPAGE_NAME"
#define MSGPS_FAX_USE_COVERPAGE             L"FAX_USE_COVERPAGE"
#define MSGPS_FAX_SERVER_COVERPAGE          L"FAX_SERVER_COVERPAGE"

#define NUM_FAX_MSG_PROPS                   4

#define MSGPI_FAX_PRINTER_NAME              0
#define MSGPI_FAX_COVERPAGE_NAME            1
#define MSGPI_FAX_USE_COVERPAGE             2
#define MSGPI_FAX_SERVER_COVERPAGE          3

#define BASE_PROVIDER_ID                    0x6600

#define NUM_FAX_PROPERTIES                  5

#define PROP_FAX_PRINTER_NAME               0
#define PROP_USE_COVERPAGE                  1
#define PROP_COVERPAGE_NAME                 2
#define PROP_SERVER_COVERPAGE               3
#define PROP_FONT                           4


#define PR_FAX_PRINTER_NAME                 PROP_TAG( PT_TSTRING, (BASE_PROVIDER_ID + PROP_FAX_PRINTER_NAME) )
#define PR_USE_COVERPAGE                    PROP_TAG( PT_LONG,    (BASE_PROVIDER_ID + PROP_USE_COVERPAGE)    )
#define PR_COVERPAGE_NAME                   PROP_TAG( PT_TSTRING, (BASE_PROVIDER_ID + PROP_COVERPAGE_NAME)   )
#define PR_SERVER_COVERPAGE                 PROP_TAG( PT_LONG,    (BASE_PROVIDER_ID + PROP_SERVER_COVERPAGE) )
#define PR_FONT                             PROP_TAG( PT_BINARY,  (BASE_PROVIDER_ID + PROP_FONT)             )


typedef struct _FAXXP_CONFIG {
    LPSTR   PrinterName;
    LPSTR   CoverPageName;
    BOOL    UseCoverPage;
    BOOL    ServerCoverPage;
    LPSTR   ServerName;
    BOOL    ServerCpOnly;
    LOGFONT FontStruct;
} FAXXP_CONFIG, *PFAXXP_CONFIG;


const static SizedSPropTagArray( NUM_FAX_PROPERTIES, sptFaxProps ) =
{
    NUM_FAX_PROPERTIES,
    {
        PR_FAX_PRINTER_NAME,
        PR_USE_COVERPAGE,
        PR_COVERPAGE_NAME,
        PR_SERVER_COVERPAGE,
        PR_FONT
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\resource.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Fax transport provider resource header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/


#define IDS_NO_FAX_PRINTER             101
#define IDS_CANT_ACCESS_PRINTER        102
#define IDS_RESOURCES_UNAVAIL          103
#define IDS_CANT_PRINT                 104
#define IDS_CANT_ACCESS_MSG_DATA       105
#define IDS_CANT_ACCESS_PROFILE        106
#define IDS_BAD_ATTACHMENTS            107
#define IDS_FONT_REGULAR               108
#define IDS_FONT_ITALIC                109
#define IDS_FONT_BOLD                  110
#define IDS_PERSONAL                   111
#define IDS_FAX_MESSAGE                112

#define IDC_STATIC                      -1
#define IDC_PRINTER_LIST               201
#define IDC_USE_COVERPAGE              202
#define IDC_COVERPAGE_LIST             203
#define IDC_SET_FONT                   204
#define IDC_FONT_NAME                  205
#define IDC_FONT_STYLE                 206
#define IDC_FONT_SIZE                  207
#define IDCSTATIC_FONT                 208
#define IDCSTATIC_FONTSTYLE            209
#define IDCSTATIC_FONTSIZE             210
#define IDC_COVERPAGE_LIST_LABEL       211
#define IDCSTATIC_FONT_GROUP           212
#define IDC_STATIC_ICON                213
#define IDC_STATIC_TITLE               214
#define IDC_STATIC_PRINTERS            215

#define FAX_CONFIG_DIALOG              501

#define IDI_FAX                        601
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\faxdoc.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxdoc.cpp

Abstract:

    This module contains all code necessary to print an
    exchange message as a fax document.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#pragma hdrstop


#ifdef WIN95
#include "mfx.h"
#include "fwprov.h"
#endif


PVOID
CXPLogon::MyGetPrinter(
    LPSTR PrinterName,
    DWORD Level
    )

/*++

Routine Description:

    Gets the printer data for a specifi printer

Arguments:

    PrinterName - Name of the desired printer

Return Value:

    Pointer to a printer info structure or NULL for failure.

--*/

{
    PVOID PrinterInfo = NULL;
    HANDLE hPrinter;
    DWORD Bytes;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {
        goto exit;
    }

    if ((!GetPrinter( hPrinter, Level, NULL, 0, &Bytes )) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        goto exit;
    }

    PrinterInfo = (LPPRINTER_INFO_2) MemAlloc( Bytes );
    if (!PrinterInfo) {
        goto exit;
    }

    if (!GetPrinter( hPrinter, Level, (LPBYTE) PrinterInfo, Bytes, &Bytes )) {
        goto exit;
    }

exit:
    ClosePrinter( hPrinter );
    return PrinterInfo;
}


VOID
CXPLogon::PrintRichText(
    HWND hWndRichEdit,
    HDC hDC,
    PFAXXP_CONFIG FaxConfig
    )

/*++

Routine Description:

    Prints the rich text contained in a rich text
    window into a DC.

Arguments:

    hWndRichEdit    - Window handle for the rich text window
    hDC             - Printer device context

Return Value:

    None.

--*/

{
    FORMATRANGE fr;
    LONG lTextOut;
    LONG lTextAmt;
    RECT rcTmp;

    LPTSTR  szText;
    LPTSTR  szChar;

    fr.hdc           = hDC;
    fr.hdcTarget     = hDC;
    fr.chrg.cpMin    = 0;
    fr.chrg.cpMax    = -1;

    //
    // Set page rect to phys page size in twips
    //
    fr.rcPage.top    = 0;
    fr.rcPage.left   = 0;
    fr.rcPage.right  = MulDiv(GetDeviceCaps(hDC, PHYSICALWIDTH),
                              1440,
                              GetDeviceCaps(hDC, LOGPIXELSX));
    fr.rcPage.bottom = MulDiv(GetDeviceCaps(hDC, PHYSICALHEIGHT),
                              1440,
                              GetDeviceCaps(hDC, LOGPIXELSY));

    //
    // Set up 3/4" horizontal and 1" vertical margins, but leave a minimum of 1"
    // printable space in each direction.  Otherwise, use full page.
    //
    fr.rc = fr.rcPage; // start with full page
    if (fr.rcPage.right > 2*3*1440/4 + 1440) {
        fr.rc.right -= (fr.rc.left = 3*1440/4);
    }
    if (fr.rcPage.bottom > 3*1440) {
        fr.rc.bottom -= (fr.rc.top = 1440);
    }

    //
    // save the formatting rectangle
    //
    rcTmp = fr.rc;

    SetMapMode( hDC, MM_TEXT );

    lTextOut = 0;
    lTextAmt = (LONG)SendMessage( hWndRichEdit, WM_GETTEXTLENGTH, 0, 0 );

    szText = (LPTSTR) MemAlloc((lTextAmt + 1) * sizeof(TCHAR));
    if (szText) {
        SendMessage(hWndRichEdit, WM_GETTEXT, (WPARAM) lTextAmt, (LPARAM) szText);

        szChar = szText;
        while (lTextOut < lTextAmt) {
            if ((*szChar != ' ') && (*szChar != '\t') && (*szChar != '\r') && (*szChar != '\n')) {
                break;
            }

            lTextOut++;
            szChar = CharNext(szChar);
        }

        MemFree(szText);

        if (!strlen(szChar)) {
            lTextAmt = 0;
        }
    }

    while (lTextOut < lTextAmt) {
        // Reset margins
        fr.rc = rcTmp;
        StartPage(hDC);
        lTextOut = (LONG) SendMessage(hWndRichEdit, EM_FORMATRANGE, TRUE, (LPARAM) &fr);
        EndPage(hDC);

        fr.chrg.cpMin = lTextOut;
        fr.chrg.cpMax = -1;
    }

    //
    // flush the cache
    //
    SendMessage(hWndRichEdit, EM_FORMATRANGE, TRUE, (LPARAM) NULL);
}


extern "C"
DWORD CALLBACK
EditStreamRead(
    DWORD_PTR dwCookie,
    LPBYTE pbBuff,
    LONG cb,
    LONG *pcb
    )

/*++

Routine Description:

    Wrapper function for the IStream read method.
    This function is used to read rich text from
    an exchange stream.

Arguments:

    dwCookie    - This pointer for the IStream object
    pbBuff      - Pointer to the data buffer
    cb          - Size of the data buffer
    pcb         - Returned byte count

Return Value:

    Return code from IStream::Read

--*/

{
    return ((LPSTREAM)dwCookie)->Read( pbBuff, cb, (ULONG*) pcb );
}


BOOL
CXPLogon::PrintText(
    HDC hDC,
    LPSTREAM lpstmT,
    PFAXXP_CONFIG FaxConfig
    )

/*++

Routine Description:

    Prints a stream of plain text into the printer DC provided.
    Note: this code was stolen from notepad.

Arguments:

    hDC         - Printer DC
    lpstmT      - Stream pointer for rich text.
    FaxConfig   - Fax configuration data

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    LPSTR BodyText = NULL;
    LPSTR lpLine;
    LPSTR pLineEOL;
    LPSTR pNextLine;
    HRESULT hResult;
    HFONT hFont = NULL;
    HFONT hPrevFont = NULL;
    TEXTMETRIC tm;
    BOOL rVal = TRUE;
    INT nLinesPerPage;
    INT dyTop;              // width of top border (pixels)
    INT dyBottom;           // width of bottom border
    INT dxLeft;             // width of left border
    INT dxRight;            // width of right border
    INT yPrintChar;         // height of a character
    INT tabSize;            // Size of a tab for print device in device units
    INT yCurpos = 0;
    INT xCurpos = 0;
    INT nPixelsLeft = 0;
    INT guess = 0;
    SIZE Size;                 // to see if text will fit in space left
    INT nPrintedLines = 0;
    BOOL fPageStarted = FALSE;
    INT iPageNum = 0;
    INT xPrintRes;          // printer resolution in x direction
    INT yPrintRes;          // printer resolution in y direction
    INT yPixInch;           // pixels/inch
    INT xPixInch;           // pixels/inch
    INT xPixUnit;           // pixels/local measurement unit
    INT yPixUnit;           // pixels/local measurement unit
    BOOL fEnglish;
    INT Chars;
    STATSTG Stats;
    INT PrevBkMode = 0;



    hResult = lpstmT->Stat( &Stats, 0 );
    if (hResult) {
        rVal = FALSE;
        goto exit;
    }

    Chars = (INT) Stats.cbSize.QuadPart;
    BodyText = (LPSTR) MemAlloc( Chars + 4 );
    if (!BodyText) {
        rVal = FALSE;
        goto exit;
    }

    hResult = lpstmT->Read( (LPVOID) BodyText, Chars, (LPDWORD) &Chars );
    if (hResult) {
        rVal = FALSE;
        goto exit;
    }

    lpLine = BodyText;

    fEnglish = GetProfileInt( "intl", "iMeasure", 1 );

    xPrintRes = GetDeviceCaps( hDC, HORZRES );
    yPrintRes = GetDeviceCaps( hDC, VERTRES );
    xPixInch  = GetDeviceCaps( hDC, LOGPIXELSX );
    yPixInch  = GetDeviceCaps( hDC, LOGPIXELSY );
    //
    // compute x and y pixels per local measurement unit
    //
    if (fEnglish) {
        xPixUnit= xPixInch;
        yPixUnit= yPixInch;
    } else {
        xPixUnit= CMToInches( xPixInch );
        yPixUnit= CMToInches( yPixInch );
    }

    SetMapMode( hDC, MM_TEXT );

    hFont = CreateFontIndirect( &FaxConfig->FontStruct );

    hPrevFont = (HFONT) SelectObject( hDC, hFont );
    SetBkMode( hDC, TRANSPARENT );
    if (!GetTextMetrics( hDC, &tm )) {
        rVal = FALSE;
        goto exit;
    }

    yPrintChar = tm.tmHeight + tm.tmExternalLeading;
    tabSize = tm.tmAveCharWidth * 8;

    //
    // compute margins in pixels
    //
    dxLeft     = LEFT_MARGIN    *  xPixUnit;
    dxRight    = RIGHT_MARGIN   *  xPixUnit;
    dyTop      = TOP_MARGIN     *  yPixUnit;
    dyBottom   = BOTTOM_MARGIN  *  yPixUnit;

    //
    // Number of lines on a page with margins
    //
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    while (*lpLine) {

        if (*lpLine == '\r') {
            lpLine += 2;
            yCurpos += yPrintChar;
            nPrintedLines++;
            xCurpos= 0;
            continue;
        }

        pLineEOL = lpLine;
        while (*pLineEOL && *pLineEOL != '\r') pLineEOL++;

        do {
            if ((nPrintedLines == 0) && (!fPageStarted)) {

                StartPage( hDC );
                fPageStarted = TRUE;
                yCurpos = 0;
                xCurpos = 0;

            }

            if (*lpLine == '\t') {

                //
                // round up to the next tab stop
                // if the current position is on the tabstop, goto next one
                //
                xCurpos = ((xCurpos + tabSize) / tabSize ) * tabSize;
                lpLine++;

            } else {

                //
                // find end of line or tab
                //
                pNextLine = lpLine;
                while ((pNextLine != pLineEOL) && *pNextLine != '\t') pNextLine++;

                //
                // find out how many characters will fit on line
                //
                Chars = (INT)(pNextLine - lpLine);
                nPixelsLeft = xPrintRes - dxRight - dxLeft - xCurpos;
                GetTextExtentExPoint( hDC, lpLine, Chars, nPixelsLeft, &guess, NULL, &Size );


                if (guess) {
                    //
                    // at least one character fits - print
                    //

                    TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, guess );

                    xCurpos += Size.cx;   // account for printing
                    lpLine  += guess;     // printed characters

                } else {

                    //
                    // no characters fit what's left
                    // no characters will fit in space left
                    // if none ever will, just print one
                    // character to keep progressing through
                    // input file.
                    //
                    if (xCurpos == 0) {
                        if( lpLine != pNextLine ) {
                            //
                            // print something if not null line
                            // could use exttextout here to clip
                            //
                            TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, 1 );
                            lpLine++;
                        }
                    } else {
                        //
                        // perhaps the next line will get it
                        //
                        xCurpos = xPrintRes;  // force to next line
                    }
                }

                //
                // move printhead in y-direction
                //
                if ((xCurpos >= (xPrintRes - dxRight - dxLeft) ) || (lpLine == pLineEOL)) {
                   yCurpos += yPrintChar;
                   nPrintedLines++;
                   xCurpos = 0;
                }

                if (nPrintedLines >= nLinesPerPage) {
                   EndPage( hDC );
                   fPageStarted = FALSE;
                   nPrintedLines = 0;
                   xCurpos = 0;
                   yCurpos = 0;
                   iPageNum++;
                }

            }

        } while( lpLine != pLineEOL );

        if (*lpLine == '\r') {
            lpLine += 1;
        }
        if (*lpLine == '\n') {
            lpLine += 1;
        }

    }

    if (fPageStarted) {
        EndPage( hDC );
    }

exit:
    MemFree( BodyText );
    if (hPrevFont) {
        SelectObject( hDC, hPrevFont );
        DeleteObject( hFont );
    }
    if (PrevBkMode) {
        SetBkMode( hDC, PrevBkMode );
    }
    return rVal;
}


DWORD
CXPLogon::PrintAttachment(
    LPSTR FaxPrinterName,
    LPSTR DocName
    )

/*++

Routine Description:

    Prints a document that is attached to a message

Arguments:

    FaxPrinterName  - name of the printer to print the attachment on
    DocName         - name of the attachment document

Return Value:

    Print job id or zero for failure.

--*/

{
    SHELLEXECUTEINFO sei;
    CHAR Args[MAX_PATH];
    CHAR TempDir[MAX_PATH];
    HANDLE hMap = NULL;
    HANDLE hEvent = NULL;
    HANDLE hMutex = NULL;
    HANDLE hMutexAttach = NULL;
    LPDWORD pJobId = NULL;
    DWORD JobId = 0;

#ifndef WIN95
    SECURITY_ATTRIBUTES memsa,mutsa,synsa,eventsa;
    SECURITY_DESCRIPTOR memsd,mutsd,synsd,eventsd;
#endif

    //
    // serialize access to this function.
    // this is necessary because we can't have more than one
    // app accessing our shared memory region and mutex
    //

    hMutexAttach = OpenMutex(MUTEX_ALL_ACCESS,FALSE,FAXRENDER_MUTEX);
    if (!hMutexAttach) {
        //
        // we need to open this mutex with a NULL dacl so that everyone can access this
        //
        #ifndef WIN95
        synsa.nLength = sizeof(SECURITY_ATTRIBUTES);
        synsa.bInheritHandle = TRUE;
        synsa.lpSecurityDescriptor = &synsd;

        if(!InitializeSecurityDescriptor(&synsd, SECURITY_DESCRIPTOR_REVISION)) {
            goto exit;
        }

        if(!SetSecurityDescriptorDacl(&synsd, TRUE, (PACL)NULL, FALSE)) {
            goto exit;
        }
        #endif

        hMutexAttach = CreateMutex(
                        #ifndef WIN95
                         &synsa,
                        #else
                         NULL,
                        #endif
                         TRUE,
                         FAXRENDER_MUTEX
                        );

        if (!hMutexAttach) {
            goto exit;
        }
    } else {
        if (WaitForSingleObject( hMutexAttach, 1000* 60 * 5) != WAIT_OBJECT_0) {
            //
            // something went wrong
            //
            CloseHandle( hMutexAttach );
            goto exit;
        }
    }


    //
    //  since mapispooler might be running under a different security context,
    //  we must setup a NULL security descriptor
    //

#ifndef WIN95
    memsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    memsa.bInheritHandle = TRUE;
    memsa.lpSecurityDescriptor = &memsd;

    if(!InitializeSecurityDescriptor(&memsd, SECURITY_DESCRIPTOR_REVISION)) {
        goto exit;
    }

    if(!SetSecurityDescriptorDacl(&memsd, TRUE, (PACL)NULL, FALSE)) {
        goto exit;
    }

    mutsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    mutsa.bInheritHandle = TRUE;
    mutsa.lpSecurityDescriptor = &mutsd;

    if(!InitializeSecurityDescriptor(&mutsd, SECURITY_DESCRIPTOR_REVISION)) {
        goto exit;
    }

    if(!SetSecurityDescriptorDacl(&mutsd, TRUE, (PACL)NULL, FALSE)) {
        goto exit;
    }

    eventsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    eventsa.bInheritHandle = TRUE;
    eventsa.lpSecurityDescriptor = &eventsd;

    if(!InitializeSecurityDescriptor(&eventsd, SECURITY_DESCRIPTOR_REVISION)) {
        goto exit;
    }

    if(!SetSecurityDescriptorDacl(&eventsd, TRUE, (PACL)NULL, FALSE)) {
        goto exit;
    }
#endif



    //
    // create the shared memory region for the print jobid
    // the jobid is filled in by the fax printer driver
    //

    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
#ifndef WIN95
        &memsa,
#else
        NULL,
#endif
        PAGE_READWRITE | SEC_COMMIT,
        0,
        4096,
        FAXXP_MEM_NAME
        );
    if (!hMap) {
        goto exit;
    }

    pJobId = (LPDWORD) MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!pJobId) {
        goto exit;
    }

    *pJobId = (DWORD) 0;

    //
    // get the temp path name and use it for the
    // working dir of the launched app
    //

    GetTempPath( sizeof(TempDir), TempDir );

    //
    // set the arguments to the app.
    // these arguments are either passed on
    // the command line with the /pt switch or
    // use as variables for substitution in the
    // ddeexec value in the registry.
    //
    // the values are as follows:
    //      %1 = file name
    //      %2 = printer name
    //      %3 = driver name
    //      %4 = port name
    //
    // the first argument does not need to be
    // supplied in the args array because it is implied,
    // shellexecuteex gets it from the lpFile field.
    // arguments 3 & 4 are left blank because they
    // are win31 artifacts that are not necessary
    // any more.  each argument must be enclosed
    // in double quotes.
    //

    wsprintf( Args, "\"%s\" \"\" \"\"", FaxPrinterName );

    //
    // fill in the SHELLEXECUTEINFO structure
    //

    sei.cbSize       = sizeof(sei);
    sei.fMask        = SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT;
    sei.hwnd         = NULL;
    sei.lpVerb       = "printto";
    sei.lpFile       = DocName;
    sei.lpParameters = Args;
    sei.lpDirectory  = TempDir;
    sei.nShow        = SW_SHOWMINNOACTIVE;
    sei.hInstApp     = NULL;
    sei.lpIDList     = NULL;
    sei.lpClass      = NULL;
    sei.hkeyClass    = NULL;
    sei.dwHotKey     = 0;
    sei.hIcon        = NULL;
    sei.hProcess     = NULL;


    //
    // create the named mutex for the print driver.
    // this is initially unclaimed, and is claimed by the first instance
    // of the print driver invoked after this. We do this last in order to
    // avoid a situation where we catch the incorrect instance of the print driver
    // printing
    //
    hMutex = CreateMutex(
#ifndef WIN95
                         &mutsa,
#else
                         NULL,
#endif
                         FALSE,
                         FAXXP_MUTEX_NAME
                        );
    if (!hMutex) {
        goto exit;
    }

    //
    // create the named event for the print driver.
    // this event is signaled when the print driver is finished rendering the document
    //
    hEvent = CreateEvent(
#ifndef WIN95
                         &eventsa,
#else
                         NULL,
#endif
                         FALSE,
                         FALSE,
                         FAXXP_EVENT_NAME
                        );
    if (!hEvent) {
        goto exit;
    }

    //
    // launch the app
    //

    if (!ShellExecuteEx( &sei )) {
        goto exit;
    }

    //
    // wait for the print driver to finish rendering the document
    //
    if (WaitForSingleObject( hEvent, 1000 * 60 * 5 ) != WAIT_OBJECT_0) {
        //
        // something went wrong...
        //
        goto exit;
    }

    //
    // wait for the print driver to exit so we can get the document
    //
    if (WaitForSingleObject( hMutex, 1000 * 60 * 5) != WAIT_OBJECT_0) {
        //
        // something went wrong
        //
        goto exit;
    }

    ReleaseMutex(hMutex);

    //
    // save the print jobid
    //

    JobId = *pJobId;

exit:
    //
    // clean up and leave...
    //

    if (sei.hProcess) CloseHandle( sei.hProcess );
    if (hEvent) CloseHandle( hEvent );
    if (hMutex) CloseHandle( hMutex );
    if (pJobId) UnmapViewOfFile( pJobId );
    if (hMap) CloseHandle( hMap );

    if (hMutexAttach) {
        ReleaseMutex( hMutexAttach );
        CloseHandle( hMutexAttach );
    }

    return JobId;
}


DWORD
CXPLogon::SendFaxDocument(
    LPMESSAGE pMsgObj,
    LPSTREAM lpstmT,
    BOOL UseRichText,
    LPSPropValue pMsgProps,
    LPSPropValue pRecipProps
    )

/*++

Routine Description:

    Prints an exchange message to the fax printer.

Arguments:

    lpstmT      - Stream pointer for rich text.
    pMsgProps   - Message properties.
    pRecipProps - Recipient properties.

Return Value:

    Zero for success, otherwise error code.

--*/

{
    PPRINTER_INFO_2 PrinterInfo = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter = NULL;
    HDC hDC = NULL;
    INT JobId;
    DWORD Bytes;
    DWORD ec;
    DWORD rVal = 0;
    HRESULT hResult;
    LPSTREAM lpstm = NULL;
    EDITSTREAM es = {0};
    HWND hWndRichEdit = NULL;
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    ULONG PropMsgCount = 0;
    LPSPropValue pPropsAttachTable = NULL;
    LPSPropValue pPropsAttach = NULL;
    LPSPropValue pProps = NULL;
    LPSPropValue pPropsMsg = NULL;
    FAXXP_CONFIG FaxConfig = {0};
    DWORD JobIdAttachment = 0;
    INT i = 0;
    LPMAPITABLE AttachmentTable = NULL;
    LPSRowSet pAttachmentRows = NULL;
    LPATTACH lpAttach = NULL;
    LPSTREAM lpstmA = NULL;
    LPSTR AttachFileName = NULL;
    CHAR TempPath[MAX_PATH];
    CHAR TempFile[MAX_PATH];
    CHAR DocFile[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPSTR DocType = NULL;
    DWORD LastJobId = 0;
    PJOB_INFO_1 JobInfo1 = NULL;
    JOB_INFO_3 JobInfo3;
    LPSTR p;
    DWORD Pages = 0;
    BOOL DeleteAttachFile;
    LPSTR FileName = NULL;
    BOOL AllAttachmentsGood = TRUE;
    MAPINAMEID NameIds[NUM_FAX_MSG_PROPS];
    MAPINAMEID *pNameIds[NUM_FAX_MSG_PROPS] = {&NameIds[0], &NameIds[1], &NameIds[2], &NameIds[3]};
    LPSPropTagArray MsgPropTags = NULL;
    LARGE_INTEGER BigZero = {0};
    CHAR FullName[128];
    HKEY hKey;
    DWORD RegSize;
    DWORD RegType;
    DWORD CountPrinters;
#ifdef WIN95
    LCID      LocaleId;
    LPSTR     lpszBuffer;
    DWORD     BytesWrite;
    HINSTANCE hinstFwProv;
    PFWSPJ    pfnStartPrintJob;
#else
    USER_INFO UserInfo = {0};
    FAX_PRINT_INFOA FaxPrintInfo = {0};
    FAX_CONTEXT_INFO ContextInfo = {0};
    FAX_COVERPAGE_INFOA FaxCpInfo = {0};

//    char szCoverPageName[MAX_PATH];
#endif   // WIN95


    //
    // get the fax config properties
    //
    hResult = m_pSupObj->OpenProfileSection(
        &FaxGuid,
        MAPI_MODIFY,
        &pProfileObj
        );
    if (HR_FAILED (hResult)) {
        rVal = IDS_CANT_ACCESS_PROFILE;
        goto exit;
    }

    hResult = pProfileObj->GetProps(
        (LPSPropTagArray) &sptFaxProps,
        0,
        &PropCount,
        &pProps
        );
    if (FAILED(hResult)) {
        rVal = IDS_CANT_ACCESS_PROFILE;
        goto exit;
    }

    FaxConfig.PrinterName      = StringDup( pProps[PROP_FAX_PRINTER_NAME].Value.LPSZ );
    FaxConfig.CoverPageName    = StringDup( pProps[PROP_COVERPAGE_NAME].Value.LPSZ );
    FaxConfig.UseCoverPage     = pProps[PROP_USE_COVERPAGE].Value.ul;
    FaxConfig.ServerCoverPage  = pProps[PROP_SERVER_COVERPAGE].Value.ul;
    CopyMemory( &FaxConfig.FontStruct, pProps[PROP_FONT].Value.bin.lpb, pProps[PROP_FONT].Value.bin.cb );

    //
    // now get the message properties
    //

    NameIds[MSGPI_FAX_PRINTER_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_PRINTER_NAME].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_PRINTER_NAME].Kind.lpwstrName = MSGPS_FAX_PRINTER_NAME;

    NameIds[MSGPI_FAX_COVERPAGE_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_COVERPAGE_NAME].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_COVERPAGE_NAME].Kind.lpwstrName = MSGPS_FAX_COVERPAGE_NAME;

    NameIds[MSGPI_FAX_USE_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_USE_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_USE_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_USE_COVERPAGE;

    NameIds[MSGPI_FAX_SERVER_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_SERVER_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_SERVER_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_SERVER_COVERPAGE;

    hResult = pMsgObj->GetIDsFromNames( NUM_FAX_MSG_PROPS, pNameIds, MAPI_CREATE, &MsgPropTags );
    if (FAILED(hResult)) {
        rVal = IDS_CANT_ACCESS_PROFILE;
        goto exit;
    }

    MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME] = PROP_TAG( PT_TSTRING, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME]) );
    MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME] = PROP_TAG( PT_TSTRING, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME]) );
    MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE]) );
    MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE]) );

    hResult = pMsgObj->GetProps( MsgPropTags, 0, &PropMsgCount, &pPropsMsg );
    if (FAILED(hResult)) {
        rVal = IDS_CANT_ACCESS_PROFILE;
        goto exit;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_PRINTER_NAME].ulPropTag) != PT_ERROR) {
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = StringDup( pPropsMsg[MSGPI_FAX_PRINTER_NAME].Value.LPSZ );
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_COVERPAGE_NAME].ulPropTag) != PT_ERROR) {
        MemFree( FaxConfig.CoverPageName );
        FaxConfig.CoverPageName = StringDup( pPropsMsg[MSGPI_FAX_COVERPAGE_NAME].Value.LPSZ );
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_USE_COVERPAGE].ulPropTag) != PT_ERROR) {
        FaxConfig.UseCoverPage = pPropsMsg[MSGPI_FAX_USE_COVERPAGE].Value.ul;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_SERVER_COVERPAGE].ulPropTag) != PT_ERROR) {
        FaxConfig.ServerCoverPage = pPropsMsg[MSGPI_FAX_SERVER_COVERPAGE].Value.ul;
    }

    //
    // open the printer
    //

    PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig.PrinterName, 2 );
    if (!PrinterInfo) {
        PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
        if (PrinterInfo) {
            for (i=0; i<(int)CountPrinters; i++) {
                if (strcmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                    break;
                }
            }
        } else {
            CountPrinters = i = 0;
        }
        if (i == (int)CountPrinters) {
            rVal = IDS_NO_FAX_PRINTER;
            goto exit;
        }

        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = StringDup( PrinterInfo[i].pPrinterName );
        MemFree( PrinterInfo );
        PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig.PrinterName, 2 );
        if (!PrinterInfo) {
            rVal = IDS_CANT_ACCESS_PROFILE;
            goto exit;
        }
    }

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( FaxConfig.PrinterName, &hPrinter, &PrinterDefaults )) {
        rVal = IDS_CANT_ACCESS_PRINTER;
        goto exit;
    }

    //
    // get the attachment table, if it is available
    //

    hResult = pMsgObj->GetAttachmentTable( 0, &AttachmentTable );
    if (HR_SUCCEEDED(hResult)) {
        hResult = HrAddColumns(
            AttachmentTable,
            (LPSPropTagArray) &sptAttachTableProps,
            gpfnAllocateBuffer,
            gpfnFreeBuffer
            );
        if (HR_SUCCEEDED(hResult)) {
            hResult = HrQueryAllRows(
                AttachmentTable,
                NULL,
                NULL,
                NULL,
                0,
                &pAttachmentRows
                );
            if (FAILED(hResult)) {
                pAttachmentRows = NULL;
            } else {
                if (pAttachmentRows->cRows == 0) {
                    MemFree( pAttachmentRows );
                    pAttachmentRows = NULL;
                }
            }
        }
    }

    if (pAttachmentRows) {

        //
        // this loop verifies that each document's attachment registration
        // supports the printto verb.
        //

        AllAttachmentsGood = TRUE;

        for (i=pAttachmentRows->cRows-1; i>=0; i--) {

            pPropsAttachTable = pAttachmentRows->aRow[i].lpProps;
            lpAttach = NULL;
            pPropsAttach = NULL;

            if (pPropsAttachTable[MSG_ATTACH_METHOD].Value.ul == NO_ATTACHMENT) {
                goto next_attachment1;
            }

            //
            // open the attachment
            //

            hResult = pMsgObj->OpenAttach( pPropsAttachTable[MSG_ATTACH_NUM].Value.ul, NULL, MAPI_BEST_ACCESS, &lpAttach );
            if (FAILED(hResult)) {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            //
            // get the attachment properties
            //

            hResult = lpAttach->GetProps(
                (LPSPropTagArray) &sptAttachProps,
                0,
                &PropCount,
                &pPropsAttach
                );
            if (FAILED(hResult)) {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            //
            // try to get the extension if the file.
            // this indicates what type of dicument it is.
            // if we cannot get the document type then it is
            // impossible to print the document.
            //

            if (DocType) {
                MemFree( DocType );
                DocType = NULL;
            }

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_EXTENSION].ulPropTag) == PT_ERROR) {
                if (PROP_TYPE(pPropsAttach[MSG_ATTACH_LFILENAME].ulPropTag) != PT_ERROR) {
                    p = strchr( pPropsAttach[MSG_ATTACH_LFILENAME].Value.LPSZ, '.' );
                    if (p) {
                        DocType = StringDup( p );
                    }
                } else if (PROP_TYPE(pPropsAttach[MSG_ATTACH_FILENAME].ulPropTag) != PT_ERROR) {
                    p = strchr( pPropsAttach[MSG_ATTACH_FILENAME].Value.LPSZ, '.' );
                    if (p) {
                        DocType = StringDup( p );
                    }
                }

            } else {
                DocType = StringDup( pPropsAttach[MSG_ATTACH_EXTENSION].Value.LPSZ );
            }

            if (!DocType) {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            Bytes = sizeof(TempFile);
            rVal = RegQueryValue( HKEY_CLASSES_ROOT, DocType, TempFile, (PLONG) &Bytes );
            if ((rVal != ERROR_SUCCESS) && (rVal != ERROR_INVALID_DATA)) {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            wsprintf( TempPath, "%s\\shell\\printto\\command", TempFile );

            Bytes = sizeof(TempFile);
            rVal = RegQueryValue( HKEY_CLASSES_ROOT, TempPath, TempFile, (PLONG) &Bytes );
            if ((rVal != ERROR_SUCCESS) && (rVal != ERROR_INVALID_DATA)) {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }
next_attachment1:

            if (lpAttach) {
                lpAttach->Release();
            }

            if (pPropsAttach) {
                MemFree( pPropsAttach );
            }

        }

        if (!AllAttachmentsGood) {
            rVal = IDS_BAD_ATTACHMENTS;
            goto exit;
        }

        for (i=pAttachmentRows->cRows-1; i>=0; i--) {

            pPropsAttachTable = pAttachmentRows->aRow[i].lpProps;
            lpAttach = NULL;
            pPropsAttach = NULL;

            if (pPropsAttachTable[MSG_ATTACH_METHOD].Value.ul == NO_ATTACHMENT) {
                goto next_attachment2;
            }

            //
            // open the attachment
            //

            hResult = pMsgObj->OpenAttach( pPropsAttachTable[MSG_ATTACH_NUM].Value.ul, NULL, MAPI_BEST_ACCESS, &lpAttach );
            if (FAILED(hResult)) {
                goto next_attachment2;
            }

            //
            // get the attachment properties
            //

            hResult = lpAttach->GetProps(
                (LPSPropTagArray) &sptAttachProps,
                0,
                &PropCount,
                &pPropsAttach
                );
            if (FAILED(hResult)) {
                goto next_attachment2;
            }

            //
            // try to get the extension if the file.
            // this indicates what type of dicument it is.
            // if we cannot get the document type then it is
            // impossible to print the document.
            //

            if (DocType) {
                MemFree( DocType );
                DocType = NULL;
            }

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_EXTENSION].ulPropTag) == PT_ERROR) {
                if (PROP_TYPE(pPropsAttach[MSG_ATTACH_LFILENAME].ulPropTag) != PT_ERROR) {
                    p = strchr( pPropsAttach[MSG_ATTACH_LFILENAME].Value.LPSZ, '.' );
                    if (p) {
                        DocType = StringDup( p );
                    }
                } else if (PROP_TYPE(pPropsAttach[MSG_ATTACH_FILENAME].ulPropTag) != PT_ERROR) {
                    p = strchr( pPropsAttach[MSG_ATTACH_FILENAME].Value.LPSZ, '.' );
                    if (p) {
                        DocType = StringDup( p );
                    }
                }
            } else {
                DocType = StringDup( pPropsAttach[MSG_ATTACH_EXTENSION].Value.LPSZ );
            }

            if (!DocType) {
                goto next_attachment2;
            }

            lpstmA = NULL;
            AttachFileName = NULL;
            DeleteAttachFile = FALSE;

            //
            // get the attached file name so that we can resolve any links
            //

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_PATHNAME].ulPropTag) != PT_ERROR) {
                FileName = pPropsAttach[MSG_ATTACH_PATHNAME].Value.LPSZ;
            } else {
                FileName = NULL;
            }

            if (_stricmp( DocType, LNK_FILENAME_EXT ) == 0) {
                if (!FileName) {
                    goto next_attachment2;
                }
                if (ResolveShortcut( FileName, DocFile )) {
                    p = strchr( DocFile, '.' );
                    if (p) {
                        MemFree( DocType );
                        DocType = StringDup( p );
                        AttachFileName = StringDup( DocFile );
                    }
                }
            } else if (FileName) {
                AttachFileName = StringDup( FileName );
            }

            //
            // get the stream object
            //

            switch( pPropsAttach[MSG_ATTACH_METHOD].Value.ul ) {

                case ATTACH_BY_VALUE:
                    hResult = lpAttach->OpenProperty(
                        PR_ATTACH_DATA_BIN,
                        &IID_IStream,
                        0,
                        0,
                        (LPUNKNOWN*) &lpstmA
                        );
                    if (FAILED(hResult)) {
                        goto next_attachment2;
                    }
                    break;

                case ATTACH_EMBEDDED_MSG:
                case ATTACH_OLE:
                    hResult = lpAttach->OpenProperty(
                        PR_ATTACH_DATA_OBJ,
                        &IID_IStreamDocfile,
                        0,
                        0,
                        (LPUNKNOWN*) &lpstmA
                        );
                    if (FAILED(hResult)) {
                        hResult = lpAttach->OpenProperty(
                            PR_ATTACH_DATA_BIN,
                            &IID_IStreamDocfile,
                            0,
                            0,
                            (LPUNKNOWN*) &lpstmA
                            );
                        if (FAILED(hResult)) {
                            hResult = lpAttach->OpenProperty(
                                PR_ATTACH_DATA_OBJ,
                                &IID_IStorage,
                                0,
                                0,
                                (LPUNKNOWN*) &lpstmA
                                );
                            if (FAILED(hResult)) {
                                goto next_attachment2;
                            }
                        }
                    }
                    break;

            }

            if (lpstmA) {

                GetTempPath( sizeof(TempPath), TempPath );
                GetTempFileName( TempPath, "Fax", 0, TempFile );
                hFile = CreateFile(
                    TempFile,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL
                    );
                if (hFile != INVALID_HANDLE_VALUE) {

                    #define BLOCK_SIZE (64*1024)
                    LPBYTE StrmData;
                    DWORD Bytes;
                    DWORD BytesWrite;

                    StrmData = (LPBYTE) MemAlloc( BLOCK_SIZE );

                    do {

                        hResult = lpstmA->Read( StrmData, BLOCK_SIZE, &Bytes );
                        if (FAILED(hResult)) {
                            break;
                        }

                        WriteFile( hFile, StrmData, Bytes, &BytesWrite, NULL );

                    } while (Bytes == BLOCK_SIZE);

                    CloseHandle( hFile );
                    MemFree( StrmData );

                    if (AttachFileName) {
                        MemFree( AttachFileName );
                    }

                    strcpy( DocFile, TempFile );
                    p = strchr( DocFile, '.' );
                    if (p) {
                        strcpy( p, DocType );
                        MoveFile( TempFile, DocFile );
                        AttachFileName = StringDup( DocFile );
                    } else {
                        AttachFileName = StringDup( TempFile );
                    }

                    DeleteAttachFile = TRUE;

                }

                lpstmA->Release();

            }

            if (AttachFileName) {

                //
                // print the attachment
                //

                JobIdAttachment = PrintAttachment( FaxConfig.PrinterName, AttachFileName );
                if (JobIdAttachment) {

                    GetJob( hPrinter, JobIdAttachment, 1, NULL, 0, &Bytes );
                    JobInfo1 = (PJOB_INFO_1) MemAlloc( Bytes );
                    if (JobInfo1) {
                        if (GetJob( hPrinter, JobIdAttachment, 1, (LPBYTE) JobInfo1, Bytes, &Bytes )) {
                            Pages += JobInfo1->TotalPages;
                        }
                        MemFree( JobInfo1 );
                    }

                    if (LastJobId) {
                        JobInfo3.JobId = JobIdAttachment;
                        JobInfo3.NextJobId = LastJobId;
                        JobInfo3.Reserved = 0;
                        SetJob( hPrinter, JobIdAttachment, 3, (PBYTE) &JobInfo3, 0 );
                        SetJob( hPrinter, LastJobId, 0, NULL, JOB_CONTROL_RESUME );
                    }

                    LastJobId = JobIdAttachment;
                }

                if (DeleteAttachFile) {
                    DeleteFile( AttachFileName );
                }

                MemFree( AttachFileName );

            }
next_attachment2:

            if (lpAttach) {
                lpAttach->Release();
            }

            if (pPropsAttach) {
                MemFree( pPropsAttach );
            }

        }

    }

    FullName[0] = 0;

    ec = RegOpenKey(
        HKEY_CURRENT_USER,
        REGKEY_FAX_USERINFO,
        &hKey
        );
    if (ec == ERROR_SUCCESS) {

        RegSize = sizeof(FullName);

        ec = RegQueryValueEx(
            hKey,
            REGVAL_FULLNAME,
            0,
            &RegType,
            (LPBYTE) FullName,
            &RegSize
            );

        RegCloseKey( hKey );
    }

#ifdef WIN95

    JobId     = 0xffffffff;

    //
    // allocate FaxInfo structure
    //

    FaxInfo Fax_Info;
    memset( &Fax_Info, 0, sizeof(FaxInfo) );

    //
    // provide recipient-specific information
    //

    strncpy(
        Fax_Info.Recipients[0].szName,
        pRecipProps[RECIP_NAME].Value.lpszA,
        NAME_LEN + 1
        );

    strncpy(
        Fax_Info.Recipients[0].szFaxNumber,
        pRecipProps[RECIP_EMAIL_ADR].Value.lpszA,
        PHONE_NUMBER_LEN
        );

    Fax_Info.nRecipientCount = 1;

    //
    // provide cover page information
    //

    Fax_Info.bSendCoverPage = FaxConfig.UseCoverPage;

    if (Fax_Info.bSendCoverPage) {
        Fax_Info.bLocalCoverPage  = ! FaxConfig.ServerCoverPage;
        strncpy( Fax_Info.szCoverPage, FaxConfig.CoverPageName, MAX_PATH );
        strcat( Fax_Info.szCoverPage, ".cov" );
    }

    strncpy( Fax_Info.szSubject, pMsgProps[MSG_SUBJECT].Value.lpszA, SUBJECT_LEN+1 );

    //
    // formatted date/time
    //

    LocaleId   = LOCALE_USER_DEFAULT;
    lpszBuffer = Fax_Info.szTimeSent;
    Bytes      = sizeof( Fax_Info.szTimeSent );
    BytesWrite = GetDateFormat( LocaleId, 0x0000,  NULL, NULL, lpszBuffer, Bytes );

    if (BytesWrite == 0) {
        rVal = GetLastError();
        goto exit;
    } else if (BytesWrite >= Bytes) {
        rVal = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    } else {
        Bytes -= BytesWrite;
    }

    strcat( lpszBuffer, " " );
    Bytes -= 1;
    lpszBuffer = &lpszBuffer[strlen(lpszBuffer)];

    if (Bytes == 0) {
        rVal = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }

    BytesWrite = GetTimeFormat( LocaleId, 0x0000,  NULL, NULL, lpszBuffer, Bytes );

    if (BytesWrite == 0) {
        rVal = GetLastError();
        goto exit;
    } else if ( BytesWrite >= Bytes ) {
        rVal = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }

    //
    // Get system code page and other sender info not grabbed from the INI file
    //

    Fax_Info.CodePage = GetACP();

    //
    // provide sender-specific information to fax driver
    //

    hinstFwProv = LoadLibrary( "fwprov.dll" );

    if (!hinstFwProv) {
        rVal = GetLastError();
        goto exit;
    }

    //
    // initiate fax print job
    //

    pfnStartPrintJob = (PFWSPJ)GetProcAddress( hinstFwProv, "fwStartPrintJob" );

    if (!pfnStartPrintJob) {
        rVal = GetLastError();
        goto exit;
    }

    if (!pfnStartPrintJob( FaxConfig.PrinterName, &Fax_Info, (PDWORD)&JobId, &hDC )) {
        rVal = GetLastError();
        goto exit;
    }

    //
    // done with fwprov.dll
    //

    if (hinstFwProv) {
        FreeLibrary( hinstFwProv );
    }

#else
    GetUserInfo( FaxConfig.PrinterName, &UserInfo );

    TCHAR DocName[64];
    LoadString(FaxXphInstance,IDS_FAX_MESSAGE,DocName,sizeof(DocName)/sizeof(TCHAR));

    FaxPrintInfo.SizeOfStruct       = sizeof(FAX_PRINT_INFOA);
    FaxPrintInfo.DocName            = DocName;
    FaxPrintInfo.RecipientName      = pRecipProps[RECIP_NAME].Value.lpszA;
    FaxPrintInfo.RecipientNumber    = pRecipProps[RECIP_EMAIL_ADR].Value.lpszA;
    FaxPrintInfo.SenderName         = FullName;
    FaxPrintInfo.SenderCompany      = UserInfo.Company;
    FaxPrintInfo.SenderDept         = UserInfo.Dept;
    FaxPrintInfo.SenderBillingCode  = UserInfo.BillingCode;
    JobId                           = 0xffffffff;

    if (PrinterInfo->Attributes & PRINTER_ATTRIBUTE_LOCAL) {
        FaxPrintInfo.DrProfileName  = m_ProfileName;
        FaxPrintInfo.DrEmailAddress = NULL;
    } else {
        FaxPrintInfo.DrEmailAddress = m_ProfileName;
        FaxPrintInfo.DrProfileName  = NULL;
    }

    ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW);

    ec = FaxStartPrintJob(
        FaxConfig.PrinterName,
        &FaxPrintInfo,
        (LPDWORD) &JobId,
        &ContextInfo
        );
    if (!ec) {
        rVal= GetLastError();
        goto exit;
    }

    if (FaxConfig.UseCoverPage) {

        FaxCpInfo.SizeOfStruct          = sizeof(FAX_COVERPAGE_INFOA);
        FaxCpInfo.CoverPageName         = FaxConfig.CoverPageName;
        FaxCpInfo.UseServerCoverPage    = FaxConfig.ServerCoverPage;
        FaxCpInfo.RecName               = pRecipProps[RECIP_NAME].Value.lpszA;
        FaxCpInfo.RecFaxNumber          = pRecipProps[RECIP_EMAIL_ADR].Value.lpszA;
        FaxCpInfo.Subject               = pMsgProps[MSG_SUBJECT].Value.lpszA;
        FaxCpInfo.Note                  = NULL;
        FaxCpInfo.PageCount             = Pages + 2;

        GetLocalTime( &FaxCpInfo.TimeSent );

        ec = FaxPrintCoverPage(
            &ContextInfo,
            &FaxCpInfo
            );
        if (!ec) {
            rVal= GetLastError();
            goto exit;
        }
    } else if (strlen(pMsgProps[MSG_SUBJECT].Value.lpszA) && !lpstmT) {
        //
        // HACK: try to use the "basenote.cov" coverpage so that we at least print something.
        // if they just entered in a subject but no note, then nothing will be printed
        //
        TCHAR CoverpageName[MAX_PATH];
        ExpandEnvironmentStrings(TEXT("%systemroot%\\system32\\basenote.cov"),CoverpageName,sizeof(CoverpageName));
        FaxCpInfo.SizeOfStruct          = sizeof(FAX_COVERPAGE_INFOA);
        FaxCpInfo.CoverPageName         = CoverpageName;
        FaxCpInfo.UseServerCoverPage    = FALSE;
        FaxCpInfo.RecName               = pRecipProps[RECIP_NAME].Value.lpszA;
        FaxCpInfo.RecFaxNumber          = pRecipProps[RECIP_EMAIL_ADR].Value.lpszA;
        FaxCpInfo.Subject               = pMsgProps[MSG_SUBJECT].Value.lpszA;
        FaxCpInfo.Note                  = NULL;
        FaxCpInfo.PageCount             = Pages + 2;

        GetLocalTime( &FaxCpInfo.TimeSent );

        ec = FaxPrintCoverPage(
            &ContextInfo,
            &FaxCpInfo
            );
        //
        // don't bail if this fails, it's a hack anyway
        //
        /*if (!ec) {
            rVal= GetLastError();
            goto exit;
        } */
    }
#endif

    if (lpstmT) {

        //
        // position the stream to the beginning
        //

        hResult = lpstmT->Seek( BigZero, STREAM_SEEK_SET, NULL );
        if (HR_FAILED (hResult)) {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }

        if (UseRichText) {

            hResult = WrapCompressedRTFStream( lpstmT, 0, &lpstm );
            if (HR_FAILED (hResult)) {
                rVal = IDS_CANT_ACCESS_MSG_DATA;
                goto exit;
            }

            //
            // print the document
            //

            hWndRichEdit = CreateWindowEx(
               WS_OVERLAPPED,
               "RICHEDIT",
               "",
               ES_MULTILINE,
               0, 0,
               0, 0,
               NULL,
               NULL,
               FaxXphInstance,
               NULL
               );
            if (!hWndRichEdit) {
                ec = GetLastError();
                rVal = IDS_CANT_ACCESS_MSG_DATA;
                goto exit;
            }

            es.pfnCallback = EditStreamRead;
            es.dwCookie = (DWORD_PTR) lpstm;

            SendMessage(
                hWndRichEdit,
                EM_STREAMIN,
                SF_RTF | SFF_SELECTION | SFF_PLAINRTF,
                (LPARAM) &es
                );

            if (es.dwError) {
                ec = es.dwError;
                rVal = IDS_CANT_ACCESS_MSG_DATA;
                goto exit;
            }

#ifdef WIN95
            PrintRichText( hWndRichEdit, hDC, &FaxConfig );
#else
            PrintRichText( hWndRichEdit, ContextInfo.hDC, &FaxConfig );
#endif

        } else {

#ifdef WIN95
            PrintText( hDC, lpstmT, &FaxConfig );
#else
            PrintText( ContextInfo.hDC, lpstmT, &FaxConfig );
#endif


        }
    }

    if (LastJobId) {
        //
        // chain the main body job to the first
        // attachment job and resume the attachment job
        //

        JobInfo3.JobId     = JobId;
        JobInfo3.NextJobId = LastJobId;
        JobInfo3.Reserved  = 0;

        if (!SetJob( hPrinter, JobId, 3, (PBYTE) &JobInfo3, 0 )) {
            DebugPrint(( "SetJob() failed, ec=%d", GetLastError() ));
        }

        if (!SetJob( hPrinter, LastJobId, 0, NULL, JOB_CONTROL_RESUME )) {
            DebugPrint(( "SetJob() failed, ec=%d", GetLastError() ));
        }

        //
        // update the page count
        //

        GetJob( hPrinter, JobId, 1, NULL, 0, &Bytes );
        JobInfo1 = (PJOB_INFO_1) MemAlloc( Bytes );
        if (JobInfo1) {
            JobInfo1->TotalPages += Pages;
            if (!SetJob( hPrinter, JobId, 1, (PBYTE) JobInfo1, 0 )) {
                DebugPrint(( "SetJob() failed, ec=%d", GetLastError() ));
            }
            MemFree( JobInfo1 );
        }
    }

    rVal = 0;

exit:
    if (pProfileObj) {
        pProfileObj->Release();
    }
    if (pProps) {
        MemFree( pProps );
    }
    if (MsgPropTags) {
        MemFree( MsgPropTags );
    }
    if (pPropsMsg) {
        MemFree( pPropsMsg );
    }
    if (pAttachmentRows) {
        MemFree( pAttachmentRows );
    }
    if (AttachmentTable) {
        AttachmentTable->Release();
    }
    if (lpstm) {
        lpstm->Release();
    }
#ifdef WIN95
    if (hDC) {
        EndDoc( hDC );
        SetJob( hPrinter, JobId, 0, NULL, JOB_CONTROL_RESUME );
        DeleteDC( hDC );
    }
#else
    if (ContextInfo.hDC) {
        EndDoc( ContextInfo.hDC );
        SetJob( hPrinter, JobId, 0, NULL, JOB_CONTROL_RESUME );
        DeleteDC( ContextInfo.hDC );
    }
#endif
    if (hPrinter) {
        ClosePrinter( hPrinter );
    }
    if (hWndRichEdit) {
        DestroyWindow( hWndRichEdit );
    }
    if (PrinterInfo) {
        MemFree( PrinterInfo );
    }
    if (FaxConfig.PrinterName) {
        MemFree( FaxConfig.PrinterName );
    }
    if (FaxConfig.CoverPageName) {
        MemFree( FaxConfig.CoverPageName );
    }
    if (DocType) {
        MemFree( DocType );
    }
    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!ifndef FAXROOT
FAXROOT=$(PROJECT_ROOT)\fax
!endif

NOUNICODE=1

!include $(FAXROOT)\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows
DLLENTRY=FaxXpDllEntry
DLLDEF=..\faxxp32.def

USE_MSVCRT=1

INCLUDES=\
  $(INCLUDES); \
  $(FAXROOT)\print\faxprint\inc; \
  $(FAXROOT)\exchange\inc

TARGETLIBS=\
  $(SDK_LIB_PATH)\kernel32.lib    \
  $(SDK_LIB_PATH)\advapi32.lib    \
  $(SDK_LIB_PATH)\uuid.lib        \
  $(SDK_LIB_PATH)\winspool.lib    \
  $(SDK_LIB_PATH)\gdi32.lib       \
  $(SDK_LIB_PATH)\user32.lib      \
  $(SDK_LIB_PATH)\ole32.lib       \
  $(SDK_LIB_PATH)\shell32.lib     \
  $(SDK_LIB_PATH)\mapi32.lib      \
  $(SDK_LIB_PATH)\comdlg32.lib    \
  $(SDK_LIB_PATH)\winfax.lib

SOURCES=\
  ..\config.cpp  \
  ..\faxdoc.cpp  \
  ..\faxxp.cpp   \
  ..\util.cpp    \
  ..\xplogon.cpp \
  ..\xpprov.cpp  \
  ..\faxxp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#include "faxhelp.h"
#include "resource.h"
#pragma hdrstop



VOID
AddCoverPagesToList(
    HWND        hwndList,
    LPSTR       pDirPath,
    BOOL        ServerCoverPage
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a listbox

Arguments:

    hwndList        - Handle to a list window
    pDirPath        - Directory to look for coverpage files
    ServerCoverPage - TRUE if the dir contains server cover pages

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    CHAR            filename[MAX_PATH];
    CHAR            CpName[MAX_PATH];
    HANDLE          hFindFile;
    LPSTR           pFilename;
    LPSTR           pExtension;
    INT             listIndex;
    INT             dirLen;
    INT             fileLen;
    INT             flags = CPFLAG_LINK;
    INT             Cnt = 2;


    //
    // Copy the directory path to a local buffer
    //

    if (pDirPath == NULL || pDirPath[0] == 0) {
        return;
    }

    if ((dirLen = strlen( pDirPath )) >= MAX_PATH - MAX_FILENAME_EXT - 1) {
        return;
    }

    strcpy( filename, pDirPath );
    if (filename[dirLen] !=  '\\')  {
        filename[dirLen] = '\\';
        filename[dirLen+1] = '\0';
        dirLen++;
    }

    //
    // Go through the following loop twice:
    //  Once to add the files with .ncp extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //

    while( Cnt ) {

        //
        // Generate a specification for the files we're interested in
        //

        pFilename = &filename[dirLen];
        *pFilename = TEXT('*');
        strcpy( pFilename+1, ServerCoverPage ? CP_FILENAME_EXT : (flags & CPFLAG_LINK) ? LNK_FILENAME_EXT : CP_FILENAME_EXT );

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile( filename, &findData );

        if (hFindFile != INVALID_HANDLE_VALUE) {

            do {

                //
                // Exclude directories and hidden files
                //

                if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY)) {
                    continue;
                }

                //
                // Make sure we have enough room to store the full pathname
                //

                if ((fileLen = strlen( findData.cFileName)) <= MAX_FILENAME_EXT ) {
                    continue;
                }

                if (fileLen + dirLen >= MAX_PATH) {
                    continue;
                }

                //
                // If we're chasing links, make sure the link refers to
                // a cover page file.
                //

                if (!ServerCoverPage && (flags & CPFLAG_LINK)) {

                    strcpy( pFilename, findData.cFileName );

                    if (!IsCoverPageShortcut(filename)) {
                        continue;
                    }
                }

                //
                // Don't display the filename extension
                //

                if (pExtension = strrchr(findData.cFileName,'.')) {
                    *pExtension = NULL;
                }

                //
                // Add the cover page name to the list window
                //

                strcpy( CpName, findData.cFileName );
                if ( ! ServerCoverPage )
                {
                   char szPersonal[30];
                   LoadString( FaxXphInstance, IDS_PERSONAL, szPersonal, 30 );
                   strcat( CpName, (char *) " " );
                   strcat( CpName, szPersonal );
                }

                listIndex = (INT)SendMessage(
                    hwndList,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) CpName
                    );

                if (listIndex != LB_ERR) {
                    SendMessage( hwndList, LB_SETITEMDATA, listIndex, ServerCoverPage );
                }

            } while (FindNextFile(hFindFile, &findData));

            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;
        Cnt -= 1;
        if (ServerCoverPage) {
            Cnt -= 1;
        }

    }
}


VOID
DrawSampleText(
    HWND hDlg,
    HDC hDC,
    PFAXXP_CONFIG FaxConfig
    )
{

    int PointSize;
    TCHAR PointSizeBuffer[16];
    TCHAR FontTypeBuffer[32];
    BOOL bItalic = FALSE;
    BOOL bBold = FALSE;

    PointSize = abs ( MulDiv((int) FaxConfig->FontStruct.lfHeight, 72, GetDeviceCaps( hDC, LOGPIXELSY)));
    _stprintf( PointSizeBuffer, TEXT("%d"), PointSize );
    SetWindowText( GetDlgItem( hDlg, IDC_FONT_SIZE ), PointSizeBuffer );

    SetWindowText( GetDlgItem( hDlg, IDC_FONT_NAME), FaxConfig->FontStruct.lfFaceName );

    //
    // get the font type
    //
    ZeroMemory(FontTypeBuffer, sizeof(FontTypeBuffer) );
    if (FaxConfig->FontStruct.lfItalic)  {
        bItalic = TRUE;
    }

    if ( FaxConfig->FontStruct.lfWeight == FW_BOLD ) {
        bBold = TRUE;
    }

    if (bBold) {
        LoadString(FaxXphInstance, IDS_FONT_BOLD, FontTypeBuffer,sizeof(FontTypeBuffer)/sizeof(TCHAR) );
        // concat "italic"
        if (bItalic) {
            LoadString(FaxXphInstance, 
                       IDS_FONT_ITALIC, 
                       &FontTypeBuffer[lstrlen(FontTypeBuffer)],
                       sizeof(FontTypeBuffer)/sizeof(TCHAR) - lstrlen(FontTypeBuffer) );
        }
    } else if (bItalic) {
        LoadString(FaxXphInstance, IDS_FONT_ITALIC, FontTypeBuffer,sizeof(FontTypeBuffer)/sizeof(TCHAR) );
    } else {
        LoadString(FaxXphInstance, IDS_FONT_REGULAR, FontTypeBuffer,sizeof(FontTypeBuffer)/sizeof(TCHAR) );
    }

    
    SetWindowText( GetDlgItem( hDlg, IDC_FONT_STYLE), FontTypeBuffer );

    
}

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    )

/*++

Routine Description:

    Dialog procedure for the fax mail transport configuration

Arguments:

    hDlg        - Window handle for this dialog
    message     - Message number
    wParam      - Parameter #1
    lParam      - Parameter #2

Return Value:

    TRUE    - Message was handled
    FALSE   - Message was NOT handled

--*/

{
    static PFAXXP_CONFIG FaxConfig;
    static HWND hwndListPrn;
    static HWND hwndListCov;
    static const DWORD faxextHelpIDs[] = {
        IDC_PRINTER_LIST,           IDH_FAXMAILTRANSPORT_FAX_PRINTERS,
        IDC_STATIC_PRINTERS,        IDH_FAXMAILTRANSPORT_FAX_PRINTERS,
        IDC_USE_COVERPAGE,          IDH_FAXMAILTRANSPORT_INCLUDE_COVER_PAGE,
        IDC_COVERPAGE_LIST,         IDH_FAXMAILTRANSPORT_COVER_PAGES,
        IDC_COVERPAGE_LIST_LABEL,   IDH_FAXMAILTRANSPORT_COVER_PAGES,
        IDCSTATIC_FONT_GROUP,       IDH_FAXMAILTRANSPORT_DEFAULT_MESSAGE_FONT_GRP,
        IDCSTATIC_FONT,             IDH_FAXMAILTRANSPORT_FONT,
        IDCSTATIC_FONTSTYLE,        IDH_FAXMAILTRANSPORT_FONT_STYLE,
        IDCSTATIC_FONTSIZE,         IDH_FAXMAILTRANSPORT_SIZE,
        IDC_FONT_NAME,              IDH_FAXMAILTRANSPORT_FONT,
        IDC_FONT_STYLE,             IDH_FAXMAILTRANSPORT_FONT_STYLE,
        IDC_FONT_SIZE,              IDH_FAXMAILTRANSPORT_SIZE,
        IDC_SET_FONT,               IDH_FAXMAILTRANSPORT_SET_FONT,
        IDC_STATIC,                 (LONG)IDH_INACTIVE,
        IDC_STATIC_ICON,            (LONG)IDH_INACTIVE,
        IDC_STATIC_TITLE,           (LONG)IDH_INACTIVE,
        0,                          0
    };

    PPRINTER_INFO_2 PrinterInfo;
    DWORD CountPrinters;
    DWORD Selection = 0;
    CHAR Buffer[256];
    CHAR CpDir[MAX_PATH];
    LPSTR p;
    PAINTSTRUCT ps;    
#ifndef WIN95
    HANDLE hFax;
    PFAX_CONFIGURATION pFaxConfiguration;
#endif
    


    switch( message ) {
        case WM_INITDIALOG:
            FaxConfig = (PFAXXP_CONFIG) lParam;
#ifndef WIN95
            //
            // defer the server CP check to this point so we don't fire up fax service 
            // unless we really need this property
            //
            if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) ){
                if (FaxGetConfiguration(hFax,&pFaxConfiguration) ){
                    FaxConfig->ServerCpOnly = pFaxConfiguration->ServerCp;
                    FaxFreeBuffer(pFaxConfiguration);
                }
                FaxClose(hFax);
            }
#endif

            hwndListPrn = GetDlgItem( hDlg, IDC_PRINTER_LIST );
            hwndListCov = GetDlgItem( hDlg, IDC_COVERPAGE_LIST );
            
            //
            // populate the printers listbox
            //
            Buffer[0] = 0;
            PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
            if (PrinterInfo) {
                DWORD i,j;
                for (i=0,j=0; i<CountPrinters; i++) {
                    if (strcmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                        SendMessage( hwndListPrn, CB_ADDSTRING, 0, (LPARAM) PrinterInfo[i].pPrinterName );
                        if (FaxConfig->PrinterName && strcmp( PrinterInfo[i].pPrinterName, FaxConfig->PrinterName ) == 0) {
#if defined(WIN95)
                            if (PrinterInfo[i].pPortName) {
                                strcpy( Buffer, PrinterInfo[i].pPortName );
                            }
#else
                            if (PrinterInfo[i].pServerName) {
                                strcpy( Buffer, PrinterInfo[i].pServerName );
                            }
#endif
                        }
                        j += 1;
                    }
                }
                MemFree( PrinterInfo );
                SendMessage( hwndListPrn, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) FaxConfig->PrinterName );
            }

            if (FaxConfig->UseCoverPage) {
                CheckDlgButton( hDlg, IDC_USE_COVERPAGE, BST_CHECKED );
            } else {
                EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), FALSE );
            }

#if defined(WIN95)
            if (Buffer[0]) {
                char *LastWhack;
                LastWhack = strrchr(Buffer, '\\');
                if (LastWhack != NULL)
                    *LastWhack = '\0';
                strcpy(CpDir, Buffer);
                strcat(CpDir, "\\print$\\coverpg\\");
            } else {
                GetServerCpDir( NULL, CpDir, sizeof(CpDir) );
            }

            AddCoverPagesToList( hwndListCov, CpDir, TRUE );

            GetWindowsDirectory( CpDir, sizeof(CpDir) );
            strcat( CpDir, "\\spool\\fax\\coverpg\\" );
            AddCoverPagesToList( hwndListCov, CpDir, FALSE );
#else
            GetServerCpDir( Buffer[0] ? Buffer : NULL, CpDir, sizeof(CpDir) );
            AddCoverPagesToList( hwndListCov, CpDir, TRUE );

            
            if (!FaxConfig->ServerCpOnly) {
                GetClientCpDir( CpDir, sizeof(CpDir) );
                AddCoverPagesToList( hwndListCov, CpDir, FALSE );
            }
#endif
            strcpy( Buffer, FaxConfig->CoverPageName );

            if ( ! FaxConfig->ServerCoverPage )
            {
               char szPersonal[30];
               LoadString( FaxXphInstance, IDS_PERSONAL, szPersonal, 30 );
               strcat( Buffer, (char *) " " );
               strcat( Buffer, szPersonal );
            }

            Selection = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, 0, (LPARAM) Buffer );
            if (Selection == LB_ERR) {
                Selection = 0;
            }

            SendMessage( hwndListCov, LB_SETCURSEL, (WPARAM) Selection, 0 );
            break;

        case ( WM_PAINT ) :
            if (BeginPaint( hDlg, &ps )) {
                DrawSampleText( hDlg, ps.hdc, FaxConfig );
                EndPaint( hDlg, &ps );
            }
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                if (LOWORD(wParam) == IDC_USE_COVERPAGE) {
                    if (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED) {
                        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), TRUE  );
                        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), TRUE  );
                    } else {
                        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
                        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), FALSE );
                    }
                    return FALSE;
                }
            }

            if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRINTER_LIST) {
                char SelectedPrinter[50];

                //
                // delete the old items from the list
                //
                SendMessage(hwndListCov, LB_RESETCONTENT, 0, 0);

                Selection = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                SendMessage( hwndListPrn, CB_GETLBTEXT, Selection, (LPARAM) SelectedPrinter );

                Buffer[0] = 0;
                PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
                if (PrinterInfo) {
                    DWORD i;
                    for (i=0; i<CountPrinters; i++) {
                        if (strcmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                            if (strcmp( PrinterInfo[i].pPrinterName, SelectedPrinter ) == 0) {
                                if (PrinterInfo[i].pServerName) {
                                    strcpy( Buffer, PrinterInfo[i].pServerName );
                                }
                            }
                        }
                    }
                    MemFree( PrinterInfo );
                }
#ifndef WIN95
                GetServerCpDir( Buffer[0] ? Buffer : NULL, CpDir, sizeof(CpDir) );
                AddCoverPagesToList( hwndListCov, CpDir, TRUE );

                BOOL ServerChanged = FALSE;
                if (!FaxConfig->ServerName) {                
                    if (Buffer[0]) {
                        ServerChanged = TRUE;
                    }
                } else if (strcmp(Buffer,FaxConfig->ServerName) != 0) {
                    ServerChanged = TRUE;
                }

                if (ServerChanged) {
                
                    //
                    // refresh server name
                    //
                    if (FaxConfig->ServerName) MemFree(FaxConfig->ServerName);
                    FaxConfig->ServerName = Buffer[0] ? StringDup(Buffer) : NULL ;

                    HANDLE hFax;
                    PFAX_CONFIGURATION pFaxConfiguration;


                    //
                    // get the servercp flag
                    //
                    FaxConfig->ServerCpOnly = FALSE;
                    if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) ){
                        if (FaxGetConfiguration(hFax,&pFaxConfiguration) ) {
                            FaxConfig->ServerCpOnly = pFaxConfiguration->ServerCp;
                            FaxFreeBuffer(pFaxConfiguration);            
                        }
                        FaxClose(hFax);
                    }
                }

                //
                // don't add client coverpages if FaxConfig->ServerCpOnly is set to true
                //
                if (! FaxConfig->ServerCpOnly) {
                    GetClientCpDir( CpDir, sizeof(CpDir) );
                    AddCoverPagesToList( hwndListCov, CpDir, FALSE );
                }
#else 
                if (Buffer[0]) {
                    strcpy(CpDir, Buffer);
                    strcat(CpDir, "\\print$\\coverpg\\");
                } else {
                    GetServerCpDir( NULL, CpDir, sizeof(CpDir) );
                }

                AddCoverPagesToList( hwndListCov, CpDir, TRUE );

                GetWindowsDirectory( CpDir, sizeof(CpDir) );
                strcat( CpDir, "\\spool\\fax\\coverpg\\" );
                AddCoverPagesToList( hwndListCov, CpDir, FALSE );
#endif
            }

            switch (wParam) {
                case IDC_SET_FONT:
                    {
                        CHOOSEFONT  cf;
                        LOGFONT     FontStruct;

                        CopyMemory( &FontStruct, &FaxConfig->FontStruct, sizeof(LOGFONT) );

                        cf.lStructSize = sizeof(CHOOSEFONT);
                        cf.hwndOwner = hDlg;
                        cf.lpLogFont = &FontStruct;
                        cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS;
                        cf.rgbColors = 0;
                        cf.lCustData = 0;
                        cf.lpfnHook = NULL;
                        cf.lpTemplateName = NULL;
                        cf.hInstance = NULL;
                        cf.lpszStyle = NULL;
                        cf.nFontType = SCREEN_FONTTYPE;
                        cf.nSizeMin = 0;
                        cf.nSizeMax = 0;

                        if (ChooseFont(&cf)) {
                            CopyMemory( &FaxConfig->FontStruct, &FontStruct, sizeof(LOGFONT) );
                            InvalidateRect(hDlg, NULL, TRUE);
                            UpdateWindow( hDlg );
                        }
                    }
                    break;

                case IDOK :
                    FaxConfig->UseCoverPage = IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED;
                    Selection = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                    SendMessage( hwndListPrn, CB_GETLBTEXT, Selection, (LPARAM) Buffer );
                    MemFree( FaxConfig->PrinterName );
                    FaxConfig->PrinterName = StringDup( Buffer );
                    Selection = (DWORD)SendMessage( hwndListCov, LB_GETCURSEL, 0, 0 );
                    SendMessage( hwndListCov, LB_GETTEXT, Selection, (LPARAM) Buffer );
                    MemFree( FaxConfig->CoverPageName );
                    p = strrchr( Buffer, '(' );
                    if (p) {
                        p[-1] = 0;
                        FaxConfig->ServerCoverPage = FALSE;
                    } else {
                        FaxConfig->ServerCoverPage = TRUE;
                    }
                    FaxConfig->CoverPageName = StringDup( Buffer );
                    EndDialog( hDlg, TRUE );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, TRUE );
                    break;
            }
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:

            FAXWINHELP( message, wParam, lParam, faxextHelpIDs );
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\faxxp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxxp.h

Abstract:

    Fax transport provider header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include <windows.h>
#include <winspool.h>
#include <mapiwin.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapicode.h>
#include <mapival.h>
#include <mapiwz.h>
#include <richedit.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <tchar.h>
#include <stdio.h>
#ifndef WIN95
#include "winfax.h"
#endif

#include "resource.h"
#include "faxreg.h"
#include "faxmapip.h"
#include "faxutil.h"
#include "devmode.h"

#ifdef WIN95
#define FAX_DRIVER_NAME                     "Microsoft Fax Client"
#else
#define FAX_DRIVER_NAME                     "Windows NT Fax Driver"
#endif
#define FAX_TRANSPORT_NAME                  "Microsoft Fax Transport Service"
#define FAX_ADDRESS_TYPE                    "FAX"
#define LNK_FILENAME_EXT                    ".lnk"
#define CP_FILENAME_EXT                     ".cov"
#define MAX_FILENAME_EXT                    4
#define CPFLAG_LINK                         0x0100

#define TRANSPORT_DISPLAY_NAME_STRING       "Fax Mail Transport"
#define TRANSPORT_DLL_NAME_STRING           "FAXXP32.DLL"

#define LEFT_MARGIN                         1  // ---|
#define RIGHT_MARGIN                        1  //    |
#define TOP_MARGIN                          1  //    |---> in inches
#define BOTTOM_MARGIN                       1  // ---|

#define InchesToCM(_x)                      (((_x) * 254L + 50) / 100)
#define CMToInches(_x)                      (((_x) * 100L + 127) / 254)

#define XPID_NAME                           0
#define XPID_EID                            1
#define XPID_SEARCH_KEY                     2
#define NUM_IDENTITY_PROPS                  3

#define RECIP_ROWID                         0
#define RECIP_NAME                          1
#define RECIP_EMAIL_ADR                     2
#define RECIP_TYPE                          3
#define RECIP_RESPONSIBILITY                4
#define RECIP_DELIVER_TIME                  5
#define RECIP_REPORT_TIME                   6
#define RECIP_REPORT_TEXT                   7
#define RECIP_ADDR_TYPE                     8
#define TABLE_RECIP_PROPS                   9

#define MSG_DISP_TO                         0
#define MSG_SUBJECT                         1
#define MSG_CLASS                           2
#define MSG_BODY                            3
#define MSG_FLAGS                           4
#define MSG_SIZE                            5
#define MSG_PRIORITY                        6
#define MSG_IMPORTANCE                      7
#define MSG_SENSITIVITY                     8
#define MSG_DR_REPORT                       9
#define NUM_MSG_PROPS                      10

#define MSG_ATTACH_METHOD                   0
#define MSG_ATTACH_NUM                      1
#define MSG_ATTACH_EXTENSION                2
#define MSG_ATTACH_FILENAME                 3
#define MSG_ATTACH_PATHNAME                 4
#define MSG_ATTACH_LFILENAME                5
#define MSG_ATTACH_TAG                      6
#define NUM_ATTACH_PROPS                    7
#define NUM_ATTACH_TABLE_PROPS              2


typedef struct _USER_INFO {
    TCHAR BillingCode[64];
    TCHAR Company[128];
    TCHAR Dept[128];
} USER_INFO, *PUSER_INFO;


const static SizedSPropTagArray ( NUM_ATTACH_TABLE_PROPS, sptAttachTableProps) =
{
    NUM_ATTACH_TABLE_PROPS,
    {
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM
    }
};

const static SizedSPropTagArray ( NUM_ATTACH_PROPS, sptAttachProps) =
{
    NUM_ATTACH_PROPS,
    {
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_EXTENSION,
        PR_ATTACH_FILENAME,
        PR_ATTACH_PATHNAME,
        PR_ATTACH_LONG_FILENAME,
        PR_ATTACH_TAG
    }
};

const static SizedSPropTagArray (TABLE_RECIP_PROPS, sptRecipTable) =
{
    TABLE_RECIP_PROPS,
    {
        PR_ROWID,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_RECIPIENT_TYPE,
        PR_RESPONSIBILITY,
        PR_DELIVER_TIME,
        PR_REPORT_TIME,
        PR_REPORT_TEXT,
        PR_ADDRTYPE
    }
};

static const SizedSPropTagArray(NUM_MSG_PROPS, sptPropsForHeader) =
{
    NUM_MSG_PROPS,
    {
        PR_DISPLAY_TO,
        PR_SUBJECT,
        PR_BODY,
        PR_MESSAGE_CLASS,
        PR_MESSAGE_FLAGS,
        PR_MESSAGE_SIZE,
        PR_PRIORITY,
        PR_IMPORTANCE,
        PR_SENSITIVITY,
        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED
    }
};

extern LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function
extern LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function
extern LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function
extern HINSTANCE           FaxXphInstance;
extern MAPIUID             FaxGuid;


LPVOID
MapiMemAlloc(
    DWORD Size
    );

VOID
MapiMemFree(
    LPVOID ptr
    );

PVOID
MyGetPrinter(
    LPSTR   PrinterName,
    DWORD   level
    );

LPSTR
GetServerName(
    LPSTR PrinterName
    );

LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

HRESULT WINAPI
OpenServiceProfileSection(
    LPMAPISUP    pSupObj,
    LPPROFSECT * ppProfSectObj
    );

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    );

BOOL
GetUserInfo(
    LPTSTR PrinterName,
    PUSER_INFO UserInfo
    );

DWORD
GetDwordProperty(
    LPSPropValue pProps,
    DWORD PropId
    );

LPSTR
GetStringProperty(
    LPSPropValue pProps,
    DWORD PropId
    );

DWORD
GetBinaryProperty(
    LPSPropValue pProps,
    DWORD PropId,
    LPVOID Buffer,
    DWORD SizeOfBuffer
    );



class CXPProvider : public IXPProvider
{
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObj );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    MAPI_IXPPROVIDER_METHODS(IMPL);

public :
    CXPProvider( HINSTANCE hInst );
    ~CXPProvider();

private :
    ULONG               m_cRef;
    CRITICAL_SECTION    m_csTransport;
    HINSTANCE           m_hInstance;
    CHAR                m_ProfileName[64];
};


class CXPLogon : public IXPLogon
{
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObj );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP InitializeStatusRow(ULONG ulFlags);
    STDMETHODIMP GrowAddressList(LPADRLIST *ppAdrList, ULONG ulResizeBy, ULONG *pulOldAndNewCount);
    MAPI_IXPLOGON_METHODS(IMPL);

private:
    void WINAPI CheckSpoolerYield( BOOL fReset = FALSE );
    void WINAPI UpdateStatus( BOOL fAddValidate=FALSE, BOOL fValidateOkState=FALSE );
    BOOL WINAPI LoadStatusString( LPTSTR pString, UINT uStringSize );
    DWORD SendFaxDocument(LPMESSAGE pMsgObj,LPSTREAM lpstmT,BOOL UseRichText,LPSPropValue pMsgProps,LPSPropValue pRecipProps);
    PVOID MyGetPrinter(LPSTR PrinterName,DWORD Level);
    VOID PrintRichText(HWND hWndRichEdit,HDC hDC,PFAXXP_CONFIG FaxConfig);
    BOOL PrintText(HDC hDC,LPSTREAM lpstmT,PFAXXP_CONFIG FaxConfig);
    DWORD PrintAttachment(LPSTR FaxPrinterName,LPSTR DocName);

public :
    CXPLogon( HINSTANCE hInstance, LPMAPISUP pSupObj, LPSTR ProfileName );
    ~CXPLogon();

    inline void WINAPI AddStatusBits
                    (DWORD dwNewBits) { m_ulTransportStatus |= dwNewBits; }
    inline void WINAPI RemoveStatusBits
                    (DWORD dwOldBits) { m_ulTransportStatus &= ~dwOldBits; }
    inline DWORD WINAPI GetTransportStatusCode
                    () { return m_ulTransportStatus; }

private :
    ULONG               m_cRef;
    HINSTANCE           m_hInstance;
    BOOL                m_fABWDSInstalled;
    ULONG               m_ulTransportStatus;
    LPWSTR              m_CpBuffer;
    DWORD               m_CpBufferSize;
    CHAR                m_ProfileName[64];

public :
    LPMAPISUP           m_pSupObj;
    HANDLE              m_hUIMutex;
    HRESULT             m_hRemoteActionErr;
    BOOL                m_fCancelPending;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This module contains utility routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#pragma hdrstop


//
// globals
//

BOOL oleInitialized;

LPSTR Platforms[] =
{
    "Windows NT x86",
    "Windows NT R4000",
    "Windows NT Alpha_AXP",
    "Windows NT PowerPC"
};



LPVOID
MapiMemAlloc(
    DWORD Size
    )

/*++

Routine Description:

    Memory allocator.

Arguments:

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID ptr;
    HRESULT hResult;

    hResult = gpfnAllocateBuffer( Size, &ptr );
    if (hResult) {
        ptr = NULL;
    } else {
        ZeroMemory( ptr, Size );
    }

    return ptr;
}


VOID
MapiMemFree(
    LPVOID ptr
    )

/*++

Routine Description:

    Memory de-allocator.

Arguments:

    ptr     - Pointer to the memory block.

Return Value:

    None.

--*/

{
    if (ptr) {
        gpfnFreeBuffer( ptr );
    }
}

HRESULT WINAPI
OpenServiceProfileSection(
    LPMAPISUP    pSupObj,
    LPPROFSECT * ppProfSectObj
    )

/*++

Routine Description:

    This function opens the profile section of this service, where the
    properties of a FAX provider (AB, MS, or XP) are stored.

Arguments:

    pSupObj         - Pointer to the provider support object
    ppProfSectObj   - Where we return a pointer to the service profile
                      section of the provider

Return Value:

    An HRESULT.

--*/

{
    SPropTagArray sptService = { 1, { PR_SERVICE_UID } };
    LPPROFSECT pProvProfSectObj;
    ULONG cValues;
    LPSPropValue pProp;
    HRESULT hResult;


    //
    // Get the PROVIDER profile section
    //
    hResult = pSupObj->OpenProfileSection(
        NULL,
        MAPI_MODIFY,
        &pProvProfSectObj
        );
    if (!hResult) {
        // Get the UID of the profile section of the service where this provider is installed
        hResult = pProvProfSectObj->GetProps (&sptService, FALSE, &cValues, &pProp);
        if (SUCCEEDED(hResult)) {
            if (S_OK == hResult) {
                // Now, with the obtained UID, open the profile section of the service
                hResult = pSupObj->OpenProfileSection ((LPMAPIUID)pProp->Value.bin.lpb,
                                                       MAPI_MODIFY,
                                                       ppProfSectObj);
            } else {
                hResult = E_FAIL;
            }
            MemFree( pProp );
        }
        pProvProfSectObj->Release();
    }
    return hResult;
}


LPSTR
RemoveLastNode(
    LPTSTR Path
    )

/*++

Routine Description:

    Removes the last node from a path string.

Arguments:

    Path    - Path string.

Return Value:

    Pointer to the path string.

--*/

{
    DWORD i;

    if (Path == NULL || Path[0] == 0) {
        return Path;
    }

    i = strlen(Path)-1;
    if (Path[i] == '\\') {
        Path[i] = 0;
        i -= 1;
    }

    for (; i>0; i--) {
        if (Path[i] == '\\') {
            Path[i+1] = 0;
            break;
        }
    }

    return Path;
}


PDEVMODE
GetPerUserDevmode(
    LPTSTR PrinterName
    )
{
    PDEVMODE DevMode = NULL;
    LONG Size;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter;

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {

        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
        return NULL;

    }

    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            PrinterName,
                            NULL,
                            NULL,
                            0
                            );

    if (Size < 0) {
        goto exit;
    }
    
    DevMode = (PDEVMODE) MemAlloc( Size );

    if (DevMode == NULL) {
        goto exit;
    }
    
    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            PrinterName,
                            DevMode,
                            NULL,
                            DM_OUT_BUFFER
                            );

    if (Size < 0) {
        MemFree( DevMode );
        goto exit;
    }


exit:
    
    ClosePrinter( hPrinter );
    return DevMode;
}


BOOL
GetUserInfo(
    LPTSTR PrinterName,
    PUSER_INFO UserInfo
    )
{
    LPBYTE DevMode;
    PDMPRIVATE PrivateDevMode = NULL;
    
    LPSTR AnsiScratch;
    HKEY hKey;
    DWORD Size;

    DevMode = (LPBYTE) GetPerUserDevmode( PrinterName );

    if (DevMode) {
        PrivateDevMode = (PDMPRIVATE) (DevMode + ((PDEVMODE) DevMode)->dmSize);
    }
    
    if (PrivateDevMode && PrivateDevMode->signature == DRIVER_SIGNATURE) {
        AnsiScratch = UnicodeStringToAnsiString( PrivateDevMode->billingCode );
        if (AnsiScratch) {
            strncpy( UserInfo->BillingCode, AnsiScratch, sizeof( UserInfo->BillingCode ) );
            MemFree( AnsiScratch );
        }
    }

    if (RegOpenKey( HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, &hKey ) == ERROR_SUCCESS) {
        
        Size = sizeof(UserInfo->Company);
        if (RegQueryValueEx( hKey, REGVAL_COMPANY, NULL, NULL, (LPBYTE)UserInfo->Company, &Size) != ERROR_SUCCESS) {
            UserInfo->Company[0] = 0;
        }
        
        Size = sizeof(UserInfo->Dept);
        if (RegQueryValueEx( hKey, REGVAL_DEPT, NULL, NULL, (LPBYTE)UserInfo->Dept, &Size) != ERROR_SUCCESS) {
            UserInfo->Dept[0] = 0;
        }
        
        RegCloseKey( hKey );
    }

    if (DevMode) {
        MemFree( DevMode );
    }

    return TRUE;
}


LPSTR
GetStringProperty(
    LPSPropValue pProps,
    DWORD PropId
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) {
        return StringDup( "" );
    }

    return StringDup( pProps[PropId].Value.LPSZ );
}


DWORD
GetDwordProperty(
    LPSPropValue pProps,
    DWORD PropId
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) {
        return 0;
    }

    return pProps[PropId].Value.ul;
}


DWORD
GetBinaryProperty(
    LPSPropValue pProps,
    DWORD PropId,
    LPVOID Buffer,
    DWORD SizeOfBuffer
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) {
        return 0;
    }

    if (pProps[PropId].Value.bin.cb > SizeOfBuffer) {
        return 0;
    }

    CopyMemory( Buffer, pProps[PropId].Value.bin.lpb, pProps[PropId].Value.bin.cb );

    return pProps[PropId].Value.bin.cb;
}


PVOID
MyGetPrinter(
    LPSTR   PrinterName,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    HANDLE hPrinter;
    PBYTE pPrinterInfo = NULL;
    DWORD cbNeeded;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {
        return NULL;
    }

    if (!GetPrinter( hPrinter, level, NULL, 0, &cbNeeded ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = (PBYTE) MemAlloc( cbNeeded )) &&
        GetPrinter( hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded ))
    {
        ClosePrinter( hPrinter );
        return pPrinterInfo;
    }

    ClosePrinter( hPrinter );
    MemFree( pPrinterInfo );
    return NULL;
}

LPSTR
GetServerName(
    LPSTR PrinterName
    )

/*++

Routine Description:

    retrieve the servername given a printer name

Arguments:

    PrinterName - Identifies the printer in question
    

Return Value:

    Pointer to a string, NULL if there is an error

--*/
{
    PPRINTER_INFO_2 PrinterInfo = NULL;
    LPSTR ServerName = NULL;

    if (!PrinterName) {
        goto exit;
    }
    
    if (!(PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter(PrinterName,2))) {
        goto exit;
    }

    if (PrinterInfo->pServerName) {
        ServerName = StringDup(PrinterInfo->pServerName);
    }
    

exit:
    if (PrinterInfo) {
        MemFree(PrinterInfo);
    }    

    return ServerName;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\faxxp.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxxp.cpp

Abstract:

    This module contains routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#pragma hdrstop


//
// globals
//

LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function
LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function
LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function
HINSTANCE           FaxXphInstance;
HMODULE             hModRichEdit;
MAPIUID             FaxGuid = FAX_XP_GUID;



extern "C"
DWORD
FaxXpDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        FaxXphInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize( NULL, MapiMemAlloc, MapiMemFree, HEAPINIT_NO_VALIDATION | HEAPINIT_NO_STRINGS );
    }

    if (Reason == DLL_PROCESS_DETACH) {
    }

    return TRUE;
}


STDINITMETHODIMP
XPProviderInit(
    HINSTANCE hInstance,
    LPMALLOC lpMalloc,
    LPALLOCATEBUFFER lpAllocateBuffer,
    LPALLOCATEMORE lpAllocateMore,
    LPFREEBUFFER lpFreeBuffer,
    ULONG ulFlags,
    ULONG ulMAPIVer,
    ULONG * lpulProviderVer,
    LPXPPROVIDER * lppXPProvider
    )

/*++

Routine Description:

    Entry point called by the MAPI spooler when a profile uses this
    transport. The spooler calls this method and expects a pointer to an
    implementation of the IXPProvider interface. MAPI uses the returned
    IXPProvider interface pointer to logon on the transport provider.

Arguments:

    Refer to MAPI Documentation for this method.

Return Value:

    An HRESULT.

--*/

{
    gpfnAllocateBuffer = lpAllocateBuffer;
    gpfnAllocateMore = lpAllocateMore;
    gpfnFreeBuffer = lpFreeBuffer;

    if (!hModRichEdit) {
        hModRichEdit = LoadLibrary( "RICHED32.DLL" );
    }

    CXPProvider * pXPProvider = new CXPProvider( hInstance );
    if (!pXPProvider) {
        return E_OUTOFMEMORY;
    }
    *lppXPProvider = (LPXPPROVIDER)pXPProvider;
    *lpulProviderVer = CURRENT_SPI_VERSION;
    return 0;
}


HRESULT STDAPICALLTYPE
CreateDefaultPropertyTags(
    LPPROFSECT pProfileObj
    )

/*++

Routine Description:

    Creates the default property tags & values.

Arguments:

    pProfileObj - Profile object.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult;
    SPropValue spvProps[NUM_FAX_PROPERTIES] = { 0 };
    PPRINTER_INFO_2 PrinterInfo;
    DWORD CountPrinters;
    LPSTR FaxPrinterName = NULL;
    LOGFONT FontStruct;
    HFONT hFont;


    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
    if (PrinterInfo) {
        DWORD i;
        for (i=0; i<CountPrinters; i++) {
            if (strcmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                FaxPrinterName = StringDup( PrinterInfo[i].pPrinterName );
                break;
            }
        }
        MemFree(PrinterInfo);
    }

    spvProps[PROP_FAX_PRINTER_NAME].ulPropTag  = PR_FAX_PRINTER_NAME;
    spvProps[PROP_FAX_PRINTER_NAME].Value.LPSZ = FaxPrinterName ? FaxPrinterName : "";

    spvProps[PROP_COVERPAGE_NAME].ulPropTag    = PR_COVERPAGE_NAME;
    spvProps[PROP_COVERPAGE_NAME].Value.LPSZ   = "";

    spvProps[PROP_USE_COVERPAGE].ulPropTag     = PR_USE_COVERPAGE;
    spvProps[PROP_USE_COVERPAGE].Value.ul      = 0;

    spvProps[PROP_SERVER_COVERPAGE].ulPropTag  = PR_SERVER_COVERPAGE;
    spvProps[PROP_SERVER_COVERPAGE].Value.ul   = 0;

    hFont = (HFONT) GetStockObject( SYSTEM_FIXED_FONT );
    GetObject( hFont, sizeof(LOGFONT), &FontStruct );

    spvProps[PROP_FONT].ulPropTag              = PR_FONT;
    spvProps[PROP_FONT].Value.bin.cb           = sizeof(LOGFONT);
    spvProps[PROP_FONT].Value.bin.lpb          = (LPBYTE) &FontStruct;

    hResult = pProfileObj->SetProps( sizeof(spvProps)/sizeof(SPropValue), spvProps, NULL);

    return hResult;
}


HRESULT STDAPICALLTYPE
ServiceEntry(
    HINSTANCE          hInstance,
    LPMALLOC           pMallocObj,
    LPMAPISUP          pSupObj,
    ULONG              ulUIParam,
    ULONG              ulFlags,
    ULONG              ulContext,
    ULONG              ulCfgPropCount,
    LPSPropValue       pCfgProps,
    LPPROVIDERADMIN    pAdminProvObj,
    LPMAPIERROR *      ppMAPIError
    )

/*++

Routine Description:

    Called by the profile setup API to display the provider
    configuration properties for this transport provider

Arguments:

    Refer to MAPI Documentation for this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult = S_OK;
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    LPSPropValue pProps = NULL;
    FAXXP_CONFIG FaxConfig;


    pSupObj->GetMemAllocRoutines( &gpfnAllocateBuffer, &gpfnAllocateMore, &gpfnFreeBuffer );

    hResult = pAdminProvObj->OpenProfileSection(
        &FaxGuid,
        NULL,
        MAPI_MODIFY,
        &pProfileObj
        );
    if (hResult) {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_CREATE) {
        CreateDefaultPropertyTags( pProfileObj );
        goto exit;
    }

    if (ulContext == MSG_SERVICE_DELETE) {
        goto exit;
    }

    hResult = pProfileObj->GetProps(
        (LPSPropTagArray) &sptFaxProps,
        0,
        &PropCount,
        &pProps
        );
    if (FAILED(hResult)) {
        goto exit;
    }

    FaxConfig.PrinterName      = GetStringProperty( pProps, PROP_FAX_PRINTER_NAME );
    FaxConfig.CoverPageName    = GetStringProperty( pProps, PROP_COVERPAGE_NAME );
    FaxConfig.UseCoverPage     = GetDwordProperty( pProps, PROP_USE_COVERPAGE );
    FaxConfig.ServerCoverPage  = GetDwordProperty( pProps, PROP_SERVER_COVERPAGE );
    
#ifndef WIN95

    //
    // get the server name from the printer name
    // 
    FaxConfig.ServerName = GetServerName(FaxConfig.PrinterName);

   //
   // nice idea but we should really defer this until it's needed, ie., if and when the
   // dialog comes up (otherwise we can fire up the fax service when it's not needed)
   //
   #if 0
       HANDLE hFax;
       PFAX_CONFIGURATION pFaxConfiguration;
   
       //
       // get the servercp flag
       //
       FaxConfig.ServerCpOnly = FALSE;
       if (FaxConnectFaxServer(FaxConfig.ServerName,&hFax) ) {
           if (FaxGetConfiguration(hFax,&pFaxConfiguration) ) {
               FaxConfig.ServerCpOnly = pFaxConfiguration->ServerCp;
               FaxFreeBuffer(pFaxConfiguration);            
           }
           FaxClose(hFax);
       }
   #endif
#endif

    if (!GetBinaryProperty( pProps, PROP_FONT, &FaxConfig.FontStruct, sizeof(FaxConfig.FontStruct) )) {
        HFONT hFont = (HFONT) GetStockObject( SYSTEM_FIXED_FONT );
        GetObject( hFont, sizeof(LOGFONT), &FaxConfig.FontStruct );
    }

    

    if (ulContext == MSG_SERVICE_CONFIGURE) {
        DialogBoxParam(
            hInstance,
            MAKEINTRESOURCE(FAX_CONFIG_DIALOG),
            (HWND) ulUIParam,
            ConfigDlgProc,
            (LPARAM) &FaxConfig
            );
    }

    pProps[PROP_FAX_PRINTER_NAME].ulPropTag  = PR_FAX_PRINTER_NAME;
    pProps[PROP_FAX_PRINTER_NAME].Value.LPSZ = FaxConfig.PrinterName;

    pProps[PROP_COVERPAGE_NAME].ulPropTag    = PR_COVERPAGE_NAME;
    pProps[PROP_COVERPAGE_NAME].Value.LPSZ   = FaxConfig.CoverPageName;

    pProps[PROP_USE_COVERPAGE].ulPropTag     = PR_USE_COVERPAGE;
    pProps[PROP_USE_COVERPAGE].Value.ul      = FaxConfig.UseCoverPage;

    pProps[PROP_SERVER_COVERPAGE].ulPropTag  = PR_SERVER_COVERPAGE;
    pProps[PROP_SERVER_COVERPAGE].Value.ul   = FaxConfig.ServerCoverPage;

    pProps[PROP_FONT].ulPropTag              = PR_FONT;
    pProps[PROP_FONT].Value.bin.lpb          = (LPBYTE)&FaxConfig.FontStruct;
    pProps[PROP_FONT].Value.bin.cb           = sizeof(FaxConfig.FontStruct);

    hResult = pProfileObj->SetProps( PropCount, pProps, NULL);

    if (FaxConfig.PrinterName) {
        MemFree( FaxConfig.PrinterName );
    }
    if (FaxConfig.CoverPageName) {
        MemFree( FaxConfig.CoverPageName );
    }    
    if (FaxConfig.ServerName) {
        MemFree(FaxConfig.ServerName);
    }

exit:
    if (pProfileObj) {
        pProfileObj->Release();
    }

    if (pProps) {
        MemFree( pProps );
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\xplogon.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    xplogon.cpp

Abstract:

    This module contains the XPLOGON class implementation.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#pragma hdrstop


CHAR gszProviderName[] = FAX_TRANSPORT_NAME;
LPSTR gszFAXAddressType = FAX_ADDRESS_TYPE;
LPSTR *gpszXPAddressTypes;



CXPLogon::CXPLogon(
    HINSTANCE       hInstance,
    LPMAPISUP       pSupObj,
    LPSTR           ProfileName
    )

/*++

Routine Description:

    Constructor of the object. Parameters are passed to initialize the
    data members with the appropiate values.

Arguments:

    hInstance   - Instance of the provider DLL
    pSupObj     - Pointer to IMAPISupport object used in
                  CXPLogon methods

Return Value:

    None.

--*/

{
    m_cRef           = 1;
    m_hInstance      = hInstance;
    m_pSupObj        = pSupObj;
    m_fABWDSInstalled = FALSE;

    strcpy( m_ProfileName, ProfileName );

    m_pSupObj->AddRef();
}


CXPLogon::~CXPLogon()

/*++

Routine Description:

    Destructor of CXPLogon. Releases memory allocated for internal
    properties during the life of this transport logon object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    // Release the IMAPISupport object
    m_pSupObj->Release();
    m_pSupObj = NULL;
}


STDMETHODIMP
CXPLogon::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )

/*++

Routine Description:

    Returns a pointer to a interface requested if the interface is
    supported and implemented by this object. If it is not supported, it
    returns NULL.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    // OLE requires NULLing parameter
    *ppvObj = NULL;
    // If this is one of the two IID return an interface pointer to it
    if (riid == IID_IXPLogon || riid == IID_IUnknown) {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }
    // This object does not support the interface requested
    return E_NOINTERFACE;
}


STDMETHODIMP
CXPLogon::AddressTypes(
    ULONG *        pulFlags,
    ULONG *        pcAdrType,
    LPTSTR **      pppAdrTypeArray,
    ULONG *        pcMAPIUID,
    LPMAPIUID **   pppMAPIUIDArray
    )

/*++

Routine Description:

    Called by the MAPI Spooler when initializing this XP logon object to
    allow the transport to register the address it will handle.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    S_OK always

--*/

{
    *pcAdrType = 1;
    *pulFlags = 0;
    gpszXPAddressTypes = &gszFAXAddressType;
    *pppAdrTypeArray = gpszXPAddressTypes;
    *pcMAPIUID = 0;
    *pppMAPIUIDArray = NULL;
    return S_OK;
}


STDMETHODIMP
CXPLogon::RegisterOptions(
    ULONG *         pulFlags,
    ULONG *         pcOptions,
    LPOPTIONDATA *  ppOptions
    )

/*++

Routine Description:

    This transport does not registers any per-recipient or per-message
    option processing, so we return 0 options. And NULL in the OPTIONDATA
    structure pointer.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    *pulFlags = 0;
    *pcOptions = 0;
    *ppOptions = NULL;
    return S_OK;
}


STDMETHODIMP
CXPLogon::InitializeStatusRow(
    ULONG ulFlags
    )

/*++

Routine Description:

    To initialize or modify the status properties of a CXPLogon
    object. This function allocates an array with NUM_STATUS_ROW_PROPS
    properties and initializes them.

Arguments:

    ulFlags - 0 if the properties are being created the first time.
              MODIFY_FLAGS if a change is being made to the properties

Return Value:

    An HRESULT.

--*/

{
    #define NUM_STATUS_ROW_PROPS    10
    SPropValue spvStatusRow[NUM_STATUS_ROW_PROPS] = { 0 };
    ULONG i = 0;

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_PROVIDER_DISPLAY property: The transport readable name
    spvStatusRow[i].ulPropTag = PR_PROVIDER_DISPLAY;
    spvStatusRow[i++].Value.LPSZ = TRANSPORT_DISPLAY_NAME_STRING;

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_RESOURCE_METHODS property. These are the methods implemented
    // in the our IMAPIStatus implementation (CMAPIStatus class.)
    spvStatusRow[i].ulPropTag = PR_RESOURCE_METHODS;
    // we support ALL the methods in our implementation of IMAPIStatus interface (except the WRITABLE ones)
    spvStatusRow[i++].Value.l = STATUS_SETTINGS_DIALOG |
                                STATUS_FLUSH_QUEUES |
                                STATUS_VALIDATE_STATE;

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_STATUS_CODE property.
    spvStatusRow[i].ulPropTag = PR_STATUS_CODE;
    spvStatusRow[i++].Value.l = GetTransportStatusCode();

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_STATUS_STRING property
    TCHAR szStatus[64];
    LoadStatusString (szStatus, sizeof(szStatus));
    spvStatusRow[i].ulPropTag = PR_STATUS_STRING;
    spvStatusRow[i++].Value.LPSZ = szStatus;

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_DISPLAY_NAME property
    spvStatusRow[i].ulPropTag = PR_DISPLAY_NAME;
    spvStatusRow[i++].Value.LPSZ = TRANSPORT_DISPLAY_NAME_STRING;

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_REMOTE_PROGRESS property
    spvStatusRow[i].ulPropTag = PR_REMOTE_PROGRESS;
    spvStatusRow[i++].Value.l = -1; // Not initialized

    ///////////////////////////////////////////////////////////////////////////
    // Set the PR_REMOTE_VALIDATE_OK property
    spvStatusRow[i].ulPropTag = PR_REMOTE_VALIDATE_OK;
    spvStatusRow[i++].Value.b = TRUE;

    // Write the entries on the provider's session status row
    HRESULT hResult = m_pSupObj->ModifyStatusRow (i, spvStatusRow, ulFlags);
    return hResult;
}


VOID WINAPI
CXPLogon::UpdateStatus(
    BOOL fAddValidate,
    BOOL fValidateOkState
    )

/*++

Routine Description:

    Updates the transport status row of this transport in the MAPI Mail
    subsystem. Updates the flags according the internal state flags
    maintained in status code of the transport and loads a readable status
    string to reset the status row. The caller of this method should update
    the status code member variable prior to calling UpdateStatus()

Arguments:

    fAddValidate
    fValidateOkState

Return Value:

    None.

--*/

{
    ULONG cProps = 1;
    SPropValue rgProps[1] = { 0 };

    rgProps[0].ulPropTag = PR_STATUS_CODE;
    rgProps[0].Value.l = GetTransportStatusCode();

    HRESULT hResult = m_pSupObj->ModifyStatusRow( cProps, rgProps, STATUSROW_UPDATE );
}


BOOL WINAPI
CXPLogon::LoadStatusString(
    LPTSTR pString,
    UINT uStringSize
    )

/*++

Routine Description:

    Loads a string from the transport's stringtable. This method is called
    by the CXPLogon::UpdateStatus method when updating a status row. This
    method loads the string based on the status bits of the transport
    status code

Arguments:

    pString      - Pointer to a string which will hold the status string
    uStringSize  - Maximum number of characters allowed in the string

Return Value:

   TRUE     - If the string was found in the string table.
   FALSE    - The string was not found. The String indicated by
              pString is set to hold 0 characters

--*/

{
    strcpy( pString, "Status String" );
    return TRUE;
}


STDMETHODIMP
CXPLogon::TransportNotify(
    ULONG * pulFlags,
    LPVOID * ppvData
    )

/*++

Routine Description:

    Update the status row registered by this transport with MAPI.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulOldStatus = GetTransportStatusCode();

    if (*pulFlags & NOTIFY_BEGIN_INBOUND) {
        AddStatusBits( STATUS_INBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_END_INBOUND) {
        RemoveStatusBits( STATUS_INBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_BEGIN_OUTBOUND) {
        AddStatusBits( STATUS_OUTBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_END_OUTBOUND) {
        RemoveStatusBits( STATUS_OUTBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_BEGIN_OUTBOUND_FLUSH) {
        m_pSupObj->SpoolerNotify( NOTIFY_SENTDEFERRED, NULL );
    }
    if (*pulFlags & NOTIFY_END_OUTBOUND_FLUSH) {
        RemoveStatusBits( STATUS_OUTBOUND_FLUSH );
    }
    if (*pulFlags & NOTIFY_END_INBOUND_FLUSH) {
        RemoveStatusBits( STATUS_INBOUND_FLUSH );
    }

    if (ulOldStatus != GetTransportStatusCode()) {
        UpdateStatus();
    }

    return S_OK;
}

STDMETHODIMP
CXPLogon::Idle(
    ULONG ulFlags
    )

/*++

Routine Description:

    Stub method. We should not get called here, because we told
    the spooler not to call us here.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    S_OK always.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::TransportLogoff(
    ULONG ulFlags
    )

/*++

Routine Description:

    This method is called by the spooler when the transport should do final
    arragements before it gets released.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    //
    // We should attempt to remove the transport's status row from
    // the system, but if we fail we won't fail the call.
    //
    HRESULT hResult = m_pSupObj->ModifyStatusRow (0, NULL, 0);

    return S_OK;
}


STDMETHODIMP
CXPLogon::SubmitMessage(
    ULONG     ulFlags,
    LPMESSAGE pMsgObj,
    ULONG *   pulMsgRef,
    ULONG *   pulReturnParm
    )

/*++

Routine Description:

    This method is called by the spooler when a client submits a
    message to a recipient whose address type this transport handles.
    The spooler calls this method twice for each deferred message.
    The first time (before the delivery time) when the message is
    submitted by the client, we simply return. The message is then queued
    by the spooler for later delivery. We keep track of when it's time
    to send deferred messages.

    The second time we're called, the state variable will be 'READY' and
    we go ahead and start the actual transmission. While we're in the
    body of this function, the implied state is 'SENDING'

    If the client logs out of this session, any pending messages get
    queued again the next time it logs in.

    In this transport we get a recipient table, we restrict the table for
    unmarked recipients. After the table is ready we invoke a helper
    method to do the actual transmission.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    LPADRLIST pAdrList = NULL, pAdrListFailed = NULL;
    ULONG ulRow, ulCount1 = 0 , ulCount2 = 0;
    LPSPropValue pProps;
    FILETIME ft;
    SYSTEMTIME st;
    BOOL fSentSuccessfully;
    ULONG cValues;
    LPSPropValue pMsgProps = NULL;
    BOOL NeedDeliveryReport;
    CHAR szHeaderText[1024];
    LPSTREAM lpstmT = NULL;
    DWORD Rslt;
    CHAR ErrorText[256];
    BOOL UseRichText = FALSE;
    LPMAPITABLE AttachmentTable = NULL;
    LPSRowSet pAttachmentRows = NULL;
    LPMAPITABLE pTable = NULL;
    SPropValue spvRecipUnsent;
    SRestriction srRecipientUnhandled;
    LPSRowSet pRecipRows = NULL;


    CheckSpoolerYield( TRUE );

    // Get the recipient table from the message
    HRESULT hResult = pMsgObj->GetRecipientTable( FALSE, &pTable );
    if (hResult) {
        goto ErrorExit;
    }

    // The spooler marks all the message recipients this transport has to
    // handle with PR_RESPONSIBILITY set to FALSE
    spvRecipUnsent.ulPropTag                       = PR_RESPONSIBILITY;
    spvRecipUnsent.Value.b                         = FALSE;

    srRecipientUnhandled.rt                        = RES_PROPERTY;
    srRecipientUnhandled.res.resProperty.relop     = RELOP_EQ;
    srRecipientUnhandled.res.resProperty.ulPropTag = PR_RESPONSIBILITY;
    srRecipientUnhandled.res.resProperty.lpProp    = &spvRecipUnsent;

    hResult = pTable->Restrict( &srRecipientUnhandled, 0 );
    if (hResult) {
        goto ErrorExit;
    }

    // Let the MAPI spooler do other things
    CheckSpoolerYield();

    hResult = HrAddColumns(
        pTable,
        (LPSPropTagArray) &sptRecipTable,
        gpfnAllocateBuffer,
        gpfnFreeBuffer
        );
    if (FAILED(hResult)) {
        goto ErrorExit;
    }

    hResult = HrQueryAllRows(
        pTable,
        NULL,
        NULL,
        NULL,
        0,
        &pRecipRows
        );
    if (FAILED(hResult)) {
        goto ErrorExit;
    }

    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();

    hResult = pMsgObj->GetProps(
        (LPSPropTagArray) &sptPropsForHeader,
        0,
        &cValues,
        &pMsgProps
        );
    if (FAILED(hResult)) {
        goto ErrorExit;
    }

    hResult = pMsgObj->OpenProperty(
        PR_RTF_COMPRESSED,
        &IID_IStream,
        0,
        0,
        (LPUNKNOWN*) &lpstmT
        );
    if (FAILED(hResult)) {
        hResult = pMsgObj->OpenProperty(
            PR_BODY,
            &IID_IStream,
            0,
            0,
            (LPUNKNOWN*) &lpstmT
            );
        if (FAILED(hResult)) {
            //
            // the message body is empty
            //
            lpstmT = NULL;
        }
    } else {
        UseRichText = TRUE;
    }

    // We need to check if the sender requeste a delivery report or not.
    if (PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED == pMsgProps[MSG_DR_REPORT].ulPropTag && pMsgProps[MSG_DR_REPORT].Value.b) {
        NeedDeliveryReport = TRUE;
    } else {
        NeedDeliveryReport = FALSE;
    }

    GetSystemTime (&st);
    SystemTimeToFileTime (&st, &ft);

    for (ulRow=0; ulRow<pRecipRows->cRows; ulRow++) {
        pProps = pRecipRows->aRow[ulRow].lpProps;

        pProps[RECIP_RESPONSIBILITY].ulPropTag = PR_RESPONSIBILITY;
        pProps[RECIP_RESPONSIBILITY].Value.b = TRUE;

        Rslt = SendFaxDocument( pMsgObj, lpstmT, UseRichText, pMsgProps, pProps );
        fSentSuccessfully = Rslt == 0;

        if (!fSentSuccessfully) {
            // Make the spooler generate an NDR instead of DR
            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_NULL;
            LoadString( FaxXphInstance, Rslt, ErrorText, sizeof(ErrorText) );
            wsprintf( szHeaderText,
                "\tThe Fax transport service failed to deliver the message to this recipient.\r\n%s\r\n",
                ErrorText
                );
            LPTSTR pStr;
            hResult = gpfnAllocateMore( Cbtszsize(szHeaderText), pProps, (LPVOID *)&pStr );
            if (SUCCEEDED(hResult)) {
                // Copy the formatted string and hook it into the
                // pre-allocated (by MAPI) column
                lstrcpy (pStr, szHeaderText);
                pProps[RECIP_REPORT_TEXT].ulPropTag = PR_REPORT_TEXT;
                pProps[RECIP_REPORT_TEXT].Value.LPSZ = pStr;
            } else {
                pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT));
                pProps[RECIP_REPORT_TEXT].Value.err = hResult;
            }
        } else {
            // For delivery report, each recipient must have this property set.
            // Otherwise the spooler will default to generate an NDR instead.
            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_DELIVER_TIME;
            pProps[RECIP_DELIVER_TIME].Value.ft = ft;

            pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT));
            pProps[RECIP_REPORT_TEXT].Value.err = S_OK;
        }

        //
        // manage the lists
        //

        LPADRLIST * ppTmpList = (fSentSuccessfully ? &pAdrList : &pAdrListFailed);
        ULONG ulTmpCount = (fSentSuccessfully ? ulCount1 : ulCount2);

        //
        // Does the list where this recipient goes have enough room for one more entry?
        // If not, resize the address list to hold QUERY_SIZE more entries.
        //
        if (!(*ppTmpList) || ((*ppTmpList)->cEntries + 1 > ulTmpCount)) {
            hResult= GrowAddressList( ppTmpList, 10, &ulTmpCount );
            if (hResult) {
                goto ErrorExit;
            }
            ulCount1 = (fSentSuccessfully ? ulTmpCount : ulCount1);
            ulCount2 = (!fSentSuccessfully ? ulTmpCount : ulCount2);
        }

        //
        // We have room now so store the new ADRENTRY. As part of the
        // storage, we're going to copy the SRow pointer from the SRowSet
        // into the ADRENTRY. Once we've done this, we won't need the
        // SRowSet any more ... and the SRow will be released when
        // we unwind the ADRLIST
        //
        (*ppTmpList)->aEntries[(*ppTmpList)->cEntries].cValues = pRecipRows->aRow[ulRow].cValues;
        (*ppTmpList)->aEntries[(*ppTmpList)->cEntries].rgPropVals = pRecipRows->aRow[ulRow].lpProps;

        //
        // Increase the number of entries in the address list
        //
        (*ppTmpList)->cEntries++;

        //
        // Now that we are finished with this row (it is in the right
        // adrlist) we want to disassociate it from the rowset
        // so we don't delete this before we modify the recipients list
        //
        pRecipRows->aRow[ulRow].lpProps = NULL;
        pRecipRows->aRow[ulRow].cValues = 0;
    }


    if (!(FAILED(hResult))) {
        // Now we need to save changes on the message and close it.
        // After this, the message object can't be used.
        hResult = pMsgObj->SaveChanges(0);
    }

    // Let the MAPI spooler do other things
    CheckSpoolerYield();

    // Do we have some recipients that the message arrived to?
    if (pAdrList) {
        hResult = pMsgObj->ModifyRecipients( MODRECIP_MODIFY, pAdrList );
        hResult = S_OK; // We'll drop the error code from the modify recipients call
        if (NeedDeliveryReport) {
            hResult = m_pSupObj->StatusRecips( pMsgObj, pAdrList );
            if (!HR_FAILED(hResult)) {
                // If we were successful, we should null out the pointer becase MAPI released
                // the memory for this structure. And we should not try to release it
                // again in the cleanup code.
                pAdrList = NULL;
            }
        }
    }

    // Do we have some recipients that the message DID NOT arrived to?
    if (pAdrListFailed) {
        hResult = pMsgObj->ModifyRecipients( MODRECIP_MODIFY, pAdrListFailed );
        // We'll drop the error code from the modify recipients call
        // The address list has the entries with the PR_RESPONSIBILITY set, so the
        // spooler will know if it has to generate NDR reports.
        hResult = m_pSupObj->StatusRecips( pMsgObj, pAdrListFailed );
        if (!HR_FAILED(hResult)) {
            // If we were successful, we should null out the pointer becase MAPI released
            // the memory for this structure. And we should not try to release it
            // again in the cleanup code.
            pAdrListFailed = NULL;
        }
    }

ErrorExit:
     // Release the table, we're finished with it
    if (pTable) {
        pTable->Release();
    }

    // Release the spooler's message if needed to
    if (pMsgObj) {
        pMsgObj->Release ();
    }

    if (pRecipRows) {
        FreeProws( pRecipRows );
    }

    if (pMsgProps) {
        MemFree( pMsgProps );
    }

    if (lpstmT) {
        lpstmT->Release();
    }

    // In case there is a warning or error floating around, don't let it escape to the spooler.
    if (FAILED(hResult)) {
        // We default to MAPI_E_NOT_ME so that the spooler would attempt handle
        // the message to other transport (currently running in this profile)
        // that handle the same address type as ours.
        hResult = MAPI_E_NOT_ME;
    } else {
        hResult = S_OK;
    }
    return hResult;
}


STDMETHODIMP
CXPLogon::GrowAddressList(
    LPADRLIST *ppAdrList,
    ULONG     ulResizeBy,
    ULONG     *pulOldAndNewCount
    )

/*++

Routine Description:

    In this function, given an address list with pulOldAndNewCount of
    entries, we resize the address list to hold the old number of
    entries plus the ulResizeBy entries. The old address list contents
    are copied to the new list and the count reset. The memory for the
    old address list is released here.

Arguments:

    ppAdrList           - Pointer to an address where the old address list
                          is and where the new resized address list will
                          be returned
    ulResizeBy          - Number of new address entries to add to the list
    pulOldAndNewCount   - Number of entries in the old address list. In
                          this parameter, upon sucessful return, will have
                          the number of in the new address list

Return Value:

    An HRESULT.

--*/

{
    LPADRLIST pNewAdrList;
    // Calculate how big the new buffer for the expanded address list should be
    ULONG cbSize = CbNewADRLIST ((*pulOldAndNewCount) + ulResizeBy);
    // Allocate the memory for it
    HRESULT hResult = gpfnAllocateBuffer (cbSize, (LPVOID *)&pNewAdrList);
    if (hResult) {
        // We can't continue
        return hResult;
    }

    // Zero-out all memory for neatness
    ZeroMemory (pNewAdrList, cbSize);

    // If we had entries in the old address list, copy the memory from
    // the old addres list into the new expanded list
    if ((*pulOldAndNewCount)) {
        CopyMemory( pNewAdrList, *ppAdrList, CbNewADRLIST ((*pulOldAndNewCount)) );
    }

    // Set the number of entries in the new address list to the OLD size
    pNewAdrList->cEntries = (*pulOldAndNewCount);

    // We must return the number of available entries in the new expanded address list
    (*pulOldAndNewCount) += ulResizeBy;

    // Free the old memory and put the new pointer in place
    gpfnFreeBuffer (*ppAdrList);
    *ppAdrList = pNewAdrList;
    return hResult;
}


STDMETHODIMP
CXPLogon::EndMessage(
    ULONG ulMsgRef,
    ULONG *pulFlags
    )

/*++

Routine Description:

    This method is called by the spooler for each message we're to
    deliver. It's the mate to SubmitMessage. We're called here twice
    for each deferred message and once for non-deferred (realtime)
    messages.

    We first check the transport state, and if we're
    WAITING for the scheduled delivery time to arrive, we return
    END_DONT_RESEND in *pulFlags, which tells the spooler to queue this
    message for deferred delivery.

    If the state is SENDING, we're getting called here after
    a message has been dequeued and delivered. Return 0 in *pulFlags
    to tell the spooler the message has been delivered.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    *pulFlags = 0;
    return S_OK;
}


STDMETHODIMP
CXPLogon::Poll(
    ULONG *pulIncoming
    )

/*++

Routine Description:

    Stub method. We should not get called here, because we told
    the spooler not to call us here.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::StartMessage(
    ULONG      ulFlags,
    LPMESSAGE  pMsgObj,
    ULONG *    pulMsgRef
    )

/*++

Routine Description:

    This method gets called when an incoming message is pending to be
    processed.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::OpenStatusEntry(
    LPCIID          pInterface,
    ULONG           ulFlags,
    ULONG *         pulObjType,
    LPMAPISTATUS *  ppEntry
    )

/*++

Routine Description:

    This method is called to get an IMAPIStatus object for this XPLOGON
    session.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    if (MAPI_MODIFY & ulFlags) {
        return E_ACCESSDENIED;
    }

    *pulObjType = MAPI_STATUS;
    return S_OK;
}


STDMETHODIMP
CXPLogon::ValidateState(
    ULONG ulUIParam,
    ULONG ulFlags
    )

/*++

Routine Description:

    This function gets caller by a client in order to validate the
    transport logon properties. This function open the profile with the
    most up-to-date properties and then compares them to what the transport
    has stored internally.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::FlushQueues(
    ULONG       ulUIParam,
    ULONG       cbTargetTransport,
    LPENTRYID   pTargetTransport,
    ULONG       ulFlags
    )

/*++

Routine Description:

    Called by the MAPI spooler when, upon request of the client or
    ourselves, we need to flush the inbound or outbound queue.
    Here we make connections to the server to download messages, refresh
    the remote message headers, and request the spooler to send us any
    deferred messages.
    Transport connecting only in FlushQueues() allow the MAPI spooler to
    better manage contention of multiple transport accessing common
    communication resources (such as COM ports) and let the spooler give us
    messages to process when is best for the overall subsystem.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}

void WINAPI
CXPLogon::CheckSpoolerYield(
    BOOL fReset
    )

/*++

Routine Description:

    Enforce the 0.2 second rule for transport that need to yield to the
    MAPI spooler.  Called periodically while processing a message to
    determine if we have used more than 0.2 seconds.  If so, then call
    SpoolerYield(), else just continue.
    This is called with fReset set to TRUE when we first enter one
    of the Transport Logon methods (usually one that is known to
    take a long time like StartMessage() or SubmitMessage(). )

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    DWORD dwStop;
    static DWORD dwStart;
    if (fReset)
    {
        dwStart = GetTickCount();
    }
    else
    {
        dwStop = GetTickCount();
        if ((dwStop - dwStart) > 200) // 200 milliseconds
        {
            m_pSupObj->SpoolerYield (0);
            dwStart = GetTickCount();
        }
    }
}

STDMETHODIMP_(ULONG)
CXPLogon::AddRef()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ++m_cRef;
    return m_cRef;
}


STDMETHODIMP_(ULONG)
CXPLogon::Release()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulCount = --m_cRef;
    if (!ulCount) {
        delete this;
    }

    return ulCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\exchange\xport\xpprov.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    xplogon.cpp

Abstract:

    This module contains the XPLOGON class implementation.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#define INITGUID
#define USES_IID_IXPProvider
#define USES_IID_IXPLogon
#define USES_IID_IMAPIStatus
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIControl
#define USES_IID_IMAPIContainer
#define USES_IID_IMAPIFolder
#define USES_IID_IMAPITableData
#define USES_IID_IStreamDocfile
#define USES_PS_PUBLIC_STRINGS

#include "faxxp.h"
#pragma hdrstop



CXPProvider::CXPProvider(
    HINSTANCE hInst
    )

/*++

Routine Description:

    Constructor of the object. Parameters are passed to initialize the
    data members with the appropiate values.

Arguments:

    hInst   - Handle to instance of this XP DLL

Return Value:

    None.

--*/

{
    m_hInstance = hInst;
    m_cRef = 1;
    InitializeCriticalSection( &m_csTransport );
}


CXPProvider::~CXPProvider()

/*++

Routine Description:

    Close down and release resources and libraries.

Arguments:

    None.

Return Value:

    None.

--*/

{
    m_hInstance = NULL;
    DeleteCriticalSection( &m_csTransport );
}


STDMETHODIMP
CXPProvider::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )

/*++

Routine Description:

    Returns a pointer to a interface requested if the interface is
    supported and implemented by this object. If it is not supported, it
    returns NULL

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    *ppvObj = NULL;
    if (riid == IID_IXPProvider || riid == IID_IUnknown) {
        *ppvObj = (LPVOID)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP
CXPProvider::Shutdown(
    ULONG * pulFlags
    )

/*++

Routine Description:

    Stub method.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPProvider::TransportLogon(
    LPMAPISUP pSupObj,
    ULONG ulUIParam,
    LPTSTR pszProfileName,
    ULONG *pulFlags,
    LPMAPIERROR *ppMAPIError,
    LPXPLOGON *ppXPLogon
    )

/*++

Routine Description:

    Display the logon dialog to show the options saved in the profile for
    this provider and allow changes to it. Save new configuration settings
    back in the profile.
    Create a new CXPLogon object and return it to the spooler. Also,
    initialize the properties array for each address type handled
    by this transport. Check all the flags and return them to the spooler

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    CXPLogon *LogonObj = new CXPLogon( m_hInstance, pSupObj, pszProfileName );
    if (!LogonObj) {
        return E_OUTOFMEMORY;
    }

    LogonObj->InitializeStatusRow(0);

    strcpy( m_ProfileName, pszProfileName );

    *ppXPLogon = LogonObj;

    return S_OK;
}

STDMETHODIMP_(ULONG)
CXPProvider::AddRef()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ++m_cRef;
    return m_cRef;
}


STDMETHODIMP_(ULONG)
CXPProvider::Release()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulCount = --m_cRef;
    if (!ulCount) {
        delete this;
    }

    return ulCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\rendtest\rendtest.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rendtest.h

Abstract:

    This file is the private header file for the rendtest test program.
    It contains some hard-coded testdaata.

Environment:

    WIN32 User Mode

Author:

    Julia J. Robinson (a-juliar) 3-15-96

--*/

LPTSTR HardCodedUserDataStrings[] = {
    _TEXT("Wesley Witt"),
    _TEXT("(206) 123-4567"),
    _TEXT("Microsoft"),
    _TEXT("1 Microsoft Way"),
    _TEXT("Redmond"),
    _TEXT("WA"),
    _TEXT("98???"),
    _TEXT("US"),
    _TEXT("Project Manager"),
    _TEXT("FAX project"),
    _TEXT("Second floor"),
    _TEXT("(206) 765-4321"),
    _TEXT("(206) 987-6543"),
    _TEXT("Julia J. Robinson"),
    _TEXT("(123) 456-7890"),
    _TEXT("EDP Temps"),
    _TEXT("Bellevue"),
    _TEXT("Free-Lance Trouble Maker"),
    _TEXT("Cover Page Division"),
    _TEXT("First desk in 2235"),
    _TEXT("(201) 123-9876"),
    _TEXT("(201) 123-1234"),
    _TEXT("This note will not appear.  We'll override it."),
    _TEXT("Same old subject"),
    _TEXT("WHEN IT'S DONE!"),
    _TEXT("1"),
    _TEXT("bob, jim, kathy"),
    _TEXT("kevin, eric, jane")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\rendtest\rendtest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rendtest.c

Abstract:

    This file contains a test driver for PrintCoverPage.

Environment:

    WIN32 User Mode

Author:

    Julia Robinson (a-juliar)  3-15-96

--*/




#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <tchar.h>
#include <winuser.h>
#include <shellapi.h>
#include "prtcovpg.h"
#include "rendtest.h"

////#define            MY_BUFFER_SIZE             (4096)
#define            FAX_DRIVER_NAME            TEXT("Windows NT Fax Driver")
////#define            DEFAULT_DRIVER_NAME        TEXT("")
int _cdecl
main( int     argcA,
      char    **argvA )
/*
Routine Description:

        Tests PrintCoverPage(), non-rendering and rendering paths.
        All files argv[1] .. argv[argc-1] are tested without rendering,
        printing out returned Flats or error code.
        If the first call to PrintCoverPage() succedes, the first file is printed.
        A COVERPAGEFIELDS structure is created from hard-coded test data.
        A note is then rendered using the *NoteRect coordinates returned.

Arguments:

    argv[1]     name of composite file to be rendered.

Return Value:

    FALSE if an error occurs in the last call to PrintCoverPage().

*/
{
    LPTSTR           *argv;                      // for command line arguments
    int              argc ;
    HDC              hdc;                        // fax printer's device context
    BOOL             Status ;                    // return value of PrintCoverPage
    DOCINFO          DocInfo;                    // structure needed for StartDoc
    PCOVERPAGEFIELDS pUserData;                  // points to test data, mostly hard-coded
    TCHAR            PrinterName[MAX_PATH];
    LPTSTR           pMyBufLoc;                  // Current Location for Writing in Buffer.
    UINT             StructSize ;                // size of COVERPAGEFIELDS and buffer
    LPTSTR           pDriver ;                   // used in parsing a profile string
    LPTSTR           pDevice ;                   //    ditto
    LPTSTR           pOutput ;                   //    ditto
    INT              Index ;
    LPTSTR           * ArrayOfPointers ;
    INT              NumTCHARs ;                 // Number of characters copied at each step.
    DWORD            StringBufferSize ;          // Number of characters needed for user strings.
    DWORD            FirstFlags ;                // Flags returned for the file we will print.
    BOOL             DoPrint ;                   // Give the printer a break if first call fails.
    PDEVMODE         pDevMode ;                  // Printer settings
    HANDLE           hPrinter ;                  // Handle to printer
    HFONT            hNoteFont ;                 // Handle to the font to be used in rendering the NOTE
    HFONT            hOldFont ;                  //
    COVDOCINFO       CovDocInfo;                 // Info returned by PrintCoverPage
    COVDOCINFO       FirstDocInfo;
#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
    argc = argcA;
#endif

    if( argc < 2 ){
        _tprintf( TEXT("usage: %s <compositefilename> [additionalflienames]"), argv[0] );
        return FALSE ;
    }

    //
    // Compute space needed for USERDATA's strings.
    //
    for( Index = 0, StringBufferSize = 0 ; Index < NUM_INSERTION_TAGS ; ++ Index ){
        StringBufferSize += sizeof(TCHAR) * ( 1 + _tcslen( HardCodedUserDataStrings[ Index ] )) ;
    }
    //
    // Allocate space for COVERPAGEFIELDS structure followed by a buffer for the strings.
    //
    StructSize = (sizeof(COVERPAGEFIELDS)) + StringBufferSize ;
    pUserData = (void *)LocalAlloc( LPTR, StructSize );
    if( !pUserData ) return FALSE ;
    pUserData->ThisStructSize = StructSize ;
    //
    // Copy the hard coded test data into the buffer and set the pointers in the
    // COVERPAGEFIELDS structure to point to these strings.
    //
    pMyBufLoc = (LPTSTR)(pUserData + 1);         // buffer follows COVERPAGEFIELDS structure
    ArrayOfPointers = & pUserData->RecName ;
    for( Index = 0 ; Index < NUM_INSERTION_TAGS ; ++ Index ) {
        ArrayOfPointers[ Index ] = pMyBufLoc ;
        NumTCHARs = 1 + _tcslen( HardCodedUserDataStrings[ Index ] );
        _tcsncpy( ArrayOfPointers[ Index ], HardCodedUserDataStrings[ Index ], NumTCHARs );
        pMyBufLoc +=  NumTCHARs ;
    }
    //
    // Use NULL String for test data
    //

    pUserData->Note = NULL ;

    //
    // Test the non-rendering path for all files.
    //

    DoPrint = FALSE ;
    Status = FALSE ;
    for( Index = 1; Index < argc ; ++ Index ){
        Status = PrintCoverPage( NULL, NULL, argv[ Index ], &CovDocInfo );
        if( Status ){
            _tprintf( TEXT( "PrintCoverPage() succeded for file %s. Flags are 0x%08lX\n" ),
                      argv[Index], CovDocInfo.Flags ) ;
            if( 1 == Index ){
                DoPrint = TRUE ;  // We'll actually print the first file.
                FirstFlags = CovDocInfo.Flags ;
                FirstDocInfo = CovDocInfo ;
            }
        }
        else{
            _tprintf( TEXT( "PrintCoverPage() failed for file %s. Last Error is %d.\n" ),
                      argv[ Index ], GetLastError()) ;
        }
    }

    //
    //
    // Find the default printer and get a device context handle for it.
    //

    GetProfileString( TEXT("Windows"), TEXT("device"), TEXT(",,,"), PrinterName, MAX_PATH ) ;
    if(( pDevice = _tcstok( PrinterName, TEXT(","))) &&
       ( pDriver = _tcstok( NULL, TEXT(", "))) &&
       ( pOutput = _tcstok( NULL, TEXT(", ")))) {

       //
       // Serve up a printer device context with orientation and paper size as in FirstDocInfo
       //

       if( !OpenPrinter( PrinterName, &hPrinter, NULL )){
           _tprintf( TEXT( "OpenPrinter falied for %s\n" ), PrinterName ) ;
           return FALSE ;
       }
       if( 0 > ( StructSize = DocumentProperties( NULL, hPrinter, NULL, NULL, NULL, 0 ))){
           _tprintf( TEXT( "First DocumentProperties() call failed\n" )) ;
           return FALSE;
       }
       if( NULL == ( pDevMode = (void*) LocalAlloc( LPTR, StructSize ))){
           _tprintf( TEXT( "LocalAlloc() failed.\n" ));
           return FALSE ;
       }
       if (0 > DocumentProperties(
           NULL,
           hPrinter,
           NULL,
           pDevMode,
           NULL,
           DM_OUT_BUFFER )){
           _tprintf( TEXT( "Second DocumentProperties() call failed\n" )) ;
           return FALSE ;
       }
       pDevMode->dmOrientation = FirstDocInfo.Orientation ;
       pDevMode->dmPaperSize = FirstDocInfo.PaperSize ;
       pDevMode->dmFields = DM_ORIENTATION | DM_PAPERSIZE ;
       if( 0 > DocumentProperties( NULL,
           hPrinter,
           NULL,
           pDevMode,
           pDevMode,
           DM_IN_BUFFER | DM_OUT_BUFFER )){
           _tprintf( TEXT( "Third DocumentProperties() call failed\n" ));
           return FALSE ;
       }
       hdc = CreateDC( pDriver, pDevice, pOutput, pDevMode ) ;
    }
    else {
        _tprintf( TEXT( "GetProfileString() falied\n" )) ;
        return FALSE;
    }

    //
    // Prepare the device context for rendering the note.
    //
    SetMapMode( hdc, MM_TEXT ) ;
    SetBkMode( hdc, TRANSPARENT );
    //
    // Print the cover page.
    //
    ZeroMemory(&DocInfo, sizeof(DocInfo));
    DocInfo.cbSize = sizeof(DocInfo);

    //
    // Render only the first file, and only if it passed the test above.
    //

    if (DoPrint && StartDoc(hdc, &DocInfo)){
        Status = PrintCoverPage(
            hdc,
            pUserData,
            argv[1],
            &CovDocInfo
            );
        if( Status && (CovDocInfo.Flags | COVFP_NOTE ) ){
            hNoteFont = CreateFontIndirect( &CovDocInfo.NoteFont );
            if( NULL == hNoteFont ){
                _tprintf( TEXT( "CreateFontIndirect failed\n" ));
                return FALSE ;
            }
            hOldFont = SelectObject( hdc, hNoteFont );
            if( NULL == hOldFont ){
                _tprintf( TEXT( "SelectObject failed\n" ));
                return FALSE ;
            }
            DPtoLP( hdc, (POINT*)&CovDocInfo.NoteRect, 2 );
            if (0 == DrawText(
                hdc,
                TEXT("Overwriting the note by the calling routine.  Hopefully this will be located in the rectangle it is supposed to be in!  We'll get it there!"),
                -1,
                &CovDocInfo.NoteRect,
                DT_LEFT | DT_NOPREFIX | DT_WORDBREAK )){
                _tprintf( TEXT("DrawText failed to print the note.\n" ));
            }
            SelectObject( hdc, hOldFont );
        }
        EndDoc(hdc);
        if( !Status ){
            _tprintf( TEXT("Failed to print %s\n"), argv[1] );
        }
    }
    DeleteObject( hdc ) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\renderer\prtcovpg.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    prtcovpg.h

Abstract:

    This module contains the WIN32 FAX API header
    for the Windows NT FaxCover rendering routine.

Author:

    Julia Robinson (a-juliar) 5-20-96

Revision History:

    Julia Robinson (a-juliar) 6-7-76
    Julia Robinson (a-juliar) 9-20-96     Allow passing paper size and orientation.
--*/

#ifndef __PRTCOVPG_H__
#define __PRTCOVPG_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Structure of the composite file header
//

typedef struct {
    BYTE      Signature[20];
    DWORD     EmfSize;
    DWORD     NbrOfTextRecords;
    SIZE      CoverPageSize;
} COMPOSITEFILEHEADER;

//
// Structure of the text box entries appended to
// the composite file
//

typedef struct {
    RECT           PositionOfTextBox;
    COLORREF       TextColor;
    LONG           TextAlignment;
    LOGFONT        FontDefinition;
    WORD           ResourceID ;
    DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOX;


//
// Structure of user data for text insertions
//

typedef struct _COVERPAGEFIELDS {

  //
  // Recipient stuff...
  //

  DWORD   ThisStructSize;
  LPTSTR  RecName;
  LPTSTR  RecFaxNumber;
  LPTSTR  RecCompany;
  LPTSTR  RecStreetAddress;
  LPTSTR  RecCity;
  LPTSTR  RecState;
  LPTSTR  RecZip;
  LPTSTR  RecCountry;
  LPTSTR  RecTitle;
  LPTSTR  RecDepartment;
  LPTSTR  RecOfficeLocation;
  LPTSTR  RecHomePhone;
  LPTSTR  RecOfficePhone;

  //
  // Senders stuff...
  //

  LPTSTR  SdrName;
  LPTSTR  SdrFaxNumber;
  LPTSTR  SdrCompany;
  LPTSTR  SdrAddress;
  LPTSTR  SdrTitle;
  LPTSTR  SdrDepartment;
  LPTSTR  SdrOfficeLocation;
  LPTSTR  SdrHomePhone;
  LPTSTR  SdrOfficePhone;

  //
  // Misc Stuff...
  //
  LPTSTR  Note;
  LPTSTR  Subject;
  LPTSTR  TimeSent;
  LPTSTR  NumberOfPages;
  LPTSTR  ToList;
  LPTSTR  CCList ;
} COVERPAGEFIELDS, *PCOVERPAGEFIELDS;

#define  NUM_INSERTION_TAGS   ((sizeof(COVERPAGEFIELDS) - sizeof(DWORD)) / sizeof(LPTSTR))

//
// pFlags fields: bit 0 is Recipient Name, bit 1 is Recipient Fax Number, et cetera.
//

#define  COVFP_NOTE         0x00400000
#define  COVFP_SUBJECT      0x00800000
#define  COVFP_NUMPAGES     0x02000000

typedef struct _COVDOCINFO {
    DWORD       Flags ;
    RECT        NoteRect ;
    short       Orientation ;
    short       PaperSize ;
    LOGFONT     NoteFont ;
} COVDOCINFO, *PCOVDOCINFO ;


//
// Function prototypes
//

DWORD
WINAPI
PrintCoverPage(
    HDC              hdc,
    PCOVERPAGEFIELDS UserData,
    LPTSTR           CompositeFileName,
    PCOVDOCINFO      pCovDocInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\awcpe.cpp ===
//--------------------------------------------------------------------------
// AWCPE.CPP
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      main module for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
//--------------------------------------------------------------------------
#include <tchar.h>
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include <shlobj.h>
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "afxpriv.h"
#include <dos.h>
#include <direct.h>
#include <cderr.h>
#include "faxreg.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define ENFORCE_FILE_EXTENSION_ON_OPEN_FILE 0
#define SHOW_ALL_FILES_FILTER 1


#define BIGGERTHAN_RECT          1
#define NOTSETBY_RECT            0
#define SMALLERTHAN_RECT        -1





UINT NEAR WM_AWCPEACTIVATE = ::RegisterWindowMessage(TEXT("AWCPE_ACTIVATE"));

BYTE BASED_CODE _gheaderVer1[20]={0x41,0x57,0x43,0x50,0x45,0x2D,0x56,0x45,0x52,0x30,0x30,0x31,0x9C,0x87,0x00,0x00,0x00,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer2[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x32,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer3[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x33,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer4[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x34,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer5w[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer5a[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x61,0x87,0x00,0x00,0x00};

static TCHAR szShellPrintFmt[] = _T("%s\\shell\\print\\command");
static TCHAR szShellOpenFmt[] = _T("%s\\shell\\open\\command");
static TCHAR szShellDdeexecFmt[] = _T("%s\\shell\\open\\ddeexec");
static TCHAR szStdOpenArg[] = _T(" \"%1\"");
static TCHAR szStdPrintArg[] = _T(" /P \"%1\"");
static TCHAR szDocIcon[] = TEXT("%s\\DefaultIcon");
static const TCHAR szDocIconArg[] = _T(",1");



BOOL GetSpecialPath(
   int nFolder,
   LPTSTR Path
   )
/*++

Routine Description:

    Get a path from a CSIDL constant

Arguments:

    nFolder     - CSIDL_ constant
    Path        - Buffer to receive the path, assume this buffer is at least MAX_PATH+1 chars large

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HRESULT hr;
    LPITEMIDLIST pIdl = NULL;
    LPMALLOC  IMalloc = NULL;
    BOOL fSuccess = FALSE;

    hr = SHGetMalloc(&IMalloc);
    if (FAILED(hr) ) {
        goto exit;
    }

    hr = SHGetSpecialFolderLocation (NULL,
                                     nFolder,
                                     &pIdl);

    if (FAILED(hr) ) {
        goto exit;
    }

    hr = SHGetPathFromIDList(pIdl, Path);
    if (FAILED(hr) ) {
        goto exit;
    }

    fSuccess = TRUE;

exit:
    if (IMalloc && pIdl) {
        IMalloc->Free((void *) pIdl );
    }

    if (IMalloc) {
        IMalloc->Release() ;
    }

    return fSuccess;

}





CDrawApp NEAR theApp;


//-------------------------------------------------------------------------
CDrawApp::CDrawApp()
{
#ifndef NT5BETA2
   TCHAR Path[MAX_PATH];
#else
   char Path[MAX_PATH];
#endif

   m_iErrorCode=EXIT_SUCCESS;
   m_pFaxMap=NULL;
   m_pIawcpe = NULL;
   m_hMod=NULL;

   ExpandEnvironmentStrings(_T("%systemroot%\\help"), Path, sizeof(Path) / sizeof(TCHAR) );
   lstrcat(Path, _T("\\fax.hlp") );
   m_pszHelpFilePath = _tcsdup(Path);

#ifndef NT5BETA2
   ExpandEnvironmentStrings(_T("%systemroot%\\help"),Path,sizeof(Path)/sizeof(TCHAR));
   wsprintf( m_HtmlHelpFile, _T("%s\\%s"), Path, _T("faxcover.chm") );
#else
   ExpandEnvironmentStringsA("%systemroot%\\help",Path,sizeof(Path));
   sprintf( m_HtmlHelpFile, "%s\\%s", Path, "faxcover.chm" );
#endif

   m_note = NULL;
   m_note_wasread = FALSE;
   m_note_wasclipped = FALSE;
   m_extrapage_count = 0;
   m_more_note = FALSE;
   m_last_note_box = NULL;
   m_note_wrench = NULL;
   m_extra_notepage = NULL;
}


//-------------------------------------------------------------------------
CDrawApp::~CDrawApp()
{

   if (m_pFaxMap)
      delete m_pFaxMap;

        if( m_note != NULL )
                delete m_note;

        if( m_note_wrench != NULL )
                delete m_note_wrench;

        if( m_extra_notepage != NULL )
                delete m_extra_notepage;
    //
    // Bug 39861 :  The app crashes AFTER the above code is executed!
    // (only if bogus paths are entered on command line, and mostly only in the UNICODE
    //  version!!)
    // Time to try quick and dirty workarounds!
#if 0
    ExitProcess( (UINT) m_iErrorCode );
#endif
}


//-------------------------------------------------------------------------
int CDrawApp::ExitInstance()
{
#ifndef _AFXCTL
        SaveStdProfileSettings();
#endif

   if (m_hSem)
      CloseHandle(m_hSem);

        //clean up code if we were rendering
        if ( m_dwSesID!=0 && m_pIawcpe )
                {
                TRACE(TEXT("AWCPE: Release() interface object \n"));
                m_pIawcpe->Release();

                m_pIawcpe=NULL;
                if( m_hMod )
                FreeLibrary( m_hMod );
                }

   TRACE(TEXT("AWCPE: Fax cover page editor exiting with error code: '%i'\n"),m_iErrorCode);

   return m_iErrorCode;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFileOpen()
{
   //
   // If a document is open, query user for saving changes.
   //
   // This fixes part of the problem described in NT bug 53830.
   //
   CDrawDoc * pDoc = CDrawDoc::GetDoc();

#if 0

   // I really wish we could prompt for saving changes BEFORE we prompt for the file name.
   // But this MAY lead to double prompting.  If the user choses not to save on this prompt, then
   // there will be a second SAVE CHANGES prompt.

   if( pDoc && !pDoc->/*COleDocument::*/SaveModified()) return ; /// SaveModified now overridden!!
#endif

   CString newName;

   if (!DoPromptFileName(newName, AFX_IDS_OPENFILE,
     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, NULL))
        return;
   OpenDocumentFile(newName);
}


//-------------------------------------------------------------------------
CDocument* CDrawApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
#ifdef _DEBUG
   if (lpszFileName != NULL)
       TRACE1("AWCPE: opening document '%s'\n",lpszFileName);
   else
       TRACE(TEXT("AWCPE: opening new document\n"));
#endif

    BOOL OldFileVersion = TRUE ;
   _tcsupr((TCHAR *)lpszFileName);

   CString FileName = lpszFileName ;
   FileName.MakeUpper();
#if ENFORCE_FILE_EXTENSION_ON_OPEN_FILE
   CString Tail = FileName;
   if( Tail.Right(4) != TEXT( ".COV" ) && Tail.Right(4) != TEXT( ".CPE" )){
       FileName += TEXT( ".COV" );
   }
#endif
/*******************DEBUG*****************/
//      ::MessageBox( NULL, lpszFileName, "debug", MB_OK );
/*****************************************/

   if (*lpszFileName != 0) {
      CFile file;
      if (!file.Open(FileName,CFile::modeRead)) {
          if (m_dwSesID!=0) {   //rendering // Not using this command line option! a-juliar
                     TRACE1("AWCPE error:  unable to find file '%s'\n",(LPCTSTR)FileName);
                         return NULL;
              }
              else {
                 CString sz;
             CString szFmt;
                 sz.LoadString(IDS_MISSING_FILE);
                 int iLength=sz.GetLength() + FileName.GetLength() + 2; //// ??????????????????
                 wsprintf(szFmt.GetBuffer(iLength), sz, (LPCTSTR)FileName);
                 szFmt.ReleaseBuffer();
                 CPEMessageBox(MSG_ERROR_MISSINGFILE, szFmt, MB_OK | MB_ICONEXCLAMATION);
              }
              return NULL;
          }
      int i = sizeof(_gheaderVer1);
      BYTE* p = new BYTE[i];
#ifdef UNICODE
      CDrawDoc::GetDoc()->m_bDataFileUsesAnsi = TRUE ;
#endif
      file.Read(p,i);
      if (memcmp(_gheaderVer1,p,i)==0) {
              CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION1;
                  TRACE(TEXT("AWCPE info:  loading version 1 document\n"));
      }
      else if (memcmp(_gheaderVer2,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION2;
             TRACE(TEXT("AWCPE info:  loading version 2 document\n"));
      }
      else if (memcmp(_gheaderVer3,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION3;
             TRACE(TEXT("AWCPE info:  loading version 3 document\n"));
      }
      else if (memcmp(_gheaderVer4,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION4;
             TRACE(TEXT("AWCPE info:  loading version 4 document\n"));
      }
      else if (memcmp(_gheaderVer5w,p,i)==0) {
#ifdef UNICODE
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION5;
             CDrawDoc::GetDoc()->m_bDataFileUsesAnsi = FALSE ;
#else
             CDrawDoc::GetDoc()->m_iDocVer = -1 ;
#endif
             TRACE(TEXT("AWCPE info:  loading version 5w document\n"));
             OldFileVersion = FALSE ;
      }
      else if (memcmp(_gheaderVer5a,p,i)==0){
          CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION5;
          TRACE(TEXT("AWCPE info:  loading version 5a document\n"));
      }
      else {
          CDrawDoc::GetDoc()->m_iDocVer=-1;
      }
      if (CDrawDoc::GetDoc()->m_iDocVer==-1) {
              if (m_dwSesID!=0) {
                     TRACE1(
                       "AWCPE error:  '%s' is not a valid version .COV file-cannot open\n",lpszFileName); // FILE EXTENSION
                     return NULL;
                  }
              CString sz;
              CString szFmt;
              sz.LoadString(IDS_INVALID_FILE);
              int iLength=sz.GetLength()+ FileName.GetLength() + 2; //?????????????????????
              wsprintf(szFmt.GetBuffer(iLength), sz, (LPCTSTR)FileName);
              szFmt.ReleaseBuffer();
              CPEMessageBox(MSG_ERROR_INVFORMAT, szFmt, MB_OK | MB_ICONEXCLAMATION);
              return NULL;
      }
           if (p)
               delete [] p;
   }

   CDocument* pDoc =  CWinApp::OpenDocumentFile((LPCTSTR)FileName); // Calls Serialize()

   if( !pDoc ) return NULL ; /// This will help fix NT bug 53830 for the case when
                             /// CDrawApp::OpenDocumentFile is called by the FRAMEWORK,
                             /// byapssing CDrawApp::OnFileNew.  When the serialization
                             /// fails, pDoc is not NULL, and this is handled below.
                             /// This is not a perfect fix --- If the document being opened
                             /// came from the MRU list, it gets removed from the MRU list.

   if( pDoc && !( CDrawDoc::GetDoc()->m_bSerializeFailed )){
       CDrawDoc::GetDoc()->UpdateAllViews(NULL);
   }
   else {
       CString sz;
       CString szFmt;
       sz.LoadString(IDS_CORRUPT_FILE);
       int iLength=sz.GetLength() + FileName.GetLength() + 2;
       wsprintf(szFmt.GetBuffer(iLength), sz, lpszFileName);
       szFmt.ReleaseBuffer();
       CPEMessageBox(MSG_ERROR_INVFORMAT, szFmt, MB_OK | MB_ICONEXCLAMATION);
       OnFileNew();
       return NULL ;
   }
   if( pDoc && OldFileVersion ){
       pDoc->SetModifiedFlag(); /// Conversion to this file format is a change worth prompting to save.
   }
   return pDoc;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFileNew()
{
   CWinApp::OnFileNew();

   if (CDrawDoc::GetDoc()->m_wOrientation!=DMORIENT_PORTRAIT) {
       CDrawDoc::GetDoc()->m_wPaperSize=DMPAPER_LETTER;
       CDrawDoc::GetDoc()->m_wOrientation=DMORIENT_PORTRAIT;
       CDrawDoc::GetDoc()->m_wScale = 100;
       CDrawDoc::GetDoc()->ComputePageSize();
   }
}


//-------------------------------------------------------------------------
BOOL CDrawApp::IsSecondInstance()
{
    m_hSem = CreateSemaphore(NULL,0,1,TEXT("AWCPE-Instance Semaphore"));
    if (m_hSem!=NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(m_hSem);
        m_hSem=NULL;
        if (::SendMessage(HWND_TOPMOST,WM_AWCPEACTIVATE,0,0)==1L)
           return TRUE;  // 1st instance app responded;  close this instance
                else
           return FALSE; // 1st instance app didnt respond; may have crashed.  open this instance.
    }
    return FALSE;
}


void CDrawApp::filter_mru_list( void )
{
        int num_files;
        int i, j;
        TCHAR keystr[100];

        num_files = m_pRecentFileList->m_nSize;

        for( i=0; i<num_files; i++ ) {
                if( m_pRecentFileList->m_arrNames[i].IsEmpty() ) // i.e. == ""
                        break;

                if( GetFileAttributes( m_pRecentFileList->m_arrNames[i] ) == 0xffffffff ) {
                        for( j=i+1; j<num_files; j++ ) {
                                m_pRecentFileList->m_arrNames[j-1] =
                                        m_pRecentFileList->m_arrNames[j];
                        }

                        m_pRecentFileList->m_arrNames[j-1] = "";

                        i--; // back up so we start at first one that got schooted
                        }
                }

        if ( i < num_files ) {
                // have to clean up ini or they might come back next time
                for( ;i < num_files; i++ ) {
                        wsprintf( keystr, m_pRecentFileList->m_strEntryFormat, i+1 ); //???????????

                        // delete empty key
                        WriteProfileString( m_pRecentFileList->m_strSectionName,
                                                                keystr, NULL );
                        }

                // now have to write out modified list so that the right
                // keys are associated with the right names
                m_pRecentFileList->WriteList();
                }
}


//-------------------------------------------------------------------------
BOOL CDrawApp::InitInstance()
{
    SetErrorMode( SetErrorMode( 0 ) | SEM_NOALIGNMENTFAULTEXCEPT );

    ParseCmdLine();                     //1st thing done
    m_bUseDefaultDirectory = TRUE ;     // Used only the first time we open a file.
    SetRegistryKey( _T("Microsoft") );    //caused MFC to write app settings to registry

    AfxEnableWin40Compatibility();    //this app is intended for Windows 4.0 compatibility

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit()) {
        CPEMessageBox(MSG_ERROR_OLEINIT_FAILED, NULL, MB_OK | MB_ICONSTOP,IDP_OLE_INIT_FAILED);
        return FALSE;
    }

    Enable3dControls();        // loads CTL3D32.DLL
    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    filter_mru_list();

    /*
        Register the application's document templates.  Document templates
        serve as the connection between documents, frame windows and views.

                CCpeDocTemplate is a derivation of CSingleDocTemplate used to
                override some default MFC behavior. See CCpeDocTemplate::MatchDocType
                below.
         */
    CCpeDocTemplate* pDocTemplate;
    pDocTemplate = new CCpeDocTemplate(
        IDR_AWCPETYPE,
        RUNTIME_CLASS(CDrawDoc),
        RUNTIME_CLASS(CMainFrame),
        RUNTIME_CLASS(CDrawView));
    pDocTemplate->SetContainerInfo(IDR_AWCPETYPE_CNTR_IP);
    AddDocTemplate(pDocTemplate);

    EnableShellOpen();
    RegistryEntries();

    if(m_bPrintHelpScreen){
        PrintHelpScreen();
        return FALSE;
    }
    InitFaxProperties();

    if (m_bCmdLinePrint) {
       CmdLinePrint();
           return FALSE;
        }
    if (m_dwSesID!=0) {
     ////  CmdLineRender();
           return FALSE;
    }
    CDocument * pDoc = NULL ;
    if (m_szFileName.IsEmpty())
       OnFileNew();
    else {
       OnFileNew();   //m_pMainWnd needs to be initialized
       pDoc = OpenDocumentFile(m_szFileName);
    }
    if(!pDoc){
        TCHAR tmpEnv[20];
        TCHAR DefaultDir[MAX_PATH];
        DWORD InstalledType = 0 ;
        HKEY hKey = NULL;
        DWORD dwKeyValueType ;
        DWORD dwsz = sizeof(DWORD)/sizeof(BYTE) ;
        HKEY UserKey;
        TCHAR PartialPath[MAX_PATH];
        DWORD dwSize = MAX_PATH;

        //
        // this gets set by fax control panel coverpage tab
        //
        if (GetEnvironmentVariable(TEXT("ClientCoverpage"),tmpEnv,sizeof(tmpEnv)/sizeof(TCHAR)) != 0 ) {
                GetSpecialPath(CSIDL_PERSONAL, DefaultDir);
                if ((RegOpenKeyEx(HKEY_CURRENT_USER,
                                  REGKEY_FAX_SETUP,
                                  0,
                                  KEY_READ,
                                  &UserKey) == ERROR_SUCCESS) &&
                    (RegQueryValueEx(UserKey,
                                     REGVAL_CP_LOCATION,
                                     0,
                                     &dwKeyValueType,
                                     (LPBYTE)PartialPath,
                                     &dwSize) == ERROR_SUCCESS) ) {
                    lstrcat(DefaultDir,TEXT("\\"));
                    lstrcat(DefaultDir,PartialPath );
                    RegCloseKey(UserKey);
                }
        }   else {

            //
            // Set default directory to
            //     server:      %SystemRoot%\system\spool\drivers\CoverPage
            //     workstation: %SystemRoot%\system32\spool\drivers\CoverPage
            //     client:      ...\My Documents\Fax\Peronal Coverpages
            //
            if ( ERROR_SUCCESS ==
                RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REGKEY_FAX_SETUP,
                    0,
                    KEY_READ,
                    &hKey)
                && ERROR_SUCCESS ==
                    RegQueryValueEx(
                        hKey,
                        REGVAL_FAXINSTALL_TYPE,
                        0,
                        &dwKeyValueType,
                        (LPBYTE)&InstalledType,
                        &dwsz)) {
                //
                // set the default dir
                //

                if ((InstalledType & FAX_INSTALL_SERVER) || (InstalledType & FAX_INSTALL_WORKSTATION)) {
                    ExpandEnvironmentStrings( DEFAULT_COVERPAGE_DIR , DefaultDir, MAX_PATH );
                } else if (InstalledType & FAX_INSTALL_NETWORK_CLIENT) {
                    GetSpecialPath(CSIDL_PERSONAL, DefaultDir);
                    if ((RegOpenKeyEx(HKEY_CURRENT_USER,
                                      REGKEY_FAX_SETUP,
                                      0,
                                      KEY_READ,
                                      &UserKey) == ERROR_SUCCESS) &&
                        (RegQueryValueEx(UserKey,
                                         REGVAL_CP_LOCATION,
                                         0,
                                         &dwKeyValueType,
                                         (LPBYTE)PartialPath,
                                         &dwSize) == ERROR_SUCCESS) ) {
                        lstrcat(DefaultDir,TEXT("\\"));
                        lstrcat(DefaultDir,PartialPath );
                        RegCloseKey(UserKey);
                    }
                } else {
                    DefaultDir[0] = 0;
                }
            }
        }

        //
        // this invokes a copy constructor that copies the data from the array
        //
        m_szDefaultDir = DefaultDir;

        if (hKey) {
            RegCloseKey( hKey );
        }

    }

    OnIdle(0);  // updates buttons before showing the window

    if (m_pMainWnd) {
       m_pMainWnd->DragAcceptFiles();
       ((CMainFrame*)m_pMainWnd)->m_wndStatusBar.SetPaneText(1,_T(""));
       ((CMainFrame*)m_pMainWnd)->m_wndStatusBar.SetPaneText(2,_T(""));
        }

    if (!m_pMainWnd->IsIconic()) {
        CString sz = GetProfileString(TIPSECTION,TIPENTRY,_T("YES"));
            if (sz==_T("YES")) {
               CSplashTipsDlg m_SplashDlg;
               m_SplashDlg.DoModal();
            }
    }

    InitRegistry();

    m_hMoveCursor = LoadCursor(IDC_MOVE);

    return TRUE;
}


//------------------------------------------------------------------------------------------------
void CDrawApp::RegistryEntries()
{
        CString PrintCmdLine;
        CString OpenCmdLine;
        CString DefaultIconCmdLine;
        CString szBuff;
    TCHAR szExe[_MAX_PATH];
    CString strFilterExt, strFileTypeId, strFileTypeName;

    RegisterShellFileTypes();

#if _MFC_VER >= 0x0400
//  ASSERT( !GetFirstDocTemplatePosition() );
#else
    ASSERT(!m_templateList.IsEmpty());  // must have some doc templates
#endif

    ::GetModuleFileName(AfxGetInstanceHandle(), szExe, _MAX_PATH);

        PrintCmdLine.
                Format( TEXT("%s%s"), szExe, szStdPrintArg );

        OpenCmdLine.
                Format( TEXT("%s%s"), szExe, szStdOpenArg  );

        DefaultIconCmdLine.
                Format( TEXT("%s%s"), szExe, szDocIconArg  );

#if _MFC_VER >= 0x0400
    POSITION pos = GetFirstDocTemplatePosition();
#else
    POSITION pos = m_templateList.GetHeadPosition();
#endif
    if (pos != NULL)    {       //only 1 document type
#if _MFC_VER >= 0x0400
           CDocTemplate* pTemplate =
                        (CDocTemplate*)GetNextDocTemplate( pos );
#else
           CDocTemplate* pTemplate =
                        (CDocTemplate*)m_templateList.GetNext(pos);
#endif
           if (pTemplate->GetDocString(strFileTypeId,
              CDocTemplate::regFileTypeId) && !strFileTypeId.IsEmpty()) {

                if (!pTemplate->GetDocString(strFileTypeName,
                      CDocTemplate::regFileTypeName))
                        strFileTypeName = strFileTypeId;    // use id name

                ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed

                szBuff.Format( szShellOpenFmt, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)OpenCmdLine,
                                          OpenCmdLine.GetLength() );

                szBuff.Format( szShellPrintFmt, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)PrintCmdLine,
                                          PrintCmdLine.GetLength() );

                        szBuff.Format( szDocIcon, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)DefaultIconCmdLine,
                                          DefaultIconCmdLine.GetLength() );

            //delete the shell\open\ddeexec key to force second instance
                //Normally, this would be done by not calling EnableShellOpen(instead of removing the ddeexec key),
                //but there seems to be a bug in MFC or Win95 shell
                szBuff.Format( szShellDdeexecFmt, (LPCTSTR)strFileTypeId );
            ::RegDeleteKey(HKEY_CLASSES_ROOT, (LPCTSTR)szBuff);
           }
    }
}



//------------------------------------------------------------------------------------------------
void CDrawApp::InitRegistry()
{
        //set registry section
    HKEY hKey = NULL;
    DWORD dwsz;
    DWORD dwType;
    DWORD dwDisposition;
    const LPCTSTR szCmdLineExt=_T(" /SSESS_ID");

    TCHAR szExeName[_MAX_PATH + 10];
    ::GetModuleFileName(AfxGetInstanceHandle(),szExeName,_MAX_PATH);
    _tcscat(szExeName,szCmdLineExt);

    if (::RegOpenKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS) {
       if (::RegQueryValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, &dwType, NULL, &dwsz) == ERROR_SUCCESS) {
          if (dwsz==0) {
             if (::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ,(LPBYTE)szExeName, (_tcsclen(szExeName)+1) * sizeof(TCHAR)) != ERROR_SUCCESS){
                 TRACE1("AWCPE Warning: registration database update failed for key: '%s'.\n",CPE_COMMAND_LINE_KEY);
	     }
          }
//        else {      //uncomment this for debugging
//           dwsz=_countof(sz);
//           if (::RegQueryValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, &dwType, (LPBYTE)sz, &dwsz) == ERROR_SUCCESS)
//              TRACE2("AWCPE Information: commandline key contains '%s' size %lu.\n", sz, dwsz);
//        }
       }
       else {
          if (::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ,(LPBYTE)szExeName, (_tcsclen(szExeName)+1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
              TRACE1("AWCPE Warning: registration database update failed for key: '%s'.\n",CPE_COMMAND_LINE_KEY);
	  }
       }
    }
    else {
        ::RegCreateKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0,
              NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition);
        ::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ, (LPBYTE)szExeName, (_tcsclen(szExeName)+1) * sizeof(TCHAR) ); ///????????????
        TRACE1("AWCPE Information: Created and added my key '%s' \n", szExeName);
    }
}


//-------------------------------------------------------------------
void CDrawApp::CmdLinePrint()
{
    try {
       if (!Print() )
          m_iErrorCode=EXIT_FAILURE;
    }
    catch(...) {
       TRACE(TEXT("AWCPE exception in command line print\n"));
       m_iErrorCode=EXIT_FAILURE;
        }

        if (m_pMainWnd)
            m_pMainWnd->SendMessage(WM_CLOSE);
 }
//-------------------------------------------------------------------
void CDrawApp::PrintHelpScreen()
{
   CString message ;
   message.LoadString( IDS_HELP_SCREEN );
  ///// _tprintf( (LPCTSTR) message );   ///// Doesn't work.
  AfxMessageBox( message );
  ///// _tprintf( TEXT( "Wouldn't a help screen be nice here?\n"));
}

//-------------------------------------------------------------------
///#if 0
void CDrawApp::CmdLineRender()
{
    try {
       if (! Render() )
          m_iErrorCode=EXIT_FAILURE;
    }
    catch(...) {
       TRACE(TEXT("AWCPE exception in command line print\n"));
       m_iErrorCode=EXIT_FAILURE;
        }

    if (m_pMainWnd)
           m_pMainWnd->SendMessage(WM_CLOSE);
 }
///#endif

//-------------------------------------------------------------------
BOOL CDrawApp::Print()
{
   m_nCmdShow = SW_MINIMIZE;
   OnFileNew();
   m_nCmdShow = SW_MINIMIZE;

   if (OpenDocumentFile(m_szFileName)==NULL) {
      TRACE1("AWCPE: unable to open file: '%s'\n",m_lpCmdLine);
      return FALSE;
   }

   ((CFrameWnd*)m_pMainWnd)->GetActiveView()->SendMessage(WM_COMMAND,MAKEWPARAM(ID_FILE_PRINT,0));
   return TRUE;
}



//-------------------------------------------------------------------
///#if 0
BOOL CDrawApp::Render()
{
    return FALSE ;

//
// Not sure what to do about the GetProcAddress call, so I have commented it out.
//
#if 0
    int i=1;
    TCHAR szTemp[_MAX_PATH];
    ULONG lLen=_MAX_PATH;
    LPTSTR szDLL=NULL;       //render DLL
    LPTSTR szfName=NULL;     //entry point name
    SCODE sc;
    DWORD lszDLL=_countof(szDLL);
    DWORD lszfName = _countof(szfName);
    LPVOID lpMsgBuf;
    DWORD dwType;
    BOOL bReturn=TRUE;
    HKEY hKey = NULL;
        UINT OldErrMode;
        CDocTemplate* pTemplate = NULL;
        CDrawDoc *pDoc;


    if (::RegOpenKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0,KEY_READ, &hKey) != ERROR_SUCCESS) {
            TRACE1("AWCPE Critical: registration database openkey failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }

//ALLOCATE SPACE FOR RENDER DLL AND ENTRY POINT NAME
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_DLL_KEY, 0,&dwType, NULL, &lszDLL) != ERROR_SUCCESS) {
           TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
           return FALSE;
    }
    else
        szDLL = new TCHAR[lszDLL+sizeof(TCHAR)];
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_FUNCTION_NAME_KEY, 0, &dwType, NULL, &lszfName) != ERROR_SUCCESS) {
           TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
           return FALSE;
    }
    else
           szfName = new TCHAR[lszfName+sizeof(TCHAR)]; //????????????? was TCHAR.

//FETCH RENDER DLL NAME AND ENTRY POINT NAME
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_DLL_KEY, 0,&dwType, (LPBYTE)szDLL, &lszDLL) != ERROR_SUCCESS) {
            TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_FUNCTION_NAME_KEY, 0, &dwType, (LPBYTE)szfName, &lszfName) != ERROR_SUCCESS) { ///???????
        TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }

    if (*szDLL==0 || *szfName==0) {
            TRACE(TEXT("AWCPE Warning: registration database fetch failed\n"));
            bReturn=FALSE;
                goto exit;
    }

//FETCH ENTRY POINT ADDRESS

    OldErrMode = ::SetErrorMode (SEM_FAILCRITICALERRORS);
    m_hMod = ::LoadLibrary(szDLL);
    if (m_hMod==NULL) {
       ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
          ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
       TRACE3("AWCPE error: %s %s %s\n",lpMsgBuf, szDLL, szfName);
           bReturn=FALSE;
           goto exit;
    }
    ::SetErrorMode (OldErrMode);

    AWCPESUPPORTPROC pfn;
    if ( (pfn = (AWCPESUPPORTPROC) ::GetProcAddress(m_hMod, szfName))==NULL) {
            LPVOID lpMsgBuf;
       ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
           ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
       TRACE1("AWCPE error: GetProcAddress returns %s\n",lpMsgBuf);
           bReturn=FALSE;
           goto exit;
    }

//FETCH WINDOWS OBJECT (USED TO FETCH FAX PROPERTIES)
    if ((sc=(*pfn)(m_dwSesID,&m_pIawcpe))!=S_OK) {
       LPVOID lpMsgBuf;
       ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
           ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
       TRACE1("AWCPE error: CPESupportEntry returns %8.8lx\n",sc);
           bReturn=FALSE;
           goto exit;
    }

        try
                {
                // set up innards for printing
                OnFileNew(); // CMainFrame::ActivateFrame will prevent window
                                         //   from showing

                if( (m_note_wrench = new CFaxProp( CRect( 0,0,0,0 ),
                                                                                   IDS_PROP_MS_NOTE ))
                        == NULL )
                        return( FALSE );

                // Read note so we can print it even if there are no note objects
                //      on cpe
                read_note();
                }
        catch( ... )
                {
                bReturn=FALSE;  // added 2/14/95 by v-randr
                goto exit;
                }


//LOOP THROUGH ALL RECIPIENTS
    do {

            sc = m_pIawcpe->GetProp(CPE_CONFIG_PRINT_DEVICE, &lLen, szTemp);
            if ( (sc != S_OK) || *szTemp==0) {
                   TRACE(TEXT("AWCPE.render() : GetProp for print device failed\n"));
                   bReturn=FALSE;
                   goto exit;
            }
            m_szRenderDevice=szTemp;

       sc = m_pIawcpe->GetProp(CPE_CONFIG_CPE_TEMPLATE, &lLen, szTemp);
       if ( (sc!=S_OK) || *szTemp==0) {
              TRACE(TEXT("AWCPE.render() : GetProp for template file failded\n"));
              bReturn=FALSE;
                  goto exit;
       }

       if ( !_tcschr(szTemp,(TCHAR)'\\') ) {      //prefix with extension if missing
              TCHAR szTemplate[_MAX_PATH];
              ::GetWindowsDirectory(szTemplate,MAX_PATH);
              _tcscat(szTemplate,TEXT("\\"));
              _tcscat(szTemplate,szTemp);
              _tcscpy(szTemp,szTemplate);
           }


       if( (pDoc = (CDrawDoc *)OpenDocumentFile(szTemp))==NULL) {
              bReturn=FALSE;
                  goto exit;
           }


           // move all "sent pages" prop obs to end of list so extra
           // pages calc can be done after all motes have printed.
           pDoc->schoot_faxprop_toend( IDS_PROP_MS_NOPG );

       TRACE1("AWCPE:  SendMessage to print recipient #%i\n",i);

        try
                {
        ((CFrameWnd*)m_pMainWnd)->GetActiveView()->
                SendMessage(WM_COMMAND,MAKEWPARAM(ID_FILE_PRINT,0));

           // close so next one will reopen again if same name
           OnFileNew(); // CMainFrame::ActivateFrame will prevent window
                                        //   from showing

                }
        catch( ... )
                {
                bReturn=FALSE;  // added 2/14/95 by v-randr
                goto exit;
                }


           i++;
    } while (m_pIawcpe->Finish(CPE_FINISH_PAGE)==CPE_NEXT_PAGE);


exit:
        if( !bReturn && (m_pIawcpe != NULL) )      // added 2/1/95 by v-randr
                m_pIawcpe->Finish( CPE_FINISH_ERROR ); // added 2/1/95 by v-randr

    if (szDLL)
       delete [] szDLL;
    if (szfName)
       delete [] szfName;

    return bReturn;
#endif
 }
///#endif




void CDrawApp::read_note( void )
        {
    SCODE sc;
    TCHAR note_filename[_MAX_PATH];
    ULONG lLen;
        CFile note_file;
        DWORD filelen, actuallen;

        if( (m_dwSesID == 0)||(m_pIawcpe == NULL) )
                return;

        if( m_note != NULL )
                {
                delete m_note;
                m_note = NULL;
                }

        m_note_wasread = FALSE;
        m_note_wasclipped = FALSE;

        sc =
                m_pIawcpe->
                        GetProp( CPE_MESSAGE_BODY_FILENAME, &lLen, NULL );
        if( sc != S_OK )
                {
                /***CAN'T GET FILENAME LENGTH***/
                /******NEED SOME KIND OF ERROR HERE*******/
                //::MessageBox( NULL, "lLen is zip", "debug", MB_OK );
        throw "read_note failed";
                }

        if( lLen == 0 )
                return; // no note to read

        if( lLen > _MAX_PATH )
                {
                /***NAME TOO LONG***/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw "read_note failed";
                }

        sc =
                m_pIawcpe->
                        GetProp( CPE_MESSAGE_BODY_FILENAME, &lLen, note_filename );
        if( sc != S_OK )
                {
                /***CAN'T GET FILENAME***/
                /******NEED SOME KIND OF ERROR HERE*******/
                //::MessageBox( NULL, "can't get filename", "debug", MB_OK );
        throw "read_note failed";
                }

        //::MessageBox( NULL, note_filename, "debug", MB_OK );

        // try to open the file
        if( !note_file.Open( (LPCTSTR)note_filename,
                                                  CFile::modeRead|CFile::shareDenyNone,
                                                  NULL ) )
                {
                /***CAN'T OPEN FILE***/
                /******NEED SOME KIND OF ERROR HERE*******/
                //::MessageBox( NULL, "can't open file", "debug", MB_OK );
        throw "read_note failed";
                }

        TRY
                filelen = note_file.GetLength();
        CATCH_ALL( e )
                {
                /***CAN'T GET FILE LENGTH***/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw;
                }
        END_CATCH_ALL


        m_note = new TCHAR[ filelen + sizeof (TCHAR) ];
        if( m_note == NULL )
                {
                /**CAN'T MAKE NOTE BUFFER**/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw "read_note failed";
                }


        TRY
                actuallen = note_file.ReadHuge( m_note, filelen );

        CATCH_ALL( e )
                {
                /**CAN'T READ NOTE**/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw;
                }
        END_CATCH_ALL

        *(m_note + actuallen) = _T('\0');
        reset_note();
        m_note_wasread = TRUE;


        note_file.Close();
        }




void CDrawApp::reset_note( void )
        {

        if( m_note != NULL )
                {
                m_note_wrench->SetText( CString( m_note ), NULL );
                m_more_note = TRUE;
                }
        else
                m_more_note = FALSE;

        }




int CDrawApp::clip_note( CDC *pdc,
                                                 LPTSTR *drawtext, LONG *numbytes,
                                                 BOOL   delete_usedtext,
                                                 LPRECT drawrect )
        /*
                Sets drawtext to the next page's worth of note text. Returns
                how many pages are left if delete_usedtext is TRUE. If FALSE,
                the page count includes the current page.
         */
        {
        TEXTMETRIC tm;
        LONG boxheight;
        LONG boxwidth;
        LONG numlines;
        int  total_lines;

        m_note_wasclipped = TRUE;
        *drawtext = NULL;
        *numbytes = 0;

        if( !more_note() )
                return( 0 );

        if( !pdc->GetTextMetrics( &tm ) )
                {
                m_more_note = FALSE;
                return( 0 );
                }

        boxheight = drawrect->bottom - drawrect->top;
        boxwidth = drawrect->right - drawrect->left;

        numlines = boxheight/tm.tmHeight;
        if( numlines <= 0 )
                return( 0 );

        m_note_wrench->m_pEdit->SetFont( pdc->GetCurrentFont(), FALSE );
        m_note_wrench->m_position = *drawrect;
        m_note_wrench->FitEditWnd( NULL, FALSE, pdc );

        total_lines = m_note_wrench->GetText( numlines, delete_usedtext );

        m_more_note = (total_lines > 0);

        *drawtext = m_note_wrench->GetRawText();
        *numbytes = lstrlen( *drawtext );

        // return number of pages left
        if( total_lines > 0 )
                return( (total_lines-1)/numlines + 1 );
        else
                return( 0 );

        }








TCHAR *CDrawApp::
        pos_to_strptr( TCHAR *src, long pos,
                                   TCHAR break_char,
                                   TCHAR **last_break, long *last_break_pos )
        /*
                Used for DBCS fiddling. Find str loc for char at pos.

                        pos == 0 -> 1st char,
                        pos == 1 -> 2st char,
                        etc.

                Returned ptr will point at char
                                                                           [pos]

                *last_break will point to last break_char found before
                char
                        [pos]

                If last_break is NULL it is ignored.

         */
        {
        TCHAR *last_break_ptr = NULL;
        long i;

        if( *src == break_char )
                last_break_ptr = src;

        for( i=0; i<pos; i++ )
                {
                src = CharNext( src );
                if( *src == _T('\0') )
                        break;

                if( *src == break_char )
                        {
                        last_break_ptr = src;
                        *last_break_pos = i;
                        }
                }

        if( last_break != NULL )
                *last_break = last_break_ptr;

        return( src );

        }




//-------------------------------------------------------------------
void CDrawApp::ParseCmdLine()
{
#ifdef _DEBUG
    if (m_lpCmdLine){
       TRACE(TEXT("AWCPE:  command line: '%s'\n"),m_lpCmdLine);
    }
#endif

    m_bCmdLinePrint=FALSE;
    m_bPrintHelpScreen=FALSE;
    m_dwSesID=0;
    m_szDefaultDir=_T("");
    m_szFileName=_T("");

    TCHAR **argv ; /////////= __argv;    /////////????????????????????
    int iArgs ;    ///////////=__argc;   /////////????????????????????

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &iArgs );
#else
    argv = __argv;
    iArgs = __argc;
#endif

    if (m_lpCmdLine==NULL || *m_lpCmdLine==0){
           return;
    }
    for (int i=1; i < iArgs; i++) {
        _tcsupr(*(argv+i));
        if (_tcsstr(*(argv+i),TEXT("/P"))) {
            m_bCmdLinePrint=TRUE;
            TRACE(TEXT("AWCPE:  command line printing mode set\n"));
        }
        else if (_tcsstr(*(argv+i),TEXT("/?"))) {
            //// TODO: Display help screen and quit.
            m_bPrintHelpScreen = TRUE ;
            TRACE(TEXT("AWCPE: help screen mode set\n"));
        }
#if 0
        else if (_tcsstr(*(argv+i),TEXT("/S"))) {
            m_dwSesID=atol(((const char*)(*(argv+i) + lstrlen(_T("/S"))*sizeof(TCHAR))));     //get session id
            TRACE(TEXT("AWCPE:  render mode set\n"));
        }
#endif
        else if (_tcsstr(*(argv+i),TEXT("/W"))) {
            TCHAR szDir[_MAX_PATH];
                    ::GetWindowsDirectory(szDir,MAX_PATH);
            m_szDefaultDir=szDir;
            TRACE1("AWCPE:  default directory set to '%s'\n",m_szDefaultDir);
        }
        else {
               m_szFileName = *(argv+i);
        }
    }
    if (m_szFileName.GetLength() > 0) {
        TCHAR szDrive[_MAX_DRIVE];
        TCHAR szDir[_MAX_DIR];
        TCHAR szFName[_MAX_FNAME];
        TCHAR szExt[_MAX_EXT];
        _tsplitpath(m_szFileName,szDrive,szDir,szFName,szExt);
        if (_tcsclen(szDir)>0 && m_szDefaultDir.GetLength()<= 0)
        m_szDefaultDir=szDir;    ////// Wrong!!!!!!! a-juliar, 8-27-96
        m_szDefaultDir = szDrive ;
        m_szDefaultDir += szDir ;

    }

//      if (!m_szFileName.IsEmpty()) {
//          if (m_szFileName[m_szFileName.GetLength()-1]==(TCHAR)' ') {
//              *(lp+j-1)=(TCHAR)'\0';
//              m_szFileName.ReleaseBuffer();
//          }
//      }
#ifdef UNICODE
    LocalFree( argv );
#endif
}


//-------------------------------------------------------------------------
//Add properties to dictionary
//  (1) CProp, param 1:  string table index of description
//  (2) CProp, param 2:  length of property, in characters
//  (3) CProp, param 3:  width of property, in lines
//  (4) CProp, param 4:  index to property value (obtained via transport(awcpesup.h))
//-------------------------------------------------------------------------
#if 0
void CDrawApp::InitFaxProperties()  // The default numbers here work fine in English.
{
   static CProp recipient_name(IDS_PROP_RP_NAME,35,1,IDS_CAPT_RP_NAME,CPE_RECIPIENT_NAME);
   static CProp recipient_fxno(IDS_PROP_RP_FXNO,35,1,IDS_CAPT_RP_FXNO,CPE_RECIPIENT_FAX_PHONE);
   static CProp recipient_comp(IDS_PROP_RP_COMP,35,1,IDS_CAPT_RP_COMP,CPE_RECIPIENT_COMPANY);
   static CProp recipient_addr(IDS_PROP_RP_ADDR,35,1,IDS_CAPT_RP_ADDR,CPE_RECIPIENT_STREET_ADDRESS);
   static CProp recipient_pobx(IDS_PROP_RP_POBX,20,1,IDS_CAPT_RP_POBX,CPE_RECIPIENT_POST_OFFICE_BOX);
   static CProp recipient_city(IDS_PROP_RP_CITY,30,1,IDS_CAPT_RP_CITY,CPE_RECIPIENT_LOCALITY);
   static CProp recipient_stat(IDS_PROP_RP_STAT,25,1,IDS_CAPT_RP_STAT,CPE_RECIPIENT_STATE_OR_PROVINCE);
   static CProp recipient_zipc(IDS_PROP_RP_ZIPC,25,1,IDS_CAPT_RP_ZIPC,CPE_RECIPIENT_POSTAL_CODE);
   static CProp recipient_ctry(IDS_PROP_RP_CTRY,25,1,IDS_CAPT_RP_CTRY,CPE_RECIPIENT_COUNTRY);
   static CProp recipient_titl(IDS_PROP_RP_TITL,20,1,IDS_CAPT_RP_TITL,CPE_RECIPIENT_TITLE);
   static CProp recipient_dept(IDS_PROP_RP_DEPT,35,1,IDS_CAPT_RP_DEPT,CPE_RECIPIENT_DEPARTMENT);
   static CProp recipient_offi(IDS_PROP_RP_OFFI,35,1,IDS_CAPT_RP_OFFI,CPE_RECIPIENT_OFFICE_LOCATION);
   static CProp recipient_htel(IDS_PROP_RP_HTEL,40,1,IDS_CAPT_RP_HTEL,CPE_RECIPIENT_HOME_PHONE);
   static CProp recipient_otel(IDS_PROP_RP_OTEL,40,1,IDS_CAPT_RP_OTEL,CPE_RECIPIENT_WORK_PHONE);
   static CProp recipient_tols(IDS_PROP_RP_TOLS,50,3,IDS_CAPT_RP_TOLS,CPE_RECIPIENT_TO_LIST);
   static CProp recipient_ccls(IDS_PROP_RP_CCLS,50,3,IDS_CAPT_RP_CCLS,CPE_RECIPIENT_CC_LIST);
   static CProp message_subj(IDS_PROP_MS_SUBJ,50,2,IDS_CAPT_MS_SUBJ,CPE_MESSAGE_SUBJECT);
   static CProp message_tsnt(IDS_PROP_MS_TSNT,25,1,IDS_CAPT_MS_TSNT,CPE_MESSAGE_SUBMISSION_TIME);
   static CProp message_nopg(IDS_PROP_MS_NOPG,15,1,IDS_CAPT_MS_NOPG,CPE_COUNT_PAGES);
   static CProp message_noat(IDS_PROP_MS_NOAT,23,1,IDS_CAPT_MS_NOAT,CPE_COUNT_ATTACHMENTS);
   static CProp message_bcod(IDS_PROP_MS_BCOD,30,1,IDS_CAPT_MS_BCOD,CPE_MESSAGE_BILLING_CODE);
   static CProp message_text(IDS_PROP_MS_TEXT,40,8,IDS_CAPT_MS_TEXT,CPE_MESSAGE_BILLING_CODE); //CPE constant needs updating
   static CProp message_note(IDS_PROP_MS_NOTE,90,12,IDS_CAPT_MS_NOTE,CPE_MESSAGE_NOTE);
   static CProp sender_name(IDS_PROP_SN_NAME,35,1,IDS_CAPT_SN_NAME,CPE_SENDER_NAME);
   static CProp sender_fxno(IDS_PROP_SN_FXNO,35,1,IDS_CAPT_SN_FXNO,CPE_SENDER_FAX_PHONE);
   static CProp sender_comp(IDS_PROP_SN_COMP,25,1,IDS_CAPT_SN_COMP,CPE_SENDER_COMPANY);
   static CProp sender_addr(IDS_PROP_SN_ADDR,35,6,IDS_CAPT_SN_ADDR,CPE_SENDER_ADDRESS);
   static CProp sender_titl(IDS_PROP_SN_TITL,20,1,IDS_CAPT_SN_TITL,CPE_SENDER_TITLE);
   static CProp sender_dept(IDS_PROP_SN_DEPT,35,1,IDS_CAPT_SN_DEPT,CPE_SENDER_DEPARTMENT);
   static CProp sender_offi(IDS_PROP_SN_OFFI,35,1,IDS_CAPT_SN_OFFI,CPE_SENDER_OFFICE_LOCATION);
   static CProp sender_htel(IDS_PROP_SN_HTEL,35,1,IDS_CAPT_SN_HTEL,CPE_SENDER_HOME_PHONE);
   static CProp sender_otel(IDS_PROP_SN_OTEL,35,1,IDS_CAPT_SN_OTEL,CPE_SENDER_WORK_PHONE);
   m_pFaxMap=new CFaxPropMap;
}
#else
void CDrawApp::InitFaxProperties()  // Make some numbers too small for test purposes.
{
   static CProp recipient_name(IDS_PROP_RP_NAME,15,1,IDS_CAPT_RP_NAME,CPE_RECIPIENT_NAME);
   static CProp recipient_fxno(IDS_PROP_RP_FXNO,15,1,IDS_CAPT_RP_FXNO,CPE_RECIPIENT_FAX_PHONE);
   static CProp recipient_comp(IDS_PROP_RP_COMP,5,1,IDS_CAPT_RP_COMP,CPE_RECIPIENT_COMPANY);
   static CProp recipient_addr(IDS_PROP_RP_ADDR,35,1,IDS_CAPT_RP_ADDR,CPE_RECIPIENT_STREET_ADDRESS);
   static CProp recipient_pobx(IDS_PROP_RP_POBX,20,1,IDS_CAPT_RP_POBX,CPE_RECIPIENT_POST_OFFICE_BOX);
   static CProp recipient_city(IDS_PROP_RP_CITY,5,1,IDS_CAPT_RP_CITY,CPE_RECIPIENT_LOCALITY);
   static CProp recipient_stat(IDS_PROP_RP_STAT,5,1,IDS_CAPT_RP_STAT,CPE_RECIPIENT_STATE_OR_PROVINCE);
   static CProp recipient_zipc(IDS_PROP_RP_ZIPC,5,1,IDS_CAPT_RP_ZIPC,CPE_RECIPIENT_POSTAL_CODE);
   static CProp recipient_ctry(IDS_PROP_RP_CTRY,5,1,IDS_CAPT_RP_CTRY,CPE_RECIPIENT_COUNTRY);
   static CProp recipient_titl(IDS_PROP_RP_TITL,20,1,IDS_CAPT_RP_TITL,CPE_RECIPIENT_TITLE);
   static CProp recipient_dept(IDS_PROP_RP_DEPT,5,1,IDS_CAPT_RP_DEPT,CPE_RECIPIENT_DEPARTMENT);
   static CProp recipient_offi(IDS_PROP_RP_OFFI,5,1,IDS_CAPT_RP_OFFI,CPE_RECIPIENT_OFFICE_LOCATION);
   static CProp recipient_htel(IDS_PROP_RP_HTEL,4,1,IDS_CAPT_RP_HTEL,CPE_RECIPIENT_HOME_PHONE);
   static CProp recipient_otel(IDS_PROP_RP_OTEL,4,1,IDS_CAPT_RP_OTEL,CPE_RECIPIENT_WORK_PHONE);
   static CProp recipient_tols(IDS_PROP_RP_TOLS,50,3,IDS_CAPT_RP_TOLS,CPE_RECIPIENT_TO_LIST);
   static CProp recipient_ccls(IDS_PROP_RP_CCLS,50,3,IDS_CAPT_RP_CCLS,CPE_RECIPIENT_CC_LIST);
   static CProp message_subj(IDS_PROP_MS_SUBJ,50,2,IDS_CAPT_MS_SUBJ,CPE_MESSAGE_SUBJECT);
   static CProp message_tsnt(IDS_PROP_MS_TSNT,5,1,IDS_CAPT_MS_TSNT,CPE_MESSAGE_SUBMISSION_TIME);
   static CProp message_nopg(IDS_PROP_MS_NOPG,5,1,IDS_CAPT_MS_NOPG,CPE_COUNT_PAGES);
   static CProp message_noat(IDS_PROP_MS_NOAT,23,1,IDS_CAPT_MS_NOAT,CPE_COUNT_ATTACHMENTS);
   static CProp message_bcod(IDS_PROP_MS_BCOD,30,1,IDS_CAPT_MS_BCOD,CPE_MESSAGE_BILLING_CODE);
   static CProp message_text(IDS_PROP_MS_TEXT,40,8,IDS_CAPT_MS_TEXT,CPE_MESSAGE_BILLING_CODE); //CPE constant needs updating
   static CProp message_note(IDS_PROP_MS_NOTE,90,12,IDS_CAPT_MS_NOTE,CPE_MESSAGE_NOTE);
   static CProp sender_name(IDS_PROP_SN_NAME,5,1,IDS_CAPT_SN_NAME,CPE_SENDER_NAME);
   static CProp sender_fxno(IDS_PROP_SN_FXNO,5,1,IDS_CAPT_SN_FXNO,CPE_SENDER_FAX_PHONE);
   static CProp sender_comp(IDS_PROP_SN_COMP,5,1,IDS_CAPT_SN_COMP,CPE_SENDER_COMPANY);
   static CProp sender_addr(IDS_PROP_SN_ADDR,35,6,IDS_CAPT_SN_ADDR,CPE_SENDER_ADDRESS);
   static CProp sender_titl(IDS_PROP_SN_TITL,5,1,IDS_CAPT_SN_TITL,CPE_SENDER_TITLE);
   static CProp sender_dept(IDS_PROP_SN_DEPT,5,1,IDS_CAPT_SN_DEPT,CPE_SENDER_DEPARTMENT);
   static CProp sender_offi(IDS_PROP_SN_OFFI,5,1,IDS_CAPT_SN_OFFI,CPE_SENDER_OFFICE_LOCATION);
   static CProp sender_htel(IDS_PROP_SN_HTEL,5,1,IDS_CAPT_SN_HTEL,CPE_SENDER_HOME_PHONE);
   static CProp sender_otel(IDS_PROP_SN_OTEL,5,1,IDS_CAPT_SN_OTEL,CPE_SENDER_WORK_PHONE);
   m_pFaxMap=new CFaxPropMap;
}
#endif


//-------------------------------------------------------------------------
BOOL CDrawApp::DoFilePageSetup(CMyPageSetupDialog& dlg)
{
   UpdatePrinterSelection(FALSE);

     dlg.m_psd.hDevMode = m_hDevMode;
     dlg.m_psd.hDevNames = m_hDevNames;

   if (dlg.DoModal() != IDOK)
      return FALSE;

   m_hDevMode=dlg.m_psd.hDevMode;
   m_hDevNames=dlg.m_psd.hDevNames;

   return TRUE;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFilePageSetup()
{
   WORD old_orientation;
   WORD old_papersize;
   WORD old_scale;
   CDrawDoc *pdoc = CDrawDoc::GetDoc();

   CMyPageSetupDialog dlg;
   if (dlg.m_pPageSetupDlg) {
      if (!DoFilePageSetup(dlg))
         return;
   }
   else
      CWinApp::OnFilePrintSetup();                //call printsetup if no existing page setup

   // save old ones so we can do a dirty check
   old_orientation = pdoc->m_wOrientation;
   old_papersize   = pdoc->m_wPaperSize;
   old_scale       = pdoc->m_wScale;

   // get (possibly) new values
   LPDEVMODE  lpDevMode = (m_hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(m_hDevMode) : NULL;
   pdoc->m_wOrientation =lpDevMode->dmOrientation;
   pdoc->m_wPaperSize   =lpDevMode->dmPaperSize;


/** DISABLE SCALEING - SEE 2868's BUG LOG **/
   if( FALSE )//lpDevMode->dmFields & DM_SCALE  )
           {
           // change scale only if printer supports it
       pdoc->m_wScale = lpDevMode->dmScale;
           }


   // dirty check
   if( (pdoc->m_wOrientation != old_orientation)||
           (pdoc->m_wPaperSize   != old_papersize)||
       (pdoc->m_wScale       != old_scale)
           )
           pdoc->SetModifiedFlag();

   if (m_hDevMode != NULL)
     ::GlobalUnlock(m_hDevMode);

   pdoc->ComputePageSize();
}

//-------------------------------------------------------------------------
void CDrawApp::OnAppAbout()
{
       CString sz;

       sz.LoadString(IDS_MESSAGE);

        ::ShellAbout( AfxGetMainWnd()->m_hWnd, sz,  TEXT(""), LoadIcon( IDR_AWCPETYPE ) );
}



//--------------------------------------------------------------------------------
static void AppendFilterSuffix(CString& filter, OPENFILENAME_NT4& ofn,
        CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
        ASSERT_VALID(pTemplate);
        ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

        CString strFilterExt, strFilterName;
        if (pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt) &&
         !strFilterExt.IsEmpty() &&
         pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
         !strFilterName.IsEmpty())
        {
                // a file based document template - add to filter list
#ifndef _MAC
                ASSERT(strFilterExt[0] == '.');
#endif
                if (pstrDefaultExt != NULL)
                {
                        // set the default extension
#ifndef _MAC
                        *pstrDefaultExt = ((LPCTSTR)strFilterExt) + 1;  // skip the '.'
#else
                        *pstrDefaultExt = strFilterExt;
#endif
                        ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
                        ofn.nFilterIndex = ofn.nMaxCustFilter + 1;  // 1 based number
                }

                // add to filter
                filter += strFilterName;
                ASSERT(!filter.IsEmpty());  // must have a file type name
                filter += (TCHAR)'\0';  // next string please
#ifndef _MAC
                filter += (TCHAR)'*';
#endif
                filter += strFilterExt;
                filter += (TCHAR)'\0';  // next string please
                ofn.nMaxCustFilter++;
        }
}

//--------------------------------------------------------------------------------
BOOL CDrawApp::DoPromptFileName(
    CString& fileName,
    UINT nIDSTitle,
    DWORD lFlags,
    BOOL bOpenFileDialog,
    CDocTemplate* pTemplate)
{
    CFileDialog dlgFile(bOpenFileDialog);

    CString title;
    VERIFY(title.LoadString(nIDSTitle));

    dlgFile.m_ofn.Flags |= lFlags;

    if (m_szDefaultDir.GetLength()>0 && m_bUseDefaultDirectory){   //added to set initial directory
        dlgFile.m_ofn.lpstrInitialDir = m_szDefaultDir;
    }

//////////   dlgFile.m_ofn.lpstrInitialDir = TEXT( "\\%SystemRoot%" );

    CString strFilter;
    CString strDefault;
    if (pTemplate != NULL) {
        ASSERT_VALID(pTemplate);
        AppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate, &strDefault);
    }
    else  {
      // do for all doc template
#if _MFC_VER >= 0x0400
        POSITION pos = GetFirstDocTemplatePosition();
        while (pos != NULL)  {
            AppendFilterSuffix(
                strFilter,
                dlgFile.m_ofn,
                (CDocTemplate*)GetNextDocTemplate( pos ),
                NULL
                );
        }
#else
        POSITION pos = m_templateList.GetHeadPosition();
        while (pos != NULL)  {
            AppendFilterSuffix(
                strFilter,
                dlgFile.m_ofn,
                (CDocTemplate*)m_templateList.GetNext(pos),
                NULL
                );
        }
#endif
    }

/// Begin a-juliar's new block
    if ( nIDSTitle == AFX_IDS_OPENFILE ){
        //
        // append the "*.cpe" filter -- Windows 95 Cover Page Files -- 9-20-96 a-juliar
        //
        CString Win95filter ;
        VERIFY( Win95filter.LoadString( IDS_OLD_FILE_FILTER ));
        strFilter += Win95filter ;
        strFilter += (TCHAR)'\0';    // next string please
#ifndef _MAC
        strFilter += _T("*.cpe");     /////
#else
        strFilter += _T( "cpe" );    ///// for a MacIntosh ?? do we need this to be right??
#endif
        dlgFile.m_ofn.nMaxCustFilter++;
        strFilter += (TCHAR)'\0';   // next string please
    }
/// End a-juliar's new block

#if SHOW_ALL_FILES_FILTER

    // begin block to append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';    // next string please

#ifndef _MAC
    strFilter += _T("*.*");
#else
    strFilter += _T("****");
#endif

    dlgFile.m_ofn.nMaxCustFilter++;
/// End block appending the all files filter
#endif
    strFilter += (TCHAR)'\0';    // last string
    dlgFile.m_ofn.nMaxCustFilter++;
    dlgFile.m_ofn.lpstrDefExt = TEXT( "COV" ); // Fix bug 57706
    dlgFile.m_ofn.lpstrFilter = strFilter;
#ifndef _MAC
    dlgFile.m_ofn.lpstrTitle = title;
#else
    dlgFile.m_ofn.lpstrPrompt = title;
#endif
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
 /////  m_szDefaultDir = dlgFile.m_ofn.lpstrInitialDir  ; /// Will the new current dir be used?? NO! Unfortunately!
    m_bUseDefaultDirectory = FALSE ; //// After first time, use the CURRENT DIRECTORY instead.
    fileName.ReleaseBuffer();
    return bResult;
}








//Map for CS help system
DWORD cshelp_map[] =
{
    IDC_CB_DRAWBORDER,  IDC_CB_DRAWBORDER,
        IDC_LB_THICKNESS,       IDC_LB_THICKNESS,
        IDC_LB_LINECOLOR,       IDC_LB_LINECOLOR,
        IDC_RB_FILLTRANS,       IDC_RB_FILLTRANS,
        IDC_RB_FILLCOLOR,       IDC_RB_FILLCOLOR,
        IDC_LB_FILLCOLOR,       IDC_LB_FILLCOLOR,
        IDC_LB_TEXTCOLOR,       IDC_LB_TEXTCOLOR,
        IDC_GRP_FILLCOLOR,  IDC_COMM_GROUPBOX,
        IDC_ST_TEXTCOLOR,   IDC_COMM_STATIC,
        IDC_ST_THICKNESS,   IDC_COMM_STATIC,
        IDC_ST_COLOR,       IDC_COMM_STATIC,
    0,0
};




//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawApp, CWinApp)
   //{{AFX_MSG_MAP(CDrawApp)
   ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
   //}}AFX_MSG_MAP
   // Standard file based document commands
   ON_COMMAND(ID_FILE_NEW, OnFileNew)
   ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
   ON_COMMAND(ID_FILE_SAVE, CDrawDoc::OnFileSave)
   ON_COMMAND(ID_FILE_SAVE_AS, CDrawDoc::OnFileSaveAs)
   // Standard print setup command
   ON_COMMAND(ID_FILE_PAGE_SETUP, OnFilePageSetup)
   ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
/// Experimental entries --- a-juliar, 7-18-96
   ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex )
//   ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing )
   ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex )
   ON_COMMAND(ID_HELP, CWinApp::OnHelp )
END_MESSAGE_MAP()






/*
        This override of MatchDocType forces MFC to reload a file that is
        already loaded and that has been modified. MFC will put up the
        standard "save changes?" dialog before reloading the file.

        This defeats MFC's default behavior of just doing nothing if you
        try to FileOpen a file that is already opened.

        This was done to fix bug 2628.
 */
#ifndef _MAC
CDocTemplate::Confidence CCpeDocTemplate::
        MatchDocType( LPCTSTR lpszPathName,
                                  CDocument*& rpDocMatch )
#else
CDocTemplate::Confidence CCpeDocTemplate::
        MatchDocType(LPCTSTR lpszFileName, DWORD dwFileType,
                                 CDocument*& rpDocMatch)
#endif
        {
        CDocTemplate::Confidence congame;

        congame =
#ifndef _MAC
                CSingleDocTemplate::MatchDocType( lpszPathName, rpDocMatch );
#else
                CSingleDocTemplate::MatchDocType( lpszFileName, dwFileType,
                                                                                  rpDocMatch );
#endif


        if( congame == CDocTemplate::yesAlreadyOpen )
                {
                if( rpDocMatch->IsModified() )
                        {
                        // force a reload after "save changes?" dialog
                        congame = CDocTemplate::yesAttemptNative;
                        rpDocMatch = NULL;
                        }
                }

        return( congame );

        }/* CCpeDocTemplate::MatchDocType */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\renderer\prtcovpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prtcovpg.c

Abstract

    Three componants of the composite page description file:
      1)  A header describing the other two componants.
      2)  An embebbed meta file of the page description objects.
      3)  Text strings (or resource ID's of string data
          requiring substitution of user data passed in to the
          function).

    Routine parses componants of composite page description file as
    created by the Windows NT "FaxCover" application; renders the
    objects to the DC, if hdc is not NULL.

Author:

    Julia J. Robinson

Revision History:

    Julia J. Robinson 6-7-96
    Julia J. Robinson 9-20-96       Allow passing paper size and orientation.

Environment:

    Windows NT


--*/

#include <windows.h>
#include <commdlg.h>
#include <winspool.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "prtcovpg.h"
#include "resource.h"


#define INITIAL_SIZE_OF_STRING_BUFFER 64
#define NOTE_INDEX  22        // Index of "{Note}"  in the InsertionTitle array.

BYTE  UNICODE_Signature[20]= {0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};


//
// Resource ID's corresponding to fields of USERDATA.
//

WORD InsertionTagResourceID[]=
{
    IDS_PROP_RP_NAME,                           // "{Recipient Name}"
    IDS_PROP_RP_FXNO,                           // "{Recipient Fax Number}"
    IDS_PROP_RP_COMP,                           // "{Recipient's Company}"
    IDS_PROP_RP_ADDR,                           // "{Recipient's Street Address}"
    IDS_PROP_RP_CITY,                           // "{Recipient's City}"
    IDS_PROP_RP_STAT,                           // "{Recipient's State}"
    IDS_PROP_RP_ZIPC,                           // "{Recipient's Zip Code}"
    IDS_PROP_RP_CTRY,                           // "{Recipient's Country}"
    IDS_PROP_RP_TITL,                           // "{Recipient's Title}"
    IDS_PROP_RP_DEPT,                           // "{Recipient's Department}"
    IDS_PROP_RP_OFFI,                           // "{Recipient's Office Location}"
    IDS_PROP_RP_HTEL,                           // "{Recipient's Home Telephone #}"
    IDS_PROP_RP_OTEL,                           // "{Recipient's Office Telephone #}"
    IDS_PROP_SN_NAME,                           // "{Sender Name}"
    IDS_PROP_SN_FXNO,                           // "{Sender Fax #}"
    IDS_PROP_SN_COMP,                           // "{Sender's Company}"
    IDS_PROP_SN_ADDR,                           // "{Sender's Address}"
    IDS_PROP_SN_TITL,                           // "{Sender's Title}"
    IDS_PROP_SN_DEPT,                           // "{Sender's Department}"
    IDS_PROP_SN_OFFI,                           // "{Sender's Office Location}"
    IDS_PROP_SN_HTEL,                           // "{Sender's Home Telephone #}"
    IDS_PROP_SN_OTEL,                           // "{Sender's Office Telephone #}"
    IDS_PROP_MS_NOTE,                           // "{Note}"
    IDS_PROP_MS_SUBJ,                           // "{Subject}"
    IDS_PROP_MS_TSNT,                           // "{Time Sent}"
    IDS_PROP_MS_NOPG,                           // "{# of Pages}"
    IDS_PROP_RP_TOLS,                           // "{To: List}"
    IDS_PROP_RP_CCLS                            // "{Cc: List}"
};



DWORD WINAPI
PrintCoverPage(
    HDC              hDC,
    PCOVERPAGEFIELDS UserData,
    LPTSTR           CompositeFileName,
    PCOVDOCINFO      pCovDocInfo
    )

/*++

    Arguments:

        hDC                   - Device context.  If NULL, we just read the file and set *pFlags

        UserData              - pointer to a structure containing user data
                                  for text insertions.  May be NULL.

        CompositeFileName     - Name of the file created by the page editor,
                                  containing the META file.

        pCovDocInfo           - pointer to structure contining information about the cover page file.
                                This includes

                                    pCovDocInfo->NoteRect

                                        - Coordinates of the "Note" insertion rectangle, returned
                                          in device coordinates.  This will be all 0 if hDC is NULL


                                    pCovDocInfo->Flags

                                        - Returns bitwise OR of the following (or more):

                                             COVFP_NOTE      if .cov file contains a Note field.

                                             COVFP_SUBJECT   if .cov file contains a Subject field.

                                             COVFP_NUMPAGES  if .cov file contains Num Pages field.

                                    pCovDocInfo->PaperSize

                                        - may use in DEVMODE as dmPaperSize

                                    pCovDocInfo->Orientation

                                        - may use in DEVMODE as dmOrientation

                                    pCovDocInfo->NoteFont

                                        - Logfont structure to be used in rendering the NOTE.
                                          This will be meaningless if hDC is NULL.
--*/

{
    ENHMETAHEADER        MetaFileHeader;
    UINT                 HeaderSize;
    LPBYTE               pMetaFileBuffer = NULL;
    const BYTE           *pConstMetaFileBuffer;
    DWORD                rVal = ERROR_SUCCESS;
    INT                  TextBoxNbr;
    COLORREF             PreviousColor;
    INT                  PreviousMapMode;
    HFONT                hThisFont = NULL;
    HGDIOBJ              hPreviousFont;
    DWORD                NbrBytesRead;
    RECT                 ClientRect;
    RECT                 ClipRect;
    RECT                 TextRect;
    RECT                 NoteRect;
    CONST RECT           *pClipRect;
    HRGN                 ClipRegion = NULL;
    int                  CRComplexity;             // return value of SelectClipRegion
    POINT                OldWindowOrg;             // return value of SetWindowOrg()
    POINT                OldViewPortOrg;           // return value of SetViewPortOrg()
    TEXTBOX              TextBox;                  // buffer for reading in a TEXTBOX
    HENHMETAFILE         MetaFileHandle;
    HANDLE               CompositeFileHandle = INVALID_HANDLE_VALUE;
    COMPOSITEFILEHEADER  CompositeFileHeader;
    DWORD                FullPrinterWidth;         // PHYSICALWIDTH
    DWORD                FullPrinterHeight;        // PHYSICALHEIGHT
    DWORD                PrinterUnitsX;            // PHYSICALWIDTH - (width of margins)
    DWORD                PrinterUnitsY;            // PHYSICALHEIGHT - (height of margins)
    INT                  HeightDrawn;              // return value of DrawText()
    INT                  ReadBufferSize;           // size of buffer for reading in strings.
    INT                  ThisBufSize;              // size buffer needed for current text string.
    LPTSTR               pStringReadIn = NULL;     // buffer for reading in strings.
    LPTSTR               pWhichTextToRender;       // pStringReadIn v. ArrayOfData[i]
    INT                  i;                        // loop index
    LPTSTR *             ArrayOfData;              // uses pointers in UserData as ragged array.
    int                  CallersDCState = 0;       // returned by SaveDC
    int                  MyDCState = 0;            // returned by SaveDC
    DWORD                ThisBit;                  // Flag field for current index.
    DWORD                Flags;                    // Return these if pFlags != NULL.
    WORD                 MoreWords[3];             // Scale, PaperSize, and Orientation
    LOGFONT              NoteFont;                 // Logfont structure found in the NOTE box



    __try {

        //
        // Initialize return values, handles, and pointers.
        //
        NoteRect.left = 0;
        NoteRect.right = 0;
        NoteRect.top = 0;
        NoteRect.bottom = 0;
        Flags = 0;
        hThisFont = NULL;
        CompositeFileHandle = INVALID_HANDLE_VALUE;
        MyDCState = 0;
        CallersDCState = 0;

        //
        // Initialize a Pointer so that
        //
        //       ArrayOfData[0] ===== pUserData->RecName ,
        //       ArrayOfData[1] ===== pUserData->RecFaxNumber ,
        //                   ... etc. ...

        if (UserData){
            ArrayOfData = &UserData->RecName;
        }

        ZeroMemory( &CompositeFileHeader, sizeof(CompositeFileHeader) );
        ZeroMemory( &TextBox, sizeof(TextBox) );

        //
        // Open the composite data file.
        //

        CompositeFileHandle = CreateFile(
            CompositeFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (CompositeFileHandle == INVALID_HANDLE_VALUE) {
            rVal = GetLastError();
            goto exit;
        }

        if ((!ReadFile( CompositeFileHandle, &CompositeFileHeader, sizeof(CompositeFileHeader), &NbrBytesRead, NULL )) ||
            sizeof(CompositeFileHeader) != NbrBytesRead)
        {
            rVal = GetLastError();
            goto exit;
        }

        //
        // Check the 20-byte signature in the header to see if the file
        //     contains ANSI or UNICODE strings.
        //

        if (memcmp( UNICODE_Signature, CompositeFileHeader.Signature, 20 )){
            rVal = ERROR_BAD_FORMAT;
            goto exit;
        }

        //
        // Extract the embedded META file from the composite file and move
        // into meta file buffer
        //

        pMetaFileBuffer = (LPBYTE) malloc( CompositeFileHeader.EmfSize );
        if (!pMetaFileBuffer){
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if ((!ReadFile( CompositeFileHandle, pMetaFileBuffer, CompositeFileHeader.EmfSize, &NbrBytesRead, NULL ) ||
            CompositeFileHeader.EmfSize != NbrBytesRead))
        {
            rVal = GetLastError();
            goto exit;
        }

        if (hDC) {           // Rendering

            //
            // Save Device Context state
            //

            CallersDCState = SaveDC( hDC );
            if (CallersDCState == 0) {
                rVal = GetLastError();
                goto exit;
            }

            //
            // Set the client rectangle dimensions for display of the meta file
            //

            FullPrinterWidth  = GetDeviceCaps( hDC, PHYSICALWIDTH );
            PrinterUnitsX     = FullPrinterWidth - 2 * GetDeviceCaps( hDC, PHYSICALOFFSETX );
            FullPrinterHeight = GetDeviceCaps( hDC, PHYSICALHEIGHT );
            PrinterUnitsY     = FullPrinterHeight - 2 * GetDeviceCaps( hDC, PHYSICALOFFSETY );

            ClientRect.top    = CompositeFileHeader.CoverPageSize.cy / 2 ;
            ClientRect.left   = -CompositeFileHeader.CoverPageSize.cx / 2;
            ClientRect.right  = CompositeFileHeader.CoverPageSize.cx / 2;
            ClientRect.bottom = -CompositeFileHeader.CoverPageSize.cy / 2;

            //
            // Set device context appropriately for rendering both text and metafile.
            //

            PreviousMapMode = SetMapMode( hDC, MM_LOENGLISH );
            if (PreviousMapMode == 0) {
                rVal = GetLastError();
                goto exit;
            }

            if (!SetWindowOrgEx( hDC, 0, 0, &OldWindowOrg )) {
                rVal = GetLastError();
                goto exit;
            }

            if (!SetViewportOrgEx( hDC, PrinterUnitsX/2, PrinterUnitsY/2, &OldViewPortOrg )) {
                rVal = GetLastError();
                goto exit;
            }

            ClipRect = ClientRect;
            pClipRect = &ClipRect;

            LPtoDP( hDC, (POINT*)&ClipRect, 2 );
            ClipRegion = CreateRectRgnIndirect( pClipRect );
            CRComplexity = SelectClipRgn( hDC, ClipRegion );
            MyDCState = SaveDC( hDC );

            if (!CompositeFileHeader.EmfSize){
                //
                // No objects to render.
                //
                rVal = ERROR_NO_MORE_FILES;
                goto exit;
            }

            pConstMetaFileBuffer = pMetaFileBuffer;

            //
            // Create an enhanced metafile, in memory, from the data in the buffer.
            //

            MetaFileHandle = SetEnhMetaFileBits(
                CompositeFileHeader.EmfSize,
                pConstMetaFileBuffer
                );
            if (!MetaFileHandle) {
                rVal = GetLastError();
                goto exit;
            }

            //
            // verify the metafile header.
            //

            HeaderSize = GetEnhMetaFileHeader(
                MetaFileHandle,
                sizeof(ENHMETAHEADER),
                &MetaFileHeader
                );

            //
            // Check header size is at least 0x64 -> NT4 or greater version of ENHMETAHEADER
            //
            if (HeaderSize < 0x64){
                rVal = ERROR_INVALID_DATA;
                DeleteEnhMetaFile( MetaFileHandle );
                goto exit;
            }

            //
            // Render the MetaFile
            //

            if (!PlayEnhMetaFile( hDC, MetaFileHandle, &ClientRect )) {
                rVal = GetLastError();
            }

            //
            // Release the metafile handle and free the buffer.
            //

            DeleteEnhMetaFile( MetaFileHandle );

            if (rVal != ERROR_SUCCESS) {
                //
                // PlayEnhMetaFile failed.
                //
                goto exit;
            }

            //
            // Set Device Context for rendering text.
            // Undo any changes that occurred when rendering the metafile.
            //

            RestoreDC( hDC, MyDCState );
            MyDCState = 0;

            if (CLR_INVALID == SetBkMode( hDC, TRANSPARENT)){
                rVal = GetLastError();
                goto exit;
            }
        }

        //
        //  Initialize buffer for reading in strings.
        //

        ReadBufferSize = INITIAL_SIZE_OF_STRING_BUFFER;

        pStringReadIn = (LPTSTR) malloc( ReadBufferSize );
        if (!pStringReadIn) {
            rVal = GetLastError();
            goto exit;
        }

        //
        // Read in Text Box objects from the composite file and print out the text.
        //

        pWhichTextToRender = NULL;
        for (TextBoxNbr=0; TextBoxNbr < (INT) CompositeFileHeader.NbrOfTextRecords; ++TextBoxNbr){

            if ((!ReadFile( CompositeFileHandle, &TextBox, sizeof(TEXTBOX), &NbrBytesRead, NULL)) ||
                NbrBytesRead != sizeof(TEXTBOX))
            {
                rVal = GetLastError();
                goto exit;
            }

            //
            // Check buffer size, lock buffer, and
            // read in variable length string of text.
            //

            ThisBufSize = sizeof(TCHAR) * (TextBox.NumStringBytes + sizeof(TCHAR));
            if (ReadBufferSize < ThisBufSize) {
                pStringReadIn = realloc( pStringReadIn, ThisBufSize );
                if (!pStringReadIn) {
                    rVal = GetLastError();
                    goto exit;
                }
            }

            if ((!ReadFile( CompositeFileHandle, (void*)pStringReadIn, TextBox.NumStringBytes, &NbrBytesRead, NULL)) ||
                NbrBytesRead != TextBox.NumStringBytes)
            {
                rVal = GetLastError();
                goto exit;
            }

            pStringReadIn[TextBox.NumStringBytes / sizeof(TCHAR)] = 0;

            if (hDC) {

                //
                // Correct position of text box.
                //

                TextRect.top    = max( TextBox.PositionOfTextBox.top,  TextBox.PositionOfTextBox.bottom );
                TextRect.left   = min( TextBox.PositionOfTextBox.left, TextBox.PositionOfTextBox.right  );
                TextRect.bottom = min( TextBox.PositionOfTextBox.top,  TextBox.PositionOfTextBox.bottom );
                TextRect.right  = max( TextBox.PositionOfTextBox.left, TextBox.PositionOfTextBox.right  );

                pWhichTextToRender = pStringReadIn;

            }

            if (TextBox.ResourceID) {

                //
                // Text box contains a FAX PROPERTY field.
                // Find appropriate field of USERDATA for this resource ID.
                //

                for (i=0,ThisBit=1; i<NUM_INSERTION_TAGS; ++i,ThisBit<<=1) {

                    if (TextBox.ResourceID == InsertionTagResourceID[i]){
                        pWhichTextToRender = UserData ? ArrayOfData[i] : NULL;

                        //
                        // Set Flags bit to indicate this FAX PROPERTY field is present.
                        //
                        Flags |= ThisBit;
                        break;
                    }
                }

                if (TextBox.ResourceID == IDS_PROP_MS_NOTE && hDC) {
                    //
                    // NOTE field found.  Return its rectangle in device coordinates.
                    // Return its LOGFONT with height adjusted for device coordinates.
                    //

                    NoteRect = TextRect;
                    LPtoDP( hDC, (POINT*)&NoteRect, 2 );
                    NoteFont = TextBox.FontDefinition;
                    NoteFont.lfHeight = (LONG)MulDiv(
                        (int)NoteFont.lfHeight,
                        GetDeviceCaps( hDC, LOGPIXELSY ),
                        100
                        );
                }
            }

            if (hDC && pWhichTextToRender) {

                //
                // Set text color and font for rendering text.
                //

                PreviousColor = SetTextColor( hDC, TextBox.TextColor );
                if (PreviousColor == CLR_INVALID){
                    rVal = GetLastError();
                    goto exit;
                }

                hThisFont = CreateFontIndirect( &(TextBox.FontDefinition) );
                if (!hThisFont) {
                    rVal = GetLastError();
                    goto exit;
                }

                hPreviousFont = SelectObject( hDC, hThisFont );
                if (!hPreviousFont) {
                    rVal = GetLastError();
                    goto exit;
                }

                //
                // Render the text.
                //

                HeightDrawn = DrawText(
                    hDC,
                    pWhichTextToRender,
                    -1,
                    &TextRect,
                    DT_NOPREFIX | DT_WORDBREAK | (UINT)TextBox.TextAlignment
                    );
                if (!HeightDrawn) {
                    rVal = GetLastError();
                    goto exit;
                }

                //
                //  Restore previous font and release the handle to the selected font
                //

                SelectObject( hDC, (HFONT)hPreviousFont );
                SetTextColor( hDC, PreviousColor );
                DeleteObject( hThisFont );

            }

        }                                           // Ends loop over all textboxes.

        //
        // Read on to get Orientation and PaperSize
        //

        if ((!ReadFile( CompositeFileHandle, MoreWords, 3*sizeof(WORD), &NbrBytesRead, NULL )) ||
            NbrBytesRead != 3 * sizeof(WORD))
        {
            rVal = GetLastError();
            goto exit;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rVal = GetExceptionCode();
    }

exit:

    if (hThisFont) {
        DeleteObject( hThisFont );
    }

    if (pStringReadIn) {
        free( pStringReadIn );
    }

    if (pMetaFileBuffer) {
        free( pMetaFileBuffer );
    }

    if (CompositeFileHandle != INVALID_HANDLE_VALUE){
        CloseHandle( CompositeFileHandle );
    }

    if( MyDCState ){
        RestoreDC( hDC, MyDCState );
    }

    if( CallersDCState ){
        RestoreDC( hDC, CallersDCState );
    }

    if (rVal == 0 && pCovDocInfo != NULL) {
        pCovDocInfo->Flags = Flags;
        pCovDocInfo->NoteRect = NoteRect;
        pCovDocInfo->PaperSize = (short) MoreWords[1];
        pCovDocInfo->Orientation = (short) MoreWords[2];
        pCovDocInfo->NoteFont = NoteFont;
    }

    if (ClipRegion) {
        DeleteObject( ClipRegion );
    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\awcpe.h ===
//--------------------------------------------------------------------------
// AWCPE.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
//--------------------------------------------------------------------------
#ifndef __AWCPE_H__
#define __AWCPE_H__

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "awcpesup.h"
#include <stdio.h>

/*****************TEMPORARY*********************/
#define CPE_MESSAGE_NOTE        CPE_RECIPIENT_NAME
/***********************************************/



//
// Look in the registry under HKEY_LOCAL_MACHINE for the following DWORD key.  Hidden fields
//    will be enabled if their corresponding bit is set.
//
#define EFC_COVER_PAGE_FIELDS (TEXT("Software\\Microsoft\\Fax\\Setup\\EFC_CoverPageFields"))
#define COVFP_REC_COMPANY                0x00000004
#define COVFP_REC_STREET_ADDRESS         0x00000008
#define COVFP_REC_CITY                   0x00000010
#define COVFP_REC_STATE                  0x00000020
#define COVFP_REC_ZIP_CODE               0x00000040
#define COVFP_REC_COUNTRY                0x00000080
#define COVFP_REC_TITLE                  0x00000100
#define COVFP_REC_DEPARTMENT             0x00000200
#define COVFP_REC_OFFICE_LOCATION        0x00000400
#define COVFP_REC_HOME_PHONE             0x00000800
#define COVFP_REC_OFFICE_PHONE           0x00001000
#define COVFP_TO_LIST                    0x04000000
#define COVFP_CC_LIST                    0x08000000

#define _countof(array) (sizeof(array)/sizeof(array[0]))
#define GENERALSECTION _T("General")
#define TIPSECTION _T("Tips Section")
#define TIPENTRY _T("ShowTips")
#define MSGDRAWPOLY _T("Show polygon end dialog")

extern DWORD cshelp_map[];

extern BYTE BASED_CODE _gheaderVer1[20];
extern BYTE BASED_CODE _gheaderVer2[20];
extern BYTE BASED_CODE _gheaderVer3[20];
extern BYTE BASED_CODE _gheaderVer4[20];
extern BYTE BASED_CODE _gheaderVer5w[20];
extern BYTE BASED_CODE _gheaderVer5a[20];

class CMyPageSetupDialog;
class CFaxPropMap;
class CFaxProp;





/*
        CCpeDocTemplate is a derivation of CSingleDocTemplate used to
        override some default MFC behavior. See CCpeDocTemplate::MatchDocType
        in AWCPE.CPP
 */
class CCpeDocTemplate : public CSingleDocTemplate
        {
public:
        CCpeDocTemplate( UINT nIDResource, CRuntimeClass* pDocClass,
                                     CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass):
                CSingleDocTemplate( nIDResource, pDocClass,     pFrameClass, pViewClass )
                {;}



#ifndef _MAC
        virtual Confidence MatchDocType(LPCTSTR lpszPathName,
                                        CDocument*& rpDocMatch);
#else
        virtual Confidence MatchDocType(LPCTSTR lpszFileName,
                                        DWORD dwFileType, CDocument*& rpDocMatch);
#endif

        };








class CDrawApp : public CWinApp
{
public:
   HCURSOR m_hMoveCursor;
   BOOL m_bCmdLinePrint;
   LPAWCPESUPPORT m_pIawcpe;
   CString m_szRenderDevice;
   CString m_szRenderName;
   CFaxPropMap* m_pFaxMap;
   DWORD m_dwSesID;

/***CHANGES FOR M8 bug 2988***/
   LOGFONT m_last_logfont;
/*****************************/


// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
   LOGFONT m_default_logfont;
////////////////////////////////

   void filter_mru_list();
   BOOL DoPromptFileName(CString&, UINT, DWORD, BOOL, CDocTemplate*);
   CDrawApp();
   ~CDrawApp();

   // stuff for putting message notes on cover page
   TCHAR *m_note;
   BOOL m_note_wasread;
   BOOL m_note_wasclipped;
   BOOL m_extrapage_count;
   BOOL m_more_note;
   CFaxProp *m_last_note_box;
   CFaxProp *m_note_wrench;
   CFaxProp *m_extra_notepage;
   CDC      *m_pdc;     // easier to put it here instead of passing
                                        // it all over the place.

   void read_note( void );
   int  clip_note( CDC *pdc,
                                   LPTSTR *drawtext, LONG *numbytes,
                                   BOOL   delete_usedtext,
                                   LPRECT drawrect );

   void reset_note( void );
#ifndef NT5BETA2
   LPTSTR GetHtmlHelpFile() { return m_HtmlHelpFile; }
#else
   LPSTR  GetHtmlHelpFile() { return m_HtmlHelpFile; }
#endif

   BOOL more_note( void )
                        {return( m_more_note );}
private:

   TCHAR *pos_to_strptr( TCHAR *src, long pos,
                                                 TCHAR break_char,
                                                 TCHAR **last_break, long *last_break_pos );
   BOOL m_bUseDefaultDirectory ;
#ifndef NT5BETA2
   TCHAR m_HtmlHelpFile[MAX_PATH];
#else
   char  m_HtmlHelpFile[MAX_PATH];
#endif
protected:
    HMODULE m_hMod;
   int m_iErrorCode;
   HANDLE m_hSem;
   CString m_szDefaultDir;
   CString m_szFileName;
   BOOL m_bPrintHelpScreen;

   void InitRegistry();
   BOOL DoFilePageSetup(CMyPageSetupDialog& dlg);
   void RegistryEntries();
   virtual BOOL InitInstance();
   virtual int ExitInstance();
   void InitFaxProperties();
   BOOL IsSecondInstance();
   void CmdLinePrint();
   void PrintHelpScreen();
   void CmdLineRender();
   BOOL Render();
   BOOL Print();
   void ParseCmdLine();
   void OnFileOpen();
   void OnFileNew();
   afx_msg void OnFilePageSetup();
   CDocument* OpenDocumentFile(LPCTSTR lpszFileName);

        //{{AFX_MSG(CDrawApp)
        afx_msg void OnAppAbout();
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};


class CSEHexception
{
   private:
     UINT m_nCode;
   public:
     CSEHexception() {};
     CSEHexception(UINT uCode) : m_nCode(uCode) {};
     ~CSEHexception() {};
     unsigned int GetNumber() {return m_nCode;};
};






extern CDrawApp NEAR theApp;


#endif //#ifndef __AWCPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cntritem.cpp ===
//============================================================================
// cntritem.h : interface of the CDrawItem class
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      OLE draw item for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//============================================================================

#include "stdafx.h"
#include "awcpe.h"
#include "cpedoc.h"
#include "cpeobj.h"
#include "cpevw.h"
#include "cntritem.h"
#include "dialogs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef _AFX_OLD_EXCEPTIONS
#define DELETE_EXCEPTION(e) do { e->Delete(); } while (0)
#else   //!_AFX_OLD_EXCEPTIONS
#define DELETE_EXCEPTION(e)
#endif  //_AFX_OLD_EXCEPTIONS


/////////////////////////////////////////////////////////////////////////////
// CDrawItem implementation

IMPLEMENT_SERIAL(CDrawItem, COleClientItem, 0)

CDrawItem::CDrawItem(CDrawDoc* pContainer, CDrawOleObj* pDrawObj)
	: COleClientItem(pContainer)
{
	m_pDrawObj = pDrawObj;
}


CDrawItem::~CDrawItem()
{
	// TODO: add cleanup code here
}

void CDrawItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	switch(nCode)
	{
	case OLE_CHANGED_STATE:
	case OLE_CHANGED_ASPECT:
		m_pDrawObj->Invalidate();
		break;
	case OLE_CHANGED:
		UpdateExtent(); // extent may have changed
		m_pDrawObj->Invalidate();
		break;
	}
}


BOOL CDrawItem::DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg)
{
	ASSERT_VALID(this);
	if (pView != NULL)
		ASSERT_VALID(pView);
	if (lpMsg != NULL)
		ASSERT(AfxIsValidAddress(lpMsg, sizeof(MSG), FALSE));

	TRY	{
		Activate(nVerb, pView, lpMsg);
	}
	CATCH(COleException, e)	{
	    if (e->m_sc==OLE_E_STATIC) 
           CPEMessageBox(0,NULL,MB_OK | MB_ICONSTOP,IDP_OLE_STATIC_OBJECT);
		else 
	       if (!ReportError(e->m_sc))
			   AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	AND_CATCH_ALL(e) {
		// otherwise, show generic error
		AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
		DELETE_EXCEPTION(e);
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;
}



BOOL CDrawItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	CDrawView* pView = GetActiveView();
	ASSERT_VALID(pView);
	CRect rect = rectPos;
	pView->ClientToDoc(rect);

	if (rect != m_pDrawObj->m_position)
	{
		// invalidate old rectangle
		m_pDrawObj->Invalidate();

		// update to new rectangle
		m_pDrawObj->m_position = rect;
		GetExtent(&m_pDrawObj->m_extent);

		// and invalidate new rectangle
		m_pDrawObj->Invalidate();

		// mark document as dirty
		GetDocument()->SetModifiedFlag();
	}
	return COleClientItem::OnChangeItemPosition(rectPos);
}

void CDrawItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// update to extent of item if m_position is not initialized
	if (m_pDrawObj->m_position.IsRectEmpty())
		UpdateExtent();

	// copy m_position, which is in document coordinates
	CDrawView* pView = GetActiveView();
	ASSERT_VALID(pView);
	rPosition = m_pDrawObj->m_position;
	pView->DocToClient(rPosition);
}

void CDrawItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Note: this sets up the m_pDocument pointer returned from
	//  CDrawItem::GetDocument, therefore it is a good idea
	//  to call the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CDrawItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

BOOL CDrawItem::UpdateExtent()
{
	CDC	  dc;
	CSize size;
	if (!GetExtent(&size) || size == m_pDrawObj->m_extent)
		return FALSE;       // blank

	if( dc.CreateCompatibleDC( NULL ) )
		{
		dc.SetMapMode( MM_TEXT );
		dc.HIMETRICtoLP( &size ); // convert to screen space
		dc.DeleteDC();
		}

	// if new object (i.e. m_extent is empty) setup position
	if (m_pDrawObj->m_extent == CSize(0, 0))
	{
		m_pDrawObj->m_position.right =
			m_pDrawObj->m_position.left + size.cx;
		m_pDrawObj->m_position.bottom =
			m_pDrawObj->m_position.top - size.cy;
	}
	// else data changed so scale up rect as well
	else if (!IsInPlaceActive() && size != m_pDrawObj->m_extent)
	{
		m_pDrawObj->m_position.right = 
			m_pDrawObj->m_position.left + size.cx;
		m_pDrawObj->m_position.bottom = 
			m_pDrawObj->m_position.top - size.cy;
	}

	m_pDrawObj->m_extent = size;
	m_pDrawObj->Invalidate();   // redraw to the new size/position
	return TRUE;
}

#ifdef FUBAR
BOOL CDrawItem::UpdateExtent()
{
	CSize size;
	if (!GetExtent(&size) || size == m_pDrawObj->m_extent)
		return FALSE;       // blank

	// if new object (i.e. m_extent is empty) setup position
	if (m_pDrawObj->m_extent == CSize(0, 0))
	{
		m_pDrawObj->m_position.right =
			m_pDrawObj->m_position.left + MulDiv(size.cx, 10, 254);
		m_pDrawObj->m_position.bottom =
			m_pDrawObj->m_position.top - MulDiv(size.cy, 10, 254);
	}
	// else data changed so scale up rect as well
	else if (!IsInPlaceActive() && size != m_pDrawObj->m_extent)
	{
		m_pDrawObj->m_position.right = 
			m_pDrawObj->m_position.left +
			MulDiv(m_pDrawObj->m_position.Width(), size.cx, m_pDrawObj->m_extent.cx);
		m_pDrawObj->m_position.bottom = 
			m_pDrawObj->m_position.top +
			MulDiv(m_pDrawObj->m_position.Height(), size.cy, m_pDrawObj->m_extent.cy);
	}

	m_pDrawObj->m_extent = size;
	m_pDrawObj->Invalidate();   // redraw to the new size/position
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDrawItem diagnostics

#ifdef _DEBUG
void CDrawItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CDrawItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpedoc.cpp ===
//--------------------------------------------------------------------------
// CPEDOC.CPP
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      document module for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CDrawDoc, COleDocument)

#define DELETE_EXCEPTION(e) do { e->Delete(); } while (0)


//--------------------------------------------------------------------------
CDrawDoc::CDrawDoc()
{

    m_wScale = 100;                                             //default to full size
    m_wPaperSize=DMPAPER_LETTER;        //default to papersize of letter
    m_wOrientation=DMORIENT_PORTRAIT;   //default to portrait mode
    m_nMapMode = MM_ANISOTROPIC;
    m_paperColor = RGB(255, 255, 255);
    ComputePageSize();

}

//--------------------------------------------------------------------------
CDrawDoc::~CDrawDoc()
{
}

//--------------------------------------------------------------------------
BOOL CDrawDoc::OnNewDocument()
{
    if (!COleDocument::OnNewDocument())
        return FALSE;

    UpdateAllViews(NULL);

    return TRUE;
}


//-----------------------------------------------------------------------------
CDrawDoc* CDrawDoc::GetDoc()
{
    CFrameWnd* pFrame = (CFrameWnd*) (AfxGetApp()->m_pMainWnd);
    return (CDrawDoc*) pFrame->GetActiveDocument();
}


//--------------------------------------------------------------------------
void CDrawDoc::Serialize(CArchive& ar)
{
    m_bSerializeFailed = FALSE ;
    if (ar.IsStoring()) {

     //
     // Windows NT Fax Cover Page Editor puts all information
     // needed for rendering up front.
     //

     StoreInformationForPrinting( ar ); // Includes the signature, _gheaderVer5

     //
     // Now serialize as in Windows 95 Cover Page Editor.
     //

     ///////////////   ar.Write( _gheaderVer4, 20 );

        ar << m_wScale;
        ar << m_wPaperSize;
        ar << m_wOrientation;
        ar << m_paperColor;
        m_objects.Serialize(ar);
    }
    else {
        TRY {
                // set defaults for any unread params
            m_wScale = 100;
            m_wPaperSize=DMPAPER_LETTER;
            m_wOrientation=DMORIENT_PORTRAIT;

            if (m_iDocVer==VERSION2) {
                ar.GetFile()->Seek(sizeof(_gheaderVer2),CFile::begin);
                ar >> m_wOrientation;
            }
            else if (m_iDocVer==VERSION3) {
                ar.GetFile()->Seek(sizeof(_gheaderVer3),CFile::begin);
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
                else if (m_iDocVer==VERSION4) {
                ar.GetFile()->Seek(sizeof(_gheaderVer4),CFile::begin);
                ar >> m_wScale;
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
            else if (m_iDocVer==VERSION5) {
                SeekPastInformationForPrinting( ar ) ;
                ar >> m_wScale;
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
            else {
                ar.GetFile()->SeekToBegin();
            }

/** DISABLE SCALEING - SEE 2868's BUG LOG **/
            m_wScale = 100;
/*******************************************/

            ComputePageSize();

            ar >> m_paperColor;
            m_objects.Serialize(ar);
        }
        CATCH_ALL( e ){
            SetModifiedFlag( FALSE ) ;
            m_bSerializeFailed = TRUE ;
            ////THROW_LAST() ;       //// No!  I don't like the framework's message box!
            DELETE_EXCEPTION( e ) ;
        }
        END_CATCH_ALL

/**********************NOTE- BUG FIX FOR 3133**********************/
// can't call COleDocument::Serialize because COleDrawObj has
// already saved its client item. Also, items associated with
// undo objects will get saved if COleDocument::Serialize is called
// and will cause the file to mysteriously grow 'n grow...
//    COleDocument::Serialize(ar);
/******************************************************************/
#ifdef UNICODE
        if( m_bDataFileUsesAnsi ){
            SetModifiedFlag();            // Conversion to UNICODE is a modification worth prompting to save!
            m_bDataFileUsesAnsi = FALSE ; // When using CLIPBOARD, assume LOGFONTW structures.
        }
#endif
    }
}


void CDrawDoc::StoreInformationForPrinting( CArchive& ar )
{
//
// Create an Enhanced MetaFile followed by text box information,
// to store, for rendering by a WINAPI function PrtCoverPage.
//
// Author  Julia J. Robinson
//
// March 29, 1996
//
   COMPOSITEFILEHEADER CompositeFileHeader ;
#ifdef UNICODE
   memcpy( &CompositeFileHeader.Signature, _gheaderVer5w, 20 );
#else
   memcpy( &CompositeFileHeader.Signature, _gheaderVer5a, 20 );
#endif
   CompositeFileHeader.CoverPageSize = m_size ;
   CompositeFileHeader.EmfSize = 0 ;
   CompositeFileHeader.NbrOfTextRecords = 0 ;
   //
   // Get the default printer to use as a reference device for the metafile.
   //
   LPTSTR  pDriver ;
   LPTSTR  pDevice ;
   LPTSTR  pOutput ;
   TCHAR  PrinterName[MAX_PATH];
   CDC ReferenceDC ;
   CDC *pScreenDC ;
   POSITION vpos = GetFirstViewPosition();
   CDrawView* pView = (CDrawView*)GetNextView(vpos);
   pScreenDC = pView->GetWindowDC();
   BOOL PrinterFound = FALSE ;
   GetProfileString( TEXT("Windows"), TEXT("device"), TEXT(",,,"), PrinterName, MAX_PATH ) ;
   if(( pDevice = _tcstok( PrinterName, TEXT(","))) &&
      ( pDriver = _tcstok( NULL, TEXT(", "))) &&
      ( pOutput = _tcstok( NULL, TEXT(", ")))) {

      PrinterFound = ReferenceDC.CreateDC( pDriver, pDevice, pOutput, NULL ) ;
   }

   //
   //  Make sure m_size agrees with current default printer settings.
   //

   ComputePageSize() ;

   //
   // Create an enhanced metafile in a buffer in memory, containing all of the graphics.
   //

   CRect Rect( 0,
               0,
               MulDiv( m_size.cx, LE_TO_HM_NUMERATOR, LE_TO_HM_DENOMINATOR ),
               MulDiv( m_size.cy, LE_TO_HM_NUMERATOR, LE_TO_HM_DENOMINATOR ));
   CMetaFileDC mDC ;

   //
   //  If no default printer exists, use the screen as reference device.
   //

   INT hdc = mDC.CreateEnhanced( !PrinterFound ? pScreenDC : &ReferenceDC,
                                 NULL,
                                 LPCRECT(Rect),
                                 NULL ) ;
   if( !hdc ){
       TRACE( TEXT("Failed to create the enhanced metafile"));
   }
#if 0
   //
   // The MM_ANISOTROPIC matches well as long as the laser printer or fax printer is the
   // reference device, but mismatches miserably when the screen is the reference device.
   //
   mDC.SetMapMode( MM_ANISOTROPIC );
   mDC.SetWindowOrg( -m_size.cx/2, m_size.cy/2 ) ;
   mDC.SetViewportExt( !PrinterFound ? pScreenDC->GetDeviceCaps(LOGPIXELSX)
                                     : ReferenceDC.GetDeviceCaps( LOGPIXELSX ),
                       !PrinterFound ? pScreenDC->GetDeviceCaps(LOGPIXELSY)
                                     : ReferenceDC.GetDeviceCaps( LOGPIXELSY ));
   mDC.SetWindowExt(100,-100);
   mDC.SetViewportOrg( 0, 0 );
#endif
   mDC.SetMapMode( MM_LOENGLISH );
   mDC.SetWindowOrg( -m_size.cx/2, m_size.cy/2 ) ;
   pView->ReleaseDC( pScreenDC );
   //
   //  Iterate the list of objects, drawing everything but text objects to the metafile.
   //  Count text boxes as we go.
   //  Consider each serializeable class separately, just to be safe!!!
   //
   if( ! m_objects.IsEmpty()){
      //CDrawView* pView = GetNextView();
      POSITION vpos = GetFirstViewPosition();
      CDrawView * pView = (CDrawView*) GetNextView( vpos ) ;
      POSITION pos = m_objects.GetHeadPosition() ;
      while( pos != NULL ) {
         CObject* pCurrentObject = m_objects.GetNext(pos) ;
         CRuntimeClass* pWhatClass = NULL ;
         if( NULL == pCurrentObject ){
            //
            // Perfectly OK to store a NULL CObject pointer in a list.
            // Don't do anything!!
            //
         }
         else if( NULL == ( pWhatClass = pCurrentObject->GetRuntimeClass())){
            //
            // Corrupted memory or programmer error!!!  The serializable object
            // ought to have a runtime class!
            //
            //     AfxMessageBox( TEXT("Unexpected object encountered!"), MB_OK, 0);
         }
         else if( pWhatClass == RUNTIME_CLASS( CDrawText )){

             ++CompositeFileHeader.NbrOfTextRecords ; // text and font info will go in AFTER the metafile.
             CDrawRect* pThisObj = (CDrawRect*) pCurrentObject ;
             pThisObj->CDrawRect::Draw( &mDC, pView ); // draw border and fill
         }
         else if ( pWhatClass == RUNTIME_CLASS( CFaxProp )){

             ++CompositeFileHeader.NbrOfTextRecords ;  // text and font info will go in AFTER the metafile.
             CDrawRect* pThisObj = (CDrawRect*) pCurrentObject ;
             pThisObj->CDrawRect::Draw( &mDC, pView ); // draw border and fill
         }
         else {
             CDrawObj* pThisObj = (CDrawObj*) pCurrentObject ;
             pThisObj->Draw( &mDC, pView );
         }
      }
   }
   /////////CDrawView::m_IsRecording = FALSE;                // re-enable the scroll bar
   LPBYTE MBuffer ;
   HENHMETAFILE hEMF = mDC.CloseEnhanced();
   if( !hEMF ){
   //    AfxMessageBox( TEXT("CloseEnhanced call failed."), MB_OK, 0);

   }
   CompositeFileHeader.EmfSize = GetEnhMetaFileBits( hEMF, NULL, NULL ) ;
   if(!CompositeFileHeader.EmfSize){
   //    AfxMessageBox( TEXT("Metafile Size is 0"), MB_OK, 0);
   }
   ar.Write( &CompositeFileHeader, sizeof(CompositeFileHeader));
   HGLOBAL hglobal ;
   if(( CompositeFileHeader.EmfSize ) &&
      ( hglobal = GlobalAlloc( GMEM_MOVEABLE, CompositeFileHeader.EmfSize )) &&
      ( MBuffer = (LPBYTE)GlobalLock(hglobal)) &&
      ( GetEnhMetaFileBits( hEMF, CompositeFileHeader.EmfSize, MBuffer ))) {

      ar.Write( MBuffer, CompositeFileHeader.EmfSize ) ;
      GlobalUnlock( hglobal ) ;
      GlobalFree( hglobal );
   }
   //
   // Reiterate the m_objects list and write the text boxes to the file
   //
   if( !m_objects.IsEmpty()){
      TEXTBOX TextBox ;
      POSITION pos = m_objects.GetHeadPosition() ;
      while( pos != NULL ){
         CObject* pObj = m_objects.GetNext(pos) ;
         //
         //  For each CDrawText and CFaxProp object,
         //  put a TEXTBOX and string in the file.
         //
         CRuntimeClass* pWhatClass = NULL ;
         if( NULL == pObj ){
            //
            // Perfectly OK to store a NULL CObject pointer in a list.
            // Don't do anything!!
            //
         }
         else if( NULL == ( pWhatClass = pObj->GetRuntimeClass())){
            //
            // Corrupted memory or programmer error!!!  The serializable object
            // ought to have a runtime class!
            //
         }
         else if( pWhatClass == RUNTIME_CLASS( CDrawText )){
              CDrawText* pThisObj = (CDrawText*) pObj ;
              TextBox.FontDefinition = pThisObj->m_logfont ;
              TextBox.ResourceID = 0 ;
              TextBox.TextColor = pThisObj->m_crTextColor ;
              TextBox.TextAlignment = pThisObj->GetTextAlignment() ;
              TextBox.PositionOfTextBox = (RECT) pThisObj->m_position ;
              CString textString =  pThisObj->GetEditTextString();
              DWORD Length = TextBox.NumStringBytes
                           = sizeof(TCHAR) * textString.GetLength() ;
              ar.Write( &TextBox, sizeof(TEXTBOX));
              ar.Write( textString.GetBuffer(Length/sizeof(TCHAR)), Length );
         }
         else if ( pWhatClass == RUNTIME_CLASS( CFaxProp )){
              CFaxProp* pThisObj = (CFaxProp*) pObj ;
              TextBox.FontDefinition = pThisObj->m_logfont ;
              TextBox.TextColor = pThisObj->m_crTextColor ;
              TextBox.TextAlignment = pThisObj->GetTextAlignment() ;
              TextBox.PositionOfTextBox = (RECT) pThisObj->m_position ;
              TextBox.ResourceID = pThisObj->GetResourceId();
              TextBox.NumStringBytes = 0 ;
              ar.Write( &TextBox, sizeof(TEXTBOX));
         }
         else { // This won't happen.
         }
       }
   }
}

void CDrawDoc::SeekPastInformationForPrinting( CArchive& ar )
{
  //
  // Start over from beginning of file and read in the file header.
  //
  ar.GetFile()->SeekToBegin();
  COMPOSITEFILEHEADER CompositeFileHeader;
  UINT BytesRead = ar.Read( &CompositeFileHeader, sizeof(COMPOSITEFILEHEADER));
  if(BytesRead != sizeof(COMPOSITEFILEHEADER)){
      //
      // Any exception will do.  The CATCH_ALL in CDrawDoc::Serialize() is the target.
      //
      AfxThrowMemoryException() ;
  }
  void * pBuffer ;
  HLOCAL hMem;

  //
  // Seek past the metafile.  It is only for printing with
  // the WINAPI function PrtCoverPage.
  //

  if( CompositeFileHeader.EmfSize ){
          hMem = LocalAlloc( LMEM_MOVEABLE, CompositeFileHeader.EmfSize );
          if( NULL == hMem ){
              LocalFree( hMem );
              AfxThrowMemoryException() ; // See above.  Any exception will do.
          }
          pBuffer = LocalLock( hMem );
          if( NULL == pBuffer ){
              AfxThrowMemoryException();
          }
          if( CompositeFileHeader.EmfSize != ar.Read( pBuffer, CompositeFileHeader.EmfSize )){
              LocalUnlock( pBuffer );
              LocalFree( hMem );
              AfxThrowMemoryException() ;
          }
          LocalUnlock( pBuffer );
          LocalFree( hMem );
  }

  //
  // Skip over the text boxes.  These are used only by PrtCoverPage.
  // Each text box is followed by a variable length string.
  //

  UINT SizeOfTextBox = sizeof(TEXTBOX) ;
  for( DWORD Index = 0 ; Index < CompositeFileHeader.NbrOfTextRecords ; ++Index ){
       TEXTBOX TextBox ;
#ifdef UNICODE
       TEXTBOXA TextBoxA ;
       if( m_bDataFileUsesAnsi ){
           BytesRead = ar.Read( &TextBoxA, sizeof(TEXTBOXA) );
           if( sizeof(TEXTBOXA) != BytesRead ){
               AfxThrowMemoryException();
           }
           TextBox.NumStringBytes = TextBoxA.NumStringBytes ;
       }
       else
#endif
       if( sizeof(TEXTBOX) != ( BytesRead = ar.Read( &TextBox, sizeof(TEXTBOX)))){
           AfxThrowMemoryException();
       }
       if( TextBox.NumStringBytes ){
           hMem = LocalAlloc( LMEM_MOVEABLE, TextBox.NumStringBytes );
           if( NULL == hMem ){
               AfxThrowMemoryException() ;
           }
           pBuffer = LocalLock( hMem );
           if( NULL == pBuffer ){
               LocalFree( hMem ) ;
               AfxThrowMemoryException() ;
           }
           if( TextBox.NumStringBytes != ar.Read( pBuffer, TextBox.NumStringBytes )){
               LocalUnlock( pBuffer );
               LocalFree( hMem );
               AfxThrowMemoryException();
           }
           LocalUnlock( pBuffer );
           LocalFree( hMem );
       }
  }
}


//--------------------------------------------------------------------------
void CDrawDoc::Draw(CDC* pDC, CDrawView* pView, CRect rcClip)
{
    POSITION pos = m_objects.GetHeadPosition();
    if( !pDC->IsPrinting() ){ // NOT PRINTING
        while (pos != NULL) {
            CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
            if( pObj->Intersects( rcClip, TRUE )){
                pObj->Draw(pDC, pView);
                if ( pView->IsSelected(pObj))
                    pObj->DrawTracker(pDC, CDrawObj::selected);
            }
        }
    }
    else { // PRINTING

        while (pos != NULL) {
            CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
            pObj->Draw(pDC, pView);
        }
    }
}


//--------------------------------------------------------------------------
void CDrawDoc::Add(CDrawObj* pObj,BOOL bUndo /*=TRUE*/)
{
#if 0
    if (bUndo)
        CDrawView::GetView()->AddToUndo(new CAddUndo(pObj));
#endif

    if (bUndo){
        CDrawView::GetView()->SaveStateForUndo();
    }
        m_objects.AddTail(pObj);
        pObj->m_pDocument = this;
        SetModifiedFlag();
}


//--------------------------------------------------------------------------
void CDrawDoc::DeleteContents()
{
    Remove();

    CDrawView* pView = CDrawView::GetView();
    if (pView){
        pView->DisableUndo();
    }
    CDrawView::FreeObjectsMemory( & m_previousStateForUndo );
    m_previousStateForUndo.RemoveAll();
}


//--------------------------------------------------------------------------
void CDrawDoc::Remove(CDrawObj* pObj /*=NULL*/)
{
    CDrawView* pView = CDrawView::GetView();

    if (pObj==NULL) {                    //remove all document objects
           if (pView) {
          if (pView->m_pObjInEdit) {                //first destroy edit window
             pView->m_pObjInEdit->m_pEdit->DestroyWindow();
             pView->m_pObjInEdit=NULL;
          }
           }
       POSITION pos = m_objects.GetHeadPosition();
       while (pos != NULL) {
          CDrawObj* pobj = (CDrawObj*)m_objects.GetNext(pos);
          if (pobj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)) ) {
             COleClientItem* pItem=((CDrawOleObj*)pobj)->m_pClientItem;
                         if (pItem)  { //remove client item from document
                     pItem->Release(OLECLOSE_NOSAVE);
                 RemoveItem(pItem);
                 pItem->InternalRelease();
                         }
          }
          delete pobj;         //delete object
           }
           m_objects.RemoveAll();
           if (pView)
              pView->m_selection.RemoveAll();     //remove pointers from selection list
        }
        else {
           if (pView) {
          if (pObj==pView->m_pObjInEdit) {
             pView->m_pObjInEdit->m_pEdit->DestroyWindow();
             pView->m_pObjInEdit=NULL;
          }
           }
       POSITION pos = m_objects.Find(pObj);
           if (pos != NULL) {
                m_objects.RemoveAt(pos);
            if (pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)) ) {
               COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
                   if (pItem)  { //remove client item from document
                      pItem->Release(OLECLOSE_NOSAVE);
                  RemoveItem(((CDrawOleObj*)pObj)->m_pClientItem);
                  pItem->InternalRelease();
                           }
            }
            if (pView)
               pView->Remove(pObj);
                delete pObj;
           }
    }
}


//--------------------------------------------------------------------------
CDrawObj* CDrawDoc::ObjectAt(const CPoint& point)
{
        CRect rc;
    rc.top=point.y+2;
        rc.bottom=point.y-2;
        rc.left=point.x-2;
        rc.right=point.x+2;

        POSITION pos = m_objects.GetTailPosition();
        while (pos != NULL) {
                CDrawObj* pObj = (CDrawObj*)m_objects.GetPrev(pos);
        if (pObj->Intersects(rc))
                            return pObj;
        }

        return NULL;
}


//--------------------------------------------------------------------------
void CDrawDoc::ComputePageSize()
{
    CSize new_size;
        BOOL do_default = FALSE;

    CPrintDialog dlg(FALSE);
    if (AfxGetApp()->GetPrinterDeviceDefaults(&dlg.m_pd)) {

       LPDEVMODE  lpDevMode = (dlg.m_pd.hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(dlg.m_pd.hDevMode) : NULL;

#ifdef _DEBUG
       if (m_wOrientation==DMORIENT_PORTRAIT)
          TRACE( TEXT("AWCPE:  CDrawDoc::ComputePageSize() orientation to portrait \n"));
           else
          TRACE(TEXT("AWCPE:  CDrawDoc::ComputePageSize() orientation to landscape \n"));
#endif

           lpDevMode->dmPaperSize=m_wPaperSize;         // version 3 param
           lpDevMode->dmOrientation=m_wOrientation; // version 2 param


           // use doc scale only if printer supports scaleing
           if( lpDevMode->dmFields & DM_SCALE   )
                lpDevMode->dmScale   = m_wScale;
           else
                lpDevMode->dmScale   = 100;


/*****************************************/

       if (dlg.m_pd.hDevMode != NULL)
          ::GlobalUnlock(dlg.m_pd.hDevMode);

       CDC dc;
       HDC hDC= dlg.CreatePrinterDC();

                // don't fail if no printer, just use defaults
                if( hDC != NULL )
                        {
                        dc.Attach(hDC);

                        // Get the size of the page in loenglish
                        new_size.cx=MulDiv(dc.GetDeviceCaps(HORZSIZE),1000,254);
                        new_size.cy=MulDiv(dc.GetDeviceCaps(VERTSIZE),1000,254);
                        }
                else
                        do_default = TRUE;
    }
    else
           do_default = TRUE;


        if( do_default )
                {
                // couldn't get at printer goo, just make a guess
                if (m_wOrientation==DMORIENT_PORTRAIT)
                        {
                        new_size.cx=850;   // 8.5 inches
                        new_size.cy=1100;  // 11 inches
                        }
                else
                        {
                        new_size.cx=1100;  // 11 inches
                        new_size.cy=850;   // 8.5 inches
                        }
                }


    if (new_size != m_size)  {
        m_size = new_size;
        POSITION pos = GetFirstViewPosition();
        while (pos != NULL)
                ((CDrawView*)GetNextView(pos))->SetPageSize(m_size);

    }
}


//--------------------------------------------------------------------------
void CDrawDoc::OnViewPaperColor()
{
        CColorDialog dlg;
        if (dlg.DoModal() != IDOK)
                return;

        m_paperColor = dlg.GetColor();
        SetModifiedFlag();
        UpdateAllViews(NULL);
}


//--------------------------------------------------------------------------
BOOL CDrawDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
{
    if (!IsOkToClose()){                  //added to check for existence of fax properties
        return FALSE;
    }
    CString newName = lpszPathName;
    if (newName.IsEmpty()){  /// SAVE AS rather than SAVE
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);

        newName = m_strPathName;
        if (bReplace && newName.IsEmpty()) {
            newName = m_strTitle;
#ifdef FUBAR
#ifndef _MAC
            if (newName.GetLength() > 8){
                newName.ReleaseBuffer(8);
            }
            // check for dubious filename
            int iBad = newName.FindOneOf(_T(" #%;/\\"));
#else
                        int iBad = newName.FindOneOf(_T(":"));
#endif
                        if (iBad != -1)
                                newName.ReleaseBuffer(iBad);
#endif

#ifndef _MAC
                        // append the default suffix if there is one
             CString strExt;
             if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) && !strExt.IsEmpty()){
                 ASSERT(strExt[0] == '.');
                 newName += strExt;
             }
#endif
         }
         CString UpperNewName = newName ;
         UpperNewName.MakeUpper();
         if( UpperNewName.Right(4) == TEXT(".CPE")){
             int Length = newName.GetLength() - 4 ;   /// Get rid of the ".CPE"
             newName = newName.Left( Length );
             newName += TEXT(".COV");   ////// Suggest the ".COV" extension.
         }

         if (!((CDrawApp*)AfxGetApp())->DoPromptFileName(
             newName,
             bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
             OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
             FALSE,
             pTemplate)){
             return FALSE;       // don't even attempt to save
         }
    }

    //
    // If called by SaveModified () on exiting, and the NewName happens to be the name of a
    // read only file, we would get a popup "Access to %1 denied" and exit without further
    // chance to save.  We avoid that scenario by checking the attributes and doing the popup
    // ourselves.  a-juliar, 9-26-96
    //

    DWORD newFileAttributes = GetFileAttributes( (LPCTSTR)newName );
    if ( 0xFFFFFFFF != newFileAttributes &&
        ((FILE_ATTRIBUTE_READONLY & newFileAttributes ) ||
        (FILE_ATTRIBUTE_DIRECTORY & newFileAttributes ))){
        CString ThisMess ;
        AfxFormatString1( ThisMess, AFX_IDP_FILE_ACCESS_DENIED, newName );
        AfxMessageBox( ThisMess );
        return FALSE ;    // Don't exit without saving.
    }

    BeginWaitCursor();
    if (!OnSaveDocument(newName)){
        if (lpszPathName == NULL){
        // be sure to delete the file
            TRY
            {
                CFile::Remove(newName);
            }
            CATCH_ALL(e)
            {
                TRACE0("Warning: failed to delete file after failed SaveAs.\n");
                DELETE_EXCEPTION(e);
            }
            END_CATCH_ALL
        }
        EndWaitCursor();
        return FALSE;
    }

    // reset the title and change the document name
    if (bReplace){
        SetPathName(newName);
    }
    EndWaitCursor();
    return TRUE;        // success
}
//--------------------------------------------------------------------------
void CDrawDoc::CloneObjectsForUndo()
{
    POSITION pos = m_objects.GetHeadPosition();
    while( pos != NULL ){
        CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
        CDrawObj* pClone = pObj->Clone( NULL );
        m_previousStateForUndo.AddTail( pClone );
    }
}
//--------------------------------------------------------------------------
void CDrawDoc::SwapListsForUndo()
{
    int iPreviousCount = (int) m_previousStateForUndo.GetCount();
    m_previousStateForUndo.AddTail( & m_objects );
    m_objects.RemoveAll();
    for( int index = 0 ; index < iPreviousCount ; ++ index ){
         CObject * pObj = m_previousStateForUndo.RemoveHead();
         m_objects.AddTail( pObj );
    }
}
//---------------------------------------------------------------------------
BOOL CDrawDoc::IsOkToClose()
{
    CDrawApp* pApp = (CDrawApp*)AfxGetApp();
    BOOL bFaxObj=FALSE;

    if ( !(pApp->m_bCmdLinePrint || pApp->m_dwSesID!=0) ) {
       POSITION pos = m_objects.GetHeadPosition();
       while (pos != NULL) {
          CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
          if (pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ) {
                 bFaxObj=TRUE;
             break;
                  }
           }
       if (!bFaxObj)
           if (CPEMessageBox(MSG_INFO_NOFAXPROP, NULL, MB_YESNO, IDS_INFO_NOFAXPROP)==IDNO)
             return FALSE;
    }

    return TRUE;
}


//---------------------------------------------------------------------------
void CDrawDoc::SetPathName( LPCTSTR lpszPathName, BOOL bAddToMRU )
{
        COleDocument::SetPathName( lpszPathName, bAddToMRU );

#if !defined( _NT ) && !defined( WIN32S )
        SHFILEINFO sfi;

        if( GetFileAttributes( lpszPathName ) != 0xffffffff ) {
                if( SHGetFileInfo( lpszPathName, 0, &sfi, sizeof( sfi ), SHGFI_DISPLAYNAME ) )  {
                        SetTitle( sfi.szDisplayName );
                }
        }
#endif
}

//---------------------------------------------------------------------------

void CDrawDoc::OnFileSave()
{
  // This override was added to "enforce" the .COV file extension when saving.  a-juliar, 9-19-96
    CString FileName = m_strPathName ;
    FileName.MakeUpper();
    if( FileName.Right(4) == TEXT( ".CPE" )){
        OnFileSaveAs();
    }
    else {
        CDocument::OnFileSave();
    }
}
//---------------------------------------------------------------------------
void CDrawDoc::OnFileSaveAs()
{
    CDocument::OnFileSaveAs() ;
}
//---------------------------------------------------------------------------
void CDrawDoc::OnUpdateFileSave(CCmdUI* pCmdUI)
{
   pCmdUI->Enable(TRUE);
}



#ifdef _DEBUG
void CDrawDoc::AssertValid() const
{
        COleDocument::AssertValid();
}

void CDrawDoc::Dump(CDumpContext& dc) const
{
        COleDocument::Dump(dc);
}
#endif //_DEBUG


BOOL CDrawDoc::SaveModified()
{
    //
    // Overridden to enforce the ".COV" file extension. 9-26-96, a-juliar
    //

    // Copied from COleDocument::SaveModified

        // determine if necessary to discard changes
        if (::InSendMessage())
        {
                POSITION pos = GetStartPosition();
                COleClientItem* pItem;
                while ((pItem = GetNextClientItem(pos)) != NULL)
                {
                        ASSERT(pItem->m_lpObject != NULL);
                        SCODE sc = pItem->m_lpObject->IsUpToDate();
                        if (sc != OLE_E_NOTRUNNING && FAILED(sc))
                        {
                                // inside inter-app SendMessage limits the user's choices
                                CString name = m_strPathName;
                                if (name.IsEmpty())
                                        VERIFY(name.LoadString(AFX_IDS_UNTITLED));

                                CString prompt;
                                AfxFormatString1(prompt, AFX_IDP_ASK_TO_DISCARD, name);
                                return AfxMessageBox(prompt, MB_OKCANCEL|MB_DEFBUTTON2,
                                        AFX_IDP_ASK_TO_DISCARD) == IDOK;
                        }
                }
        }

        // sometimes items change without a notification, so we have to
        //  update the document's modified flag before calling
        //  CDocument::SaveModified.
        UpdateModifiedFlag();

        ///// return CDocument::SaveModified();

        if (!IsModified())
                return TRUE;        // ok to continue

#ifdef _MAC
        CWinApp* pApp = AfxGetApp();
        if (pApp->m_nSaveOption == CWinApp::saveNo)
                return TRUE;
        else if (pApp->m_nSaveOption == CWinApp::saveYes)
        {
                DoFileSave();
                return TRUE;
        }
#endif

        // get name/title of document
        CString name;
        if (m_strPathName.IsEmpty())
        {
                // get name based on caption
                name = m_strTitle;
                if (name.IsEmpty())
                        VERIFY(name.LoadString(AFX_IDS_UNTITLED));
        }
        else
        {
                // get name based on file title of path name
                name = m_strPathName;
#if 0
                if (afxData.bMarked4) /// won't complie without afximpl.h; probably false anyway.
                {
                        AfxGetFileTitle(m_strPathName, name.GetBuffer(_MAX_PATH), _MAX_PATH);
                        name.ReleaseBuffer();
                }
#endif
        }

#ifdef _MAC
        AfxGetFileTitle(m_strPathName, name.GetBuffer(_MAX_FNAME), _MAX_FNAME);
        name.ReleaseBuffer();
#endif

        CString prompt;
#ifndef _MAC
        AfxFormatString1(prompt, AFX_IDP_ASK_TO_SAVE, name);
        switch (AfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE))
#else
        AfxFormatString2(prompt, AFX_IDP_ASK_TO_SAVE, AfxGetAppName(), name);
        switch (AfxMessageBox(prompt, MB_SAVEDONTSAVECANCEL, AFX_IDP_ASK_TO_SAVE))
#endif
        {
        case IDCANCEL:
                return FALSE;       // don't continue

        case IDYES:
            {
            //
            // Enforce the ".COV" extension.
            //

                CString FileName = m_strPathName ;
                FileName.MakeUpper();
                if ( FileName.Right(4) != TEXT( ".COV" )){
                    return DoSave( NULL ) ;
                }
                else {
                    return DoFileSave();
                }

                break;
            }
        case IDNO:
                // If not saving changes, revert the document
                break;

        default:
                ASSERT(FALSE);
                break;
        }
        return TRUE;    // keep going

}


//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawDoc, COleDocument)
   //{{AFX_MSG_MAP(CDrawDoc)
        ON_UPDATE_COMMAND_UI(ID_MAPI_MSG_NOTE, OnUpdateMapiMsgNote)
        //}}AFX_MSG_MAP
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleDocument::OnUpdatePasteMenu)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleDocument::OnUpdatePasteLinkMenu)
   ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleDocument::OnUpdateEditLinksMenu)
   ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
   ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleDocument::OnUpdateObjectVerbMenu)
   ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleDocument::OnUpdateObjectVerbMenu)
   ON_COMMAND(ID_OLE_EDIT_CONVERT, COleDocument::OnEditConvert)
   ON_COMMAND(ID_FILE_SAVE, OnFileSave)
   ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
END_MESSAGE_MAP()




void CDrawDoc::OnUpdateMapiMsgNote(CCmdUI* pCmdUI)
        {
        CDrawObj *pObj;
        CFaxProp *pfaxprop;
    POSITION pos;

    pos = m_objects.GetHeadPosition();
    while (pos != NULL)
        {
        pObj = (CDrawObj*)m_objects.GetNext(pos);
                if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
                        {
                        pfaxprop = (CFaxProp *)pObj;
                        if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE )
                                {
                                // only allow one note, don't let user make any more
                                pCmdUI->Enable( FALSE );
                                return;
                                }
                        }
        }

        // No notes, let user make one
        pCmdUI->Enable( TRUE );

        }



void CDrawDoc::
        schoot_faxprop_toend( WORD res_id )
        /*
                Moves all CFaxProps objects in m_objects that are of
                type res_id to the end of the list.

                Can throw a CMemoryException
         */
        {
        CObList temp_obs;
        CDrawObj *pObj;
        CFaxProp *pfaxprop;
    POSITION pos, cur_pos;

    pos = m_objects.GetHeadPosition();
    while (pos != NULL)
        {
                cur_pos = pos;
        pObj = (CDrawObj*)m_objects.GetNext(pos);
                if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
                        {
                        pfaxprop = (CFaxProp *)pObj;
                        if( pfaxprop->GetResourceId() == res_id )
                                {
                                // move prop to temporary list
                                temp_obs.AddTail( pObj );

                                // remove from original list
                                m_objects.RemoveAt( cur_pos );
                                }
                        }
        }

        // put all found objects at end of original list
        m_objects.AddTail( &temp_obs );

        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\awcpesup.h ===
/*
 *  AWCPESUP . H
 *
 *      Microsoft AtWork Fax for Windows
 *      Copyright (C) 1993-1994, Microsoft Corporation
 *
 *      Information in this document is subject to change without notice and does
 *      not represent a commitment on the part of Microsoft Corporation.
 */

/*
 * Constants
 */


// Recipient properties
#define CPE_RECIPIENT_NAME              (0x80000001)
#define CPE_RECIPIENT_TITLE             (0x80000002)
#define CPE_RECIPIENT_DEPARTMENT        (0x80000003)
#define CPE_RECIPIENT_OFFICE_LOCATION   (0x80000004)
#define CPE_RECIPIENT_COMPANY           (0x80000005)
#define CPE_RECIPIENT_STREET_ADDRESS    (0x80000006)
#define CPE_RECIPIENT_POST_OFFICE_BOX   (0x80000007)
#define CPE_RECIPIENT_LOCALITY                  (0x80000008)
#define CPE_RECIPIENT_STATE_OR_PROVINCE (0x80000009)
#define CPE_RECIPIENT_POSTAL_CODE               (0x80000010)
#define CPE_RECIPIENT_COUNTRY                   (0x80000011)
#define CPE_RECIPIENT_HOME_PHONE        (0x80000012)
#define CPE_RECIPIENT_WORK_PHONE        (0x80000013)
#define CPE_RECIPIENT_FAX_PHONE         (0x80000014)

// Sender properties
#define CPE_SENDER_NAME                 (0x08000001)
#define CPE_SENDER_TITLE                (0x08000002)
#define CPE_SENDER_DEPARTMENT           (0x08000003)
#define CPE_SENDER_OFFICE_LOCATION      (0x08000004)
#define CPE_SENDER_COMPANY              (0x08000005)
#define CPE_SENDER_ADDRESS              (0x08000006)
#define CPE_SENDER_HOME_PHONE           (0x08000007)
#define CPE_SENDER_WORK_PHONE           (0x08000008)
#define CPE_SENDER_FAX_PHONE            (0x08000009)
#define CPE_RECIPIENT_TO_LIST           (0x0800000A)
#define CPE_RECIPIENT_CC_LIST           (0x0800000B)

// Message related properties
#define CPE_MESSAGE_SUBJECT             (0x00800001)
#define CPE_MESSAGE_SUBMISSION_TIME     (0x00800002)
#define CPE_MESSAGE_BILLING_CODE        (0x00800003)

// Miscellanous message properties
#define CPE_MISC_ATTACHMENT_NAME_LIST   (0x00800004)// ; delimeted list of attachment names
#define CPE_MISC_USER_DEFINED           (0x00800005)// lpvBuf contains LPSPropValue

// Count type properties
#define CPE_COUNT_RECIPIENTS            (0x00800006)// Total count of recipients
#define CPE_COUNT_ATTACHMENTS           (0x00800007)// Total number of attachments
#define CPE_COUNT_PAGES                 (0x00800008)// total number of pages

// Derived property so CPE can get at PR_BODY data
// using the tempfile copy of PR_BODY
#define CPE_MESSAGE_BODY_FILENAME               (0x00800009)// Temp filename for PR_BODY text

// Configuration properties
#define CPE_CONFIG_CPE_TEMPLATE         (0x00080004)
#define CPE_CONFIG_PRINT_DEVICE         (0x00080005)// The device to print to

// Finish modes
#define CPE_FINISH_PAGE                 (0x00008001) //This is used when the
                                                                                                  //CPE finishes a page with out an error
#define CPE_FINISH_ERROR                (0x00008002) // This is used when the
                                                                                                          //CPE encounters an error.
                                                                                                          //This causes the process to end and
                                                                                                          //no further processing should take place

// Finish return values
#define CPE_NEXT_PAGE                   (0x00000001)
#define CPE_DONE                        (0x80000001)
#define CPE_ERROR                       (0x80000002)


//Version info
#define AWCPESUPPORT_VERSION                    (0x00010000)

/*
 * CPESupport Interface
 */
typedef ULONG FAR *LPULONG;

#undef INTERFACE
#define INTERFACE IAWCPESupport

DECLARE_INTERFACE_(IAWCPESupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

        // *** ICPESupport methods ***
        STDMETHOD(GetVersion) (THIS_ LPULONG lpulVer) PURE;
        /* This function is used for version checking,
           it is currently not implemented */

        STDMETHOD(GetProp) (THIS_ ULONG ulProp, LPULONG lpulBufSize, LPVOID lpvBuf) PURE;
        /* This function is used to retrieve properties for the Cover Page.
                ulProp is one of the property constants above.
                lpulBufSize is a pointer to the size of the buffer pointed to by lpvBuf.
                lpvBuf is a buffer where the property value is returned.  If this value is NULL,
                the size needed to hold the property is returned in lpulBufSize.
        */

        STDMETHOD(SetProp) (THIS_ ULONG ulProp, LPVOID lpvBuf) PURE;
        /* This function is used to set properties On the message.
                ulProp is one of the property constants above.
                lpvBuf is the buffer where the property value is.
        */

        STDMETHOD(GetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
        /* This function is used to retrieve the count of certain attributes, such
           as thee number of recipients.
           ulCntProp is one of the Count properties listed above.
           lpulCount is where the count value is returned.
        */

        STDMETHOD(SetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
        /* This function is used to set the count of certain attributes, such
           as the number of recipients.
           ulCntProp is one of the Count properties listed above.
           lpulCount is the count value.
        */

        STDMETHOD(Finish) (THIS_ ULONG ulMode) PURE;
        /* This function get called when the CPE finishes a page or encounters an error.
           The CPE passes one of the finish codes from above to the function to signal
           which case is finishing, either the page or the CPE encountered an error.
           ulMode is one of the pre defined modes.

           The function can return three modes other than normal errors:
                        CPE_NEXT_PAGE   Finish returns this to signal the CPE to start printing
                                                        the next page.

                        CPE_DONE                Finish returns this to signal the CPE that all of the
                                                        Cover pages ahve been printed.

                        CPE_ERROR               Finish returns this to signal that an error ocurred in
                                                        the transport subsystem.  The CPE should exit with out UI
                                                        and without calling finish again.

        */
};
typedef IAWCPESupport FAR * LPAWCPESUPPORT;

// Service Entry definition
extern "C" {
typedef LONG (WINAPI *AWCPESUPPORTPROC)(DWORD dwSesID, LPAWCPESUPPORT FAR* lppCPESup);
}
typedef AWCPESUPPORTPROC FAR* LPAWCPESUPPORTPROC;



/*
 * GUIDs
 */
DEFINE_GUID(IID_IAWCPESupport, 0xd1ac6c20,0x91d4,0x101b,0xae,0xcc,0x00,0x00,0x0b,0x69,0x1f,0x18);

/*
 * Registry key locations
 */

// THESE MUST BE IDENTICAL TO THE ONES IN FAXCOVER.H!!!!!!!     $BUGBUG this needs to be removed before release

// This is the root level key where the CPE specific sub keys are stored
#define CPE_SUPPORT_ROOT_KEY    (TEXT("Software\\Microsoft\\At Work Fax\\Transport Service Provider"))

// This is the location where the CPE puts the command line to used when calling it to print
// cover pages at send time.  The format is total at the CPE's discretion.  The transport will
// look for the string "SESS_ID" and replace it with the current session id.  The session ID is
// a DWORD.
#define CPE_COMMAND_LINE_KEY (TEXT("Cover Page Editor"))

// This key contains the DLL name that the CPE loads to get the Support Object
#define CPE_SUPPORT_DLL_KEY (TEXT("CPE Support DLL"))

//This is the key that holds the name of the function in the Support DLL that is the actual "Service Entry"
#define CPE_SUPPORT_FUNCTION_NAME_KEY (TEXT("CPE Support Function Name"))

// END IDENTICAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpeedt.cpp ===
//---------------------------------------------------------------------------
// cpeedt.cpp - implementation for edit object
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains edit class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

IMPLEMENT_SERIAL(CTextEdit, CEdit, 0)



//---------------------------------------------------------------------------
CTextEdit::CTextEdit()
{
    m_pDrawObj=NULL;

}


//---------------------------------------------------------------------------
void CTextEdit::Serialize(CArchive& ar)
{
    CString szEditText;
    CEdit::Serialize(ar);
    if (ar.IsStoring()) {
       GetWindowText(szEditText);
       ar << szEditText;
    }
    else {
       ar >> szEditText;
       SetWindowText(szEditText);
    }
}



//---------------------------------------------------------------------------
CTextEdit::CTextEdit(CDrawObj* pDrawObj) : m_pDrawObj(pDrawObj)
{
    CDrawView * pView = CDrawView::GetView();
    m_pTextBoxForUndo = pView ? pView->m_pObjInEdit : NULL ;
}


//---------------------------------------------------------------------------
void CTextEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_TAB){
        CDrawView::GetView()->OnChar(nChar,nRepCnt,nFlags);
    }
    else{
        CEdit::OnChar(nChar,nRepCnt,nFlags);
    }
#if 0
    if ( m_pTextBoxForUndo ){
         m_pTextBoxForUndo->m_bUndoAlignment = FALSE ;
         m_pTextBoxForUndo->m_bUndoFont = FALSE ;
         m_pTextBoxForUndo->m_bUndoTextChange = TRUE ;
    }
#endif
    CDrawView * pView = CDrawView::GetView() ;
    if ( pView && pView->m_pObjInEdit ){
        pView->m_pObjInEdit->m_bUndoAlignment = FALSE ;
        pView->m_pObjInEdit->m_bUndoFont = FALSE ;
        pView->m_pObjInEdit->m_bUndoTextChange = TRUE ;
    }
}


//---------------------------------------------------------------------------
BOOL CTextEdit::PreTranslateMessage(MSG* pMsg)
{
   return CEdit::PreTranslateMessage(pMsg);
}


//---------------------------------------------------------------------------
BOOL CTextEdit::OnEraseBkgnd(CDC* pDC)
{
   return CEdit::OnEraseBkgnd(pDC);
}


//---------------------------------------------------------------------------
void CTextEdit::OnLButtonDown(UINT nFlags, CPoint point)
{
    if (CDrawView::GetView()->m_bFontChg) {
       CDrawView::GetView()->OnSelchangeFontSize();
       CDrawView::GetView()->OnSelchangeFontName();
       CDrawView::GetView()->m_bFontChg=FALSE;
        }

    CEdit::OnLButtonDown(nFlags, point);
}

//---------------------------------------------------------------------------
void CTextEdit::OnSetFocus(CWnd* pOldWnd)
{
   CEdit::OnSetFocus(pOldWnd);
}



//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CTextEdit, CEdit)
    //{{AFX_MSG_MAP(CTextEdit)
    //}}AFX_MSG_MAP
    ON_WM_CHAR()
    ON_WM_LBUTTONDOWN()
    ON_WM_ERASEBKGND()
    ON_WM_SETFOCUS()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpeedt.h ===
//--------------------------------------------------------------------------
// cpeedt.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEEDT_H__
#define __CPEEDT_H__

class CDrawObj;
class CDrawView;
class CDrawText;


class CTextEdit : public CEdit
{

public:
    CTextEdit();
    CTextEdit(CDrawObj*);

protected:
    CDrawObj* m_pDrawObj;
    DECLARE_SERIAL(CTextEdit);
    CDrawText* m_pTextBoxForUndo ;

#ifdef _DEBUG
    void AssertValid();
#endif
    virtual void Serialize(CArchive& ar);

    //{{AFX_MSG(CTextEdit)
    //}}AFX_MSG
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnChar(UINT, UINT, UINT);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);

    DECLARE_MESSAGE_MAP()
};



#endif   //#ifndef __CPEEDT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpedoc.h ===
//--------------------------------------------------------------------------
// CPEDOC.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEDOC_H__
#define __CPEDOC_H__

#define MILIMETERS_TO_HIMETRIC 100        // Conversion factor
#define LE_TO_HM_NUMERATOR   2540         // LOENGLISH to HIMETRIC conversion
#define LE_TO_HM_DENOMINATOR 100
class CDrawView;
class CDrawObj;

class CDrawDoc : public COleDocument
{
public:
    enum {VERSION1,VERSION2,VERSION3,VERSION4, VERSION5};
    int m_iDocVer;
    WORD m_wOrientation;
    WORD m_wPaperSize;
    WORD m_wScale;
    BOOL m_bSerializeFailed ;
#ifdef UNICODE
    BOOL m_bDataFileUsesAnsi ;
#endif

        CObList m_objects;
        CObList  m_previousStateForUndo ;

        virtual ~CDrawDoc();
        static CDrawDoc* GetDoc();
        CObList* GetObjects() { return &m_objects; }
        BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
        const CSize& GetSize() const { return m_size; }
        void ComputePageSize();
        int GetMapMode() const { return m_nMapMode; }
        COLORREF GetPaperColor() const { return m_paperColor; }
        CDrawObj* ObjectAt(const CPoint& point);
        void Draw(CDC* pDC, CDrawView* pView, CRect rcClip);
        void Add(CDrawObj* pObj,BOOL bUndo=TRUE);
        void Remove(CDrawObj* pObj=NULL);
        virtual void Serialize(CArchive& ar);   // overridden for document i/o
        BOOL IsOkToClose();
        void schoot_faxprop_toend( WORD res_id );

#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:
        CSize m_size;
        int m_nMapMode;
        COLORREF m_paperColor;

        virtual BOOL OnNewDocument();
        void DeleteContents();
        CDrawDoc();
        virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
        void OnUpdateFileSave(CCmdUI* pCmdUI);
public:
        void OnFileSave();
        void OnFileSaveAs();
        void CloneObjectsForUndo();
        void SwapListsForUndo();
        virtual BOOL SaveModified(); // return TRUE if ok to continue // override to enforce ".COV" extension
protected:
        void StoreInformationForPrinting( CArchive& ar );
        void SeekPastInformationForPrinting( CArchive& ar );
        DECLARE_DYNCREATE(CDrawDoc)

        //{{AFX_MSG(CDrawDoc)
        afx_msg void OnViewPaperColor();
        afx_msg void OnUpdateMapiMsgNote(CCmdUI* pCmdUI);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//
// Structure of the composite file header.
// These will be used in the Windows API function  PrtCoverPage
//
typedef struct tagCOMPOSITEFILEHEADER {
  BYTE      Signature[20];
  DWORD     EmfSize;
  DWORD     NbrOfTextRecords;
  SIZE      CoverPageSize;
} COMPOSITEFILEHEADER;
//
// Structure of the text box entries in the composite file.  For printing purposes only.
//
typedef struct tagTextBox{
  RECT           PositionOfTextBox;
  COLORREF       TextColor;
  UINT           TextAlignment;
  LOGFONT        FontDefinition;
  WORD           ResourceID ;        // Identifies a FAX PROPERTY.
  DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOX;

#ifdef UNICODE
typedef struct tagTextBoxA{
  RECT           PositionOfTextBox;
  COLORREF       TextColor;
  UINT           TextAlignment;
  LOGFONTA       FontDefinition;
  WORD           ResourceID ;        // Identifies a FAX PROPERTY.
  DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOXA;
#endif
#endif //#ifndef __CPEDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cntritem.h ===
//--------------------------------------------------------------------------
// CNTRITEM.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CNTRITEM_H__
#define __CNTRITEM_H__


class CDrawDoc;
class CDrawView;

class CDrawItem : public COleClientItem
{
	DECLARE_SERIAL(CDrawItem)

// Constructors
public:
	CDrawItem(CDrawDoc* pContainer = NULL, CDrawOleObj* pDrawObj = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CDrawDoc* GetDocument()
		{ return (CDrawDoc*)COleClientItem::GetDocument(); }
	CDrawView* GetActiveView()
		{ return (CDrawView*)COleClientItem::GetActiveView(); }

	CDrawOleObj* m_pDrawObj;    // back pointer to OLE draw object

// Operations
	BOOL UpdateExtent();

// Implementation
public:
	~CDrawItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual BOOL DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);

protected:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};



#endif   //#ifndef __CNTRITEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpeobj.cpp ===
///============================================================================
// cpeobj.cpp - implementation for drawing objects
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains drawing objects for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/14/95      Added check for too thin rects in CDrawLine::MoveHandleTo
// 3/8          Added stuff for handling notes on cpe
// 3/10         commented out rect.bottom+=2 in CDrawText::SnapToFont
// 3/22         Fixed char set bug for editboxes
//
//============================================================================
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "richedit.h"
#include <windows.h>
#include <windowsx.h>
#include <math.h>

IMPLEMENT_SERIAL(CDrawObj, CObject, 0)
IMPLEMENT_SERIAL(CDrawRect, CDrawObj, 0)
IMPLEMENT_SERIAL(CFaxText, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawText, CDrawRect, 0)
IMPLEMENT_SERIAL(CFaxProp, CDrawText, 0)
IMPLEMENT_SERIAL(CDrawLine, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawRoundRect, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawEllipse, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawPoly, CDrawObj, 0)
IMPLEMENT_SERIAL(CDrawOleObj, CDrawObj, 0)

#if 0
//// THIS SHOULD BE INLINE!!
LONG CDrawText::GetTextAlignment(){
   //
   //  Added by a-juliar, 4/8/96.  We need access to m_lStyle for our rendering routines.
   //
          //                  return (( ES_CENTER == ( ALL_ALIGN_FIELDS & m_lStyle )) ? DT_CENTER :
            //                       (( ES_RIGHT  == ( ALL_ALIGN_FIELDS & m_lStyle )) ? DT_RIGHT  :
              //                          DT_LEFT )) | DT_NOPREFIX ;
                 return m_lStyle | DT_NOPREFIX ;
};
#endif

//--------------------------------------------------------------------------
BOOL CALLBACK
        get_fontdata( ENUMLOGFONT* lpnlf,NEWTEXTMETRIC* lpntm,int iFontType,
                          LPARAM lpData )
        /*
                Gets charset and other data for font lpnlf
         */
        {
        CDrawText *pdt = (CDrawText *)lpData;

        pdt->m_logfont.lfCharSet = lpnlf->elfLogFont.lfCharSet;

        return( FALSE );

        }





//---------------------------------------------------------------------------
CDrawObj::CDrawObj()
{
    m_lLinePointSize=1;  //default to 1
}

//---------------------------------------------------------------------------
CDrawObj::~CDrawObj()
{
}

//---------------------------------------------------------------------------
CDrawObj::CDrawObj(const CRect& position)
{
    m_position = position;
    m_pDocument = NULL;

    m_bPen = TRUE;
    m_logpen.lopnStyle = PS_INSIDEFRAME;

    m_lLinePointSize=1;  //default to 1

    CClientDC dc(NULL);

    m_logpen.lopnWidth.x = (long) m_lLinePointSize*100/72;  //convert to LU
    m_logpen.lopnWidth.y = (long) m_lLinePointSize*100/72;  //convert to LU

    m_logpen.lopnColor = COLOR_BLACK;

    m_bBrush = FALSE;
    m_logbrush.lbStyle = BS_SOLID;
    m_logbrush.lbColor = COLOR_WHITE;
    m_logbrush.lbHatch = HS_HORIZONTAL;
}


//---------------------------------------------------------------------------
void CDrawObj::Serialize(CArchive& ar)
{
    CObject::Serialize(ar);
    if (ar.IsStoring()) {
        ar << m_position;
        ar << (WORD)m_bPen;
        ar.Write(&m_logpen, sizeof(LOGPEN));
        ar << (WORD)m_bBrush;
        ar.Write(&m_logbrush, sizeof(LOGBRUSH));
        ar << m_lLinePointSize;
    }
    else   {
        // get the document back pointer from the archive
        m_pDocument = (CDrawDoc*)ar.m_pDocument;
        ASSERT_VALID(m_pDocument);
        ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CDrawDoc)));

        WORD wTemp;
        ar >> m_position;
        ar >> wTemp; m_bPen = (BOOL)wTemp;
        if( sizeof(LOGPEN) != ar.Read(&m_logpen,sizeof(LOGPEN))){
             AfxThrowMemoryException() ; // Any exception will do.
        }
        ar >> wTemp; m_bBrush = (BOOL)wTemp;
        if( sizeof(LOGBRUSH) != ar.Read(&m_logbrush, sizeof(LOGBRUSH))){
             AfxThrowMemoryException(); // Aiming for the CATCH_ALL block in CDrawDoc::Serialize
        }
        ar >> m_lLinePointSize;
    }
}


//---------------------------------------------------------------------------
void CDrawObj::Draw(CDC*, CDrawView* )
{
}


//---------------------------------------------------------------------------
CDrawObj& CDrawObj::operator=(const CDrawObj& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

//   (CObject&)*this=rdo;  //assign cobject part

   m_bPen = rdo.m_bPen;
   m_logpen = rdo.m_logpen;
   m_bBrush = rdo.m_bBrush;
   m_logbrush = rdo.m_logbrush;
   m_lLinePointSize=rdo.m_lLinePointSize;
   m_pDocument=rdo.m_pDocument;

   return *this;
}


//---------------------------------------------------------------------------
void CDrawObj::DrawTracker(CDC* pDC, TrackerState state)
{
    ASSERT_VALID(this);

    switch (state) {
      case normal:
        break;

      case selected:
      case active: {
         int nHandleCount = GetHandleCount();
         for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) {
            CPoint handle = GetHandle(nHandle);
            pDC->PatBlt(handle.x - 3, handle.y - 3, 7, 7, DSTINVERT);
         }
      }
      break;
    }
}

//---------------------------------------------------------------------------
// position is in logical
//---------------------------------------------------------------------------
void CDrawObj::MoveTo(const CRect& position, CDrawView* pView)
{
    ASSERT_VALID(this);

    if (position == m_position)
        return;

    Invalidate();
    m_position = position;
    Invalidate();

    m_pDocument->SetModifiedFlag();

    pView->UpdateStatusBar();
}


//---------------------------------------------------------------------------
// Note: if bSelected, hit-codes start at one for the top-left
// and increment clockwise, 0 means no hit.
// If !bSelected, 0 = no hit, 1 = hit (anywhere)
// point is in logical coordinates
//---------------------------------------------------------------------------
int CDrawObj::HitTest(CPoint point, CDrawView* pView, BOOL bSelected)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    if (bSelected) {
        int nHandleCount = GetHandleCount();
        for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) {
            // GetHandleRect returns in logical coords
            CRect rc = GetHandleRect(nHandle,pView);
            if (point.x >= rc.left && point.x < rc.right &&
                point.y <= rc.top && point.y > rc.bottom)
                return nHandle;
        }
    }
    else  {
       if (point.x >= m_position.left && point.x < m_position.right &&
             point.y <= m_position.top && point.y > m_position.bottom)
          return 1;
    }
    return 0;
}


//---------------------------------------------------------------------------
BOOL CDrawObj::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect fixed = m_position;
    fixed.NormalizeRect();
    CRect rectT = rect;
    rectT.NormalizeRect();
    return !(rectT & fixed).IsRectEmpty();
}


//---------------------------------------------------------------------------
BOOL CDrawObj::ContainedIn(const CRect& rect)
{
    ASSERT_VALID(this);

    CRect fixed = m_position;
    fixed.NormalizeRect();
    CRect rectT = rect;
    rectT.NormalizeRect();

        // prevent rects that are too skinny or short
        if( fixed.left == fixed.right )
                fixed.right = fixed.left+1;

        if( fixed.top == fixed.bottom )
                fixed.bottom = fixed.top+1;

    return ((rectT | fixed)==rectT);
}


//---------------------------------------------------------------------------
int CDrawObj::GetHandleCount()
{
    ASSERT_VALID(this);
    return 8;
}


//---------------------------------------------------------------------------
// returns logical coords of center of handle
//---------------------------------------------------------------------------
CPoint CDrawObj::GetHandle(int nHandle)
{
    ASSERT_VALID(this);
    int x, y, xCenter, yCenter;

    // this gets the center regardless of left/right and top/bottom ordering
    xCenter = m_position.left + m_position.Width() / 2;
    yCenter = m_position.top + m_position.Height() / 2;

    switch (nHandle)
    {
    default:
        ASSERT(FALSE);

    case 1:
        x = m_position.left;
        y = m_position.top;
        break;

    case 2:
        x = xCenter;
        y = m_position.top;
        break;

    case 3:
        x = m_position.right;
        y = m_position.top;
        break;

    case 4:
        x = m_position.right;
        y = yCenter;
        break;

    case 5:
        x = m_position.right;
        y = m_position.bottom;
        break;

    case 6:
        x = xCenter;
        y = m_position.bottom;
        break;

    case 7:
        x = m_position.left;
        y = m_position.bottom;
        break;

    case 8:
        x = m_position.left;
        y = yCenter;
        break;
    }

    return CPoint(x, y);
}


//---------------------------------------------------------------------------
// return rectange of handle in logical coords
//---------------------------------------------------------------------------
CRect CDrawObj::GetHandleRect(int nHandleID, CDrawView* pView)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    CRect rect;
    // get the center of the handle in logical coords
    CPoint point = GetHandle(nHandleID);
    // convert to client/device coords
    pView->DocToClient(point);
    // return CRect of handle in device coords
    rect.SetRect(point.x-3, point.y-3, point.x+3, point.y+3);
    pView->ClientToDoc(rect);

    return rect;
}


//---------------------------------------------------------------------------
HCURSOR CDrawObj::GetHandleCursor(int nHandle)
{
    ASSERT_VALID(this);

    LPCTSTR id;
    switch (nHandle) {
    default:
        ASSERT(FALSE);

    case 1:
    case 5:
        id = IDC_SIZENWSE;
        break;

    case 2:
    case 6:
        id = IDC_SIZENS;
        break;

    case 3:
    case 7:
        id = IDC_SIZENESW;
        break;

    case 4:
    case 8:
        id = IDC_SIZEWE;
        break;
    }

    return AfxGetApp()->LoadStandardCursor(id);
}


//---------------------------------------------------------------------------
// point must be in logical
//---------------------------------------------------------------------------
void CDrawObj::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    CRect position = m_position;
    switch (nHandle)
    {
    default:
        ASSERT(FALSE);

    case 1:
        position.left = point.x;
        position.top = point.y;
        break;

    case 2:
        position.top = point.y;
        break;

    case 3:
        position.right = point.x;
        position.top = point.y;
        break;

    case 4:
        position.right = point.x;
        break;

    case 5:
        position.right = point.x;
        position.bottom = point.y;
        break;

    case 6:
        position.bottom = point.y;
        break;

    case 7:
        position.left = point.x;
        position.bottom = point.y;
        break;

    case 8:
        position.left = point.x;
        break;
    }

    MoveTo(position, pView);
}


//---------------------------------------------------------------------------
void CDrawObj::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
      TRACE(TEXT("AWCPE: CDrawObj::Invalidate, missing View pointer\n"));
      return;
   }

   CRect rect = m_position;
   pView->DocToClient(rect);
   if (pView->IsSelected(this)) {
        rect.left -= 4;
        rect.top -= 5;
        rect.right += 5;
        rect.bottom += 4;
   }

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawObj::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawObj* pClone = new CDrawObj(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    return pClone;
}


//---------------------------------------------------------------------------
void CDrawObj::OnDblClk(CDrawView* )
{
}


#ifdef _DEBUG
void CDrawObj::AssertValid()
{
   ASSERT(m_position.left <= m_position.right);
   ASSERT(m_position.bottom <= m_position.top);
}
#endif


//*********************************************************************
// CDrawRect
//*********************************************************************

//---------------------------------------------------------------------------
CDrawRect::CDrawRect()
{
}


//---------------------------------------------------------------------------
CDrawRect::~CDrawRect()
{
}

//---------------------------------------------------------------------------
CDrawRect::CDrawRect(const CRect& position)
        : CDrawObj(position)
{
}


//----------------------------------------------------------------------
void CDrawRect::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawObj::Serialize(ar);
    if (ar.IsStoring()) {
    }
    else {
    }
}

#define XinBOUNDS          \
   ((position.right > position.left) \
                 ? point.x > position.left && point.x < position.right \
         : point.x > position.right && point.x < position.left)

#define YinBOUNDS          \
   ((position.top > position.bottom) \
                 ? point.y > position.bottom && point.y < position.top \
         : point.y > position.top && point.y < position.bottom)



//---------------------------------------------------------------------------
void CDrawRect::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    CRect position = m_position;

    switch (nHandle) {
    case 1:
        if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
           if (uiShiftDraw & SHIFT_TOOL) {   //DRAW SQUARE
                          if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
                          }
                          else {
                 position.left = point.x;
                 position.top =  (position.top > position.bottom) ? position.bottom + abs(position.right - position.left)
                            : position.bottom - abs(position.right - position.left);
                 if (!YinBOUNDS) {
                    position.top =  point.y;
                                position.left = (position.left < position.right) ? position.right - abs(position.top - position.bottom)
                                  : position.right + abs(position.top - position.bottom) ;
                                 }
                          }
               }
           else {     //KEEP ASPECT RATIO SIMILAR
                          if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
                          }
                          else {
                             UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                             UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                             UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
                 position.left = point.x;
                             iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                             position.top = (position.bottom < position.top) ? position.bottom + (iW*iAspect)/100
                                 : position.bottom - (iW*iAspect)/100;
                             if (!YinBOUNDS) {
                   position.top =  point.y;
                               iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                               position.left = (position.left < position.right) ? position.right - ((iAspect>0)?(iH*100)/iAspect:0)
                                   : position.right + ((iAspect>0)?(iH*100)/iAspect:0);
                 }
                          }
           }
            }
                else {    //NORMAL DRAWING
                position.left = point.x;
                position.top = point.y;
                }
        break;

    case 2:
        position.top = point.y;
        break;

    case 3:
        if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
                   if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
                   }
                   else {
                      UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                      UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                      UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
                      if (XinBOUNDS) {
                position.top =  point.y;
                        iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                        position.right = (position.left < position.right) ? position.left + ((iAspect>0)?(iH*100)/iAspect:0)
                            : position.left - ((iAspect>0)?(iH*100)/iAspect:0);
              }
              else {
                position.right = point.x;
                        iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                        position.top = (position.bottom < position.top) ? position.bottom + (iW*iAspect)/100
                            : position.bottom - (iW*iAspect)/100;
                      }
                   }
            }
                else {    //NORMAL DRAWING
                position.right = point.x;
                position.top = point.y;
                }
        break;

    case 4:
        position.right = point.x;
        break;

    case 5:
        if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
                   if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
                   }
                   else {
                      UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                      UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                      UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
              position.right = point.x;
                      iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                      position.bottom = (position.bottom < position.top) ? position.top - (iW*iAspect)/100
                          : position.top + (iW*iAspect)/100;
                      if (!YinBOUNDS) {
                position.bottom =  point.y;
                        iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                        position.right = (position.left < position.right) ? position.left + ((iAspect>0)?(iH*100)/iAspect:0)
                            : position.left - ((iAspect>0)?(iH*100)/iAspect:0);
              }
                   }
            }
                else {    //NORMAL DRAWING
                position.right = point.x;
                position.bottom = point.y;
                }
        break;

    case 6:
        position.bottom = point.y;
        break;

    case 7:
        if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
                   if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
                   }
                   else {
                      UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                      UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                      UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
              position.left = point.x;
                      iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                      position.bottom = (position.bottom < position.top) ? position.top - (iW*iAspect)/100
                          : position.top + (iW*iAspect)/100;
                      if (!YinBOUNDS) {
                position.bottom =  point.y;
                        iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                        position.left = (position.left < position.right) ? position.right - ((iAspect>0)?(iH*100)/iAspect:0)
                            : position.right + ((iAspect>0)?(iH*100)/iAspect:0);
              }
                   }
            }
                else {    //NORMAL DRAWING
                position.left = point.x;
                position.bottom = point.y;
                }
        break;

    case 8:
        position.left = point.x;
        break;

    default:
        ASSERT(FALSE);
    }

    MoveTo(position, pView);
}


//---------------------------------------------------------------------------
void CDrawRect::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen* pOldPen;
    CBrush brush;
    if (!brush.CreateBrushIndirect(&m_logbrush))
        return;
    CPen pen;
    if (!pen.CreatePenIndirect(&m_logpen))
        return;

    if (m_bBrush)
       pOldBrush = pDC->SelectObject(&brush);
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen)
       pOldPen = pDC->SelectObject(&pen);
    else
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);

    CRect rect = m_position;

    pDC->Rectangle(rect);

    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawRect::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect rectT = rect;
    rectT.NormalizeRect();

    CRect fixed = m_position;
    fixed.NormalizeRect();
    if ((rectT & fixed).IsRectEmpty())
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawRect::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawRect* pClone = new CDrawRect(m_position);

    *pClone=*this;

    ASSERT_VALID(pClone);

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//*********************************************************************
// CFaxText
//*********************************************************************

//---------------------------------------------------------------------------
CFaxText::CFaxText()
{
   Initialize();
}

//---------------------------------------------------------------------------
CFaxText::CFaxText(const CRect& position)
        : CDrawRect(position)
{
   Initialize();
}


//----------------------------------------------------------------------
void CFaxText::Initialize()
{
   m_bPrintRTF=TRUE;
   m_hRTFWnd=NULL;
   m_hLib=NULL;
   m_wResourceid=IDS_PROP_MS_TEXT;
}

//---------------------------------------------------------------------------
CFaxText::~CFaxText()
{
   EndRTF();
}

//----------------------------------------------------------------------
void CFaxText::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
    if (ar.IsStoring()) {
    }
    else {
        if (GetApp()->m_dwSesID!=0) {    //rendering
                   InitRTF();
                   StreamInRTF();
                   CheckForFit();
        }
    }
}


//---------------------------------------------------------------------------
void CFaxText::InitRTF()
{
    LPVOID lpMsgBuf;

    m_hLib = LoadLibrary(TEXT("RICHED32.DLL"));

    if (!m_hLib) {
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                 ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
        TRACE1("AWCPE error: %s (error loading RICHED32.DLL)\n",lpMsgBuf);
                return;
    }

    m_hRTFWnd = CreateWindow(TEXT("RICHEDIT"),TEXT(""),WS_CHILD | ES_MULTILINE, 0, 0, 0, 0,CDrawView::GetView()->m_hWnd,
        (HMENU)0, AfxGetInstanceHandle(),NULL);

        if (!m_hRTFWnd) {
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                 ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
        TRACE1("AWCPE error: %s (error in CreateWindow for RICHEDIT)\n",lpMsgBuf);
        return;
        }
}


//---------------------------------------------------------------------------
void CFaxText::EndRTF()
{
    if (m_hRTFWnd) {
            ::DestroyWindow(m_hRTFWnd);
                m_hRTFWnd=NULL;
        }

    if (m_hLib) {
        ::FreeLibrary(m_hLib);
                m_hLib=NULL;
        }
}


//-------------------------------------------------------------------------------------------------------
DWORD CALLBACK CFaxText::EditStreamCallBack(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    dwCookie=0;
        pbBuff=0;
        cb=0;
    pcb=0;

//  get a iStream from transport
//  read from storage.

        return 0;
}


//---------------------------------------------------------------------------
void CFaxText::StreamInRTF()
{
   if (m_hRTFWnd==NULL)
      return;

    EDITSTREAM es;
        es.dwCookie=0;   //pIStream pointer here
    es.dwError=0;
    es.pfnCallback= EditStreamCallBack;
    ::SendMessage(m_hRTFWnd, EM_STREAMIN, SF_RTF, (LPARAM)&es);
}

//---------------------------------------------------------------------------
void CFaxText::RectToTwip(CRect& rc,CDC& dc)
{
   int iX=dc.GetDeviceCaps(LOGPIXELSX);
   int iY=dc.GetDeviceCaps(LOGPIXELSY);
   rc.left=(rc.left*1440)/iX;
   rc.right=(rc.right*1440)/iX;
   rc.top=(rc.top*1440)/iY;
   rc.bottom=(rc.bottom*1440)/iX;
}

//---------------------------------------------------------------------------
void CFaxText::CheckForFit()
{
   if (m_hRTFWnd==NULL)
      return;

   CDrawView* pView=CDrawView::GetView();

   FORMATRANGE fr;
   CClientDC dc(pView);
   fr.hdc=fr.hdcTarget=dc.GetSafeHdc();
   CRect rc=m_position;
   pView->DocToClient(rc,&dc);
   RectToTwip(rc,dc);
   fr.rc=fr.rcPage=rc;
   fr.chrg.cpMin=0;
   fr.chrg.cpMax=-1;

   LRESULT lTextToPrint = ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);
   LRESULT lTextLength = ::SendMessage(m_hRTFWnd, WM_GETTEXTLENGTH, 0, 0L);

   if (m_bPrintRTF = (lTextToPrint <= lTextLength)) {
       //notify transport going to print RTF
   }
   else {
       //notify transport not going to print RTF
   }

   ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);       //clean up.
}



//---------------------------------------------------------------------------
void CFaxText::Draw(CDC* pDC,CDrawView* pView)
{
    if ( (GetApp()->m_dwSesID!=0) && (!(m_hRTFWnd!=NULL && m_bPrintRTF)) )
           return;

    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen* pOldPen;
    CBrush brush;
    if (!brush.CreateBrushIndirect(&m_logbrush))
        return;
    CPen pen;
    if (!pen.CreatePenIndirect(&m_logpen))
        return;

    if (m_bBrush)
       pOldBrush = pDC->SelectObject(&brush);
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen)
       pOldPen = pDC->SelectObject(&pen);
    else
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);

    CRect rect = m_position;

    pDC->Rectangle(rect);

    int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
    int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
    int x = -wx-1;
    int y = -wy-1;
    pView->DocToClient(rect,pDC);
    rect.InflateRect(x,y);
    pView->ClientToDoc(rect,pDC);

    if (GetApp()->m_dwSesID!=0) {    //rendering
       FORMATRANGE fr;
       CRect rc=m_position;
       pView->DocToClient(rc,pDC);
       RectToTwip(rc,*pDC);
       fr.rc=fr.rcPage=rc;
       fr.chrg.cpMin=0;
       fr.chrg.cpMax=-1;
       LRESULT lTextLength = ::SendMessage(m_hRTFWnd, WM_GETTEXTLENGTH, 0, 0L);
       LRESULT lTextToPrint = ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, TRUE, (LPARAM)&fr);
           if (lTextLength!=lTextToPrint)
               TRACE(TEXT("AWCPE: error, printed text range != total text length\n"));
       ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);   //clean up.
    }
    else {
       pDC->SetBkMode(TRANSPARENT);
       pDC->DrawText(_T("{Fax Text}"),10,rect,ES_LEFT);
    }

    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);
}


//---------------------------------------------------------------------------
CDrawObj* CFaxText::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CFaxText* pClone = new CFaxText(m_position);

    *pClone=*this;

    ASSERT_VALID(pClone);

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//*********************************************************************
// CDrawText
//*********************************************************************

//---------------------------------------------------------------------------
CDrawText::CDrawText()
{
    Initialize();
}


//---------------------------------------------------------------------------
CDrawText::CDrawText(const CRect& position)
        : CDrawRect(position)
{
    Initialize();
}


//---------------------------------------------------------------------------
void CDrawText::Initialize()
{
    m_pEdit=NULL;
    m_lStyle = ES_LEFT;
    InitEditWnd();
    m_brush=NULL;
    m_crTextColor=COLOR_BLACK;
    m_bUndoAlignment = FALSE ;
    m_bUndoTextChange = FALSE ;
    m_bUndoFont = FALSE ;
    m_bPen=FALSE;
    m_logbrush.lbColor = COLOR_WHITE;
    NewBrush();  //brush is created, for WM_CTLCOLOR processing

    m_logfont = theApp.m_last_logfont;

    m_pFont = new CFont;
    m_pFont->CreateFontIndirect(&m_logfont);

    if (m_pEdit){
        m_pEdit->SetFont(m_pFont);
    }
}

//-----------------------------------------------------------------------------
void CDrawText::OnEditUndo()
{
    if( !m_pEdit ){
        return;
    }
    if( m_bUndoAlignment ){
        ToggleAlignmentForUndo();
        return;
    }
    if( m_bUndoFont ){
        ToggleFontForUndo();
        return;
    }
    //
    // Let the edit control handle Undo
    //
    m_pEdit->SendMessage(WM_UNDO,0,0L);
}

//------------------------------------------------------------------------------
BOOL CDrawText::CanUndo()
{
    return m_bUndoFont || m_bUndoAlignment || m_pEdit && m_pEdit->CanUndo() ;
}

//------------------------------------------------------------------------------
void CDrawText::ToggleFontForUndo()
{
    LOGFONT temp ;
    memcpy( &temp, &m_logfont, sizeof(LOGFONT)) ;
    memcpy( &m_logfont, &m_previousLogfontForUndo, sizeof(LOGFONT)) ;
    memcpy( &m_previousLogfontForUndo, &temp, sizeof(LOGFONT)) ;
    ChgLogfont( m_logfont );
}
//------------------------------------------------------------------------------
void CDrawText::ToggleAlignmentForUndo()
{
    CDrawView * pView = CDrawView::GetView();

    //
    // We can't call ChgAlignment because it sets the state for the UNDO.
    //

    LONG lStyle = m_previousAlignmentForUndo;
    m_previousAlignmentForUndo = m_lStyle;
    m_lStyle=lStyle;

    LOGFONT logfont;
    HFONT hFont = (HFONT) m_pEdit->SendMessage(WM_GETFONT);
    ::GetObject(hFont,sizeof(LOGFONT),&logfont);

    CTextEdit* pEdit=m_pEdit;

    CString szText;
    m_pEdit->GetWindowText(szText);

    m_pEdit = new CTextEdit;
    RECT rect;
    pEdit->GetWindowRect(&rect);
    CDrawView::GetView()->ScreenToClient(&rect);

    m_pEdit->Create(WS_CHILD | lStyle /*| ES_AUTOVSCROLL*/ | ES_NOHIDESEL | ES_MULTILINE, rect,
        CDrawView::GetView(), ID_TEXT);

    m_pEdit->SetWindowText(szText);

    pEdit->DestroyWindow();
    delete pEdit;

    if (m_pFont)
       delete m_pFont;

    m_pFont = new CFont;
    m_pFont->CreateFontIndirect(&logfont);
    if (m_pEdit){
       m_pEdit->SetFont(m_pFont);
    }
    pView->UpdateStyleBar();
    ShowEditWnd( pView, FALSE ); /// This MUST BE SHOWN.  Thus, the UNDO will not look consistant
                                 /// with just changing the alignment.  Bad things happen if
                                 //// we show the window there.
}

//---------------------------------------------------------------------------
CDrawText::~CDrawText()
{
    if (m_pEdit) {
       m_pEdit->DestroyWindow();
       delete m_pEdit;
    }
    if (m_brush)
       VERIFY(::DeleteObject(m_brush));

    if (m_pFont)
       delete m_pFont;
}


//---------------------------------------------------------------------------
CDrawText& CDrawText::operator=(const CDrawText& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawRect::operator=(rdo);  //assign cdrawrect part

   m_crTextColor=rdo.m_crTextColor;
   m_szEditText = rdo.m_szEditText;
   m_lStyle = rdo.m_lStyle;

   memcpy(&m_logfont, &rdo.m_logfont, sizeof(m_logfont));
   LOGFONT lf;
   ChgLogfont(lf,FALSE);

   if (m_pEdit) {
      CString szEditText;
      if (rdo.m_pEdit) {
         rdo.m_pEdit->GetWindowText(szEditText);
         m_pEdit->SetWindowText(szEditText);
      }
   }
   return *this;
}


//---------------------------------------------------------------------
void CDrawText::ChgAlignment(CDrawView* pView, LONG lStyle)
{
    if (!m_pEdit) {
       TRACE(TEXT("AWCPE.CPEOBJ.CHGALIGNMENT: invalid CEdit pointer\n"));
       return;
    }
//
// Save the state for Undoing.
//
    m_bUndoTextChange = FALSE;
    m_bUndoAlignment = TRUE;
    m_bUndoFont = FALSE;
    m_previousAlignmentForUndo = m_lStyle ;

    if (::GetWindowLong(m_pEdit->m_hWnd, GWL_STYLE) & lStyle)
      return;

    m_lStyle=lStyle;

    LOGFONT logfont;
    HFONT hFont = (HFONT) m_pEdit->SendMessage(WM_GETFONT);
    ::GetObject(hFont,sizeof(LOGFONT),&logfont);

    CTextEdit* pEdit=m_pEdit;

    CString szText;
    m_pEdit->GetWindowText(szText);

    m_pEdit = new CTextEdit;
    RECT rect;
    pEdit->GetWindowRect(&rect);
    CDrawView::GetView()->ScreenToClient(&rect);

    m_pEdit->Create(WS_CHILD | lStyle | ES_NOHIDESEL | ES_MULTILINE, rect,
        CDrawView::GetView(), ID_TEXT);

    m_pEdit->SetWindowText(szText);

    pEdit->DestroyWindow();
    delete pEdit;

    if (m_pFont)
       delete m_pFont;

    m_pFont = new CFont;
    m_pFont->CreateFontIndirect(&logfont);
    if (m_pEdit)
       m_pEdit->SetFont(m_pFont);

    pView->UpdateStyleBar();
 //   if( this == pView->m_pObjInEdit ){
 //       ShowEditWnd( pView, FALSE );    // Give it input focus, but don't initialize Undo state.
 //   }        // This is a disaster.  The Windows 95 folks lived with this bug, so can the
               // Windows NT folks.  After changing text alignment, the edit control does not
               // have the input focus.  But it does after we UNDO such a change!
}


//---------------------------------------------------------------------
void CDrawText::SnapToFont()
{
   CDrawView* pView = CDrawView::GetView();
   if (m_pEdit==NULL || pView==NULL) {
      TRACE(TEXT("CDrawText::SnapToFont-missing m_pEdit or view pointer\n"));
      return;
   }

   CClientDC dc(pView);
   pView->OnPrepareDC(&dc,NULL);
   dc.SelectObject(m_pEdit->GetFont());

   Invalidate(); // clear size rect droppings
   SnapToFont_onthefly( pView, &dc, m_position );

   FitEditWnd(NULL);
   Invalidate(); // draw new stuff

   pView->UpdateStatusBar();
}



#ifdef FUBAR // keep this around awhile for reference
void CDrawText::SnapToFont()
{
   CDrawView* pView = CDrawView::GetView();
   if (m_pEdit==NULL || pView==NULL) {
      TRACE( TEXT("CDrawText::SnapToFont-missing m_pEdit or view pointer\n"));
      return;
   }

   TEXTMETRIC tm;
   CClientDC dc(pView);

   pView->OnPrepareDC(&dc,NULL);
   int x = MulDiv(m_logpen.lopnWidth.x, dc.GetDeviceCaps(LOGPIXELSX), 100)+1;
   int y = MulDiv(m_logpen.lopnWidth.y, dc.GetDeviceCaps(LOGPIXELSY), 100)+1;


   CRect rect = m_position;
   pView->DocToClient(rect,&dc);
   rect.InflateRect(-x,-y);
   pView->ClientToDoc(rect,&dc);

   dc.SelectObject(m_pEdit->GetFont());
//   CString sz;
//   GetLongestString(sz);
//   CSize cs = dc.GetTextExtent(sz,sz.GetLength());
   CSize cs;

   dc.GetTextMetrics(&tm);
   cs.cy=tm.tmHeight + tm.tmExternalLeading;

   int iOHeight =  (rect.bottom < rect.top) ? rect.top - rect.bottom : rect.bottom - rect.top;

   int iLines= (cs.cy>0)?(int)((iOHeight/(float)cs.cy)*100):0;
//   int iLines= (cs.cy>0)?iOHeight/cs.cy:0;

   iLines=(iLines+50)/100;
   if (iLines<1)
      iLines=1;

   int iH=iLines*cs.cy+1;
//   int iH=iLines*cs.cy;

   if (rect.bottom < rect.top)
      rect.bottom = rect.top-iH;
   else
      rect.top = rect.bottom-iH;

   int iNHeight =  (rect.bottom < rect.top) ? rect.top - rect.bottom : rect.bottom - rect.top;
   if (iOHeight > iNHeight)
      Invalidate();

//  TRACE??("before border inflating: RectH(%i),border x,y(%i,%i),cs.cy(%i), iLines(%i), iH(%i)\n",rect.top-rect.bottom,x,y,cs.cy,iLines,iH);

   pView->DocToClient(rect,&dc);
   rect.InflateRect(x,y);
   rect.bottom+=2;
   pView->ClientToDoc(rect,&dc);

//  TRACE("after border inflating: RectH(%i),border x,y(%i,%i),cs.cy(%i), iLines(%i), iH(%i)\n",rect.top-rect.bottom,x,y,cs.cy,iLines,iH);

   m_position=rect;
   Invalidate();

   FitEditWnd(NULL);

   pView->UpdateStatusBar();
}
#endif


//---------------------------------------------------------------------
void CDrawText::
        SnapToFont_onthefly( CDrawView *pView, CDC *fly_dc,
                                                 CRect &fly_rect, CFont *dpFont )
   /*
                If dpFont is not NULL it is selected into fly_dc after
                switching to MM_TEXT mode.
        */
   {
   TEXTMETRIC tm;
   LONG temp;

   if( pView == NULL )
                return;

   int x =
                MulDiv( m_logpen.lopnWidth.x,
                                fly_dc->GetDeviceCaps(LOGPIXELSX),
                                100)+1;
   int y =
                MulDiv( m_logpen.lopnWidth.y,
                                fly_dc->GetDeviceCaps(LOGPIXELSY),
                                100)+1;

   // normalize rect first
   if( fly_rect.top < fly_rect.bottom )
                {
                temp = fly_rect.top;
                fly_rect.top = fly_rect.bottom;
                fly_rect.bottom = temp;
                }

   if( fly_rect.right < fly_rect.left )
                {
                temp = fly_rect.right;
                fly_rect.right = fly_rect.left;
                fly_rect.left = temp;
                }

   // save original spot so we can avoid rect jiggle due
   // to unavoidable integer roundoff error below
   RECT save_rect = fly_rect;

   pView->DocToClient(fly_rect,fly_dc);
   fly_rect.InflateRect(-x,-y);

   CPoint pW1=fly_dc->GetWindowOrg();
   CPoint pW2=pW1;
   pView->DocToClient(pW2,fly_dc);
   CPoint pV=fly_dc->GetViewportOrg();

   // do snapping in MM_TEXT to get rect exactly right
   fly_dc->SetMapMode(MM_TEXT);
   fly_dc->SetWindowOrg(pW2);
   fly_dc->SetViewportOrg(pV);

   CSize cs;

   if( dpFont != NULL )
                fly_dc->SelectObject( dpFont );

   fly_dc->GetTextMetrics(&tm);
   cs.cy=tm.tmHeight;// + tm.tmExternalLeading;

   int iLines= (cs.cy>0)
                                        ?(fly_rect.bottom - fly_rect.top - 1 + cs.cy/2)/cs.cy
                                        :0;
   if (iLines<1)
      iLines=1;

   // snap height to a whole text line
   fly_rect.bottom = fly_rect.top + iLines*cs.cy + 1;

   // back to MM_ANISOTROPHIC
   fly_dc->SetMapMode(MM_ANISOTROPIC);
   fly_dc->SetWindowOrg(pW1);
   fly_dc->SetViewportOrg(pV);
   fly_dc->SetViewportExt(fly_dc->GetDeviceCaps(LOGPIXELSX),
                                                  fly_dc->GetDeviceCaps(LOGPIXELSY));
   fly_dc->SetWindowExt(100, -100);

   fly_rect.InflateRect(x,y);
   pView->ClientToDoc(fly_rect,fly_dc); // back to the future

   // integer round off error from above may cause rect to
   // jiggle a bit, so slap it back where it is supposed to be.
   int new_height = fly_rect.top - fly_rect.bottom;
   fly_rect = save_rect;
   fly_rect.bottom = fly_rect.top - new_height;

   }


//---------------------------------------------------------------------
void CDrawText::ChgLogfont(LOGFONT& lf, BOOL bResize /*=TRUE*/)
{
    CDrawView* pView = CDrawView::GetView();
    if (m_pEdit==NULL || pView==NULL) {
        TRACE(TEXT("CDrawText::ChgLogfont--missing m_pEdit or view pointer\n"));
        return;
    }


    CClientDC dc(pView);
    CRect rect;
    CString sz;
    CSize oldcs,newcs;

    if (m_pFont){
       delete m_pFont;
    }
    m_pFont = new CFont;

    // get charset for font (-> m_pEdit->m_logfont)

    ::EnumFontFamilies(
        dc.GetSafeHdc(),
        m_logfont.lfFaceName,
        (FONTENUMPROC)get_fontdata,
        LPARAM(this)
        );

    if (!m_pFont->CreateFontIndirect(&m_logfont)){
         TRACE(TEXT("CPEOBJ.ChgLogFont(): Unable to create font\n"));
    }
    theApp.m_last_logfont = m_logfont;

    if (m_pEdit){
        m_pEdit->SetFont(m_pFont);
    }

    SnapToFont(); // changing box size irratates Justin. Just snap for now

    Invalidate();
    pView->UpdateStatusBar();

    pView->UpdateStyleBar();
    CDrawDoc::GetDoc()->SetModifiedFlag();
}


//----------------------------------------------------------------------
void CDrawText::GetLongestString(CString& szLong)
{
   int linecount = (int)m_pEdit->SendMessage(EM_GETLINECOUNT,0,0L);

   if (linecount <= 0)
      return;

   TCHAR* sz;
   CString szHold;
   CString szTemp;
   int iSaveLen=0;
   WORD num;
   for (int i=0;i<linecount;i++) {
       int linelength = (int)m_pEdit->SendMessage(EM_LINELENGTH,(WPARAM)m_pEdit->SendMessage(EM_LINEINDEX,(WPARAM)i,0L),0L);
       if (linelength>0) {
          sz=new TCHAR[linelength+sizeof(TCHAR)];
          *(LPWORD)sz=(WORD)(linelength+sizeof(TCHAR));
          num = (WORD)m_pEdit->SendMessage(EM_GETLINE,(WPARAM)i,(LPARAM)(LPCSTR) sz);
                  sz[num]=(TCHAR)'\0';
                  szTemp=sz;
                  int j = szTemp.GetLength();
                  if ( j > iSaveLen) {
                     szHold=sz;
                         iSaveLen=j;
                  }
          delete [] sz;
           }
   }
   szLong=szHold;
}

//----------------------------------------------------------------------
void CDrawText::InitEditWnd()
{
    if (m_pEdit)
       return;
    m_pEdit = new CTextEdit;
    RECT rect;
    m_pEdit->Create(WS_CHILD | m_lStyle /*| ES_AUTOVSCROLL*/ | ES_NOHIDESEL | ES_MULTILINE, rect,
        CDrawView::GetView(), ID_TEXT);
}

//----------------------------------------------------------------------
void CDrawText::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
        LOGFONT lf;
    if (ar.IsStoring()) {
        ar.Write(&m_logfont, sizeof(LOGFONT));
                if (m_pEdit) {    //make sure that m_szEditText has window text
           FitEditWnd(NULL);
                }
        ar << m_lStyle;
        ar << m_szEditText;
        ar << m_crTextColor;
    }
    else {  ///  Reading in from a file
#ifdef UNICODE
         if( CDrawDoc::GetDoc()->m_bDataFileUsesAnsi ){

             //
             // Read in a LOGFONTA and convert it to a LOGFONT.
             //

              LOGFONTA LogFontA ;
              if( sizeof(LOGFONTA) != ar.Read( &LogFontA, sizeof(LOGFONTA))){
                  AfxThrowMemoryException() ; // Any exception will do.
                                              //CATCH_ALL in CDrawDoc::Serialize is the target.
              }
              memcpy( &m_logfont, &LogFontA, sizeof(LOGFONTA)-LF_FACESIZE) ;

              if( 0 == MultiByteToWideChar( CP_ACP,
                                            MB_PRECOMPOSED,
                                            LogFontA.lfFaceName,
                                            LF_FACESIZE,
                                            m_logfont.lfFaceName,
                                            LF_FACESIZE)){
                  AfxThrowMemoryException() ;
              }

         }
         else
#endif
        if(sizeof(LOGFONT) != ar.Read(&m_logfont,sizeof(LOGFONT))){
            AfxThrowMemoryException() ; // Any exception will do.
        }
        ar >> m_lStyle;
        ar >> m_szEditText;
        ar >> m_crTextColor;

                // Fix for 3405. Overide saved charset (codepage) with current
                //                               system charset. theApp.m_last_logfont is set
                //                               initially in CMainFrame::CreateStyleBar when
                //                               the CPE initializes so it is gaurenteed to be
                //                               valid by the time it gets here.
                m_logfont.lfCharSet = theApp.m_last_logfont.lfCharSet;

        ChgLogfont(lf,FALSE);
    }

    if (m_pEdit)
       m_pEdit->Serialize(ar);

    if (!ar.IsStoring()){
      SnapToFont();
      NewBrush();          /// Bug fix! unraided.  a-juliar 8-27-76
                           /// The text boxes were not being drawn with proper
                           /// background color when they had the input focus.
                           /// This bug was present in Windows 95 version.
    }
}



//---------------------------------------------------------------------------
int CDrawText::GetText( int numlines, BOOL delete_text )
        /*
                Returns number of ACTUAL remaining lines in editbox
         */
        {
        int linecount;
        int linelength;
        TCHAR* sz;
        WORD num;
        int i;
        int buflen;
        int zapline_char;
        int getline_char;


        m_szEditText=_T("");


        // see if there is any text
        linecount = m_pEdit->GetLineCount();
        if( (linecount == 1)&&(m_pEdit->LineLength( 0 ) == 0) )
                return( 0 );


        if( numlines > 0 )
                {
                if( numlines < linecount )
                        linecount = numlines;
                }


        for( i=0;i<linecount;i++ )
                {
                getline_char = m_pEdit->LineIndex( i );
                linelength = m_pEdit->LineLength( getline_char );
                if (linelength>0)
                        {
                        buflen = 2*linelength;
                        sz=new TCHAR[buflen+sizeof(TCHAR)];
                        num = (WORD)m_pEdit->GetLine( i, sz, buflen );
                        sz[num]=(TCHAR)'\0';
                        m_szEditText+=sz;

                        delete [] sz;
                        }

                if( i<linecount )
                        m_szEditText+=(TCHAR) '\n';
                }


        if( delete_text )
                {
                zapline_char = m_pEdit->LineIndex( linecount-1 );
                m_pEdit->SetSel( 0,
                                                 zapline_char +
                                                        m_pEdit->LineLength( zapline_char ),
                                                 TRUE );

                m_pEdit->Clear();
                }

        // see if there is still any text
        linecount = m_pEdit->GetLineCount();
        if( (linecount == 1)&&(m_pEdit->LineLength( 0 ) == 0) )
                return( 0 );
        else
                return( linecount );

}




//---------------------------------------------------------------------------
void CDrawText::SetText(CString& szText, CDrawView* pView)
{
   if (!m_pEdit)
      return;

   m_pEdit->SetWindowText(szText);

   FitEditWnd(pView);
}


//---------------------------------------------------------------------------
void CDrawText::OnDblClk(CDrawView* pView)
{
   ShowEditWnd(pView, TRUE);
}

//--------------------------------------------------------------------------------------------------
void CDrawText::NewBrush()
{
    if (m_brush)
       ::DeleteObject(m_brush);

    m_brush = ::CreateBrushIndirect(&m_logbrush);
}


//---------------------------------------------------------------------------------------------------
BOOL CDrawText::HitTestEdit(CDrawView* pView,CPoint& lpoint)
{
    if (pView->m_selection.GetCount()!=1)
      return FALSE;

    CRect cr = m_position;
    cr.NormalizeRect();

    CRect pointrc(lpoint, CSize(1, 1));
    CRect objrc = m_position;
    objrc.NormalizeRect();
    objrc.InflateRect(-5,-5);
    return !(pointrc & objrc).IsRectEmpty();
}


//---------------------------------------------------------------------------------------------------
BOOL CDrawText::ShowEditWnd(CDrawView* pView, BOOL Initialize)
{
    FitEditWnd(pView);
    pView->m_pObjInEdit=this;
    if( Initialize ){
        m_bUndoFont = FALSE ;
        m_bUndoAlignment = FALSE ;
        m_bUndoTextChange = FALSE ;
    }
    m_pEdit->ShowWindow(SW_NORMAL);
    m_pEdit->SetFocus();

    pView->Select(NULL, FALSE, FALSE);
    return TRUE;
}


//---------------------------------------------------------------------------
void CDrawText::HideEditWnd(CDrawView* pView, BOOL SaveUndoState )
{
    if (!pView->m_pObjInEdit)
       return;
    if( CanUndo() && SaveUndoState ){
       OnEditUndo();                // Revert to Text Box's previous state.
       pView->SaveStateForUndo();   // Gives the View a record of the Text Box's last change.
       OnEditUndo();                // Return to "present state".
       m_bUndoFont = FALSE ;
       m_bUndoTextChange = FALSE ;
       m_bUndoAlignment = FALSE ;   // Now the View should handle Undo.
    }

    pView->m_pObjInEdit=NULL;

    GetText();

    m_pEdit->ShowWindow(SW_HIDE);
}


//---------------------------------------------------------------------------
CFont* CDrawText::GetFont()
{
    return m_pFont;
}


//---------------------------------------------------------------------------
void CDrawText::Draw(CDC* pDC,CDrawView* pView)
{
    CPoint p;

        CFont *pNewFont = NULL;
    CFont* pOldFont=NULL;
    CBrush* pOldBrush=NULL;
    CPen* pOldPen=NULL;
    CBrush brush;
    CPen pen;

       //ALLOCATE GDI OBJECTS
    if (m_bBrush) {
       if (!brush.CreateBrushIndirect(&m_logbrush))
           return;
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen) {
       if (!pen.CreatePenIndirect(&m_logpen))
          return;
       pOldPen = pDC->SelectObject(&pen);
    }
    else {  //if no bPen & printing, use NULL pen
       if (pDC->IsPrinting()) {
          pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
       }
       else {   //default pen -- dashdot, gray border
          m_savepenstyle = m_logpen.lopnStyle;

//          m_logpen.lopnStyle = PS_DASH;
          m_logpen.lopnStyle = PS_DOT;

          m_savepencolor = m_logpen.lopnColor;
          m_logpen.lopnColor = RGB(192, 192, 192);
          m_logpen.lopnWidth.x = 1;
          m_logpen.lopnWidth.y = 1;
          pen.CreatePenIndirect(&m_logpen);
          pOldPen = pDC->SelectObject(&pen);
       }
    }


    CRect rect = m_position;

    CFont* pFont = NULL;
    if (pDC->IsPrinting() /*&& m_bPreview*/ ) {   //scale font to printer size
       LOGFONT logFont;
       memcpy(&logFont, &m_logfont, sizeof(m_logfont));
       pFont = new CFont;
       logFont.lfHeight = MulDiv(m_logfont.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       pFont->CreateFontIndirect(&logFont);
       pOldFont= pDC->SelectObject(pFont);

           SnapToFont_onthefly( pView, pDC, rect );
    }
    else {
       pOldFont= pDC->SelectObject(m_pEdit->GetFont());
        }

    pDC->Rectangle(rect);

    if (pView->m_pObjInEdit != this && m_szEditText.GetLength()>0) {

       int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
       int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       int x = -wx-1;
       int y = -wy-1;

       pView->DocToClient(rect,pDC);
       CPoint pW1=pDC->GetWindowOrg();
       CPoint pW2=pW1;
       pView->DocToClient(pW2,pDC);
       CPoint pV=pDC->GetViewportOrg();
       rect.InflateRect(x,y);
       pDC->SetMapMode(MM_TEXT);                                         //switch to MM_TEXT
       pDC->SetWindowOrg(pW2);
       pDC->SetViewportOrg(pV);
       pDC->SetTextColor(m_crTextColor);
       pDC->SetBkMode(TRANSPARENT);

       pDC->DrawText(m_szEditText,m_szEditText.GetLength(),rect,
                                 m_lStyle | DT_NOPREFIX );

/************TEMPORARY*******************/
//       pOldPen = pDC->SelectObject(
//                              CPen::FromHandle( (HPEN)GetStockObject( BLACK_PEN ) ) );
//
//       pDC->Rectangle(rect);
/****************************************/


       pDC->SetMapMode(MM_ANISOTROPIC);                  //switch back to MM_ANISOTROPHIC
       pDC->SetWindowOrg(pW1);
       pDC->SetViewportOrg(pV);
       pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
       pDC->SetWindowExt(100, -100);
    }

       //CLEANUP GDI OBJECTS
    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);

    if (!m_bPen) {
       m_logpen.lopnColor=m_savepencolor;
       m_logpen.lopnStyle=m_savepenstyle;
    }

    if (pOldFont)
       pDC->SelectObject(pOldFont);

    if (pFont)
       delete pFont;

    if (pNewFont)
       delete pNewFont;
}


//---------------------------------------------------------------------------
void CDrawText::FitEditWnd(CDrawView* pView, BOOL call_gettext, CDC *pdc )
{
   CClientDC dc(NULL);
   CRect rect = m_position;

   if( pdc == NULL )
        {
   if (pView==NULL)
     pView=CDrawView::GetView();

   pView->DocToClient(rect);

   if( pdc == NULL )
                pdc = &dc;


   int iX = pdc->GetDeviceCaps(LOGPIXELSX);
   int iY = pdc->GetDeviceCaps(LOGPIXELSY);
   int wx=MulDiv(m_logpen.lopnWidth.x, iX, 100);
   int wy=MulDiv(m_logpen.lopnWidth.y, iY, 100);
   int x = -wx-1;
   int y = -wy-1;
   rect.InflateRect(x,y);
        }

   m_pEdit->MoveWindow(&rect);

   m_pEdit->GetClientRect(&rect);         //set formatting rectangle to client area
   m_pEdit->SetRect(&rect);

   if( call_gettext )
                GetText();
}


//---------------------------------------------------------------------------
void CDrawText::MoveTo(const CRect& position, CDrawView* pView)
{
   CDrawRect::MoveTo(position, pView);
}

//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawText::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    CDrawRect::MoveHandleTo(nHandle, point, pView, uiShiftDraw);

    FitEditWnd(pView);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawText::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);
    CString copy_text;

    CDrawText* pClone = new CDrawText(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this; // copy geometry, style, etc., in one swoop

    // have to stuff in a few other things
    pClone->m_pEdit = NULL; // don't point to old one
    pClone->InitEditWnd();

    // make a new one
    pClone->m_brush = ::CreateBrushIndirect( &pClone->m_logbrush );

    // ditto
    if( (pClone->m_pFont = new CFont) != NULL )
    {
        pClone->m_pFont->CreateFontIndirect( &pClone->m_logfont );
        pClone->m_pEdit->SetFont( pClone->m_pFont, FALSE );
    }

        // copy text
        m_pEdit->GetWindowText( copy_text );
        pClone->m_pEdit->SetWindowText( copy_text );

        // and position
        pClone->m_position = m_position;


        // shoe it in
        pClone->FitEditWnd( NULL );

    if (pDoc != NULL)
        pDoc->Add(pClone);

    return pClone;
}





//*********************************************************************
// CFaxProp
//*********************************************************************

//---------------------------------------------------------------------------
CFaxProp::CFaxProp()
{
}


//---------------------------------------------------------------------------
CFaxProp::CFaxProp(const CRect& position,WORD wResourceid)
        : CDrawText(position)
{
    m_wResourceid=wResourceid;
}


//---------------------------------------------------------------------------
CFaxProp::~CFaxProp()
{
// F I X  for 3647 /////////////
//
// Zap m_last_note_box at note destroy time so we don't have
// a dangling pointer.
//
                if( m_wResourceid == IDS_PROP_MS_NOTE )
                        theApp.m_last_note_box = NULL;
////////////////////////////////
}


//----------------------------------------------------------------------
void CFaxProp::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawText::Serialize(ar);

    if (ar.IsStoring()) {
        ar << (WORD)m_wResourceid;
    }
    else {
        ar >> m_wResourceid;
        if (GetApp()->m_dwSesID!=0) {    //rendering
           GetApp()->m_pFaxMap->GetPropString(m_wResourceid,m_szEditText);
           m_pEdit->SetWindowText(m_szEditText);
           FitEditWnd(CDrawView::GetView());

// F I X  for 3647 /////////////
//
// set m_last_note_box at note creation time instead of at
// draw time.
//
                if( m_wResourceid == IDS_PROP_MS_NOTE )
                        theApp.m_last_note_box = this;
////////////////////////////////
        }
    }
}


//---------------------------------------------------------------------------------------------------
BOOL CFaxProp::ShowEditWnd(CDrawView* pView, BOOL Initialize )
{
    return FALSE;    //fax property object doesnt support editing
}


//---------------------------------------------------------------------------
void CFaxProp::HideEditWnd(CDrawView* pView, BOOL SaveUndoState )
{
    return;    //never shown, never hidden
}



//---------------------------------------------------------------------------
CFaxProp& CFaxProp::operator=(const CFaxProp& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawText::operator=(rdo);  //assign cdrawrect part

   m_wResourceid = rdo.m_wResourceid;

   return *this;
}


//---------------------------------------------------------------------------
void CFaxProp::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

        LPTSTR draw_str;
        UINT   draw_style;
    CFont* pOldFont=NULL;
    CBrush* pOldBrush=NULL;
    CPen* pOldPen=NULL;
    CBrush brush;
    CPen pen;
        long draw_strlen;
        CRect note_rect;
        int num_pages;

       //ALLOCATE GDI OBJECTS
    if (m_bBrush) {
       if (!brush.CreateBrushIndirect(&m_logbrush))
           return;
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen) {
       if (!pen.CreatePenIndirect(&m_logpen))
          return;
       pOldPen = pDC->SelectObject(&pen);
    }
    else {  //if no bPen & printing, use NULL pen
       if (pDC->IsPrinting()) {
          pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
       }
       else {   //default pen -- dashdot, gray border
          m_savepenstyle = m_logpen.lopnStyle;

//          m_logpen.lopnStyle = PS_DASH;
          m_logpen.lopnStyle = PS_DOT;

          m_savepencolor = m_logpen.lopnColor;
          m_logpen.lopnColor = RGB(192, 192, 192);
          m_logpen.lopnWidth.x = 1;
          m_logpen.lopnWidth.y = 1;
          pen.CreatePenIndirect(&m_logpen);
          pOldPen = pDC->SelectObject(&pen);
       }
    }

    CRect rect = m_position;

    CFont* pFont = NULL;
    if (pDC->IsPrinting() /*&& m_bPreview*/ ) {   //scale font to printer size
       LOGFONT logFont;
       memcpy(&logFont, &m_logfont, sizeof(m_logfont));
       pFont = new CFont;
       logFont.lfHeight = MulDiv(m_logfont.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       pFont->CreateFontIndirect(&logFont);
       pOldFont= pDC->SelectObject(pFont);

                SnapToFont_onthefly( pView, pDC, rect );
    }
    else {
       pOldFont= pDC->SelectObject(m_pEdit->GetFont());
        }

// F I X  for 3647 /////////////
//
// Don't draw anything if this is an extra notepage disguised as
// a page-no object.
//
// (see the code with clip_note in it below for why)
//
        if( !((theApp.m_extra_notepage == this)&&
                  (theApp.m_extra_notepage->m_wResourceid == IDS_PROP_MS_NOPG)) )
        pDC->Rectangle( rect );
////////////////////////////////

    if( (m_szEditText.GetLength()>0)||
        (m_wResourceid == IDS_PROP_MS_NOTE) ) {
       int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
       int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       int x = -wx-1;
       int y = -wy-1;
       pView->DocToClient(rect,pDC);
       CPoint pW1=pDC->GetWindowOrg();
       CPoint pW2=pW1;
       pView->DocToClient(pW2,pDC);
       CPoint pV=pDC->GetViewportOrg();
       rect.InflateRect(x,y);

                if( (m_wResourceid == IDS_PROP_MS_NOPG)&&
                        theApp.m_note_wasread &&
                        (theApp.m_extrapage_count < 0)&&
                        (theApp.m_extra_notepage != NULL) )
                        {
                        note_rect = theApp.m_extra_notepage->m_position;
                pView->DocToClient( note_rect,pDC );
                note_rect.InflateRect(x,y);
                        }


       pDC->SetMapMode(MM_TEXT);                                         //switch to MM_TEXT
       pDC->SetWindowOrg(pW2);
       pDC->SetViewportOrg(pV);
       pDC->SetTextColor(m_crTextColor);
       pDC->SetBkMode(TRANSPARENT);

                draw_style = m_lStyle | DT_NOPREFIX;

                // stuff for notes
                if( (m_wResourceid == IDS_PROP_MS_NOTE)&&
                        theApp.m_note_wasread )
                        {
                        theApp.clip_note( pDC, &draw_str, &draw_strlen, TRUE, rect );

// F I X  for 3647 /////////////
//
// Don't set m_last_note_box here! Set it in CFaxProp::Serialize
//
//                      theApp.m_last_note_box = this;
                        }
                else
                if( (m_wResourceid == IDS_PROP_MS_NOPG)&&
                        theApp.m_note_wasread )
                        {
                        if( (theApp.m_extrapage_count < 0)&&
                                (theApp.m_extra_notepage != NULL) )
                                {

// F I X  for 3647 /////////////
//
// PROBLEM: Wrong dc attributes are in place at this point to
//                      properly calculate pages left. Must temporarialy switch
//                      to extra note's attributes by recursively calling
//                      Draw for the extra note with its id temporarialy set to
//                      a page-no object so that it will calculate the correct
//                      pages left and NOT draw anything in the process.
//
                                if( theApp.m_extra_notepage == this )
                                        {
                                        // We are in the second level of recursion
                                        // here. This is extra notepage disguised as a
                                        // page-no object. Calculate pages left.
                                        theApp.m_extrapage_count =
                                                theApp.clip_note( pDC, &draw_str, &draw_strlen,
                                                                                  FALSE, note_rect );
                                        }
                                else
                                        {
                                        // We are in the first level of recursion here.
                                        // Make extra note look like a page-no object.
                                        theApp.m_extra_notepage->m_wResourceid =
                                                        IDS_PROP_MS_NOPG;
                                        theApp.m_extra_notepage->m_szEditText = m_szEditText;

                                // switch back to MM_ANISOTROPHIC so mapping will be
                                        // correct for Draw call
                                pDC->SetMapMode(MM_ANISOTROPIC);
                                pDC->SetWindowOrg(pW1);
                                pDC->SetViewportOrg(pV);
                                pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
                                pDC->SetWindowExt(100, -100);

                                        // recursively call Draw to force calc of re,aomomgpages
                                        // left using correct font, etc.
                                        theApp.m_extra_notepage->Draw( pDC, pView );

                                        // restore mapping mode so page-no will draw correctly
                                pDC->SetMapMode(MM_TEXT);
                                pDC->SetWindowOrg(pW2);
                                pDC->SetViewportOrg(pV);
                                pDC->SetTextColor(m_crTextColor);
                                pDC->SetBkMode(TRANSPARENT);


                                        // restore extra note's true identity
                                        theApp.m_extra_notepage->m_wResourceid =
                                                        IDS_PROP_MS_NOTE;
                                        }
                                }

                        // If this isn't extra notepage in disguise then
                        // do normal page-no thing
                        if( theApp.m_extra_notepage != this )
                                {
                                num_pages = _ttoi( (LPCTSTR)m_szEditText );
                                num_pages += theApp.m_extrapage_count;
                                m_szEditText.Format( TEXT("%i"), num_pages );
                                draw_str = (LPTSTR)(LPCTSTR)m_szEditText;
                                draw_strlen = lstrlen( draw_str );
                                }
////////////////////////////////
                        }
                //end of stuff for notes
                else
                        {
                        draw_str = (LPTSTR)(LPCTSTR)m_szEditText;
                        draw_strlen = lstrlen( draw_str );
                        }

// F I X  for 3647 /////////////
//
// Don't draw anything if this is an extra notepage disguised as
// a page-no object.
//
// (see the code with clip_note in it above for why)
//
        if( !((theApp.m_extra_notepage == this)&&
                  (theApp.m_extra_notepage->m_wResourceid == IDS_PROP_MS_NOPG)) )
                {
                pDC->DrawText( draw_str, draw_strlen, rect, draw_style);
                }
////////////////////////////////

       pDC->SetMapMode(MM_ANISOTROPIC);                  //switch back to MM_ANISOTROPHIC
       pDC->SetWindowOrg(pW1);
       pDC->SetViewportOrg(pV);
       pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
       pDC->SetWindowExt(100, -100);
    }

       //CLEANUP GDI OBJECTS
    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);

    if (!m_bPen) {
       m_logpen.lopnColor=m_savepencolor;
       m_logpen.lopnStyle=m_savepenstyle;
    }

    if (pOldFont)
       pDC->SelectObject(pOldFont);

    if (pFont)
       delete pFont;
}



//---------------------------------------------------------------------------
CDrawObj* CFaxProp::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CFaxProp* pClone = new CFaxProp(m_position,m_wResourceid);

    ASSERT_VALID(pClone);

    *pClone=*this;
    CString szCaption;
    szCaption.LoadString( m_wResourceid );
    pClone->SetText( szCaption, CDrawView::GetView() );
    if (pDoc != NULL){
        pDoc->Add(pClone);
    }
    ASSERT_VALID(pClone);
    return pClone;
}





//*********************************************************************
// CDrawLine
//*********************************************************************


//---------------------------------------------------------------------------
CDrawLine::CDrawLine()
{
}


//---------------------------------------------------------------------------
CDrawLine::~CDrawLine()
{
}

//---------------------------------------------------------------------------
CDrawLine::CDrawLine(const CRect& position)
        : CDrawRect(position)
{
}


//----------------------------------------------------------------------
void CDrawLine::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
}


//----------------------------------------------------------------------
void CDrawLine::NegAdjustLineForPen(CRect& rect)
{
    if (rect.top > rect.bottom) {
       rect.top += m_logpen.lopnWidth.y / 2;
       rect.bottom -= (m_logpen.lopnWidth.y + 1) / 2;
    }
    else {
       rect.top -= (m_logpen.lopnWidth.y + 1) / 2;
       rect.bottom += m_logpen.lopnWidth.y / 2;
    }

    if (rect.left > rect.right) {
       rect.left += m_logpen.lopnWidth.x / 2;
       rect.right -= (m_logpen.lopnWidth.x + 1) / 2;
    }
    else {
       rect.left -= (m_logpen.lopnWidth.x + 1) / 2;
       rect.right += m_logpen.lopnWidth.x / 2;
    }
}


//----------------------------------------------------------------------
void CDrawLine::AdjustLineForPen(CRect& rect)
{

        // added by v-randr 2/15/95
        if( (rect.left == rect.right)&&(rect.top == rect.bottom) )
                return;

    if (rect.top > rect.bottom) {
       rect.top -= m_logpen.lopnWidth.y / 2;
       rect.bottom += (m_logpen.lopnWidth.y + 1) / 2;
    }
    else {
       rect.top += (m_logpen.lopnWidth.y + 1) / 2;
       rect.bottom -= m_logpen.lopnWidth.y / 2;
    }

    if (rect.left > rect.right) {
       rect.left -= m_logpen.lopnWidth.x / 2;
       rect.right += (m_logpen.lopnWidth.x + 1) / 2;
    }
    else {
       rect.left += (m_logpen.lopnWidth.x + 1) / 2;
       rect.right -= m_logpen.lopnWidth.x / 2;
    }
}


//---------------------------------------------------------------------------
void CDrawLine::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
      TRACE(TEXT("AWCPE: CDrawLine::Invalidate, missing View pointer\n"));
      return;
   }

   CRect rect = m_position;

   if (rect.top > rect.bottom) {
      rect.top += m_logpen.lopnWidth.y;
      rect.bottom -= m_logpen.lopnWidth.y;
   }
   else {
      rect.top -= m_logpen.lopnWidth.y;
      rect.bottom += m_logpen.lopnWidth.y;
   }

   if (rect.left > rect.right) {
      rect.left += m_logpen.lopnWidth.x;
      rect.right -= m_logpen.lopnWidth.x;
   }
   else {
      rect.left -= m_logpen.lopnWidth.x;
      rect.right += m_logpen.lopnWidth.x;
   }

   pView->DocToClient(rect);

   if (pView->IsSelected(this)) {
        rect.left -= 4;
        rect.top -= 5;
        rect.right += 5;
        rect.bottom += 4;
   }

   pView->InvalidateRect(rect, FALSE);

//   pView->ClientToDoc(rect);
//   CClientDC dc(pView);
//   pView->OnPrepareDC(&dc,NULL);
//   CPen pen(PS_SOLID,1,RGB(255,0,0));
//   dc.SelectObject(&pen);
//   dc.SelectStockObject(NULL_BRUSH);
//   dc.Rectangle(rect);
}


//---------------------------------------------------------------------------
void CDrawLine::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen* pOldPen;
    CBrush brush;
    if (!brush.CreateBrushIndirect(&m_logbrush))
        return;
    CPen pen;
    if (!pen.CreatePenIndirect(&m_logpen))
        return;

    if (m_bBrush)
       pOldBrush = pDC->SelectObject(&brush);
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen)
       pOldPen = pDC->SelectObject(&pen);
    else
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);

    CRect rect = m_position;

    AdjustLineForPen(rect);

    pDC->MoveTo( rect.TopLeft() );
    pDC->LineTo( rect.BottomRight() );

//    CPen p(PS_DOT,1,RGB(0,255,0));  //testing
//    pDC->SelectObject(&p);
//    pDC->SelectStockObject(NULL_BRUSH);
//    pDC->Rectangle(m_position);
//    TRACE("m_position coordinates: (%i,%i), (%i,%i)",m_position.left,m_position.top,m_position.right,m_position.bottom);
//    TRACE(", drawing coordinates: (%i,%i), (%i,%i)\n",rect.left,rect.top,rect.right,rect.bottom);

    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);
}



//---------------------------------------------------------------------------
int CDrawLine::GetHandleCount()
{
    ASSERT_VALID(this);

    return 2;
}


//---------------------------------------------------------------------------
// returns center of handle in logical coordinates
//---------------------------------------------------------------------------
CPoint CDrawLine::GetHandle(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 2)
       nHandle = 5;

    return CDrawRect::GetHandle(nHandle);
}


//---------------------------------------------------------------------------
HCURSOR CDrawLine::GetHandleCursor(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 2)
        nHandle = 5;

    return CDrawRect::GetHandleCursor(nHandle);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawLine::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawLine* pClone = new CDrawLine(m_position);

    *pClone=*this;

    ASSERT_VALID(pClone);

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}

// rearranged by v-randr 2/15/95
#define PI (3.14159)
#define ONESIXTH_PI   (PI/6)
#define ONETHIRD_PI   (PI/3)
#define ONEHALF_PI    (PI/2)
#define ONEFORTH_PI   (PI/4)
#define THREEFORTH_PI (PI*3/4)
#define TWOTHIRD_PI   (PI*2/3)
#define FIVESIXTH_PI  (PI*5/6)


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawLine::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    CRect position = m_position;

    if (nHandle == 2)
        nHandle = 5;

    switch (nHandle) {
    case 1:
        if (uiShiftDraw & SHIFT_DRAW) {
           if (uiShiftDraw & SHIFT_TOOL) {
               BOOL bNegR=FALSE;
                           double radian = atan2((double)(point.y-position.bottom),(double)(point.x-position.right));
                           if (radian < 0) {
                              radian *= -1;
                                  bNegR=TRUE;
                           }
                           if (radian >= 0 && radian < ONESIXTH_PI) {
                   position.left = point.x;
                   position.top = (long) (tan(0.0f) * (point.x - position.right) + position.bottom ) - 1;
                           }
                           else
                           if (radian >= ONESIXTH_PI && radian < ONETHIRD_PI) {
                               if (radian >= ONESIXTH_PI && radian < ONEFORTH_PI) {
                      position.left = point.x;
                      position.top = (long) (tan(((bNegR)?-ONEFORTH_PI:ONEFORTH_PI)) * (point.x - position.right) + position.bottom );
                                   }
                                   else {
                      position.top = point.y;
                      position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-ONEFORTH_PI:ONEFORTH_PI))  + position.right );
                                   }
                           }
                           else
                           if (radian >= ONETHIRD_PI && radian < TWOTHIRD_PI) {
                   position.top = point.y;
                   position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-ONEHALF_PI:ONEHALF_PI))  + position.right);
                           }
                           else
                           if (radian >= TWOTHIRD_PI && radian < FIVESIXTH_PI) {
                               if (radian >= TWOTHIRD_PI && radian < THREEFORTH_PI) {
                      position.top = point.y;
                      position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-THREEFORTH_PI:THREEFORTH_PI))  + position.right );
                                   }
                                   else {
                      position.left = point.x;
                      position.top = (long) (tan(((bNegR)?-THREEFORTH_PI:THREEFORTH_PI)) * (point.x - position.right) + position.bottom );
                                   }
                           }
                           else
                           if (radian >= FIVESIXTH_PI && radian < PI) {
                   position.left = point.x;
                   position.top = (long) (tan(PI) * (point.x - position.right) + position.bottom -1);
                           }

                        // make sure rect isn't too skinny, added 2/14/95 by v-randr
                        if( CDrawTool::c_down != point )
                                {
                                if( (position.left == position.right)&&
                                        (position.top != position.bottom) )
                                        position.left = position.right-1;
                                }

               }
                   else {
                           BOOL bNegR=FALSE;
                           double radianTL = atan2((double)(position.top-position.bottom),(double)(position.left-position.right));
                           if (radianTL < 0) {
                              radianTL *= -1;
                                  bNegR=TRUE;
                           }

               if (pView->m_bShiftSignal ) {
                               TRACE(TEXT("shift signaled--slope is being calculated\n"));
                           if (position.left - position.right != 0) {
                                  float temp = (position.top - position.bottom)  / (float) (position.left - position.right);
                                      if (temp>0)
                                         temp += (float)0.005;
                                      else
                                         temp -= (float)0.005;
                                      temp *= 100;
                     m_iSlope = (int)temp;
                  }
                              m_iB = (position.bottom*100 - m_iSlope*position.right);
                                  pView->m_bShiftSignal=FALSE;
                           }

                           if ( (radianTL >= 0 && radianTL < ONEFORTH_PI) || (radianTL >= THREEFORTH_PI && radianTL < PI)) {
                               position.left = point.x;
                                   int temp = position.left* m_iSlope + m_iB;
                                   if (temp>0)
                                      temp += 50;
                                   else
                                      temp -= 50;
                               position.top = temp/100;
                           }
                           else {
                              position.top = point.y;
                                  if (m_iSlope != 0) {
                                  float temp = (position.top*100 - m_iB) / (float)m_iSlope;
                                      if (temp>0)
                                        temp += (float).5;
                                      else
                                        temp -= (float).5;
                                  position.left = (long) temp;
                                  }
                           }
//             TRACE("slope(%i), yint(%i)\n",m_iSlope, m_iB);
                   }
        }
                else {
           CDrawRect::MoveHandleTo(nHandle, point, pView);
                   return;
                }
        break;
    case 5:
        if (uiShiftDraw & SHIFT_DRAW) {
                           BOOL bNegR=FALSE;
                           double radianTL = atan2((double)(position.top-position.bottom),(double)(position.left-position.right));
                           if (radianTL < 0) {
                              radianTL *= -1;
                                  bNegR=TRUE;
                           }

               if (pView->m_bShiftSignal ) {
                               TRACE(TEXT("shift signaled--slope is being calculated\n"));
                           if (position.left - position.right != 0) {
                                  float temp = (position.top - position.bottom)  / (float) (position.left - position.right);
                                      if (temp>0)
                                         temp += (float)0.005;
                                      else
                                         temp -= (float)0.005;
                                      temp *= 100;
                     m_iSlope = (int)temp;
                  }
                              m_iB = (position.bottom*100 - m_iSlope*position.right);
                                  pView->m_bShiftSignal=FALSE;
                           }

                           if ( (radianTL >= 0 && radianTL < ONEFORTH_PI) || (radianTL >= THREEFORTH_PI && radianTL < PI)) {
                               position.right = point.x;
                                   int temp = position.right* m_iSlope + m_iB;
                                   if (temp>0)
                                      temp += 50;
                                   else
                                      temp -= 50;
                               position.bottom = temp/100;
                           }
                           else {
                              position.bottom = point.y;
                                  if (m_iSlope != 0) {
                                  float temp = (position.bottom*100 - m_iB) / (float)m_iSlope;
                                      if (temp>0)
                                        temp += (float).5;
                                      else
                                        temp -= (float).5;
                                  position.right = (long) temp;
                                  }
                           }
            }
                else {
           CDrawRect::MoveHandleTo(nHandle, point, pView);
                   return;
                }
        break;

    default:
        CDrawRect::MoveHandleTo(nHandle, point, pView);
        return;
        }

    MoveTo(position, pView);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawLine::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

        CRect rectT = rect;
        rectT.NormalizeRect();

    if (bShortCut) {
        CRect fixed = m_position;
        fixed.NormalizeRect();
        return (!(rectT & fixed).IsRectEmpty() );
    }

        CDrawView* pView=CDrawView::GetView();
    CClientDC dc(pView);

    dc.BeginPath();
        Draw(&dc,pView);   //draw into GDI path
        dc.EndPath();

    CPen pen;
        LOGPEN lp=m_logpen;
    pen.CreatePenIndirect(&lp);
    CPen* oldpen= dc.SelectObject(&pen);
    dc.WidenPath();
    HRGN hregion;
        hregion = ::PathToRegion(dc.GetSafeHdc());
    dc.SelectObject(oldpen);
    BOOL b= ::RectInRegion(hregion,rectT);
    ::DeleteObject(hregion);
        return b;
}



//*********************************************************************
// CDrawRoundRect
//*********************************************************************


//----------------------------------------------------------------------
CDrawRoundRect::CDrawRoundRect()
{
}


//----------------------------------------------------------------------
CDrawRoundRect::~CDrawRoundRect()
{
}


//----------------------------------------------------------------------
CDrawRoundRect::CDrawRoundRect(const CRect& position)
        : CDrawRect(position)
{
    m_roundness.x = 16;
    m_roundness.y = 16;
}


//----------------------------------------------------------------------
void CDrawRoundRect::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
    if (ar.IsStoring())
        ar << m_roundness;
    else
        ar >> m_roundness;
}



//----------------------------------------------------------------------
void CDrawRoundRect::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen* pOldPen;
    CBrush brush;
    if (!brush.CreateBrushIndirect(&m_logbrush))
        return;
    CPen pen;
    if (!pen.CreatePenIndirect(&m_logpen))
        return;

    if (m_bBrush)
       pOldBrush = pDC->SelectObject(&brush);
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen)
       pOldPen = pDC->SelectObject(&pen);
    else
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);

    pDC->RoundRect(m_position, m_roundness);

    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);
}



//----------------------------------------------------------------------
// returns center of handle in logical coordinates
CPoint CDrawRoundRect::GetHandle(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 9) {
        CRect rect = m_position;
        rect.NormalizeRect();
        CPoint point = rect.BottomRight();
        point.x -= m_roundness.x / 2;
        point.y -= m_roundness.y / 2;
        return point;
    }

    return CDrawRect::GetHandle(nHandle);
}

//----------------------------------------------------------------------
HCURSOR CDrawRoundRect::GetHandleCursor(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 9)
        return AfxGetApp()->LoadStandardCursor(IDC_SIZE);

    return CDrawRect::GetHandleCursor(nHandle);
}


//----------------------------------------------------------------------
void CDrawRoundRect::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    if (nHandle == 9) {
        CRect rect = m_position;
        rect.NormalizeRect();
        if (point.x > rect.right - 1)
                point.x = rect.right - 1;
        else if (point.x < rect.left + rect.Width() / 2)
                point.x = rect.left + rect.Width() / 2;
        if (point.y > rect.bottom - 1)
                point.y = rect.bottom - 1;
        else if (point.y < rect.top + rect.Height() / 2)
                point.y = rect.top + rect.Height() / 2;
        m_roundness.x = 2 * (rect.right - point.x);
        m_roundness.y = 2 * (rect.bottom - point.y);
        m_pDocument->SetModifiedFlag();
        Invalidate();
        return;
    }

    CDrawRect::MoveHandleTo(nHandle, point, pView, uiShiftDraw);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawRoundRect::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect rectT = rect;
    rectT.NormalizeRect();

    CRect fixed = m_position;
    fixed.NormalizeRect();

    if( bShortCut ){
        return !(fixed & rectT).IsRectEmpty();
    }

    if ((rectT & fixed).IsRectEmpty())
        return FALSE;

    CRgn rgn;
    rgn.CreateRoundRectRgn(fixed.left, fixed.top, fixed.right, fixed.bottom,
        m_roundness.x, m_roundness.y);

    return rgn.RectInRegion(fixed);
}


//---------------------------------------------------------------------------
CDrawRoundRect& CDrawRoundRect::operator=(const CDrawRoundRect& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawRect::operator=(rdo);  //assign cdrawrect part

   m_roundness = rdo.m_roundness;

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawRoundRect::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawRoundRect* pClone = new CDrawRoundRect(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//*********************************************************************
// CDrawEllipse
//*********************************************************************

//----------------------------------------------------------------------
CDrawEllipse::CDrawEllipse()
{
}

//----------------------------------------------------------------------
CDrawEllipse::~CDrawEllipse()
{
}


//----------------------------------------------------------------------
CDrawEllipse::CDrawEllipse(const CRect& position)
        : CDrawRect(position)
{
}


//----------------------------------------------------------------------
void CDrawEllipse::Serialize(CArchive& ar)
{
    CDrawRect::Serialize(ar);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawEllipse::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawEllipse* pClone = new CDrawEllipse(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//----------------------------------------------------------------------
void CDrawEllipse::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);
    CBrush* pOldBrush;
    CPen* pOldPen;
    CBrush brush;
    if (!brush.CreateBrushIndirect(&m_logbrush))
        return;
    CPen pen;
    if (!pen.CreatePenIndirect(&m_logpen))
        return;

    if (m_bBrush)
       pOldBrush = pDC->SelectObject(&brush);
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen)
       pOldPen = pDC->SelectObject(&pen);
    else
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);

    pDC->Ellipse(m_position);

    if (pOldBrush)
       pDC->SelectObject(pOldBrush);
    if (pOldPen)
       pDC->SelectObject(pOldPen);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawEllipse::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect rectT = rect;
    rectT.NormalizeRect();

    CRect fixed = m_position;
    fixed.NormalizeRect();
        CRgn rgn;
    if( bShortCut ){
        return !(fixed & rectT).IsRectEmpty();
    }
    if ((rectT & fixed).IsRectEmpty())
        return FALSE;

    rgn.CreateEllipticRgnIndirect(fixed);

    return rgn.RectInRegion(fixed);
}




//--------------------------------------------------------------------------
// CDrawPoly
//--------------------------------------------------------------------------

//---------------------------------------------------------------------------
CDrawPoly::CDrawPoly()
{
    m_points = NULL;
    m_nPoints = 0;
    m_nAllocPoints = 0;
}

//---------------------------------------------------------------------------
CDrawPoly::CDrawPoly(const CRect& position)
        : CDrawObj(position)
{
    m_points = NULL;
    m_nPoints = 0;
    m_nAllocPoints = 0;
    m_bPen = TRUE;
    m_bBrush = FALSE;
}

//---------------------------------------------------------------------------
CDrawPoly::~CDrawPoly()
{
    if (m_points != NULL)
       delete m_points;
}


//---------------------------------------------------------------------------
void CDrawPoly::Serialize( CArchive& ar )
{
    int i;
    CDrawObj::Serialize( ar );
    if( ar.IsStoring() ) {
        ar << (WORD) m_nPoints;
        ar << (WORD) m_nAllocPoints;
        for (i = 0;i< m_nPoints; i++)
                ar << m_points[i];
    }
    else  {
        WORD wTemp;
        ar >> wTemp; m_nPoints = wTemp;
        ar >> wTemp; m_nAllocPoints = wTemp;
        m_points = NewPoints(m_nAllocPoints);
        for (i = 0;i < m_nPoints; i++)
                ar >> m_points[i];
    }
}

//---------------------------------------------------------------------------
void CDrawPoly::Draw(CDC* pDC,CDrawView*)
{
    ASSERT_VALID(this);

    CBrush brush;
    if (!brush.CreateBrushIndirect(&m_logbrush))
        return;
    CPen pen;
    if (!pen.CreatePenIndirect(&m_logpen))
        return;

    CBrush* pOldBrush;
    CPen* pOldPen;

    if (m_bBrush)
       pOldBrush = pDC->SelectObject(&brush);
    else
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

    if (m_bPen)
        pOldPen = pDC->SelectObject(&pen);
    else
        pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);

    pDC->Polygon(m_points, m_nPoints);

    pDC->SelectObject(pOldBrush);
    pDC->SelectObject(pOldPen);
}


//---------------------------------------------------------------------------
// position must be in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::MoveTo(const CRect& position, CDrawView* pView)
{
    ASSERT_VALID(this);
    if (position == m_position)
        return;

    Invalidate();

    for (int i = 0; i < m_nPoints; i += 1)  {
        m_points[i].x += position.left - m_position.left;
        m_points[i].y += position.top - m_position.top;
    }

    m_position = position;

        Invalidate();

    m_pDocument->SetModifiedFlag();
}


//---------------------------------------------------------------------------
int CDrawPoly::GetHandleCount()
{
    return m_nPoints;
}


//---------------------------------------------------------------------------
CPoint CDrawPoly::GetHandle(int nHandle)
{
    ASSERT_VALID(this);

    ASSERT(nHandle >= 1 && nHandle <= m_nPoints);
    return m_points[nHandle - 1];
}


//---------------------------------------------------------------------------
// return rectange of handle in logical coords
//---------------------------------------------------------------------------
CRect CDrawPoly::GetHandleRect(int nHandleID, CDrawView* pView)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    CRect rect;
    // get the center of the handle in logical coords
    CPoint point = GetHandle(nHandleID);
    // convert to client/device coords
    pView->DocToClient(point);
    // return CRect of handle in device coords
    rect.SetRect(point.x-3, point.y-3, point.x+3, point.y+3);
    pView->ClientToDoc(rect);

    return rect;
}



//---------------------------------------------------------------------------
int CDrawPoly::HitTest(CPoint point, CDrawView* pView, BOOL bSelected)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    if (bSelected) {
        int nHandleCount = GetHandleCount();
        for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) {
            // GetHandleRect returns in logical coords
            CRect rc = GetHandleRect(nHandle,pView);
            if (point.x >= rc.left && point.x < rc.right &&
                point.y <= rc.top && point.y > rc.bottom)
                return nHandle;
        }
    }
    else  {
       if (point.x >= m_position.left && point.x < m_position.right &&
             point.y <= m_position.top && point.y > m_position.bottom)
          return 1;
    }
    return 0;
}




//---------------------------------------------------------------------------
HCURSOR CDrawPoly::GetHandleCursor(int nHandle )
{
    CPoint p1;
    LPCTSTR id;
    CPoint p2;

    if (nHandle==1)
      p1 = m_points[m_nPoints - 1];
        else
      p1 = m_points[nHandle - 2];

    if (nHandle==m_nPoints)
      p2 = m_points[0];
        else
      p2 = m_points[nHandle];

    float m =  ((p2.x-p1.x)!=0) ? (p2.y-p1.y) / ((float)(p2.x-p1.x)) : 9999;

    if (m>=3 || m<=-3)
       id = IDC_SIZEWE;
        else
       if (m>.3)
          id = IDC_SIZENWSE;
       else
              if (m<-.3)
             id = IDC_SIZENESW;
              else
             id = IDC_SIZENS;

//    TRACE("CDrawPoly::GetHandleCursor, handle: %i, P1(%i,%i), P2(%i,%i), slope: %3.2f\n",nHandle,p1.x,p1.y,p2.x,p2.y,m);

    return AfxGetApp()->LoadStandardCursor(id);
//    return AfxGetApp()->LoadStandardCursor(IDC_ARROW);
}


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView, UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);
    ASSERT(nHandle >= 1 && nHandle <= m_nPoints);
    if (m_points[nHandle - 1] == point)
        return;

    m_points[nHandle - 1] = point;
    RecalcBounds(pView);

    Invalidate();
    m_pDocument->SetModifiedFlag();
}

//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawPoly::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);
    CRgn rgn;
    if( bShortCut ){
        return TRUE ; // Called by CDrawDoc::Draw().  Skip the test and just Draw().
    }
    rgn.CreatePolygonRgn(m_points, m_nPoints, ALTERNATE);
    return rgn.RectInRegion(rect);
}


//---------------------------------------------------------------------------
CDrawPoly& CDrawPoly::operator=(const CDrawPoly& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawObj::operator=(rdo);  //assign cobject part

   m_points = NewPoints(rdo.m_nAllocPoints);
   memcpy(m_points, rdo.m_points, sizeof(CPoint) * rdo.m_nPoints);
   m_nAllocPoints = rdo.m_nAllocPoints;
   m_nPoints = rdo.m_nPoints;

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawPoly::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawPoly* pClone = new CDrawPoly(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::AddPoint(const CPoint& point, CDrawView* pView)
{
    ASSERT_VALID(this);
    if (m_nPoints == m_nAllocPoints) {
        CPoint* newPoints = NewPoints(m_nAllocPoints + 10);
        if (m_points != NULL) {
             memcpy(newPoints, m_points, sizeof(CPoint) * m_nAllocPoints);
             delete m_points;
        }
        m_points = newPoints;
        m_nAllocPoints += 10;
    }

    if (m_nPoints == 0 || m_points[m_nPoints - 1] != point) {
        m_points[m_nPoints++] = point;
        if (!RecalcBounds(pView)) {
            Invalidate();
        }
        m_pDocument->SetModifiedFlag();
    }
}


//---------------------------------------------------------------------------
CPoint* CDrawPoly::NewPoints(int nPoints)
{
    return (CPoint*)new BYTE[nPoints * sizeof(CPoint)];
}


//---------------------------------------------------------------------------
BOOL CDrawPoly::RecalcBounds(CDrawView* pView)
{
    ASSERT_VALID(this);

    if (m_nPoints == 0)
        return FALSE;

    CRect bounds(m_points[0], CSize(0, 0));
    for (int i = 1; i < m_nPoints; ++i) {
        if (m_points[i].x < bounds.left)
                bounds.left = m_points[i].x;
        if (m_points[i].x > bounds.right)
                bounds.right = m_points[i].x;
        if (m_points[i].y < bounds.top)
                bounds.top = m_points[i].y;
        if (m_points[i].y > bounds.bottom)
                bounds.bottom = m_points[i].y;
    }

    if (bounds == m_position)
        return FALSE;

    Invalidate();

    m_position = bounds;

    Invalidate();

    return TRUE;
}


BOOL CDrawOleObj::c_bShowItems = FALSE;


//---------------------------------------------------------------------------
CDrawOleObj::CDrawOleObj() : m_extent(0,0)
{
    m_pClientItem = NULL;
}


//---------------------------------------------------------------------------
CDrawOleObj::CDrawOleObj(const CRect& position)
        : CDrawObj(position), m_extent(0,0)
{
    m_pClientItem = NULL;
}


//---------------------------------------------------------------------------
void CDrawOleObj::Serialize( CArchive& ar )
{
    ASSERT_VALID(this);

    CDrawObj::Serialize(ar);

    if (ar.IsStoring()) {
        ar << m_extent;
        ar << m_pClientItem;
    }
    else  {
        ar >> m_extent;
        ar >> m_pClientItem;
        m_pClientItem->m_pDrawObj = this;
    }
}


//---------------------------------------------------------------------------
CDrawOleObj& CDrawOleObj::operator=(const CDrawOleObj& rdo)
{
   CDrawItem* pItem = NULL;

   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawObj::operator=(rdo);  //assign cdrawobj part

   TRY  {
      CDrawItem* pItem = new CDrawItem(m_pDocument, this);
      if (!pItem->CreateCloneFrom(rdo.m_pClientItem))
         AfxThrowMemoryException();
      m_pClientItem = pItem;
   }
   CATCH_ALL(e) {
      pItem->Delete();
      m_pClientItem = NULL;
      THROW_LAST();
   }
   END_CATCH_ALL

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawOleObj::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    AfxGetApp()->BeginWaitCursor();

    CDrawOleObj* pClone=NULL;

    TRY  {
        pClone = new CDrawOleObj(m_position);

        ASSERT_VALID(pClone);

        *pClone=*this;

        if (pDoc != NULL)
           pDoc->Add(pClone);
    }
    CATCH_ALL(e) {
        delete pClone;
        AfxGetApp()->EndWaitCursor();
        THROW_LAST();
    }
    END_CATCH_ALL

    AfxGetApp()->EndWaitCursor();

    return pClone;
}


//---------------------------------------------------------------------------
void CDrawOleObj::Draw(CDC* pDC,CDrawView*)
{
    ASSERT_VALID(this);

    CDrawItem* pItem = m_pClientItem;
    if (pItem != NULL) {
        // draw the OLE item itself
/********* debug to find why viewer isn't showing presentation data ***/
//              CRect temp_rect = m_position;
//              temp_rect.right += 100;
//              temp_rect.bottom -= 100;

        pItem->Draw(pDC, m_position, DVASPECT_CONTENT);
//      pItem->Draw(pDC, temp_rect, DVASPECT_CONTENT);
/**********************************************************************/

                if (!pDC->IsPrinting()) {

          // use a CRectTracker to draw the standard effects
          CRectTracker tracker;
          tracker.m_rect = m_position;
          pDC->LPtoDP(tracker.m_rect);

          if (c_bShowItems) {
              // put correct border depending on item type
              if (pItem->GetType() == OT_LINK)
                tracker.m_nStyle |= CRectTracker::dottedLine;
              else
                tracker.m_nStyle |= CRectTracker::solidLine;
          }

          // put hatching over the item if it is currently open
          if (pItem->GetItemState() == COleClientItem::openState ||
              pItem->GetItemState() == COleClientItem::activeUIState) {
             tracker.m_nStyle |= CRectTracker::hatchInside;
          }
          tracker.Draw(pDC);
        }
    }
}


//---------------------------------------------------------------------------
void CDrawOleObj::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
      TRACE(TEXT("AWCPE: CDrawOleObj::Invalidate, missing View pointer\n"));
      return;
   }
   CRect rect = m_position;
   pView->DocToClient(rect);
   if (pView->IsSelected(this)) {
        rect.left -= 4;
        rect.top -= 5;
        rect.right += 5;
        rect.bottom += 4;
   }
   rect.InflateRect(1, 1); // handles CDrawOleObj objects

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
void CDrawOleObj::OnDblClk(CDrawView* pView)
{
    AfxGetApp()->BeginWaitCursor();
    m_pClientItem->DoVerb(
        GetKeyState(VK_CONTROL) < 0 ? OLEIVERB_OPEN : OLEIVERB_PRIMARY,
        pView);
    AfxGetApp()->EndWaitCursor();

}


//---------------------------------------------------------------------------
// position is in logical
//---------------------------------------------------------------------------
void CDrawOleObj::MoveTo(const CRect& position, CDrawView* pView)
{
    ASSERT_VALID(this);

    if (position == m_position)
        return;

    // call base class to update position
    CDrawObj::MoveTo(position, pView);

    // update position of in-place editing session on position change
    if (m_pClientItem->IsInPlaceActive())
        m_pClientItem->SetItemRects();
}

//----------------------------------------------------------------------------------------------

CMoveContext::CMoveContext(RECT& rc, CDrawObj* pObj, BOOL bPointChg) : m_rc(rc), m_pObj(pObj)
{
    m_points=NULL;

        if ( pObj->IsKindOf(RUNTIME_CLASS(CDrawPoly)) && bPointChg) {
             CDrawPoly* pPoly = (CDrawPoly*)pObj;
         m_points = pPoly->NewPoints(pPoly->m_nAllocPoints);
         memcpy(m_points, pPoly->m_points, sizeof(CPoint) * pPoly->m_nPoints);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpeobj.h ===
//--------------------------------------------------------------------------
// CPEOBJ.H
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEOBJ_H__
#define __CPEOBJ_H__

#define SHIFT_DRAW      0x0001
#define SHIFT_TOOL          0x0002

class CTextEdit;
class CMainFrame;
class CDrawView;
class CDrawDoc;

  //Colors used in CPE drawing program
#define COLOR_WHITE   RGB(255, 255, 255)
#define COLOR_LTBLUE  RGB(166, 202, 240)
#define COLOR_LTGRAY  RGB(192, 192, 192)
#define COLOR_MDGRAY  RGB(160, 160, 154)
#define COLOR_DKGRAY  RGB(128, 128, 128)
#define COLOR_BLACK   RGB(0, 0, 0)
//-------------------------------------------------------------------------
// CDrawObj - base class for all 'drawable objects'
//-------------------------------------------------------------------------
class CDrawObj : public CObject
{
protected:
        DECLARE_SERIAL(CDrawObj);
        CDrawObj();

public:
        BOOL m_bPen;
        BOOL m_bBrush;

        CDrawObj(const CRect& position);

        CRect m_position;
        CDrawDoc* m_pDocument;

   CDrawObj& operator=(const CDrawObj& rdo);

        virtual int GetHandleCount();
        virtual CPoint GetHandle(int nHandle);
        CRect GetHandleRect(int nHandleID, CDrawView* pView);

        virtual HCURSOR GetHandleCursor(int nHandle);

        virtual void Draw(CDC* pDC,CDrawView*);
 //////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        enum TrackerState { normal, selected, active };
        virtual void DrawTracker(CDC* pDC, TrackerState state);
        virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
        virtual int HitTest(CPoint point, CDrawView* pView, BOOL bSelected);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual BOOL ContainedIn(const CRect& rect);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual void OnDblClk(CDrawView* pView);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void Invalidate();

// Implementation
public:
        virtual ~CDrawObj();
        virtual void Serialize(CArchive& ar);
        LOGBRUSH m_logbrush;
        LOGPEN m_logpen;
   LONG m_lLinePointSize;

#ifdef _DEBUG
        void AssertValid();
#endif

        // implementation data
protected:
   CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
};




//---------------------------------------------------------------------
class CDrawRect : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawRect);
        CDrawRect();
        ~CDrawRect();

public:
        CDrawRect(const CRect& position);

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);

protected:

        friend class CRectTool;
};


//---------------------------------------------------------------------
class CFaxText : public CDrawRect
{
protected:
        DECLARE_SERIAL(CFaxText);
    BOOL m_bPrintRTF;
    HINSTANCE m_hLib;
        HWND m_hRTFWnd;
        CFaxText();
        ~CFaxText();
    static DWORD CALLBACK AFX_EXPORT EditStreamCallBack(DWORD_PTR dwCookie,LPBYTE pbBuff, LONG cb, LONG *pcb);
    void RectToTwip(CRect& rc,CDC& dc);
        void CheckForFit();

public:
    WORD m_wResourceid;
        CFaxText(const CRect& position);
    void EndRTF();
        void InitRTF();
    void Initialize();
        void StreamInRTF();

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

protected:

        friend class CRectTool;
};


//---------------------------------------------------------------------
class CDrawText : public CDrawRect
{
public:
   CTextEdit* m_pEdit;
   HBRUSH m_brush;
   LOGFONT m_logfont;
   COLORREF m_crTextColor;

   CDrawText(const CRect& position);
   CDrawText& operator=(const CDrawText& rdo);

   virtual void Serialize(CArchive& ar);
   virtual void Draw(CDC* pDC,CDrawView*);
   virtual BOOL HitTestEdit(CDrawView* pView,CPoint& point);
   virtual void ChgAlignment(CDrawView*, LONG);
   virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
   virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
   virtual CDrawObj* Clone(CDrawDoc* pDoc);
   CFont* GetFont();
   void ChgLogfont(LOGFONT& lf, BOOL bResize=TRUE);

   void ToggleFontForUndo();
   void ToggleAlignmentForUndo();
   LOGFONT m_previousLogfontForUndo;
   LONG m_previousAlignmentForUndo ;
   BOOL CanUndo();
   void OnEditUndo();
   BOOL m_bUndoFont ;          // LOGFONT was last change, and edit control is active.
   BOOL m_bUndoAlignment ;     // ALIGNMENT was last change, and edit control is active.
   BOOL m_bUndoTextChange ;

   void SnapToFont();
   virtual BOOL ShowEditWnd(CDrawView* pView, BOOL Initialize=TRUE);
   virtual void HideEditWnd(CDrawView* pView, BOOL SaveUndoState=TRUE);
   void SetText(CString& szText, CDrawView* pView);
   void NewBrush();
   virtual void OnDblClk(CDrawView* pView);
   HBRUSH GetBrush() {return m_brush;};
   COLORREF GetBrushColor() {return m_logbrush.lbColor;};
   void SnapToFont_onthefly(
       CDrawView *pView,
       CDC *fly_dc,
       CRect &fly_rect,
       CFont *dpFont=NULL
       );
   int GetText( int numlines = -1, BOOL delete_text = FALSE );

   LPTSTR GetRawText( void )
                {return( (LPTSTR)(LPCTSTR)m_szEditText );};
   CString GetEditTextString(){ return m_szEditText; };
   LONG GetTextAlignment(){
                      return m_lStyle ;
   };
protected:
   CFont* m_pOldFont;  //font used to save font in DC
   CFont* m_pFont;     //font used for edit control
   LONG m_lStyle;
   COLORREF m_savepencolor;
   UINT m_savepenstyle;
   CString m_szEditText;
   DECLARE_SERIAL(CDrawText);
   CDrawText();
   ~CDrawText();
   void FitEditWnd( CDrawView*, BOOL call_gettext=TRUE, CDC *pdc=NULL );
   void InitEditWnd();
   void Initialize();
   void GetLongestString(CString& szLong);

   friend class CRectTool;
};



//---------------------------------------------------------------------
class CFaxProp : public CDrawText
{
protected:
        DECLARE_SERIAL(CFaxProp);
        CFaxProp();
        ~CFaxProp();

public:
        CFaxProp(const CRect& position,WORD wResourceid);
        virtual void Serialize(CArchive& ar);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void Draw(CDC* pDC,CDrawView*);
   CFaxProp& operator=(const CFaxProp& rdo);
   BOOL ShowEditWnd(CDrawView* pView, BOOL Initialize = TRUE );
   void HideEditWnd(CDrawView* pView, BOOL SaveUndoState = TRUE );

   WORD GetResourceId( void )
                {return( m_wResourceid );}

protected:
   WORD m_wResourceid;
        friend class CRectTool;
};






//---------------------------------------------------------------------
class CDrawLine : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawLine);
        CDrawLine();
        ~CDrawLine();

public:
        CDrawLine(const CRect& position);

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 ////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual CPoint GetHandle(int nHandle);
        virtual int GetHandleCount();
        virtual HCURSOR GetHandleCursor(int nHandle);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual void Invalidate();
        void AdjustLineForPen(CRect& rc);
        void NegAdjustLineForPen(CRect& rc);

protected:
    int m_iSlope;
    int m_iB;

        friend class CRectTool;
};




//---------------------------------------------------------------------
class CDrawEllipse : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawEllipse);
        CDrawEllipse();
        ~CDrawEllipse();

public:
        CDrawEllipse(const CRect& position);
        virtual void Serialize(CArchive& ar);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void Draw(CDC* pDC,CDrawView*);
 //////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);

protected:

        friend class CRectTool;
};



//---------------------------------------------------------------------
class CDrawRoundRect : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawRoundRect);
        CDrawRoundRect();
        ~CDrawRoundRect();

public:
        CDrawRoundRect(const CRect& position);
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
  ////////      virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual CPoint GetHandle(int nHandle);
        virtual HCURSOR GetHandleCursor(int nHandle);
   CDrawRoundRect& operator=(const CDrawRoundRect& rdo);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

protected:
        CPoint m_roundness; // for roundRect corners

        friend class CRectTool;
};





//---------------------------------------------------------------------
class CDrawPoly;

class CDrawPoly : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawPoly);
        CDrawPoly();

public:
        CDrawPoly(const CRect& position);

   CDrawPoly& operator=(const CDrawPoly& rdo);
        void AddPoint(const CPoint& point, CDrawView* pView = NULL);
        BOOL RecalcBounds(CDrawView* pView = NULL);

// Implementation
public:
        CRect GetHandleRect(int nHandleID, CDrawView* pView);
        virtual int HitTest(CPoint point, CDrawView* pView, BOOL bSelected);
        virtual ~CDrawPoly();
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 ///////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual void MoveTo(const CRect& position, CDrawView* pView = NULL);
        virtual int GetHandleCount();
        virtual CPoint GetHandle(int nHandle);
        virtual HCURSOR GetHandleCursor(int nHandle);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

        // static helper for creating arrays of points
        static CPoint* NewPoints(int nPoints);

//protected:
        int m_nPoints;
        int m_nAllocPoints;
        CPoint* m_points;
        CDrawPoly* m_pDrawObj;

//      friend class CPolyTool;
};


//---------------------------------------------------------------------
class CDrawItem;    // COleClientItem derived class

class CDrawOleObj : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawOleObj);
        CDrawOleObj();

public:
        CDrawOleObj(const CRect& position);

// Implementation
public:
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 //////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
   CDrawOleObj& operator=(const CDrawOleObj& rdo);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void OnDblClk(CDrawView* pView);
        virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
        virtual void Invalidate();

        static BOOL c_bShowItems;

        CDrawItem* m_pClientItem;
        CSize m_extent; // current extent is tracked separate from scaled position
};

//---------------------------------------------------------------------
class CMoveContext: public CObject {
   CMoveContext(RECT& rc, CDrawObj* pObj, BOOL bPointChg);
   RECT m_rc;
   CDrawObj* m_pObj;
   CPoint* m_points;
};


#endif // __CPEOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpetool.cpp ===
//============================================================================
// cpetool.cpp - implementation for drawing tools
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains tool classes for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/7/95       Added check for empty list in CSelectTool::OnLButtonUp to
//                              avoid GPF (bug 2422).
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#include <math.h>

#define TOOL  0x8000

CPtrList CDrawTool::c_tools;

static CSelectTool selectTool;
static CRectTool lineTool(line);
static CRectTool textTool(text);
static CRectTool faxpropTool(faxprop);
static CRectTool rectTool(rect);
static CRectTool roundRectTool(roundRect);
static CRectTool ellipseTool(ellipse);
static CPolyTool polyTool;

CPoint CDrawTool::c_down;
UINT CDrawTool::c_nDownFlags;
CPoint CDrawTool::c_last;
DrawShape CDrawTool::c_drawShape = select;

CDrawTool::CDrawTool(DrawShape drawShape)
{
   m_drawShape = drawShape;
   c_tools.AddTail(this);
   m_bMoveCurSet=FALSE;
}

CDrawTool* CDrawTool::FindTool(DrawShape drawShape)
{
   POSITION pos = c_tools.GetHeadPosition();
   while (pos != NULL) {
        CDrawTool* pTool = (CDrawTool*)c_tools.GetNext(pos);
        if (pTool->m_drawShape == drawShape)
                return pTool;
   }

   return NULL;
}

void CDrawTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   // deactivate any in-place active item on this view!
   COleClientItem* pActiveItem = pView->GetDocument()->GetInPlaceActiveItem(pView);
   if (pActiveItem != NULL) {
        pActiveItem->Close();
        ASSERT(pView->GetDocument()->GetInPlaceActiveItem(pView) == NULL);
   }

   pView->SetCapture();
   TRACE(TEXT("AWCPE: mouse capture set\n"));
   c_nDownFlags = nFlags;

   //TRACE( "c_down =%d,%d\n", c_down.x, c_down.y );
   c_down = point;

   c_last = point;
}

void CDrawTool::OnLButtonDblClk(CDrawView* , UINT , const CPoint& )
{
}

void CDrawTool::OnLButtonUp(CDrawView* pView, UINT , const CPoint& point)
{
   ReleaseCapture();
   TRACE(TEXT("AWCPE: mouse capture released\n"));

   if (point == c_down) {
      c_drawShape = select;
   }
}

void CDrawTool::OnMouseMove(CDrawView* , UINT , const CPoint& point)
{
   c_last = point;
   SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));
   m_bMoveCurSet=FALSE;
}

void CDrawTool::OnCancel()
{
   c_drawShape = select;
}

////////////////////////////////////////////////////////////////////////////
// CResizeTool

enum SelectMode
{
   none,
   netSelect,
   move,
   size
};

SelectMode selectMode = none;
int nDragHandle;

CPoint lastPoint;

CSelectTool::CSelectTool()
        : CDrawTool(select)
{
    m_bClicktoMove=FALSE;
}


//---------------------------------------------------------------------------------------
void CSelectTool::OnArrowKey(CDrawView* pView, UINT nChar, UINT nRepCnt, UINT nFlags)
{
   TRACE(TEXT("CSelectTool::OnArrowKey\n"));

   CPoint delta;
   if (nRepCnt>1)
      nRepCnt*=5;

   if (nChar == VK_LEFT) {
      delta.x=-1*nRepCnt;
      delta.y=0;
   }
   if (nChar == VK_RIGHT) {
      delta.x=nRepCnt;
      delta.y=0;
   }
   if (nChar == VK_UP) {
      delta.x=0;
      delta.y=nRepCnt;
   }
   if (nChar == VK_DOWN) {
      delta.x=0;
      delta.y=-1*nRepCnt;
   }

   POSITION pos = pView->m_selection.GetHeadPosition();
   CDrawDoc* pDoc = CDrawDoc::GetDoc();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

   while (pos != NULL) {
      CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
      CRect position = pObj->m_position;
      position += delta;
      int r = (position.right > position.left) ? position.right : position.left;
      int l = (position.right > position.left) ? position.left : position.right;
      int t = (position.top > position.bottom) ? position.top : position.bottom;
      int b = (position.top > position.bottom) ? position.bottom : position.top;

          if (l > rect.left && r < rect.right && t < rect.top && b > rect.bottom )
         pObj->MoveTo(position, pView);
   }
}


//---------------------------------------------------------------------------------------
void CSelectTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
    CPoint local = point;
    pView->ClientToDoc(local);


    CDrawObj* pObj;
    selectMode = none;

    // Check for resizing (only allowed on single selections)
    if (pView->m_selection.GetCount() == 1)
    {
        pObj = (CDrawObj*)pView->m_selection.GetHead();
        nDragHandle = pObj->HitTest(local, pView, TRUE);
        if (nDragHandle != 0) {
                selectMode = size;
                }
    }

    // See if the click was on an object, select and start move if so
    if (selectMode == none)     {

       pObj = pView->GetDocument()->ObjectAt(local);

       if (pObj != NULL) {
            selectMode = move;

            if (pView->IsSelected(pObj)) {       //check to activate edit window for edit object
                if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
                   if (((CDrawText*)pObj)->HitTestEdit(pView,local))
                      if (((CDrawText*)pObj)->ShowEditWnd(pView))
                         return;
            }

            if( (nFlags & MK_SHIFT)&&(nFlags & MK_CONTROL) )
                                {
                // Shft+Ctrl+Click clones the selection...
                pView->CloneSelection();
                                }
                        else {
                   if (!pView->IsSelected(pObj) || ((nFlags & MK_CONTROL) != 0) ) {
                          if ( (nFlags & MK_CONTROL) == 0)
                          pView->Select(NULL);
                              pView->Select(pObj, (nFlags & MK_CONTROL) != 0);
                  pView->UpdateStatusBar();
                  pView->UpdateStyleBar();
                           }
                           if (!pView->IsSelected(pObj))
                              selectMode=none;
                        }
        }
    }

        if (selectMode==move || selectMode==size)
        m_bClicktoMove=TRUE;

        // Click on background, start a net-selection
    if (selectMode == none) {

        if ((nFlags & MK_CONTROL) == 0)
             pView->Select(NULL);

        selectMode = netSelect;

        CClientDC dc(pView);
        CRect rect(point.x, point.y, point.x, point.y);
        rect.NormalizeRect();
        dc.DrawFocusRect(rect);
    }

    lastPoint = local;

    CDrawTool::OnLButtonDown(pView, nFlags, point);
}


//---------------------------------------------------------------------------------
void CSelectTool::OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   if ((nFlags & MK_SHIFT) != 0) {
        // Shift+DblClk deselects object...
        CPoint local = point;
        pView->ClientToDoc(local);
        CDrawObj* pObj = pView->GetDocument()->ObjectAt(local);
        if (pObj != NULL)
                pView->Deselect(pObj);
   }
   else {
        // "Normal" DblClk, or OLE server...
        if (pView->m_selection.GetCount() == 1)
                ((CDrawObj*)pView->m_selection.GetHead())->OnDblClk(pView);
   }

   CDrawTool::OnLButtonDblClk(pView, nFlags, point);
}


//---------------------------------------------------------------------------------
void CSelectTool::OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   m_bClicktoMove=FALSE;

   if (pView->GetCapture() == pView) {
        if (selectMode == netSelect) {
            CClientDC dc(pView);
            CRect rect(c_down.x, c_down.y, c_last.x, c_last.y);
            rect.NormalizeRect();
            dc.DrawFocusRect(rect);

            pView->SelectWithinRect(rect, TRUE);
        }
        else if (selectMode != none) {
                 pView->GetDocument()->UpdateAllViews(pView);
        }
   }

#ifdef GRID
   if (pView->m_bSnapToGrid && (selectMode==move || selectMode==size))
      CheckSnapSelObj(pView);
#endif


   if( (selectMode==size) &&                                       // if we're sizing AND
           (!(CDrawObj*)pView->m_selection.IsEmpty()) )// something got picked
                {                                                                                  // then do pObj
        CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetHead();
        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->SnapToFont();
                }

   }


   CDrawTool::OnLButtonUp(pView, nFlags, point);
}


#ifdef GRID
//---------------------------------------------------------------------------------
void CSelectTool::CheckSnapSelObj(CDrawView* pView)
{
   CRect r(0,0,0,0);
   CRect temp;
   int iOffsetX=0;
   int iOffsetY=0;

   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
     CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
     temp = pObj->m_position;
     temp.NormalizeRect();
     r |= temp;
   }
   if (r.TopLeft().y < r.BottomRight().y) {
       int temp = r.TopLeft().y;
       r.TopLeft().y=r.BottomRight().y;
           r.BottomRight().y=temp;
   }

   CDrawDoc* pDoc = pView->GetDocument();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

     //first check Top and left
   for (int y = rect.top-pView->m_iGridSize; y > rect.bottom; y -= pView->m_iGridSize)  //Top of object
      if (r.TopLeft().y > (y-8) && r.TopLeft().y < (y+8)) {
         iOffsetY=y-r.TopLeft().y;
         break;
      }

   for (int x = rect.left + pView->m_iGridSize; x < rect.right; x += pView->m_iGridSize)  //Left of object
      if (r.TopLeft().x < (x+8) && r.TopLeft().x > (x-8)) {
         iOffsetX=x-r.TopLeft().x;
         break;
      }

   if (iOffsetX !=0 || iOffsetY != 0) {
      AdjustSelObj(pView,iOffsetX,iOffsetY);
      return;
   }

   iOffsetX=iOffsetY=0;

     //if top and left dont need snapping, check right and bottom
   for (y = rect.top-pView->m_iGridSize; y > rect.bottom; y -= pView->m_iGridSize)  //Top of object
      if (r.BottomRight().y > (y-8) && r.BottomRight().y < (y+8)) {
         iOffsetY=y-r.BottomRight().y;
         break;
      }

   for (x = rect.left + pView->m_iGridSize; x < rect.right; x += pView->m_iGridSize)  //Left of object
      if (r.BottomRight().x < (x+8) && r.BottomRight().x > (x-8)) {
         iOffsetX=x-r.BottomRight().x;
         break;
      }

   if (iOffsetX !=0 || iOffsetY != 0)
      AdjustSelObj(pView,iOffsetX,iOffsetY);
}
#endif


//---------------------------------------------------------------------------------
void CSelectTool::AdjustSelObj(CDrawView* pView, int iOffsetX, int iOffsetY)
{
   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
        CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
        CRect position = pObj->m_position;
        position.OffsetRect(iOffsetX,iOffsetY);
        pObj->MoveTo(position, pView);
   }
}


#ifdef GRID
//---------------------------------------------------------------------------------
int CSelectTool::NearestGridPoint(CDrawView* pView, CPoint& local,CPoint& ngp)
{
   CSize delta;
   CPoint upL,upR,loL,loR;
   int iDistance;
   int iHold;

   CDrawDoc* pDoc = pView->GetDocument();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

   for (int y = rect.top-20; y > rect.bottom; y -= 20)   //find y bound
      if (local.y > y) {
         upL.y=y+20;
         upR.y=y+20;
         loL.y=y;
         loR.y=y;
         break;
      }
   for (int x = rect.left + 20; x < rect.right; x += 20)  //find x bound
      if (local.x < x) {
         upL.x=x-20;
         loL.x=x-20;
         upR.x=x;
         loR.x=x;
         break;
      }

   delta=(CSize)(local - upR);   //get distance to upR point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   iHold=iDistance;
   ngp=upR;

   delta=(CSize)(local - loR);   //get distance to loR point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=loR;
   }
   delta=(CSize)(local - upL);   //get distance to upL point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=upL;
   }
   delta=(CSize)(local - loL);   //get distance to loL point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=loL;
   }

   return iHold;
}
#endif



//---------------------------------------------------------------------------------
void CSelectTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   if (pView->GetCapture() != pView) {   //if not in capture, set cursor
      CDrawObj* pObj;
      CPoint local=point;
      pView->ClientToDoc(local);

      if (c_drawShape == select && pView->m_selection.GetCount() == 1) {
               //check for handle cursor change
          pObj = (CDrawObj*)pView->m_selection.GetHead();
          int nHandle = pObj->HitTest(local, pView, TRUE);
          if (nHandle != 0) {
             SetCursor(pObj->GetHandleCursor(nHandle));
             return; // bypass CDrawTool
          }
      }
               //check for move cursor change
      if (c_drawShape == select) {
              pObj=pView->GetDocument()->ObjectAt(local);
          if (pObj != NULL) {
             if (pView->m_selection.GetCount() == 1 && pView->IsSelected(pObj) &&
                    pObj->IsKindOf(RUNTIME_CLASS(CDrawText)) ) {
                if ( !((CDrawText*)pObj)->HitTestEdit(pView,local) ) {
                   SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                   m_bMoveCurSet=TRUE;
                   return; // bypass CDrawTool
                }
             }
             else {
                if ( pView->IsSelected(pObj)) {
                   SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                   m_bMoveCurSet=TRUE;
                   return; // bypass CDrawTool
                }
             }
          }
      }

      if (c_drawShape == select)
         CDrawTool::OnMouseMove(pView, nFlags, point);

      return;
   }

   // move or resize, add to undo collection

    if (m_bClicktoMove && pView->m_selection.GetCount() > 0) {

        pView->SaveStateForUndo();
        m_bClicktoMove=FALSE;
   }


   if (selectMode == netSelect) {     //do net selection drawing
      CClientDC dc(pView);
      CRect rect(c_down.x, c_down.y, c_last.x, c_last.y);
      rect.NormalizeRect();
      dc.DrawFocusRect(rect);
      rect.SetRect(c_down.x, c_down.y, point.x, point.y);
      rect.NormalizeRect();
      dc.DrawFocusRect(rect);

      CDrawTool::OnMouseMove(pView, nFlags, point);
      return;
   }

   CPoint local = point;
   pView->ClientToDoc(local);
   CPoint delta;
   delta = (CPoint)(local - lastPoint);

   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
      CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);

      CRect position = pObj->m_position;

      if (selectMode == move) {
        position += delta;
        pObj->MoveTo(position, pView);
      }
      else
      if (nDragHandle != 0) {

                UINT iShift=0;

//              if (pObj->IsKindOf(RUNTIME_CLASS(CDrawLine))) {
//              }

        if (nFlags & MK_SHIFT)
                   iShift |= SHIFT_DRAW;

            if (nFlags & TOOL)
                   iShift |= SHIFT_TOOL;

        pObj->MoveHandleTo(nDragHandle, local, pView, iShift);
      }
   }

   lastPoint = local;

   c_last = point;
   if (selectMode == size && c_drawShape == select) {
      SetCursor(((CDrawObj*)pView->m_selection.GetHead())->GetHandleCursor(nDragHandle));
      return; // bypass CDrawTool
   }
   else   //set cursor if in move mode
      if (selectMode == move && c_drawShape == select) {
             if (!m_bMoveCurSet) {
            SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                        m_bMoveCurSet=TRUE;
                 }
         return; // bypass CDrawTool
      }

   if (c_drawShape == select)
        CDrawTool::OnMouseMove(pView, nFlags, point);
}

////////////////////////////////////////////////////////////////////////////
CRectTool::CRectTool(DrawShape drawShape)
        : CDrawTool(drawShape)
{
}

void CRectTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
     CDrawTool::OnLButtonDown(pView, nFlags, point);

     CPoint local = point;
     pView->ClientToDoc(local);

     CDrawObj* pObj;

     switch (m_drawShape) {
     default:
        ASSERT(FALSE); // unsuported shape!

     case rect:
        pObj = new CDrawRect(CRect(local, CSize(0, 0)));
        break;

     case text:
        pObj = new CDrawText(CRect(local, CSize(0, 0)));
        break;

//     case faxprop:
//        pObj = new CFaxProp(CRect(local, CSize(0, 0)));
//      break;

     case roundRect:
        pObj = new CDrawRoundRect(CRect(local, CSize(0, 0)));
        break;

     case ellipse:
        pObj = new CDrawEllipse(CRect(local, CSize(0, 0)));
        break;

     case line:
        pObj = new CDrawLine(CRect(local, CSize(0, 0)));
        break;
     }

     pView->GetDocument()->Add(pObj);

     pView->Select(NULL);
     pView->Select(pObj);
         pView->UpdateStatusBar();
         pView->UpdateStyleBar();

     selectMode = size;
     nDragHandle = 1;
     lastPoint = local;
}

void CRectTool::OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point)
{
     CDrawTool::OnLButtonDblClk(pView, nFlags, point);
}

void CRectTool::OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   BOOL bObj=TRUE;
   CDrawObj* pObj;

   if (point == c_down) {
        // Don't create empty objects...
        pObj = (CDrawObj*)pView->m_selection.GetTail();
        pView->GetDocument()->Remove(pObj);
//      delete pObj;
        selectTool.OnLButtonDown(pView, nFlags, point); // try a select!
        bObj=FALSE;
   }

   selectTool.OnLButtonUp(pView, nFlags, point);

   if (bObj) {
      if (m_drawShape==text) {
         pObj = (CDrawObj*) pView->m_selection.GetTail();
         if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->ShowEditWnd(pView);
            pView->Select(NULL, FALSE, FALSE);
         }
      }
   }
}

void CRectTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   //TRACE( "point =%d,%d\n", point.x, point.y );
   SetCursor(AfxGetApp()->LoadStandardCursor(IDC_CROSS));
   selectTool.OnMouseMove(pView, nFlags | TOOL, point);
}


////////////////////////////////////////////////////////////////////////////
// CPolyTool

CPolyTool::CPolyTool()
        : CDrawTool(poly)
{
   m_pDrawObj = NULL;
}

void CPolyTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   CDrawTool::OnLButtonDown(pView, nFlags, point);

   CPoint local = point;
   pView->ClientToDoc(local);

   if (m_pDrawObj == NULL) {
          pView->SetCapture();

          m_pDrawObj = new CDrawPoly(CRect(local, CSize(0, 0)));
          pView->GetDocument()->Add(m_pDrawObj);
          pView->Select(NULL);
          pView->Select(m_pDrawObj);
      m_pDrawObj->AddPoint(local, pView);
   }
   else if (local == m_pDrawObj->m_points[0]) {
        // Stop when the first point is repeated...
        ReleaseCapture();
        m_pDrawObj->m_nPoints -= 1;
        if (m_pDrawObj->m_nPoints < 2) {
                delete m_pDrawObj;
        }
        else {
                m_pDrawObj->Invalidate();
        }
        m_pDrawObj = NULL;
        c_drawShape = select;
        return;
   }

   local.x += 1; // adjacent points can't be the same!
   m_pDrawObj->AddPoint(local, pView);

   selectMode = size;
   nDragHandle = m_pDrawObj->GetHandleCount();
   lastPoint = local;
}

void CPolyTool::OnLButtonUp(CDrawView* , UINT , const CPoint& )
{
   // Don't release capture yet!
}

void CPolyTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
    if (m_pDrawObj != NULL && (nFlags & MK_LBUTTON) != 0) {
       CPoint local = point;
       pView->ClientToDoc(local);
       m_pDrawObj->AddPoint(local);
       nDragHandle = m_pDrawObj->GetHandleCount();
       lastPoint = local;
       c_last = point;
       SetCursor(AfxGetApp()->LoadCursor(IDC_PENCIL));
    }
    else {
       SetCursor(AfxGetApp()->LoadStandardCursor(IDC_CROSS));
       selectTool.OnMouseMove(pView, nFlags, point);
    }
}

void CPolyTool::OnLButtonDblClk(CDrawView* pView, UINT , const CPoint& )
{
    ReleaseCapture();

    int nPoints = m_pDrawObj->m_nPoints;
    if (nPoints > 2 &&
        (m_pDrawObj->m_points[nPoints - 1] == m_pDrawObj->m_points[nPoints - 2] ||
        m_pDrawObj->m_points[nPoints - 1].x - 1 == m_pDrawObj->m_points[nPoints - 2].x &&
        m_pDrawObj->m_points[nPoints - 1].y == m_pDrawObj->m_points[nPoints - 2].y)) {
        // Nuke the last point if it's the same as the next to last...
        m_pDrawObj->m_nPoints -= 1;
        m_pDrawObj->Invalidate();
    }

    m_pDrawObj = NULL;
    c_drawShape = select;

    //
    // As part of the re-design for fixing bug # 39665,
    // put the "Ready" message back on the status bar.
    // Fix by a-juliar, 05-24-96
    //

    CString sz ;
    sz.LoadString( AFX_IDS_IDLEMESSAGE );
    CMainFrame* pFrame = (CMainFrame*) AfxGetApp()->m_pMainWnd;
    CStatusBar* pStatus = &pFrame->m_wndStatusBar;
    pStatus->SetPaneText( 0, sz );
}

void CPolyTool::OnCancel()
{
    CDrawTool::OnCancel();

    m_pDrawObj = NULL;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpevw.cpp ===
//===========================================================================
// CPEVW.cpp : implementation of the CDrawView class
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains main view class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/15/95      Disabled removing offpage objects in CDrawView::SetPageSize
// 2/21         Changed OnSpaceAcross,Down to use floating point
// 3/2          Added throw to EndDoc in render
// 3/9          Added msg-on-cpe stuff
//
//===========================================================================
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#include <dos.h>
#include <direct.h>
#include <afxpriv.h>
#include <math.h>
#include <winspool.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define CENTER_WHITE_AREA  1 // tonyle wants the white area centered with half the gray on each side.
#define CENTERING_FUDGE_FACTOR 22 // Number of logical units we are consistently off-center by.
#define USING_PAPER_COLOR 0

const int G_ISPACING = 10;     //in LU (MM_LOENGLISH)

//
// private clipboard format (list of Draw objects).
// These could contain LOGFONTA or LOGFONTW structures a-juliar 9-6-96.
//

#ifdef UNICODE
CLIPFORMAT CDrawView::m_cfDraw =
        (CLIPFORMAT)::RegisterClipboardFormat(TEXT("AWCPE Draw Object W"));
#else
CLIPFORMAT CDrawView::m_cfDraw =
        (CLIPFORMAT)::RegisterClipboardFormat(TEXT("AWCPE Draw Object A"));
#endif

IMPLEMENT_DYNCREATE(CDrawView, CScrollView)

//--------------------------------------------------------------------------
CDrawView::CDrawView()
{
//
//  Set m_dwEfcFields to the DWORD value of a registry key if it exists.
//
    HKEY hKey ;
    DWORD dwType ;
    m_dwEfcFields = 0 ;
    DWORD dwRegKeyVal ;
    DWORD dwsz = sizeof(DWORD)/sizeof(BYTE);
    if ( ERROR_SUCCESS == ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                          TEXT("SOFTWARE"),
                                          0,
                                          KEY_READ,
                                          &hKey)) {
        if ( ERROR_SUCCESS == ::RegOpenKeyEx( hKey,
                                              TEXT("Microsoft"),
                                              0,
                                              KEY_READ,
                                              &hKey)) {
            if ( ERROR_SUCCESS == ::RegOpenKeyEx( hKey,
                                                  TEXT("FAX"),
                                                  0,
                                                  KEY_READ,
                                                  &hKey)) {
                if ( ERROR_SUCCESS == ::RegOpenKeyEx( hKey,
                                                      TEXT("Setup"),
                                                      0,
                                                      KEY_READ,
                                                      &hKey)) {
                    if ( ERROR_SUCCESS == ::RegQueryValueEx(hKey,
                                                            TEXT("EFC_CoverPageFields"),
                                                            0,
                                                            &dwType,
                                                            (LPBYTE)&dwRegKeyVal,
                                                            &dwsz)) {
                        if ( REG_DWORD == dwType ){
                            m_dwEfcFields = dwRegKeyVal ;
                        }
                    }
                }
            }
        }
    }


   m_bGridLines= FALSE;
#ifdef GRID
   m_bSnapToGrid=FALSE;
#endif

#ifdef GRID
   m_iGridSize=GRID_LARGE;
   m_hbitmap.LoadBitmap(ID_GRIDDOT);
   m_hbitmap.GetObject(sizeof(BITMAP),(LPSTR)&m_bm);
#endif
   m_penSolid.CreatePen(PS_SOLID, 1, COLOR_LTBLUE);
   m_penDot.CreatePen(PS_DOT, 1, COLOR_LTBLUE);

   m_pObjInEdit=NULL;
   m_bFontChg=FALSE;
   m_bKU=TRUE;
   m_bCanUndo = FALSE ;
}


//--------------------------------------------------------------------------
CDrawView::~CDrawView()
{
}

//--------------------------------------------------------------------------
BOOL CDrawView::PreCreateWindow(CREATESTRUCT& cs)
{
   ASSERT(cs.style & WS_CHILD);
   if (cs.lpszClass == NULL)
        cs.lpszClass = AfxRegisterWndClass(CS_DBLCLKS);

   CScrollView::PreCreateWindow(cs);

   return TRUE;
}

//--------------------------------------------------------------------------
int CDrawView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
   if (CScrollView::OnCreate(lpCreateStruct) == -1)
      return -1;

   DWORD dwExStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE);

   //
   // If it is mirrored then turn off mirroing and set the VScroll bar on the other side.
   //
   if (dwExStyle & WS_EX_LAYOUTRTL) {
       SetWindowLong(m_hWnd, GWL_EXSTYLE, (dwExStyle & ~WS_EX_LAYOUTRTL) ^ WS_EX_LEFTSCROLLBAR);
   }
   
   return 0;
}

//--------------------------------------------------------------------------
CDrawView* CDrawView::GetView()
{
    try {

    CFrameWnd* pFrame = (CFrameWnd*) AfxGetMainWnd();

    if (!pFrame)
       return NULL;

    CView* pView = pFrame->GetActiveView();
    if (!pView)
       return NULL;

    if (!pView->IsKindOf(RUNTIME_CLASS(CDrawView)))
       return NULL;

    return (CDrawView*) pView;

    } catch(...) {
        ;
    }

    return NULL;

}


//------------------------------------------------------------
void CDrawView::OnUpdate(CView* , LPARAM lHint, CObject* pHint)
{
   switch (lHint)
   {
   case HINT_UPDATE_WINDOW:    // redraw entire window
        Invalidate(FALSE);
        break;

   case HINT_UPDATE_DRAWOBJ:   // a single object has changed
    ((CDrawObj*)pHint)->Invalidate();
        break;

   case HINT_UPDATE_SELECTION: // an entire selection has changed
        {
                CObList* pList = pHint != NULL ? (CObList*)pHint : &m_selection;
                POSITION pos = pList->GetHeadPosition();
                while (pos != NULL)
                        ((CDrawObj*)pList->GetNext(pos))->Invalidate();
        }
        break;

   case HINT_DELETE_SELECTION: // an entire selection has been removed
        if (pHint != &m_selection)
        {
                CObList* pList = (CObList*)pHint;
                POSITION pos = pList->GetHeadPosition();
                while (pos != NULL)     {
                        CDrawObj* pObj = (CDrawObj*)pList->GetNext(pos);
                        pObj->Invalidate();
                        Remove(pObj);   // remove it from this view's selection
                }
        }
        break;

   case HINT_UPDATE_OLE_ITEMS:
        {
                CDrawDoc* pDoc = GetDocument();
                POSITION pos = pDoc->GetObjects()->GetHeadPosition();
                while (pos != NULL)
                {
                        CDrawObj* pObj = (CDrawObj*)pDoc->GetObjects()->GetNext(pos);
                        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
                            pObj->Invalidate();
                }
        }
        break;

   default:
        ASSERT(FALSE);
        break;
   }

}


//--------------------------------------------------------------------------
void CDrawView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
   pDC->SetWindowOrg(0,0);
   CScrollView::OnPrepareDC(pDC, pInfo);
   DoPrepareDC(pDC);
}

//--------------------------------------------------------------------------
// This method created to resolve bug w/ MFC caused by /SUBSYSTEM:Windows,4.0
//--------------------------------------------------------------------------
void CDrawView::DoPrepareDC(CDC* pDC)
{
   CSize extents;

   if (pDC==NULL)
      return;



   // mapping mode is MM_ANISOTROPIC
   // these extents setup a mode similar to MM_LOENGLISH
   // MM_LOENGLISH is in .01 physical inches
   // these extents provide .01 logical inches

   extents.cx = pDC->GetDeviceCaps(LOGPIXELSX);
   extents.cy = pDC->GetDeviceCaps(LOGPIXELSY);

   pDC->SetMapMode(MM_ANISOTROPIC);
   pDC->SetViewportExt( extents );

   pDC->SetWindowExt(100, -100);


   // set the origin of the coordinate system to the center of the page
   CPoint ptOrg;
#if CENTER_WHITE_AREA
   ptOrg.x = GetTotalSize().cx / 2 + CENTERING_FUDGE_FACTOR ;
#else
   ptOrg.x = GetDocument()->GetSize().cx / 2 ;
#endif
   ptOrg.y = GetDocument()->GetSize().cy / 2;

   // ptOrg is in logical coordinates

   pDC->OffsetWindowOrg(-ptOrg.x,ptOrg.y);

}



//--------------------------------------------------------------------------
BOOL CDrawView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
   // do the scroll
   if (!CScrollView::OnScrollBy(sizeScroll, bDoScroll))
        return FALSE;

   // update the position of any in-place active item
   if (bDoScroll)
   {
        UpdateActiveItem();
        UpdateWindow();
   }
   return TRUE;
}


//--------------------------------------------------------------------------
HBRUSH CDrawView::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
    HBRUSH b = CScrollView::OnCtlColor(pDC, pWnd, nCtlColor);

    if (nCtlColor == CTLCOLOR_EDIT) {
        if (m_pObjInEdit) {
            if(m_pObjInEdit->m_bBrush){
               pDC->SetBkColor(m_pObjInEdit->m_logbrush.lbColor);
               pDC->SetTextColor(m_pObjInEdit->m_crTextColor);
               return m_pObjInEdit->GetBrush();
            }
            else {
                //
                // Text box is supposed to have transparent background,
                // NT Bug 54161.
                //
                // Paliative measure -- pick a color other than the text.
                //
                ///pDC->SetBkMode( TRANSPARENT );   /// This screws up backspacing without making it transparant.
                ///return (HBRUSH)pDC->SelectStockObject( NULL_BRUSH );
                COLORREF crTextColor = m_pObjInEdit->m_crTextColor;
                pDC->SetTextColor(crTextColor);
                if( GetBValue(crTextColor) > 150 &&
                    GetRValue(crTextColor) > 150 &&
                    GetGValue(crTextColor) > 150){
                    //
                    // Text is light.  Use black background.
                    //
                    pDC->SetBkColor( RGB( 0, 0, 0 ));
                    return (HBRUSH) GetStockObject( BLACK_BRUSH );
                }
                else{
                    pDC->SetBkColor( RGB( 255, 255, 255 ));
                    return (HBRUSH) GetStockObject( WHITE_BRUSH );
                }
            }
        }
        return b;
    }

    return b;
}


//--------------------------------------------------------------------------
void CDrawView::OnDraw(CDC* pDC)
{
    //
    // Revised 8-22-96 by a-juliar to fix NT Bug 43431.
    //

    CDrawDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    CDC dc;

    CDC* pDrawDC = pDC;

    CBitmap bitmap;
    CBitmap* pOldBitmap;

    CRect clipbox;

    pDC->GetClipBox(clipbox);
#define GIVE_MFC_NORMALIZE_RECT_A_TRY   0
#if GIVE_MFC_NORMALIZE_RECT_A_TRY
    clipbox.NormalizeRect();
#else
    if( clipbox.bottom > clipbox.top ){
        int temp = clipbox.bottom ;
        clipbox.bottom = clipbox.top ;
        clipbox.top = temp ;
    }
    if( clipbox.left > clipbox.right ){
        int temp = clipbox.left ;
        clipbox.left = clipbox.right ;
        clipbox.right = temp ;
    }
#endif
    clipbox.top    += 1;
    clipbox.left   -= 1;
    clipbox.right  += 1;
    clipbox.bottom -= 1;
    CRect rect = clipbox ;
    DocToClient(rect);        // Now "rect" is in device coordinates and "clipbox" is in logical coordinates.

    if(!pDC->IsPrinting()) {

        // draw to offscreen bitmap for fast looking repaints

        if( dc.CreateCompatibleDC(pDC) ){

            if (bitmap.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height())) {
                OnPrepareDC(&dc,NULL);
                pDrawDC = &dc;

                // offset origin more because bitmap is just piece of the whole drawing

                dc.OffsetViewportOrg(-rect.left, -rect.top);
                pOldBitmap = dc.SelectObject(&bitmap);
                dc.SetBrushOrg(rect.left % 8, rect.top % 8);

                // might as well clip to the same rectangle

                dc.IntersectClipRect(clipbox);
            }
        }
    }
    else{

        //
        // Printing. Must undo the correction for centering done in DoPrepareDC();
        //

         pDrawDC->OffsetWindowOrg( ( GetTotalSize().cx - pDoc->GetSize().cx )/ 2 + CENTERING_FUDGE_FACTOR, 0 ) ;
    }


    if (!pDC->IsPrinting()){

        //
        // Paint the whole thing Light Gray first.  The white part will be done in DrawGrid().
        //

        HBRUSH oldbrush = (HBRUSH)::SelectObject(pDrawDC->m_hDC,(HBRUSH)::GetStockObject(LTGRAY_BRUSH) );
        pDrawDC->PatBlt( clipbox.left, clipbox.top, clipbox.Width(), clipbox.Height(), PATCOPY);
        ::SelectObject(pDrawDC->m_hDC,oldbrush);

        DrawGrid( pDrawDC );
    }
    else{
        // Printing.
        // Paint the whole thing white.  Paper color feature isn't supported.
        //
        pDrawDC->FillSolidRect(clipbox, RGB( 255, 255, 255 ) );

    }

    pDoc->Draw(pDrawDC, this, clipbox);

    if (pDrawDC != pDC) {
        pDC->SetViewportOrg(0, 0);
        pDC->SetWindowOrg(0,0);
        pDC->SetMapMode(MM_TEXT);
        dc.SetViewportOrg(0, 0);
        dc.SetWindowOrg(0,0);
        dc.SetMapMode(MM_TEXT);
        pDC->BitBlt(rect.left, rect.top, rect.Width(), rect.Height(),
                        &dc, 0, 0, SRCCOPY);
        dc.SelectObject(pOldBitmap);
    }
}


//--------------------------------------------------------------------------
void CDrawView::Remove(CDrawObj* pObj)
{
   POSITION pos = m_selection.Find(pObj);
   if (pos != NULL)
          m_selection.RemoveAt(pos);

}


//--------------------------------------------------------------------------
void CDrawView::PasteNative(COleDataObject& dataObject)
{
   // get file refering to clipboard data
   CFile* pFile = dataObject.GetFileData(m_cfDraw);
   if (pFile == NULL)
        return;

   // connect the file to the archive
   CArchive ar(pFile, CArchive::load);
   TRY
   {
        ar.m_pDocument = GetDocument(); // set back-pointer in archive

        // read the selection
        m_selection.Serialize(ar);
   }
   CATCH_ALL(e)
   {
        ar.Close();
        delete pFile;
        THROW_LAST();
   }
   END_CATCH_ALL

   ar.Close();
   delete pFile;
}


//--------------------------------------------------------------------------
void CDrawView::PasteEmbedded(COleDataObject& dataObject)
{
   BeginWaitCursor();

   // paste embedded
   CDrawOleObj* pObj = new CDrawOleObj(GetInitialPosition());
   ASSERT_VALID(pObj);
   CDrawItem* pItem = new CDrawItem(GetDocument(), pObj);
   ASSERT_VALID(pItem);
   pObj->m_pClientItem = pItem;

   TRY {
        if (!pItem->CreateFromData(&dataObject) &&
                !pItem->CreateStaticFromData(&dataObject)) {
                AfxThrowMemoryException();      // any exception will do
        }

        // add the object to the document
        GetDocument()->Add(pObj);
        m_selection.AddTail(pObj);

        // try to get initial presentation data
        pItem->UpdateLink();
        pItem->UpdateExtent();
   }
   CATCH_ALL(e) {
        // clean up item
        pItem->Delete();
        pObj->m_pClientItem = NULL;
        GetDocument()->Remove(pObj);
        delete pObj;

        CPEMessageBox(MSG_ERROR_OLE_FAILED_TO_CREATE, NULL, MB_OK,IDP_FAILED_TO_CREATE);
   }
   END_CATCH_ALL

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::DrawGrid(CDC* pDC )
{
    //
    // Revised by a-juliar 8-22-96 to fix NT bug 43431.
    // Called by CDrawView::OnDraw(), which will draw the gray background.
    // Thus we do not need the client rect or clip box here at all.
    // The white background for the printable portion of the document will be drawn here.
    //
   CDrawDoc* pDoc = GetDocument();

   CRect rect;    // White area containing the printable portion of our document.

   int RectWidth  = pDoc->GetSize().cx ;
   int RectHeight = pDoc->GetSize().cy ;
   rect.left = - RectWidth / 2;
   rect.top = RectHeight / 2;
   rect.right = rect.left + RectWidth ;
   rect.bottom = rect.top - RectHeight ;

    //
    //  Draw white background.
    //

    HBRUSH oldbrush = (HBRUSH)::SelectObject(pDC->m_hDC,(HBRUSH)::GetStockObject(WHITE_BRUSH) );
    pDC->PatBlt(rect.left, rect.top, RectWidth, -RectHeight, PATCOPY);
    //pDC->FillSolidRect( rect, RGB( 255, 255, 255 ) );

    // draw shadow

    ::SelectObject(pDC->m_hDC,(HBRUSH)::GetStockObject(DKGRAY_BRUSH) );
    pDC->PatBlt(rect.right,rect.top-5, 5, -RectHeight, PATCOPY );
    pDC->PatBlt(rect.left+5,rect.bottom, RectWidth, -5, PATCOPY );

    ::SelectObject(pDC->m_hDC,oldbrush);

    // Outlines

    pDC->MoveTo(rect.right, rect.top);
    pDC->LineTo(rect.right, rect.bottom);
    pDC->LineTo(rect.left, rect.bottom);
    pDC->LineTo(rect.left, rect.top);

    //
    // If "Grid lines" is checked on the view menu, draw the grid lines.
    //

    if (m_bGridLines) {
        CPen* pOldPen = pDC->SelectObject(&m_penDot);
        for (int x = 100; x < rect.right; x += 100) {      // +x
            pDC->MoveTo(x, rect.top);
            pDC->LineTo(x, rect.bottom);
        }
        for (x = -100; x > rect.left; x -= 100) {      // -x
            pDC->MoveTo(x, rect.top);
            pDC->LineTo(x, rect.bottom);
        }
        for (int y = 100; y < rect.top; y += 100) {        // +y
            pDC->MoveTo(rect.left, y);
            pDC->LineTo(rect.right, y);
        }
        for (y = -100; y > rect.bottom; y -= 100) {        // -y
            pDC->MoveTo(rect.left, y);
            pDC->LineTo(rect.right, y);
        }

        pDC->SelectObject(&m_penSolid);
        //Center lines
        pDC->MoveTo(rect.left, 0);
        pDC->LineTo(rect.right, 0);
        pDC->MoveTo(0, rect.top);
        pDC->LineTo(0, rect.bottom);

        pDC->SelectObject(pOldPen);
    }
}
// -------------------------------------------------------------------------
CSize CDrawView::ComputeScrollSize( CSize size )
{
    //
    //  Compute the scroll sizes.  The width needs to accommodate a grayed area on the margins of
    //  the document, at least 1.25 times the width of the document, and at least as wide as the
    //  client area of the window when it is maximized.  a-juliar 6-24-96
    //

    CClientDC dc(NULL);
    size.cy = MulDiv(size.cy+8, dc.GetDeviceCaps(LOGPIXELSY), 100);
   // size.cx = MulDiv((int)(size.cx * 1.10), dc.GetDeviceCaps(LOGPIXELSX), 100 ); // deliberate gray area
    size.cx = MulDiv( size.cx+16, dc.GetDeviceCaps(LOGPIXELSX), 100 ) ; // No unnecessary gray area.
#if CENTER_WHITE_AREA

    //
    //  Find out how wide the view is when maximized. Make scroll width at least this wide.
    //
#if 0
    long lScreenWidth = dc.GetDeviceCaps( HORZRES ) ;
    NONCLIENTMETRICS ncm ;
    BOOL rval = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    int iScrollBarAndBorderWidth = ncm.iBorderWidth + ncm.iScrollWidth ;
    long lMaxWidth = lScreenWidth - iScrollBarAndBorderWidth ;
    size.cx = rval ? max( lMaxWidth, size.cx ) : max( lScreenWidth, size.cx ) ;
#endif

    size.cx = max( size.cx,
                   GetSystemMetrics( SM_CXMAXIMIZED )
                      - GetSystemMetrics( SM_CXVSCROLL )
                           - 2 * GetSystemMetrics( SM_CXBORDER ));

#endif

    return size ;
}

//--------------------------------------------------------------------------
void CDrawView::OnInitialUpdate()
{
#if 0
   CSize size = GetDocument()->GetSize();
   CClientDC dc(NULL);
   size.cx = MulDiv(size.cx+(int)(size.cx*.25), dc.GetDeviceCaps(LOGPIXELSX), 100);
   size.cy = MulDiv(size.cy+8, dc.GetDeviceCaps(LOGPIXELSY), 100);
#endif
   CSize size = ComputeScrollSize( GetDocument()->GetSize() );
   SetScrollSizes(MM_TEXT, size);

   m_selection.RemoveAll();
#if CENTER_WHITE_AREA
   POINT ptStartingPosition ;
   ptStartingPosition.y = 0 ;
   CRect rect ;
   GetClientRect( &rect );
   ptStartingPosition.x = ( size.cx - rect.right ) / 2 ;
   ScrollToPosition( ptStartingPosition );
#endif
}


//--------------------------------------------------------------------------
void CDrawView::SetPageSize(CSize size)
{
   size = ComputeScrollSize(size);
   SetScrollSizes(MM_TEXT, size);
   GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_WINDOW, NULL);
}


//--------------------------------------------------------------------------
BOOL CDrawView::OnPreparePrinting(CPrintInfo* pInfo)
{
  /// BEGIN TRY THIS //// to get context sensitive help to work:
    //Modified code begin

        if (pInfo->m_pPD)
                delete pInfo->m_pPD;

        pInfo->m_pPD = new CMyPrintDlg(FALSE, PD_ALLPAGES | PD_USEDEVMODECOPIES |
                PD_NOSELECTION);

    //Modified code end
  /// ENE TRY THIS
   if (m_pObjInEdit)     //if there's an object in edit, remove it
      m_pObjInEdit->HideEditWnd(this);

   if (pInfo && GetApp()->m_bCmdLinePrint)
      pInfo->m_bPreview=TRUE;

   if (pInfo->m_bPreview) {
          pInfo->SetMinPage(1);
          pInfo->SetMaxPage(1);
   }

   return DoPreparePrinting(pInfo);
}


//--------------------------------------------------------------------------
void CDrawView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
{
   CScrollView::OnBeginPrinting(pDC,pInfo);

//   GetDocument()->ComputePageSize();
}

//--------------------------------------------------------------------------
void CDrawView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}


//--------------------------------------------------------------------------
BOOL CDrawView::IsSelected(const CObject* pDocItem) const
{
   CDrawObj* pDrawObj = (CDrawObj*)pDocItem;
   if (pDocItem->IsKindOf(RUNTIME_CLASS(CDrawItem)))
        pDrawObj = ((CDrawItem*)pDocItem)->m_pDrawObj;
   return m_selection.Find(pDrawObj) != NULL;
}


//--------------------------------------------------------------------------
void CDrawView::OnInsertObject()
{
   // Invoke the standard Insert Object dialog box to obtain information
   //  for new CDrawItem object.
   CMyOleInsertDialog dlg;       //// To get Context Sensitive Help, we define our own class. a-juliar
   if (dlg.DoModal() != IDOK)
        return;

   BeginWaitCursor();

   // First create the C++ object
   CDrawOleObj* pObj = new CDrawOleObj(GetInitialPosition());
   ASSERT_VALID(pObj);
   CDrawItem* pItem = new CDrawItem(GetDocument(), pObj);
   ASSERT_VALID(pItem);
   pObj->m_pClientItem = pItem;

   // Now create the OLE object/item
   TRY
   {
        if (!dlg.CreateItem(pObj->m_pClientItem)) {
                AfxThrowMemoryException();
        }

        // add the object to the document
        GetDocument()->Add(pObj);

        // try to get initial presentation data
        pItem->UpdateLink();
        pItem->UpdateExtent();

        // if insert new object -- initially show the object
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
                pItem->DoVerb(OLEIVERB_SHOW, this);

        GetDocument()->UpdateAllViews( NULL );
   }
   CATCH_ALL(e)
   {
        // clean up item
        pItem->Delete();
        pObj->m_pClientItem = NULL;
        GetDocument()->Remove(pObj);
        delete pObj;

        CPEMessageBox(MSG_ERROR_OLE_FAILED_TO_CREATE, NULL, MB_OK,IDP_FAILED_TO_CREATE);
   }
   END_CATCH_ALL

   EndWaitCursor();
}

//--------------------------------------------------------------------------
// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.
//--------------------------------------------------------------------------
void CDrawView::OnCancelEdit()
{
   // deactivate any in-place active item on this view!
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL) {
        // if we found one, deactivate it
        pActiveItem->Close();
   }
   ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);

   // escape also brings us back into select mode
   ReleaseCapture();

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   if (pTool != NULL)
        pTool->OnCancel();

   CDrawTool::c_drawShape = select;
}


//--------------------------------------------------------------------------
void CDrawView::OnSetFocus(CWnd* pOldWnd)
{
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL &&
        pActiveItem->GetItemState() == COleClientItem::activeUIState) {
        // need to set focus to this item if it is in the same view
        CWnd* pWnd = pActiveItem->GetInPlaceWindow();
        if (pWnd != NULL) {
                pWnd->SetFocus();
                return;
        }
    }

    CScrollView::OnSetFocus(pOldWnd);
}


//--------------------------------------------------------------------------
CRect CDrawView::GetInitialPosition()
{
    CRect rect(10, 10, 10, 10);
    ClientToDoc(rect);
    return rect;
}


//--------------------------------------------------------------------------
void CDrawView::ClientToDoc(CPoint& point, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.DPtoLP(&point);
      return;
   }

   pDC->DPtoLP(&point);
}


//--------------------------------------------------------------------------
void CDrawView::ClientToDoc(CRect& rect, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.DPtoLP(rect);
      ASSERT(rect.left <= rect.right);
      ASSERT(rect.bottom <= rect.top);
      return;
   }

   pDC->DPtoLP(rect);
   ASSERT(rect.left <= rect.right);
   ASSERT(rect.bottom <= rect.top);
}


//--------------------------------------------------------------------------
void CDrawView::DocToClient(CPoint& point, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.LPtoDP(&point);
          return;
   }

   pDC->LPtoDP(&point);
}


//--------------------------------------------------------------------------
void CDrawView::DocToClient(CRect& rect, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.LPtoDP(rect);
      rect.NormalizeRect();
          return;
   }

   pDC->LPtoDP(rect);
   rect.NormalizeRect();
}


//--------------------------------------------------------------------------
void CDrawView::CheckStyleBar(BOOL bUnderline, BOOL bBold, BOOL bItalic,
   BOOL bLeft, BOOL bCenter, BOOL bRight)
{
    UINT id, style;
    int i;
    int image;

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bUnderline)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bBold)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bItalic)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_LEFT);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bLeft)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_CENTERED);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bCenter)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_RIGHT);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bRight) {
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    }
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

}


//--------------------------------------------------------------------------
// * Updates style bar based on font characterics of selected object(s)
// * Called whenever a drawing object is selected or deselected
//--------------------------------------------------------------------------
void CDrawView::UpdateStyleBar(CObList* pObList/*=NULL*/,CDrawText* p /*=NULL*/)
{
   CString sz;
//   char cFace[LF_FACESIZE];
   CString cFace;
   LONG style;
   TCHAR cSize[5];

   CComboBox& cboxSize=GetFrame()->m_StyleBar.m_cboxFontSize;
   CComboBox& cboxName=GetFrame()->m_StyleBar.m_cboxFontName;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   if (pText) {
      if (!pText->m_pEdit)
         return;

//    CClientDC dc(pText->m_pEdit);
//    dc.SelectObject(pText->m_pEdit->GetFont());
//    dc.GetTextFace(sizeof(cFace),cFace);        //FONT FACE NAME
      cFace=pText->m_logfont.lfFaceName;
      cboxName.GetWindowText(sz);
      if (sz!=cFace)
             cboxName.SetWindowText(cFace);

      _itot(GetPointSize(*pText),cSize,10); //POINT SIZE
      cboxSize.GetWindowText(sz);
      if (sz!=cSize)
             cboxSize.SetWindowText(cSize);

      LONG style= ::GetWindowLong(pText->m_pEdit->m_hWnd, GWL_STYLE);
      CheckStyleBar(pText->m_logfont.lfUnderline,          //underline
              pText->m_logfont.lfWeight==FW_BOLD,              //bold
              pText->m_logfont.lfItalic,                       //italic
              (!((style & ES_CENTER) || (style & ES_RIGHT))),  //left
              style & ES_CENTER,                               //center
              style & ES_RIGHT);                               //right
      return;
   }

   BOOL bText=FALSE;
   BOOL bFontFace=TRUE;
   BOOL bPointSize=TRUE;
   BOOL bUnderline=TRUE;
   BOOL bBold=TRUE;
   BOOL bItalic=TRUE;
   BOOL bLeft=TRUE;
   BOOL bCenter=TRUE;
   BOOL bRight=TRUE;
   CString szSaveFace;
   WORD wSaveSize=0;
   CDrawText* pTxt;

   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
     CDrawObj* pObj = (CDrawObj*)pob->GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
        pTxt=(CDrawText*)pObj;
         if (pTxt->m_pEdit)
            bText=TRUE;
     else
        continue;

        if ( (wSaveSize != 0) && (GetPointSize(*pTxt) != wSaveSize) ) //font size
           bPointSize=FALSE;

        cFace=pTxt->m_logfont.lfFaceName;

        if ( (szSaveFace.GetLength() > 0) && (cFace != szSaveFace) )
           bFontFace=FALSE;

        if (!pTxt->m_logfont.lfUnderline)     //underline
           bUnderline=FALSE;

        if (pTxt->m_logfont.lfWeight!=FW_BOLD) //bold
           bBold=FALSE;

        if (!pTxt->m_logfont.lfItalic)         //italic
           bItalic=FALSE;

        style=::GetWindowLong(((CDrawText*)pObj)->m_pEdit->m_hWnd, GWL_STYLE);
        if ( ((style & ES_CENTER) || (style & ES_RIGHT)) )  //left style
           bLeft=FALSE;

        if (!(style & ES_CENTER))  //center style
           bCenter=FALSE;

        if ( !(style & ES_RIGHT) )  //right style
           bRight=FALSE;

        szSaveFace=cFace;
        wSaveSize=(WORD)GetPointSize(*pTxt);
     }
   }

   if (!bText) //no object in edit, nor any text object
      return;

   cboxName.GetWindowText(sz);
   if (bFontFace) {
      if (sz!=szSaveFace)
         cboxName.SetWindowText(cFace);
   }
   else
      cboxName.SetWindowText(TEXT(""));

   cboxSize.GetWindowText(sz);
   if (bPointSize) {
      _itot(wSaveSize,cSize,10);
      if (cSize!=sz)
         cboxSize.SetWindowText(cSize);
   }
   else
      cboxSize.SetWindowText(TEXT(""));

   CheckStyleBar(bUnderline, bBold, bItalic, bLeft, bCenter, bRight);
}


//--------------------------------------------------------------------------
void CDrawView::Select(CDrawObj* pObj, BOOL bShift /*=FALSE*/, BOOL bCheckEdit /*=TRUE*/)
{
    if (bCheckEdit && m_pObjInEdit)     //if there's an object in edit, remove it
       m_pObjInEdit->HideEditWnd(this);

    if (pObj==NULL) {
        OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
        m_selection.RemoveAll();
                return;
    }

    if (bShift) {
      if (IsSelected(pObj)) {
         Deselect(pObj);
             return;
      }
          else {
         m_selection.AddTail(pObj);
                 pObj->Invalidate();
          }
        }
        else {
      if (!IsSelected(pObj)) {
         m_selection.AddTail(pObj);
                 pObj->Invalidate();
      }
        }
}


//--------------------------------------------------------------------------
// rect is in device coordinates
//--------------------------------------------------------------------------
void CDrawView::SelectWithinRect(CRect rect, BOOL bAdd)
{
        if (!bAdd)
                Select(NULL);

        ClientToDoc(rect);

        CObList* pObList = GetDocument()->GetObjects();
        POSITION posObj = pObList->GetHeadPosition();
    CDrawObj* pObj;
        while (posObj != NULL) {
                pObj = (CDrawObj*)pObList->GetNext(posObj);
                if (pObj->ContainedIn(rect))
                        Select(pObj);
        }

    UpdateStatusBar();
    UpdateStyleBar();
}


//--------------------------------------------------------------------------
void CDrawView::Deselect(CDrawObj* pObj)
{
    POSITION pos = m_selection.Find(pObj);
    if (pos != NULL) {
                pObj->Invalidate();
        m_selection.RemoveAt(pos);
    }
        UpdateStatusBar();
    UpdateStyleBar();
}

//--------------------------------------------------------------------------
void CDrawView::CloneSelection()
{
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);

        BOOL bThisIsANote = FALSE ;
        if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ){
            CFaxProp * pfaxprop = (CFaxProp *)pObj;
            if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE ){
                 bThisIsANote = TRUE ;
            }
        }
        if (!bThisIsANote){
           pObj->Clone(pObj->m_pDocument);
        }
                // copies object and adds it to the document
    }
}


//--------------------------------------------------------------------------
void CDrawView::UpdateActiveItem()
{
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL &&
        pActiveItem->GetItemState() == COleClientItem::activeUIState) {
        // this will update the item rectangles by calling
        //  OnGetPosRect & OnGetClipRect.
        pActiveItem->SetItemRects();
    }
}

//--------------------------------------------------------------------------
// CDrawView message handlers
//--------------------------------------------------------------------------
void CDrawView::OnLButtonDown(UINT nFlags, CPoint point)
{
   CObList oblist;
   if (m_bFontChg) {
      POSITION pos = m_selection.GetHeadPosition();
      while (pos != NULL)
          oblist.AddHead(m_selection.GetNext(pos));
   }

   CDrawText* p = m_pObjInEdit;

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   if (pTool != NULL)
       pTool->OnLButtonDown(this, nFlags, point);

   if (m_bFontChg) {
      OnSelChangeFontSize(&oblist,p);
      OnSelChangeFontName(&oblist,p);
      m_bFontChg=FALSE;
   }
}



//--------------------------------------------------------------------------
void CDrawView::OnRButtonDown(UINT nFlags, CPoint pt)
{
   if (GetCapture() == this) {
      TRACE(TEXT("AWCPE:  CDrawView::ONRButtonDown, cannot invoke properties when in LButtondown capture\n"));
      return;
   }


   CDrawObj* pObj;

   CPoint local = pt;
   ClientToDoc(local);

   pObj = GetDocument()->ObjectAt(local);

   if (pObj == NULL) {
      TrackViewMenu(pt);
      return;
   }
#if 0
///  Related to BUG # 33733
///
///  We should do this all the time!  Word Picture 6.0 does it
///  whether the object is selected or not!!!
   if (!IsSelected(pObj))
      return;
#endif

   //// [[[ tonyle wants the object to be selected. TODO !!  FIX for BUG 33733

   if( ! IsSelected( pObj )){
       while( ! m_selection.IsEmpty() ){

           //
           // Invalidate() while AnObj is still selected, so next paint will erase tracker.
           //

           CDrawObj* AnObj = (CDrawObj*) m_selection.GetHead() ;
           AnObj->Invalidate();
           m_selection.RemoveHead();
       }
       m_selection.AddHead( pObj );
       pObj->Invalidate();
   }
   //// ]]] end of make tonyle happy block.

   TrackObjectMenu(pt);
}


//---------------------------------------------------------------------------------
void CDrawView::TrackObjectMenu(CPoint& pt)
{
   BOOL bTextObj=FALSE;
   BOOL bOLEObj=FALSE;

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL && !(bTextObj && bOLEObj) ) {
     CDrawObj* pobj = (CDrawObj*) m_selection.GetNext(pos);
     if ( pobj->IsKindOf(RUNTIME_CLASS(CDrawText)) )
        bTextObj=TRUE;
     else
        if ( pobj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
           bOLEObj=TRUE;
   }

   CMenu mainmenu;
   mainmenu.CreatePopupMenu();
   CString temp;
   temp.LoadString(IDS_MENU_CUT);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_CUT, temp);
   temp.LoadString(IDS_MENU_COPY);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_COPY, temp);
   temp.LoadString(IDS_MENU_PASTE);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_PASTE, temp);
   mainmenu.AppendMenu(MF_SEPARATOR);
   if (bOLEObj) {
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OLE_VERB_FIRST, _TEXT("<<OLE VERBS GO HERE>>"));
      mainmenu.AppendMenu(MF_SEPARATOR);
   }
   CMenu textmenu;
   if (bTextObj) {
      temp.LoadString(IDS_MENU_FONT);
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_FONT, temp);

      textmenu.CreatePopupMenu();
      temp.LoadString(IDS_MENU_ALIGNLEFT);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_LEFT, temp);
      temp.LoadString(IDS_MENU_ALIGNCENTER);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_CENTERED, temp);
      temp.LoadString(IDS_MENU_ALIGNRIGHT);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_RIGHT, temp);

      temp.LoadString(IDS_MENU_ALIGNTEXT);
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED | MF_POPUP,
                          (UINT_PTR)textmenu.GetSafeHmenu(),
           temp);

      mainmenu.AppendMenu(MF_SEPARATOR);
   }

   temp.LoadString(IDS_MENU_PROPERTIES);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_PROPERTIES, temp);
   mainmenu.AppendMenu(MF_SEPARATOR);

   temp.LoadString(IDS_MENU_MOVETOFRONT);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OBJECT_MOVETOFRONT, temp);
   temp.LoadString(IDS_MENU_SENDTOBACK);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OBJECT_MOVETOBACK, temp);

   ClientToScreen(&pt);
   mainmenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
   if (bTextObj)
      textmenu.Detach();
}


//--------------------------------------------------------------------------
void CDrawView::TrackViewMenu(CPoint& pt)
{
   CMenu mainmenu;
   mainmenu.CreatePopupMenu();
   CString temp;
   temp.LoadString(IDS_MENU_VIEWSTYLEBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_STYLEBAR, temp);
   temp.LoadString(IDS_MENU_VIEWDRAWINGBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_DRAWBAR, temp);
   temp.LoadString(IDS_MENU_VIEWSTATUSBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_STATUS_BAR, temp);
   temp.LoadString(IDS_MENU_VIEWGRIDLINES);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_GRIDLINES, temp);

#ifdef GRID
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_GRID, _TEXT("Grid Lines"));
   mainmenu.AppendMenu(MF_SEPARATOR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_GRID_SETTINGS, _TEXT("Grid Settings..."));
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_SNAP_TO_GRID, _TEXT("Snap to &Grid"));
#endif

   ClientToScreen(&pt);
   mainmenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
}



//--------------------------------------------------------------------------
void CDrawView::OnLButtonUp(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnLButtonUp(this, nFlags, point);

    if (CDrawTool::c_drawShape != poly) {
       CDrawTool::c_drawShape = select;
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnMouseMove(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnMouseMove(this, nFlags, point);
}


//--------------------------------------------------------------------------
void CDrawView::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnLButtonDblClk(this, nFlags, point);
}


//--------------------------------------------------------------------------
void CDrawView::OnDestroy()
{
    CScrollView::OnDestroy();

    // deactivate the inplace active item on this view
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
    {
        pActiveItem->Deactivate();
        ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
    }
}


//--------------------------------------------------------------------------
// *_*_*_   RECIPIENT WM_COMMAND METHODS
//--------------------------------------------------------------------------
void CDrawView::CreateFaxProp(WORD wResourceid)
{
   CDrawText* pTextObj;
   CFaxProp* pFaxPropObj;
   CString szCaption;
   CString szPropName;

   BeginWaitCursor();

   if (GetApp() && GetApp()->m_pFaxMap) {
      GetApp()->m_pFaxMap->GetCaption(wResourceid,szCaption);
      GetApp()->m_pFaxMap->GetPropString(wResourceid,szPropName);
   }

//FETCH CLIENT AREA MEASUREMENTS
   CRect clientrect;   //client area
   TEXTMETRIC tm;
   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;
   CPoint cp = clientrect.TopLeft();

//SET FAX PROPERTY
   pFaxPropObj = new CFaxProp(CRect(0,0,0,0),wResourceid);
   CClientDC dc(this);
   dc.SetMapMode(MM_ANISOTROPIC);
   dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX),dc.GetDeviceCaps(LOGPIXELSY));
   dc.SetWindowExt(100, -100);
   dc.SelectObject(pFaxPropObj->GetFont());
   dc.GetTextMetrics(&tm);
   int faxpropWidth = GetApp()->m_pFaxMap->GetPropDefLength(wResourceid)
           * tm.tmAveCharWidth;
   int faxpropHeight = GetApp()->m_pFaxMap->GetPropDefLines(wResourceid)
           * (tm.tmHeight+3*tm.tmInternalLeading);

//SET CAPTION SIZE
   pTextObj = new CDrawText(CRect(0,0,0,0));
   dc.SelectObject(pTextObj->GetFont());
   CSize caption = dc.GetTextExtent(szCaption,szCaption.GetLength()+1);
   caption.cx += 10;
   caption.cy += 3*tm.tmInternalLeading;

//SET SIZES AND LOCATION OF BINDING RECT
   int rectwidth=faxpropWidth+caption.cx+G_ISPACING;
   int rectheight=(faxpropHeight>caption.cy) ? faxpropHeight : caption.cy;
   cp.x = (cp.x+ihalfwidth)-(long)(.5*rectwidth);
   cp.y = (cp.y-ihalfheight)+(long)(.5*rectheight);

//FIND EMPTY LOCATION NEAREST CENTER OF CLIENT AREA
   CRect objrect(cp.x,cp.y,cp.x+rectwidth,cp.y-rectheight);
   FindLocation(objrect);

//SET CAPTION AND FAX PROPERTY
   pTextObj->m_position.SetRect( objrect.left,objrect.top, objrect.left + caption.cx, objrect.top - caption.cy);
   objrect.left += caption.cx+G_ISPACING;
   pFaxPropObj->m_position.SetRect( objrect.left,objrect.top, objrect.left+faxpropWidth, objrect.top-faxpropHeight);      //set property object text

//Snap to current font for fine tuning
   pTextObj->SnapToFont();
   pFaxPropObj->SnapToFont();

//SET TEXT, ADD TO CONTAINER, AND SELECT CAPTION AND FAX PROPERTY
   pTextObj->SetText(szCaption, this);
   pFaxPropObj->SetText(szPropName, this);
   GetDocument()->Add(pTextObj);
   GetDocument()->Add(pFaxPropObj);
   Select(NULL);
   Select(pTextObj);
   Select(pFaxPropObj);

   UpdateStatusBar();
   UpdateStyleBar();

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::CreateFaxText()
{
   CFaxText* pFaxText;

   BeginWaitCursor();

//FETCH CLIENT AREA MEASUREMENTS
   CRect clientrect;   //client area
   TEXTMETRIC tm;
   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;
   CPoint cp = clientrect.TopLeft();

//SET FAX PROPERTY
   pFaxText = new CFaxText(CRect(0,0,0,0));
   CClientDC dc(this);
   dc.SetMapMode(MM_ANISOTROPIC);
   dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX),dc.GetDeviceCaps(LOGPIXELSY));
   dc.SetWindowExt(100, -100);
   dc.SelectStockObject(SYSTEM_FONT);
   dc.GetTextMetrics(&tm);
   int faxpropWidth = GetApp()->m_pFaxMap->GetPropDefLength(IDS_PROP_MS_TEXT)
           * tm.tmAveCharWidth;
   int faxpropHeight = GetApp()->m_pFaxMap->GetPropDefLines(IDS_PROP_MS_TEXT)
           * (tm.tmHeight+3*tm.tmInternalLeading);

//SET SIZES AND LOCATION OF BINDING RECT
   cp.x = (cp.x+ihalfwidth)-(long)(.5*faxpropWidth);
   cp.y = (cp.y-ihalfheight)+(long)(.5*faxpropHeight);

//FIND EMPTY LOCATION NEAREST CENTER OF CLIENT AREA
   CRect objrect(cp.x,cp.y,cp.x+faxpropWidth,cp.y-faxpropHeight);
   FindLocation(objrect);

//SET CAPTION AND FAX PROPERTY
   pFaxText->m_position.SetRect( objrect.left,objrect.top, objrect.bottom, objrect.right);

//SET TEXT, ADD TO CONTAINER, AND SELECT CAPTION AND FAX PROPERTY
   GetDocument()->Add(pFaxText);
   Select(NULL);
   Select(pFaxText);

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::FindLocation(CRect& objrect)
{
   CObList* pObList = GetDocument()->GetObjects();
   POSITION posObj;
   CRect rcMove=objrect;
   double angle=0;
   CPoint p;
   int r=5;
   BOOL bFoundPlace;
   CRect clientrect;
   CPoint ptCR;

   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;

   ptCR.x=clientrect.left+ihalfwidth;
   ptCR.y=clientrect.top-ihalfheight;
   int iobjwidth = objrect.right-objrect.left;
   int iobjheight = objrect.top-objrect.bottom;
   int iLongestR=max(ihalfheight,ihalfwidth);

   BOOL bCont=TRUE;
//   CClientDC dc(this);                 //testing
//   OnPrepareDC(&dc,NULL);              //testing

   if (iobjwidth>ihalfwidth*2 || iobjheight>ihalfheight*2 ) {      //object is larger than client area

//       rcMove.top=ptCR.y;
//       rcMove.left=ptCR.x;

       rcMove.top=ptCR.y + iobjheight/2;
       rcMove.left=ptCR.x - iobjwidth/2;

       if( rcMove.top > clientrect.top )
                rcMove.top=clientrect.top;

       if( rcMove.left < clientrect.left )
                rcMove.left=clientrect.left;

           rcMove.right=rcMove.left+iobjwidth;
           rcMove.bottom=rcMove.top-iobjheight;
   }
   else {
      while (bCont) {
        bFoundPlace=TRUE;
            posObj = pObList->GetHeadPosition();
            while (posObj != NULL) {
                CDrawObj* pObj = (CDrawObj*)pObList->GetNext(posObj);
                if (pObj->Intersects(rcMove,TRUE)) {
                   bFoundPlace=FALSE;
                       break;
                    }
        }

            if (bFoundPlace)
              break;

        while(1) {
                p.x= (int)(r * cos(angle));
                p.y= (int)(r * sin(angle));
                if (angle<355)
                       angle += 10;
                else {
                       if (r<iLongestR) {
                          r+= 15;
                          angle=0;
                            }
                        else {
                                p.x=p.y=0;
                                bCont=FALSE;
                                break;
                            }
             }

                 if ( ((ptCR.x+p.x-.5*iobjwidth) > clientrect.left) &&
                    ((ptCR.x+p.x+.5*iobjwidth) < clientrect.right) &&
                        ((ptCR.y+p.y-.5*iobjheight) > clientrect.bottom) &&
                        ((ptCR.y+p.y+.5*iobjheight) < clientrect.top) )
                      break;
            }

        rcMove = objrect + p;

//      dc.Rectangle(rcMove);   //testing
      }
   }
   objrect=rcMove;
}



//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipName()
{
   CreateFaxProp(IDS_PROP_RP_NAME);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipFaxNum()
{
   CreateFaxProp(IDS_PROP_RP_FXNO);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCompany()
{
   CreateFaxProp(IDS_PROP_RP_COMP);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipAddress()
{
   CreateFaxProp(IDS_PROP_RP_ADDR);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCity()
{
   CreateFaxProp(IDS_PROP_RP_CITY);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipState()
{
   CreateFaxProp(IDS_PROP_RP_STAT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipPOBox()
{
   CreateFaxProp(IDS_PROP_RP_POBX);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipZipCode()
{
   CreateFaxProp(IDS_PROP_RP_ZIPC);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCountry()
{
   CreateFaxProp(IDS_PROP_RP_CTRY);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipTitle()
{
   CreateFaxProp(IDS_PROP_RP_TITL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipDept()
{
   CreateFaxProp(IDS_PROP_RP_DEPT);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipOfficeLoc()
{
   CreateFaxProp(IDS_PROP_RP_OFFI);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipHMTeleNum()
{
   CreateFaxProp(IDS_PROP_RP_HTEL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipOFTeleNum()
{
   CreateFaxProp(IDS_PROP_RP_OTEL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipToList()
{
   CreateFaxProp(IDS_PROP_RP_TOLS);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCCList()
{
   CreateFaxProp(IDS_PROP_RP_CCLS);
}

//--------------------------------------------------------------------------
// *_*_*_   SENDER WM_COMMAND METHODS
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderName()
{
    CreateFaxProp(IDS_PROP_SN_NAME);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderFaxNum()
{
   CreateFaxProp(IDS_PROP_SN_FXNO);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderCompany()
{
   CreateFaxProp(IDS_PROP_SN_COMP);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderAddress()
{
   CreateFaxProp(IDS_PROP_SN_ADDR);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderTitle()
{
   CreateFaxProp(IDS_PROP_SN_TITL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderDept()
{
   CreateFaxProp(IDS_PROP_SN_DEPT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderOfficeLoc()
{
   CreateFaxProp(IDS_PROP_SN_OFFI);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderHMTeleNum()
{
   CreateFaxProp(IDS_PROP_SN_HTEL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderOFTeleNum()
{
   CreateFaxProp(IDS_PROP_SN_OTEL);
}

// *_*_*_   MESSAGE WM_COMMAND METHODS

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgSubject()
{
   CreateFaxProp(IDS_PROP_MS_SUBJ);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgTimeSent()
{
   CreateFaxProp(IDS_PROP_MS_TSNT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgNumPages()
{
   CreateFaxProp(IDS_PROP_MS_NOPG);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgAttach()
{
   CreateFaxProp(IDS_PROP_MS_NOAT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgBillCode()
{
   CreateFaxProp(IDS_PROP_MS_BCOD);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgFaxText()
{
   CreateFaxText();
}

//--------------------------------------------------------------------------
void CDrawView::OnMapiMsgNote()
{
   CreateFaxProp(IDS_PROP_MS_NOTE);
}

//--------------------------------------------------------------------------
void CDrawView::OnDrawSelect()
{
    CDrawTool::c_drawShape = select;
}

void CDrawView::OnDrawRoundRect()
{
    CDrawTool::c_drawShape = roundRect;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawRect()
{
    CDrawTool::c_drawShape = rect;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawText()
{
    CDrawTool::c_drawShape = text;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawLine()
{
    CDrawTool::c_drawShape = line;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawEllipse()
{
    CDrawTool::c_drawShape = ellipse;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawPolygon()
{
//The Window's 95 way: Bring up a dialog box with directions the FIRST TIME ONLY!!! How unconventional!
//    CString sz = AfxGetApp()->GetProfileString(GENERALSECTION,MSGDRAWPOLY,_T("YES"));
//    if ( sz==_T("YES") ) {
  //     CPEMessageBox(MSG_INFO_DRAWPOLY, NULL, MB_OK, IDS_INFO_DRAWPOLY);
  //         AfxGetApp()->WriteProfileString(GENERALSECTION,MSGDRAWPOLY,_T("NO"));
    //    }

    //
    // Fix for BUG 39665 by a-juliar, 05-24-96.  We have modified the resource string
    // for IDS_INFO_DRAWPOLY to give the same directions that Word 6.0 gives.  But I
    // really dislike the dialog box that appeared only the first time you ran the app.
    // PUT THE DIRECTIONS ON THE STATUS BAR where they belong!
    //

    CString sz ;
    sz.LoadString( IDS_INFO_DRAWPOLY );
    GetFrame()->m_wndStatusBar.SetPaneText(0,sz);
    CDrawTool::c_drawShape = poly;
}


//----------------------------------------------------------------------------
void CDrawView::OnSelEndOKFontSize()
{
}

//----------------------------------------------------------------------------
void CDrawView::OnSelChangeFontName(CObList* pObList/*=NULL*/, CDrawText* p /*=NULL*/)
{
   CString szName;
   CComboBox& cbox=GetFrame()->m_StyleBar.m_cboxFontName;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   int iSel = cbox.GetCurSel();
   if ( iSel != CB_ERR)
       cbox.GetLBText(iSel,szName);
   else
       cbox.GetWindowText(szName);

   LOGFONT lf;
   if (pText) {   //change object in edit
       lstrcpy(pText->m_logfont.lfFaceName,szName);
       lf.lfWeight=pText->m_logfont.lfWeight;
       lf.lfItalic=pText->m_logfont.lfItalic;
       pText->ChgLogfont(lf);
       pText->m_pEdit->SetFocus();
       return;
   }

   CDrawObj* pObj;

   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
      pObj=(CDrawObj*) pob->GetNext(pos);
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
         CDrawText* pTextObj=(CDrawText*)pObj;
             lstrcpy(pTextObj->m_logfont.lfFaceName,szName);
         lf.lfWeight=pTextObj->m_logfont.lfWeight;
         lf.lfItalic=pTextObj->m_logfont.lfItalic;
             pTextObj->ChgLogfont(lf);
      }
   }
   ::SetFocus(m_hWnd);
}

//----------------------------------------------------------------------------
void CDrawView::OnSelchangeFontName()
{
   OnSelChangeFontName();
}

//----------------------------------------------------------------------------
void CDrawView::OnSelchangeFontSize()
{
   OnSelChangeFontSize();
}


//----------------------------------------------------------------------------
void CDrawView::OnEditChangeFont()
{
   m_bFontChg=TRUE;
}

//----------------------------------------------------------------------------
void CDrawView::OnSelChangeFontSize(CObList* pObList/*=NULL*/,CDrawText* p /*=NULL*/)
{
   CString sz;
   CComboBox& cbox=GetFrame()->m_StyleBar.m_cboxFontSize;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   int iSel = cbox.GetCurSel();
   if ( iSel != CB_ERR)
       cbox.GetLBText(iSel,sz);
   else
       cbox.GetWindowText(sz);
   WORD wPointSize = (WORD)_ttoi(sz);

   if (wPointSize <= 0 || wPointSize > 5000) {
      UpdateStyleBar(pob,pText);
      return;
   }

   CClientDC dc(NULL);

   LOGFONT lf;
   if (pText) {   //change object in edit
       if (GetPointSize(*pText)==wPointSize)
              return;
       pText->m_logfont.lfHeight=  -MulDiv(wPointSize,100,72);
       lf.lfWeight=pText->m_logfont.lfWeight;
       lf.lfItalic=pText->m_logfont.lfItalic;
       pText->m_logfont.lfWidth=0;
       pText->ChgLogfont(lf);
       pText->m_pEdit->SetFocus();
       return;
   }

   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
      pObj=(CDrawObj*) pob->GetNext(pos);
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
             CDrawText* pTextObj=(CDrawText*)pObj;
             if (GetPointSize(*pTextObj)!=wPointSize) {
            lf.lfWeight=pTextObj->m_logfont.lfWeight;
            lf.lfItalic=pTextObj->m_logfont.lfItalic;
            pTextObj->m_logfont.lfHeight= -MulDiv(wPointSize,100,72);
                pTextObj->m_logfont.lfWidth=0;
                pTextObj->ChgLogfont(lf);
                pTextObj->FitEditWnd(this);
             }
      }
   }
   ::SetFocus(m_hWnd);
}


//----------------------------------------------------------------------------
void CDrawView::OnFont()
{
    LOGFONT lf ;
    UINT id, style;
    int i;
    int image;
    CString sz;
    CClientDC dc(NULL);

    memset(&lf,0,sizeof(LOGFONT)) ;

    GetFrame()->m_StyleBar.m_cboxFontName.GetWindowText(sz);
    if (sz.GetLength()>0){
        lstrcpy( lf.lfFaceName, sz);
    }
    GetFrame()->m_StyleBar.m_cboxFontSize.GetWindowText(sz);
    if (sz.GetLength()>0) {
        WORD wPointSize = (WORD)_ttoi(sz);
        lf.lfHeight = -( (wPointSize * dc.GetDeviceCaps(LOGPIXELSY))/72 );
    }
    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfWeight = FW_BOLD;
    }
    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfItalic = TRUE ;
    }
    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfUnderline = TRUE ;
    }

    CMyFontDialog dlgFont(
        (LPLOGFONT)&lf,
        CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS | CF_NOVERTFONTS,
        NULL,
        this
        ) ;
    LOGFONT dlf;

    if (dlgFont.DoModal()==IDOK) {

        //
        // steveke wants the font change Undoable.
        // We are going to assume that THE FONT HAS CHANGED.
        // If it hasn't, UNDO will do nothing.
        //

        if (m_pObjInEdit) {   //change object in edit

            m_pObjInEdit->m_bUndoFont = TRUE ;
            m_pObjInEdit->m_bUndoAlignment = FALSE ;
            m_pObjInEdit->m_bUndoTextChange = FALSE ;
            memcpy (
                & m_pObjInEdit->m_previousLogfontForUndo,
                & m_pObjInEdit->m_logfont,
                sizeof(LOGFONT)
                );
            memset(&m_pObjInEdit->m_logfont,0,sizeof(LOGFONT)) ;

            lstrcpy(m_pObjInEdit->m_logfont.lfFaceName,dlgFont.GetFaceName()) ;

            m_pObjInEdit->m_logfont.lfHeight=-MulDiv(dlgFont.GetSize()/10,100,72);

            dlf.lfWeight=m_pObjInEdit->m_logfont.lfWeight;
            dlf.lfItalic=m_pObjInEdit->m_logfont.lfItalic;

            m_pObjInEdit->m_logfont.lfWeight=dlgFont.GetWeight();
            m_pObjInEdit->m_logfont.lfItalic=dlgFont.IsItalic() != FALSE;
            m_pObjInEdit->m_logfont.lfUnderline=dlgFont.IsUnderline() != FALSE;

            m_pObjInEdit->ChgLogfont(dlf);

            m_pObjInEdit->m_pEdit->SetFocus();
            return;
        }

        SaveStateForUndo();

        CDrawObj* pObj;
        CDrawText* pTextObj;
        POSITION pos = m_selection.GetHeadPosition();
        while (pos != NULL) {
            pObj=(CDrawObj*)m_selection.GetNext(pos);
            if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
                pTextObj=(CDrawText*)pObj;
                memset(&pTextObj->m_logfont,0,sizeof(LOGFONT)) ;
                lstrcpy(pTextObj->m_logfont.lfFaceName,dlgFont.GetFaceName()) ;
                pTextObj->m_logfont.lfHeight=-MulDiv(dlgFont.GetSize()/10,100,72);
                dlf.lfWeight=pTextObj->m_logfont.lfWeight;
                dlf.lfItalic=pTextObj->m_logfont.lfItalic;
                pTextObj->m_logfont.lfWeight=dlgFont.GetWeight();
                pTextObj->m_logfont.lfItalic=dlgFont.IsItalic() != FALSE;
                pTextObj->m_logfont.lfUnderline=dlgFont.IsUnderline() != FALSE;
                pTextObj->ChgLogfont(dlf);
            }
        }
    }

}



//----------------------------------------------------------------------------
void CDrawView::OnStyleBold()
{
   LOGFONT lf;
   UINT nID, nStyle;
   int iImage;
   LONG lWeight;
   int index;

   index = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
   GetFrame()->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   if (nStyle&TBBS_CHECKED)   /////// BUG FIX!  by a-juliar
      lWeight=FW_BOLD;
   else
      lWeight=FW_REGULAR;


   if (m_pObjInEdit) {   //change object in edit
       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;


       lf.lfWeight=m_pObjInEdit->m_logfont.lfWeight;
       lf.lfItalic=m_pObjInEdit->m_logfont.lfItalic;
       m_pObjInEdit->m_logfont.lfWeight=lWeight;
       m_pObjInEdit->ChgLogfont(lf, FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
        lf.lfWeight=((CDrawText*)pObj)->m_logfont.lfWeight;
        lf.lfItalic=((CDrawText*)pObj)->m_logfont.lfItalic;
        ((CDrawText*)pObj)->m_logfont.lfWeight=lWeight;
        ((CDrawText*)pObj)->ChgLogfont(lf, FALSE);

     }
   }
}



//----------------------------------------------------------------------------
void CDrawView::OnStyleItalic()
{
   UINT nID, nStyle;
   int iImage;
   BOOL bItalic;
   int index;

   index = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
   GetFrame()->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   ///////bItalic = !(nStyle & TBBS_CHECKED);   /// BUG FIX! This is backwards!!!  a-juliar
   bItalic = (nStyle & TBBS_CHECKED) ? 1 : 0 ;
   LOGFONT lf;
   if (m_pObjInEdit) {   //change object in edit

       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;

       m_pObjInEdit->m_logfont.lfItalic=bItalic != FALSE;
       m_pObjInEdit->ChgLogfont(lf,FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->m_logfont.lfItalic=bItalic != FALSE;
            ((CDrawText*)pObj)->ChgLogfont(lf,FALSE);
     }
   }
}


//----------------------------------------------------------------------------
void CDrawView::OnStyleUnderline()
{
   UINT nID, nStyle;
   int iImage;
   BOOL bUnderline;
   int index;

   index = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
   GetFrame()->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   bUnderline = (nStyle & TBBS_CHECKED) ? 1 : 0 ;
   LOGFONT lf;
   if (m_pObjInEdit) {   //change object in edit

       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;

       m_pObjInEdit->m_logfont.lfUnderline=bUnderline != FALSE;
       m_pObjInEdit->ChgLogfont(lf,FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->m_logfont.lfUnderline=bUnderline != FALSE;
            ((CDrawText*)pObj)->ChgLogfont(lf,FALSE);
     }
   }
}



//----------------------------------------------------------------------------
void CDrawView::ChgTextAlignment(LONG lstyle)
{
    if (m_pObjInEdit) {
        m_pObjInEdit->ChgAlignment(this, lstyle);
        m_pObjInEdit->m_pEdit->ShowWindow(SW_NORMAL);
        GetDocument()->SetModifiedFlag();          //set document dirty
        return;
    }
    SaveStateForUndo();
    CDrawObj* pObj;
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
        pObj=(CDrawObj*)m_selection.GetNext(pos);
        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->ChgAlignment(this, lstyle);
            GetDocument()->SetModifiedFlag();         //set document dirty
            pObj->Invalidate();
     }
   }
}


void CDrawView::OnStyleLeft()
{
   ChgTextAlignment(ES_LEFT);
}


void CDrawView::OnStyleCentered()
{
   ChgTextAlignment(ES_CENTER);
}


void CDrawView::OnStyleRight()
{
   ChgTextAlignment(ES_RIGHT);
}

#ifdef GRID
void CDrawView::OnSnapToGrid()
{
    m_bSnapToGrid=!m_bSnapToGrid;
}
#endif

#ifdef GRID
void CDrawView::OnGridSettings()
{
   CGridSettingsDlg dlg(this);

   if (dlg.DoModal() != IDOK)
       return;

   if (dlg.m_bRBSmall)
      m_iGridSize=GRID_SMALL;
   else
      if (dlg.m_bRBMedium)
         m_iGridSize=GRID_MEDIUM;
      else
         m_iGridSize=GRID_LARGE;

   m_bGrid=dlg.m_bCBViewGrid;
   m_bSnapToGrid=dlg.m_bCBSnapToGrid;

   Invalidate(FALSE);

   m_pDocument->SetModifiedFlag();
}
#endif


//--------------------------------------------------------------------------
void CDrawView::NormalizeObjs()
{
    CDrawObj* pobj;
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       NormalizeRect(pobj->m_position);
    }
}


//--------------------------------------------------------------------------
void CDrawView::NormalizeRect(CRect& rc)
{
        int nTemp;
        if (rc.left > rc.right) {
                nTemp = rc.left;
                rc.left = rc.right;
                rc.right = nTemp;
        }
        if (rc.top < rc.bottom) {
                nTemp = rc.top;
                rc.top = rc.bottom;
                rc.bottom = nTemp;
        }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignLeft()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int ileftmost = GetDocument()->GetSize().cx / 2;

        NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.left < ileftmost)
           ileftmost=pobj->m_position.left;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.left != ileftmost) {
          rc = pobj->m_position;
          rc.right = ileftmost + (pobj->m_position.right - pobj->m_position.left);
          rc.left = ileftmost;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignRight()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int irightmost = GetDocument()->GetSize().cx / -2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.right > irightmost)
           irightmost=pobj->m_position.right;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.right != irightmost) {
          rc = pobj->m_position;
          rc.left = irightmost - (pobj->m_position.right - pobj->m_position.left);
          rc.right = irightmost;
          pobj->MoveTo(rc, this);
       }
    }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignTop()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int itopmost = GetDocument()->GetSize().cy / -2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.top > itopmost)
           itopmost=pobj->m_position.top;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.top != itopmost) {
          rc = pobj->m_position;
          rc.bottom = itopmost - (pobj->m_position.top - pobj->m_position.bottom);
          rc.top = itopmost;
          pobj->MoveTo(rc, this);
       }
    }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignBottom()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int ibottommost = GetDocument()->GetSize().cy / 2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.bottom < ibottommost)
           ibottommost=pobj->m_position.bottom;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.bottom != ibottommost) {
          rc = pobj->m_position;
          rc.top = ibottommost + (pobj->m_position.top - pobj->m_position.bottom);
          rc.bottom = ibottommost;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignHorzCenter()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    int iMiddle;
    if (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iMiddle = pobj->m_position.top - ((pobj->m_position.top - pobj->m_position.bottom) / 2);
    }
    else
       return;

    CRect rc;
    int iTempMiddle, iMoveY;

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iTempMiddle = pobj->m_position.top - ((pobj->m_position.top - pobj->m_position.bottom) / 2);
       if (iTempMiddle != iMiddle) {
          iMoveY = iMiddle - iTempMiddle;
          rc = pobj->m_position;
          rc.bottom += iMoveY;
          rc.top += iMoveY;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignVertCenter()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    int iMiddle;
    if (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iMiddle = pobj->m_position.right - ((pobj->m_position.right - pobj->m_position.left) / 2);
    }
    else
       return;

    CRect rc;
    int iTempMiddle, iMoveX;

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iTempMiddle = pobj->m_position.right - ((pobj->m_position.right - pobj->m_position.left) / 2);
       if (iTempMiddle != iMiddle) {
          iMoveX = iMiddle - iTempMiddle;
          rc = pobj->m_position;
          rc.left += iMoveX;
          rc.right += iMoveX;
          pobj->MoveTo(rc, this);
       }
    }
}

//-------------------------------------------------------------------------------
CSortedObList& CSortedObList::operator=(CObList& list)
{
    POSITION pos = list.GetHeadPosition();
    while (pos != NULL)
       AddHead(list.GetNext(pos));
    return *this;
}


//-------------------------------------------------------------------------------
inline void CSortedObList::swap(UINT i, UINT j)
{
    CObject* temp;
    temp = GetAt(FindIndex(i));
    SetAt(FindIndex(i),GetAt(FindIndex(j)));
    SetAt(FindIndex(j),temp);
}


//-------------------------------------------------------------------------------
void CSortedObList::SortToLeft()
{
   CDrawObj* pi,*pi1;

   for (UINT top=(UINT)GetCount()-1;top>0;top--) {   //simple bubble sort
      for (UINT i=0;i<top;i++) {
         pi=(CDrawObj*) GetAt(FindIndex(i));
         pi1=(CDrawObj*) GetAt(FindIndex(i+1));
         if (pi1->m_position.left < pi->m_position.left )
            swap(i+1,i);
                 else
            if (pi1->m_position.left == pi->m_position.left &&
                  pi1->m_position.right < pi->m_position.right )
               swap(i+1,i);
     }
   }
}


//-------------------------------------------------------------------------------
void CSortedObList::SortToBottom()
{
   CDrawObj* pi,*pi1;

   for (UINT top=(UINT)GetCount()-1;top>0;top--) {   //simple bubble sort
      for (UINT i=0;i<top;i++) {
         pi=(CDrawObj*) GetAt(FindIndex(i));
         pi1=(CDrawObj*) GetAt(FindIndex(i+1));
         if (pi1->m_position.bottom < pi->m_position.bottom )
            swap(i+1,i);
                 else
            if (pi1->m_position.bottom == pi->m_position.bottom &&
                  pi1->m_position.top < pi->m_position.top )
               swap(i+1,i);
     }
   }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceAcross()
{
    CDrawObj* pobj;
    CDrawObj *pi1;
    CRect rc;
    int iObjLength=0;
    double iSpace=0;
        double drop_loc;
        long ob_width;
    CSortedObList sol;


    NormalizeObjs();

    SaveStateForUndo();

    int iCount = (int)m_selection.GetCount();
    if (iCount <=2)
       return;

    sol=m_selection;
    sol.SortToLeft();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjLength += (pobj->m_position.right - pobj->m_position.left);
    }

    CRect& rcR = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcL = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcR.right - rcL.left;

    if (iObjLength < iSpan)     //between spaces are even
                {
        iSpace = ((double)(iSpan-iObjLength)) / (iCount-1);
                drop_loc = ((double)rcL.right) + iSpace;
                }
    else
        {           //evenly space middles
                drop_loc = ((double)(rcL.left + rcL.right))/2;
        iSpace = (((double)(rcR.left + rcR.right))/2 - drop_loc) /
                                (iCount-1);
                drop_loc += iSpace;
                }


    for (int i=1;i<iCount-1;i++)
        {
                pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
                rc = pi1->m_position;
                ob_width = rc.right-rc.left;
                if (iObjLength < iSpan)
                        {
                        rc.left = (long)(drop_loc + 0.5);
                        rc.right = rc.left + ob_width;
                        drop_loc += (ob_width + iSpace);
                        }
       else
                {
                        rc.left = (long)(drop_loc - ob_width/2 + 0.5);
                        rc.right = rc.left + ob_width;
                        drop_loc += iSpace;
                        }

                pi1->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceDown()
{
    CDrawObj* pobj;
    int iObjHeight=0;
    double iSpace=0;
        double drop_loc;
        long ob_height;
    CSortedObList sol;
    CRect rc;
    CDrawObj *pi1;


    NormalizeObjs();

    SaveStateForUndo();

    int iCount = (int)m_selection.GetCount();
    if (iCount <=2)
       return;

    sol=m_selection;
    sol.SortToBottom();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjHeight += (pobj->m_position.top - pobj->m_position.bottom);
    }

    CRect& rcT = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcB = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcT.top - rcB.bottom;

    if (iObjHeight < iSpan)     //between spaces are even
                {
        iSpace = ((double)(iSpan-iObjHeight)) / (iCount-1);
                drop_loc = ((double)rcB.top) + iSpace;
                }
    else
        {                      //evenly space middles
                drop_loc = ((double)(rcB.bottom + rcB.top))/2;
        iSpace = (((double)(rcT.bottom + rcT.top))/2 - drop_loc) /
                                (iCount-1);
                drop_loc += iSpace;
                }


    for (int i=1;i<iCount-1;i++)
        {
                pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
                rc = pi1->m_position;
                ob_height = rc.top - rc.bottom;

                if (iObjHeight < iSpan)
                        {
                        rc.bottom = (long)(drop_loc + 0.5);
                        rc.top = rc.bottom + ob_height;
                        drop_loc += (ob_height + iSpace);
                        }
                else
                        {
                        rc.bottom = (long)(drop_loc - ob_height/2 + 0.5);
                        rc.top = rc.bottom + ob_height;
                        drop_loc += iSpace;
                        }

                pi1->MoveTo(rc, this);
        }
}


#ifdef FUBAR
void CDrawView::OnSpaceAcross()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    int iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    int iObjLength=0;
    int iSpace=0;

    CSortedObList sol;
    sol=m_selection;
    sol.SortToLeft();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjLength += (pobj->m_position.right - pobj->m_position.left);
    }

    CRect& rcR = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcL = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcR.right - rcL.left;

    if (iObjLength < iSpan)     //between spaces are even
       iSpace = (iSpan-iObjLength) / (iCount-1);
    else                       //evenly space middles
       iSpace = ((rcR.left + (rcR.right-rcR.left)/2)
                  - (rcL.left + (rcL.right-rcL.left)/2)) / (iCount-1);

    CRect rc;
    CDrawObj* pi,*pi1;
    for (int i=0;i<iCount-2;i++) {
       pi=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
       pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i+1));
       rc = pi1->m_position;
       if (iObjLength < iSpan) {
          rc.left = pi->m_position.right + iSpace;
          rc.right = rc.left + (pi1->m_position.right-pi1->m_position.left);
       }
       else {
          int middleL = pi->m_position.left + ((pi->m_position.right-pi->m_position.left)/2);
          rc.left = (middleL+iSpace)-((pi1->m_position.right-pi1->m_position.left)/2);
          rc.right = rc.left + (pi1->m_position.right-pi1->m_position.left);
       }
       pi1->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceDown()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    int iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    int iObjHeight=0;
    int iSpace=0;

    CSortedObList sol;
    sol=m_selection;
    sol.SortToBottom();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjHeight += (pobj->m_position.top - pobj->m_position.bottom);
    }

    CRect& rcT = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcB = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcT.top - rcB.bottom;

    if (iObjHeight < iSpan)     //between spaces are even
       iSpace = (iSpan-iObjHeight) / (iCount-1);
    else                       //evenly space middles
       iSpace = ((rcT.bottom + (rcT.top-rcT.bottom)/2)
                  - (rcB.bottom + (rcB.top-rcB.bottom)/2)) / (iCount-1);

    CRect rc;
    CDrawObj* pi,*pi1;
    for (int i=0;i<iCount-2;i++) {
       pi=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
       pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i+1));
       rc = pi1->m_position;
       if (iObjHeight < iSpan) {
          rc.bottom = pi->m_position.top + iSpace;
          rc.top = rc.bottom + (pi1->m_position.top-pi1->m_position.bottom);
       }
       else {
          int middleL = pi->m_position.bottom + ((pi->m_position.top-pi->m_position.bottom)/2);
          rc.bottom = (middleL+iSpace)-((pi1->m_position.top-pi1->m_position.bottom)/2);
          rc.top = rc.bottom + (pi1->m_position.top-pi1->m_position.bottom);
       }
       pi1->MoveTo(rc, this);
    }
}
#endif


//--------------------------------------------------------------------------
void CDrawView::OnCenterWidth()
{
    if (m_selection.GetCount() < 1)
            return;

    SaveStateForUndo();

    CRect rc(0,0,0,0);

    POSITION pos = m_selection.GetHeadPosition();
    CDrawObj* pobj;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
           pobj->m_position.NormalizeRect();
       rc |= pobj->m_position;
    }

    int iSpace = rc.left + ((rc.right - rc.left) /2);

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       rc = pobj->m_position;
       rc.left += -iSpace;
       rc.right += -iSpace;
       pobj->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnCenterHeight()
{
    if (m_selection.GetCount() < 1)
            return;

    SaveStateForUndo();

    CRect rc(0,0,0,0);

    POSITION pos = m_selection.GetHeadPosition();
    CDrawObj* pobj;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
           pobj->m_position.NormalizeRect();
       rc |= pobj->m_position;   //requires Y increase downward
    }

    NormalizeRect(rc);
    NormalizeObjs();

    int iSpace = rc.bottom + ((rc.top - rc.bottom) /2);

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       rc = pobj->m_position;
       rc.bottom += -iSpace;
       rc.top += -iSpace;
       pobj->MoveTo(rc, this);
    }
}


void CDrawView::OnUpdateDrawEllipse(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == ellipse);
}


void CDrawView::OnUpdateDrawLine(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == line);
}

void CDrawView::OnUpdateDrawRect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == rect);
}

void CDrawView::OnUpdateDrawText(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == text);
}

void CDrawView::OnUpdateDrawRoundRect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == roundRect);
}

void CDrawView::OnUpdateDrawSelect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == select);
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdatePosStatusBar(CCmdUI* pCmdUI)
{
    pCmdUI->Enable();
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdateFaxText(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdateSingleSelect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() == 1);
}

void CDrawView::OnUpdateMoreThanOne(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() >= 1);
}


void CDrawView::OnUpdateMove(CCmdUI* pCmdUI)
{
#if 0
   pCmdUI->Enable(m_selection.GetCount() == 1
         && GetDocument()->GetObjects()->GetCount()>1);
#endif

   //
   // BUG FIX for 33738, by a-juliar, 5-20-96
   //

      int Count = (int)m_selection.GetCount() ;
      pCmdUI->Enable( Count > 0
             && GetDocument()->GetObjects()->GetCount() > Count ) ;
}


#ifdef GRID
void CDrawView::OnUpdateSnapToGrid(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(m_bSnapToGrid);
}
#endif

void CDrawView::OnUpdateAlign(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() > 1);
}

void CDrawView::OnUpdateAlign3(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() >= 3);
}


#ifdef GRID
void CDrawView::OnUpdateGridSettings(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(1);
}
#endif


//-------------------------------------------------------------------------------
void CDrawView::OnEditSelectAll()
{
    CObList* pObList = GetDocument()->GetObjects();
    POSITION pos = pObList->GetHeadPosition();
    while (pos != NULL)
        Select((CDrawObj*)pObList->GetNext(pos));

    UpdateStatusBar();
    UpdateStyleBar();
}

//-------------------------------------------------------------------------------
void CDrawView::OnUpdateEditSelectAll(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->GetObjects()->GetCount() != 0);
}

//-------------------------------------------------------------------------------
void CDrawView::OnEditUndo()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit && m_pObjInEdit->CanUndo()){
        m_pObjInEdit->OnEditUndo() ;
        return ;
    }
    if(m_pObjInEdit && m_pObjInEdit->m_pEdit ){
        m_pObjInEdit->HideEditWnd( this, FALSE );
    }
    m_selection.RemoveAll();
    GetDocument()->SwapListsForUndo();
    InvalidateRect( NULL );
  ///  GetDocument()->UpdateAllViews();
}

//-------------------------------------------------------------------------------
void CDrawView::OnEditClear()
{
    if (m_selection.GetCount() > 0){
       SaveStateForUndo();
    }
    // update all the views before the selection goes away
    GetDocument()->UpdateAllViews(NULL, HINT_DELETE_SELECTION, &m_selection);
    OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);

    // now remove the selection from the document
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
           GetDocument()->Remove(pObj);
       GetDocument()->SetModifiedFlag();          //set document dirty
    }
    m_selection.RemoveAll();

    SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));

    UpdateStatusBar();
}


//----------------------------------------------------------------------------------
void CDrawView::UpdateStatusBar()
{
    CMainFrame* pFrame = (CMainFrame*) AfxGetMainWnd();
    if (!pFrame)
       return;

    if (CDrawView::GetView()->m_selection.GetCount()!=1) {
       pFrame->m_wndStatusBar.SetPaneText(1,_T(""));
       pFrame->m_wndStatusBar.SetPaneText(2,_T(""));
       return;
        }

    POSITION pos = m_selection.GetHeadPosition();
    if (pos==NULL)
           return;

    CDrawObj* pObj=(CDrawObj*)m_selection.GetNext(pos);

    CRect rc = pObj->m_position;
        CSize cs=CDrawDoc::GetDoc()->GetSize();

    CDrawView::GetView()->NormalizeRect(rc);
    rc.left+= cs.cx/2;
    rc.right+= cs.cx/2;
    rc.top = cs.cy/2-rc.top;
    rc.bottom = cs.cy/2 - rc.bottom;

    TCHAR szT1[] = _T(" %i, %i");
    TCHAR szT2[] = _T(" %i x %i");
    TCHAR sz[50];
    wsprintf(sz,szT1,rc.left,rc.top);
    pFrame->m_wndStatusBar.SetPaneText(1,sz);
    wsprintf(sz,szT2,rc.right-rc.left,rc.bottom-rc.top);
    pFrame->m_wndStatusBar.SetPaneText(2,sz);
}

void CDrawView::SaveStateForUndo()
{
    m_bCanUndo = TRUE ;
    CDrawDoc * pDoc = GetDocument() ;
    CObList * pPrevious = &pDoc->m_previousStateForUndo ;
    FreeObjectsMemory( pPrevious );
    pPrevious->RemoveAll();
    pDoc->CloneObjectsForUndo();
}

void CDrawView::FreeObjectsMemory( CObList * pObList )
{
    POSITION pos = pObList->GetHeadPosition();
    while( pos != NULL ){
        CObject * pObj = pObList->GetNext( pos ) ;
        CRuntimeClass* pWhatClass = pObj->GetRuntimeClass() ;
        if( pWhatClass == RUNTIME_CLASS( CDrawOleObj )){
            COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
            if (pItem)  { //remove client item from document
                pItem->Release(OLECLOSE_NOSAVE);
                pItem->InternalRelease();
            }
            delete pObj ;
        }
        else {
            delete pObj ;
        }
    }
}

void CDrawView::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( m_bCanUndo );
}

void CDrawView::OnUpdateAnySelect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!m_selection.IsEmpty());
}

void CDrawView::OnUpdateDrawPolygon(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == poly);
}

void CDrawView::OnSize(UINT nType, int cx, int cy)
{
    CScrollView::OnSize(nType, cx, cy);
    UpdateActiveItem();
}

void CDrawView::OnViewGridLines()
{
    m_bGridLines = !m_bGridLines;
    Invalidate(FALSE);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateViewGridLines(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bGridLines);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateFont(CCmdUI* pCmdUI)
{
   if (m_pObjInEdit) {
      pCmdUI->Enable(TRUE);
      return;
   }

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL)
     if (((CDrawObj*)m_selection.GetNext(pos))->IsKindOf(RUNTIME_CLASS(CDrawText))) {
        pCmdUI->Enable(TRUE);
        return;
     }

   pCmdUI->Enable(FALSE);
}


//--------------------------------------------------------------------------
int CDrawView::GetPointSize(CDrawText& TextObj)
{
   return abs(MulDiv(TextObj.m_logfont.lfHeight,72,100));

/*
   TEXTMETRIC tm;
   CClientDC dc(TextObj.m_pEdit);
   dc.SelectObject(TextObj.m_pEdit->GetFont());
   dc.GetTextMetrics(&tm);
   int pointsize = MulDiv( (tm.tmHeight-tm.tmInternalLeading),72,dc.GetDeviceCaps(LOGPIXELSY) );
   return pointsize;
*/
}


BOOL CDrawView::OnEraseBkgnd(CDC* pDC)
{
    return TRUE;
}


void CDrawView::OnObjectMoveBack()
{
   CDrawDoc* pDoc = GetDocument();
   CDrawObj* pObj = (CDrawObj*)m_selection.GetHead();
   CObList* pObjects = pDoc->GetObjects();
   POSITION pos = pObjects->Find(pObj);
   ASSERT(pos != NULL);
   if (pos != pObjects->GetHeadPosition()) {
          POSITION posPrev = pos;
          pObjects->GetPrev(posPrev);
          pObjects->RemoveAt(pos);
          pObjects->InsertBefore(posPrev, pObj);
      pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveForward()
{
   CDrawDoc* pDoc = GetDocument();
   CDrawObj* pObj = (CDrawObj*)m_selection.GetHead();
   CObList* pObjects = pDoc->GetObjects();
   POSITION pos = pObjects->Find(pObj);
   ASSERT(pos != NULL);
   if (pos != pObjects->GetTailPosition()) {
          POSITION posNext = pos;
          pObjects->GetNext(posNext);
          pObjects->RemoveAt(pos);
          pObjects->InsertAfter(posNext, pObj);
          pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveToBack()
{
   SaveStateForUndo();
   CDrawDoc* pDoc = GetDocument();
   CObList* pObjects = pDoc->GetObjects();
   POSITION s_pos = m_selection.GetTailPosition();
   while( s_pos != NULL ){
       CDrawObj* pObj = (CDrawObj*)m_selection.GetPrev( s_pos ) ;
       POSITION o_pos = pObjects->Find(pObj);
       ASSERT(o_pos != NULL);
       pObjects->RemoveAt(o_pos);
       pObjects->AddHead(pObj);
       pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveToFront()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
        return;
    }

    SaveStateForUndo();

    CDrawDoc* pDoc = GetDocument();
    CObList* pObjects = pDoc->GetObjects();
    POSITION s_pos = m_selection.GetHeadPosition();
    while( s_pos != NULL ){
        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext( s_pos ) ;
        POSITION o_pos = pObjects->Find(pObj);
        ASSERT(o_pos != NULL);
        pObjects->RemoveAt(o_pos);
        pObjects->AddTail(pObj);
        pObj->Invalidate();
    }
    pDoc->SetModifiedFlag();
}


void CDrawView::OnEditCopy()
{
   ASSERT_VALID(this);
   ASSERT(m_cfDraw != NULL);

   if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
       m_pObjInEdit->m_pEdit->SendMessage(WM_COPY,0,0L);
       m_pObjInEdit->m_bUndoAlignment = FALSE ;
       m_pObjInEdit->m_bUndoFont = FALSE ;
       m_pObjInEdit->m_bUndoTextChange = TRUE ;
       return;
   }

   // Create a shared file and associate a CArchive with it
   CSharedFile file;
   CArchive ar(&file, CArchive::store);

   // Serialize selected objects to the archive
   m_selection.Serialize(ar);
   ar.Close();

   COleDataSource* pDataSource = NULL;

   CDrawOleObj* pDrawOle = (CDrawOleObj*)m_selection.GetHead();
   TRY {
        pDataSource = new COleDataSource;
        // put on local format instead of or in addation to
        pDataSource->CacheGlobalData(m_cfDraw, file.Detach());

        // if only one item and it is a COleClientItem then also
        // paste in that format
        if (m_selection.GetCount() == 1 &&
                pDrawOle->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
        {
                pDrawOle->m_pClientItem->GetClipboardData(pDataSource, FALSE);
        }
        pDataSource->SetClipboard();
   }
   CATCH_ALL(e)
   {
        delete pDataSource;
        THROW_LAST();
   }
   END_CATCH_ALL
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
    // WRONG! don't enable COPY just because an edit control has input focus! Must have
    // selected text with non-zero length. a-juliar, 9-5-96
    // pCmdUI->Enable(!m_selection.IsEmpty() || (m_pObjInEdit && m_pObjInEdit->m_pEdit));

    if(m_pObjInEdit && m_pObjInEdit->m_pEdit){
        int nStartChar, nEndChar ;
        m_pObjInEdit->m_pEdit->GetSel( nStartChar, nEndChar );
        if( nStartChar < nEndChar ){
            pCmdUI->Enable( TRUE );
            return;
        }
    }
    pCmdUI->Enable(!m_selection.IsEmpty());

}


//--------------------------------------------------------------------------
void CDrawView::OnEditCut()
{
   if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
       m_pObjInEdit->m_pEdit->SendMessage(WM_CUT,0,0L);
       m_pObjInEdit->m_bUndoAlignment = FALSE ;
       m_pObjInEdit->m_bUndoFont = FALSE ;
       m_pObjInEdit->m_bUndoTextChange = TRUE ;
       return;
   }

   OnEditCopy();
   OnEditClear();
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditCut(CCmdUI* pCmdUI)
{
    // WRONG! don't enable CUT just because an edit control has input focus! Must have
    // selected text with non-zero length. a-juliar, 9-5-96
    // pCmdUI->Enable(!m_selection.IsEmpty() || (m_pObjInEdit && m_pObjInEdit->m_pEdit));

    if(m_pObjInEdit && m_pObjInEdit->m_pEdit){
        int nStartChar, nEndChar ;
        m_pObjInEdit->m_pEdit->GetSel( nStartChar, nEndChar );
        if( nStartChar < nEndChar ){
            pCmdUI->Enable( TRUE );
            return;
        }
    }
    pCmdUI->Enable(!m_selection.IsEmpty());
}


//--------------------------------------------------------------------------

void CDrawView::OnEditPaste()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
        m_pObjInEdit->m_pEdit->SendMessage(WM_PASTE,0,0L);
        m_pObjInEdit->m_bUndoAlignment = FALSE ;
        m_pObjInEdit->m_bUndoFont = FALSE ;
        m_pObjInEdit->m_bUndoTextChange = TRUE ;
        return;
    }

    COleDataObject dataObject;
    dataObject.AttachClipboard();

    // invalidate current selection since it will be deselected
    OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
    m_selection.RemoveAll();
    if (dataObject.IsDataAvailable(m_cfDraw)) {
        PasteNative(dataObject);
        //
        // Adjust position of all items in m_selection and add them to the document
        //
        POSITION pos = m_selection.GetHeadPosition();

        while (pos != NULL) {
            CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos) ;
            CRect rect = pObj->m_position;
            rect.top-=10;
            rect.bottom-=10;
            rect.left+=10;
            rect.right+=10;
            pObj->MoveTo( rect, this );
            GetDocument()->Add(pObj);
        }
        OnEditCopy();   /// Fix for bug 44896. Position adjustments above now are in clipboard.
                        /// so that next paste will be offset just a little bit more. 6-19-96
    }
    else {
        PasteEmbedded(dataObject);
    }

    GetDocument()->SetModifiedFlag();

    // invalidate new pasted stuff
    GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_SELECTION, &m_selection);
}

//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditPaste(CCmdUI* pCmdUI)
{
    // Revised by a-juliar, 9-18-96.  Don't allow pastiing a second note rect into the document.

    if (m_pObjInEdit && m_pObjInEdit->m_pEdit ){
        pCmdUI->Enable( ::IsClipboardFormatAvailable(CF_TEXT)); // a-juliar, 9-5-96
        return ;
    }

    //
    // determine if private or standard OLE formats are on the clipboard
    //

    COleDataObject dataObject;
    BOOL bAvailable ;
    BOOL bEnable = dataObject.AttachClipboard() &&
        ((bAvailable = dataObject.IsDataAvailable(m_cfDraw)) ||
        COleClientItem::CanCreateFromData(&dataObject));

    // enable command based on availability
    if( !bEnable ) {
        pCmdUI->Enable(FALSE);
        return ;
    }
    if( !bAvailable ) { // Clipboard has a standard OLE format on it.
        pCmdUI->Enable(TRUE);
        return ;
    }
    //
    // Enable PASTE unless both of the following hold:
    // 1. Document already has a NOTE field
    // 2. Clipboard has a note field.
    //
    BOOL bDocAlreadyHasNoteRect = FALSE ;
    POSITION pos;
    CFaxProp* pfaxprop ;
    pos = GetDocument()->m_objects.GetHeadPosition();
    while (pos != NULL){
        CDrawObj* pObj = (CDrawObj*) GetDocument()->m_objects.GetNext(pos);
        if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ){
        pfaxprop = (CFaxProp *)pObj;
        if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE ){

                 bDocAlreadyHasNoteRect = TRUE ;
            }
        }
    }
    if( !bDocAlreadyHasNoteRect ){
        pCmdUI->Enable(TRUE);
        return ;
    }
    //
    // See if there is a NOTE on the clipboard
    //

    CObList ClipboardList ;
    TRY{
        CFile* pFile = dataObject.GetFileData(m_cfDraw);
        if (pFile == NULL){
            pCmdUI->Enable(FALSE);
            return;
        }
        CArchive ar(pFile, CArchive::load);
        ar.m_pDocument = GetDocument(); // set back-pointer in archive
        ClipboardList.Serialize(ar);
        ar.Close();
        delete pFile;
        //
        // Traverse the list ClipboardList to look for NOTE and free memory.
        //
        POSITION pos = ClipboardList.GetHeadPosition();
        while( pos != NULL ){
            CObject * pObj = ClipboardList.GetNext( pos ) ;
            CRuntimeClass* pWhatClass = pObj->GetRuntimeClass() ;
            if( pWhatClass == RUNTIME_CLASS( CFaxProp )){
                pfaxprop = (CFaxProp *)pObj;
                if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE ){

                         bEnable = FALSE ;
                }
                delete pObj ;
            }
            else if( pWhatClass == RUNTIME_CLASS( CDrawOleObj )){
                COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
                if (pItem)  { //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    ////GetDocument->RemoveItem(((CDrawOleObj*)pObj)->m_pClientItem); ///
                    pItem->InternalRelease();
                }
                delete pObj ;
            }
            else {
                delete pObj ;
            }
        }
        ClipboardList.RemoveAll();
    }
    CATCH_ALL(e)
    {
        pCmdUI->Enable( FALSE );
        return ;
    }
    END_CATCH_ALL
    pCmdUI->Enable(bEnable);
}


//--------------------------------------------------------------------------
void CDrawView::OnFilePrint()
{
   m_selection.RemoveAll();
   if ( ((CDrawApp*)AfxGetApp())->m_dwSesID!=0) {
   ///////   Render();
          return;
   }


   CScrollView::OnFilePrint();

   //GetDocument()->ComputePageSize();
}


//--------------------------------------------------------------------------
#if 0
void CDrawView::Render()
{
   CString strTemp;
   CDrawDoc *pdoc = GetDocument();
   HANDLE hprt;
   LONG   dev_size;
   DEVMODE *dev_buf = NULL;

   // setup the printing DC
   TRACE(TEXT("AWCPE:  CPEVW.CPP.Render() called\n"));

   if( !OpenPrinter( (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice, &hprt, NULL ) )
          {
      TRACE(TEXT("CPEVW.Render: unable to open printer\n"));
      throw "render failed";
          }


   dev_size =
                DocumentProperties( this->GetSafeHwnd(),
                                                hprt,
                                                (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice,
                                                NULL,
                                                    NULL,
                                                    0 );

        dev_buf = (DEVMODE *)new BYTE[ dev_size ];

        if( (dev_size == 0)||(dev_buf == NULL) )
          {
          ClosePrinter( hprt );
      TRACE(TEXT("CPEVW.Render: unable to make dev_buf\n"));
      throw "render failed";
          }


        DocumentProperties( this->GetSafeHwnd(),
                                                hprt,
                                                (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice,
                                                dev_buf,
                                            NULL,
                                            DM_OUT_BUFFER );

        ClosePrinter( hprt );


    dev_buf->dmPaperSize   = pdoc->m_wPaperSize;
    dev_buf->dmOrientation = pdoc->m_wOrientation;

        // use doc scale only if printer supports scaling
        if( dev_buf->dmFields & DM_SCALE        )
        dev_buf->dmScale   = pdoc->m_wScale;
        else
        dev_buf->dmScale   = 100;


   CDC dcPrint;
   if( dcPrint.CreateDC(_T("winspool"),GetApp()->m_szRenderDevice,NULL,
                (void *)dev_buf )==0)
        {
                delete [] dev_buf;

      TRACE(TEXT("CPEVW.Render: unable to create a printer DC\n"));
      throw "render failed";
        }



        delete [] dev_buf;

        // reset note position
        theApp.reset_note();


   dcPrint.m_bPrinting=TRUE;

   DOCINFO docInfo;
   memset(&docInfo, 0, sizeof(DOCINFO));
   docInfo.cbSize = sizeof(DOCINFO);
   docInfo.lpszDocName = GetDocument()->GetTitle();
   docInfo.lpszOutput = NULL;

   TRACE(TEXT("AWCPE:  CPEVW.CPP.StartDoc() called\n"));
   if (dcPrint.StartDoc(&docInfo) == SP_ERROR) {
      TRACE(TEXT("CPEVW.Render: unable to StartDoc\n"));
      throw "render failed";
   }

   OnPrepareDC(&dcPrint,NULL);

   TRACE(TEXT("AWCPE:  CPEVW.CPP.StartPage() called\n"));
   if (dcPrint.StartPage() < 0) {
      TRACE(TEXT("CPEVW.Render: unable to StartPage\n"));
      throw "render failed";
   }


   // set up for note pages
   //
   // NOTE TO RAND:
   //   The extra note must be created BEFORE OnPrint so that
   //   any page-no objects can properly guess how many pages
   //   are left after the note object has consumed some of the
   //   note text. page-no objects are sorted to be after note
   //   objects in the objects list so they will be drawn after
   //   the note object has drawn. Setting of theApp.m_last_note_box
   //   has been done before this point so that the extranote
   //   will be created with the proper font, etc (bug fix for
   //   3647).
   //
   if( theApp.m_note_wasread )
                make_extranote( &dcPrint );

   OnPrint(&dcPrint, NULL);



   // get rid of surprise dialogs
   pdoc->SetModifiedFlag( FALSE );

   TRACE(TEXT("AWCPE:  CPEVW.CPP.EndPage() called\n"));
   if (dcPrint.EndPage() < 0) {
      TRACE(TEXT("CPEVW.Render: unable to EndPage\n"));
      throw "render failed";
   }


        // see if we need extra note pages
        if( theApp.m_note_wasread )
                {
                if( theApp.m_extra_notepage != NULL )
                        {
                        // print page sized chunks untill note is consumed
                        while( theApp.more_note() )
                                {
                                if( dcPrint.StartPage() < 0 )
                                        {
                                        TRACE(TEXT("CPEVW.Render: unable to StartPage\n"));
                                        throw "render failed";
                                        }

                                theApp.m_extra_notepage->Draw( &dcPrint, this );

                                if( dcPrint.EndPage() < 0 )
                                        {
                                        TRACE(TEXT("CPEVW.Render: unable to EndPage\n"));
                                        throw "render failed";
                                        }
                                }

                        delete theApp.m_extra_notepage;
                        theApp.m_extra_notepage = NULL;
                        }

                // get rid of surprise dialogs
                pdoc->SetModifiedFlag( FALSE );
                }


   TRACE(TEXT("AWCPE:  CPEVW.CPP.EndDoc() called\n"));
   if( dcPrint.EndDoc() < 0 )
          {
      TRACE(TEXT("CPEVW.Render: unable to EndDoc\n"));
      throw "render failed";
      }
/*
   if (pDMOut)
      delete [] (BYTE*) pDMOut;
 */
}
#endif





void CDrawView::make_extranote( CDC *pdc )
        {
        CRect note_rect;
        CDrawDoc *pdoc = GetDocument();
        CRect physical_margins;
        CRect note_margins;

        physical_margins.left = pdc->GetDeviceCaps( PHYSICALOFFSETX );
        physical_margins.top = pdc->GetDeviceCaps( PHYSICALOFFSETY );
        physical_margins.right =
                pdc->GetDeviceCaps( PHYSICALWIDTH ) -
                        (physical_margins.left + pdc->GetDeviceCaps( HORZRES ));
        physical_margins.bottom =
                pdc->GetDeviceCaps( PHYSICALHEIGHT ) -
                        (physical_margins.top + pdc->GetDeviceCaps( VERTRES ));


        note_margins.left   = -physical_margins.left;
        note_margins.top    = -physical_margins.top;
        note_margins.right  =
                pdc->GetDeviceCaps( HORZRES ) + physical_margins.right;
        note_margins.bottom =
                pdc->GetDeviceCaps( VERTRES ) + physical_margins.bottom;

        ClientToDoc( note_margins, pdc );


        note_rect.left =
                note_rect.top = 0;
        note_rect.right  = pdc->GetDeviceCaps( HORZRES );
        note_rect.bottom = pdc->GetDeviceCaps( VERTRES );

        ClientToDoc( note_rect, pdc );


        note_margins.left   += 125;     // 1.25"
        note_margins.top    -= 100;     // 1.00"
        note_margins.right  -= 125; // 1.25"
        note_margins.bottom += 100; // 1.00"

        if( note_margins.left > note_rect.left )
                note_rect.left = note_margins.left;

        if( note_margins.top < note_rect.top )
                note_rect.top = note_margins.top;

        if( note_margins.right < note_rect.right )
                note_rect.right = note_margins.right;

        if( note_margins.bottom > note_rect.bottom )
                note_rect.bottom = note_margins.bottom;


        if( theApp.m_extra_notepage != NULL )
                delete theApp.m_extra_notepage;

        theApp.m_extrapage_count = -1; // forces a recalc in CFaxprop::Draw
        theApp.m_extra_notepage = NULL;


// F I X  for 3647 /////////////
//
//FIX FOR 3647 reenables the following 'if' (by commenting out the FALSE)
        if( /*FALSE*/ theApp.m_last_note_box != NULL )
////////////////////////////////
                {
                // make a temp faxprop out of the last note prop so
                // extra pages will have same attrs (line drawn around box,
                // font, etc.)
                theApp.m_extra_notepage =
                        (CFaxProp *)theApp.m_last_note_box->Clone( NULL );

                theApp.m_extra_notepage->m_position = note_rect;
                }
        else
                {
                // Weren't any note objects, make a default one
                theApp.m_extra_notepage =
                        new CFaxProp( note_rect, IDS_PROP_MS_NOTE );

// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
        theApp.m_extra_notepage->m_logfont = theApp.m_default_logfont;
        theApp.m_extra_notepage->
                ChgLogfont( theApp.m_extra_notepage->m_logfont );
////////////////////////////////
                }
        }





#ifdef FUBAR
void CDrawView::make_extranote( CDC *pdc )
        {
        CSize doc_size;
        CRect doc_rect;
        CDrawDoc *pdoc = GetDocument();
        CRect note_size;


        if( theApp.m_extra_notepage != NULL )
                delete theApp.m_extra_notepage;

        theApp.m_extrapage_count = -1; // forces a recalc in CFaxprop::Draw
        theApp.m_extra_notepage = NULL;

        doc_size = pdoc->GetSize();

        // shrink by 6% to allow for transform round off
        // and printer edge
        //
        // This is probably a bug. I'll look at it later. The
        // vieworigin seems to be off a little and the printed
        // page is clipped without this kludge
        //
        doc_size.cx     = (doc_size.cx * 94)/100;
        doc_size.cy     = (doc_size.cy * 94)/100;

        // make page sized rect
        doc_rect.left   = -doc_size.cx/2;
        doc_rect.top    =  doc_size.cy/2;
        doc_rect.right  =  doc_rect.left + doc_size.cx;
        doc_rect.bottom =  doc_rect.top - doc_size.cy;


        if( theApp.m_last_note_box != NULL )
                {
                // make a temp faxprop out of the last note prop so
                // extra pages will have same attrs (line drawn around box,
                // font, etc.)
                theApp.m_extra_notepage =
                        (CFaxProp *)theApp.m_last_note_box->Clone( NULL );

                theApp.m_extra_notepage->m_position = doc_rect;
                }
        else
                {
                // Weren't any note objects, make a default one
                theApp.m_extra_notepage =
                        new CFaxProp( doc_rect, IDS_PROP_MS_NOTE );
                }
        }
#endif





//--------------------------------------------------------------------------
void CDrawView::OnViewShowObjects()
{
   CDrawOleObj::c_bShowItems = !CDrawOleObj::c_bShowItems;
   GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_OLE_ITEMS, NULL);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateViewShowObjects(CCmdUI* pCmdUI)
{
   pCmdUI->SetCheck(CDrawOleObj::c_bShowItems);
}


//-------------------------------------------------------------------------
void CDrawView::OnEditProperties()
{
   if (m_selection.GetCount() < 1 || CDrawTool::c_drawShape != select)
      return;

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   ASSERT(pTool != NULL);

   CObjPropDlg dlg(this);

   if (dlg.DoModal() != IDOK)
       return;

   SaveStateForUndo();  // Assume a change has been made, and make it undoable.

   CString szColorBlack;
   szColorBlack.LoadString(ID_COLOR_BLACK);
   CString szColorWhite;
   szColorWhite.LoadString(ID_COLOR_WHITE);
   CString szColorLTGRAY;
   szColorLTGRAY.LoadString(ID_COLOR_LTGRAY);
   CString szColorMDGRAY;
   szColorMDGRAY.LoadString(ID_COLOR_MDGRAY);
   CString szColorDKGRAY;
   szColorDKGRAY.LoadString(ID_COLOR_DKGRAY);

   COLORREF crFillColor;
   if (dlg.m_szFillColor==szColorBlack)
      crFillColor=COLOR_BLACK;
   else
      if (dlg.m_szFillColor==szColorWhite)
         crFillColor=COLOR_WHITE;
      else
      if (dlg.m_szFillColor==szColorLTGRAY)
         crFillColor=COLOR_LTGRAY;
      else
      if (dlg.m_szFillColor==szColorMDGRAY)
         crFillColor=COLOR_MDGRAY;
      else
      if (dlg.m_szFillColor==szColorDKGRAY)
         crFillColor=COLOR_DKGRAY;
      else
         crFillColor=COLOR_WHITE;

   COLORREF crLineColor;
   if (dlg.m_szLineColor==szColorBlack)
      crLineColor=COLOR_BLACK;
   else
      if (dlg.m_szLineColor==szColorWhite)
         crLineColor=COLOR_WHITE;
      else
      if (dlg.m_szLineColor==szColorLTGRAY)
         crLineColor=COLOR_LTGRAY;
      else
      if (dlg.m_szLineColor==szColorMDGRAY)
         crLineColor=COLOR_MDGRAY;
      else
      if (dlg.m_szLineColor==szColorDKGRAY)
         crLineColor=COLOR_DKGRAY;
      else
         crLineColor=COLOR_BLACK;

   COLORREF crTextColor;
   if (dlg.m_szTextColor==szColorBlack)
      crTextColor=COLOR_BLACK;
   else
      if (dlg.m_szTextColor==szColorWhite)
         crTextColor=COLOR_WHITE;
      else
      if (dlg.m_szTextColor==szColorLTGRAY)
         crTextColor=COLOR_LTGRAY;
      else
      if (dlg.m_szTextColor==szColorMDGRAY)
         crTextColor=COLOR_MDGRAY;
      else
      if (dlg.m_szTextColor==szColorDKGRAY)
         crTextColor=COLOR_DKGRAY;
      else
         crTextColor=COLOR_BLACK;

   long lPointSize = _ttol(dlg.m_szThickness);   //integrity check for line thickness
   if (lPointSize < 0)
      lPointSize=1;
   else
      if (lPointSize==0) {
         dlg.m_bCBDrawBorder=FALSE;
             lPointSize=1;
      }
      else
             if (lPointSize>72)
                lPointSize=72;

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
      CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
          pObj->Invalidate();
      pObj->m_bPen=dlg.m_bCBDrawBorder;
      pObj->m_bBrush=dlg.m_bRBFillColor;
          long nPS=lPointSize*100/72;
      pObj->m_lLinePointSize=lPointSize;

      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawLine))) {     //this correct line m_position for chgs in thickness
             CDrawLine* pLineObj = (CDrawLine*)pObj;
         CRect rc = pLineObj->m_position;
                 pLineObj->AdjustLineForPen(rc);
         pLineObj->m_logpen.lopnWidth.y=pLineObj->m_logpen.lopnWidth.x=nPS;
                 pLineObj->NegAdjustLineForPen(rc);
                 pLineObj->m_position=rc;
      }
          else
         pObj->m_logpen.lopnWidth.y=pObj->m_logpen.lopnWidth.x=nPS;

      pObj->m_logpen.lopnColor = crLineColor;
      pObj->m_logbrush.lbColor = crFillColor;
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
              ((CDrawText*)pObj)->m_crTextColor = crTextColor;
              ((CDrawText*)pObj)->FitEditWnd(this);
              ((CDrawText*)pObj)->NewBrush();
      }
          pObj->Invalidate();
   }

   m_pDocument->SetModifiedFlag();
}

//-------------------------------------------------------------------------
void CDrawView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
   CDrawDoc* pDoc = GetDocument();
   CObList* pObjects = pDoc->GetObjects();
   if (!pObjects) {
      CScrollView::OnChar(nChar,nRepCnt,nFlags);
      return;
   }

   POSITION pos;
   CDrawObj* pObj;

   if (nChar == VK_TAB && (m_selection.GetCount()==1 || m_pObjInEdit)
             && pObjects->GetCount() > 1 ) {
      if (m_pObjInEdit)
             pos = pObjects->Find(m_pObjInEdit);
      else {
             pObj = (CDrawObj*)m_selection.GetHead();
             pos = pObjects->Find(pObj);
      }

      BOOL bShift = ::GetKeyState(VK_SHIFT) & 0x8000;

      if (bShift)
            pObjects->GetPrev(pos);
      else
            pObjects->GetNext(pos);

      if (pos==NULL)
             if (bShift)
               pObj=(CDrawObj*)pObjects->GetTail();
             else
               pObj=(CDrawObj*)pObjects->GetHead();
      else
             pObj=(CDrawObj*)pObjects->GetAt(pos);

      Select(NULL);
      Select(pObj);
          UpdateStatusBar();
          UpdateStyleBar();
      pDoc->SetModifiedFlag();
   }
   else
      if (m_pObjInEdit && pObjects->GetCount()==1) {
             CDrawObj* p = m_pObjInEdit;
         Select(NULL);
             Select(m_pObjInEdit);
             UpdateStatusBar();
             UpdateStyleBar();
          }
      else
           CScrollView::OnChar(nChar,nRepCnt,nFlags);
}


void CDrawView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
        switch (nChar) {

                case VK_LEFT:
                case VK_RIGHT:
                case VK_UP:
                case VK_DOWN:
           if (m_selection.GetCount() >=1 &&  m_pObjInEdit==NULL) {
              CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
              if (pTool != NULL)
                 pTool->OnArrowKey(this, nChar, nRepCnt, nFlags);
           }
           break;

                case VK_SHIFT:
                        if (m_bKU) {
                       m_bShiftSignal=TRUE;
                       m_bKU=FALSE;
                        }
                        break;
        }

    CScrollView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CDrawView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
        switch (nChar) {
                case VK_SHIFT:
                    m_bKU=TRUE;
                        break;
        }

    CScrollView::OnKeyUp(nChar, nRepCnt, nFlags);
}


//-------------------------------------------------------------------------
void CDrawView::OnEditChange()
{
   m_pDocument->SetModifiedFlag();
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
   BOOL bEnable = m_selection.GetCount() >= 1 && CDrawTool::c_drawShape == select;
   if (bEnable) {
        bEnable=FALSE;
                POSITION pos = m_selection.GetHeadPosition();
                while (pos != NULL) {
                        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
                        if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj))) {
                            bEnable=TRUE;
                            break;
                        }
                }
   }

   pCmdUI->Enable(bEnable);
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateToList(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_TO_LIST ) ? TRUE : FALSE );
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateCcList(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_CC_LIST ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCompany(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_COMPANY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecAddress(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_STREET_ADDRESS ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCity(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_CITY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecState(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_STATE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecZipCode(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_ZIP_CODE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCountry(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_COUNTRY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecTitle(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_TITLE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecDept(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_DEPARTMENT ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecOfficeLoc(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_OFFICE_LOCATION ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecHomePhone(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_HOME_PHONE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecOfficePhone(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_OFFICE_PHONE ) ? TRUE : FALSE );
}

//-------------------------------------------------------------------------
void CDrawView::OnFilePrintPreview()
{
   CScrollView::OnFilePrintPreview();
}


/////////////////////////////////////////////////////////////////////////////
// CDrawView diagnostics

#ifdef _DEBUG
void CDrawView::AssertValid() const
{
        CScrollView::AssertValid();
}

void CDrawView::Dump(CDumpContext& dc) const
{
        CScrollView::Dump(dc);
}
#endif //_DEBUG





//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawView, CScrollView)
   //{{AFX_MSG_MAP(CDrawView)
   ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
   ON_COMMAND(ID_CANCEL_EDIT, OnCancelEdit)
   ON_WM_RBUTTONDOWN()
   ON_WM_LBUTTONDOWN()
   ON_WM_KEYDOWN()
   ON_WM_KEYUP()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_WM_LBUTTONDBLCLK()
   ON_EN_CHANGE(ID_TEXT, OnEditChange)
   ON_COMMAND(ID_MAPI_RECIP_NAME, OnMAPIRecipName)
   ON_COMMAND(ID_MAPI_RECIP_FAXNUM, OnMAPIRecipFaxNum)
   ON_COMMAND(ID_MAPI_RECIP_COMPANY, OnMAPIRecipCompany)
   ON_COMMAND(ID_MAPI_RECIP_ADDRESS, OnMAPIRecipAddress)
   ON_COMMAND(ID_MAPI_RECIP_CITY, OnMAPIRecipCity)
   ON_COMMAND(ID_MAPI_RECIP_STATE, OnMAPIRecipState)
   ON_COMMAND(ID_MAPI_RECIP_POBOX, OnMAPIRecipPOBox)
   ON_COMMAND(ID_MAPI_RECIP_ZIPCODE, OnMAPIRecipZipCode)
   ON_COMMAND(ID_MAPI_RECIP_COUNTRY, OnMAPIRecipCountry)
   ON_COMMAND(ID_MAPI_RECIP_TITLE, OnMAPIRecipTitle)
   ON_COMMAND(ID_MAPI_RECIP_DEPT, OnMAPIRecipDept)
   ON_COMMAND(ID_MAPI_RECIP_OFFICELOC, OnMAPIRecipOfficeLoc)
   ON_COMMAND(ID_MAPI_RECIP_HMTELENUM, OnMAPIRecipHMTeleNum)
   ON_COMMAND(ID_MAPI_RECIP_OFTELENUM, OnMAPIRecipOFTeleNum)
   ON_COMMAND(ID_MAPI_RECIP_TOLIST, OnMAPIRecipToList)
   ON_COMMAND(ID_MAPI_RECIP_CCLIST, OnMAPIRecipCCList)
   ON_COMMAND(ID_MAPI_SENDER_NAME, OnMAPISenderName)
   ON_COMMAND(ID_MAPI_SENDER_FAXNUM, OnMAPISenderFaxNum)
   ON_COMMAND(ID_MAPI_SENDER_COMPANY, OnMAPISenderCompany)
   ON_COMMAND(ID_MAPI_SENDER_ADDRESS, OnMAPISenderAddress)
   ON_COMMAND(ID_MAPI_SENDER_TITLE, OnMAPISenderTitle)
   ON_COMMAND(ID_MAPI_SENDER_DEPT, OnMAPISenderDept)
   ON_COMMAND(ID_MAPI_SENDER_OFFICELOC, OnMAPISenderOfficeLoc)
   ON_COMMAND(ID_MAPI_SENDER_HMTELENUM, OnMAPISenderHMTeleNum)
   ON_COMMAND(ID_MAPI_SENDER_OFTELENUM, OnMAPISenderOFTeleNum)
   ON_COMMAND(ID_MAPI_MSG_SUBJECT, OnMAPIMsgSubject)
   ON_COMMAND(ID_MAPI_MSG_TIMESENT, OnMAPIMsgTimeSent)
   ON_COMMAND(ID_MAPI_MSG_NUMPAGES, OnMAPIMsgNumPages)
   ON_COMMAND(ID_MAPI_MSG_ATTACH, OnMAPIMsgAttach)
   ON_COMMAND(ID_MAPI_MSG_BILLCODE, OnMAPIMsgBillCode)
   ON_COMMAND(ID_MAPI_MSG_FAXTEXT, OnMAPIMsgFaxText)
   ON_COMMAND(ID_FONT, OnFont)
   ON_COMMAND(ID_DRAW_SELECT, OnDrawSelect)
   ON_COMMAND(ID_DRAW_ROUNDRECT, OnDrawRoundRect)
   ON_COMMAND(ID_DRAW_RECT, OnDrawRect)
   ON_COMMAND(ID_DRAW_TEXT, OnDrawText)
   ON_COMMAND(ID_DRAW_LINE, OnDrawLine)
   ON_COMMAND(ID_DRAW_ELLIPSE, OnDrawEllipse)
   ON_CBN_EDITCHANGE(ID_FONT_NAME, OnEditChangeFont)
   ON_CBN_SELENDOK(ID_FONT_SIZE, OnSelEndOKFontSize)
   ON_COMMAND(ID_STYLE_BOLD, OnStyleBold)
   ON_COMMAND(ID_STYLE_ITALIC, OnStyleItalic)
   ON_COMMAND(ID_STYLE_UNDERLINE, OnStyleUnderline)
   ON_COMMAND(ID_STYLE_LEFT, OnStyleLeft)
   ON_COMMAND(ID_STYLE_CENTERED, OnStyleCentered)
   ON_COMMAND(ID_STYLE_RIGHT, OnStyleRight)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POS1, OnUpdatePosStatusBar)
   ON_UPDATE_COMMAND_UI(ID_DRAW_ELLIPSE, OnUpdateDrawEllipse)
   ON_UPDATE_COMMAND_UI(ID_DRAW_LINE, OnUpdateDrawLine)
   ON_UPDATE_COMMAND_UI(ID_DRAW_RECT, OnUpdateDrawRect)
   ON_UPDATE_COMMAND_UI(ID_DRAW_TEXT, OnUpdateDrawText)
   ON_UPDATE_COMMAND_UI(ID_DRAW_ROUNDRECT, OnUpdateDrawRoundRect)
   ON_UPDATE_COMMAND_UI(ID_DRAW_SELECT, OnUpdateDrawSelect)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_CENTERWIDTH, OnUpdateMoreThanOne)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVEBACK, OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_MAPI_MSG_FAXTEXT, OnUpdateFaxText)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNLEFT, OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_SPACEACROSS, OnUpdateAlign3)
   ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
   ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
   ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
   ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateAnySelect)
   ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
   ON_COMMAND(ID_DRAW_POLYGON, OnDrawPolygon)
   ON_UPDATE_COMMAND_UI(ID_DRAW_POLYGON, OnUpdateDrawPolygon)
   ON_WM_SIZE()
   ON_COMMAND(ID_LAYOUT_ALIGNLEFT, OnAlignLeft)
   ON_COMMAND(ID_LAYOUT_ALIGNRIGHT, OnAlignRight)
   ON_COMMAND(ID_LAYOUT_ALIGNTOP, OnAlignTop)
   ON_COMMAND(ID_LAYOUT_ALIGNBOTTOM, OnAlignBottom)
   ON_COMMAND(ID_LAYOUT_ALIGNHORZCENTER, OnAlignHorzCenter)
   ON_COMMAND(ID_LAYOUT_ALIGNVERTCENTER, OnAlignVertCenter)
   ON_COMMAND(ID_LAYOUT_SPACEACROSS, OnSpaceAcross)
   ON_COMMAND(ID_LAYOUT_SPACEDOWN, OnSpaceDown)
   ON_COMMAND(ID_LAYOUT_CENTERWIDTH, OnCenterWidth)
   ON_COMMAND(ID_LAYOUT_CENTERHEIGHT, OnCenterHeight)
   ON_COMMAND(ID_VIEW_GRIDLINES, OnViewGridLines)
   ON_UPDATE_COMMAND_UI(ID_VIEW_GRIDLINES, OnUpdateViewGridLines)
   ON_UPDATE_COMMAND_UI(ID_FONT_NAME,  OnUpdateFont)
   ON_WM_ERASEBKGND()
   ON_COMMAND(ID_OBJECT_MOVEBACK, OnObjectMoveBack)
   ON_COMMAND(ID_OBJECT_MOVEFORWARD, OnObjectMoveForward)
   ON_COMMAND(ID_OBJECT_MOVETOBACK, OnObjectMoveToBack)
   ON_COMMAND(ID_OBJECT_MOVETOFRONT, OnObjectMoveToFront)
   ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
   ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
   ON_COMMAND(ID_EDIT_CUT, OnEditCut)
   ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
   ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
   ON_WM_SETFOCUS()
   ON_COMMAND(ID_VIEW_SHOWOBJECTS, OnViewShowObjects)
   ON_UPDATE_COMMAND_UI(ID_VIEW_SHOWOBJECTS, OnUpdateViewShowObjects)
   ON_COMMAND(ID_EDIT_PROPERTIES, OnEditProperties)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PROPERTIES, OnUpdateEditProperties)
   ON_WM_DESTROY()
   ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
   ON_CBN_EDITCHANGE(ID_FONT_SIZE, OnEditChangeFont)
   ON_CBN_SELCHANGE(ID_FONT_NAME, OnSelchangeFontName)
   ON_CBN_SELCHANGE(ID_FONT_SIZE, OnSelchangeFontSize)
   ON_UPDATE_COMMAND_UI(ID_FONT_SIZE, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVEFORWARD, OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVETOBACK, OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVETOFRONT, OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_FONT_NAME, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_FONT_SIZE, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_BOLD, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_ITALIC, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_UNDERLINE, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_LEFT, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_CENTERED, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_RIGHT, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_FONT, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNRIGHT, OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNTOP, OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNBOTTOM, OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNHORZCENTER, OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNVERTCENTER, OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_SPACEDOWN, OnUpdateAlign3)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_CENTERHEIGHT, OnUpdateMoreThanOne)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POS2, OnUpdatePosStatusBar)
//
// Enable or disable menu for fax property fields depending on a registry key.   a-juliar
//
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_TOLIST, OnUpdateToList)
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_CCLIST, OnUpdateCcList)
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_COMPANY , OnUpdateRecCompany )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_ADDRESS , OnUpdateRecAddress )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_CITY , OnUpdateRecCity )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_STATE , OnUpdateRecState )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_ZIPCODE , OnUpdateRecZipCode )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_COUNTRY , OnUpdateRecCountry )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_TITLE , OnUpdateRecTitle )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_DEPT , OnUpdateRecDept )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_OFFICELOC , OnUpdateRecOfficeLoc )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_HMTELENUM , OnUpdateRecHomePhone )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_OFTELENUM , OnUpdateRecOfficePhone )
   ON_WM_CHAR()
   ON_COMMAND(ID_STYLE_LEFT, OnStyleLeft)
   ON_COMMAND(ID_STYLE_CENTERED, OnStyleCentered)
   ON_COMMAND(ID_STYLE_RIGHT, OnStyleRight)
        ON_COMMAND(ID_MAPI_MSG_NOTE, OnMapiMsgNote)
        //}}AFX_MSG_MAP
   // Standard printing commands
#ifdef GRID
   ON_UPDATE_COMMAND_UI(ID_SNAP_TO_GRID, OnUpdateSnapToGrid)
   ON_UPDATE_COMMAND_UI(ID_GRID_SETTINGS, OnUpdateGridSettings)
   ON_COMMAND(ID_SNAP_TO_GRID, OnSnapToGrid)
   ON_COMMAND(ID_GRID_SETTINGS, OnGridSettings)
   ON_COMMAND(ID_VIEW_GRID, OnViewGrid)
#endif
   ON_WM_CREATE()
   ON_WM_CTLCOLOR()
   ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
   ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\faxprop.cpp ===
//---------------------------------------------------------------------------
// faxprop.cpp -
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains dictionary for fax properties for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 3/8/95       Added stuff for handling notes on cpe
// 3/21/95      Added stuff for updating pages-sent property with notes
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#define PROP_LENGTH_ADJUSTMENT 7  // 4 wasn't enough.  Needed because some characters are wider than average.

CMapWordToPtr CFaxPropMap::m_PropMap;


CProp::CProp(
    WORD wR_PROP,
    WORD wPropDefLen,
    WORD wPropDefLines,
    WORD wR_CAPT,
    ULONG lPropIndex
    ) : m_lPropIndex(lPropIndex)
{
    m_wR_PROP=wR_PROP;
    m_szPropName.LoadString(wR_PROP);
    m_wR_CAPT=wR_CAPT;
    m_szCaption.LoadString(wR_CAPT);
    //
    // m_wPropDefLen must exceed # of chars in m_szPropName in ALL LANGUAGES. a-juliar, 9-10-96
    //
    int StringLength = max( 0, m_szPropName.GetLength() + PROP_LENGTH_ADJUSTMENT ) ;
    m_wPropDefLen = max( (WORD)StringLength, wPropDefLen ) ;
    m_wPropDefLines=wPropDefLines;

    CFaxPropMap::m_PropMap[m_wR_PROP]=this;
}


//----------------------------------------------------------------------------
void CFaxPropMap::GetCaption(WORD propid, CString& szCaption)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetCaption:  property not found\n"));
      return;
   }

   szCaption = ((CProp*)pProp)->m_szCaption;
}


//----------------------------------------------------------------------------
//used to retrieve either a value or the property name
//----------------------------------------------------------------------------
void CFaxPropMap::GetPropString(WORD propid, CString& szPropValue)
{
   SCODE sc;
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      szPropValue = _T("");
      TRACE(TEXT("AWCPE.FAXPROP.GetPropString:  property id not found in table\n"));
      return;
   }

   CProp* pCProp=(CProp*)pProp;
   if (pCProp==NULL) {
       TRACE(TEXT("AWCPE.FAXPROP.GetPropString:  property key not found in dictionary\n"));
       szPropValue=_T("");
       return;
   }

   if ( (theApp.m_dwSesID!=0) && theApp.m_pIawcpe ) {
       ULONG temp= pCProp->m_wPropDefLines*pCProp->m_wPropDefLen + 1;
           ULONG lLen=0;
           WORD wtemp;

        if( propid == IDS_PROP_MS_NOTE )
                        {
                        szPropValue = _T("");
                        get_message_note();
                        return;
                        }

       if (propid!=IDS_PROP_MS_NOPG) {
          sc = theApp.m_pIawcpe->GetProp(pCProp->m_lPropIndex, &lLen, NULL);    //get length of property
          if (sc != S_OK) {
             TRACE(TEXT("AWCPE: GetPropString--unable to fetch length; GetProp != S_OK(%lx); prop:'%#8x'"),sc,pCProp->m_lPropIndex);
             TRACE1("; caption: '%s'",pCProp->m_szCaption);
                 TRACE1("; defaulting to length: '%i'\n",temp);
                 lLen=temp;
              }
          else
             if (lLen<=0 || lLen>10*temp) {
                    TRACE1("AWCPE: GetPropString--unreasonable length from GetProp(), prop: '%#8x'",pCProp->m_lPropIndex);
                TRACE1("; caption: '%s'",pCProp->m_szCaption);
                TRACE1("; fetched: '%i'",lLen);
                    TRACE1("; defaulting to length: '%i'\n",temp);
                    lLen=temp;
                 }
           }
       else {
              lLen=10;
           }

       LPTSTR BASED_CODE szTemp = ::new TCHAR[lLen];

       if( propid == IDS_PROP_MS_NOPG )
                {
                // IDS_PROP_MS_NOPG does not count the coverpage
                sc = theApp.m_pIawcpe->
                                GetProp(pCProp->m_lPropIndex, &lLen, (void*)&wtemp);

                wtemp += 1; // count the cover page
                wsprintf(szTemp,TEXT("%i"), wtemp );
                }
           else
        {
          sc = theApp.m_pIawcpe->GetProp(pCProp->m_lPropIndex, &lLen, szTemp);
                }

       if (sc !=S_OK) {    //failed to get property from transport interface
          szPropValue = _T("");
              TRACE1("AWCPE: GetPropString--unable to fetch value (prop:'%#8x')",pCProp->m_lPropIndex);
          TRACE(TEXT("; GetProp != S_OK; defaulting to blank property\n"));
       }
           else {
           szPropValue = szTemp;
           TRACE1("AWCPE: (%i",propid);
           TRACE1(",%#8x)\t",pCProp->m_lPropIndex);
           TRACE1("caption: '%s'\t",pCProp->m_szCaption);
               TRACE1("value: '%s'\n",szPropValue);
           }

           if (szTemp!=NULL)
              ::delete [] szTemp;
   }
   else {
       szPropValue = pCProp->m_szPropName;
   }

}


//----------------------------------------------------------------------------
WORD CFaxPropMap::GetPropDefLines(WORD propid)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetNumLines:  property not found\n"));
      return 0;
   }

   return ((CProp*)pProp)->m_wPropDefLines;
}


//----------------------------------------------------------------------------
WORD CFaxPropMap::GetPropDefLength(WORD propid)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetPropLength:  property not found\n"));
      return 0;
   }

   return ((CProp*)pProp)->m_wPropDefLen;
}




//----------------------------------------------------------------------------
void  CFaxPropMap::get_message_note( void )
        {

        if( !theApp.m_note_wasread )
                theApp.read_note();


        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpevw.h ===
//--------------------------------------------------------------------------
// cpevw.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEVW_H__
#define __CPEVW_H__


// Hints for UpdateAllViews/OnUpdate
#define HINT_UPDATE_WINDOW      0
#define HINT_UPDATE_DRAWOBJ     1
#define HINT_UPDATE_SELECTION   2
#define HINT_DELETE_SELECTION   3
#define HINT_UPDATE_OLE_ITEMS   4


class CDrawObj;
class CDrawText;
class CDrawApp;
class CDrawDoc;
class CMainFrame;

typedef enum {GRID_SMALL=10,GRID_MEDIUM=20,GRID_LARGE=50} eGridSize;     //grid sizes, in LU

class CSortedObList : public CObList
{
public:
   CSortedObList() {};
   CSortedObList& operator=(CObList&);
   void SortToLeft();
   void SortToBottom();
private:
   void swap(unsigned int i, unsigned int j);
};


class CDrawView : public CScrollView
{
public:
    BOOL m_bShiftSignal;
    BOOL m_bKU;
    CPen m_penDot;
    CPen m_penSolid;
    BOOL m_bFontChg;
    CDrawText* m_pObjInEdit;

protected:
    BOOL m_bCanUndo ;
public:
    BOOL CanUndo() { return m_bCanUndo ; }
    void DisableUndo(){ m_bCanUndo = FALSE ; }
    void SaveStateForUndo();
    static void FreeObjectsMemory( CObList * pObList );

    HBRUSH m_brush;

    CMainFrame* GetFrame() {return ((CMainFrame*)AfxGetMainWnd());}
    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
    static CDrawView* GetView();
    CDrawDoc* GetDocument() { return (CDrawDoc*)m_pDocument; }
    void SetPageSize(CSize size);
    CRect GetInitialPosition();
    void DoPrepareDC(CDC* pDC);
    void TrackObjectMenu(CPoint&);
    void TrackViewMenu(CPoint&);
    void NormalizeObjs();

    void DocToClient(CRect& rect, CDC* pDC=NULL);
    void DocToClient(CPoint& point, CDC* pDC=NULL);
    void ClientToDoc(CPoint& point, CDC* pDC=NULL);
    void ClientToDoc(CRect& rect, CDC* pDC=NULL);

    void Select(CDrawObj* pObj, BOOL bShift = FALSE, BOOL bCheckEdit=TRUE);
    void SelectWithinRect(CRect rect, BOOL bAdd = FALSE);
    void Deselect(CDrawObj* pObj);
    void CloneSelection();
    void CreateFaxProp(WORD wResourceid);
    void CreateFaxText();
    void FindLocation(CRect& objrect);
    void UpdateActiveItem();
    void Remove(CDrawObj* pObj);
    void PasteNative(COleDataObject& dataObject);
    void PasteEmbedded(COleDataObject& dataObject);

    virtual ~CDrawView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    void UpdateStatusBar();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    void DrawGrid(CDC* pDC);

    static CLIPFORMAT m_cfDraw; // custom clipboard format

    CObList m_selection;
    BOOL m_bGridLines;
    BOOL m_bActive; // is the view active?

protected:
    CDrawView();
    BOOL m_bBold;
    BOOL m_bItalic;
    BOOL m_bUnderline;
    DWORD m_dwEfcFields ;

    DECLARE_DYNCREATE(CDrawView)
    virtual void OnInitialUpdate(); // called first time after construct
    int GetPointSize(CDrawText&);
    CSize ComputeScrollSize(CSize size) ;
    void CheckStyleBar(BOOL, BOOL, BOOL, BOOL, BOOL, BOOL);
    void NormalizeRect(CRect& rc);
    void UpdateStyleBar(CObList* pObList=NULL,CDrawText* p=NULL);

        // Printing support

    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

        // OLE Container support
public:
    afx_msg void OnChar(UINT, UINT, UINT);
    virtual BOOL IsSelected(const CObject* pDocItem) const;
    afx_msg void OnSelchangeFontName();
    afx_msg void OnSelchangeFontSize();

    void OnSelChangeFontName(CObList* pObList=NULL,CDrawText* p=NULL);
    void OnSelChangeFontSize(CObList* pObList=NULL,CDrawText* p=NULL);

    void make_extranote( CDC *pdc );
    //void make_extranote_and_count_pages( BOOL do_transform );

// Generated message map functions
protected:
    void ChgTextAlignment(LONG lstyle);

    //{{AFX_MSG(CDrawView)

    afx_msg void OnInsertObject();
    afx_msg void OnCancelEdit();
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnFilePrintPreview();
    afx_msg void OnEditChange();
    afx_msg void OnMAPIRecipName();
    afx_msg void OnMAPIRecipFaxNum();
    afx_msg void OnMAPIRecipCompany();
    afx_msg void OnMAPIRecipAddress();
    afx_msg void OnMAPIRecipCity();
    afx_msg void OnMAPIRecipState();
    afx_msg void OnMAPIRecipPOBox();
    afx_msg void OnMAPIRecipZipCode();
    afx_msg void OnMAPIRecipCountry();
    afx_msg void OnMAPIRecipTitle();
    afx_msg void OnMAPIRecipDept();
    afx_msg void OnMAPIRecipOfficeLoc();
    afx_msg void OnMAPIRecipHMTeleNum();
    afx_msg void OnMAPIRecipOFTeleNum();
    afx_msg void OnMAPIRecipToList();
    afx_msg void OnMAPIRecipCCList();
    afx_msg void OnMAPISenderName();
    afx_msg void OnMAPISenderFaxNum();
    afx_msg void OnMAPISenderCompany();
    afx_msg void OnMAPISenderAddress();
    afx_msg void OnMAPISenderTitle();
    afx_msg void OnMAPISenderDept();
    afx_msg void OnMAPISenderOfficeLoc();
    afx_msg void OnMAPISenderHMTeleNum();
    afx_msg void OnMAPISenderOFTeleNum();
    afx_msg void OnMAPIMsgSubject();
    afx_msg void OnMAPIMsgTimeSent();
    afx_msg void OnMAPIMsgNumPages();
    afx_msg void OnMAPIMsgAttach();
    afx_msg void OnMAPIMsgBillCode();
    afx_msg void OnMAPIMsgFaxText();
    afx_msg void OnFont();
    afx_msg void OnDrawSelect();
    afx_msg void OnDrawRoundRect();
    afx_msg void OnDrawRect();
    afx_msg void OnDrawText();
    afx_msg void OnDrawLine();
    afx_msg void OnDrawEllipse();
    afx_msg void OnEditChangeFont();
    afx_msg void OnSelEndOKFontSize();
    afx_msg void OnStyleBold();
    afx_msg void OnStyleItalic();
    afx_msg void OnStyleUnderline();
    afx_msg void OnStyleLeft();
    afx_msg void OnStyleCentered();
    afx_msg void OnStyleRight();
    afx_msg void OnUpdatePosStatusBar(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawEllipse(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawLine(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawRect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawRoundRect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawSelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSingleSelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoreThanOne(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMove(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFaxText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateAlign(CCmdUI* pCmdUI);
    afx_msg void OnUpdateAlign3(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnEditClear();
    afx_msg void OnEditUndo();
    afx_msg void OnUpdateAnySelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnDrawPolygon();
    afx_msg void OnUpdateDrawPolygon(CCmdUI* pCmdUI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnAlignLeft();
    afx_msg void OnAlignRight();
    afx_msg void OnAlignTop();
    afx_msg void OnAlignBottom();
    afx_msg void OnAlignHorzCenter();
    afx_msg void OnAlignVertCenter();
    afx_msg void OnSpaceAcross();
    afx_msg void OnSpaceDown();
    afx_msg void OnCenterWidth();
    afx_msg void OnCenterHeight();
    afx_msg void OnViewGridLines();
    afx_msg void OnUpdateViewGridLines(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFont(CCmdUI* pCmdUI);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnObjectMoveBack();
    afx_msg void OnObjectMoveForward();
    afx_msg void OnObjectMoveToBack();
    afx_msg void OnObjectMoveToFront();
    afx_msg void OnViewPaperColor();
    afx_msg void OnDrawBitmap();
    afx_msg void OnUpdateDrawBitmap(CCmdUI* pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnEditCut();
    afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnFilePrint();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnViewShowObjects();
    afx_msg void OnUpdateViewShowObjects(CCmdUI* pCmdUI);
    afx_msg void OnEditProperties();
    afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
    afx_msg void OnDestroy();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnMapiMsgNote();
    afx_msg void OnUpdateToList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateCcList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCompany(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecAddress(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCity(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecState(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecZipCode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCountry(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecTitle(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecDept(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecOfficeLoc(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecHomePhone(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecOfficePhone(CCmdUI* pCmdUI);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


#endif //#ifndef __CPEVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\cpetool.h ===
//--------------------------------------------------------------------------
// CPETOOL.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPETOOL_H__
#define __CPETOOL_H__


#include "cpeobj.h"


class CDrawView;

enum DrawShape
{
	select,
	line,
	rect,
	text,
	faxprop,
	roundRect,
	ellipse,
	poly
};

class CDrawTool
{
// Constructors
public:
	CDrawTool(DrawShape nDrawShape);

// Overridables
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnArrowKey(CDrawView* pView, UINT, UINT, UINT) {};
	virtual void OnCancel();

// Attributes
	DrawShape m_drawShape;

	static CDrawTool* FindTool(DrawShape drawShape);
	static CPtrList c_tools;
	static CPoint c_down;
	static UINT c_nDownFlags;
	static CPoint c_last;
	static DrawShape c_drawShape;
    BOOL m_bMoveCurSet;
};

class CSelectTool : public CDrawTool
{
public:
   BOOL m_bClicktoMove;
   BOOL m_bSnapped;
   CPoint m_snappoint;

	CSelectTool();

	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnArrowKey(CDrawView* pView, UINT, UINT, UINT);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
protected:
#ifdef GRID
   void CheckSnapSelObj(CDrawView*);
   int NearestGridPoint(CDrawView*, CPoint&,CPoint&);
#endif
   void AdjustSelObj(CDrawView*, int, int);
};

class CRectTool : public CDrawTool
{
// Constructors
public:
	CRectTool(DrawShape drawShape);

// Implementation
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
};

class CPolyTool : public CDrawTool
{
// Constructors
public:
	CPolyTool();

// Implementation
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnCancel();

	CDrawPoly* m_pDrawObj;
};

////////////////////////////////////////////////////////////////////////////

#endif // __CPETOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\dialogs.h ===
//=========================================================================
// DIALOGS.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//=========================================================================
//
// Modified by a-juliar to fix NT bug 49528.
//
#ifndef __DIALOGS_H__
#define __DIALOGS_H__

///#ifndef ENABLE_HELP
///#define ENABLE_HELP
///#endif

//------------------------------------------------------------------------
// CPE error message codes
//
// 001 - 299 information
// 300 - 499 error
// >= 500    critical
//------------------------------------------------------------------------
#define MSG_INFO_DRAWPOLY              001
#define MSG_INFO_NOFAXPROP             002
#define MSG_ERROR_INVFORMAT            300
#define MSG_ERROR_OLEINIT_FAILED       301
#define MSG_ERROR_OLE_FAILED_TO_CREATE 302
#define MSG_ERROR_MISSINGFILE          303
#define MSG_ERROR_NOPAGESETUPDLL       304
#define MSG_ERROR_NOPAGESETUP          305

int CPEMessageBox(int errorcode, LPCTSTR sz, UINT nType=MB_OK, int msgid=-1);


class CDrawView;

//---------------------------------------------------------------------------
// CObjPropDlg dialog
//---------------------------------------------------------------------------
class CObjPropDlg : public CDialog
{
public:
   BOOL m_bCBDrawBorder;
   BOOL m_bRBFillColor;
   BOOL m_bRBFillTrans;
   CString m_szThickness;
   CString m_szLineColor;
   CString m_szFillColor;
   CString m_szTextColor;
        CObjPropDlg(CWnd* pParent = NULL); // standard constructor

        //{{AFX_DATA(CObjPropDlg)
        enum { IDD = IDD_OBJ_PROP};
        //}}AFX_DATA

protected:
   CDrawView* m_pView;

        afx_msg void OnSelChangeFillColor();
    BOOL OnInitDialog();
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        CButton& GetRBFillColor() { return *(CButton*)GetDlgItem(IDC_RB_FILLCOLOR); }
        CButton& GetRBFillTrans() { return *(CButton*)GetDlgItem(IDC_RB_FILLTRANS); }
        CComboBox& GetLBThickness() { return *(CComboBox*)GetDlgItem(IDC_LB_THICKNESS); }
        CComboBox& GetLBLineColor() { return *(CComboBox*)GetDlgItem(IDC_LB_LINECOLOR); }
        CComboBox& GetLBFillColor() { return *(CComboBox*)GetDlgItem(IDC_LB_FILLCOLOR); }
        CWnd& GetGRPFillColor() { return *(CWnd*)GetDlgItem(IDC_GRP_FILLCOLOR); }
        CComboBox& GetLBTextColor() { return *(CComboBox*)GetDlgItem(IDC_LB_TEXTCOLOR); }
        CWnd& GetSTTextColor() { return *(CWnd*)GetDlgItem(IDC_ST_TEXTCOLOR); }

        //{{AFX_MSG(CObjPropDlg)
                // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG

        virtual void OnOK();

        CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

        afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
///#ifdef ENABLE_HELP
        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif

        DECLARE_MESSAGE_MAP()
};





//---------------------------------------------------------------------------
// CGridSettingsDlg dialog
//---------------------------------------------------------------------------
class CGridSettingsDlg : public CDialog
{
public:
        CGridSettingsDlg(CWnd* pParent = NULL); // standard constructor
   BOOL m_bRBSmall, m_bRBMedium, m_bRBLarge;
   BOOL m_bCBViewGrid, m_bCBSnapToGrid;

        //{{AFX_DATA(CGridSettingsDlg)
        enum { IDD = IDD_GRID_SETTINGS};
        //}}AFX_DATA

protected:
   CDrawView* m_pView;

   BOOL OnInitDialog();

        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

        //{{AFX_MSG(CGridSettingsDlg)
                // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG

        afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
///#ifdef ENABLE_HELP
        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        DECLARE_MESSAGE_MAP()
};



//--------------------------------------------------------------
class CBigIcon : public CButton
{
public:
        void SizeToContent();

protected:
        virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

        //{{AFX_MSG(CBigIcon)
        afx_msg BOOL OnEraseBkgnd(CDC* pDC);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};



//--------------------------------------------------------------
class CSplashTipsDlg : public CDialog
{
public:
    CFont m_tips_font;
    CFont m_tipstitle_font;
    int m_iCurrentTip;
        CSplashTipsDlg(CWnd* pParent = NULL);    // standard constructor
    BOOL OnInitDialog();

        //{{AFX_DATA(CSplashTipsDlg)
        enum { IDD = IDD_SPLASHTIPS };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA

protected:
    CButton* GetNextTip() {return (CButton*) GetDlgItem(IDC_B_NEXTTIP);};
    CButton* GetPrevTip() {return (CButton*) GetDlgItem(IDC_B_PREVTIP);};
    CButton* GetShowTips() {return (CButton*) GetDlgItem(IDC_CK_SHOWTIPS);};
    CEdit* GetTitle() {return (CEdit*) GetDlgItem(IDC_STA_TITLE);};
    CEdit* GetTips() {return (CEdit*) GetDlgItem(IDC_STA_TIP);};

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

        afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
        afx_msg void OnNextTip();
        afx_msg void OnPrevTip();
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual void OnOK();

        //{{AFX_MSG(CSplashTipsDlg)
        //}}AFX_MSG

        afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
///#ifdef ENABLE_HELP
///        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        DECLARE_MESSAGE_MAP()
};

//--------------------------------------------------------------------------------------
class CMyCommonDialog : public CCommonDialog
{
public:
        CMyCommonDialog( CWnd* pParentWnd );

protected:
        //{{AFX_MSG(CMyCommonDialog)        //////// I typed this, not the app wizard! a-juliar
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG

        DECLARE_MESSAGE_MAP()
};

class CMyOleInsertDialog : public COleInsertDialog
{
public:
    CMyOleInsertDialog( DWORD dwFlags = IOF_SELECTCREATENEW, CWnd* pParentWnd = NULL );

protected:
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

    DECLARE_MESSAGE_MAP()
};


typedef BOOL (APIENTRY *PPSD)(PAGESETUPDLG*);

class CMyPageSetupDialog : public CMyCommonDialog
{
public:
        CMyPageSetupDialog(CWnd* pParentWnd = NULL);
        ~CMyPageSetupDialog();
        PAGESETUPDLG m_psd;
        PPSD m_pPageSetupDlg;
        HINSTANCE m_hLib;

        virtual INT_PTR DoModal();
};

//--------------------------------------------------------------------------------------

class CMyPrintDlg : public CPrintDialog
{
        DECLARE_DYNAMIC(CMyPrintDlg)

public:
        CMyPrintDlg(BOOL bPrintSetupOnly,
                // TRUE for Print Setup, FALSE for Print Dialog
                DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
                        | PD_HIDEPRINTTOFILE | PD_NOSELECTION,
                CWnd* pParentWnd = NULL);

protected:
        //{{AFX_MSG(CMyPrintDlg)
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//---------------------------------------------------------------------------------------
class CMyFontDialog : public CFontDialog
{
public:
    CMyFontDialog(LPLOGFONT lplfInitial = NULL,
                  DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
                  CDC* pdcPrinter = NULL,
                  CWnd* pParentWnd = NULL);
protected:
    afx_msg BOOL OnHelpInfo( HELPINFO* pHelpInfo);
    DECLARE_MESSAGE_MAP()
};
//---------------------------------------------------------------------------------------
//
// Help Context ID's for the CObjPropDlg  "Line, Fill, and Color"
//

#define IDH_LB_FILLCOLOR        1140   // Line, Fill and Color: "" (ComboBox)
#define IDH_LB_TEXTCOLOR        1141   // Line, Fill and Color: "" (ComboBox)
#define IDH_GRP_FILLCOLOR       1142   // Line, Fill and Color: "Fill color" (Button)
#define IDH_LB_THICKNESS        1143   // Line, Fill and Color: "" (Edit)
#define IDH_CB_DRAWBORDER       1144   // Line, Fill and Color: "&Draw border/line" (Button)
#define IDH_LB_LINECOLOR        1145   // Line, Fill and Color: "" (ComboBox)
#define IDH_RB_FILLTRANS        1146   // Line, Fill and Color: "T&ransparent" (Button)
#define IDH_RB_FILLCOLOR        1147   // Line, Fill and Color: "C&olor" (Button)

extern const DWORD aHelpIDs[] ;       /// Defined in dialogs.cpp
extern const DWORD aOleDlgHelpIDs[] ; /// Defined in dialogs.cpp
#endif // #ifndef __DIALOGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\dialogs.cpp ===
//----------------------------------------------------------------------
// dialogs.cpp : implementation file
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains misc. dialogs for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modification:     a-juliar modified it to fix NT bug 49528  8/2/96
//----------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include <htmlhelp.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

WORD wStandardLineSizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 0 };

#define TOTAL_TIPS 11

//
// Help IDs for IDD_INSERTOBJECT (1000)
//
#define HIDC_IO_CREATENEW                       0x3E80834
#define HIDC_IO_CREATEFROMFILE                  0x3E80835
#define HIDC_IO_LINKFILE                        0x3E80836
#define HIDC_IO_OBJECTTYPELIST                  0x3E80837
#define HIDC_IO_DISPLAYASICON                   0x3E80838
#define HIDC_IO_CHANGEICON                      0x3E80839
#define HIDC_IO_FILE                            0x3E8083A
#define HIDC_IO_FILEDISPLAY                     0x3E8083B
#define HIDC_IO_RESULTIMAGE                     0x3E8083C
#define HIDC_IO_RESULTTEXT                      0x3E8083D
#define HIDC_IO_ICONDISPLAY                     0x3E8083E
#define HIDC_IO_FILETYPE                        0x3E80841
#define HIDC_IO_INSERTCONTROL                   0x3E80842
#define HIDC_IO_ADDCONTROL                      0x3E80843
#define HIDC_IO_CONTROLTYPELIST                 0x3E80844

const DWORD aOleDlgHelpIDs[]={
        IDC_IO_CREATENEW,       HIDC_IO_CREATENEW,
        IDC_IO_CREATEFROMFILE,  HIDC_IO_CREATEFROMFILE,
        IDC_IO_LINKFILE,        HIDC_IO_LINKFILE,
        IDC_IO_OBJECTTYPELIST,  HIDC_IO_OBJECTTYPELIST,
        IDC_IO_DISPLAYASICON,   HIDC_IO_DISPLAYASICON,
        IDC_IO_CHANGEICON,      HIDC_IO_CHANGEICON,
        IDC_IO_FILE,            HIDC_IO_FILE,
        IDC_IO_FILEDISPLAY,     HIDC_IO_FILEDISPLAY,
        IDC_IO_RESULTIMAGE,     HIDC_IO_RESULTIMAGE,
        IDC_IO_RESULTTEXT,      HIDC_IO_RESULTTEXT,
        IDC_IO_ICONDISPLAY,     HIDC_IO_ICONDISPLAY,
        IDC_IO_FILETYPE,        HIDC_IO_FILETYPE,
        IDC_IO_INSERTCONTROL,   HIDC_IO_INSERTCONTROL,
        IDC_IO_ADDCONTROL,      HIDC_IO_ADDCONTROL,
        IDC_IO_CONTROLTYPELIST, HIDC_IO_CONTROLTYPELIST,
        IDC_IO_OBJECTTYPETEXT,  HIDC_IO_OBJECTTYPELIST,
        IDC_IO_FILETEXT,        HIDC_IO_FILE,
        0,                      0
};

const DWORD aHelpIDs[]=
{
        IDC_LB_FILLCOLOR,       IDH_LB_FILLCOLOR,       // Line, Fill and Color: "" (ComboBox)
        IDC_LB_TEXTCOLOR,       IDH_LB_TEXTCOLOR,       // Line, Fill and Color: "" (ComboBox)
        IDC_ST_TEXTCOLOR,       IDH_LB_TEXTCOLOR,       // Line, Fill and Color: "Te&xt color:" (Static)
        IDC_GRP_FILLCOLOR,      IDH_GRP_FILLCOLOR,      // Line, Fill and Color: "Fill color" (Button)
        IDC_LB_THICKNESS,       IDH_LB_THICKNESS,       // Line, Fill and Color: "" (Edit)
        IDC_ST_THICKNESS,       IDH_LB_THICKNESS,       //
        IDC_CB_DRAWBORDER,      IDH_CB_DRAWBORDER,      // Line, Fill and Color: "&Draw border/line" (Button)
        IDC_LB_LINECOLOR,       IDH_LB_LINECOLOR,       // Line, Fill and Color: "" (ComboBox)
        IDC_ST_COLOR,           IDH_LB_LINECOLOR,       //
        IDC_RB_FILLTRANS,       IDH_RB_FILLTRANS,       // Line, Fill and Color: "T&ransparent" (Button)
        IDC_RB_FILLCOLOR,       IDH_RB_FILLCOLOR,       // Line, Fill and Color: "C&olor" (Button)
        0, 0
};


//------------------------------------------------------------------------
// CObjPropDlg dialog
//------------------------------------------------------------------------
CObjPropDlg::CObjPropDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CObjPropDlg::IDD, pParent)
{
}

//----------------------------------------------------------------------------
void CObjPropDlg::OnSelChangeFillColor()
{
    GetRBFillColor().SetCheck(1);
    GetRBFillTrans().SetCheck(0);
}

void CObjPropDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CObjPropDlg)
    DDX_Check(pDX, IDC_CB_DRAWBORDER, m_bCBDrawBorder);
    DDX_Check(pDX, IDC_RB_FILLCOLOR, m_bRBFillColor);
    DDX_Check(pDX, IDC_RB_FILLTRANS, m_bRBFillTrans);
    DDX_CBString(pDX, IDC_LB_THICKNESS, m_szThickness);
    DDX_CBString(pDX, IDC_LB_LINECOLOR, m_szLineColor);
    DDX_CBString(pDX, IDC_LB_FILLCOLOR, m_szFillColor);
    DDX_CBString(pDX, IDC_LB_TEXTCOLOR, m_szTextColor);
    // DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index);
        //}}AFX_DATA_MAP
}



LRESULT CObjPropDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{
    ::WinHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                        AfxGetApp()->m_pszHelpFilePath,
                        HELP_WM_HELP, /////////HELP_FINDER,
                        (DWORD_PTR)(LPSTR)aHelpIDs ) ; ///0);

    return 0;
}


///#ifdef ENABLE_HELP   /// Just Do It!
LRESULT CObjPropDlg::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
{
    ::WinHelp( (HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)aHelpIDs );

    return( 0 );
}
///#endif


//------------------------------------------------------------------------
BOOL CObjPropDlg::OnInitDialog()
{
   TCHAR szPointSize[4];
   for ( int i = 0 ; wStandardLineSizes[i] != 0 ; i++ ) {
      _itot ((int) wStandardLineSizes[i], szPointSize, 10);
      GetLBThickness().AddString(szPointSize);
   }

   CString szBLACK;
   szBLACK.LoadString(ID_COLOR_BLACK);
   CString szWHITE;
   szWHITE.LoadString(ID_COLOR_WHITE);
   CString szLTGRAY;
   szLTGRAY.LoadString(ID_COLOR_LTGRAY);
   CString szMDGRAY;
   szMDGRAY.LoadString(ID_COLOR_MDGRAY);
   CString szDKGRAY;
   szDKGRAY.LoadString(ID_COLOR_DKGRAY);

   GetLBLineColor().AddString(szBLACK);
   GetLBLineColor().AddString(szWHITE);
   GetLBLineColor().AddString(szLTGRAY);
   GetLBLineColor().AddString(szMDGRAY);
   GetLBLineColor().AddString(szDKGRAY);

   GetLBFillColor().AddString(szBLACK);
   GetLBFillColor().AddString(szWHITE);
   GetLBFillColor().AddString(szLTGRAY);
   GetLBFillColor().AddString(szMDGRAY);
   GetLBFillColor().AddString(szDKGRAY);

   GetLBTextColor().AddString(szBLACK);
   GetLBTextColor().AddString(szWHITE);
   GetLBTextColor().AddString(szLTGRAY);
   GetLBTextColor().AddString(szMDGRAY);
   GetLBTextColor().AddString(szDKGRAY);

   BOOL bFillObj=FALSE;
   BOOL bTextColor=TRUE;
   BOOL bFillColor=TRUE;
   BOOL bFillTrans=TRUE;
   BOOL bFillRGB=TRUE;
   BOOL bLineRGB=TRUE;
   BOOL bTextRGB=TRUE;
   BOOL bPen=TRUE;
   BOOL bPenThickness=TRUE;
   BOOL bBorder=TRUE;
   BOOL bTextObj=FALSE;
   BOOL bAllOleObjs=TRUE;
   int iSaveLinePointSize=0;
   COLORREF crSaveFillRGB=0;
   COLORREF crSaveLineRGB=0;
   COLORREF crSaveTextRGB=0;

   CDrawView* pView = CDrawView::GetView();
   if (!pView) {
      TRACE(TEXT("DIALOGS.CGRidSettingsDlg-view missing\n"));
      return FALSE;
   }

      //iterate thru selected objects for object properties
   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
       CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);

       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
          bTextObj=TRUE;

       if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawLine)))
          bFillObj=TRUE;

       if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
          bAllOleObjs=FALSE;

       if (iSaveLinePointSize !=0 && iSaveLinePointSize != pObj->m_lLinePointSize)
         bPenThickness=FALSE;
       if (crSaveFillRGB !=0 && crSaveFillRGB != pObj->m_logbrush.lbColor)
         bFillRGB=FALSE;
       if (crSaveLineRGB !=0 && crSaveLineRGB != pObj->m_logpen.lopnColor)
         bLineRGB=FALSE;
       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)) &&
           crSaveTextRGB !=0 && crSaveTextRGB != ((CDrawText*)pObj)->m_crTextColor)
         bTextRGB=FALSE;

       if (!pObj->m_bBrush)
          bFillColor=FALSE;
       if (pObj->m_bBrush)
          bFillTrans=FALSE;
       if (!pObj->m_bPen)
          bPen=FALSE;

       iSaveLinePointSize=pObj->m_lLinePointSize;
       crSaveFillRGB=pObj->m_logbrush.lbColor;
       crSaveLineRGB=pObj->m_logpen.lopnColor;
       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
          crSaveTextRGB=((CDrawText*)pObj)->m_crTextColor;
   }


    //load default point size
   if (bPenThickness) {
      _itot (iSaveLinePointSize, szPointSize, 10);
      m_szThickness=szPointSize;
   }
   else
      m_szThickness="";    //indeterminate state

   CString sz;
   if (bFillRGB) {  //Fill color listbox
      if (crSaveFillRGB==COLOR_BLACK)
         m_szFillColor=szBLACK;
      else
      if (crSaveFillRGB==COLOR_WHITE)
         m_szFillColor=szWHITE;
      else
      if (crSaveFillRGB==COLOR_LTGRAY)
         m_szFillColor=szLTGRAY;
      else
      if (crSaveFillRGB==COLOR_MDGRAY)
         m_szFillColor=szMDGRAY;
      else
      if (crSaveFillRGB==COLOR_DKGRAY)
         m_szFillColor=szDKGRAY;
      else
         m_szFillColor=szWHITE;
   }
   else
      m_szFillColor="";

   if (bLineRGB) { //Line color listbox
      if (crSaveLineRGB==COLOR_BLACK)
         m_szLineColor=szBLACK;
      else
      if (crSaveLineRGB==COLOR_WHITE)
         m_szLineColor=szWHITE;
      else
      if (crSaveLineRGB==COLOR_LTGRAY)
         m_szLineColor=szLTGRAY;
      else
      if (crSaveLineRGB==COLOR_MDGRAY)
         m_szLineColor=szMDGRAY;
      else
      if (crSaveLineRGB==COLOR_DKGRAY)
         m_szLineColor=szDKGRAY;
      else
         m_szLineColor=szBLACK;
   }
   else
      m_szLineColor="";

   if (bTextRGB) {
      if (crSaveTextRGB==COLOR_BLACK)
         m_szTextColor=szBLACK;
      else
      if (crSaveTextRGB==COLOR_WHITE)
         m_szTextColor=szWHITE;
      else
      if (crSaveTextRGB==COLOR_LTGRAY)
         m_szTextColor=szLTGRAY;
      else
      if (crSaveTextRGB==COLOR_MDGRAY)
         m_szTextColor=szMDGRAY;
      else
      if (crSaveTextRGB==COLOR_DKGRAY)
         m_szTextColor=szDKGRAY;
      else
         m_szTextColor=szBLACK;
   }
   else
      m_szTextColor="";

   m_bCBDrawBorder=bPen;
   m_bRBFillColor=bFillColor;
   m_bRBFillTrans=bFillTrans;

   if (!bFillObj) {
     GetLBFillColor().EnableWindow(FALSE);
     GetGRPFillColor().EnableWindow(FALSE);
     GetRBFillColor().EnableWindow(FALSE);
     GetRBFillTrans().EnableWindow(FALSE);
   }

   if (!bTextObj) {
     GetLBTextColor().EnableWindow(FALSE);
     GetSTTextColor().EnableWindow(FALSE);
   }

   if (bAllOleObjs) {
     GetLBFillColor().EnableWindow(FALSE);
     GetGRPFillColor().EnableWindow(FALSE);
     GetRBFillColor().EnableWindow(FALSE);
     GetRBFillTrans().EnableWindow(FALSE);
   }

   CDialog::OnInitDialog();

   ModifyStyleEx(0, WS_EX_CONTEXTHELP);  /////// puts "?" button in the dialog box.

   return TRUE;
}


//------------------------------------------------------------------------
void CObjPropDlg::OnOK()
{
    CString sz;
    GetLBThickness().GetWindowText(sz);

    if (sz < "0" || sz > "72") {
        CPEMessageBox(0,NULL,MB_OK | MB_ICONSTOP,IDP_INVALID_THICKNESS);
                GetLBThickness().SetFocus();
                return;
        }

    CDialog::OnOK();
}




#ifdef GRID
//------------------------------------------------------------------------
// CGridSettingsDlg dialog
//------------------------------------------------------------------------
CGridSettingsDlg::CGridSettingsDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CGridSettingsDlg::IDD, pParent)
{
   CDrawView* pView = CDrawView::GetView();
   if (pView) {
      m_bRBSmall=(pView->m_iGridSize==GRID_SMALL);
      m_bRBMedium=(pView->m_iGridSize==GRID_MEDIUM);
      m_bRBLarge=(pView->m_iGridSize==GRID_LARGE);
      m_bCBViewGrid=pView->m_bGrid;
      m_bCBSnapToGrid=pView->m_bSnapToGrid;
   }
   else
      TRACE(TEXT("DIALOGS.CGRidSettingsDlg-view missing\n"));
}


void CGridSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGridSettingsDlg)
    DDX_Check(pDX, IDC_RB_SMALL, m_bRBSmall);
    DDX_Check(pDX, IDC_RB_MEDIUM, m_bRBMedium);
    DDX_Check(pDX, IDC_RB_LARGE, m_bRBLarge);
    DDX_Check(pDX, IDC_CB_VIEWGRID, m_bCBViewGrid);
    DDX_Check(pDX, IDC_CB_SNAPTOGRID, m_bCBSnapToGrid);
        //}}AFX_DATA_MAP
}

//------------------------------------------------------------------------
BOOL CGridSettingsDlg::OnInitDialog()
{
   return CDialog::OnInitDialog();
}
#endif

LRESULT CGridSettingsDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{

#ifndef NT5BETA2
    ::HtmlHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#else
    ::HtmlHelpA( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#endif

    return 0;
}


///////#ifdef ENABLE_HELP
LRESULT CGridSettingsDlg::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
{

#ifndef NT5BETA2
    ::HtmlHelp( (HWND)wParam,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#else
    ::HtmlHelpA( (HWND)wParam,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#endif

    return( 0 );
}
//////////#endif




//-----------------------------------------------------------------------
int CPEMessageBox(int errorcode, LPCTSTR sz, UINT nType, int msgid)
{
   if (sz==NULL && msgid==-1)
      return 0;

   CString lpszCaption;
   CString lpszText;
   CString temp;

//   lpszCaption.LoadString(IDS_APP_NAME);
//   lpszCaption += _T(": ");
//   CString sztemp;
//   if (errorcode < 300)
//      sztemp.LoadString(IDS_INFORMATION_MESSAGE);
//   else
//      if (errorcode < 500)
//         sztemp.LoadString(IDS_WARNING_MESSAGE);
//      else
//         sztemp.LoadString(IDS_CRITICAL_MESSAGE);
//   lpszCaption += sztemp;

   lpszCaption.LoadString(IDS_MESSAGE);

   if (sz==NULL)
       lpszText.LoadString(msgid);
   else
       lpszText = sz;

//   temp.LoadString(IDS_IDNUM);
//   lpszText += temp;

//   temp.LoadString(IDS_MODULE_NAME);
//   LPTSTR szappname = temp.GetBuffer(9*sizeof(TCHAR));
//   for (int j = temp.GetLength()/sizeof(TCHAR); j < 9; j++)
//     szappname[j]=(TCHAR)'0';
//   szappname[8]=0;
//   lpszText += szappname;
//   temp.ReleaseBuffer();
//
//   TCHAR szRes[3];
//   wsprintf (szRes, "%03lu", errorcode);
//   lpszText += szRes;

   return ::MessageBox(CWnd::GetFocus()->GetSafeHwnd(), lpszText, lpszCaption, nType);
}




//--------------------------------------------------------------------------
//  SPLASH TIPS DIALOG
//--------------------------------------------------------------------------
CSplashTipsDlg::CSplashTipsDlg(CWnd* /*=NULL*/)
   : CDialog(CSplashTipsDlg::IDD)
{
        //{{AFX_DATA_INIT(CSplashTipsDlg)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}



//--------------------------------------------------------------------------
void CSplashTipsDlg::OnPrevTip()
{
        if (m_iCurrentTip>1)
           m_iCurrentTip--;
        else
           m_iCurrentTip=TOTAL_TIPS;

        CString sz;
        sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

        GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
        GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);
}


//--------------------------------------------------------------------------
void CSplashTipsDlg::OnNextTip()
{
        if (m_iCurrentTip<TOTAL_TIPS)
           m_iCurrentTip++;
        else
           m_iCurrentTip=1;

        CString sz;
        sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

        GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
        GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);
}


//--------------------------------------------------------------------------
HBRUSH CSplashTipsDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
        int dlg_id;

        dlg_id = pWnd->GetDlgCtrlID();

#ifndef WIN32S
        if( dlg_id != IDC_CK_SHOWTIPS )
                {
                if( (nCtlColor == CTLCOLOR_STATIC)||(dlg_id == IDC_TIPWINDOW) )
                        {
                        pDC->SetTextColor( GetSysColor( COLOR_INFOTEXT ) );
                        pDC->SetBkMode( TRANSPARENT );
                return( (HBRUSH)::GetSysColorBrush( COLOR_INFOBK ) );
                        }
                }
#endif

        return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

//--------------------------------------------------------------------------
void CSplashTipsDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CSplashTipsDlg)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}

void CSplashTipsDlg::OnOK()
{
        AfxGetApp()->WriteProfileString(TIPSECTION,TIPENTRY,(GetShowTips()->GetCheck()==1 ? _T("YES"):_T("NO") ));

    CDialog::OnOK();
}

//--------------------------------------------------------------------------
BOOL CSplashTipsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    CenterWindow();
        CString sz;

        sz.LoadString(IDS_DIDYOUKNOW);
    GetTitle()->SetWindowText(sz);
        sz.LoadString(IDS_TIP1);
    GetTips()->SetWindowText(sz);
        m_iCurrentTip=1;
        GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
        GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);

    sz = AfxGetApp()->GetProfileString(TIPSECTION,TIPENTRY,_T("YES"));
        GetShowTips()->SetCheck(sz==_T("YES"));

        // set fonts for tips window
    LOGFONT lf;
    (GetTitle()->GetFont())->GetObject(sizeof(LOGFONT),&lf);
    lf.lfWeight = FW_BOLD;
    m_tipstitle_font.CreateFontIndirect(&lf);
    GetDlgItem(IDC_STA_TITLE)->SetFont(&m_tipstitle_font);

    (GetTips()->GetFont())->GetObject(sizeof(LOGFONT),&lf);
    lf.lfWeight = FW_NORMAL;
    m_tips_font.CreateFontIndirect(&lf);
    GetDlgItem(IDC_STA_TIP)->SetFont(&m_tips_font);

///#ifdef ENABLE_HELP
///   ModifyStyleEx(0, WS_EX_CONTEXTHELP);   /// Put the "?" button in the dialog box.
///#endif

    return TRUE;
}


LRESULT CSplashTipsDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{

#ifndef NT5BETA2
    ::HtmlHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#else
    ::HtmlHelpA( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#endif

    return 0;
}


#if 0
///#ifdef ENABLE_HELP     // Let's don't do it for the tips!  a-juliar
LRESULT CSplashTipsDlg::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
{

#ifndef NT5BETA2
    ::HtmlHelp( (HWND)wParam,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#else
    ::HtmlHelpA( (HWND)wParam,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#endif

    return( 0 );
}
///#endif
#endif


#define CY_SHADOW   4
#define CX_SHADOW   4

//--------------------------------------------------------------------------
void CBigIcon::SizeToContent()
{
   // get system icon size
   int cxIcon = ::GetSystemMetrics(SM_CXICON);
   int cyIcon = ::GetSystemMetrics(SM_CYICON);

   // a big icon should be twice the size of an icon + shadows
        SetWindowPos(NULL, 0, 0, cxIcon*2 + CX_SHADOW + 4, cyIcon*2 + CY_SHADOW + 4,
                SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
}


//--------------------------------------------------------------------------
void CBigIcon::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
   CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
   ASSERT(pDC != NULL);

   CRect rect;
   GetClientRect(rect);
   int cxClient = rect.Width();
   int cyClient = rect.Height();

   // load icon
   HICON hicon = AfxGetApp()->LoadIcon(IDR_AWCPETYPE);
   if (hicon == NULL)
        return;

   // draw icon into off-screen bitmap
   int cxIcon = ::GetSystemMetrics(SM_CXICON);
   int cyIcon = ::GetSystemMetrics(SM_CYICON);

   CBitmap bitmap;
   if (!bitmap.CreateCompatibleBitmap(pDC, cxIcon, cyIcon))
        return;
   CDC dcMem;
   if (!dcMem.CreateCompatibleDC(pDC))
        return;
   CBitmap* pBitmapOld = dcMem.SelectObject(&bitmap);
   if (pBitmapOld == NULL)
        return;

   // blt the bits already on the window onto the off-screen bitmap
   dcMem.StretchBlt(0, 0, cxIcon, cyIcon, pDC,
        2, 2, cxClient-CX_SHADOW-4, cyClient-CY_SHADOW-4, SRCCOPY);

   // draw the icon on the background
   dcMem.DrawIcon(0, 0, hicon);

   // draw border around icon
   CPen pen;
   pen.CreateStockObject(BLACK_PEN);
   CPen* pPenOld = pDC->SelectObject(&pen);
   pDC->Rectangle(0, 0, cxClient-CX_SHADOW, cyClient-CY_SHADOW);
   if (pPenOld)
        pDC->SelectObject(pPenOld);

   // draw shadows around icon
   CBrush br;
   br.CreateStockObject(DKGRAY_BRUSH);
   rect.SetRect(cxClient-CX_SHADOW, CY_SHADOW, cxClient, cyClient);
   pDC->FillRect(rect, &br);
   rect.SetRect(CX_SHADOW, cyClient-CY_SHADOW, cxClient, cyClient);
   pDC->FillRect(rect, &br);

   // draw the icon contents
   pDC->StretchBlt(2, 2, cxClient-CX_SHADOW-4, cyClient-CY_SHADOW-4,
        &dcMem, 0, 0, cxIcon, cyIcon, SRCCOPY);
}


//--------------------------------------------------------------------------
BOOL CBigIcon::OnEraseBkgnd(CDC*)
{
   return TRUE;
}



//--------------------------------------------------------------------------
CMyPageSetupDialog::CMyPageSetupDialog(CWnd* pParentWnd) : CMyCommonDialog(pParentWnd)
{

    m_hLib=NULL;
    m_pPageSetupDlg=NULL;
        memset(&m_psd, 0, sizeof(m_psd));
        m_psd.lStructSize = sizeof(PAGESETUPDLG);
        m_psd.Flags |= PSD_DISABLEMARGINS;
        m_psd.hInstance = AfxGetInstanceHandle();


    UINT OldErrMode = ::SetErrorMode (SEM_FAILCRITICALERRORS);
        m_hLib = ::LoadLibrary(TEXT("comdlg32.dll"));
    if (m_hLib!=NULL) {
#ifdef UNICODE
        m_pPageSetupDlg = (PPSD)GetProcAddress(m_hLib, "PageSetupDlgW");
#else
        m_pPageSetupDlg = (PPSD)GetProcAddress(m_hLib, "PageSetupDlgA");
#endif
        if (m_pPageSetupDlg==NULL)
           CPEMessageBox(MSG_ERROR_NOPAGESETUP, NULL, MB_OK | MB_ICONEXCLAMATION, IDS_NOPAGESETUP);
        }
        else
        CPEMessageBox(MSG_ERROR_NOPAGESETUPDLL, NULL, MB_OK | MB_ICONEXCLAMATION, IDS_NOPAGESETUPDLL);
    ::SetErrorMode (OldErrMode);
}







//--------------------------------------------------------------------------
CMyPageSetupDialog::~CMyPageSetupDialog()
{
    if (m_hLib)
       ::FreeLibrary(m_hLib);
}

//--------------------------------------------------------------------------
INT_PTR CMyPageSetupDialog::DoModal()
{
        ASSERT_VALID(this);
        ASSERT(m_pPageSetupDlg != NULL);

        m_psd.hwndOwner = PreModal();
        INT_PTR nResult = m_pPageSetupDlg(&m_psd);
        PostModal();


        return nResult;
}


//---------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CMyPrintDlg, CPrintDialog)

//---------------------------------------------------------------------------
CMyPrintDlg::CMyPrintDlg(BOOL bPrintSetupOnly, DWORD dwFlags, CWnd* pParentWnd) :
        CPrintDialog(bPrintSetupOnly, dwFlags, pParentWnd)
{
}

//---------------------------------------------------------------------------

BOOL CMyPrintDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
        return (BOOL)Default();

}

//---------------------------------------------------------------------------

CMyCommonDialog::CMyCommonDialog( CWnd* pParentWnd ) :
       CCommonDialog( pParentWnd )
{
}

BOOL CMyCommonDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    return (BOOL)Default();
}

//----------------------------------------------------------------------------
CMyFontDialog::CMyFontDialog( LPLOGFONT lplfInitial,
                              DWORD dwFlags,
                              CDC* pdcPrinter,
                              CWnd * pParentWnd) :
                 CFontDialog( lplfInitial, dwFlags, pdcPrinter, pParentWnd )
{
}
//----------------------------------------------------------------------------
CMyFontDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    return (BOOL)Default();
}
//----------------------------------------------------------------------------
CMyOleInsertDialog::CMyOleInsertDialog(DWORD dwFlags, CWnd* pParentWnd ) :
        COleInsertDialog( dwFlags, pParentWnd )
{
}

//---------------------------------------------------------------------------
CMyOleInsertDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    //// return Default();   /// Worked in the other dialog boxes, but here it just
                             /// flashed the item we want temporarily and then threw
                             /// the faxcover help contents up.  BAD!!

    ::WinHelp( (HWND)(pHelpInfo->hItemHandle),
                        TEXT("mfcuix.hlp"),
                        HELP_WM_HELP,
                        (ULONG_PTR)(LPSTR)aOleDlgHelpIDs ) ;

    return 0;


}
//---------------------------------------------------------------------------

//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CObjPropDlg, CDialog)
   ON_LBN_SELCHANGE(IDC_LB_FILLCOLOR, OnSelChangeFillColor)
    //{{AFX_MSG_MAP(CObjPropDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
   ON_MESSAGE( WM_HELP, OnWM_HELP )
////#ifdef ENABLE_HELP
   ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
////#endif
END_MESSAGE_MAP()

#ifdef GRID
BEGIN_MESSAGE_MAP(CGridSettingsDlg, CDialog)
    //{{AFX_MSG_MAP(CGridSettingsDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
   ON_MESSAGE( WM_HELP, OnWM_HELP )
/////#ifdef ENABLE_HELP
   ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
/////#endif
END_MESSAGE_MAP()
#endif

BEGIN_MESSAGE_MAP(CSplashTipsDlg, CDialog)
        //{{AFX_MSG_MAP(CSplashTipsDlg)
   ON_WM_CTLCOLOR()
   ON_BN_CLICKED(IDC_B_NEXTTIP, OnNextTip)
   ON_BN_CLICKED(IDC_B_PREVTIP, OnPrevTip)
        //}}AFX_MSG_MAP
   ON_MESSAGE( WM_HELP, OnWM_HELP )
/////#ifdef ENABLE_HELP
/////   ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU ) ///Don't put "?" button in Tips box
/////#endif
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CBigIcon, CButton)
        //{{AFX_MSG_MAP(CBigIcon)
        ON_WM_DRAWITEM()
        ON_WM_ERASEBKGND()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_MESSAGE_MAP(CMyPrintDlg, CPrintDialog)
        //{{AFX_MSG_MAP(CMyPrintDlg)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyCommonDialog, CCommonDialog)
        //{{AFX_MSG_MAP(CMyCommonDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyOleInsertDialog, COleInsertDialog)
        //{{AFX_MSG_MAP(CMyOleInsertDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyFontDialog, CFontDialog)
        //{{AFX_MSG_MAP(CMyFontDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\ntonly.h ===
#include <string.h>

#define _mbsncmp(x,y,z)      strncmp((LPSTR)x,(LPSTR)y,z)
#define _mbsstr(x,y)         (unsigned char*)strstr((LPSTR)x,(LPSTR)y)
#define _mbstok(x,y)         strtok((LPSTR)x,(LPSTR)y)
#define _mbscmp(x,y)         strcmp((LPSTR)x,(LPSTR)y)
#define _mbslen(x)           strlen((LPSTR)x)
#define _mbscpy(x,y)         strcpy((LPSTR)x,(LPSTR)y)
#define _mbsupr(x)           strupr((LPSTR)x)
#define _mbscat(x,y)         strcat((LPSTR)x,(LPSTR)y)
#define _mbschr(x,y)         strchr((LPSTR)x,y)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\faxprop.h ===
//=============================================================================
// FAXPROP.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//=============================================================================
#ifndef __FAXPROP_H__
#define __FAXPROP_H__


//--------------------------------------------------------------------------
class CProp
{
public:
   WORD m_wR_CAPT;
   WORD m_wR_PROP;
   CString m_szPropName;
   CString m_szCaption;
   WORD m_wPropDefLen;
   WORD m_wPropDefLines;
   ULONG m_lPropIndex;
   CProp(WORD wR_PROP, WORD wPropDefLen, WORD wPropDefLines,WORD wR_CAPT,
     ULONG lPropIndex);
};

/*
class CFaxPropMap;

class CFaxPropMapIterator
{
   CFaxPropMapIterator(CFaxPropMap& faxmap);
private:
   CFaxPropMap* currentlink;
   CFaxPropMap* prevlink
   CFaxPropMap& theMap;
}
*/


//--------------------------------------------------------------------------
class CFaxPropMap
{
public:
   static CMapWordToPtr m_PropMap;

//   CFaxProp();
//   void GetPropValue(WORD propid, CString& szPropValue);
   void GetCaption(WORD propid, CString& szCaption);
//   void GetPropName(WORD propid, CString& szPropName);
   void GetPropString(WORD propid, CString& szPropName);
   WORD GetPropDefLines(WORD propid);
   WORD GetPropDefLength(WORD propid);

protected:
//   friend class CFaxPropMapIterator;
   CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
	void get_message_note( void );
};



#endif   //#ifndef __FAXPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\mainfrm.h ===
//---------------------------------------------------------------------------
// MAINFRM.H
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __MAINFRM_H__
#define __MAINFRM_H__

///#ifndef ENABLE_HELP
///#define ENABLE_HELP
///#endif

class CSizeComboBox : public CComboBox
{
        int m_nLogVert;
public:
        void EnumFontSizes(CString& szFontName);
        static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf,
                LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);
        void InsertSize(int nSize);
};



class CStyleBar : public CToolBar
{
public:
        CComboBox       m_cboxFontName;
        CSizeComboBox   m_cboxFontSize;
        CFont       m_font;
protected:
        virtual BOOL PreTranslateMessage(MSG* pMsg);
};

class CDrawApp;

class CMainFrame : public CFrameWnd
{
        DECLARE_DYNCREATE(CMainFrame)
public:
    CStyleBar   m_StyleBar;
        CToolBar    m_DrawBar;
        CStatusBar  m_wndStatusBar;

        CMainFrame();
        virtual ~CMainFrame();
        virtual void ActivateFrame( int nCmdShow = - 1 );

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:
   HMENU m_mainmenu;
   int m_iTop;
   int m_iSecond;
   HICON m_toolbar_icon;

   BOOL CreateDrawToolBar();
   BOOL CreateStyleBar();

   afx_msg void OnMenuSelect(UINT, UINT, HMENU);
   afx_msg void OnInitMenu(CMenu* pPopupMenu);
   afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
   afx_msg void OnUpdateControlStyleBarMenu(CCmdUI* pCmdUI);
   afx_msg void OnUpdateControlDrawBarMenu(CCmdUI* pCmdUI);
   afx_msg BOOL OnStyleBarCheck(UINT nID);
   afx_msg BOOL OnDrawBarCheck(UINT nID);
   afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
   afx_msg void OnShowTips();
   afx_msg void OnDropDownFontName();
   afx_msg void OnDropDownFontSize();
   virtual BOOL PreTranslateMessage(MSG* pMsg);

   void PopupText();
   void EnumFontSizes(CString& szFontName);

        //{{AFX_MSG(CMainFrame)
   afx_msg LRESULT OnAWCPEActivate(WPARAM wParam, LPARAM lParam);
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
        //}}AFX_MSG
///#ifdef ENABLE_HELP ////
///        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        afx_msg void OnHelp();
        afx_msg LRESULT OnWM_HELP(WPARAM wParam, LPARAM lParam);
        afx_msg BOOL OnQueryOpen( void );

   DECLARE_MESSAGE_MAP()
};



#endif // #ifndef __MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by AWCPE.RC
//
#define IDR_AWCPETYPE                   2
#define IDR_AWCPEDOC                    3
#define IDR_AWCPETYPE_CNTR_IP           6
#define IDR_STYLEBAR                    10
#define IDR_DRAWTOOL                    11
#define ID_GRIDDOT                      12
#define IDW_STYLEBAR                    20
#define ID_VIEW_STYLEBAR                20
#define ID_TEXT                         20
#define IDW_DRAWBAR                     21
#define ID_VIEW_DRAWBAR                 21
#define ID_VIEW_GRIDLINES               22
#define IDC_B_PREVTIP                   80
#define IDC_B_NEXTTIP                   81
#define IDD_SPLASHTIPS                  99
#define IDD_ABOUTBOX                    100
#define IDP_BUSY                        100
#define IDD_OBJ_PROP                    101
#define IDP_OLE_INIT_FAILED             101
#define IDD_GRID_SETTINGS               102
#define IDP_FAILED_TO_CREATE            102
#define IDC_WEIGHT                      102
#define IDC_PENCIL                      102
#define IDC_NOFILL                      103
#define ID_CANCEL_EDIT                  104
#define ID_SNAP_TO_GRID                 105
#define IDI_TBARICON                    108
#define IDC_MOVE                        109
#define IDC_CB_VIEWGRID                 113
#define IDC_CB_SNAPTOGRID               114
#define IDC_RB_SMALL                    115
#define IDC_RB_MEDIUM                   116
#define IDC_RB_LARGE                    117
#define IDC_ST_TEXTCOLOR                118
#define IDC_GRP_FILLCOLOR               119
#define IDC_PHYSICAL_MEM                120
#define IDC_DISK_SPACE                  121
#define IDC_BIGICON                     122
#define IDC_STA_TIP                     123
#define IDC_CK_SHOWTIPS                 124
#define IDC_STA_BITMAP                  127
#define IDC_STA_TITLE                   129
#define IDC_ICO_TIPS                    130
#define IDC_ST_THICKNESS                131
#define IDC_TIPWINDOW                   131
#define IDC_ST_COLOR                    132
#define IDI_TIPS                        140
#define ID_VIEW_GRID                    150
#define ID_OBJECT_LINECOLOR             201
#define ID_OBJECT_FILLCOLOR             202
#define ID_OBJECT_MOVETOFRONT           203
#define ID_OBJECT_MOVETOBACK            204
#define ID_OBJECT_MOVEFORWARD           205
#define ID_OBJECT_MOVEBACK              206
#define ID_LAYOUT_ALIGNLEFT             208
#define ID_LAYOUT_ALIGNRIGHT            209
#define ID_LAYOUT_ALIGNTOP              210
#define ID_LAYOUT_ALIGNBOTTOM           211
#define ID_LAYOUT_ALIGNHORZCENTER       212
#define ID_LAYOUT_ALIGNVERTCENTER       213
#define ID_LAYOUT_SPACEACROSS           214
#define ID_LAYOUT_SPACEDOWN             215
#define ID_LAYOUT_CENTERWIDTH           216
#define ID_LAYOUT_CENTERHEIGHT          217
#define ID_VIEW_PAPERCOLOR              301
#define ID_VIEW_SHOWOBJECTS             302
#define ID_EDIT_PROPERTIES              400
#define ID_DRAW_SELECT                  501
#define ID_DRAW_TEXT                    502
#define ID_DRAW_LINE                    503
#define ID_DRAW_RECT                    504
#define ID_DRAW_ROUNDRECT               505
#define ID_DRAW_POLYGON                 506
#define ID_DRAW_ELLIPSE                 507
#define ID_STYLE_BOLD                   600
#define ID_STYLE_ITALIC                 601
#define ID_STYLE_UNDERLINE              602
#define ID_STYLE_LEFT                   603
#define ID_STYLE_CENTERED               604
#define ID_STYLE_RIGHT                  605
#define ID_FONT_NAME                    650
#define ID_FONT_SIZE                    651
#define ID_FONT                         700
#define ID_ALIGN_LEFT                   701
#define ID_ALIGN_CENTER                 702
#define ID_ALIGN_RIGHT                  703
#define ID_SHOW_TIPS                    750
#define IDC_COMM_STATIC                 998
#define IDC_COMM_GROUPBOX               999
#define ID_MAPI_RECIP_NAME              1001
#define ID_MAPI_RECIP_FAXNUM            1002
#define ID_MAPI_RECIP_COMPANY           1003
#define ID_MAPI_RECIP_ADDRESS           1004
#define ID_MAPI_RECIP_TITLE             1005
#define ID_MAPI_RECIP_DEPT              1006
#define ID_MAPI_RECIP_OFFICELOC         1007
#define ID_MAPI_RECIP_HMTELENUM         1008
#define ID_MAPI_RECIP_OFTELENUM         1009
#define ID_MAPI_RECIP_TOLIST            1010
#define ID_MAPI_RECIP_CCLIST            1011
#define ID_MAPI_SENDER_NAME             1012
#define ID_MAPI_SENDER_FAXNUM           1013
#define ID_MAPI_SENDER_COMPANY          1014
#define ID_MAPI_SENDER_ADDRESS          1015
#define ID_MAPI_SENDER_TITLE            1016
#define ID_MAPI_SENDER_DEPT             1017
#define ID_MAPI_SENDER_OFFICELOC        1018
#define ID_MAPI_SENDER_HMTELENUM        1019
#define ID_MAPI_SENDER_OFTELENUM        1020
#define ID_MAPI_MSG_SUBJECT             1021
#define ID_MAPI_MSG_TIMESENT            1022
#define ID_MAPI_MSG_NUMPAGES            1023
#define ID_MAPI_MSG_ATTACH              1024
#define ID_MAPI_MSG_BILLCODE            1025
#define ID_MAPI_MSG_FAXTEXT             1026
#define ID_MAPI_RECIP_CITY              1027
#define ID_MAPI_RECIP_STATE             1028
#define ID_MAPI_RECIP_ZIPCODE           1029
#define ID_MAPI_RECIP_COUNTRY           1030
#define ID_MAPI_RECIP_POBOX             1031
#define ID_MAPI_MSG_NOTE                1032
#define IDS_OLD_FILE_FILTER             1033
#define ID_TOOLBAR_STYLE                1100
#define ID_TOOLBAR_DRAWING              1101
#define IDS_PROP_RP_NAME                2001
#define IDS_CAPT_RP_NAME                2002
#define IDS_PROP_RP_FXNO                2003
#define IDS_CAPT_RP_FXNO                2004
#define IDS_PROP_RP_COMP                2005
#define IDS_CAPT_RP_COMP                2006
#define IDS_PROP_RP_ADDR                2007
#define IDS_CAPT_RP_ADDR                2008
#define IDS_PROP_RP_TITL                2009
#define IDS_CAPT_RP_TITL                2010
#define IDS_PROP_RP_DEPT                2011
#define IDS_CAPT_RP_DEPT                2012
#define IDS_PROP_RP_OFFI                2013
#define IDS_CAPT_RP_OFFI                2014
#define IDS_PROP_RP_HTEL                2015
#define IDS_CAPT_RP_HTEL                2016
#define IDS_PROP_RP_OTEL                2017
#define IDS_CAPT_RP_OTEL                2018
#define IDS_PROP_RP_TOLS                2019
#define IDS_CAPT_RP_TOLS                2020
#define IDS_PROP_RP_CCLS                2021
#define IDS_CAPT_RP_CCLS                2022
#define IDS_PROP_SN_NAME                2023
#define IDS_CAPT_SN_NAME                2024
#define IDS_PROP_SN_FXNO                2025
#define IDS_CAPT_SN_FXNO                2026
#define IDS_PROP_SN_COMP                2027
#define IDS_CAPT_SN_COMP                2028
#define IDS_PROP_SN_ADDR                2029
#define IDS_CAPT_SN_ADDR                2030
#define IDS_PROP_SN_TITL                2031
#define IDS_CAPT_SN_TITL                2032
#define IDS_PROP_SN_DEPT                2033
#define IDS_CAPT_SN_DEPT                2034
#define IDS_PROP_SN_OFFI                2035
#define IDS_CAPT_SN_OFFI                2036
#define IDS_PROP_SN_HTEL                2037
#define IDS_CAPT_SN_HTEL                2038
#define IDS_PROP_SN_OTEL                2039
#define IDS_CAPT_SN_OTEL                2040
#define IDS_PROP_MS_SUBJ                2041
#define IDS_CAPT_MS_SUBJ                2042
#define IDS_PROP_MS_TSNT                2043
#define IDS_CAPT_MS_TSNT                2044
#define IDS_PROP_MS_NOPG                2045
#define IDS_CAPT_MS_NOPG                2046
#define IDS_PROP_MS_NOAT                2047
#define IDS_CAPT_MS_NOAT                2048
#define IDS_PROP_MS_BCOD                2049
#define IDS_CAPT_MS_BCOD                2050
#define IDS_PROP_MS_TEXT                2051
#define IDS_CAPT_MS_TEXT                2052
#define IDS_PROP_RP_CITY                2053
#define IDS_CAPT_RP_CITY                2054
#define IDS_PROP_RP_STAT                2055
#define IDS_CAPT_RP_STAT                2056
#define IDS_PROP_RP_ZIPC                2057
#define IDS_CAPT_RP_ZIPC                2058
#define IDS_PROP_RP_CTRY                2059
#define IDS_CAPT_RP_CTRY                2060
#define IDS_PROP_RP_POBX                2061
#define IDS_CAPT_RP_POBX                2062
#define IDS_PROP_MS_NOTE                2063
#define IDS_CAPT_MS_NOTE                2064
#define IDP_FILE_MENU                   2100
#define IDP_EDIT_MENU                   2101
#define IDP_VIEW_MENU                   2102
#define IDP_INSERT_MENU                 2103
#define IDP_FORMAT_MENU                 2104
#define IDP_LAYOUT_MENU                 2105
#define IDP_HELP_MENU                   2106
#define IDP_SPACE_EVEN                  2107
#define IDP_CENTER_PAGE                 2108
#define IDP_ALIGN_TEXT                  2109
#define IDP_RECIPIENT                   2110
#define IDP_SENDER                      2111
#define IDP_MESSAGE                     2112
#define IDP_ALIGN_OBJECTS               2113
#define IDP_INVALID_THICKNESS           2115
#define IDP_OLE_STATIC_OBJECT           2116
#define IDS_DISK_SPACE_UNAVAIL          2200
#define IDS_DISK_SPACE                  2209
#define IDS_MATH_COPR_NOTPRESENT        2210
#define IDS_MATH_COPR_PRESENT           2211
#define IDS_PHYSICAL_MEM                2212
#define IDS_INVALID_FILE                2213
#define IDS_CORRUPT_FILE                2214
#define IDS_MAWF_NAME                   2300
#define IDS_AWF_NAME                    2301
#define IDS_APP_NAME                    2302
#define IDS_INFORMATION_MESSAGE         2303
#define IDS_WARNING_MESSAGE             2304
#define IDS_CRITICAL_MESSAGE            2305
#define IDS_MODULE_NAME                 2309
#define MAWF_E_GENERIC                  2310
#define IDS_IDNUM                       2311
#define IDS_MESSAGE                     2312
#define IDS_MENU_CUT                    2400
#define IDS_MENU_COPY                   2401
#define IDS_MENU_PASTE                  2402
#define IDS_MENU_FONT                   2403
#define IDS_MENU_ALIGNTEXT              2404
#define IDS_MENU_ALIGNLEFT              2405
#define IDS_MENU_ALIGNCENTER            2406
#define IDS_MENU_ALIGNRIGHT             2407
#define IDS_MENU_PROPERTIES             2408
#define IDS_MENU_MOVETOFRONT            2409
#define IDS_MENU_SENDTOBACK             2410
#define IDS_MENU_VIEWSTYLEBAR           2411
#define IDS_MENU_VIEWDRAWINGBAR         2412
#define IDS_MENU_VIEWSTATUSBAR          2413
#define IDS_MENU_VIEWGRIDLINES          2414
#define IDS_TIP_BASE                    2500
#define IDS_TIP1                        2501
#define IDS_TIP2                        2502
#define IDS_TIP3                        2503
#define IDS_TIP4                        2504
#define IDS_TIP5                        2505
#define IDS_TIP6                        2506
#define IDS_TIP7                        2507
#define IDS_TIP8                        2508
#define IDS_TIP9                        2509
#define IDS_TIP10                       2510
#define IDS_TIP11                       2511
#define IDS_TIP12                       2512
#define IDS_TIP13                       2513
#define IDS_TIP14                       2514
#define IDS_TIP15                       2515
#define IDS_TIP16                       2516
#define IDS_TIP17                       2517
#define IDS_TIP18                       2518
#define IDS_TIP19                       2519
#define IDS_MISSING_FILE                2520
#define IDS_NOPAGESETUP                 2521
#define IDS_NOPAGESETUPDLL              2522
#define IDS_DIDYOUKNOW                  2999
#define IDS_INFO_NOFAXPROP              3000
#define ID_COLOR_BLACK                  3006
#define ID_COLOR_WHITE                  3007
#define ID_COLOR_LTGRAY                 3008
#define ID_COLOR_DKGRAY                 3009
#define ID_COLOR_MDGRAY                 3010
#define ID_INDICATOR_POS1               3011
#define IDS_NOMOREUNDO                  3012
#define IDS_INFO_DRAWPOLY               3013
#define ID_INDICATOR_POS2               3014
#define IDC_CB_DRAWBORDER               4000
#define IDS_DEFAULT_FONT                4000
#define IDC_LB_THICKNESS                4001
#define IDS_DEFAULT_BOXFONT             4001
#define IDC_LB_LINECOLOR                4002
#define IDC_RB_FILLTRANS                4004
#define IDC_RB_FILLCOLOR                4005
#define IDC_TXTLB_FILLCOLOR             4006
#define IDC_LB_FILLCOLOR                4007
#define IDC_LB_TEXTCOLOR                4008
#define ID_MAPI_MSG_BODY                32790

#define IDS_HELP_SCREEN                 135
// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         32791
#define _APS_NEXT_CONTROL_VALUE         132
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\mainfrm.cpp ===
//--------------------------------------------------------------------------
// MAINFRM.CPP
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains main frame class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#ifndef NT_BUILD
#include <mbstring.h>
#endif

#include <htmlhelp.h>
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "afxpriv.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

   //constants for font name & size
const int INDEX_FONTNAME = 10 ;
const int INDEX_FONTSIZE = 12 ;
const int NAME_WIDTH  = 170 ;
const int NAME_HEIGHT = 140 ;
const int SIZE_WIDTH  = 60 ;
const int SIZE_HEIGHT = 140 ;

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

extern UINT NEAR WM_AWCPEACTIVATE;

WORD nFontSizes[] = { 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 0 };

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE stylebar[] =
{
    // same order as in the bitmap 'stylebar.bmp'
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
        ID_SEPARATOR,
    ID_FILE_PRINT,
        ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
    ID_STYLE_BOLD,
    ID_STYLE_ITALIC,
    ID_STYLE_UNDERLINE,
        ID_SEPARATOR,
    ID_STYLE_LEFT,
    ID_STYLE_CENTERED,
    ID_STYLE_RIGHT,
};


static UINT BASED_CODE drawtools[] =
{
    // same order as in the bitmap 'drawtools.bmp'
    ID_DRAW_SELECT,
    ID_DRAW_TEXT,
    ID_DRAW_LINE,
    ID_DRAW_RECT,
    ID_DRAW_ROUNDRECT,
    ID_DRAW_POLYGON,
    ID_DRAW_ELLIPSE,
        ID_SEPARATOR,
    ID_OBJECT_MOVETOFRONT,
    ID_OBJECT_MOVETOBACK,
        ID_SEPARATOR,
    ID_LAYOUT_SPACEACROSS,
    ID_LAYOUT_SPACEDOWN,
        ID_SEPARATOR,
    ID_LAYOUT_ALIGNLEFT,
    ID_LAYOUT_ALIGNRIGHT,
    ID_LAYOUT_ALIGNTOP,
    ID_LAYOUT_ALIGNBOTTOM,
#ifdef GRID
    ID_SNAP_TO_GRID,
#endif

};


static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,
    ID_INDICATOR_POS1,                          //id for object coordinates
    ID_INDICATOR_POS2,                          //id for object coordinates
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


//--------------------------------------------------------------------------
CMainFrame::CMainFrame()
{
        m_toolbar_icon = theApp.LoadIcon( IDI_TBARICON );
}


//--------------------------------------------------------------------------
CMainFrame::~CMainFrame()
{
}



//--------------------------------------------------------------------------
BOOL CALLBACK
        EnumFamProc( ENUMLOGFONT* lpnlf,NEWTEXTMETRIC* lpntm,int iFontType,
                        LPARAM lpData)
        {
        if( lpnlf == NULL )
                return FALSE;

        CComboBox* pCBox = (CComboBox*)lpData;

        if( pCBox )
                {
                if( _tcsncmp((lpnlf->elfLogFont.lfFaceName),
                                           TEXT("@"), 1 )
                        == 0 )
                        {
                        /*
                                This is a "vertical" font. Nobody wants to show these,
                                so filter them out and keep going.
                         */
                        return( TRUE );
                        }

                if( pCBox->
                                FindStringExact(0,(LPCTSTR)(lpnlf->elfLogFont.lfFaceName))
                                ==CB_ERR )
/***CHANGES FOR M8 bug 2988***/
                        {
                        pCBox->AddString( (LPCTSTR)(lpnlf->elfLogFont.lfFaceName) );

                        // look for fonts that matches system charset and keep
                        // first one in sort order
                        if( theApp.m_last_logfont.lfCharSet
                                        == lpnlf->elfLogFont.lfCharSet )
                                {
                                if( _tcscmp((lpnlf->elfLogFont.lfFaceName),
                                                      (theApp.m_last_logfont.lfFaceName) )
                                        < 0 )
                                        {
                                        // found it, copy the whole thing
                                        theApp.m_last_logfont = lpnlf->elfLogFont;
                                        }
                                }
                        }
/*****************************/
                }

        return TRUE ;

        }



//--------------------------------------------------------------------------
BOOL CMainFrame::CreateStyleBar()
{
   if (!m_StyleBar.Create(this,WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE,IDW_STYLEBAR) ||
        !m_StyleBar.LoadBitmap(IDR_STYLEBAR) ||
        !m_StyleBar.SetButtons(stylebar,
          sizeof(stylebar)/sizeof(UINT))) {
        TRACE(TEXT("AWCPE.MAINFRM.CREATESTYLEBAR: Failed to create stylebar\n"));
        return FALSE;
   }

   CString sz;
   sz.LoadString(ID_TOOLBAR_STYLE);
   m_StyleBar.SetWindowText(sz);

   CRect rect;
   int cyFit;
   m_StyleBar.SetButtonInfo(INDEX_FONTNAME, ID_FONT_NAME, TBBS_SEPARATOR, NAME_WIDTH );
   m_StyleBar.SetButtonInfo(INDEX_FONTNAME+1, ID_SEPARATOR, TBBS_SEPARATOR, 12 );
   m_StyleBar.GetItemRect(INDEX_FONTNAME, &rect);
   cyFit = rect.Height();
   rect.right = rect.left + NAME_WIDTH;
   rect.bottom = rect.top + NAME_HEIGHT;       // drop height

   if (!m_StyleBar.m_cboxFontName.Create(
        WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWN|CBS_SORT,
        rect, &m_StyleBar, ID_FONT_NAME))  {
        TRACE(TEXT("Failed to create combobox inside toolbar\n"));
        return FALSE ;      // fail to create
   }

   // Create font size combo box on toolbar
   m_StyleBar.SetButtonInfo(INDEX_FONTSIZE, ID_FONT_SIZE, TBBS_SEPARATOR, SIZE_WIDTH);
   m_StyleBar.SetButtonInfo(INDEX_FONTSIZE+1, ID_SEPARATOR, TBBS_SEPARATOR, 12 );
   m_StyleBar.GetItemRect(INDEX_FONTSIZE, &rect);
   cyFit = rect.Height();
   rect.right = rect.left + SIZE_WIDTH;
   rect.bottom = rect.top + SIZE_HEIGHT;       // drop height

   if (!m_StyleBar.m_cboxFontSize.Create(
        WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWN,
        rect, &m_StyleBar, ID_FONT_SIZE)) {
        TRACE(TEXT("Failed to create combobox inside toolbar\n"));
        return FALSE ;
   }

/***CHANGES FOR M8 bug 2988***/
   // Fill font name combobox
//   CClientDC dc(NULL);
//   ::EnumFontFamilies(dc.GetSafeHdc(),(LPCTSTR)NULL,(FONTENUMPROC)EnumFamProc,LPARAM(&m_StyleBar.m_cboxFontName));

   CString strDefaultFont;
//   strDefaultFont.LoadString(IDS_DEFAULT_FONT);
   LOGFONT system_logfont;
   CFont   system_font;

   system_font.Attach( ::GetStockObject(SYSTEM_FONT) );
   system_font.GetObject( sizeof (LOGFONT), (LPVOID)&system_logfont );
   theApp.m_last_logfont = system_logfont;

   // Fill font name combobox and find default font
   CClientDC dc(NULL);
   ::EnumFontFamilies(dc.GetSafeHdc(),(LPCTSTR)NULL,(FONTENUMPROC)EnumFamProc,LPARAM(&m_StyleBar.m_cboxFontName));

   // enum changed theApp.m_last_logfont to first font that had same
   // charset as system font. Use face name for default

   // As it stands now, theApp.m_last_logfont.lfFaceName is the ALGERIAN described in
   // bug 39656, which I am really tired of seeing when the tool bar pops up!
   // Must set it back to the system_logfont.  But system_font is still LOGFONT for the system font.
   // This next line of code will FIX 39656. a-juliar, 05-23-96.

   theApp.m_last_logfont = system_logfont ;

   strDefaultFont = theApp.m_last_logfont.lfFaceName;

   // Wouldn't it be better to use the font mentioned in the resource file?
   //    5-30-95 a-juliar

   strDefaultFont.LoadString( IDS_DEFAULT_FONT );

   memset(&(theApp.m_last_logfont),0,sizeof(LOGFONT)) ;
   theApp.m_last_logfont.lfHeight = -17;   //LU
   theApp.m_last_logfont.lfWeight = 200; // non-bold font weight
   theApp.m_last_logfont.lfCharSet = DEFAULT_CHARSET;
   theApp.m_last_logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
   theApp.m_last_logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
   theApp.m_last_logfont.lfQuality = DEFAULT_QUALITY;
   theApp.m_last_logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
////   strDefaultFont.LockBuffer();
   _tcsncpy(theApp.m_last_logfont.lfFaceName,strDefaultFont.GetBuffer(0),LF_FACESIZE);
   strDefaultFont.ReleaseBuffer();


/*****************************/


   CString strDefaultBoxFont;
   strDefaultBoxFont.LoadString(IDS_DEFAULT_BOXFONT);

   m_StyleBar.m_cboxFontSize.EnumFontSizes(strDefaultFont);   //load font sizes for default font.



   ////////////////////////////////////////////////////////
   // FIX FOR 3718
   //
   // DBCS funny buisness font code for name and size comboboxes
   // removed and replaced with the following four lines. These
   // comboboxes are set to use the same font as menus do. This
   // automatically takes care of all localization headaches (knock
   // on wood...).
   //
   m_StyleBar.m_font.Attach(::GetStockObject(DEFAULT_GUI_FONT));
   m_StyleBar.m_cboxFontName.SetFont(&m_StyleBar.m_font);
   m_StyleBar.m_cboxFontSize.SetFont(&m_StyleBar.m_font);
/***NEEDED FOR M8 bug 2988***/
   m_StyleBar.m_cboxFontName.SelectString(-1,strDefaultFont);
   ////////////////////////////////////////////////////////




/***CHANGES FOR M8 bug 2988***/
//   m_StyleBar.m_cboxFontSize.SetCurSel(2);
/********the blow is since M8*****/
        int initial_fontsize_index;
        CString size_str;
        int font_size;

        if( (initial_fontsize_index =
                        m_StyleBar.m_cboxFontSize.FindStringExact( -1, TEXT("10") ))
                == CB_ERR )
                initial_fontsize_index = 2;

        m_StyleBar.m_cboxFontSize.SetCurSel( initial_fontsize_index );

        m_StyleBar.m_cboxFontSize.GetWindowText( size_str );
    font_size = _ttoi( size_str );
        if( font_size <= 0 || font_size > 5000 )
                font_size = 10;

        theApp.m_last_logfont.lfHeight = -MulDiv(font_size,100,72);
        theApp.m_last_logfont.lfWidth = 0;
/*****************************/

// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
    theApp.m_default_logfont = theApp.m_last_logfont;
////////////////////////////////


   #if _MFC_VER >= 0x0300
      m_StyleBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
      EnableDocking(CBRS_ALIGN_ANY);
      DockControlBar(&m_StyleBar);
      m_StyleBar.SetBarStyle(m_StyleBar.GetBarStyle()
          | CBRS_TOOLTIPS | CBRS_FLYBY);
   #endif

   UINT id, style;
   int image;
   int idx = m_StyleBar.CommandToIndex(ID_STYLE_RIGHT);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_LEFT);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_CENTERED);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);

   return TRUE ;
}


BOOL CMainFrame::CreateDrawToolBar()
{
   if (!m_DrawBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE,IDW_DRAWBAR) ||
        !m_DrawBar.LoadBitmap(IDR_DRAWTOOL) ||
        !m_DrawBar.SetButtons(drawtools,
          sizeof(drawtools)/sizeof(UINT))) {
        TRACE(TEXT("Failed to create toolbar\n"));
        return -1;      // fail to create
   }

   CString sz;
   sz.LoadString(ID_TOOLBAR_DRAWING);
   m_DrawBar.SetWindowText(sz);

   #if _MFC_VER >= 0x0300
      m_DrawBar.EnableDocking(CBRS_ALIGN_ANY);
      EnableDocking(CBRS_ALIGN_ANY);
      DockControlBar(&m_DrawBar);
      m_DrawBar.SetBarStyle(m_DrawBar.GetBarStyle()
          | CBRS_TOOLTIPS | CBRS_FLYBY);
   #endif

   return TRUE;
}


void CMainFrame::OnUpdateControlStyleBarMenu(CCmdUI* pCmdUI)
{
    pCmdUI->m_nID= IDW_STYLEBAR;
    CFrameWnd::OnUpdateControlBarMenu(pCmdUI);
}

void CMainFrame::OnUpdateControlDrawBarMenu(CCmdUI* pCmdUI)
{
    pCmdUI->m_nID= IDW_DRAWBAR;
    CFrameWnd::OnUpdateControlBarMenu(pCmdUI);
}

//-----------------------------------------------------------------------------------
BOOL CMainFrame::OnStyleBarCheck(UINT nID)
{
    return CFrameWnd::OnBarCheck(IDW_STYLEBAR);
}


//-----------------------------------------------------------------------------------
BOOL CMainFrame::OnDrawBarCheck(UINT nID)
{
    return CFrameWnd::OnBarCheck(IDW_DRAWBAR);
}



//-----------------------------------------------------------------------------------
LRESULT CMainFrame::OnAWCPEActivate(WPARAM wParam, LPARAM lParam)
{
   SetForegroundWindow();
   if (IsIconic())
       ShowWindow(SW_NORMAL);
   return 1L;
}


//----------------------------------------------------------------------------
void CMainFrame::OnDropDownFontName()
{
}


//----------------------------------------------------------------------------
void CMainFrame::OnDropDownFontSize()
{
   CString szFontName;

   CString sz;
   m_StyleBar.m_cboxFontSize.GetWindowText(sz);

   int iSel = m_StyleBar.m_cboxFontName.GetCurSel();
   if ( iSel != CB_ERR)
       m_StyleBar.m_cboxFontName.GetLBText(iSel,szFontName);
   else
       m_StyleBar.m_cboxFontName.GetWindowText(szFontName);

   m_StyleBar.m_cboxFontSize.EnumFontSizes(szFontName);
   if (sz.GetLength()>0)
       m_StyleBar.m_cboxFontSize.SetWindowText(sz);
}


//-----------------------------------------------------------------------------------
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
     if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

     if (!CreateStyleBar())
        return -1;
     if (!CreateDrawToolBar())
        return -1;

     if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))  {
        TRACE(TEXT("Failed to create status bar\n"));
        return -1;      // fail to create
     }

//   UINT nID, nStyle;
//       int cxWidth;
//   m_wndStatusBar.GetPaneInfo( 1, nID, nStyle, cxWidth);
//       m_wndStatusBar.SetPaneInfo( 1, nID, nStyle, 100);

        // set toolbar(small) icon
        SendMessage( WM_SETICON, (WPARAM)TRUE, (LPARAM)m_toolbar_icon );

     return 0;
}

//----------------------------------------------------------------------------------------------
void CMainFrame::OnShowTips()
{
    CSplashTipsDlg m_SplashDlg;
    m_SplashDlg.DoModal();
}


//----------------------------------------------------------------------------------------------
BOOL CMainFrame::PreTranslateMessage(MSG* pMsg)
{
   BOOL bReturn;
   if ((CDrawView::GetView() && CDrawView::GetView()->m_pObjInEdit))
       bReturn = FALSE;
   else
       bReturn = CFrameWnd::PreTranslateMessage(pMsg);

   return bReturn;
}


///////////#ifdef ENABLE_HELP  ///// Just Do It!
//----------------------------------------------------------------------------------------------
//LRESULT CMainFrame::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
//{
//    ::WinHelp( (HWND)wParam,  AfxGetApp()->m_pszHelpFilePath,  HELP_CONTEXTMENU,
//               (DWORD)(LPSTR)cshelp_map );
//
//        return( 0 );
//}
//////////////#endif


//----------------------------------------------------------------------------------------------
LRESULT CMainFrame::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{   
#ifndef NT5BETA2
    ::HtmlHelp( m_hWnd,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#else
    ::HtmlHelpA( m_hWnd,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#endif

    return 0;
}
 
//----------------------------------------------------------------------------------------------
void CMainFrame::OnHelp()
{
#ifndef NT5BETA2
    ::HtmlHelp( m_hWnd,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
#else
    ::HtmlHelpA( m_hWnd,
                 GetApp()->GetHtmlHelpFile(),
                 HH_DISPLAY_TOPIC, 0L);
#endif

}

//----------------------------------------------------------------------------------------------
void CMainFrame::OnInitMenu(CMenu* pPopupMenu)
{
   m_mainmenu = ::GetMenu(m_hWnd);
   CFrameWnd::OnInitMenu(pPopupMenu);
}

//----------------------------------------------------------------------------------------------
// This is mostly code lifted from MFC's WINFRM.CPP.  It's to enable the app to display text for
// POPUPs.
//----------------------------------------------------------------------------------------------
void CMainFrame::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hmenu)
{
        // set the tracking state (update on idle)
        if (nFlags == 0xFFFF) {
                // cancel menu operation (go back to idle now)
                CFrameWnd* pFrameWnd = GetTopLevelFrame();
                ASSERT_VALID(pFrameWnd);
                if (!pFrameWnd->m_bHelpMode)
                        m_nIDTracking = AFX_IDS_IDLEMESSAGE;
                else
                        m_nIDTracking = AFX_IDS_HELPMODEMESSAGE;
                SendMessage(WM_SETMESSAGESTRING, (WPARAM)m_nIDTracking);
                ASSERT(m_nIDTracking == m_nIDLastMessage);

                // update right away
                CWnd* pWnd = GetMessageBar();
                if (pWnd != NULL)
                        pWnd->UpdateWindow();
        }
        else
        if ( nFlags & (MF_SEPARATOR|MF_MENUBREAK|MF_MENUBARBREAK))      {
                m_nIDTracking = 0;
        }
        else
        if (nFlags & (MF_POPUP)) {    //added this to track POPUPs
        if (hmenu==m_mainmenu) {
               m_iTop=nItemID;
                   m_iSecond=-1;
            }
            else
               m_iSecond=nItemID;

        PopupText();
        }
        else
        if (nItemID >= 0xF000 && nItemID < 0xF1F0) { // max of 31 SC_s
                // special strings table entries for system commands
                m_nIDTracking = ID_COMMAND_FROM_SC(nItemID);
                ASSERT(m_nIDTracking >= AFX_IDS_SCFIRST &&
                        m_nIDTracking < AFX_IDS_SCFIRST + 31);
        }
        else
        if (nItemID >= AFX_IDM_FIRST_MDICHILD)  {
                // all MDI Child windows map to the same help id
                m_nIDTracking = AFX_IDS_MDICHILD;
        }
        else {
                // track on idle
                m_nIDTracking = nItemID;
        }

        // when running in-place, it is necessary to cause a message to
        //  be pumped through the queue.
        if (m_nIDTracking != m_nIDLastMessage && GetParent() != NULL) {
                PostMessage(WM_KICKIDLE);
        }
}


//----------------------------------------------------------------------------------------------
void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
   CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
}


//----------------------------------------------------------------------------------------------
void CMainFrame::PopupText()
{
   if (m_iTop<0 || m_iTop > 10 || m_iSecond > 10 || m_iSecond < -1)
      return;

   CString sz;

   if (m_iTop==0) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_FILE_MENU);
   }
   else
   if (m_iTop==1) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_EDIT_MENU);
   }
   else
   if (m_iTop==2) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_VIEW_MENU);
   }
   else
   if (m_iTop==3) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_INSERT_MENU);
      else
      if (m_iSecond==0)
         sz.LoadString(IDP_RECIPIENT);
      else
      if (m_iSecond==1)
         sz.LoadString(IDP_SENDER);
      else
      if (m_iSecond==2)
         sz.LoadString(IDP_MESSAGE);
   }
   else
   if (m_iTop==4) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_FORMAT_MENU);
      else
      if (m_iSecond==1)
         sz.LoadString(IDP_ALIGN_TEXT);
   }
   else
   if (m_iTop==5) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_LAYOUT_MENU);
      else
      if (m_iSecond==3)
         sz.LoadString(IDP_ALIGN_OBJECTS);
      else
      if (m_iSecond==4)
         sz.LoadString(IDP_SPACE_EVEN);
      else
      if (m_iSecond==5)
         sz.LoadString(IDP_CENTER_PAGE);
   }
   else
   if (m_iTop==6) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_HELP_MENU);
   }

   m_wndStatusBar.SetPaneText(0,sz);
}

#ifdef _DEBUG
//----------------------------------------------------------------------------------------------
void CMainFrame::AssertValid() const
{
        CFrameWnd::AssertValid();
}



//----------------------------------------------------------------------------------------------
void CMainFrame::Dump(CDumpContext& dc) const
{
        CFrameWnd::Dump(dc);
}

#endif //_DEBUG




BOOL CMainFrame::OnQueryOpen( void )
        {

    return( !(theApp.m_bCmdLinePrint || (theApp.m_dwSesID!=0)) );

        }



void CMainFrame::ActivateFrame( int nCmdShow )
        {

    if( theApp.m_bCmdLinePrint || (theApp.m_dwSesID!=0) )
                {
                //::MessageBeep( 0xffffffff );
                ShowWindow( SW_HIDE );
                }
        else
                CFrameWnd::ActivateFrame( nCmdShow );

        }




//--------------------------------------------------------------------------------------------
BOOL CStyleBar::PreTranslateMessage(MSG* pMsg)
{
         if (!( (pMsg->message == WM_KEYDOWN) && ((pMsg->wParam == VK_RETURN)||(pMsg->wParam == VK_ESCAPE)) ))
                return CToolBar::PreTranslateMessage(pMsg);

     CDrawView* pView = CDrawView::GetView();
         if (pView==NULL)
                return CToolBar::PreTranslateMessage(pMsg);

     if (pMsg->wParam == VK_ESCAPE) {
        pView->m_bFontChg=FALSE;
        pView->UpdateStyleBar();
        if (pView->m_pObjInEdit)
           pView->m_pObjInEdit->m_pEdit->SetFocus();
                else
           pView->SetFocus();
                return CToolBar::PreTranslateMessage(pMsg);
         }

         HWND hwndFontNameEdit=::GetDlgItem(m_cboxFontName.m_hWnd,1001);
         if (pMsg->hwnd == hwndFontNameEdit) {
                  pView->OnSelchangeFontName();
         }
         else {
       HWND hwndFontSizeEdit=::GetDlgItem(m_cboxFontSize.m_hWnd,1001);
       if (pMsg->hwnd == hwndFontSizeEdit)
          pView->OnSelchangeFontSize();
         }

     return CToolBar::PreTranslateMessage(pMsg);
}


//--------------------------------------------------------------------------
void CSizeComboBox::EnumFontSizes(CString& szFontName)
{
   CClientDC dc(NULL);
   m_nLogVert=dc.GetDeviceCaps(LOGPIXELSY);

   ResetContent();

   ::EnumFontFamilies(dc.GetSafeHdc(), szFontName, (FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);
}


//--------------------------------------------------------------------------
void CSizeComboBox::InsertSize(int nSize)
{
    ASSERT(nSize > 0);

    TCHAR buf[10];
    wsprintf(buf,TEXT("%d"),nSize);

    if (FindStringExact(-1,buf) == CB_ERR)  {
            AddString(buf);
    }
}

//-------------------------------------------------------------------
BOOL CALLBACK CSizeComboBox::EnumSizeCallBack(LOGFONT FAR*, LPNEWTEXTMETRIC lpntm, int FontType, LPVOID lpv)
{
   CSizeComboBox* pThis = (CSizeComboBox*)lpv;
   TCHAR buf[10];                                //????????????????????????????????
   if ( (FontType & TRUETYPE_FONTTYPE) ||
        !( (FontType & TRUETYPE_FONTTYPE) || (FontType & RASTER_FONTTYPE) ) ) {

        if (pThis->GetCount() != 0)
           pThis->ResetContent();

        for (int i = 0; nFontSizes[i]!=0; i++) {
            wsprintf(buf,TEXT("%d"),nFontSizes[i]);      //????????????????????Not changed. J.R.
                pThis->AddString(buf);
        }
            return FALSE;
   }

   int pointsize = MulDiv( (lpntm->tmHeight - lpntm->tmInternalLeading),72,pThis->m_nLogVert);
   pThis->InsertSize(pointsize);
   return TRUE;
}


//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
   ON_WM_CREATE()
   ON_UPDATE_COMMAND_UI(ID_VIEW_STYLEBAR, OnUpdateControlStyleBarMenu)
   ON_COMMAND_EX(ID_VIEW_STYLEBAR, OnStyleBarCheck)
   ON_UPDATE_COMMAND_UI(ID_VIEW_DRAWBAR, OnUpdateControlDrawBarMenu)
   ON_COMMAND_EX(ID_VIEW_DRAWBAR, OnDrawBarCheck)
   //}}AFX_MSG_MAP
   ON_COMMAND(ID_SHOW_TIPS, OnShowTips)
   ON_CBN_DROPDOWN(ID_FONT_NAME, OnDropDownFontName)
   ON_CBN_DROPDOWN(ID_FONT_SIZE, OnDropDownFontSize)
   ON_WM_INITMENUPOPUP()
   ON_WM_MENUSELECT()
   ON_WM_INITMENU()

   ON_COMMAND(ID_DEFAULT_HELP, OnHelp)    /// a-juliar, 6-18-96
   ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)     /// added by a-juliar, 6-18-96
   ON_REGISTERED_MESSAGE(WM_AWCPEACTIVATE, OnAWCPEActivate)
   ON_WM_QUERYOPEN()
// These next three lines were commented out in the code I inherited.  Let's try them!
// a-juliar, 6-18-96
   ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
   ON_COMMAND(ID_HELP, OnHelp)
   ON_COMMAND(ID_CONTEXT_HELP, OnContextHelp)

/////////#ifdef ENABLE_HELP  ///////
////        ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
/////////#endif

   ON_COMMAND(ID_HELP_INDEX, OnHelp)
   ON_MESSAGE( WM_HELP, OnWM_HELP )

END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxcover\src\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE 2.0 support
#include <afxodlgs.h>       // MFC OLE 2.0 dialog support
#include <oledlg.h>         // MFC OLE dialog support
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxisapi\routing.cpp ===
#include "isapi.h"
#pragma hdrstop


BOOL
IsapiFaxGetRoutingInfo(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_GET_ROUTINGINFO iFaxGetRoutingInfo = (PIFAX_GET_ROUTINGINFO) Ecb->lpbData;

    LPBYTE RoutingInfoBuffer = NULL;
    DWORD RoutingInfoBufferSize = 0;

    if (!FaxGetRoutingInfoW(
            iFaxGetRoutingInfo->FaxPortHandle,
            iFaxGetRoutingInfo->RoutingGuid,
            &RoutingInfoBuffer,
            &RoutingInfoBufferSize
            ))
    {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    SendResponseWithData( Ecb, (LPBYTE) &RoutingInfoBufferSize, sizeof(DWORD) );
    SendResponseWithData( Ecb, (LPBYTE) RoutingInfoBuffer, RoutingInfoBufferSize );

    FaxFreeBuffer( RoutingInfoBuffer );

    return TRUE;
}


static
DWORD
BufferSize(
   PFAX_ROUTING_METHODW RoutingMethod,
   DWORD MethodCount
   )
{
    DWORD i;
    DWORD Size = 0;

    for (i=0; i<MethodCount; i++) {
        Size += sizeof(FAX_ROUTING_METHODW);
        Size += StringSize( RoutingMethod[i].DeviceName );
        Size += StringSize( RoutingMethod[i].Guid );
        Size += StringSize( RoutingMethod[i].FriendlyName );
        Size += StringSize( RoutingMethod[i].FunctionName );
        Size += StringSize( RoutingMethod[i].ExtensionImageName );
        Size += StringSize( RoutingMethod[i].ExtensionFriendlyName );
    }

    return Size;
}


BOOL
IsapiFaxEnumRoutingMethods(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_GENERAL iFaxGeneral = (PIFAX_GENERAL) Ecb->lpbData;

    PFAX_ROUTING_METHODW RoutingMethod = NULL;
    DWORD MethodsReturned = 0;

    if (!FaxEnumRoutingMethodsW( iFaxGeneral->FaxHandle, (LPBYTE*)&RoutingMethod, &MethodsReturned )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    DWORD Size = BufferSize( RoutingMethod, MethodsReturned );

    for (DWORD i=0; i<MethodsReturned; i++) {
        RoutingMethod[i].DeviceName = (LPWSTR) ((DWORD)RoutingMethod[i].DeviceName - (DWORD)RoutingMethod);
        RoutingMethod[i].Guid = (LPWSTR) ((DWORD)RoutingMethod[i].Guid - (DWORD)RoutingMethod);
        RoutingMethod[i].FriendlyName = (LPWSTR) ((DWORD)RoutingMethod[i].FriendlyName - (DWORD)RoutingMethod);
        RoutingMethod[i].FunctionName = (LPWSTR) ((DWORD)RoutingMethod[i].FunctionName - (DWORD)RoutingMethod);
        RoutingMethod[i].ExtensionImageName = (LPWSTR) ((DWORD)RoutingMethod[i].ExtensionImageName - (DWORD)RoutingMethod);
        RoutingMethod[i].ExtensionFriendlyName = (LPWSTR) ((DWORD)RoutingMethod[i].ExtensionFriendlyName - (DWORD)RoutingMethod);
    }

    SendResponseWithData( Ecb, (LPBYTE) &MethodsReturned, sizeof(DWORD) );
    SendResponseWithData( Ecb, (LPBYTE) RoutingMethod, Size );

    FaxFreeBuffer( RoutingMethod );

    return TRUE;
}


BOOL
IsapiFaxEnableRoutingMethod(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_ENABLE_ROUTING_METHOD iFaxEnableRouting = (PIFAX_ENABLE_ROUTING_METHOD) Ecb->lpbData;

    if (!FaxEnableRoutingMethodW(
            iFaxEnableRouting->FaxPortHandle,
            iFaxEnableRouting->RoutingGuid,
            iFaxEnableRouting->Enabled))
    {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxisapi\faxisapi.cpp ===
#include "isapi.h"
#pragma hdrstop


HINSTANCE hInstance;


extern "C"
DWORD
FaxIsapiDllInit(
    HINSTANCE hModule,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        hInstance = hModule;
        DisableThreadLibraryCalls( hInstance );
    }

    if (Reason == DLL_PROCESS_DETACH) {
    }

    return TRUE;
}


BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO  *pVer
    )
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );
    strncpy( pVer->lpszExtensionDesc, "Fax ISAPI DLL", HSE_MAX_EXT_DLL_NAME_LEN );

    HeapInitialize( NULL, NULL, NULL, 0 );

    return TRUE;
}


BOOL WINAPI
TerminateExtension(
    DWORD dwFlags
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxisapi\isapi.h ===
#include <windows.h>
#include <httpext.h>
#include <stdio.h>
#include <tchar.h>

#include "faxutil.h"
#include "faxisapi.h"
#include "winfax.h"
#include "winfaxp.h"


#define FixupStringOut(_s,_buf) if ((_s)) { (_s) = (LPWSTR) ((DWORD)(_s) - (DWORD)(_buf)); }
#define FixupStringIn(_s,_buf)  if ((_s)) { (_s) = (LPWSTR) ((DWORD)(_s) + (DWORD)(_buf)); }



BOOL
SendHeaders(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxConnect(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxDisConnect(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxEnumPorts(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
SendError(
    LPEXTENSION_CONTROL_BLOCK Ecb,
    DWORD ErrorCode
    );

BOOL
SendResponseWithData(
    LPEXTENSION_CONTROL_BLOCK Ecb,
    LPBYTE Data,
    DWORD DataSize
    );

BOOL
SendResponse(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxGetPort(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxOpenPort(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxSetPort(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxClose(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxGetRoutingInfo(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxEnumRoutingMethods(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxEnableRoutingMethod(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxGetDeviceStatus(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );

BOOL
IsapiFaxGetVersion(
    LPEXTENSION_CONTROL_BLOCK Ecb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxisapi\extproc.cpp ===
#include "isapi.h"
#pragma hdrstop


#define MIN_RESPONSE "Content-type: text/html\r\n\r\n"



BOOL
SendHeaders(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    DWORD Length;
    DWORD ec;


    Length = strlen(MIN_RESPONSE);
    if (!Ecb->ServerSupportFunction( Ecb->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, &Length, (LPDWORD) MIN_RESPONSE )) {
        ec = GetLastError();
        return FALSE;
    }

    return TRUE;
}


BOOL
SendError(
    LPEXTENSION_CONTROL_BLOCK Ecb,
    DWORD ErrorCode
    )
{
    IFAX_RESPONSE_HEADER Response;

    Response.Size      = sizeof(IFAX_RESPONSE_HEADER);
    Response.ErrorCode = ErrorCode;

    DWORD Length = sizeof(IFAX_RESPONSE_HEADER);
    return Ecb->WriteClient( Ecb->ConnID, &Response, &Length, 0 );
}


BOOL
SendResponse(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    DWORD Length = sizeof(IFAX_RESPONSE_HEADER);

    IFAX_RESPONSE_HEADER Response;

    Response.Size      = Length;
    Response.ErrorCode = 0;

    return Ecb->WriteClient( Ecb->ConnID, &Response, &Length, 0 );
}


BOOL
SendResponseWithData(
    LPEXTENSION_CONTROL_BLOCK Ecb,
    LPBYTE Data,
    DWORD DataSize
    )
{
    DWORD Length = sizeof(IFAX_RESPONSE_HEADER) + DataSize;

    PIFAX_RESPONSE_HEADER Response = (PIFAX_RESPONSE_HEADER) MemAlloc( Length );
    if (!Response) {
        return FALSE;
    }

    Response->Size      = Length;
    Response->ErrorCode = 0;

    CopyMemory( (LPBYTE)((LPBYTE)Response+sizeof(IFAX_RESPONSE_HEADER)), Data, DataSize );

    BOOL Rval = Ecb->WriteClient( Ecb->ConnID, Response, &Length, 0 );

    MemFree( Response );

    return Rval;
}


DWORD
HttpExtensionProc(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    DWORD Command = *((LPDWORD)Ecb->lpbData);
    LPBYTE Data = (LPBYTE)(((LPBYTE)Ecb->lpbData)+sizeof(DWORD));
    DWORD Rval = HSE_STATUS_SUCCESS;


    DebugPrint(( L"HttpExtensionProc(): ConnId=0x%08x, Command=0x%08x", Ecb->ConnID, Command ));

    Ecb->dwHttpStatusCode = 0;

    if (!SendHeaders( Ecb )) {
        return FALSE;
    }

    Ecb->dwHttpStatusCode = 200;

    switch (Command) {
        case ICMD_CONNECT:
            if (!IsapiFaxConnect( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_DISCONNECT:
            if (!IsapiFaxDisConnect( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_ENUM_PORTS:
            if (!IsapiFaxEnumPorts( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_GET_PORT:
            if (!IsapiFaxGetPort( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_SET_PORT:
            if (!IsapiFaxSetPort( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_OPEN_PORT:
            if (!IsapiFaxOpenPort( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_CLOSE:
            if (!IsapiFaxClose( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_GET_ROUTINGINFO:
            if (!IsapiFaxGetRoutingInfo( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_GET_DEVICE_STATUS:
            if (!IsapiFaxGetDeviceStatus( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_ENUM_ROUTING_METHODS:
            if (!IsapiFaxEnumRoutingMethods( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_ENABLE_ROUTING_METHOD:
            if (!IsapiFaxEnableRoutingMethod( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        case ICMD_GET_VERSION:
            if (!IsapiFaxGetVersion( Ecb )) {
                Rval = HSE_STATUS_ERROR;
            }
            break;

        default:
            break;
    }

    DebugPrint(( L"HttpExtensionProc(): ConnId=0x%08x, Rval=0x%08x", Ecb->ConnID, Rval ));

    return Rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxisapi\port.cpp ===
#include "isapi.h"
#pragma hdrstop


static
DWORD
BufferSize(
    PFAX_PORT_INFOW PortInfo,
    DWORD PortCount
    )
{
    DWORD i;
    DWORD Size = 0;

    for (i=0; i<PortCount; i++) {
        Size += sizeof(FAX_PORT_INFOW);
        Size += StringSize( PortInfo[i].DeviceName );
        Size += StringSize( PortInfo[i].Tsid );
        Size += StringSize( PortInfo[i].Csid );
    }

    return Size;
}


BOOL
IsapiFaxEnumPorts(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    LPBYTE Data = (LPBYTE)(((LPBYTE)Ecb->lpbData)+sizeof(DWORD));
    HANDLE FaxHandle;
    PFAX_PORT_INFOW PortInfo = NULL;
    DWORD PortsReturned = 0;


    FaxHandle = (HANDLE) *((LPDWORD)Data);

    if (!FaxEnumPortsW( FaxHandle, (LPBYTE*)&PortInfo, &PortsReturned )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    DWORD Size = BufferSize( PortInfo, PortsReturned );

    for (DWORD i=0; i<PortsReturned; i++) {
        FixupStringOut( PortInfo[i].DeviceName, PortInfo );
        FixupStringOut( PortInfo[i].Tsid, PortInfo );
        FixupStringOut( PortInfo[i].Csid, PortInfo );
    }

    SendResponseWithData( Ecb, (LPBYTE) &PortsReturned, sizeof(DWORD) );
    SendResponseWithData( Ecb, (LPBYTE) PortInfo, Size );

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


BOOL
IsapiFaxGetPort(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_GENERAL iFaxGeneral = (PIFAX_GENERAL) Ecb->lpbData;

    PFAX_PORT_INFOW PortInfo = NULL;

    if (!FaxGetPortW( iFaxGeneral->FaxHandle, (LPBYTE*)&PortInfo )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    DWORD Size = BufferSize( PortInfo, 1 );

    FixupStringOut( PortInfo->DeviceName, PortInfo );
    FixupStringOut( PortInfo->Tsid, PortInfo );
    FixupStringOut( PortInfo->Csid, PortInfo );

    SendResponseWithData( Ecb, (LPBYTE) PortInfo, Size );

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


BOOL
IsapiFaxSetPort(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_SET_PORT iFaxSetPort = (PIFAX_SET_PORT) Ecb->lpbData;

    FixupStringIn( iFaxSetPort->PortInfo.DeviceName, &iFaxSetPort->PortInfo );
    FixupStringIn( iFaxSetPort->PortInfo.Tsid, &iFaxSetPort->PortInfo );
    FixupStringIn( iFaxSetPort->PortInfo.Csid, &iFaxSetPort->PortInfo );

    if (!FaxSetPortW( iFaxSetPort->FaxPortHandle, (LPBYTE)&iFaxSetPort->PortInfo )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    return TRUE;
}


BOOL
IsapiFaxOpenPort(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_OPEN_PORT iFaxOpenPort = (PIFAX_OPEN_PORT) Ecb->lpbData;

    HANDLE FaxPortHandle = NULL;

    if (!FaxOpenPort(
        iFaxOpenPort->FaxHandle,
        iFaxOpenPort->DeviceId,
        iFaxOpenPort->Flags,
        &FaxPortHandle ))
    {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    SendResponseWithData( Ecb, (LPBYTE) &FaxPortHandle, sizeof(DWORD) );

    return TRUE;
}


DWORD
DeviceStatusSize(
    PFAX_DEVICE_STATUSW DeviceStatus
    )
{
    DWORD Size = sizeof(FAX_DEVICE_STATUSW);

    Size += StringSize( DeviceStatus->CallerId );
    Size += StringSize( DeviceStatus->Csid );
    Size += StringSize( DeviceStatus->DeviceName );
    Size += StringSize( DeviceStatus->DocumentName );
    Size += StringSize( DeviceStatus->PhoneNumber );
    Size += StringSize( DeviceStatus->RoutingString );
    Size += StringSize( DeviceStatus->SenderName );
    Size += StringSize( DeviceStatus->RecipientName );
    Size += StringSize( DeviceStatus->StatusString );
    Size += StringSize( DeviceStatus->Tsid );

    return Size;
}


BOOL
IsapiFaxGetDeviceStatus(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_GENERAL iFaxGeneral = (PIFAX_GENERAL) Ecb->lpbData;

    PFAX_DEVICE_STATUSW DeviceStatus = NULL;

    if (!FaxGetDeviceStatusW( iFaxGeneral->FaxHandle, (LPBYTE*) &DeviceStatus )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    DWORD Size = DeviceStatusSize( DeviceStatus );

    FixupStringOut( DeviceStatus->CallerId, DeviceStatus );
    FixupStringOut( DeviceStatus->Csid, DeviceStatus );
    FixupStringOut( DeviceStatus->DeviceName, DeviceStatus );
    FixupStringOut( DeviceStatus->DocumentName, DeviceStatus );
    FixupStringOut( DeviceStatus->PhoneNumber, DeviceStatus );
    FixupStringOut( DeviceStatus->RoutingString, DeviceStatus );
    FixupStringOut( DeviceStatus->SenderName, DeviceStatus );
    FixupStringOut( DeviceStatus->RecipientName, DeviceStatus );
    FixupStringOut( DeviceStatus->StatusString, DeviceStatus );
    FixupStringOut( DeviceStatus->Tsid, DeviceStatus );

    SendResponseWithData( Ecb, (LPBYTE) DeviceStatus, Size );

    FaxFreeBuffer( DeviceStatus );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxisapi\server.cpp ===
#include "isapi.h"
#pragma hdrstop


BOOL
IsapiFaxConnect(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    LPBYTE Data = (LPBYTE)(((LPBYTE)Ecb->lpbData)+sizeof(DWORD));
    HANDLE FaxHandle;


    if (!FaxConnectFaxServer( (LPWSTR) Data, &FaxHandle )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    return SendResponseWithData( Ecb, (LPBYTE)&FaxHandle, sizeof(FaxHandle) );
}


BOOL
IsapiFaxDisConnect(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    LPBYTE Data = (LPBYTE)(((LPBYTE)Ecb->lpbData)+sizeof(DWORD));
    HANDLE FaxHandle;


    FaxHandle = (HANDLE) *((LPDWORD)Data);

    if (!FaxClose( FaxHandle )) {
        return FALSE;
    }

    return TRUE;
}


BOOL
IsapiFaxClose(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_GENERAL iFaxGeneral = (PIFAX_GENERAL) Ecb->lpbData;
    return FaxClose( iFaxGeneral->FaxHandle );
}


BOOL
IsapiFaxGetVersion(
    LPEXTENSION_CONTROL_BLOCK Ecb
    )
{
    PIFAX_GENERAL iFaxGeneral = (PIFAX_GENERAL) Ecb->lpbData;

    DWORD Version = 0;

    if (!FaxGetVersion( iFaxGeneral->FaxHandle, &Version )) {
        SendError( Ecb, GetLastError() );
        return FALSE;
    }

    SendResponseWithData( Ecb, (LPBYTE) &Version, sizeof(DWORD) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxqueue\faxqueue.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

  faxqueue.h

Abstract:

  This module contains the definitions for faxqueue.cpp

Environment:

  WIN32 User Mode

Author:

  Wesley Witt (wesw) 9-june-1997
  Steven Kehrli (steveke) 30-oct-1998 - major rewrite

--*/

#ifndef _FAXQUEUE_H
#define _FAXQUEUE_H

#include <windows.h>
#include <tchar.h>
#include <commctrl.h>
#include <winspool.h>
#include <shellapi.h>
#include <stdlib.h>
#include <search.h>
#include <winfax.h>

#include "resource.h"
#include "faxreg.h"
#include "faxhelp.h"
#include "faxutil.h"

// The following enum is used to identify the columns in the list view
enum eListViewColumnIndex
{
    eDocumentName = 0,
    eJobType,
    eStatus,
    eOwner,
    ePages,
    eSize,
    eScheduledTime,
    ePort,
    eIllegalColumnIndex  // Indicates that the column index is illegal
};

typedef struct _WINPOSINFO {
#ifdef DEBUG
    BOOL             bDebug;
#endif // DEBUG
#ifdef TOOLBAR_ENABLED
    BOOL             bToolbarVisible;
#endif // TOOLBAR_ENABLED
    BOOL             bStatusBarVisible;
    DWORD            ColumnWidth[eIllegalColumnIndex];
    WINDOWPLACEMENT  WindowPlacement;
} WINPOSINFO, *PWINPOSINFO;

#ifdef TOOLBAR_ENABLED
typedef struct _TOOLBAR_MENU_STATE {
    DWORD  CommandId;
    BOOL   Enabled;
    BOOL   Toolbar;
} TOOLBAR_MENU_STATE, *PTOOLBAR_MENU_STATE;
#endif // TOOLBAR_ENABLED

typedef struct _PROCESS_INFO_ITEM {
    LIST_ENTRY       ListEntry;
    LPTSTR           szPrinterName;
    HANDLE           hProcess;
    HWND             hWnd;
} PROCESS_INFO_ITEM, *PPROCESS_INFO_ITEM;

typedef struct _JOB_ID_ITEM {
    LIST_ENTRY       ListEntry;
    DWORD            dwJobId;
} JOB_ID_ITEM, *PJOB_ID_ITEM;

typedef struct _PORT_JOB_INFO_ITEM {
    LIST_ENTRY       ListEntry;
    DWORD            dwDeviceId;
    LPTSTR           szDeviceName;
    DWORD            dwJobId;
} PORT_JOB_INFO_ITEM, *PPORT_JOB_INFO_ITEM;

#ifdef WIN95
#define FAX_DRIVER_NAME         TEXT("Windows NT Fax Driver")
#else
#define FAX_DRIVER_NAME         TEXT("Windows NT Fax Driver")
#endif // WIN95

#define FAXQUEUE_WINCLASS       TEXT("FaxQueueWinClass")
#define RESOURCE_STRING_LEN     256

#define UM_SELECT_FAX_PRINTER   (WM_USER + 1)

#define ITEM_SEND_MASK          0x100
#define ITEM_IDLE_MASK          0x200
#define ITEM_PAUSED_MASK        0x400
#define ITEM_USEROWNSJOB_MASK   0x800

extern HINSTANCE  g_hInstance;            // g_hInstance is the handle to the instance
extern HWND       g_hWndMain;             // g_hWndMain is the handle to the parent window
extern HWND       g_hWndListView;         // g_hWndListView is the handle to the list view window

extern HWND       g_hWndToolbar;          // g_hWndToolbar is the handle to the toolbar

extern LPTSTR     g_szTitleConnected;     // g_szTitleConnected is the window title when connected
extern LPTSTR     g_szTitleNotConnected;  // g_szTitleNotConnected is the window title when not connected
extern LPTSTR     g_szTitleConnecting;    // g_szTitleConnecting is the window title when connecting
extern LPTSTR     g_szTitleRefreshing;    // g_szTitleRefreshing is the window title when refreshing
extern LPTSTR     g_szTitlePaused;        // g_szTitlePaused is the window title when paused

extern LPTSTR     g_szCurrentUserName;    // g_szCurrentUserName is the name of the current user

extern HANDLE     g_hStartEvent;          // g_hStartEvent is the handle to an event indicating the fax event queue exists
extern HANDLE     g_hExitEvent;           // g_hExitEvent is the handle to an event indicating the application is exiting

extern LPTSTR     g_szMachineName;        // g_szMachineName is the machine to connect to
extern HANDLE     g_hFaxSvcMutex;         // g_hFaxSvcMutex is an object to synchronize access to the fax service routines
extern HANDLE     g_hFaxSvcHandle;        // g_hFaxSvcHandle is the handle to the fax service
extern LONG       g_nNumConnections;      // g_nNumConnections is the number of connections to the fax service
extern HANDLE     g_hCompletionPort;      // g_hCompletionPort is the handle to the completion port

extern WINPOSINFO  WinPosInfo;

extern DWORD DocumentPropertiesHelpIDs[];

// Function definitions:

VOID
GetFaxQueueRegistryData(
    PWINPOSINFO  pWinPosInfo
);

VOID
SetFaxQueueRegistryData(
#ifdef TOOLBAR_ENABLED
    BOOL  bToolbarVisible,
#endif // TOOLBAR_ENABLED
    BOOL  bStatusBarVisible,
    HWND  hWndList,
    HWND  hWnd
);

VOID
GetColumnHeaderText(
    eListViewColumnIndex  eColumnIndex,
    LPTSTR                szColumnHeader
);

LPVOID
GetFaxPrinters(
    LPDWORD  pdwNumFaxPrinters
);

LPTSTR
GetDefaultPrinterName(
);

VOID
SetDefaultPrinterName(
    LPTSTR  szPrinterName
);

PLIST_ENTRY
InsertListEntry(
    PLIST_ENTRY  pList,
    PLIST_ENTRY  pListEntry
);

PLIST_ENTRY
RemoveListEntry(
    PLIST_ENTRY  pListEntry
);

PLIST_ENTRY
FreeList(
    PLIST_ENTRY  pList
);

VOID
Disconnect(
);

BOOL
Connect(
);

LPTSTR
GetColumnItemText(
    eListViewColumnIndex  eColumnIndex,
    PFAX_JOB_ENTRY        pFaxJobEntry,
    LPTSTR                szDeviceName
);

VOID
SetColumnItem(
    HWND            hWndListView,
    BOOL            bInsert,
    INT             iItem,
    INT             iSubItem,
    LPTSTR          szColumnItem,
    UINT            uState,
    PFAX_JOB_ENTRY  pFaxJobEntry
);

#ifdef TOOLBAR_ENABLED

VOID
EnableToolbarMenuState(
    HWND   hWndToolbar,
    DWORD  dwCommand,
    BOOL   bEnable
);

HWND
CreateToolbar(
    HWND  hWnd
);

HWND
CreateToolTips(
    HWND  hWnd
);

#endif // TOOLBAR_ENABLED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxqueue\faxqueue.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

  faxqueue.cpp

Abstract:

  This module implements the fax queue viewer

Environment:

  WIN32 User Mode

Author:

  Wesley Witt (wesw) 9-june-1997
  Steven Kehrli (steveke) 30-oct-1998 - major rewrite

--*/

#include "faxqueue.h"

HINSTANCE  g_hInstance;            // g_hInstance is the handle to the instance
HWND       g_hWndMain;             // g_hWndMain is the handle to the parent window
HWND       g_hWndListView;         // g_hWndListView is the handle to the list view window

HWND       g_hWndToolbar;          // g_hWndToolbar is the handle to the toolbar

LPTSTR     g_szTitleConnected;     // g_szTitleConnected is the window title when connected
LPTSTR     g_szTitleNotConnected;  // g_szTitleNotConnected is the window title when not connected
LPTSTR     g_szTitleConnecting;    // g_szTitleConnecting is the window title when connecting
LPTSTR     g_szTitleRefreshing;    // g_szTitleRefreshing is the window title when refreshing
LPTSTR     g_szTitlePaused;        // g_szTitlePaused is the window title when paused

LPTSTR     g_szCurrentUserName;    // g_szCurrentUserName is the name of the current user

HANDLE     g_hStartEvent;          // g_hStartEvent is the handle to an event indicating the fax event queue exists
HANDLE     g_hExitEvent;           // g_hExitEvent is the handle to an event indicating the application is exiting

LPTSTR     g_szMachineName;        // g_szMachineName is the machine to connect to
HANDLE     g_hFaxSvcMutex;         // g_hFaxSvcMutex is an object to synchronize access to the fax service routines
HANDLE     g_hFaxSvcHandle;        // g_hFaxSvcHandle is the handle to the fax service
LONG       g_nNumConnections;      // g_nNumConnections is the number of connections to the fax service
HANDLE     g_hCompletionPort;      // g_hCompletionPort is the handle to the completion port

WINPOSINFO  WinPosInfo =
{
#ifdef DEBUG
    FALSE,
#endif // DEBUG
#ifdef TOOLBAR_ENABLED
    FALSE,  // toolbar
#endif // TOOLBAR_ENABLED
    TRUE,   // status bar
    200,    // eDocumentName
    80,     // eJobType
    80,     // eStatus
    80,     // eOwner
    60,     // ePages
    100,    // eSize
    140,    // eScheduledTime
    120,    // ePort
    {sizeof(WINDOWPLACEMENT), 0, SW_SHOWNORMAL, {0, 0}, {0, 0}, {50, 100, 695, 300}}
};

DWORD DocumentPropertiesHelpIDs[] =
{
    IDC_FAX_DOCUMENTNAME,         IDH_QUEUE_DOCUMENTNAME,
    IDC_FAX_RECIPIENTINFO,        IDH_QUEUE_RECIPIENTINFO,
    IDC_FAX_RECIPIENTNAME_TEXT,   IDH_QUEUE_RECIPIENTNAME,
    IDC_FAX_RECIPIENTNAME,        IDH_QUEUE_RECIPIENTNAME,
    IDC_FAX_RECIPIENTNUMBER_TEXT, IDH_QUEUE_RECIPIENTNUMBER,
    IDC_FAX_RECIPIENTNUMBER,      IDH_QUEUE_RECIPIENTNUMBER,
    IDC_FAX_SENDERINFO,           IDH_QUEUE_SENDERINFO,
    IDC_FAX_SENDERNAME_TEXT,      IDH_QUEUE_SENDERNAME,
    IDC_FAX_SENDERNAME,           IDH_QUEUE_SENDERNAME,
    IDC_FAX_SENDERCOMPANY_TEXT,   IDH_QUEUE_SENDERCOMPANY,
    IDC_FAX_SENDERCOMPANY,        IDH_QUEUE_SENDERCOMPANY,
    IDC_FAX_SENDERDEPT_TEXT,      IDH_QUEUE_SENDERDEPT,
    IDC_FAX_SENDERDEPT,           IDH_QUEUE_SENDERDEPT,
    IDC_FAX_BILLINGCODE_TEXT,     IDH_QUEUE_BILLINGCODE,
    IDC_FAX_BILLINGCODE,          IDH_QUEUE_BILLINGCODE,
    IDC_FAX_FAXINFO,              IDH_QUEUE_FAXINFO,
    IDC_FAX_JOBTYPE_TEXT,         IDH_QUEUE_JOBTYPE,
    IDC_FAX_JOBTYPE,              IDH_QUEUE_JOBTYPE,
    IDC_FAX_STATUS_TEXT,          IDH_QUEUE_STATUS,
    IDC_FAX_STATUS,               IDH_QUEUE_STATUS,
    IDC_FAX_PAGES_TEXT,           IDH_QUEUE_PAGES,
    IDC_FAX_PAGES,                IDH_QUEUE_PAGES,
    IDC_FAX_SIZE_TEXT,            IDH_QUEUE_SIZE,
    IDC_FAX_SIZE,                 IDH_QUEUE_SIZE,
    IDC_FAX_SCHEDULEDTIME_TEXT,   IDH_QUEUE_SCHEDULEDTIME,
    IDC_FAX_SCHEDULEDTIME,        IDH_QUEUE_SCHEDULEDTIME,
    0,                    0
};

// MainWndProc is the parent window procedure
LRESULT CALLBACK MainWndProc (HWND hWndMain, UINT iMsg, WPARAM wParam, LPARAM lParam);

// SelectFaxPrinterDlgProc is the select fax printer dialog procedure
INT_PTR CALLBACK SelectFaxPrinterDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

// DocumentPropertiesDlgProc is the select fax printer dialog procedure
INT_PTR CALLBACK DocumentPropertiesDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

// EnumThreadWndProc is the callback function for the EnumThreadWindows call
BOOL CALLBACK EnumThreadWndProc(HWND hWnd, LPARAM lParam);

// PostEventToCompletionPort posts an exit packet to a completion port
VOID PostEventToCompletionPort(HANDLE hCompletionPort, DWORD dwEventId, DWORD dwJobId);

// FaxEventThread is the thread to handle the fax events
DWORD FaxEventThread (LPVOID lpv);

extern "C"
int __cdecl
_tmain(
    int     argc,
    LPTSTR  argv[]
)
{
    WNDCLASSEX  wndclass;
    MSG         msg;

    // bStarted indicates if the application has started
    BOOL        bStarted;

    // szFormat is a format string
    TCHAR       szFormat[RESOURCE_STRING_LEN];

    // szComputerName is the local computer name
    LPTSTR      szComputerName;
    DWORD       dwComputerNameSize;

    // hThread is the handle to a thread
    HANDLE      hThread;
    // hAccel is the handle to the accelerators
    HACCEL      hAccel;

    DWORD       dwReturn;
    DWORD       cb;

    // Set g_hInstance
    g_hInstance = GetModuleHandle(NULL);

    // Set bStarted to FALSE to indicate the application has not started
    bStarted = FALSE;

    // Get the machine name
    g_szMachineName = NULL;
    if (argc == 2) {
        // Allocate the memory for the machine name
        g_szMachineName = (LPTSTR) MemAlloc((lstrlen(argv[1]) + 1) * sizeof(TCHAR));
        if (g_szMachineName) {
            // Copy the machine name
            lstrcpy(g_szMachineName, argv[1]);

            // Allocate the memory for the local computer name
            dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
            szComputerName = (LPTSTR) MemAlloc((MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR));
            if (szComputerName) {
                // Get the local computer name
                if (GetComputerName(szComputerName, &dwComputerNameSize)) {
                    // Compare the local computer name against the machine name
                    if (!lstrcmpi(g_szMachineName, szComputerName)) {
                        // Local computer name and machine name are the same, so set machine name to NULL
                        MemFree(g_szMachineName);
                        g_szMachineName = NULL;
                    }
                }

                MemFree(szComputerName);
            }
        }
    }

    // Set the window title when connected
    if (g_szMachineName) {
        // Convert the machine name to uppercase
        g_szMachineName = CharUpper(g_szMachineName);

        LoadString(g_hInstance, IDS_FAXQUEUE_REMOTE_CAPTION, szFormat, RESOURCE_STRING_LEN);
        // Allocate the memory for the window title
        g_szTitleConnected = (LPTSTR) MemAlloc((lstrlen(szFormat) + lstrlen(g_szMachineName) + 1) * sizeof(TCHAR));

        if (!g_szTitleConnected) {
            // Set the exit code
            dwReturn = GetLastError();

            goto ExitLevel0;
        }

        wsprintf(g_szTitleConnected, szFormat, g_szMachineName);
    }
    else {
        LoadString(g_hInstance, IDS_FAXQUEUE_LOCAL_CAPTION, szFormat, RESOURCE_STRING_LEN);
        // Allocate the memory for the window title
        g_szTitleConnected = (LPTSTR) MemAlloc((lstrlen(szFormat) + 1) * sizeof(TCHAR));

        if (!g_szTitleConnected) {
            // Set the exit code
            dwReturn = GetLastError();

            goto ExitLevel0;
        }

        lstrcpy(g_szTitleConnected, szFormat);
    }

    // Set the window title when not connected
    LoadString(g_hInstance, IDS_FAXQUEUE_NOT_CONNECTED, szFormat, RESOURCE_STRING_LEN);
    // Allocate the memory for the window title
    g_szTitleNotConnected = (LPTSTR) MemAlloc((lstrlen(g_szTitleConnected) + lstrlen(szFormat) + 1) * sizeof(TCHAR));
    if (!g_szTitleNotConnected) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel1;
    }
    lstrcpy(g_szTitleNotConnected, g_szTitleConnected);
    lstrcat(g_szTitleNotConnected, szFormat);

    // Set the window title when connecting
    LoadString(g_hInstance, IDS_FAXQUEUE_CONNECTING, szFormat, RESOURCE_STRING_LEN);
    // Allocate the memory for the window title
    g_szTitleConnecting = (LPTSTR) MemAlloc((lstrlen(g_szTitleConnected) + lstrlen(szFormat) + 1) * sizeof(TCHAR));
    if (!g_szTitleConnecting) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel2;
    }
    lstrcpy(g_szTitleConnecting, g_szTitleConnected);
    lstrcat(g_szTitleConnecting, szFormat);

    // Set the window title when refreshing
    LoadString(g_hInstance, IDS_FAXQUEUE_REFRESHING, szFormat, RESOURCE_STRING_LEN);
    // Allocate the memory for the window title
    g_szTitleRefreshing = (LPTSTR) MemAlloc((lstrlen(g_szTitleConnected) + lstrlen(szFormat) + 1) * sizeof(TCHAR));
    if (!g_szTitleRefreshing) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel3;
    }
    lstrcpy(g_szTitleRefreshing, g_szTitleConnected);
    lstrcat(g_szTitleRefreshing, szFormat);

    // Set the window title when paused
    LoadString(g_hInstance, IDS_FAXQUEUE_PAUSED, szFormat, RESOURCE_STRING_LEN);
    // Allocate the memory for the window title
    g_szTitlePaused = (LPTSTR) MemAlloc((lstrlen(g_szTitleConnected) + lstrlen(szFormat) + 1) * sizeof(TCHAR));
    if (!g_szTitlePaused) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel4;
    }
    lstrcpy(g_szTitlePaused, g_szTitleConnected);
    lstrcat(g_szTitlePaused, szFormat);

    g_hWndMain = NULL;

    // Find the window
    g_hWndMain = FindWindow(FAXQUEUE_WINCLASS, g_szTitlePaused);
    if (g_hWndMain) {
        goto ExitLevel5;
    }

    // Find the window
    g_hWndMain = FindWindow(FAXQUEUE_WINCLASS, g_szTitleRefreshing);
    if (g_hWndMain) {
        goto ExitLevel5;
    }

    // Find the window
    g_hWndMain = FindWindow(FAXQUEUE_WINCLASS, g_szTitleConnecting);
    if (g_hWndMain) {
        goto ExitLevel5;
    }

    // Find the window
    g_hWndMain = FindWindow(FAXQUEUE_WINCLASS, g_szTitleNotConnected);
    if (g_hWndMain) {
        goto ExitLevel5;
    }

    // Find the window
    g_hWndMain = FindWindow(FAXQUEUE_WINCLASS, g_szTitleConnected);
    if (g_hWndMain) {
        goto ExitLevel5;
    }

    // Create the g_hStartEvent
    g_hStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!g_hStartEvent) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel5;
    }

    // Create the g_hExitEvent
    g_hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!g_hExitEvent) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel6;
    }

    // Initialize the fax service
    g_hFaxSvcMutex = CreateMutex(NULL, FALSE, NULL);
    if (!g_hFaxSvcMutex) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel7;
    }
    g_hFaxSvcHandle = NULL;
    g_nNumConnections = 0;

    hThread = CreateThread(NULL, 0, FaxEventThread, NULL, 0, NULL);
    if (!hThread) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel8;
    }
    CloseHandle(hThread);

    // Load the accelerators
    hAccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCEL));
    if (!hAccel) {
        // Set the exit code
        dwReturn = GetLastError();

        goto ExitLevel9;
    }

    // Get the name of the current user
    cb = 0;
    GetUserName(NULL, &cb);
    g_szCurrentUserName = (LPTSTR) MemAlloc((cb + 1) * sizeof(TCHAR));
    if (!GetUserName(g_szCurrentUserName, &cb)) {
        MemFree(g_szCurrentUserName);
        g_szCurrentUserName = NULL;
    }

    // Retrieve the persistent data
    GetFaxQueueRegistryData(&WinPosInfo);

    // Initialize the common controls
    InitCommonControls();

    // Set bStarted to TRUE to indicate the application has started
    bStarted = TRUE;

    // Initialize the wndclass
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = MainWndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = g_hInstance;
    wndclass.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FAXQUEUE_ICON));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
    wndclass.lpszClassName = FAXQUEUE_WINCLASS;
    wndclass.hIconSm = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FAXQUEUE_ICON));

    RegisterClassEx(&wndclass);

    g_hWndMain = CreateWindow(FAXQUEUE_WINCLASS, g_szTitleConnecting, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, g_hInstance, NULL);

    // Move and show the window
    SetWindowPlacement(g_hWndMain, &WinPosInfo.WindowPlacement);
    ShowWindow(g_hWndMain, SW_SHOWNORMAL);
    UpdateWindow(g_hWndMain);

    // Set the start event
    SetEvent(g_hStartEvent);

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(g_hWndMain, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (g_szCurrentUserName) {
        MemFree(g_szCurrentUserName);
    }

ExitLevel9:
    SetEvent(g_hExitEvent);

ExitLevel8:
    CloseHandle(g_hFaxSvcMutex);

ExitLevel7:
    CloseHandle(g_hExitEvent);

ExitLevel6:
    CloseHandle(g_hStartEvent);

ExitLevel5:
    if ((g_hWndMain) && (!bStarted)) {
        // g_hWndMain is valid but the application has not started, so it must already be running
        // Switch to that window
        ShowWindow(g_hWndMain, SW_RESTORE);
        SetForegroundWindow(g_hWndMain);

        // Set the exit code
        dwReturn = 0;
        // Set bStarted to TRUE to indicate the application has started
        bStarted = TRUE;
    }

    MemFree(g_szTitlePaused);

ExitLevel4:
    MemFree(g_szTitleRefreshing);

ExitLevel3:
    MemFree(g_szTitleConnecting);

ExitLevel2:
    MemFree(g_szTitleNotConnected);

ExitLevel1:
    MemFree(g_szTitleConnected);

ExitLevel0:
    if (g_szMachineName) {
        MemFree(g_szMachineName);
    }

    if (!bStarted) {
        // szErrorCaption is the error caption if the application cannot start
        TCHAR       szErrorCaption[RESOURCE_STRING_LEN];
        // szErrorFormat is the format of the error message if the application cannot start
        TCHAR       szErrorFormat[RESOURCE_STRING_LEN];
        // szErrorReason is the error reason if the application cannot start
        LPTSTR      szErrorReason;
        // szErrorMessage is the error message if the application cannot start
        LPTSTR      szErrorMessage;

        // The application did not start so display an error message
        // Load the error caption
        LoadString(g_hInstance, IDS_ERROR_CAPTION, szErrorCaption, RESOURCE_STRING_LEN);

        // Try to get the error message from the system message table
        szErrorMessage = NULL;
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwReturn, 0, (LPTSTR) &szErrorReason, 0, NULL)) {
            // Load the error format
            LoadString(g_hInstance, IDS_ERROR_APP_FAILED_FORMAT, szErrorFormat, RESOURCE_STRING_LEN);

            // Allocate the memory for the error message
            szErrorMessage = (LPTSTR) MemAlloc((lstrlen(szErrorReason) + RESOURCE_STRING_LEN + 1) * sizeof(TCHAR));
            if (szErrorMessage) {
                // Set the error message
                wsprintf(szErrorMessage, szErrorFormat, szErrorReason);
            }
            LocalFree(szErrorReason);
        }

        if (!szErrorMessage) {
            // Allocate the memory for the error message
            szErrorMessage = (LPTSTR) MemAlloc((RESOURCE_STRING_LEN) * sizeof(TCHAR));
            if (szErrorMessage) {
                // Load the error message
                LoadString(g_hInstance, IDS_ERROR_APP_FAILED, szErrorMessage, RESOURCE_STRING_LEN);
            }
        }

        if (szErrorMessage) {
            // Display the error message
            MessageBox(NULL, szErrorMessage, szErrorCaption, MB_OK | MB_ICONERROR | MB_APPLMODAL);
            MemFree(szErrorMessage);
        }
    }

    return dwReturn;
}

LRESULT CALLBACK MainWndProc (HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    // rcClient is the rectangle of the client area
    RECT                rcClient;

    // hWndToolTips is the handle to the tool tips window
    static HWND         hWndToolTips;
    // rcToolbar is the rectangle of the toolbar
    static RECT         rcToolbar;

    // hWndStatusBar is the handle to the status bar
    static HWND         hWndStatusBar;
    // rcStatusBar is the rectangle of the status bar
    static RECT         rcStatusBar;

    // hFaxMenu is the handle to the fax menu
    static HMENU        hFaxMenu;
    // hFaxSetAsDefaultMenu is the handle to the set as default printer menu
    static HMENU        hFaxSetAsDefaultMenu;
    // hFaxSharingMenu is the handle to the sharing menu
    static HMENU        hFaxSharingMenu;
    // hFaxPropertiesMenu is the handle to the properties menu
    static HMENU        hFaxPropertiesMenu;

    // hDocumentMenu is the handle to the document menu
    static HMENU        hDocumentMenu;

    // hViewMenu is the handle to the view menu
    static HMENU        hViewMenu;

    // uCurrentMenu indicates the current menu selection
    static UINT         uCurrentMenu;

    // pProcessInfoList is a pointer to the process info list
    static PLIST_ENTRY  pProcessInfoList;

    switch (iMsg) {
        case WM_CREATE:
            // lvc specifies the attributes of a particular column of the list view
            LV_COLUMN  lvc;
            // nColumnIndex is used to enumerate each column of the list view
            INT        nColumnIndex;
            // szColumnHeader is the column header text
            TCHAR      szColumnHeader[RESOURCE_STRING_LEN];

            // Set pProcessInfoList to NULL
            pProcessInfoList = NULL;

            // Get the handle to the fax menu
            hFaxMenu = GetSubMenu(GetMenu(hWnd), 0);
            // Initialize the set as default printer menu
            hFaxSetAsDefaultMenu = NULL;
            // Initialize the sharing menu
            hFaxSharingMenu = NULL;
            // Initialize the properties menu
            hFaxPropertiesMenu = NULL;

            // Disable the pause faxing menu item and the cancel all faxes menu item
            EnableMenuItem(hFaxMenu, IDM_FAX_PAUSE_FAXING, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hFaxMenu, IDM_FAX_CANCEL_ALL_FAXES, MF_BYCOMMAND | MF_GRAYED);

#ifdef TOOLBAR_ENABLED
            // Disable the pause faxing toolbar menu item and the cancel all faxes toolbar menu item
            EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_PAUSE_FAXING, FALSE);
            EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_CANCEL_ALL_FAXES, FALSE);
#endif // TOOLBAR_ENABLED

#ifdef WIN95
            // Disable the sharing menu item
            EnableMenuItem(hFaxMenu, 5, MF_BYPOSITION | MF_GRAYED);
            // Disable the properties menu item
            EnableMenuItem(hFaxMenu, 7, MF_BYPOSITION | MF_GRAYED);
#endif // WIN95

            // Get the handle to the document menu
            hDocumentMenu = GetSubMenu(GetMenu(hWnd), 1);

            // Get the handle to the view menu
            hViewMenu = GetSubMenu(GetMenu(hWnd), 2);

#ifdef TOOLBAR_ENABLED
            // Set the toolbar
            if (WinPosInfo.bToolbarVisible) {
                // Show the toolbar
                hWndToolTips = CreateToolTips(hWnd);
                g_hWndToolbar = CreateToolbar(hWnd);
                // Get the rectangle of the status bar
                GetWindowRect(g_hWndToolbar, &rcToolbar);
            }
            else {
                ZeroMemory(&rcToolbar, sizeof(rcToolbar));
            }

            // Check the menu item
            CheckMenuItem(hViewMenu, IDM_VIEW_TOOLBAR, MF_BYCOMMAND | (WinPosInfo.bToolbarVisible ? MF_CHECKED : MF_UNCHECKED));
#else
            ZeroMemory(&rcToolbar, sizeof(rcToolbar));
#endif // TOOLBAR_ENABLED

            // Set the status bar
            if (WinPosInfo.bStatusBarVisible) {
                // Show the status bar
                hWndStatusBar = CreateStatusWindow(WS_CHILD | WS_CLIPSIBLINGS | WS_TABSTOP | WS_VISIBLE | SBARS_SIZEGRIP, NULL, hWnd, IDM_STATUS_BAR);
                // Get the rectangle of the status bar
                GetWindowRect(hWndStatusBar, &rcStatusBar);
            }
            else {
                ZeroMemory(&rcStatusBar, sizeof(rcStatusBar));
            }

            // Check the menu item
            CheckMenuItem(hViewMenu, IDM_VIEW_STATUS_BAR, MF_BYCOMMAND | (WinPosInfo.bStatusBarVisible ? MF_CHECKED : MF_UNCHECKED));

            // Get the rectangle of the client area
            GetClientRect(hWnd, &rcClient);
            // Create the list view control
            g_hWndListView = CreateWindowEx(WS_EX_CLIENTEDGE, WC_LISTVIEW, NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_TABSTOP | WS_VISIBLE | LVS_REPORT, 0, (rcToolbar.bottom - rcToolbar.top), rcClient.right, rcClient.bottom - (rcStatusBar.bottom - rcStatusBar.top) - (rcToolbar.bottom - rcToolbar.top), hWnd, NULL, g_hInstance, NULL);
            if (g_hWndListView) {
                ListView_SetExtendedListViewStyle(g_hWndListView, LVS_EX_FULLROWSELECT);

                // Set common attributes for each column
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.fmt = LVCFMT_LEFT;

                for (nColumnIndex = 0; nColumnIndex < (INT) eIllegalColumnIndex; nColumnIndex++) {
                    // Get the column header text
                    GetColumnHeaderText((eListViewColumnIndex) nColumnIndex, szColumnHeader);

                    // Set the column header text
                    lvc.pszText = szColumnHeader;
                    // Set the column width
                    lvc.cx = WinPosInfo.ColumnWidth[nColumnIndex];
                    // Set the column number
                    lvc.iSubItem = nColumnIndex;
                    // Insert column into list view
                    ListView_InsertColumn(g_hWndListView, lvc.iSubItem, &lvc);
                }

                SetFocus(g_hWndListView);
            }

            break;

        case WM_MENUSELECT:
            UINT  uBase;

            switch (LOWORD(wParam)) {
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_1:
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_2:
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_3:
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_4:
                    wParam = MAKELONG(LOWORD(IDM_FAX_SET_AS_DEFAULT_PRINTER), HIWORD(wParam));
                    break;

                case IDM_FAX_SHARING_1:
                case IDM_FAX_SHARING_2:
                case IDM_FAX_SHARING_3:
                case IDM_FAX_SHARING_4:
                    wParam = MAKELONG(LOWORD(IDM_FAX_SHARING), HIWORD(wParam));
                    break;

                case IDM_FAX_PROPERTIES_1:
                case IDM_FAX_PROPERTIES_2:
                case IDM_FAX_PROPERTIES_3:
                case IDM_FAX_PROPERTIES_4:
                    wParam = MAKELONG(LOWORD(IDM_FAX_PROPERTIES), HIWORD(wParam));
                    break;

                case IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE:
                case IDM_FAX_SHARING_MORE:
                case IDM_FAX_PROPERTIES_MORE:
                    wParam = MAKELONG(LOWORD(IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE), HIWORD(wParam));
                    break;
            }

            if (hWndStatusBar) {
                uBase = IDS_MENU_BASE;
                MenuHelp(iMsg, wParam, lParam, NULL, g_hInstance, hWndStatusBar, &uBase);
            }

            break;

        case WM_INITMENUPOPUP:
            if (((HMENU) wParam == hFaxMenu) && (LOWORD(lParam) == 0)) {
                // mii is the menu item info
                MENUITEMINFO      mii;
                // szMenuString is a menu string
                TCHAR             szMenuString[RESOURCE_STRING_LEN];
                // dwNumOldMenuItems is the old number of menu items
                DWORD             dwNumOldMenuItems;
                // dwNumNewMenuItems is the new number of menu items
                DWORD             dwNumNewMenuItems;

                // pFaxPrintersConfig is the pointer to the fax printers
                LPPRINTER_INFO_2  pFaxPrintersConfig;
                // dwNumFaxPrinters is the number of fax printers
                DWORD             dwNumFaxPrinters;
                // dwIndex is a counter to enumerate each menu and printer
                DWORD             dwIndex;
                // dwDefaultIndex is the index of the default fax printer
                DWORD             dwDefaultIndex;

                // szDefaultPrinterName is the default printer name
                LPTSTR            szDefaultPrinterName;

                if ((WaitForSingleObject(g_hStartEvent, 0) != WAIT_TIMEOUT) && (ListView_GetItemCount(g_hWndListView))) {
                    // Enable the cancel all faxes menu item
                    EnableMenuItem(hFaxMenu, IDM_FAX_CANCEL_ALL_FAXES, MF_BYCOMMAND | MF_ENABLED);
                }
                else {
                    // Disable the cancel all faxes menu item
                    EnableMenuItem(hFaxMenu, IDM_FAX_CANCEL_ALL_FAXES, MF_BYCOMMAND | MF_GRAYED);
                }

                // Get the default printer
                szDefaultPrinterName = GetDefaultPrinterName();

                // Get the fax printers
                pFaxPrintersConfig = (LPPRINTER_INFO_2) GetFaxPrinters(&dwNumFaxPrinters);
                if ((pFaxPrintersConfig) && (dwNumFaxPrinters > 1)) {
                    // Many fax printers, so set menu items as sub-menus
                    // Initialize the menu item info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STATE | MIIM_SUBMENU;
                    mii.fState = MFS_ENABLED;

                    // Update the set as default printer menu item
                    if (!hFaxSetAsDefaultMenu) {
                        hFaxSetAsDefaultMenu = CreatePopupMenu();

                        mii.hSubMenu = hFaxSetAsDefaultMenu;
                        SetMenuItemInfo(hFaxMenu, IDM_FAX_SET_AS_DEFAULT_PRINTER, FALSE, &mii);
                    }

                    // Update the sharing menu item
                    if (!hFaxSharingMenu) {
                        hFaxSharingMenu = CreatePopupMenu();

                        mii.hSubMenu = hFaxSharingMenu;
                        SetMenuItemInfo(hFaxMenu, IDM_FAX_SHARING, FALSE, &mii);
                    }

                    // Update the properties menu item
                    if (!hFaxPropertiesMenu) {
                        hFaxPropertiesMenu = CreatePopupMenu();

                        mii.hSubMenu = hFaxPropertiesMenu;
                        SetMenuItemInfo(hFaxMenu, IDM_FAX_PROPERTIES, FALSE, &mii);
                    }

                    // Initialize the menu item info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID | MIIM_STATE | MIIM_TYPE;
                    mii.fType = MFT_STRING;

                    // Get the number of menu items
                    dwNumOldMenuItems = (DWORD) GetMenuItemCount(hFaxSetAsDefaultMenu);

                    // Insert the default fax printer first into the menus
                    for (dwDefaultIndex = dwNumFaxPrinters, dwNumNewMenuItems = 0; (szDefaultPrinterName) && (dwDefaultIndex > 0); dwDefaultIndex--) {
                        if (!lstrcmpi(szDefaultPrinterName, pFaxPrintersConfig[dwDefaultIndex - 1].pPrinterName)) {
                            // Set the menu string
                            wsprintf(szMenuString, TEXT("&%d %s"), dwNumNewMenuItems + 1, pFaxPrintersConfig[dwDefaultIndex - 1].pPrinterName);
                            mii.fState = MFS_CHECKED | MFS_ENABLED;
                            mii.dwTypeData = szMenuString;

                            // Insert the item into the set as default printer menu
                            mii.wID = IDM_FAX_SET_AS_DEFAULT_PRINTER_1;
                            InsertMenuItem(hFaxSetAsDefaultMenu, dwNumOldMenuItems, TRUE, &mii);

                            // Insert the item into the sharing menu
                            mii.wID = IDM_FAX_SHARING_1;
                            InsertMenuItem(hFaxSharingMenu, dwNumOldMenuItems, TRUE, &mii);

                            // Insert the item into the properties menu
                            mii.wID = IDM_FAX_PROPERTIES_1;
                            InsertMenuItem(hFaxPropertiesMenu, dwNumOldMenuItems, TRUE, &mii);

                            // Increment the number of new menu items
                            dwNumNewMenuItems++;

                            break;
                        }
                    }

                    // Propagate the menus with the list of fax printers
                    mii.fState = MFS_ENABLED;
                    for (dwIndex = 0; (dwIndex < dwNumFaxPrinters) && (dwNumNewMenuItems < (IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE - IDM_FAX_SET_AS_DEFAULT_PRINTER_1)); dwIndex++) {
                        if (dwIndex != (dwDefaultIndex - 1)) {
                            // Set the menu string
                            wsprintf(szMenuString, TEXT("&%d %s"), dwNumNewMenuItems + 1, pFaxPrintersConfig[dwIndex].pPrinterName);
                            mii.dwTypeData = szMenuString;

                            // Insert the item into the set as default printer menu
                            mii.wID = (IDM_FAX_SET_AS_DEFAULT_PRINTER_1 + dwNumNewMenuItems);
                            InsertMenuItem(hFaxSetAsDefaultMenu, (dwNumOldMenuItems + dwNumNewMenuItems), TRUE, &mii);

                            // Insert the item into the sharing menu
                            mii.wID = (IDM_FAX_SHARING_1 + dwNumNewMenuItems);
                            InsertMenuItem(hFaxSharingMenu, (dwNumOldMenuItems + dwNumNewMenuItems), TRUE, &mii);

                            // Insert the item into the properties menu
                            mii.wID = (IDM_FAX_PROPERTIES_1 + dwNumNewMenuItems);
                            InsertMenuItem(hFaxPropertiesMenu, (dwNumOldMenuItems + dwNumNewMenuItems), TRUE, &mii);

                            // Increment the number of new menu items
                            dwNumNewMenuItems++;
                        }
                    }

                    if (dwNumFaxPrinters > (IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE - IDM_FAX_SET_AS_DEFAULT_PRINTER_1)) {
                        // Finish the menus with the printers string
                        LoadString(g_hInstance, IDS_MENU_ITEM_FAX_PRINTERS, szMenuString, RESOURCE_STRING_LEN);
                        mii.dwTypeData = szMenuString;

                        // Insert the item into the set as default printer menu
                        mii.wID = IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE;
                        InsertMenuItem(hFaxSetAsDefaultMenu, (dwNumOldMenuItems + dwNumNewMenuItems), TRUE, &mii);

                        // Insert the item into the sharing menu
                        mii.wID = IDM_FAX_SHARING_MORE;
                        InsertMenuItem(hFaxSharingMenu, (dwNumOldMenuItems + dwNumNewMenuItems), TRUE, &mii);

                        // Insert the item into the properties menu
                        mii.wID = IDM_FAX_PROPERTIES_MORE;
                        InsertMenuItem(hFaxPropertiesMenu, (dwNumOldMenuItems + dwNumNewMenuItems), TRUE, &mii);
                    }

                    // Remove the old items from the set as default printer menu
                    for (dwIndex = 0; dwIndex < dwNumOldMenuItems; dwIndex++) {
                        DeleteMenu(hFaxSetAsDefaultMenu, 0, MF_BYPOSITION);
                    }

                    // Remove the old items from the sharing menu
                    for (dwIndex = 0; dwIndex < dwNumOldMenuItems; dwIndex++) {
                        DeleteMenu(hFaxSharingMenu, 0, MF_BYPOSITION);
                    }

                    // Remove the old items from the properties menu
                    for (dwIndex = 0; dwIndex < dwNumOldMenuItems; dwIndex++) {
                        DeleteMenu(hFaxPropertiesMenu, 0, MF_BYPOSITION);
                    }
                }
                else {
                    // One or zero fax printers, so set sub-menus as menu items
                    // Initialize the menu item info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STATE | MIIM_SUBMENU;
                    mii.hSubMenu = NULL;

                    // Update the set as default printer menu item
                    if (hFaxSetAsDefaultMenu) {
                        DestroyMenu(hFaxSetAsDefaultMenu);
                        hFaxSetAsDefaultMenu = NULL;
                    }
                    if ((pFaxPrintersConfig) && (dwNumFaxPrinters == 1) && (szDefaultPrinterName) && (!lstrcmpi(szDefaultPrinterName, pFaxPrintersConfig[0].pPrinterName))) {
                        mii.fState = MFS_CHECKED | MFS_ENABLED;
                    }
                    else {
                        mii.fState = (dwNumFaxPrinters == 1) ? MFS_ENABLED : MFS_GRAYED;
                    }
                    SetMenuItemInfo(hFaxMenu, IDM_FAX_SET_AS_DEFAULT_PRINTER, FALSE, &mii);

                    // Update the sharing menu item
                    if (hFaxSharingMenu) {
                        DestroyMenu(hFaxSharingMenu);
                        hFaxSharingMenu = NULL;
                    }
                    mii.fState = (dwNumFaxPrinters == 1) ? MFS_ENABLED : MFS_GRAYED;
                    SetMenuItemInfo(hFaxMenu, IDM_FAX_SHARING, FALSE, &mii);

                    // Update the properties menu item
                    if (hFaxPropertiesMenu) {
                        DestroyMenu(hFaxPropertiesMenu);
                        hFaxPropertiesMenu = NULL;
                    }
                    mii.fState = (dwNumFaxPrinters == 1) ? MFS_ENABLED : MFS_GRAYED;
                    SetMenuItemInfo(hFaxMenu, IDM_FAX_PROPERTIES, FALSE, &mii);
                }

                if (pFaxPrintersConfig) {
                    MemFree(pFaxPrintersConfig);
                }

                if (szDefaultPrinterName) {
                    MemFree(szDefaultPrinterName);
                }
            }
            else if (((HMENU) wParam == hDocumentMenu) && (LOWORD(lParam) == 1)) {
                if ((WaitForSingleObject(g_hStartEvent, 0) == WAIT_TIMEOUT) || (!ListView_GetSelectedCount(g_hWndListView))) {
                    // Disconnected or no items selected, so disable all menu items
                    // Disable the pause menu item
                    EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PAUSE, MF_BYCOMMAND | MF_GRAYED);
                    // Disable the resume menu item
                    EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESUME, MF_BYCOMMAND | MF_GRAYED);
                    // Disable the restart menu item
                    EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESTART, MF_BYCOMMAND | MF_GRAYED);
                    // Disable the cancel menu item
                    EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_CANCEL, MF_BYCOMMAND | MF_GRAYED);
                    // Disable the properties menu item
                    EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PROPERTIES, MF_BYCOMMAND | MF_GRAYED);
                }
                else {
                    // uAndMask is the mask indicating the item attributes ANDed together
                    UINT   uAndMask;
                    // uOrMask is the mask indicating the item attributes ORed together
                    UINT   uOrMask;
                    // uState is the item's state
                    UINT   uState;
                    // dwListIndex is the index of a particular item in the list view
                    DWORD  dwListIndex;
                    // bUserHasAccess indicates the user has job manage access
                    BOOL   bUserHasAccess;

                    // Initialize uAndMask
                    uAndMask = LVIS_OVERLAYMASK;
                    // Initialize uOrMask
                    uOrMask = 0;

                    // Enumerate each selected item in the list view
                    dwListIndex = ListView_GetNextItem(g_hWndListView, -1, LVNI_ALL | LVNI_SELECTED);
                    while (dwListIndex != -1) {
                        // Get the item's attributes
                        uState = ListView_GetItemState(g_hWndListView, dwListIndex, LVIS_OVERLAYMASK);
                        // AND the item's attributes with uAndMask
                        uAndMask &= uState;
                        // OR the item's attributes with uOrMask
                        uOrMask |= uState;
                        dwListIndex = ListView_GetNextItem(g_hWndListView, dwListIndex, LVNI_ALL | LVNI_SELECTED);
                    }

                    if (uAndMask & ITEM_USEROWNSJOB_MASK) {
                        // User owns all of the jobs
                        bUserHasAccess = TRUE;
                    }
                    else {
                        // User does not own all of the jobs, so determine if user has job manage permission
                        // Initialize bUserHasAccess to FALSE
                        bUserHasAccess = FALSE;

                        // Connect to the fax service
                        if (Connect()) {
                            // Get the user's job manage access
                            bUserHasAccess = FaxAccessCheck(g_hFaxSvcHandle, FAX_JOB_MANAGE);
                            // Disconnect from the fax service
                            Disconnect();
                        }
                    }

                    if (((uAndMask & ITEM_SEND_MASK) == 0) || ((uAndMask & ITEM_IDLE_MASK) == 0)) {
                        // Not a send job or a send job in progress, so disable the pause, resume and restart menu items
                        // Disable the pause menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PAUSE, MF_BYCOMMAND | MF_GRAYED);
                        // Disable the resume menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESUME, MF_BYCOMMAND | MF_GRAYED);
                        // Disable the restart menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESTART, MF_BYCOMMAND | MF_GRAYED);
                    }
                    else if (uAndMask & ITEM_PAUSED_MASK) {
                        // Idle send job that is paused, so enable the resume and restart menu items and disable the pause menu item
                        // Disable the pause menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PAUSE, MF_BYCOMMAND | MF_GRAYED);
                        // Enable the resume menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESUME, MF_BYCOMMAND | (bUserHasAccess ? MF_ENABLED : MF_GRAYED));
                        // Enable the restart menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESTART, MF_BYCOMMAND | (bUserHasAccess ? MF_ENABLED : MF_GRAYED));
                    }
                    else if ((uOrMask & ITEM_PAUSED_MASK) == 0) {
                        // Idle send job that is not paused, so enable the pause and restart menu items and disable the resume menu item
                        // Enable the pause menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PAUSE, MF_BYCOMMAND | (bUserHasAccess ? MF_ENABLED : MF_GRAYED));
                        // Disable the resume menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESUME, MF_BYCOMMAND | MF_GRAYED);
                        // Enable the restart menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESTART, MF_BYCOMMAND | (bUserHasAccess ? MF_ENABLED : MF_GRAYED));
                    }
                    else {
                        // Idle send job, so enable the restart menu item and disable the pause and resume menu items
                        // Enable the pause menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PAUSE, MF_BYCOMMAND | MF_GRAYED);
                        // Disable the resume menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESUME, MF_BYCOMMAND | MF_GRAYED);
                        // Enable the restart menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_RESTART, MF_BYCOMMAND | (bUserHasAccess ? MF_ENABLED : MF_GRAYED));
                    }

                    // Enable the cancel menu item
                    EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_CANCEL, MF_BYCOMMAND | (bUserHasAccess ? MF_ENABLED : MF_GRAYED));

                    if (ListView_GetSelectedCount(g_hWndListView) == 1) {
                        // Only one item selected, so enable the properties menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);
                    }
                    else {
                        // Multiple items selected, so disable the properties menu item
                        EnableMenuItem(hDocumentMenu, IDM_DOCUMENT_PROPERTIES, MF_BYCOMMAND | MF_GRAYED);
                    }
                }
            }

            break;

        case WM_NOTIFY:
            LPNMHDR  pnmhdr;
            // dwMessagePos is the cursor position for the message
            DWORD    dwMessagePos;

            pnmhdr = (LPNMHDR) lParam;
            if ((pnmhdr->hwndFrom == g_hWndListView) && (pnmhdr->code == NM_RCLICK)) {
                // User has right-clicked in the list view, so display the document context menu
                // Initialize the document menu
                SendMessage(g_hWndMain, WM_INITMENUPOPUP, (WPARAM) hDocumentMenu, MAKELPARAM(1, FALSE));
                // Get the cursor position
                dwMessagePos = GetMessagePos();
                // Display the document context menu
                TrackPopupMenu(hDocumentMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON, LOWORD(dwMessagePos), HIWORD(dwMessagePos), 0, g_hWndMain, NULL);
            }
            else if ((pnmhdr->hwndFrom == g_hWndListView) && (pnmhdr->code == NM_DBLCLK)) {
                // rcItem is the rectangle of the item
                RECT  rcItem;

                // User has double-clicked in the list view, so display the job properties
                if (ListView_GetSelectedCount(g_hWndListView) != 1) {
                    break;
                }

                // Get the item's bounding rectangle
                if (ListView_GetItemRect(g_hWndListView, ListView_GetNextItem(g_hWndListView, -1, LVNI_ALL | LVNI_SELECTED), &rcItem, LVIR_BOUNDS)) {
                    // Get the cursor position
                    dwMessagePos = GetMessagePos();
                    // Get the window rectangle of the list view
                    GetWindowRect(g_hWndListView, &rcClient);
                    // Adjust dwMessagePos to indicate the cursor position within the list view
                    dwMessagePos = MAKELONG(LOWORD(dwMessagePos) - rcClient.left, HIWORD(dwMessagePos) - rcClient.top);

                    if ((LOWORD(dwMessagePos) >= rcItem.left) && (LOWORD(dwMessagePos) <= rcItem.right) && (HIWORD(dwMessagePos) >= rcItem.top) && (HIWORD(dwMessagePos) <= rcItem.bottom)) {
                        // Display the job properties
                        SendMessage(g_hWndMain, WM_COMMAND, MAKEWPARAM(IDM_DOCUMENT_PROPERTIES, 0), 0);
                    }
                }
            }
#ifdef TOOLBAR_ENABLED
            else if (pnmhdr->code == TTN_NEEDTEXT) {
                // pToolTipText is the pointer to the tool tip text structure
                LPTOOLTIPTEXT  pToolTipText;
                // szToolTip is the tool tip text
                TCHAR          szToolTip[RESOURCE_STRING_LEN];

                pToolTipText = (LPTOOLTIPTEXT) lParam;
                switch (pToolTipText->hdr.idFrom) {
                    case IDM_FAX_PAUSE_FAXING:
                        LoadString(g_hInstance, IDS_MENU_FAX_PAUSE_FAXING, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_FAX_CANCEL_ALL_FAXES:
                        LoadString(g_hInstance, IDS_MENU_FAX_CANCEL_ALL_FAXES, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_DOCUMENT_PAUSE:
                        LoadString(g_hInstance, IDS_MENU_DOCUMENT_PAUSE, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_DOCUMENT_RESUME:
                        LoadString(g_hInstance, IDS_MENU_DOCUMENT_PAUSE, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_DOCUMENT_RESTART:
                        LoadString(g_hInstance, IDS_MENU_DOCUMENT_RESTART, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_DOCUMENT_CANCEL:
                        LoadString(g_hInstance, IDS_MENU_DOCUMENT_CANCEL, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_DOCUMENT_PROPERTIES:
                        LoadString(g_hInstance, IDS_MENU_DOCUMENT_PROPERTIES, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_VIEW_REFRESH:
                        LoadString(g_hInstance, IDS_MENU_VIEW_REFRESH, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    case IDM_HELP_TOPICS:
                        LoadString(g_hInstance, IDS_MENU_HELP_TOPICS, szToolTip, RESOURCE_STRING_LEN);
                        break;

                    default:
                        ZeroMemory(szToolTip, sizeof(szToolTip));
                        break;

                }

                pToolTipText->lpszText = szToolTip;
            }
#endif // TOOLBAR_ENABLED
            break;

        case WM_SETFOCUS:
            SetFocus(g_hWndListView);
            break;

        case WM_SIZE:
#ifdef TOOLBAR_ENABLED
            // Resize the toolbar
            if (WinPosInfo.bToolbarVisible) {
                SendMessage(g_hWndToolbar, iMsg, wParam, lParam);
            }
#endif // TOOLBAR_ENABLED

            // Resize the status bar
            if (WinPosInfo.bStatusBarVisible) {
                SendMessage(hWndStatusBar, iMsg, wParam, lParam);
            }

            // Get the rectangle of the client area
            GetClientRect(hWnd, &rcClient);
            // Resize the list view
            MoveWindow(g_hWndListView, 0, (rcToolbar.bottom - rcToolbar.top), rcClient.right, rcClient.bottom - (rcStatusBar.bottom - rcStatusBar.top) - (rcToolbar.bottom - rcToolbar.top), TRUE);
            break;

        case UM_SELECT_FAX_PRINTER:
            // szCommandLine is the command line
            TCHAR                szCommandLine[MAX_PATH];
            // si is the startup info for the print ui
            STARTUPINFO          si;
            // pi is the process info for the print ui
            PROCESS_INFORMATION  pi;
            // hWndPrintUI is the handle to the print ui window
            HWND                 hWndPrintUI;
            // pProcessInfoItem is a pointer to a PROCESS_INFO_ITEM structure
            PPROCESS_INFO_ITEM   pProcessInfoItem;
            // szErrorCaption is the error caption if CreateProcess() fails
            TCHAR                szErrorCaption[RESOURCE_STRING_LEN];
            // szErrorMessage is the error message if CreateProcess() fails
            LPTSTR               szErrorMessage;

            if (uCurrentMenu == IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE) {
                // Set the default printer
                SetDefaultPrinterName((LPTSTR) wParam);

                MemFree((LPBYTE) wParam);
                uCurrentMenu = 0;
                return 0;
            }

            if (pProcessInfoList) {
                // See if print ui is already open
                pProcessInfoItem = (PPROCESS_INFO_ITEM) pProcessInfoList;

                while (TRUE) {
                    if (!lstrcmpi((LPTSTR) wParam, pProcessInfoItem->szPrinterName)) {
                        // Printer name matches, so print ui may still be open
                        if (WaitForSingleObject(pProcessInfoItem->hProcess, 0) != WAIT_OBJECT_0) {
                            // Print ui is still open
                            ShowWindow(pProcessInfoItem->hWnd, SW_SHOWNORMAL);
                            SetForegroundWindow(pProcessInfoItem->hWnd);
                            return 0;
                        }

                        if (pProcessInfoItem == (PPROCESS_INFO_ITEM) pProcessInfoList) {
                            pProcessInfoList = pProcessInfoItem->ListEntry.Blink;
                        }

                        if (IsListEmpty(pProcessInfoList)) {
                            // This is the last item in the list, so set the list head to NULL
                            pProcessInfoList = NULL;
                        }
                        else {
                            // Remove the process info item from the list
                            RemoveEntryList(&pProcessInfoItem->ListEntry);
                        }
                        // Free the process info item
                        MemFree(pProcessInfoItem);
                        break;
                    }

                    // Step to the next process info item
                    pProcessInfoItem = (PPROCESS_INFO_ITEM) pProcessInfoItem->ListEntry.Blink;

                    if (pProcessInfoItem == (PPROCESS_INFO_ITEM) pProcessInfoList) {
                        // The list has been traversed
                        break;
                    }
                }
            }

            switch (uCurrentMenu) {
                case IDM_FAX_SHARING_MORE:
                    // Set the parameters
                    wsprintf(szCommandLine, TEXT("rundll32 printui.dll,PrintUIEntry /p /t1 /n \"%s\""), (LPTSTR) wParam);
                    break;

                case IDM_FAX_PROPERTIES_MORE:
                    // Set the parameters
                    wsprintf(szCommandLine, TEXT("rundll32 printui.dll,PrintUIEntry /p /t0 /n \"%s\""), (LPTSTR) wParam);
                    break;
            }

            // Initialize si
            ZeroMemory(&si, sizeof(si));
            GetStartupInfo(&si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_NORMAL;

            // Initialize pi
            ZeroMemory(&pi, sizeof(pi));

            // Launch the print ui
            hWndPrintUI = NULL;
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            if (CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi)) {
                // Find the print ui window
                do {
                    Sleep(250);
                    EnumThreadWindows(pi.dwThreadId, EnumThreadWndProc, (LPARAM) &hWndPrintUI);
                } while (hWndPrintUI == NULL);

                SetCursor(LoadCursor(NULL, IDC_ARROW));

                // Add the process info item to the list
                pProcessInfoItem = (PPROCESS_INFO_ITEM) MemAlloc(sizeof(PROCESS_INFO_ITEM) + (lstrlen((LPTSTR) wParam) + 1) * sizeof(TCHAR));
                if (pProcessInfoItem) {
                    // Set szPrinterName
                    pProcessInfoItem->szPrinterName = (LPTSTR) ((UINT_PTR) pProcessInfoItem + sizeof(PROCESS_INFO_ITEM));
                    // Copy szPrinterName
                    lstrcpy(pProcessInfoItem->szPrinterName, (LPTSTR) wParam);

                    // Copy hProcess
                    pProcessInfoItem->hProcess = pi.hProcess;

                    // Copy hWndPrintUI
                    pProcessInfoItem->hWnd = hWndPrintUI;

                    // Insert the process info item into the list
                    if (pProcessInfoList) {
                        InsertTailList(pProcessInfoList, &pProcessInfoItem->ListEntry);
                    }
                    else {
                        pProcessInfoList = &pProcessInfoItem->ListEntry;
                        InitializeListHead(pProcessInfoList);
                    }
                }
            }
            else {
                // CreateProcess() failed, so display an error message
                SetCursor(LoadCursor(NULL, IDC_ARROW));

                // Load the error caption
                LoadString(g_hInstance, IDS_ERROR_CAPTION, szErrorCaption, RESOURCE_STRING_LEN);

                // Try to get the error message from the system message table
                if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, (LPTSTR) &szErrorMessage, 0, NULL)) {
                    // Display the error message
                    MessageBox(hWnd, szErrorMessage, szErrorCaption, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                    LocalFree(szErrorMessage);
                }
                else {
                    // Allocate the memory for the error message
                    szErrorMessage = (LPTSTR) MemAlloc((RESOURCE_STRING_LEN) * sizeof(TCHAR));
                    if (szErrorMessage) {
                        // Load the error message
                        LoadString(g_hInstance, IDS_ERROR_PRINTER_PROPERTIES, szErrorMessage, RESOURCE_STRING_LEN);
                        // Display the error message
                        MessageBox(hWnd, szErrorMessage, szErrorCaption, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                        MemFree(szErrorMessage);
                    }
                }
            }

            MemFree((LPBYTE) wParam);
            uCurrentMenu = 0;

            break;

        case WM_COMMAND:
            // mii is the menu item info
            MENUITEMINFO    mii;
            // szPrinterName is the printer name
            LPTSTR          szPrinterName;
            // pFaxJobEntry is the pointer to the fax jobs
            PFAX_JOB_ENTRY  pFaxJobEntry;
            // lvi specifies the attributes of a particular item in the list view
            LV_ITEM         lvi;
            // dwListIndex is the index of a particular item in the list view
            DWORD           dwListIndex;

            switch (LOWORD(wParam)) {
                case IDM_FAX_PAUSE_FAXING:
                    // pFaxConfig is the pointer to the fax configuration
                    PFAX_CONFIGURATION  pFaxConfig;

                    // Initialize the menu item info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STATE;
                    mii.fState = 0;

                    // Get the size of the menu item
                    if (!GetMenuItemInfo(hFaxMenu, IDM_FAX_PAUSE_FAXING, FALSE, &mii)) {
                        break;
                    }

                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    if (Connect()) {
                        // Get the fax configuration
                        if (FaxGetConfiguration(g_hFaxSvcHandle, &pFaxConfig)) {
                            // Toggle the pause faxing status
                            pFaxConfig->PauseServerQueue = mii.fState & MFS_CHECKED ? FALSE : TRUE;
                            // Set the fax configuration
                            if (FaxSetConfiguration(g_hFaxSvcHandle, pFaxConfig)) {
                                // Check the menu item
                                CheckMenuItem(hFaxMenu, IDM_FAX_PAUSE_FAXING, MF_BYCOMMAND | (pFaxConfig->PauseServerQueue ? MF_CHECKED : MF_UNCHECKED));
#ifdef TOOLBAR_ENABLED
                                // Enable the pause faxing toolbar menu item
                                EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_PAUSE_FAXING, pFaxConfig->PauseServerQueue);
#endif // TOOLBAR_ENABLED
                            }

                            FaxFreeBuffer(pFaxConfig);
                        }

                        Disconnect();
                    }

                    // Set the window title to indicate connected or paused
                    SetWindowText(hWnd, mii.fState & MFS_CHECKED ? g_szTitleConnected : g_szTitlePaused);

                    SetCursor(LoadCursor(NULL, IDC_ARROW));

                    break;

                case IDM_FAX_CANCEL_ALL_FAXES:
                    // dwNumFaxJobs is the number of fax jobs
                    DWORD           dwNumFaxJobs;
                    // dwIndex is a counter to enumerate each fax job
                    DWORD           dwIndex;

                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    if (Connect()) {
                        // Enumerate the fax jobs
                        if (FaxEnumJobs(g_hFaxSvcHandle, &pFaxJobEntry, &dwNumFaxJobs)) {
                            // Enumerate and cancel each fax job
                            for (dwIndex = 0; dwIndex < dwNumFaxJobs; dwIndex++) {
                                FaxSetJob(g_hFaxSvcHandle, pFaxJobEntry[dwIndex].JobId, JC_DELETE, &pFaxJobEntry[dwIndex]);
                            }

                            FaxFreeBuffer(pFaxJobEntry);
                        }

                        Disconnect();
                    }

                    SetCursor(LoadCursor(NULL, IDC_ARROW));

                    break;

                case IDM_FAX_CLOSE:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    break;

                case IDM_DOCUMENT_PAUSE:
                case IDM_DOCUMENT_RESUME:
                case IDM_DOCUMENT_RESTART:
                case IDM_DOCUMENT_CANCEL:
                    // pJobIdList is a pointer to the job id list
                    PLIST_ENTRY    pJobIdList;
                    // JobIdItem is a JOB_ID_ITEM structure
                    PJOB_ID_ITEM   pJobIdItem;
                    // FaxJobEntry is the fax job
                    FAX_JOB_ENTRY  FaxJobEntry;
                    // dwCommand is the command to set the fax job entry
                    DWORD          dwCommand;

                    switch (LOWORD(wParam)) {
                        case IDM_DOCUMENT_PAUSE:
                            dwCommand = JC_PAUSE;
                            break;

                        case IDM_DOCUMENT_RESUME:
                            dwCommand = JC_RESUME;
                            break;

                        case IDM_DOCUMENT_RESTART:
                            dwCommand = JC_RESTART;
                            break;

                        case IDM_DOCUMENT_CANCEL:
                            dwCommand = JC_DELETE;
                            break;
                    }

                    // Set pJobIdList to NULL
                    pJobIdList = NULL;

                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    if (Connect()) {
                        // Initialize FaxJobEntry
                        ZeroMemory(&FaxJobEntry, sizeof(FaxJobEntry));
                        FaxJobEntry.SizeOfStruct = sizeof(FaxJobEntry);

                        // Enumerate each selected item in the list view
                        dwListIndex = ListView_GetNextItem(g_hWndListView, -1, LVNI_ALL | LVNI_SELECTED);
                        while (dwListIndex != -1) {
                            // Initialize lvi
                            lvi.mask = LVIF_PARAM;
                            // Set the item number
                            lvi.iItem = dwListIndex;
                            // Set the subitem number
                            lvi.iSubItem = 0;
                            // Set the lParam
                            lvi.lParam = 0;
                            // Get the selected item from the list view
                            if (ListView_GetItem(g_hWndListView, &lvi)) {
                                // Add the job id item to the list
                                pJobIdItem = (PJOB_ID_ITEM) MemAlloc(sizeof(JOB_ID_ITEM));
                                if (pJobIdItem) {
                                    // Copy dwJobId
                                    pJobIdItem->dwJobId = (DWORD) lvi.lParam;
                                    // Insert the job id item into the list
                                    if (pJobIdList) {
                                        InsertTailList(pJobIdList, &pJobIdItem->ListEntry);
                                    }
                                    else {
                                        pJobIdList = &pJobIdItem->ListEntry;
                                        InitializeListHead(pJobIdList);
                                    }
                                }
                            }

                            dwListIndex = ListView_GetNextItem(g_hWndListView, dwListIndex, LVNI_ALL | LVNI_SELECTED);
                        }

                        while (pJobIdList) {
                            // Get the job id item from the list
                            pJobIdItem = (PJOB_ID_ITEM) pJobIdList;
                            // Set FaxJobEntry
                            FaxJobEntry.JobId = pJobIdItem->dwJobId;
                            // Set the fax job entry
                            if (FaxSetJob(g_hFaxSvcHandle, FaxJobEntry.JobId, dwCommand, &FaxJobEntry)) {
                                if (LOWORD(wParam) != IDM_DOCUMENT_CANCEL) {
                                    // Post an event to the completion port to indicate thread is to refresh
                                    PostEventToCompletionPort(g_hCompletionPort, (DWORD) -1, FaxJobEntry.JobId);
                                }
                            }

                            // Set the head of the job id item list to the next job id item in the list
                            pJobIdList = pJobIdItem->ListEntry.Blink;

                            if (IsListEmpty(pJobIdList)) {
                                // This is the last item in the list, so set the list head to NULL
                                pJobIdList = NULL;
                            }
                            else {
                                // Remove the job id item from the list
                                RemoveEntryList(&pJobIdItem->ListEntry);
                            }
                            // Free the job id item
                            MemFree(pJobIdItem);
                        }

                        Disconnect();
                    }

                    SetCursor(LoadCursor(NULL, IDC_ARROW));

                    break;

                case IDM_DOCUMENT_PROPERTIES:
                    // PropSheetHeader is the property sheet header
                    PROPSHEETHEADER  PropSheetHeader;
                    // PropSheetPage is the property sheet page
                    PROPSHEETPAGE    PropSheetPage;

                    // Set pJobIdList to NULL
                    pJobIdList = NULL;

                    // Initialize PropSheetHeader
                    PropSheetHeader.dwSize = sizeof(PropSheetHeader);
                    // Set the property sheet header flags
                    PropSheetHeader.dwFlags = PSH_NOAPPLYNOW | PSH_PROPSHEETPAGE | PSH_PROPTITLE;
                    // Set the property sheet header owner window
                    PropSheetHeader.hwndParent = hWnd;
                    // Set the property sheet header hInstance
                    PropSheetHeader.hInstance = g_hInstance;
                    // Set the number of property sheet pages
                    PropSheetHeader.nPages = 1;
                    // Set the start property sheet page
                    PropSheetHeader.nStartPage = 0;
                    PropSheetHeader.pStartPage = NULL;
                    // Set the property sheet pages
                    PropSheetHeader.ppsp = &PropSheetPage;

                    // Initialize PropSheetPage
                    PropSheetPage.dwSize = sizeof(PropSheetPage);
                    // Set the property sheet page flags
                    PropSheetPage.dwFlags = 0;
                    // Set the property sheet page hInstance
                    PropSheetPage.hInstance = g_hInstance;
                    // Set the property sheet page dialog template
                    PropSheetPage.pszTemplate = MAKEINTRESOURCE(IDD_DOCUMENT_PROPERTIES);
                    // Set the property sheet page dialog procedure
                    PropSheetPage.pfnDlgProc = DocumentPropertiesDlgProc;

                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    if (Connect()) {
                        // Enumerate each selected item in the list view
                        dwListIndex = ListView_GetNextItem(g_hWndListView, -1, LVNI_ALL | LVNI_SELECTED);
                        while (dwListIndex != -1) {
                            // Initialize lvi
                            lvi.mask = LVIF_PARAM;
                            // Set the item number
                            lvi.iItem = dwListIndex;
                            // Set the subitem number
                            lvi.iSubItem = 0;
                            // Set the lParam
                            lvi.lParam = 0;
                            // Get the selected item from the list view
                            if (ListView_GetItem(g_hWndListView, &lvi)) {
                                // Add the job id item to the list
                                pJobIdItem = (PJOB_ID_ITEM) MemAlloc(sizeof(JOB_ID_ITEM));
                                if (pJobIdItem) {
                                    // Copy dwJobId
                                    pJobIdItem->dwJobId = (DWORD) lvi.lParam;
                                    // Insert the job id item into the list
                                    if (pJobIdList) {
                                        InsertTailList(pJobIdList, &pJobIdItem->ListEntry);
                                    }
                                    else {
                                        pJobIdList = &pJobIdItem->ListEntry;
                                        InitializeListHead(pJobIdList);
                                    }
                                }
                            }

                            dwListIndex = ListView_GetNextItem(g_hWndListView, dwListIndex, LVNI_ALL | LVNI_SELECTED);
                        }

                        while (pJobIdList) {
                            // Get the job id item from the list
                            pJobIdItem = (PJOB_ID_ITEM) pJobIdList;
                            if (FaxGetJob(g_hFaxSvcHandle, pJobIdItem->dwJobId, &pFaxJobEntry)) {
                                // Set the property sheet header pszCaption
                                PropSheetHeader.pszCaption = pFaxJobEntry->DocumentName;
                                // Set the property sheet page lParam
                                PropSheetPage.lParam = (LPARAM) pFaxJobEntry;

                                // Create the property sheet
                                PropertySheet(&PropSheetHeader);
                            }

                            // Set the head of the job id item list to the next job id item in the list
                            pJobIdList = pJobIdItem->ListEntry.Blink;

                            if (IsListEmpty(pJobIdList)) {
                                // This is the last item in the list, so set the list head to NULL
                                pJobIdList = NULL;
                            }
                            else {
                                // Remove the job id item from the list
                                RemoveEntryList(&pJobIdItem->ListEntry);
                            }
                            // Free the job id item
                            MemFree(pJobIdItem);
                        }

                        Disconnect();
                    }

                    SetCursor(LoadCursor(NULL, IDC_ARROW));

                    break;

#ifdef TOOLBAR_ENABLED
                case IDM_VIEW_TOOLBAR:
                    if (WinPosInfo.bToolbarVisible) {
                        // Close the toolbar
                        DestroyWindow(g_hWndToolbar);
                        DestroyWindow(hWndToolTips);
                        ZeroMemory(&rcToolbar, sizeof(rcToolbar));
                    }
                    else {
                        // Show the toolbar
                        hWndToolTips = CreateToolTips(hWnd);
                        g_hWndToolbar = CreateToolbar(hWnd);
                        // Get the rectangle of the toolbar
                        GetWindowRect(g_hWndToolbar, &rcToolbar);
                    }

                    WinPosInfo.bToolbarVisible = !WinPosInfo.bToolbarVisible;
                    // Check the menu item
                    CheckMenuItem(hViewMenu, IDM_VIEW_TOOLBAR, MF_BYCOMMAND | (WinPosInfo.bToolbarVisible ? MF_CHECKED : MF_UNCHECKED));

                    // Get the rectangle of the client area
                    GetClientRect(hWnd, &rcClient);
                    // Resize the list view
                    MoveWindow(g_hWndListView, 0, (rcToolbar.bottom - rcToolbar.top), rcClient.right, rcClient.bottom - (rcStatusBar.bottom - rcStatusBar.top) - (rcToolbar.bottom - rcToolbar.top), TRUE);
                    break;
#endif // TOOLBAR_ENABLED

                case IDM_VIEW_STATUS_BAR:
                    if (WinPosInfo.bStatusBarVisible) {
                        // Close the status bar
                        DestroyWindow(hWndStatusBar);
                        ZeroMemory(&rcStatusBar, sizeof(rcStatusBar));
                    }
                    else {
                        // Show the status bar
                        hWndStatusBar = CreateStatusWindow(WS_CHILD | WS_CLIPSIBLINGS | WS_TABSTOP | WS_VISIBLE | SBARS_SIZEGRIP, NULL, hWnd, IDM_STATUS_BAR);
                        // Get the rectangle of the status bar
                        GetWindowRect(hWndStatusBar, &rcStatusBar);
                    }

                    WinPosInfo.bStatusBarVisible = !WinPosInfo.bStatusBarVisible;
                    // Check the menu item
                    CheckMenuItem(hViewMenu, IDM_VIEW_STATUS_BAR, MF_BYCOMMAND | (WinPosInfo.bStatusBarVisible ? MF_CHECKED : MF_UNCHECKED));

                    // Get the rectangle of the client area
                    GetClientRect(hWnd, &rcClient);
                    // Resize the list view
                    MoveWindow(g_hWndListView, 0, (rcToolbar.bottom - rcToolbar.top), rcClient.right, rcClient.bottom - (rcStatusBar.bottom - rcStatusBar.top) - (rcToolbar.bottom - rcToolbar.top), TRUE);
                    break;

                case IDM_VIEW_REFRESH:
                    if (WaitForSingleObject(g_hStartEvent, 0) == WAIT_OBJECT_0) {
                        // Post an event to the completion port to indicate thread is to refresh
                        PostEventToCompletionPort(g_hCompletionPort, FEI_FAXSVC_STARTED, (DWORD) -1);
                    }
                    else {
                        // Set the start event
                        SetEvent(g_hStartEvent);
                    }

                    break;

                case IDM_HELP_TOPICS:
                    HtmlHelp(GetDesktopWindow(), FAXQUEUE_HTMLHELP_FILENAME, HH_DISPLAY_TOPIC, 0L);
                    break;

                case IDM_HELP_ABOUT:
                    // szCaption is the caption for the shell about dialog box
                    TCHAR  szCaption[RESOURCE_STRING_LEN];

                    LoadString(g_hInstance, IDS_FAXQUEUE_LOCAL_CAPTION, szCaption, RESOURCE_STRING_LEN);
                    ShellAbout(hWnd, szCaption, NULL, NULL);
                    break;

                case IDM_FAX_SET_AS_DEFAULT_PRINTER:
                case IDM_FAX_SHARING:
                case IDM_FAX_PROPERTIES:
                    // pFaxPrintersConfig is the pointer to the fax printers
                    LPPRINTER_INFO_2  pFaxPrintersConfig;
                    // dwNumFaxPrinters is the number of fax printers
                    DWORD             dwNumFaxPrinters;

                    // Set the current menu selection
                    if (LOWORD(wParam) == IDM_FAX_SET_AS_DEFAULT_PRINTER) {
                        uCurrentMenu = IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE;
                    }
                    else if (LOWORD(wParam) == IDM_FAX_SHARING) {
                        uCurrentMenu = IDM_FAX_SHARING_MORE;
                    }
                    else if (LOWORD(wParam) == IDM_FAX_PROPERTIES) {
                        uCurrentMenu = IDM_FAX_PROPERTIES_MORE;
                    }
                    else {
                        break;
                    }

                    // Get the fax printers
                    pFaxPrintersConfig = (LPPRINTER_INFO_2) GetFaxPrinters(&dwNumFaxPrinters);
                    if (pFaxPrintersConfig) {
                        // Allocate the memory for the printer name
                        szPrinterName = (LPTSTR) MemAlloc((lstrlen(pFaxPrintersConfig[0].pPrinterName) + 1) * sizeof(TCHAR));
                        if (szPrinterName) {
                            // Copy the printer name
                            lstrcpy(szPrinterName, pFaxPrintersConfig[0].pPrinterName);

                            // Post a message that a printer has been selected
                            PostMessage(hWnd, UM_SELECT_FAX_PRINTER, (UINT_PTR) szPrinterName, 0);
                        }

                        MemFree(pFaxPrintersConfig);
                    }

                    break;

                case IDM_FAX_SET_AS_DEFAULT_PRINTER_1:
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_2:
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_3:
                case IDM_FAX_SET_AS_DEFAULT_PRINTER_4:
                case IDM_FAX_SHARING_1:
                case IDM_FAX_SHARING_2:
                case IDM_FAX_SHARING_3:
                case IDM_FAX_SHARING_4:
                case IDM_FAX_PROPERTIES_1:
                case IDM_FAX_PROPERTIES_2:
                case IDM_FAX_PROPERTIES_3:
                case IDM_FAX_PROPERTIES_4:
                    // hMenu is the handle to the menu
                    HMENU   hMenu;
                    // szMenuString is a menu string
                    TCHAR   szMenuString[RESOURCE_STRING_LEN];
                    // szMenuItemName is the menu item name
                    LPTSTR  szMenuItemName;

                    // Get the handle to the menu, set the current menu selection, and set the menu string
                    if ((LOWORD(wParam) >= IDM_FAX_SET_AS_DEFAULT_PRINTER_1) && (LOWORD(wParam) < IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE)) {
                        hMenu = hFaxSetAsDefaultMenu;
                        uCurrentMenu = IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE;
                        wsprintf(szMenuString, TEXT("&%d "), LOWORD(wParam) - IDM_FAX_SET_AS_DEFAULT_PRINTER_1 + 1);
                    }
                    else if ((LOWORD(wParam) >= IDM_FAX_SHARING_1) && (LOWORD(wParam) < IDM_FAX_SHARING_MORE)) {
                        hMenu = hFaxSharingMenu;
                        uCurrentMenu = IDM_FAX_SHARING_MORE;
                        wsprintf(szMenuString, TEXT("&%d "), LOWORD(wParam) - IDM_FAX_SHARING_1 + 1);
                    }
                    else if ((LOWORD(wParam) >= IDM_FAX_PROPERTIES_1) && (LOWORD(wParam) < IDM_FAX_PROPERTIES_MORE)) {
                        hMenu = hFaxPropertiesMenu;
                        uCurrentMenu = IDM_FAX_PROPERTIES_MORE;
                        wsprintf(szMenuString, TEXT("&%d "), LOWORD(wParam) - IDM_FAX_PROPERTIES_1 + 1);
                    }
                    else {
                        break;
                    }

                    // Initialize the menu item info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.dwTypeData = NULL;
                    mii.cch = 0;

                    // Get the size of the menu item
                    if (GetMenuItemInfo(hMenu, LOWORD(wParam), FALSE, &mii)) {
                        mii.cch++;
                        // Allocate the memory for the menu item
                        szMenuItemName = (LPTSTR) MemAlloc(mii.cch * sizeof(TCHAR));
                        if (szMenuItemName) {
                            mii.dwTypeData = szMenuItemName;
                            // Get the menu item
                            if (GetMenuItemInfo(hMenu, LOWORD(wParam), FALSE, &mii)) {
                                // Allocate the memory for the printer name
                                szPrinterName = (LPTSTR) MemAlloc((lstrlen(szMenuItemName) - lstrlen(szMenuString) + 1) * sizeof(TCHAR));
                                if (szPrinterName) {
                                    // Copy the printer name
                                    lstrcpy(szPrinterName, (LPTSTR) ((UINT_PTR) szMenuItemName + lstrlen(szMenuString) * sizeof(TCHAR)));

                                    // Post a message that a printer has been selected
                                    PostMessage(hWnd, UM_SELECT_FAX_PRINTER, (UINT_PTR) szPrinterName, 0);
                                }
                            }

                            MemFree(szMenuItemName);
                        }
                    }

                    break;

                case IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE:
                case IDM_FAX_SHARING_MORE:
                case IDM_FAX_PROPERTIES_MORE:
                    uCurrentMenu = LOWORD(wParam);
                    DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_SELECT_FAX_PRINTER), hWnd, SelectFaxPrinterDlgProc);
                    break;

            }

            break;

        case WM_CLOSE:
            // Set the exit event
            SetEvent(g_hExitEvent);
            if (WaitForSingleObject(g_hStartEvent, 0) == WAIT_OBJECT_0) {
                // Post an event to the completion port to indicate thread is to exit
                PostEventToCompletionPort(g_hCompletionPort, FEI_FAXSVC_ENDED, (DWORD) -1);
            }

#ifdef TOOLBAR_ENABLED
            // Set the persistent data
            SetFaxQueueRegistryData(WinPosInfo.bToolbarVisible, WinPosInfo.bStatusBarVisible, g_hWndListView, hWnd);
#else
            // Set the persistent data
            SetFaxQueueRegistryData(WinPosInfo.bStatusBarVisible, g_hWndListView, hWnd);
#endif // TOOLBAR_ENABLED

            // Free the process info list
            while (pProcessInfoList) {
                // Get the head of the process info list
                pProcessInfoItem = (PPROCESS_INFO_ITEM) pProcessInfoList;

                // Set the head of process info list to the next process info item in the list
                pProcessInfoList = pProcessInfoItem->ListEntry.Blink;

                if (IsListEmpty(pProcessInfoList)) {
                    // This is the last item in the list, so set the list head to NULL
                    pProcessInfoList = NULL;
                }
                else {
                    // Remove the process info item from the list
                    RemoveEntryList(&pProcessInfoItem->ListEntry);
                }
                // Free the process info item
                MemFree(pProcessInfoItem);
            }

            break;

        case WM_DESTROY:
#ifdef TOOLBAR_ENABLED
            if (WinPosInfo.bToolbarVisible) {
                // Close the toolbar
                DestroyWindow(g_hWndToolbar);
                DestroyWindow(hWndToolTips);
            }
#endif // TOOLBAR_ENABLED

            if (WinPosInfo.bStatusBarVisible) {
                // Close the status bar
                DestroyWindow(hWndStatusBar);
            }

            // Close the list view
            DestroyWindow(g_hWndListView);

            PostQuitMessage(0);
            break;
    }

    return DefWindowProc(hWnd, iMsg, wParam, lParam);
}

INT_PTR CALLBACK SelectFaxPrinterDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    // hWndPrinterList is the handle to the fax printer list box
    static HWND   hWndPrinterList;

    switch(iMsg) {
        case WM_INITDIALOG:
            // pFaxPrintersConfig is the pointer to the fax printers
            LPPRINTER_INFO_2  pFaxPrintersConfig;
            // dwNumFaxPrinters is the number of fax printers
            DWORD             dwNumFaxPrinters;
            // dwIndex is a counter to enumerate each printer
            DWORD             dwIndex;

            // Get the handle to the fax printer list box
            hWndPrinterList = GetDlgItem(hDlg, IDC_FAX_PRINTER_LIST);

            // Get the fax printers
            pFaxPrintersConfig = (LPPRINTER_INFO_2) GetFaxPrinters(&dwNumFaxPrinters);
            if ((pFaxPrintersConfig) && (dwNumFaxPrinters)) {
                // Propagate the list box with the list of fax printers
                for (dwIndex = 0; dwIndex < dwNumFaxPrinters; dwIndex++) {
                    SendMessage(hWndPrinterList, LB_ADDSTRING, 0, (UINT_PTR) pFaxPrintersConfig[dwIndex].pPrinterName);
                }
            }

            if (pFaxPrintersConfig) {
                MemFree(pFaxPrintersConfig);
            }

            return TRUE;

        case WM_COMMAND:
            switch(HIWORD(wParam)) {
                case LBN_DBLCLK:
                    SendMessage(GetDlgItem(hDlg, IDOK), BM_CLICK, 0, 0);
                    break;
            }

            switch(LOWORD(wParam)) {
                case IDOK:
                    // szPrinterName is the printer name
                    LPTSTR     szPrinterName;
                    // ulpIndex is the index of the currently selected item in the list box
                    ULONG_PTR  ulpIndex;
                    DWORD      cb;

                    // Get the current selection of the list box
                    ulpIndex = SendMessage(hWndPrinterList, LB_GETCURSEL, 0, 0);
                    if (ulpIndex != LB_ERR) {
                        // Get the size of the current selection of the list box
                        cb = (DWORD) SendMessage(hWndPrinterList, LB_GETTEXTLEN, ulpIndex, NULL);
                        if (cb != LB_ERR) {
                            // Allocate the memory for the current selection
                            szPrinterName = (LPTSTR) MemAlloc((cb + 1) * sizeof(TCHAR));
                            if (szPrinterName) {
                                // Get the current selection of the list box
                                if (SendMessage(hWndPrinterList, LB_GETTEXT, ulpIndex, (UINT_PTR) szPrinterName) != LB_ERR) {
                                    // Post a message that a printer has been selected
                                    PostMessage(g_hWndMain, UM_SELECT_FAX_PRINTER, (UINT_PTR) szPrinterName, 0);
                                }
                            }
                        }
                    }

                case IDCANCEL:
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
            }
            break;
    }

    return FALSE;
}

INT_PTR CALLBACK DocumentPropertiesDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch(iMsg) {
        case WM_INITDIALOG:
            // pFaxJobEntry is the pointer to the fax job
            PFAX_JOB_ENTRY  pFaxJobEntry;
            // szColumnItem is text of a column item for those items that are equivalent to a column item
            LPTSTR          szColumnItem;

            // Get the pointer to the fax job from the property sheet page
            pFaxJobEntry = (PFAX_JOB_ENTRY) ((LPPROPSHEETPAGE) lParam)->lParam;

            // Get the column item text for the document name
            szColumnItem = GetColumnItemText(eDocumentName, pFaxJobEntry, NULL);
            // Set the job type static text
            if (szColumnItem) {
                SetDlgItemText(hDlg, IDC_FAX_DOCUMENTNAME, szColumnItem);
                MemFree(szColumnItem);
            }

            // Set the recipient's name static text
            if (pFaxJobEntry->RecipientName) {
                SetDlgItemText(hDlg, IDC_FAX_RECIPIENTNAME, pFaxJobEntry->RecipientName);
            }

            // Set the recipient's fax number static text
            if (pFaxJobEntry->RecipientNumber) {
                SetDlgItemText(hDlg, IDC_FAX_RECIPIENTNUMBER, pFaxJobEntry->RecipientNumber);
            }

            // Set the sender's name static text
            if (pFaxJobEntry->SenderName) {
                SetDlgItemText(hDlg, IDC_FAX_SENDERNAME, pFaxJobEntry->SenderName);
            }

            // Set the sender's company static text
            if (pFaxJobEntry->SenderCompany) {
                SetDlgItemText(hDlg, IDC_FAX_SENDERCOMPANY, pFaxJobEntry->SenderCompany);
            }

            // Set the sender's department static text
            if (pFaxJobEntry->SenderDept) {
                SetDlgItemText(hDlg, IDC_FAX_SENDERDEPT, pFaxJobEntry->SenderDept);
            }

            // Set the billing code static text
            if (pFaxJobEntry->BillingCode) {
                SetDlgItemText(hDlg, IDC_FAX_BILLINGCODE, pFaxJobEntry->BillingCode);
            }

            // Get the column item text for the job type
            szColumnItem = GetColumnItemText(eJobType, pFaxJobEntry, NULL);
            // Set the job type static text
            if (szColumnItem) {
                SetDlgItemText(hDlg, IDC_FAX_JOBTYPE, szColumnItem);
                MemFree(szColumnItem);
            }

            // Get the column item text for the status
            szColumnItem = GetColumnItemText(eStatus, pFaxJobEntry, NULL);
            // Set the status static text
            if (szColumnItem) {
                SetDlgItemText(hDlg, IDC_FAX_STATUS, szColumnItem);
                MemFree(szColumnItem);
            }

            // Get the column item text for the pages
            szColumnItem = GetColumnItemText(ePages, pFaxJobEntry, NULL);
            // Set the pages static text
            if (szColumnItem) {
                SetDlgItemText(hDlg, IDC_FAX_PAGES, szColumnItem);
                MemFree(szColumnItem);
            }

            // Get the column item text for the size
            szColumnItem = GetColumnItemText(eSize, pFaxJobEntry, NULL);
            // Set the size static text
            if (szColumnItem) {
                SetDlgItemText(hDlg, IDC_FAX_SIZE, szColumnItem);
                MemFree(szColumnItem);
            }

            // Get the column item text for the scheduled time
            szColumnItem = GetColumnItemText(eScheduledTime, pFaxJobEntry, NULL);
            // Set the scheduled time static text
            if (szColumnItem) {
                SetDlgItemText(hDlg, IDC_FAX_SCHEDULEDTIME, szColumnItem);
                MemFree(szColumnItem);
            }

            FaxFreeBuffer(pFaxJobEntry);

            return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
            FAXWINHELP(iMsg, wParam, lParam, DocumentPropertiesHelpIDs);
            break;

    }

    return FALSE;
}

BOOL CALLBACK EnumThreadWndProc(HWND hWnd, LPARAM lParam)
{
    if (GetWindowLong(hWnd, GWL_STYLE) & WS_VISIBLE) {
        CopyMemory((LPBYTE) lParam, &hWnd, sizeof(hWnd));
        return FALSE;
    }

    return TRUE;
}

VOID PostEventToCompletionPort(HANDLE hCompletionPort, DWORD dwEventId, DWORD dwJobId)
{
    PFAX_EVENT  pFaxEvent;

    pFaxEvent = (PFAX_EVENT) LocalAlloc(LPTR, sizeof(FAX_EVENT));
    pFaxEvent->EventId = dwEventId;
    pFaxEvent->JobId = dwJobId;

    PostQueuedCompletionStatus(hCompletionPort, sizeof(FAX_EVENT), 0, (LPOVERLAPPED) pFaxEvent);
}

DWORD FaxEventThread (LPVOID lpv)
{
    // hExitStartEvents is a pointer to the g_hExitEvent and g_hStartEvent
    HANDLE               hExitStartEvents[2];

    // mii is the menu item info
    MENUITEMINFO         mii;
    // hFaxMenu is a handle to the fax menu
    HMENU                hFaxMenu;

    // pFaxConfig is the pointer to the fax configuration
    PFAX_CONFIGURATION   pFaxConfig;

    // pPortJobInfoList is a pointer to the port job info list
    PLIST_ENTRY          pPortJobInfoList;
    // pPortJobInfo is a pointer to a PORT_JOB_INFO_ITEM structure
    PPORT_JOB_INFO_ITEM  pPortJobInfoItem;
    // pFaxPortInfo is the pointer to the fax ports
    PFAX_PORT_INFO       pFaxPortInfo;
    // dwNumFaxPorts is the number of fax ports
    DWORD                dwNumFaxPorts;
    // szDeviceName is the device name of the current fax port
    LPTSTR               szDeviceName;
    // dwJobId is the fax job id on the current fax port
    DWORD                dwJobId;

    // pFaxJobEntry is the pointer to the fax jobs
    PFAX_JOB_ENTRY       pFaxJobEntry;
    // dwNumFaxJobs is the number of fax jobs
    DWORD                dwNumFaxJobs;
    // lvfi specifies the attributes of a particular item to find in the list view
    LV_FINDINFO          lvfi;
    // dwListIndex is the index of a particular item in the list view
    DWORD                dwListIndex;
    // nColumnIndex is used to enumerate each column of the list view
    INT                  nColumnIndex;
    // szColumnItem is the text of a column item
    LPTSTR               szColumnItem;
    // uState is the state of a particular item in the list view
    UINT                 uState;
    // dwOldFocusIndex is the old item in the list view with the focus
    DWORD                dwOldFocusIndex;
    // dwNewFocusIndex is the new item in the list view with the focus
    DWORD                dwNewFocusIndex;

    // pFaxEvent is a pointer to the port event
    PFAX_EVENT           pFaxEvent;
    DWORD                dwBytes;
    ULONG_PTR            ulpCompletionKey;

    // dwIndex is a counter to enumerate each fax port and fax job
    DWORD                dwIndex;
    DWORD                dwRslt;

    // Set hExitStartEvents
    // g_hExitEvent
    hExitStartEvents[0] = g_hExitEvent;
    // g_hStartEvent
    hExitStartEvents[1] = g_hStartEvent;

    // Initialize hFaxMenu
    hFaxMenu = NULL;

    // Set pPortJobInfo to NULL
    pPortJobInfoList = NULL;

    while (TRUE) {
        // Wait for Exit, or Start event
        dwRslt = WaitForMultipleObjects(2, hExitStartEvents, FALSE, INFINITE);
        if (dwRslt == WAIT_OBJECT_0) {
            // Exit event was signaled, so exit
            return 0;
        }

        // Set the window title to indicate connecting
        SetWindowText(g_hWndMain, g_szTitleConnecting);

        // Get the handle to the fax menu
        if (!hFaxMenu) {
            hFaxMenu = GetSubMenu(GetMenu(g_hWndMain), 0);
        }

        // Create the completion port
        g_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
        if (!g_hCompletionPort) {
            goto ExitLevel0;
        }

        // Connect to the fax service
        if (!Connect()) {
            goto ExitLevel1;
        }

        // Initialize the fax event queue
        if (!FaxInitializeEventQueue(g_hFaxSvcHandle, g_hCompletionPort, 0, NULL, 0)) {
            // Disconnect from the fax service
            Disconnect();
            goto ExitLevel1;
        }

        // Determine if faxing is paused
        if (FaxGetConfiguration(g_hFaxSvcHandle, &pFaxConfig)) {
            // Check the menu item
            CheckMenuItem(hFaxMenu, IDM_FAX_PAUSE_FAXING, MF_BYCOMMAND | (pFaxConfig->PauseServerQueue ? MF_CHECKED : MF_UNCHECKED));
#ifdef TOOLBAR_ENABLED
            // Enable the pause faxing toolbar menu item
            EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_PAUSE_FAXING, pFaxConfig->PauseServerQueue);
#endif // TOOLBAR_ENABLED
            FaxFreeBuffer(pFaxConfig);
        }

        // Enumerate the fax ports
        if (FaxEnumPorts(g_hFaxSvcHandle, &pFaxPortInfo, &dwNumFaxPorts)) {
            for (dwIndex = 0; dwIndex < dwNumFaxPorts; dwIndex++) {
                // Add each port job info into the list
                pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) MemAlloc(sizeof(PORT_JOB_INFO_ITEM) + (lstrlen(pFaxPortInfo[dwIndex].DeviceName) + 1) * sizeof(TCHAR));
                if (pPortJobInfoItem) {
                    // Copy dwDeviceId
                    pPortJobInfoItem->dwDeviceId = pFaxPortInfo[dwIndex].DeviceId;

                    // Set szDeviceName
                    pPortJobInfoItem->szDeviceName = (LPTSTR) ((UINT_PTR) pPortJobInfoItem + sizeof(PORT_JOB_INFO_ITEM));
                    // Copy szDeviceName
                    lstrcpy(pPortJobInfoItem->szDeviceName, pFaxPortInfo[dwIndex].DeviceName);

                    // Set dwJobId
                    pPortJobInfoItem->dwJobId = (DWORD) -1;

                    // Insert the port job info into the list
                    if (pPortJobInfoList) {
                        InsertTailList(pPortJobInfoList, &pPortJobInfoItem->ListEntry);
                    }
                    else {
                        pPortJobInfoList = &pPortJobInfoItem->ListEntry;
                        InitializeListHead(pPortJobInfoList);
                    }
                }
            }

            FaxFreeBuffer(pFaxPortInfo);
        }

        // Enable the pause faxing menu item and the cancel all faxes menu item
        EnableMenuItem(hFaxMenu, IDM_FAX_PAUSE_FAXING, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem(hFaxMenu, IDM_FAX_CANCEL_ALL_FAXES, MF_BYCOMMAND | MF_ENABLED);

#ifdef TOOLBAR_ENABLED
        // Enable the pause faxing toolbar menu item and the cancel all faxes toolbar menu item
        EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_PAUSE_FAXING, TRUE);
        EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_CANCEL_ALL_FAXES, TRUE);
#endif // TOOLBAR_ENABLED

        // Disconnect from the fax service
        Disconnect();

        // Wait for fax events
        while (GetQueuedCompletionStatus(g_hCompletionPort, &dwBytes, &ulpCompletionKey, (LPOVERLAPPED *) &pFaxEvent, INFINITE)) {
            if (pFaxEvent->EventId == FEI_FAXSVC_ENDED) {
                // Thread should stop listening for fax events
                LocalFree(pFaxEvent);
                break;
            }

            switch (pFaxEvent->EventId) {
                case FEI_MODEM_POWERED_ON:
                case FEI_MODEM_POWERED_OFF:
                case FEI_RINGING:
                case FEI_ABORTING:
                    // Ignore these fax events
                    break;

                case FEI_FAXSVC_STARTED:
                    // Set the window title to indicate refreshing
                    SetWindowText(g_hWndMain, g_szTitleRefreshing);

                    // Initialize the menu item info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STATE;
                    mii.fState = 0;

                    // Get the state of the menu item
                    GetMenuItemInfo(hFaxMenu, IDM_FAX_PAUSE_FAXING, FALSE, &mii);

                    // Connect to the fax service
                    if (Connect()) {
                        // Enumerate the fax jobs
                        if (FaxEnumJobs(g_hFaxSvcHandle, &pFaxJobEntry, &dwNumFaxJobs)) {
                            // Initialize lvfi
                            lvfi.flags = LVFI_PARAM;

                            // Get the old item with the focus
                            dwOldFocusIndex = ListView_GetNextItem(g_hWndListView, -1, LVNI_ALL | LVNI_FOCUSED);

                            // Add new fax jobs and move existing fax jobs to their correct position
                            for (dwIndex = 0; dwIndex < dwNumFaxJobs; dwIndex++) {
                                // Set the search criteria
                                lvfi.lParam = pFaxJobEntry[dwIndex].JobId;

                                // Initialize the item's state
                                uState = 0;

                                // Initialize the device name
                                szDeviceName = NULL;

                                if (pPortJobInfoList) {
                                    // Find the appropriate job
                                    pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoList;

                                    while (TRUE) {
                                        if (pFaxJobEntry[dwIndex].JobId == pPortJobInfoItem->dwJobId) {
                                            // Job id matches, so this is the appropriate port
                                            // Get the device name
                                            szDeviceName = pPortJobInfoItem->szDeviceName;
                                            break;
                                        }

                                        // Step to the next port job info item
                                        pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoItem->ListEntry.Blink;

                                        if (pPortJobInfoItem == (PPORT_JOB_INFO_ITEM) pPortJobInfoList) {
                                            // The list has been traversed
                                            break;
                                        }
                                    }
                                }

                                // Find the job in the list view
                                dwListIndex = ListView_FindItem(g_hWndListView, -1, &lvfi);
                                if ((dwListIndex != -1) && (dwListIndex != dwIndex)) {
                                    // Job exists in the list view but is in the wrong position, so get the item
                                    // Get the item's state
                                    uState = ListView_GetItemState(g_hWndListView, dwListIndex, LVIS_FOCUSED | LVIS_SELECTED);

                                    // Delete the item from its current position
                                    ListView_DeleteItem(g_hWndListView, dwListIndex);
                                    // Set dwListIndex to -1 so item will be inserted into the list view
                                    dwListIndex = -1;
                                }

                                for (nColumnIndex = 0; nColumnIndex < (INT) eIllegalColumnIndex; nColumnIndex++) {
                                    // Get the column item text
                                    szColumnItem = GetColumnItemText((eListViewColumnIndex) nColumnIndex, &pFaxJobEntry[dwIndex], szDeviceName);
                                    // Insert item into the list view
                                    SetColumnItem(g_hWndListView, (dwListIndex == -1) ? TRUE : FALSE, dwIndex, nColumnIndex, szColumnItem, uState, &pFaxJobEntry[dwIndex]);
                                    if (szColumnItem) {
                                        MemFree(szColumnItem);
                                    }
                                }
                            }

                            // Get the new item with the focus
                            dwNewFocusIndex = ListView_GetNextItem(g_hWndListView, -1, LVNI_ALL | LVNI_FOCUSED);

                            if ((dwOldFocusIndex != -1) && (dwNewFocusIndex != -1) && (dwNewFocusIndex >= dwNumFaxJobs)) {
                                // Job will no longer exist in the list view, so set the focus to the item occupying that index
                                // Get the state of the item occupying that index
                                uState = ListView_GetItemState(g_hWndListView, dwOldFocusIndex, LVIS_FOCUSED | LVIS_SELECTED | LVIS_OVERLAYMASK);
                                // Set the focus to the new item
                                ListView_SetItemState(g_hWndListView, dwOldFocusIndex, uState | LVIS_FOCUSED, uState | LVIS_FOCUSED);
                            }

                            // Remove old fax jobs
                            dwListIndex = ListView_GetItemCount(g_hWndListView);
                            for (dwIndex = dwNumFaxJobs; dwIndex < dwListIndex; dwIndex++) {
                                ListView_DeleteItem(g_hWndListView, dwNumFaxJobs);
                            }

                            FaxFreeBuffer(pFaxJobEntry);
                        }

                        // Disconnect from the fax service
                        Disconnect();
                    }

                    // Set the window title to indicate connected or paused
                    SetWindowText(g_hWndMain, mii.fState & MFS_CHECKED ? g_szTitlePaused : g_szTitleConnected);

                    continue;

                case FEI_JOB_QUEUED:
                case FEI_ANSWERED:
                    // Initialize the device name
                    szDeviceName = NULL;

                    if ((pFaxEvent->EventId == FEI_ANSWERED) && (pPortJobInfoList)) {
                        // Find the appropriate port
                        pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoList;

                        while (TRUE) {
                            if (pFaxEvent->DeviceId == pPortJobInfoItem->dwDeviceId) {
                                // Device id matches, so this is the appropriate port
                                // Set the job id
                                pPortJobInfoItem->dwJobId = pFaxEvent->JobId;
                                // Get the device name
                                szDeviceName = pPortJobInfoItem->szDeviceName;
                                break;
                            }

                            // Step to the next port job info item
                            pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoItem->ListEntry.Blink;

                            if (pPortJobInfoItem == (PPORT_JOB_INFO_ITEM) pPortJobInfoList) {
                                // The list has been traversed
                                break;
                            }
                        }
                    }

                    // Connect to the fax service
                    if (Connect()) {
                        // Enumerate the fax jobs
                        if (FaxEnumJobs(g_hFaxSvcHandle, &pFaxJobEntry, &dwNumFaxJobs)) {
                            // Initialize lvfi
                            lvfi.flags = LVFI_PARAM;

                            // Add the new fax job to its correct position
                            for (dwIndex = 0; dwIndex < dwNumFaxJobs; dwIndex++) {
                                // Check if the current fax job matches the new fax job
                                if (pFaxJobEntry[dwIndex].JobId != pFaxEvent->JobId) {
                                    continue;
                                }

                                // Set the search criteria
                                lvfi.lParam = pFaxJobEntry[dwIndex].JobId;

                                // Find the job in the list view
                                dwListIndex = ListView_FindItem(g_hWndListView, -1, &lvfi);
                                if (dwListIndex != -1) {
                                    // Job exists in the list view but is in the wrong position, so get the item
                                    // Delete the item from its current position
                                    ListView_DeleteItem(g_hWndListView, dwListIndex);
                                }

                                for (nColumnIndex = 0; nColumnIndex < (INT) eIllegalColumnIndex; nColumnIndex++) {
                                    // Get the column item text
                                    szColumnItem = GetColumnItemText((eListViewColumnIndex) nColumnIndex, &pFaxJobEntry[dwIndex], szDeviceName);
                                    // Insert item into the list view
                                    SetColumnItem(g_hWndListView, TRUE, dwIndex, nColumnIndex, szColumnItem, 0, &pFaxJobEntry[dwIndex]);
                                    if (szColumnItem) {
                                        MemFree(szColumnItem);
                                    }
                                }

                                break;
                            }

                            FaxFreeBuffer(pFaxJobEntry);
                        }

                        // Disconnect from the fax service
                        Disconnect();
                    }

                    continue;

                case FEI_DELETED:
                    // Initialize lvfi
                    lvfi.flags = LVFI_PARAM;

                    // Set the search criteria
                    lvfi.lParam = pFaxEvent->JobId;

                    // Find the job in the list view
                    dwListIndex = ListView_FindItem(g_hWndListView, -1, &lvfi);
                    if (dwListIndex != -1) {
                        // Delete the item from the list view
                        ListView_DeleteItem(g_hWndListView, dwListIndex);
                    }

                    continue;

                default:
                    // Initialize the device name
                    szDeviceName = NULL;
                    // Initialize the fax job id
                    dwJobId = (DWORD) -1;

                    // Set the port job info item
                    if ((pFaxEvent->EventId != (DWORD) -1) && (pPortJobInfoList)) {
                        // Find the appropriate port
                        pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoList;

                        while (TRUE) {
                            if (pFaxEvent->DeviceId == pPortJobInfoItem->dwDeviceId) {
                                // Device id matches, so this is the appropriate port
                                // Get the fax job id
                                if (pFaxEvent->EventId == FEI_IDLE) {
                                    dwJobId = pPortJobInfoItem->dwJobId;
                                }
                                else {
                                    dwJobId = pFaxEvent->JobId;
                                    // Set the device name
                                    szDeviceName = pPortJobInfoItem->szDeviceName;
                                }

                                // Update the job id
                                pPortJobInfoItem->dwJobId = pFaxEvent->JobId;
                                break;
                            }

                            // Step to the next port job info item
                            pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoItem->ListEntry.Blink;

                            if (pPortJobInfoItem == (PPORT_JOB_INFO_ITEM) pPortJobInfoList) {
                                // The list has been traversed
                                break;
                            }
                        }
                    }
                    else if (pFaxEvent->EventId == (DWORD) -1) {
                        // Set the fax job id
                        dwJobId = pFaxEvent->JobId;
                    }

                    // Initialize lvfi
                    lvfi.flags = LVFI_PARAM;

                    // Set the search criteria
                    lvfi.lParam = dwJobId;

                    // Find the job in the list view
                    dwListIndex = ListView_FindItem(g_hWndListView, -1, &lvfi);
                    if (dwListIndex != -1) {
                        // Connect to the fax service
                        if (Connect()) {
                            // Get the fax job
                            pFaxJobEntry = NULL;
                            while ((FaxGetJob(g_hFaxSvcHandle, dwJobId, &pFaxJobEntry)) && (pFaxJobEntry->Status == FPS_AVAILABLE) && ((pFaxJobEntry->JobType == JT_SEND) || (pFaxJobEntry->JobType == JT_RECEIVE))) {
                                FaxFreeBuffer(pFaxJobEntry);
                                pFaxJobEntry = NULL;
                                Sleep(250);
                            }

                            if (pFaxJobEntry) {
                                // Job exists in the list view, so set the item
                                for (nColumnIndex = 0; nColumnIndex < (INT) eIllegalColumnIndex; nColumnIndex++) {
                                     // Get the column item text
                                     szColumnItem = GetColumnItemText((eListViewColumnIndex) nColumnIndex, pFaxJobEntry, szDeviceName);
                                     // Set item in the list view
                                     SetColumnItem(g_hWndListView, FALSE, dwListIndex, nColumnIndex, szColumnItem, 0, pFaxJobEntry);
                                     if (szColumnItem) {
                                         MemFree(szColumnItem);
                                     }
                                }

                                FaxFreeBuffer(pFaxJobEntry);
                            }

                            // Disconnect from the fax service
                            Disconnect();
                        }
                    }

                    break;
            }

            LocalFree(pFaxEvent);
        }

        // Disable the pause faxing menu item and the cancel all faxes menu item
        EnableMenuItem(hFaxMenu, IDM_FAX_PAUSE_FAXING, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hFaxMenu, IDM_FAX_CANCEL_ALL_FAXES, MF_BYCOMMAND | MF_GRAYED);

#ifdef TOOLBAR_ENABLED
        // Disable the pause faxing toolbar menu item and the cancel all faxes toolbar menu item
        EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_PAUSE_FAXING, FALSE);
        EnableToolbarMenuState(g_hWndToolbar, IDM_FAX_CANCEL_ALL_FAXES, FALSE);
#endif // TOOLBAR_ENABLED

        // Free the port job info list
        while (pPortJobInfoList) {
            // Get the head of the port job info list
            pPortJobInfoItem = (PPORT_JOB_INFO_ITEM) pPortJobInfoList;

            // Set the head of port job info list to the next port job info item in the list
            pPortJobInfoList = pPortJobInfoItem->ListEntry.Blink;

            if (IsListEmpty(pPortJobInfoList)) {
                // This is the last item in the list, so set the list head to NULL
                pPortJobInfoList = NULL;
            }
            else {
                // Remove the port job info item from the list
                RemoveEntryList(&pPortJobInfoItem->ListEntry);
            }
            // Free the port job info item
            MemFree(pPortJobInfoItem);
        }

ExitLevel1:
        CloseHandle(g_hCompletionPort);

ExitLevel0:
        // Reset the start event
        ResetEvent(g_hStartEvent);

        // Set the window title to indicate not connected
        SetWindowText(g_hWndMain, g_szTitleNotConnected);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxview\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxview.c

Abstract:

    This file implements a simple TIFF image viewer.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "resource.h"
#include "tifflib.h"
#include "faxutil.h"


typedef struct _PRINT_INFO {
    HWND    hwnd;
    LPWSTR  FileName;
    HDC     hdc;
    DWORD   FromPage;
    DWORD   ToPage;
    DWORD   Copies;
} PRINT_INFO, *PPRINT_INFO;


static HANDLE hDevMode = NULL;
static HANDLE hDevNames = NULL;

extern HWND   hwndStatusbar;


BOOL
ReadTiffData(
    HANDLE  hTiff,
    LPBYTE  *TiffData,
    DWORD   Width,
    LPDWORD TiffDataLinesAlloc,
    DWORD   PageNumber
    );





BOOL
PrintSetup(
    HWND hwnd
    )
{
    PRINTDLG pdlg = {0};

    pdlg.lStructSize          = sizeof(PRINTDLG);
    pdlg.hwndOwner            = hwnd;
    pdlg.hDevMode             = hDevMode;
    pdlg.hDevNames            = hDevNames;
    pdlg.Flags                = PD_PRINTSETUP;

    if (PrintDlg( &pdlg )) {
        hDevMode = pdlg.hDevMode;
        hDevNames = pdlg.hDevNames;
        return TRUE;
    }

    return FALSE;
}


DWORD
PrintThread(
    PPRINT_INFO pi
    )
{
    LPBYTE      bmiBuf[sizeof(BITMAPINFOHEADER)+(sizeof(RGBQUAD)*2)];
    PBITMAPINFO bmi = (PBITMAPINFO) bmiBuf;
    HANDLE      hTiff;
    TIFF_INFO   TiffInfo;
    LPBYTE      TiffData;
    DWORD       TiffDataSize;
    DWORD       i;
    INT         HorzRes;
    INT         VertRes;
    INT         PrintJobId  = 0;
    DOCINFO     DocInfo;
    DWORD       TiffDataLinesAlloc;
    DWORD       VertResFactor = 1;


    hTiff = TiffOpen(
        pi->FileName,
        &TiffInfo,
        TRUE
        );
    if (!hTiff) {
        return 0;
    }

    TiffDataSize = TiffInfo.ImageHeight * (TiffInfo.ImageWidth / 8);

    TiffData = (LPBYTE) VirtualAlloc(
        NULL,
        TiffDataSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!TiffData) {
        return 0;
    }

    TiffDataLinesAlloc = TiffInfo.ImageHeight;

    bmi->bmiHeader.biSize           = sizeof(BITMAPINFOHEADER);
    bmi->bmiHeader.biWidth          = TiffInfo.ImageWidth;
    bmi->bmiHeader.biHeight         = - (INT) TiffInfo.ImageHeight;
    bmi->bmiHeader.biPlanes         = 1;
    bmi->bmiHeader.biBitCount       = 1;
    bmi->bmiHeader.biCompression    = BI_RGB;
    bmi->bmiHeader.biSizeImage      = 0;
    bmi->bmiHeader.biXPelsPerMeter  = 7874;
    bmi->bmiHeader.biYPelsPerMeter  = 7874;
    bmi->bmiHeader.biClrUsed        = 0;
    bmi->bmiHeader.biClrImportant   = 0;

    if (TiffInfo.PhotometricInterpretation) {
        bmi->bmiColors[0].rgbBlue       = 0;
        bmi->bmiColors[0].rgbGreen      = 0;
        bmi->bmiColors[0].rgbRed        = 0;
        bmi->bmiColors[0].rgbReserved   = 0;
        bmi->bmiColors[1].rgbBlue       = 0xff;
        bmi->bmiColors[1].rgbGreen      = 0xff;
        bmi->bmiColors[1].rgbRed        = 0xff;
        bmi->bmiColors[1].rgbReserved   = 0;
    } else {
        bmi->bmiColors[0].rgbBlue       = 0xff;
        bmi->bmiColors[0].rgbGreen      = 0xff;
        bmi->bmiColors[0].rgbRed        = 0xff;
        bmi->bmiColors[0].rgbReserved   = 0;
        bmi->bmiColors[1].rgbBlue       = 0;
        bmi->bmiColors[1].rgbGreen      = 0;
        bmi->bmiColors[1].rgbRed        = 0;
        bmi->bmiColors[1].rgbReserved   = 0;
    }

    if (TiffInfo.YResolution <= 100) {
        bmi->bmiHeader.biYPelsPerMeter /= 2;
        VertResFactor = 2;
    }

    HorzRes = GetDeviceCaps( pi->hdc, HORZRES );
    VertRes = GetDeviceCaps( pi->hdc, VERTRES );

    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszOutput = NULL;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    DocInfo.lpszDocName = wcsrchr( pi->FileName, L'\\' );
    if (DocInfo.lpszDocName) {
        DocInfo.lpszDocName += 1;
    } else {
        DocInfo.lpszDocName = pi->FileName;
    }

    while( pi->Copies ) {

        PrintJobId = StartDoc( pi->hdc, &DocInfo );
        if (PrintJobId <= 0) {
            DeleteDC( pi->hdc );
            return FALSE;
        }

        for (i=pi->FromPage-1; i<min(pi->ToPage,TiffInfo.PageCount); i++)
        {
            DWORD Lines;
            DWORD StripDataSize;
            DWORD ImageWidth = TiffInfo.ImageWidth;
            DWORD ImageHeight = TiffInfo.ImageHeight;
            DWORD LinesAllocated = MAXVERTBITS;
            INT   DestWidth;
            INT   DestHeight;
            FLOAT ScaleX;
            FLOAT ScaleY;
            FLOAT Scale;


            SendMessage(
                hwndStatusbar,
                SB_SETTEXT,
                1,
                (LPARAM) L"Printing"
                );

            ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, i+1 );

            TiffGetCurrentPageData(
                hTiff,
                &Lines,
                &StripDataSize,
                &ImageWidth,
                &ImageHeight
                );

            ScaleX = (FLOAT) ImageWidth / (FLOAT) HorzRes;
            ScaleY = ((FLOAT) ImageHeight * VertResFactor) / (FLOAT) VertRes;

            Scale = ScaleX > ScaleY ? ScaleX : ScaleY;

            DestWidth = (int) ((FLOAT) ImageWidth / Scale);
            DestHeight = (int) (((FLOAT) ImageHeight * VertResFactor) / Scale);

            bmi->bmiHeader.biWidth = ImageWidth;
            bmi->bmiHeader.biHeight = - (INT)ImageHeight;

            StartPage( pi->hdc );

            StretchDIBits(
                pi->hdc,
                0,
                0,
                DestWidth,
                DestHeight,
                0,
                0,
                ImageWidth,
                ImageHeight,
                TiffData,
                (BITMAPINFO *) bmi,
                DIB_RGB_COLORS,
                SRCCOPY
                );

            EndPage ( pi->hdc ) ;
        }

        pi->Copies -= 1;
        EndDoc( pi->hdc );
    }

    DeleteDC( pi->hdc );
    TiffClose( hTiff );
    VirtualFree( TiffData, 0, MEM_RELEASE );
    MemFree( pi->FileName );
    MemFree( pi );

    return 0;
}


HANDLE
PrintTiffFile(
    HWND hwnd,
    LPWSTR FileName,
    LPWSTR PrinterName
    )
{
    static DWORD Flags     = PD_ALLPAGES | PD_RETURNDC | PD_HIDEPRINTTOFILE | PD_NOSELECTION | PD_NOWARNING;
    static WORD  nFromPage = 0xFFFF;
    static WORD  nToPage   = 0xFFFF;
    static WORD  nCopies   = 1;

    DWORD ThreadId;
    HANDLE hThread;
    PPRINT_INFO pi;
    PRINTDLG pd = {0};
    WCHAR DefaultPrinter[1024];


    if (hwnd) {

        pd.lStructSize = sizeof(pd);
        pd.hwndOwner   = hwnd;
        pd.hDevMode    = hDevMode;
        pd.hDevNames   = hDevNames;
        pd.Flags       = Flags;
        pd.nFromPage   = nFromPage;
        pd.nToPage     = nToPage;
        pd.nMinPage    = 1;
        pd.nMaxPage    = 65535;
        pd.nCopies     = nCopies;

        if (!PrintDlg(&pd)) {
            return NULL;
        }

        hDevMode    = pd.hDevMode;
        hDevNames   = pd.hDevNames;
        Flags       = pd.Flags;
        nFromPage   = pd.nFromPage;
        nToPage     = pd.nToPage;

        pi = (PPRINT_INFO) MemAlloc( sizeof(PRINT_INFO) );
        if (!pi) {
            return NULL;
        }

        pi->hwnd      = hwnd;
        pi->hdc       = pd.hDC;
        pi->FromPage  = Flags & PD_PAGENUMS ? pd.nFromPage : 1;
        pi->ToPage    = pd.nToPage;
        pi->Copies    = pd.nCopies;
        pi->FileName  = StringDup( FileName );

    } else {

        if (!PrinterName) {
            //
            // get the default printer name
            //

            GetProfileString(
                L"windows",
                L"device",
                NULL,
                DefaultPrinter,
                sizeof(DefaultPrinter)
                );
            if (!DefaultPrinter[0]) {
                return NULL;
            }

            PrinterName = wcschr( DefaultPrinter, L',' );
            if (PrinterName) {
                *PrinterName = 0;
            }
            PrinterName = DefaultPrinter;
        }

        pi = (PPRINT_INFO) MemAlloc( sizeof(PRINT_INFO) );
        if (!pi) {
            return NULL;
        }

        pi->hdc = CreateDC( TEXT("WINSPOOL"), PrinterName, NULL, NULL );
        if (!pi->hdc) {
            return NULL;
        }

        pi->hwnd      = NULL;
        pi->FromPage  = 1;
        pi->ToPage    = 65535;
        pi->Copies    = 1;
        pi->FileName  = StringDup( FileName );

    }

    hThread = CreateThread(
        NULL,
        1024*100,
        (LPTHREAD_START_ROUTINE) PrintThread,
        (LPVOID) pi,
        0,
        &ThreadId
        );

    if (!hThread) {
        return NULL;
    }

    return hThread;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxqueue\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Wesley Witt (wesw)

C_DEFINES=$(C_DEFINES) -DTOOLBAR_ENABLED

!ENDIF

!ifndef FAXROOT
FAXROOT=$(PROJECT_ROOT)\fax
!endif

!include $(FAXROOT)\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1

UMTYPE=windows

WIN32_IE_VERSION=0x0300
WIN32_WINNT_VERSION=0x0400

INCLUDES=\
    $(INCLUDES);

LINKLIBS=\
    $(LINKLIBS) \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\winspool.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\htmlhelp.lib \
    $(SDK_LIB_PATH)\winfax.lib

SOURCES=\
    ..\faxqueue.rc \
    ..\faxqueue.cpp \
    ..\util.cpp \
    ..\toolbar.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxqueue\toolbar.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

  toolbar.cpp

Abstract:

  This module implements the toolbar functions for the fax queue viewer

Environment:

  WIN32 User Mode

Author:

  Andrew Ritz (andrewr) 14-jan-1998
  Steven Kehrli (steveke) 30-oct-1998 - major rewrite

--*/

#ifdef TOOLBAR_ENABLED

#include "faxqueue.h"

#define NUMIMAGES     5

#define IMAGEWIDTH    22
#define IMAGEHEIGHT   24

#define BUTTONWIDTH   22
#define BUTTONHEIGHT  24

TBBUTTON ToolBarButton[] =
{
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
//  {0, IDM_FAX_PAUSE_FAXING,      TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
//  {0, IDM_FAX_CANCEL_ALL_FAXES,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
    {1, IDM_DOCUMENT_PAUSE,        TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
    {2, IDM_DOCUMENT_RESUME,       TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, IDM_DOCUMENT_RESTART,      TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
    {0, IDM_DOCUMENT_CANCEL,       TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
//  {0, IDM_DOCUMENT_PROPERTIES,   TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
    {4, IDM_VIEW_REFRESH,          TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0},
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0},
    {3, IDM_HELP_TOPICS,           TBSTATE_ENABLED,  TBSTYLE_BUTTON, {0,0}, 0, 0}
//  {0, 0,                         TBSTATE_ENABLED,  TBSTYLE_SEP,    {0,0}, 0, 0}
};

TOOLBAR_MENU_STATE ToolbarMenuState[] =
{
    {IDM_FAX_PAUSE_FAXING,     FALSE, FALSE},
    {IDM_FAX_CANCEL_ALL_FAXES, FALSE, FALSE},
    {IDM_DOCUMENT_PAUSE,       FALSE, TRUE},
    {IDM_DOCUMENT_RESUME,      FALSE, TRUE},
    {IDM_DOCUMENT_RESTART,     FALSE, FALSE},
    {IDM_DOCUMENT_CANCEL,      FALSE, TRUE},
    {IDM_DOCUMENT_PROPERTIES,  FALSE, FALSE},
    {IDM_VIEW_REFRESH,         FALSE, TRUE},
    {IDM_HELP_TOPICS,          FALSE, TRUE},
};

VOID
EnableToolbarMenuState(
    HWND   hWndToolbar,
    DWORD  CommandId,
    BOOL   Enabled
)
{
    DWORD  dwIndex;

    dwIndex = CommandId - IDM_FAX_PAUSE_FAXING;

	// Set the toolbar menu state
    ToolbarMenuState[dwIndex].Enabled = Enabled;

    if ((hWndToolbar) && (ToolbarMenuState[dwIndex].Toolbar)) {
		if (CommandId == IDM_FAX_PAUSE_FAXING) {
			// Toolbar menu item is for pause faxing, so change the toolbar menu item bitmap
			SendMessage(hWndToolbar, TB_CHANGEBITMAP, CommandId, Enabled ? 0 : 1);
		}
		else {
			// Enable the toolbar menu item
	        SendMessage(hWndToolbar, TB_ENABLEBUTTON, CommandId, Enabled);
		}
    }
}

HWND
CreateToolbar(
    HWND  hWnd
)
{
    // hWndToolbar is the handle to the toolbar
    HWND  hWndToolbar;

    // Create the toolbar
    hWndToolbar = CreateToolbarEx(
        hWnd,
        WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT,
        IDM_TOOLBAR,
        NUMIMAGES,
        g_hInstance,
        IDB_TOOLBAR,
        ToolBarButton,
        sizeof(ToolBarButton) / sizeof(TBBUTTON),
        BUTTONWIDTH,
        BUTTONHEIGHT,
        IMAGEWIDTH,
        IMAGEHEIGHT,
        sizeof(TBBUTTON)
        );

    if (hWndToolbar) {
        SendMessage(hWndToolbar, TB_AUTOSIZE, 0, 0);
    }

    return hWndToolbar;
}

HWND
CreateToolTips(
    HWND  hWnd
)
{
    // hWndToolTips is the handle to the tooltips window
    HWND  hWndToolTips;

    // Create the tooltips window
    hWndToolTips = CreateWindowEx(
        WS_EX_TOOLWINDOW,
        TOOLTIPS_CLASS,
        NULL,
        WS_CHILD,
        0,
        0,
        0,
        0,
        hWnd,
        (HMENU) IDM_TOOLTIP,
        g_hInstance,
        NULL
        );

    return hWndToolTips;
}

#endif // TOOLBAR_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxqueue\resource.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

  resource.h

Abstract:

  This module contains all manifest constants for the fax queue viewer

Environment:

  WIN32 User Mode

Author:

  Wesley Witt (wesw) 27-June-1995
  Steven Kehrli (steveke) 30-oct-1998 - major rewrite

--*/

#define IDI_FAXQUEUE_ICON                    101

#define IDR_MENU                             201
#define IDM_FAX_SET_AS_DEFAULT_PRINTER       202
#define IDM_FAX_PAUSE_FAXING                 203
#define IDM_FAX_CANCEL_ALL_FAXES             204
#define IDM_FAX_SHARING                      205
#define IDM_FAX_PROPERTIES                   206
#define IDM_FAX_CLOSE                        207
#define IDM_DOCUMENT_PAUSE                   208
#define IDM_DOCUMENT_RESUME                  209
#define IDM_DOCUMENT_RESTART                 210
#define IDM_DOCUMENT_CANCEL                  211
#define IDM_DOCUMENT_PROPERTIES              212
#define IDM_VIEW_TOOLBAR                     213
#define IDM_VIEW_STATUS_BAR                  214
#define IDM_VIEW_REFRESH                     215
#define IDM_HELP_TOPICS                      216
#define IDM_HELP_ABOUT                       217

#define IDM_FAX_SET_AS_DEFAULT_PRINTER_1     301
#define IDM_FAX_SET_AS_DEFAULT_PRINTER_2     302
#define IDM_FAX_SET_AS_DEFAULT_PRINTER_3     303
#define IDM_FAX_SET_AS_DEFAULT_PRINTER_4     304
#define IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE  305

#define IDM_FAX_SHARING_1                    311
#define IDM_FAX_SHARING_2                    312
#define IDM_FAX_SHARING_3                    313
#define IDM_FAX_SHARING_4                    314
#define IDM_FAX_SHARING_MORE                 315

#define IDM_FAX_PROPERTIES_1                 321
#define IDM_FAX_PROPERTIES_2                 322
#define IDM_FAX_PROPERTIES_3                 323
#define IDM_FAX_PROPERTIES_4                 324
#define IDM_FAX_PROPERTIES_MORE              325

#define IDR_ACCEL                            401

#define IDB_TOOLBAR                          501
#define IDM_TOOLBAR                          502
#define IDM_TOOLTIP                          503

#define IDM_STATUS_BAR                       601

#define IDD_SELECT_FAX_PRINTER               701
#define IDC_FAX_PRINTER_LIST                 702

#define IDD_DOCUMENT_PROPERTIES              801
#define IDC_FAX_DOCUMENTNAME_TEXT            802
#define IDC_FAX_DOCUMENTNAME                 803
#define IDC_FAX_RECIPIENTINFO                804
#define IDC_FAX_RECIPIENTNAME_TEXT           805
#define IDC_FAX_RECIPIENTNAME                806
#define IDC_FAX_RECIPIENTNUMBER_TEXT         807
#define IDC_FAX_RECIPIENTNUMBER              808
#define IDC_FAX_SENDERINFO                   809
#define IDC_FAX_SENDERNAME_TEXT              810
#define IDC_FAX_SENDERNAME                   811
#define IDC_FAX_SENDERCOMPANY_TEXT           812
#define IDC_FAX_SENDERCOMPANY                813
#define IDC_FAX_SENDERDEPT_TEXT              814
#define IDC_FAX_SENDERDEPT                   815
#define IDC_FAX_BILLINGCODE_TEXT             816
#define IDC_FAX_BILLINGCODE                  817
#define IDC_FAX_FAXINFO                      818
#define IDC_FAX_JOBTYPE_TEXT                 819
#define IDC_FAX_JOBTYPE                      820
#define IDC_FAX_STATUS_TEXT                  821
#define IDC_FAX_STATUS                       822
#define IDC_FAX_PAGES_TEXT                   823
#define IDC_FAX_PAGES                        824
#define IDC_FAX_SIZE_TEXT                    825
#define IDC_FAX_SIZE                         826
#define IDC_FAX_SCHEDULEDTIME_TEXT           827
#define IDC_FAX_SCHEDULEDTIME                828

#define IDS_FAXQUEUE_LOCAL_CAPTION           1001
#define IDS_FAXQUEUE_REMOTE_CAPTION          1002
#define IDS_FAXQUEUE_NOT_CONNECTED           1003
#define IDS_FAXQUEUE_CONNECTING              1004
#define IDS_FAXQUEUE_REFRESHING              1005
#define IDS_FAXQUEUE_PAUSED                  1006
#define IDS_DOCUMENT_NAME_COLUMN             1007
#define IDS_JOB_TYPE_COLUMN                  1008
#define IDS_STATUS_COLUMN                    1009
#define IDS_OWNER_COLUMN                     1010
#define IDS_SIZE_COLUMN                      1011
#define IDS_PAGES_COLUMN                     1012
#define IDS_SCHEDULED_TIME_COLUMN            1013
#define IDS_PORT_COLUMN                      1014
#define IDS_MENU_ITEM_FAX_PRINTERS           1015
#define IDS_ERROR_CAPTION                    1016
#define IDS_ERROR_APP_FAILED_FORMAT          1017
#define IDS_ERROR_APP_FAILED                 1018
#define IDS_ERROR_PRINTER_PROPERTIES         1019
#define IDS_NO_DOCUMENT_NAME                 1020
#define IDS_QUEUE_STATUS_DELETING            1021
#define IDS_QUEUE_STATUS_PAUSED              1022
#define IDS_QUEUE_STATUS_RETRYING            1023
#define IDS_QUEUE_STATUS_RETRIES_EXCEEDED    1024
#define IDS_JOB_TYPE_SEND                    1025
#define IDS_JOB_TYPE_RECEIVE                 1026
#define IDS_JOB_TYPE_ROUTING                 1027
#define IDS_JOB_TYPE_FAIL_RECEIVE            1028
#define IDS_JOB_STATUS_DIALING               1029
#define IDS_JOB_STATUS_SENDING               1030
#define IDS_JOB_STATUS_RECEIVING             1031
#define IDS_JOB_STATUS_COMPLETED             1032
#define IDS_JOB_STATUS_HANDLED               1033
#define IDS_JOB_STATUS_UNAVAILABLE           1034
#define IDS_JOB_STATUS_BUSY                  1035
#define IDS_JOB_STATUS_NO_ANSWER             1036
#define IDS_JOB_STATUS_BAD_ADDRESS           1037
#define IDS_JOB_STATUS_NO_DIAL_TONE          1038
#define IDS_JOB_STATUS_DISCONNECTED          1039
#define IDS_JOB_STATUS_FATAL_ERROR_SND       1040
#define IDS_JOB_STATUS_FATAL_ERROR_RCV       1041
#define IDS_JOB_STATUS_NOT_FAX_CALL          1042
#define IDS_JOB_STATUS_CALL_DELAYED          1043
#define IDS_JOB_STATUS_CALL_BLACKLISTED      1044
#define IDS_JOB_STATUS_INITIALIZING          1045
#define IDS_JOB_STATUS_OFFLINE               1046
#define IDS_JOB_STATUS_RINGING               1047
#define IDS_JOB_STATUS_AVAILABLE             1048
#define IDS_JOB_STATUS_ABORTING              1049
#define IDS_JOB_STATUS_ROUTING               1050
#define IDS_JOB_STATUS_ANSWERED              1051
#define IDS_JOB_SIZE_BYTES                   1052
#define IDS_JOB_SIZE_KBYTES                  1053
#define IDS_JOB_SIZE_MBYTES                  1054
#define IDS_JOB_SIZE_GBYTES                  1055
#define IDS_JOB_SCHEDULED_TIME_NOW           1056

#define IDS_MENU_BASE                        1100
#define IDS_MENU_FAX_SET_AS_DEFAULT_PRINTER  IDS_MENU_BASE + IDM_FAX_SET_AS_DEFAULT_PRINTER
#define IDS_MENU_FAX_PAUSE_FAXING            IDS_MENU_BASE + IDM_FAX_PAUSE_FAXING
#define IDS_MENU_FAX_CANCEL_ALL_FAXES        IDS_MENU_BASE + IDM_FAX_CANCEL_ALL_FAXES
#define IDS_MENU_FAX_SHARING                 IDS_MENU_BASE + IDM_FAX_SHARING
#define IDS_MENU_FAX_PROPERTIES              IDS_MENU_BASE + IDM_FAX_PROPERTIES
#define IDS_MENU_FAX_CLOSE                   IDS_MENU_BASE + IDM_FAX_CLOSE
#define IDS_MENU_DOCUMENT_PAUSE              IDS_MENU_BASE + IDM_DOCUMENT_PAUSE
#define IDS_MENU_DOCUMENT_RESUME             IDS_MENU_BASE + IDM_DOCUMENT_RESUME
#define IDS_MENU_DOCUMENT_RESTART            IDS_MENU_BASE + IDM_DOCUMENT_RESTART
#define IDS_MENU_DOCUMENT_CANCEL             IDS_MENU_BASE + IDM_DOCUMENT_CANCEL
#define IDS_MENU_DOCUMENT_PROPERTIES         IDS_MENU_BASE + IDM_DOCUMENT_PROPERTIES
#define IDS_MENU_VIEW_TOOLBAR                IDS_MENU_BASE + IDM_VIEW_TOOLBAR
#define IDS_MENU_VIEW_STATUS_BAR             IDS_MENU_BASE + IDM_VIEW_STATUS_BAR
#define IDS_MENU_VIEW_REFRESH                IDS_MENU_BASE + IDM_VIEW_REFRESH
#define IDS_MENU_HELP_TOPICS                 IDS_MENU_BASE + IDM_HELP_TOPICS
#define IDS_MENU_HELP_ABOUT                  IDS_MENU_BASE + IDM_HELP_ABOUT
#define IDS_MENU_FAX_PRINTERS                IDS_MENU_BASE + IDM_FAX_SET_AS_DEFAULT_PRINTER_MORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxview\faxview.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxview.c

Abstract:

    This file implements a simple TIFF image viewer.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "resource.h"
#include "tifflib.h"
#include "faxutil.h"


#define WM_OPEN_FILE                (WM_USER + 501)
#define WM_VIEW_REFRESH             (WM_USER + 503)
#define WM_VIEW_CLOSE               (WM_USER + 504)

#define TOP                         0
#define LEFT                        1
#define BOTTOM                      2
#define RIGHT                       3

#define SEPHEIGHT                   7

#define FILLORDER_LSB2MSB           2


typedef struct _TOOLBAR_STATE {
    ULONG   Id;
    BOOL    State;
    LPSTR   Msg;
} TOOLBAR_STATE, *PTOOLBAR_STATE;

//
// globals
//

LPBYTE      bmiBuf[sizeof(BITMAPINFOHEADER)+(sizeof(RGBQUAD)*2)];
PBITMAPINFO bmi = (PBITMAPINFO) bmiBuf;
TIFF_INFO   TiffInfo;
HWND        hwndMain;
HWND        hwndView;
HWND        hwndEdit;
HWND        hwndCoolbar;
HWND        hwndTooltip;
HMENU       hMenu;
HMENU       hMenuZoom;
HANDLE      hTiff;
LPBYTE      TiffData;
DWORD       TiffDataSize;
DWORD       TiffDataLinesAlloc;
DWORD       CxScreen;
DWORD       CyScreen;
DWORD       CxClient;
DWORD       CyClient;
DWORD       ScrollWidth;
DWORD       ScrollHeight;
DWORD       VScrollMax;
DWORD       HScrollMax;
DWORD       VScrollPage;
DWORD       VScrollLine;
DWORD       HScrollLine;
INT         VscrollPos;
INT         HscrollPos;
INT         ScrollPosTrack = -1;
DWORD       Width;
DWORD       Height;
DWORD       OrigWidth;
DWORD       OrigHeight;
WCHAR       TiffFileName[MAX_PATH*2];
WCHAR       PrinterName[MAX_PATH*2];
WCHAR       LastDir[MAX_PATH*2];
DWORD       CurrPage;
HWND        hwndToolbar;
HWND        hwndStatusbar;
DWORD       ToolbarHeight;
DWORD       StatusbarHeight;
HMENU       hmenuFrame;
BOOL        TiffFileOpened;
DWORD       CurrZoom;
HCURSOR     Hourglass;
WNDPROC     OrigEditProc;
BOOL        FileIsOpen;
HIMAGELIST  himlCoolbar;
HBITMAP     hBitmapBackground;
HINSTANCE   hInstance;



TBBUTTON TbButton[] =
    {
        {  -1, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,      {0,0}, 0, -1 },
        {   0, IDM_FILEOPEN,         TBSTATE_ENABLED,        TBSTYLE_BUTTON,   {0,0}, 0,  0 },
        {   1, IDM_PRINT,            TBSTATE_INDETERMINATE,  TBSTYLE_BUTTON,   {0,0}, 0,  1 },
        {   2, IDM_ZOOM,             TBSTATE_INDETERMINATE,  TBSTYLE_DROPDOWN, {0,0}, 0,  2 },
        {  -1, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,      {0,0}, 0, -1 },
        {  -1, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,      {0,0}, 0, -1 },
        {   3, IDM_HELP,             TBSTATE_ENABLED,        TBSTYLE_BUTTON,   {0,0}, 0,  3 }
    };


TOOLBAR_STATE ToolbarState[] =
    {
        {  IDM_FILEOPEN,        TRUE,   "" },
        {  IDM_PRINT,           TRUE,   "" },
        {  IDM_PAGE_UP,         TRUE,   "" },
        {  IDM_PAGE_DOWN,       TRUE,   "" }
    };

#define MAX_TOOLBAR_STATES (sizeof(ToolbarState)/sizeof(TOOLBAR_STATE))


double Zooms[] =
{
    1.00,
     .90,
     .80,
     .70,
     .60,
     .50,
     .40,
     .30,
     .20,
     .10
};

#define MAX_ZOOMS (sizeof(Zooms)/sizeof(double))


//
// prototypes
//

VOID
PopUpMsg(
    LPWSTR format,
    ...
    );

LRESULT
WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
ChildWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
ReadTiffData(
    HANDLE  hTiff,
    LPBYTE  *TiffData,
    DWORD   Width,
    LPDWORD TiffDataLinesAlloc,
    DWORD   PageNumber
    );

HDC
GetPrinterDC(
    void
    );

BOOL
TiffMailDefault(
    LPWSTR  TiffFileName,
    LPWSTR  ProfileName,
    LPWSTR  Password,
    PULONG  ResultCode
    );

VOID
InitializeStatusBar(
    HWND hwnd
    );

BOOL
BrowseForFileName(
    HWND   hwnd,
    LPWSTR FileName,
    LPWSTR Extension,
    LPWSTR FileDesc,
    LPWSTR Dir
    );

BOOL
PrintSetup(
    HWND hwnd
    );

HANDLE
PrintTiffFile(
    HWND hwnd,
    LPWSTR FileName,
    LPWSTR PrinterName
    );

BOOL
IsFaxViewerDefaultViewer(
    VOID
    );

BOOL
MakeFaxViewerDefaultViewer(
    VOID
    );

BOOL
IsItOkToAskForDefault(
    VOID
    );

BOOL
SetAskForViewerValue(
    DWORD Ask
    );

BOOL
SaveWindowPlacement(
    HWND hwnd
    );

BOOL
QueryWindowPlacement(
    HWND hwnd
    );



BOOL
OpenTiffFile(
    LPWSTR FileName,
    HWND hwnd
    )
{
    HANDLE      _hTiff;
    TIFF_INFO   _TiffInfo;
    LPBYTE      _TiffData;
    DWORD       _TiffDataSize;


    _hTiff = TiffOpen(
        FileName,
        &_TiffInfo,
        TRUE
        );
    if (!_hTiff) {
        PopUpMsg( L"Could not open TIFF file [%s]", FileName );
        return FALSE;
    }

    if ( (_TiffInfo.ImageWidth != 1728) ||
         (_TiffInfo.CompressionType != 4 ) ) {

        PopUpMsg( L"Not valid MS TIFF file\n" );
        TiffClose( _hTiff );
        return FALSE;

    }

    _TiffDataSize = _TiffInfo.ImageHeight * (_TiffInfo.ImageWidth / 8);

    _TiffData = (LPBYTE) VirtualAlloc(
        NULL,
        _TiffDataSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!_TiffData) {
        TiffClose( _hTiff );
        PopUpMsg( L"could allocate memory for TIFF data\n" );
        return FALSE;
    }

    hTiff          = _hTiff;
    TiffInfo       = _TiffInfo;
    TiffData       = _TiffData;
    TiffDataSize   = _TiffDataSize;

    TiffDataLinesAlloc = TiffInfo.ImageHeight;

    CurrPage = 1;
    ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, CurrPage );

    bmi->bmiHeader.biSize           = sizeof(BITMAPINFOHEADER);
    bmi->bmiHeader.biWidth          = TiffInfo.ImageWidth;
    bmi->bmiHeader.biHeight         = - (INT) TiffInfo.ImageHeight;
    bmi->bmiHeader.biPlanes         = 1;
    bmi->bmiHeader.biBitCount       = 1;
    bmi->bmiHeader.biCompression    = BI_RGB;
    bmi->bmiHeader.biSizeImage      = 0;
    bmi->bmiHeader.biXPelsPerMeter  = 7874;
    bmi->bmiHeader.biYPelsPerMeter  = 7874;
    bmi->bmiHeader.biClrUsed        = 0;
    bmi->bmiHeader.biClrImportant   = 0;

    if (TiffInfo.PhotometricInterpretation) {
        bmi->bmiColors[0].rgbBlue       = 0;
        bmi->bmiColors[0].rgbGreen      = 0;
        bmi->bmiColors[0].rgbRed        = 0;
        bmi->bmiColors[0].rgbReserved   = 0;
        bmi->bmiColors[1].rgbBlue       = 0xff;
        bmi->bmiColors[1].rgbGreen      = 0xff;
        bmi->bmiColors[1].rgbRed        = 0xff;
        bmi->bmiColors[1].rgbReserved   = 0;
    } else {
        bmi->bmiColors[0].rgbBlue       = 0xff;
        bmi->bmiColors[0].rgbGreen      = 0xff;
        bmi->bmiColors[0].rgbRed        = 0xff;
        bmi->bmiColors[0].rgbReserved   = 0;
        bmi->bmiColors[1].rgbBlue       = 0;
        bmi->bmiColors[1].rgbGreen      = 0;
        bmi->bmiColors[1].rgbRed        = 0;
        bmi->bmiColors[1].rgbReserved   = 0;
    }


    OrigWidth = Width = TiffInfo.ImageWidth;
    OrigHeight = Height = TiffInfo.ImageHeight;

    TiffFileOpened = TRUE;

    return TRUE;
}


VOID
FitRectToScreen(
    PRECT prc
    )
{
    INT cxScreen;
    INT cyScreen;
    INT delta;

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (prc->right > cxScreen) {
        delta = prc->right - prc->left;
        prc->right = cxScreen;
        prc->left = prc->right - delta;
    }

    if (prc->left < 0) {
        delta = prc->right - prc->left;
        prc->left = 0;
        prc->right = prc->left + delta;
    }

    if (prc->bottom > cyScreen) {
        delta = prc->bottom - prc->top;
        prc->bottom = cyScreen;
        prc->top = prc->bottom - delta;
    }

    if (prc->top < 0) {
        delta = prc->bottom - prc->top;
        prc->top = 0;
        prc->bottom = prc->top + delta;
    }
}


VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    )
{
    RECT rc;
    RECT rcOwner;
    RECT rcCenter;
    HWND hwndOwner;

    GetWindowRect( hwnd, &rc );

    if (hwndToCenterOver) {
        hwndOwner = hwndToCenterOver;
        GetClientRect( hwndOwner, &rcOwner );
    } else {
        hwndOwner = GetWindow( hwnd, GW_OWNER );
        if (!hwndOwner) {
            hwndOwner = GetDesktopWindow();
        }
        GetWindowRect( hwndOwner, &rcOwner );
    }

    //
    //  Calculate the starting x,y for the new
    //  window so that it would be centered.
    //
    rcCenter.left = rcOwner.left +
            (((rcOwner.right - rcOwner.left) -
            (rc.right - rc.left))
            / 2);

    rcCenter.top = rcOwner.top +
            (((rcOwner.bottom - rcOwner.top) -
            (rc.bottom - rc.top))
            / 2);

    rcCenter.right = rcCenter.left + (rc.right - rc.left);
    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top);

    FitRectToScreen( &rcCenter );

    SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0,
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
}


LRESULT
AskViewerDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            CenterWindow( hwnd, GetDesktopWindow() );
            break;

        case WM_COMMAND:
            switch( wParam ) {
                case IDOK:
                    SetAskForViewerValue( !IsDlgButtonChecked( hwnd, IDC_DEFAULT_VIEWER ) == BST_CHECKED );
                    EndDialog( hwnd, IDOK );
                    break;

                case IDCANCEL:
                    SetAskForViewerValue( !IsDlgButtonChecked( hwnd, IDC_DEFAULT_VIEWER ) == BST_CHECKED );
                    EndDialog( hwnd, IDCANCEL );
                    break;
            }
            break;
    }

    return FALSE;
}


void
MoveCoolbar(
    DWORD HowAlign
    )
{
    RECT    rc;
    RECT    rcCoolbar;
    int     x;
    int     y;
    int     cx;
    int     cy;


    GetClientRect( hwndMain, &rc );
    GetWindowRect( hwndCoolbar, &rcCoolbar );

    switch( HowAlign ) {
        default:
        case TOP:
            x = 0;
            y = 0;
            cx = rc.right - rc.left;
            cy = rc.bottom - rc.top;
            break;

        case LEFT:
            x = 0;
            y = 0;
            cx = rcCoolbar.right - rcCoolbar.left;
            cy = rc.bottom - rc.top;
            break;

        case BOTTOM:
            x = 0;
            y = rc.bottom - (rcCoolbar.bottom - rcCoolbar.top);
            cx = rc.right - rc.left;
            cy = rcCoolbar.bottom - rcCoolbar.top;
            break;

        case RIGHT:
            x = rc.right - (rcCoolbar.right - rcCoolbar.left);
            y = 0;
            cx = rcCoolbar.right - rcCoolbar.left;
            cy = rc.bottom - rc.top;
            break;
    }

    MoveWindow( hwndCoolbar, x, y, cx, cy, TRUE );
}


VOID
LoadBackgroundBitmap(
    VOID
    )
{
    COLORREF    clrFace;
    HBITMAP     hbmSave;
    UINT        n;
    UINT        i;
    RGBQUAD     rgbTable[256];
    RGBQUAD     rgbFace;
    HDC         hdc;


    if (hBitmapBackground) {
        DeleteObject( hBitmapBackground );
    }

    hBitmapBackground = (HBITMAP) LoadImage(
        hInstance,
        MAKEINTRESOURCE(IDB_COOLBAR),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTSIZE | LR_CREATEDIBSECTION
        );

    hdc = CreateCompatibleDC(NULL);
    clrFace = GetSysColor(COLOR_BTNFACE);

    if (clrFace != RGB(192,192,192)) {

        hbmSave = (HBITMAP) SelectObject( hdc, hBitmapBackground );
        n = GetDIBColorTable(hdc, 0, 256, rgbTable);

        rgbFace.rgbRed   = GetRValue(clrFace);
        rgbFace.rgbGreen = GetGValue(clrFace);
        rgbFace.rgbBlue  = GetBValue(clrFace);

        for (i = 0; i < n; i++)
        {
            rgbTable[i].rgbRed   = (rgbTable[i].rgbRed   * rgbFace.rgbRed  ) / 192;
            rgbTable[i].rgbGreen = (rgbTable[i].rgbGreen * rgbFace.rgbGreen) / 192;
            rgbTable[i].rgbBlue  = (rgbTable[i].rgbBlue  * rgbFace.rgbBlue ) / 192;
        }

        SetDIBColorTable(hdc, 0, n, rgbTable);
        SelectObject(hdc, hbmSave);
    }

    DeleteDC( hdc );
}


VOID
SetBackground(
    VOID
    )
{
    REBARBANDINFO   rbbi;
    DWORD           fMask;


    LoadBackgroundBitmap();

    if (hBitmapBackground) {
        fMask = RBBIM_BACKGROUND;
        rbbi.hbmBack = hBitmapBackground;
    } else {
        fMask = RBBIM_BACKGROUND | RBBIM_COLORS;
        rbbi.hbmBack = NULL;
        rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
        rbbi.clrBack = GetSysColor(COLOR_BTNFACE);
    }

    rbbi.cbSize = sizeof(REBARBANDINFO);

    rbbi.fMask = RBBIM_ID | RBBIM_CHILD;
    if (SendMessage( hwndCoolbar, RB_GETBANDINFO, 0, (LPARAM) &rbbi )) {
        rbbi.fMask = fMask;
        SendMessage( hwndCoolbar, RB_SETBANDINFO, 0, (LPARAM) &rbbi );
        InvalidateRect( rbbi.hwndChild, NULL, TRUE );
    }
}


int
WINAPI
wWinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nShowCmd
    )

/*++

Routine Description:

    Main entry point for the TIFF image viewer.


Arguments:

    hInstance       - Instance handle
    hPrevInstance   - Not used
    lpCmdLine       - Command line arguments
    nShowCmd        - How to show the window

Return Value:

    Return code, zero for success.

--*/

{
    LPWSTR                  *argv;
    DWORD                   argc;
    WNDCLASS                wc;
    MSG                     msg;
    RECT                    rect;
    DWORD                   i;
    HANDLE                  hThread;
    LOGBRUSH                lb;
    RECT                    rc;
    TBADDBITMAP             tbab;
    INITCOMMONCONTROLSEX    iccex;
    REBARBANDINFO           rbbi;
    LRESULT                 lButtonSize;



    hInstance = hInst;

    //
    // general init code
    //

    HeapInitialize(NULL,NULL,NULL,0);

    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC = ICC_COOL_CLASSES;
    InitCommonControlsEx( &iccex );

    FaxTiffInitialize();

    //
    // process the command line
    //

    argv = CommandLineToArgvW( GetCommandLine(), &argc );

    for (i=1; i<argc; i++) {
        if (argv[i][0] == L'-' || argv[i][0] == L'/') {
            switch (towlower(argv[i][1])) {
                case L'p':
                    if (towlower(argv[i][2]) == L't') {
                        hThread = PrintTiffFile( NULL, argv[i+1], argv[i+2] );
                    } else {
                        hThread = PrintTiffFile( NULL, argv[i+1], NULL );
                    }
                    if (hThread) {
                        WaitForSingleObject( hThread, INFINITE );
                    }
                    return 0;

                default:
                    break;
            }
        } else {
            //
            // must be a file name for viewing
            //
            wcscpy( TiffFileName, argv[i] );
        }
    }

    if ((!IsFaxViewerDefaultViewer()) && IsItOkToAskForDefault()) {
        int Answer = DialogBox( hInstance, MAKEINTRESOURCE(IDD_VIEWER), NULL, AskViewerDlgProc );
        if (Answer == IDOK) {
            MakeFaxViewerDefaultViewer();
        }
    }

    CxScreen = GetSystemMetrics( SM_CXSCREEN );
    CyScreen = GetSystemMetrics( SM_CYSCREEN );

    ScrollWidth  = GetSystemMetrics( SM_CYVSCROLL );
    ScrollHeight = GetSystemMetrics( SM_CYHSCROLL );

    CurrPage = 1;

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC)WndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName  = MAKEINTRESOURCE( FAXVIEW );
    wc.lpszClassName = L"FaxView";

    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    lb.lbStyle = BS_SOLID;
    lb.lbColor = RGB( 221,232,23 );
    lb.lbHatch = 0;

    wc.lpfnWndProc   = (WNDPROC)ChildWndProc;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_CROSS);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = L"FaxViewChild";

    if (!RegisterClass(&wc)) {
        return FALSE;
    }

    hwndMain = CreateWindow(
        L"FaxView",                                        // window class name
        L"FaxView",                                        // window caption
        WS_OVERLAPPEDWINDOW,                               // window style
        CW_USEDEFAULT,                                     // initial x position
        CW_USEDEFAULT,                                     // initial y position
        CW_USEDEFAULT,                                     // initial x size
        CW_USEDEFAULT,                                     // initial y size
        NULL,                                              // parent window handle
        NULL,                                              // window menu handle
        hInstance,                                         // program instance handle
        NULL                                               // creation parameters
        );

    if (!hwndMain) {
        return 0;
    }

    hMenu = GetMenu( hwndMain );
    hMenuZoom = GetSubMenu( GetSubMenu( hMenu, 1 ), 3 );

    Hourglass = LoadCursor( NULL, IDC_WAIT );
    if (!Hourglass) {
        DebugPrint(( L"LoadCursor() failed for IDC_WAIT, ec=%d", GetLastError() ));
    }

    //
    // create the coolbar
    //

    hwndCoolbar = CreateWindowEx(
        WS_EX_TOOLWINDOW,
        REBARCLASSNAME,
        NULL,
        WS_VISIBLE |
           WS_BORDER |
           WS_CHILD |
           WS_CLIPCHILDREN |
           WS_CLIPSIBLINGS |
           RBS_TOOLTIPS |
           RBS_BANDBORDERS |
           CCS_NODIVIDER |
           CCS_NOPARENTALIGN,
        0,
        0,
        200,
        100,
        hwndMain,
        (HMENU) IDM_COOLBAR,
        hInstance,
        NULL
        );
    if (!hwndCoolbar) {
        return 0;
    }

    //
    // create and populate the toolbar
    //

    hwndToolbar = CreateWindowEx(
        WS_EX_TOOLWINDOW,
        TOOLBARCLASSNAME,
        NULL,
        WS_CHILD | TBSTYLE_FLAT | CCS_ADJUSTABLE | CCS_NODIVIDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NOPARENTALIGN,
        0,
        0,
        0,
        0,
        hwndCoolbar,
        (HMENU) IDM_TOOLBAR,
        hInstance,
        NULL
        );

    SendMessage( hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0 );

    SendMessage( hwndToolbar, TB_SETMAXTEXTROWS, 2, 0 );
    SendMessage( hwndToolbar, TB_SETBITMAPSIZE,  0, MAKELONG(24,24) );

    tbab.hInst = hInstance;
    tbab.nID   = IDB_OPEN_BIG;
    SendMessage( hwndToolbar, TB_ADDBITMAP, 1, (LPARAM) &tbab );

    tbab.nID   = IDB_PRINT_BIG;
    SendMessage( hwndToolbar, TB_ADDBITMAP, 1, (LPARAM) &tbab );

    tbab.nID   = IDB_ZOOM_BIG;
    SendMessage( hwndToolbar, TB_ADDBITMAP, 1, (LPARAM) &tbab );

    tbab.nID   = IDB_HELP_BIG;
    SendMessage( hwndToolbar, TB_ADDBITMAP, 1, (LPARAM) &tbab );

    SendMessage( hwndToolbar, TB_ADDSTRING, 0, (LPARAM) L"Open\0Print\0Zoom\0Help\0\0" );
    SendMessage( hwndToolbar, TB_ADDBUTTONS, sizeof(TbButton)/sizeof(TBBUTTON), (LPARAM)&TbButton );

    SendMessage( hwndToolbar, TB_SETBUTTONWIDTH, 0, MAKELONG(50,200) );

    ShowWindow( hwndToolbar, SW_SHOW );

    //
    // add the toolbar to the coolbar
    //

    lButtonSize = SendMessage( hwndToolbar, TB_GETBUTTONSIZE, 0, 0 );

    ZeroMemory( &rbbi, sizeof(rbbi) );

    rbbi.cbSize       = sizeof(REBARBANDINFO);
    rbbi.fMask        = RBBIM_CHILD |
                         RBBIM_CHILDSIZE |
                         RBBIM_ID |
                         RBBIM_STYLE |
                         RBBIM_COLORS ;
    rbbi.cxMinChild   = LOWORD(lButtonSize);
    rbbi.cyMinChild   = HIWORD(lButtonSize);
    rbbi.clrFore      = GetSysColor(COLOR_BTNTEXT);
    rbbi.clrBack      = GetSysColor(COLOR_BTNFACE);
    rbbi.fStyle       = RBBS_CHILDEDGE | RBBS_FIXEDBMP;
    rbbi.wID          = IDM_TOOLBAR;
    rbbi.hwndChild    = hwndToolbar;
    rbbi.lpText       = NULL;
    rbbi.hbmBack      = NULL;
    rbbi.iImage       = 0;

    SendMessage( hwndCoolbar, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbbi );

    SetBackground();

    MoveCoolbar( TOP );

    GetWindowRect( hwndCoolbar, &rc );
    ToolbarHeight = rc.bottom - rc.top - 1;

    hwndStatusbar = CreateStatusWindow(
        WS_CHILD | WS_VISIBLE | WS_BORDER,
        L"Fax Viewer",
        hwndMain,
        IDM_STATUSBAR
        );
    GetWindowRect( hwndStatusbar, &rect );
    StatusbarHeight = rect.bottom - rect.top;
    InitializeStatusBar( hwndMain );

    if (TiffFileName[0]) {
        PostMessage( hwndMain, WM_OPEN_FILE, 0, (LPARAM) TiffFileName );
    }

    GetClientRect( hwndMain, &rc );

    hwndView = CreateWindow(
        L"FaxViewChild",                                   // window class name
        NULL,                                              // window caption
        WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE,   // window style
        rc.left,                                           // initial x position
        rc.top + ToolbarHeight + SEPHEIGHT,                // initial y position
        rc.right - rc.left,                                // initial x size
        rc.bottom - rc.top - ToolbarHeight - SEPHEIGHT - StatusbarHeight,  // initial y size
        hwndMain,                                          // parent window handle
        NULL,                                              // window menu handle
        hInstance,                                         // program instance handle
        NULL                                               // creation parameters
        );

    if (!hwndView) {
        return 0;
    }

    hwndTooltip = CreateWindowEx(
        WS_EX_TOOLWINDOW,
        TOOLTIPS_CLASS,
        NULL,
        WS_CHILD,
        0,
        0,
        0,
        0,
        hwndView,
        (HMENU) IDM_TOOLTIP,
        hInstance,
        NULL
        );

    if (!hwndTooltip) {
        return 0;
    }

    ShowWindow( hwndMain, SW_SHOWNORMAL );
    ShowWindow( hwndView, SW_SHOWNORMAL );

    UpdateWindow( hwndMain );
    UpdateWindow( hwndView );
    InvalidateRect( hwndView, NULL, TRUE );

    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }

    return 0;
}


BOOL
ReadTiffData(
    HANDLE  hTiff,
    LPBYTE  *TiffData,
    DWORD   Width,
    LPDWORD TiffDataLinesAlloc,
    DWORD   PageNumber
    )
{
    DWORD Lines = 0;


    TiffSeekToPage( hTiff, PageNumber, FILLORDER_LSB2MSB );

    TiffUncompressMmrPage( hTiff, (LPDWORD) *TiffData, &Lines );

    if (Lines > *TiffDataLinesAlloc) {

        *TiffDataLinesAlloc = Lines;

        VirtualFree( *TiffData, 0, MEM_RELEASE );

        *TiffData = (LPBYTE) VirtualAlloc(
            NULL,
            Lines * (Width / 8),
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (!*TiffData) {
            return FALSE;
        }
    }

    if (!TiffUncompressMmrPage( hTiff, (LPDWORD) *TiffData, &Lines )) {
        return FALSE;
    }

    EnableMenuItem( hMenu, IDM_PAGE_UP, PageNumber == 1 ? MF_GRAYED : MF_ENABLED );

    return TRUE;
}



VOID
PopUpMsg(
    LPWSTR format,
    ...
    )

/*++

Routine Description:

    Pops up a message box to indicate an error.


Arguments:

    format          - Format string
    ...             - Other arguments

Return Value:

    None.

--*/

{
    WCHAR buf[1024];
    va_list arg_ptr;


    va_start( arg_ptr, format );
    _vsnwprintf( buf, sizeof(buf), format, arg_ptr );
    va_end( arg_ptr );

    MessageBox(
        NULL,
        buf,
        L"FaxView",
        MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION
        );
}


VOID
ChangeTitle(
    HWND hwnd,
    LPWSTR FileName
    )

/*++

Routine Description:

    Changes the title text of the window.


Arguments:

    hwnd            - Window handle

Return Value:

    None.

--*/

{
    LPWSTR p;
    WCHAR WindowTitle[128];


    p = wcsrchr( FileName, L'\\' );
    if (p) {
        FileName = p + 1;
    }

    if (TiffFileName[0]) {
        swprintf( WindowTitle, L"FaxView - %s  Page %d of %d", FileName, CurrPage, TiffInfo.PageCount );
    } else {
        swprintf( WindowTitle, L"FaxView" );
    }
    SetWindowText( hwnd, WindowTitle );
}


VOID
UpdateStatusBar(
    LPWSTR lpszStatusString,
    WORD   partNumber,
    WORD   displayFlags
    )
{
    SendMessage(
        hwndStatusbar,
        SB_SETTEXT,
        partNumber | displayFlags,
        (LPARAM)lpszStatusString
        );
}



VOID
InitializeStatusBar(
    HWND hwnd
    )
{
    UpdateStatusBar( L"Fax Viewer", 0, 0 );
}




LRESULT
WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the TIFF image viewer main window.

Arguments:

    hwnd            - Window handle
    message         - message identifier
    wParam          - Parameter
    lParam          - Parameter

Return Value:

    Return result, zero for success.

--*/

{
    HDC hdc;
    RECT rc;
    HCURSOR OldCursor;
    BOOL ReOpen;
    PAINTSTRUCT ps;
    LPWSTR p;
    WCHAR FileName[MAX_PATH*2];



    switch (message) {
        case WM_CREATE:
            hmenuFrame = GetMenu( hwnd );
            QueryWindowPlacement( hwnd );
            return 0;

        case WM_PAINT:
            GetClientRect( hwnd, &rc );
            rc.top += ToolbarHeight;
            rc.bottom = rc.top + SEPHEIGHT;
            hdc = BeginPaint( hwnd, &ps );
            DrawEdge( hdc, &rc, EDGE_RAISED, BF_TOP | BF_BOTTOM | BF_MIDDLE );
            EndPaint( hwnd, &ps );
            return 0;

        case WM_OPEN_FILE:
            ReOpen = FALSE;
            wcscpy( FileName, (LPWSTR) lParam );
            goto open_file;
            return 0;


        case WM_NOTIFY:
            if (((LPNMHDR)lParam)->code == TBN_DROPDOWN) {
                SendMessage( hwndToolbar, TB_GETRECT, IDM_ZOOM, (LPARAM)&rc );
                rc.top = rc.bottom;
                MapWindowPoints( hwndToolbar, HWND_DESKTOP, (POINT *)&rc, 2 );
                TrackPopupMenu( hMenuZoom, TPM_LEFTALIGN | TPM_LEFTBUTTON, rc.left, rc.top, 0, hwnd, NULL );
            }
            return 0;

        case WM_COMMAND:

            if (HIWORD(wParam) == 0) {
                switch( wParam ) {
                    case IDM_FILEOPEN:

                        ReOpen = TiffFileOpened;

                        //
                        // ask the user to choose a file name
                        //

                        if (!BrowseForFileName( hwnd, FileName, L"tif", L"Fax Image Files", LastDir )) {
                            return 0;
                        }
open_file:

                        if (!OpenTiffFile( FileName, hwnd )) {
                            return 0;
                        }

                        //
                        // update the last directory name
                        //

                        p = wcsrchr( FileName, L'\\' );
                        if (p) {
                            wcscpy( LastDir, FileName );
                            p = wcsrchr( LastDir, L'\\' );
                            if (p) {
                                *p = 0;
                            }
                        }

                        wcscpy( TiffFileName, FileName );

                        OldCursor = SetCursor( Hourglass );

                        if (ReOpen) {
                            TiffFileOpened = FALSE;
                            TiffClose( hTiff );
                            VirtualFree( TiffData, 0, MEM_RELEASE );
                            TiffData = NULL;
                            hTiff = NULL;
                            Width = 0;
                            Height = 0;
                            OrigWidth = 0;
                            OrigHeight = 0;
                            TiffDataSize = 0;
                            SendMessage( hwndView, WM_VIEW_CLOSE, 0, 0 );
                        }


                        ChangeTitle( hwnd, TiffFileName );
                        SendMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );

                        SetCursor( OldCursor );

                        EnableMenuItem( hMenu, IDM_CLOSE,       MF_ENABLED );
                        EnableMenuItem( hMenu, IDM_PRINT,       MF_ENABLED );
                        EnableMenuItem( hMenu, IDM_PRINT_SETUP, MF_ENABLED );
                        EnableMenuItem( hMenu, IDM_ZOOM,        MF_ENABLED );
                        EnableMenuItem( hMenu, IDM_PAGE_UP,     MF_GRAYED  );

                        if (TiffInfo.PageCount > 1) {
                            EnableMenuItem( hMenu, IDM_PAGE_DOWN,   MF_ENABLED );
                        }

                        SendMessage( hwndToolbar, TB_SETSTATE, IDM_PRINT, (LPARAM) MAKELONG(TBSTATE_ENABLED, 0) );
                        SendMessage( hwndToolbar, TB_SETSTATE, IDM_ZOOM,  (LPARAM) MAKELONG(TBSTATE_ENABLED, 0) );
                        return 0;

                    case IDM_ZOOM_100:
                    case IDM_ZOOM_90:
                    case IDM_ZOOM_80:
                    case IDM_ZOOM_70:
                    case IDM_ZOOM_60:
                    case IDM_ZOOM_50:
                    case IDM_ZOOM_40:
                    case IDM_ZOOM_30:
                    case IDM_ZOOM_20:
                    case IDM_ZOOM_10:
                        CheckMenuItem( hMenuZoom, CurrZoom+IDM_ZOOM_100, MF_UNCHECKED );
                        CheckMenuItem( hMenuZoom, wParam, MF_CHECKED );
                        CurrZoom = wParam - IDM_ZOOM_100;
                        SendMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
                        return 0;

                    case IDM_PAGE_UP:
                        if (CurrPage == 1) {
                            MessageBeep( MB_ICONEXCLAMATION );
                            return 0;
                        }
                        ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, --CurrPage );
                        ChangeTitle( hwnd, TiffFileName );
                        SendMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
                        return 0;

                    case IDM_PAGE_DOWN:
                        if (CurrPage == TiffInfo.PageCount) {
                            MessageBeep( MB_ICONEXCLAMATION );
                            return 0;
                        }
                        ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, ++CurrPage );
                        ChangeTitle( hwnd, TiffFileName );
                        SendMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
                        return 0;

                    case IDM_PRINT_SETUP:
                        PrintSetup( hwnd );
                        return 0;

                    case IDM_PRINT:
                        PrintTiffFile( hwnd, TiffFileName, NULL );
                        return 0;

                    case IDM_CLOSE:

                        TiffFileOpened = FALSE;
                        TiffClose( hTiff );
                        VirtualFree( TiffData, 0, MEM_RELEASE );
                        TiffData = NULL;
                        hTiff = NULL;
                        Width = 0;
                        Height = 0;
                        OrigWidth = 0;
                        OrigHeight = 0;
                        TiffDataSize = 0;
                        TiffFileName[0] = 0;
                        ChangeTitle( hwnd, TiffFileName );

                        SendMessage( hwndView, WM_VIEW_CLOSE, 0, 0 );

                        EnableMenuItem( hMenu, IDM_CLOSE,       MF_GRAYED );
                        EnableMenuItem( hMenu, IDM_PRINT,       MF_GRAYED );
                        EnableMenuItem( hMenu, IDM_PRINT_SETUP, MF_GRAYED );
                        EnableMenuItem( hMenu, IDM_PAGE_UP,     MF_GRAYED );
                        EnableMenuItem( hMenu, IDM_PAGE_DOWN,   MF_GRAYED );
                        EnableMenuItem( hMenu, IDM_ZOOM,        MF_GRAYED );

                        SendMessage( hwndToolbar, TB_SETSTATE, IDM_PRINT, (LPARAM) MAKELONG(TBSTATE_INDETERMINATE, 0) );
                        SendMessage( hwndToolbar, TB_SETSTATE, IDM_ZOOM,  (LPARAM) MAKELONG(TBSTATE_INDETERMINATE, 0) );

                        return 0;

                    case IDM_EXIT:
                        PostQuitMessage( 0 );
                        return 0;

                    case IDM_HELP:
                        WinHelp(hwnd, TEXT( "faxview.HLP" ), HELP_FINDER, 0L);
                        return 0;


                    case IDM_ABOUT:
                        ShellAbout( hwnd, L"Fax Viewer", NULL, NULL );
                        break;
                }
            }
            return 0;

        case WM_SIZE:
            MoveCoolbar( TOP );
            SendMessage( hwndToolbar,   message, wParam, lParam );
            SendMessage( hwndStatusbar, message, wParam, lParam );

            InitializeStatusBar( hwnd );

            CyClient = HIWORD(lParam) - ToolbarHeight - SEPHEIGHT - StatusbarHeight;
            CxClient = LOWORD(lParam);

            //
            // resize the view window
            //

            GetClientRect( hwnd, &rc );
            MoveWindow(
                hwndView,
                rc.left,
                rc.top+ToolbarHeight+SEPHEIGHT,
                CxClient,
                CyClient,
                TRUE
                );
            return 0;

        case WM_KEYDOWN:
            switch( wParam ) {
                case VK_NEXT:
                    if (GetKeyState( VK_CONTROL ) & 0x8000) {
                        SendMessage( hwnd, WM_COMMAND, IDM_PAGE_DOWN, 0 );
                    } else {
                        SendMessage( hwndView, WM_VSCROLL, MAKELONG(SB_PAGEDOWN,0), 0 );
                    }
                    break;

                case VK_PRIOR:
                    if (GetKeyState( VK_CONTROL ) & 0x8000) {
                        SendMessage( hwnd, WM_COMMAND, IDM_PAGE_UP, 0 );
                    } else {
                        SendMessage( hwndView, WM_VSCROLL, MAKELONG(SB_PAGEUP,0), 0 );
                    }
                    break;

                case VK_END:
                    SendMessage( hwndView, WM_VSCROLL, MAKELONG(SB_BOTTOM,0), 0 );
                    break;

                case VK_HOME:
                    SendMessage( hwndView, WM_VSCROLL, MAKELONG(SB_TOP,0), 0 );
                    break;

                case VK_LEFT:
                    SendMessage( hwndView, WM_HSCROLL, MAKELONG(SB_LINELEFT,0), 0 );
                    break;

                case VK_RIGHT:
                    SendMessage( hwndView, WM_HSCROLL, MAKELONG(SB_LINERIGHT,0), 0 );
                    break;

                case VK_UP:
                    SendMessage( hwndView, WM_VSCROLL, MAKELONG(SB_LINEUP,0), 0 );
                    break;

                case VK_DOWN:
                    SendMessage( hwndView, WM_VSCROLL, MAKELONG(SB_LINEDOWN,0), 0 );
                    break;

                case VK_F4:
                    SendMessage( hwnd, WM_COMMAND, IDM_FILEOPEN, 0 );
                    break;

                case VK_F1:
                    SendMessage( hwnd, WM_COMMAND, IDM_HELP, 0 );
                    break;
            }
            return 0;

        case WM_SYSCOLORCHANGE:
            SendMessage( hwndCoolbar, message, wParam, lParam );
            SetBackground();
            return 0;

        case WM_DESTROY:
            SaveWindowPlacement( hwnd );
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}


VOID
UpdateScrollInfo(
    HWND hwnd
    )
{
    SCROLLINFO si;


    //
    // set the vertical scroll amounts for pages & lines
    //

    if (TiffInfo.PageCount) {
        VScrollMax  = TiffInfo.PageCount * Height;
        VScrollPage = Height;
        VScrollLine = VScrollPage / 10;
        HScrollLine = TiffInfo.ImageWidth / 10;
    } else {
        VScrollMax  = 0;
        VScrollPage = 0;
        VScrollLine = 0;
    }

    si.cbSize       = sizeof(SCROLLINFO);
    si.fMask        = SIF_RANGE;

    GetScrollInfo( hwnd, SB_VERT, &si );

    si.cbSize       = sizeof(SCROLLINFO);
    si.fMask        = SIF_RANGE;
    si.nMin         = 0;
    si.nMax         = VScrollMax;
    si.nPage        = CyClient;

    SetScrollInfo( hwnd, SB_VERT, &si, TRUE );

    si.cbSize       = sizeof(SCROLLINFO);
    si.fMask        = SIF_RANGE;

    GetScrollInfo( hwnd, SB_HORZ, &si );

    HScrollMax       = Width - CxClient;

    si.cbSize       = sizeof(SCROLLINFO);
    si.fMask        = SIF_RANGE;
    si.nMin         = 0;
    si.nMax         = HScrollMax;
    si.nPage        = CxClient;

    SetScrollInfo( hwnd, SB_HORZ, &si, TRUE );
}


DWORD
ScrollPosToPage(
    DWORD ScrollPos
    )
{
    DWORD Page = 0;

    Page = ScrollPos / VScrollPage;
    Page = Page + (((ScrollPos % VScrollPage) > 0) ? 1 : 0);

    return Page == 0 ? 1 : Page;
}


VOID
ScrollViewVertically(
    HWND hwnd,
    INT  ScrollCode,
    INT  Position
    )
{
    INT         OldScrollPos;
    RECT        rcClip;
    INT         Delta;
    SCROLLINFO  si;
    DWORD       NewPage;
    DWORD       Remaining;


    OldScrollPos = VscrollPos;

    if (ScrollCode == SB_LINEUP || ScrollCode == SB_LINEDOWN) {

        if (ScrollCode == SB_LINEUP) {
            VscrollPos -= VScrollLine;
        } else {
            VscrollPos += VScrollLine;
        }
line_scroll:
        VscrollPos = max( 0, min( VscrollPos, (int) VScrollMax ) );
        SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
        Delta = VscrollPos - OldScrollPos;

        if (Delta == 0) {

            MessageBeep( MB_ICONASTERISK );
            return;

        } else if (Delta > 0) {

            if (VscrollPos < (INT)VScrollPage) {
                Remaining = VScrollPage - VscrollPos;
            } else if (VscrollPos % VScrollPage == 0) {
                Remaining = 0;
            } else {
                Remaining = TiffInfo.ImageHeight - (VscrollPos % VScrollPage);
            }
            if (Remaining < CyClient) {
                VscrollPos -= (CyClient - Remaining);
                Delta -= (CyClient - Remaining);
                if (Delta == 0) {
                    //
                    // advance to the next page
                    //
                    if (CurrPage == TiffInfo.PageCount) {
                        MessageBeep( MB_ICONASTERISK );
                        VscrollPos = OldScrollPos;
                        return;
                    }
                    ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, ++CurrPage );
                    ChangeTitle( hwndMain, TiffFileName );
                    VscrollPos = VScrollPage*(CurrPage-1);
                    SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
                    PostMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
                    return;
                }
                SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
            }

            GetClientRect( hwnd, &rcClip );
            ScrollWindow( hwnd, 0, -Delta, NULL, &rcClip );

        } else {

            if (OldScrollPos % VScrollPage == 0) {
                //
                // advance to the previous page
                //
                if (CurrPage == 1) {
                    MessageBeep( MB_ICONASTERISK );
                    return;
                }
                ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, --CurrPage );
                ChangeTitle( hwndMain, TiffFileName );
                VscrollPos = VScrollPage * (CurrPage - 1) + TiffInfo.ImageHeight - CyClient;
                SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
                PostMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
                return;
            }

            if (ScrollPosToPage( VscrollPos ) != CurrPage) {
                //
                // the file was positioned just below the top
                // of the previous page, so lets align to the beginning
                // of the current page
                //

                Remaining = -((INT)OldScrollPos - ((INT)CurrPage - 1) * (INT)TiffInfo.ImageHeight);
                VscrollPos -= Delta - Remaining;
                Delta = Remaining;

            }

            GetClientRect( hwnd, &rcClip );
            ScrollWindow( hwnd, 0, -Delta, NULL, &rcClip );
        }
        return;
    }

    if (ScrollCode == SB_THUMBTRACK) {
        if (ScrollPosTrack == -1) {
            ScrollPosTrack = VscrollPos;
        }
        VscrollPos = max( 0, min( Position, (int) VScrollMax ) );
        SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
        return;
    }

    if (ScrollCode == SB_ENDSCROLL && ScrollPosTrack != -1) {
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_POS;
        GetScrollInfo( hwnd, SB_VERT, &si );
        VscrollPos = si.nPos;
        Delta = VscrollPos - ScrollPosTrack;
        ScrollPosTrack = -1;
        NewPage = ScrollPosToPage( VscrollPos );
        if (NewPage != CurrPage) {
            //
            // the user changed pages
            //
            CurrPage = NewPage;
            ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, CurrPage );
            ChangeTitle( hwndMain, TiffFileName );
            VscrollPos = VScrollPage*(CurrPage-1);
            SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
            PostMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
            return;
        } else {
            SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
            if (Delta != 0) {
                GetClientRect( hwnd, &rcClip );
                ScrollWindow( hwnd, 0, -Delta, NULL, &rcClip );
            }
            return;
        }
        return;
    }

    if (ScrollCode == SB_PAGEDOWN) {
        VscrollPos += CyClient;
        goto line_scroll;
        return;
    }

    if (ScrollCode == SB_PAGEUP) {
        VscrollPos -= CyClient;
        goto line_scroll;
        return;
    }

    if (ScrollCode == SB_TOP) {
        CurrPage = 1;
        ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, CurrPage );
        ChangeTitle( hwndMain, TiffFileName );
        VscrollPos = 0;
        SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
        PostMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
        return;
    }

    if (ScrollCode == SB_BOTTOM) {
        CurrPage = TiffInfo.PageCount;
        ReadTiffData( hTiff, &TiffData, TiffInfo.ImageWidth, &TiffDataLinesAlloc, CurrPage );
        ChangeTitle( hwndMain, TiffFileName );
        VscrollPos = 0;
        SetScrollPos( hwnd, SB_VERT, VscrollPos, TRUE );
        PostMessage( hwndView, WM_VIEW_REFRESH, 0, 0 );
        return;
    }
}


LRESULT
ChildWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static double ZoomPct = 1.00;
    static HDC hdcMem = NULL;

    RECT rc;
    PAINTSTRUCT ps;
    HDC hdc;
    HCURSOR OldCursor;
    int OldScrollPos;
    int Delta;
    HBITMAP hBmp;


    switch (message) {

        case WM_CREATE:
            ZoomPct = Zooms[CurrZoom];
            return 0;

        case WM_VSCROLL:
            ScrollViewVertically( hwnd, LOWORD(wParam), HIWORD(wParam) );
            UpdateScrollInfo( hwnd );
            return 0;

        case WM_HSCROLL:
            OldScrollPos = HscrollPos;

            GetClientRect( hwnd, &rc );

            switch (LOWORD (wParam)) {
                case SB_LINEUP:
                    HscrollPos -= HScrollLine;
                    break;

                case SB_LINEDOWN:
                    HscrollPos += HScrollLine;
                    break;

                case SB_PAGEUP:
                    HscrollPos -= CxClient;
                    break;

                case SB_PAGEDOWN:
                    HscrollPos += CxClient;
                    break;

                case SB_THUMBPOSITION:
                    HscrollPos = HIWORD(wParam);
                    break;

                case SB_THUMBTRACK:
                    HscrollPos = HIWORD(wParam);
                    break;
            }

            HscrollPos = max( 0, min( HscrollPos, (int) HScrollMax ) );

            SetScrollPos( hwnd, SB_HORZ, HscrollPos, TRUE );

            Delta = HscrollPos - OldScrollPos;
            if (Delta != 0) {
                ScrollWindow( hwnd, -Delta, 0, &rc, &rc );
            }
            return 0;

        case WM_PAINT:
            hdc = BeginPaint( hwnd, &ps );
            if (TiffFileOpened) {
                GetClientRect( hwnd, &rc );
                BitBlt(
                    hdc,
                    ps.rcPaint.left,
                    ps.rcPaint.top,
                    ps.rcPaint.right - ps.rcPaint.left,
                    ps.rcPaint.bottom - ps.rcPaint.top,
                    hdcMem,
                    HscrollPos + ((int)ps.rcPaint.left - (int)rc.left),
                    (VscrollPos%VScrollPage) + ((int)ps.rcPaint.top - (int)rc.top),
                    SRCCOPY
                    );
            }
            EndPaint( hwnd, &ps );
            return 0;

        case WM_VIEW_CLOSE:
           DeleteDC( hdcMem );
           hdcMem = NULL;
           VscrollPos = 0;
           HscrollPos = 0;
           UpdateScrollInfo( hwnd );
           return 0;

        case WM_VIEW_REFRESH:
            ZoomPct = Zooms[CurrZoom];

            HscrollPos = 0;
            Width = (DWORD)(OrigWidth * ZoomPct);
            Height = (DWORD)(OrigHeight * ZoomPct);

            SetScrollPos( hwnd, SB_HORZ, HscrollPos, TRUE );

            OldCursor = SetCursor( Hourglass );
            DeleteDC( hdcMem );

            hdc = GetDC( hwnd );
            hBmp = CreateCompatibleBitmap( hdc, Width, Height );
            hdcMem = CreateCompatibleDC( hdc );
            SelectObject( hdcMem, hBmp );

            StretchDIBits(
                hdcMem,
                0,
                0,
                Width,
                Height,
                0,
                0,
                TiffInfo.ImageWidth,
                TiffInfo.ImageHeight,
                TiffData,
                bmi,
                DIB_RGB_COLORS,
                SRCCOPY
                );

            ReleaseDC( hwnd, hdc );
            DeleteObject( hBmp );

            UpdateScrollInfo( hwnd );

            InvalidateRect( hwnd, NULL, TRUE );

            SetCursor( OldCursor );
            return 0;

        case WM_SIZE:
            UpdateScrollInfo( hwnd );
            GetClientRect( hwnd, &rc );
            CyClient = rc.bottom - rc.top;
            CxClient = rc.right - rc.left;
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxview\browse.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    browse.c

Abstract:
    This file implements the functions that make use of the common
    file _open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 20-June-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>



UINT APIENTRY
BrowseHookProc(
    HWND   hwnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure to cause the window to be the foreground
    window and centered.

Arguments:

    hwnd       - window handle to the dialog box
    message    - message number
    wParam     - first message parameter
    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    if (message == WM_INITDIALOG) {
        SetForegroundWindow( hwnd );
//      CenterWindow( hwnd, hwndFrame );
    }

    return FALSE;
}


BOOL
BrowseForFileName(
    HWND   hwnd,
    LPWSTR FileName,
    LPWSTR Extension,
    LPWSTR FileDesc,
    LPWSTR Dir
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    file name;

Arguments:

    FileName - name of the selected file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the FileName is changed to have the selected file name.

--*/

{
    OPENFILENAME    of;
    WCHAR           ftitle[MAX_PATH];
    WCHAR           title[MAX_PATH];
    WCHAR           fname[MAX_PATH];
    WCHAR           filter[1024];
    LPWSTR          s;


    ftitle[0] = 0;
    swprintf( fname, L"*.%s", Extension );
    ZeroMemory( filter, sizeof(filter) );

    s = filter;

    s += 1 + swprintf( s, L"%s(*.%s)", FileDesc, Extension );
    s += 1 + swprintf( s, L"*.%s", Extension );

    s += 1 + swprintf( s, L"All Files(*.*)" );
    s += 1 + swprintf( s, L"*.*" );

    wcscpy( title, L"File Selection" );

    of.lStructSize       = sizeof( OPENFILENAME );
    of.hwndOwner         = hwnd;
    of.hInstance         = GetModuleHandle( NULL );
    of.lpstrFilter       = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter    = 0;
    of.nFilterIndex      = 1;
    of.lpstrFile         = fname;
    of.nMaxFile          = MAX_PATH;
    of.lpstrFileTitle    = ftitle;
    of.nMaxFileTitle     = MAX_PATH;
    of.lpstrInitialDir   = Dir;
    of.lpstrTitle        = title;
    of.Flags             = OFN_ENABLEHOOK | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
    of.nFileOffset       = 0;
    of.nFileExtension    = 0;
    of.lpstrDefExt       = Extension;
    of.lCustData         = 0;
    of.lpfnHook          = BrowseHookProc;
    of.lpTemplateName    = NULL;

    if (GetOpenFileName( &of )) {
        wcscpy( FileName, fname );
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxqueue\util.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

  util.cpp

Abstract:

  This module implements utility functions for the fax queue viewer

Environment:

  WIN32 User Mode

Author:

  Andrew Ritz (andrewr) 14-jan-1998
  Steven Kehrli (steveke) 30-oct-1998 - major rewrite

--*/

#include "faxqueue.h"

VOID
GetFaxQueueRegistryData(
    PWINPOSINFO  pWinPosInfo
)
/*++

Routine Description:

  Get the persistent data for the fax queue viewer

Arguments:

  pWinPosInfo - pointer to the structure that contains the persistent data

Return Value:

  None

--*/
{
    HKEY             hKey;
    DWORD            dwDisposition;
    DWORD            dwType;

#ifdef DEBUG
    // bDebug indicates if debugging is enabled
    BOOL             bDebug;
    DWORD            dwDebugSize;
#endif // DEBUG

#ifdef TOOLBAR_ENABLED
    // bToolbarVisible is the status of the toolbar
    BOOL             bToolbarVisible;
    DWORD            dwToolbarSize;
#endif

    // bStatusBarVisible is the state of the status bar
    BOOL             bStatusBarVisible;
    DWORD            dwStatusBarSize;

    // nColumnIndex is used to enumerate each column of the list view
    INT              nColumnIndex;
    // szColumnKey is the string representation of a column's registry value
    TCHAR            szColumnKey[RESOURCE_STRING_LEN];

    // dwColumnWidth is the column width
    DWORD            dwColumnWidth;
    DWORD            dwColumnSize;

    // WindowPlacement is the window placement
    WINDOWPLACEMENT  WindowPlacement;
    DWORD            dwWindowPlacementSize;

#ifdef DEBUG
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {
        // Get the state of the job id
        dwDebugSize = sizeof(bDebug);
        if (RegQueryValueEx(hKey, REGVAL_DBGLEVEL, NULL, &dwType, (LPBYTE) &bDebug, &dwDebugSize) == ERROR_SUCCESS) {
            pWinPosInfo->bDebug = bDebug;
        }

        RegCloseKey(hKey);
    }
#endif // DEBUG

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGKEY_FAXQUEUE, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {
#ifdef TOOLBAR_ENABLED
        // Get the state of the toolbar
        dwToolbarSize = sizeof(bToolbarVisible);
        if (RegQueryValueEx(hKey, REGVAL_TOOLBARS, NULL, &dwType, (LPBYTE) &bToolbarVisible, &dwToolbarSize) == ERROR_SUCCESS) {
            pWinPosInfo->bToolbarVisible = bToolbarVisible;
        }
#endif // TOOLBAR_ENABLED

        // Get the state of the status bar
        dwStatusBarSize = sizeof(bStatusBarVisible);
        if (RegQueryValueEx(hKey, REGVAL_STATUSBAR, NULL, &dwType, (LPBYTE) &bStatusBarVisible, &dwStatusBarSize) == ERROR_SUCCESS) {
            pWinPosInfo->bStatusBarVisible = bStatusBarVisible;
        }

        // Get the column widths
        for (nColumnIndex = 0; nColumnIndex < (INT) eIllegalColumnIndex; nColumnIndex++) {
            // Set the column's registry value
            wsprintf(szColumnKey, REGVAL_COLUMNWIDTH, nColumnIndex);

            dwColumnSize = sizeof(dwColumnWidth);
            if (RegQueryValueEx(hKey, szColumnKey, NULL, &dwType, (LPBYTE) &dwColumnWidth, &dwColumnSize) == ERROR_SUCCESS) {
                pWinPosInfo->ColumnWidth[nColumnIndex] = dwColumnWidth;
            }
        }

        // Get the window placement
        dwWindowPlacementSize = sizeof(WindowPlacement);
        if (RegQueryValueEx(hKey, REGVAL_WINDOW_PLACEMENT, NULL, &dwType, (LPBYTE) &WindowPlacement, &dwWindowPlacementSize) == ERROR_SUCCESS) {
            if (dwWindowPlacementSize == sizeof(WindowPlacement)) {
                CopyMemory((LPBYTE) &pWinPosInfo->WindowPlacement, (LPBYTE) &WindowPlacement, sizeof(WindowPlacement));
            }
        }

        RegCloseKey(hKey);
    }
}

VOID
SetFaxQueueRegistryData(
#ifdef TOOLBAR_ENABLED
    BOOL  bToolbarVisible,
#endif // TOOLBAR_ENABLED
    BOOL  bStatusBarVisible,
    HWND  hWndList,
    HWND  hWnd
)
/*++

Routine Description:

  Set the persistent data for the fax queue viewer

Arguments:

  bToolbarVisible - status of the toolbar
  bStatusBarVisible - status of the status bar
  hWndList - handle to the list view
  hWnd - handle to the fax queue viewer window

Return Value:

  None

--*/
{
    HKEY             hKey;
    DWORD            dwDisposition;

    // nColumnIndex is used to enumerate each column of the list view
    INT              nColumnIndex;
    // szColumnKey is the string representation of a column's registry value
    TCHAR            szColumnKey[RESOURCE_STRING_LEN];

    // dwColumnWidth is the column width
    DWORD            dwColumnWidth;

    // WindowPlacement is the window placement
    WINDOWPLACEMENT  WindowPlacement;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGKEY_FAXQUEUE, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {
#ifdef TOOLBAR_ENABLED
        // Set the state of the toolbar
        RegSetValueEx(hKey, REGVAL_TOOLBARS, 0, REG_DWORD, (LPBYTE) &bToolbarVisible, sizeof(bToolbarVisible));
#endif // TOOLBAR_ENABLED

        // Set the state of the status bar
        RegSetValueEx(hKey, REGVAL_STATUSBAR, 0, REG_DWORD, (LPBYTE) &bStatusBarVisible, sizeof(bStatusBarVisible));

        // Set the column widths
        for (nColumnIndex = 0; nColumnIndex < (INT) eIllegalColumnIndex; nColumnIndex++) {
            // Set the column's registry value
            wsprintf(szColumnKey, REGVAL_COLUMNWIDTH, nColumnIndex);

            dwColumnWidth = ListView_GetColumnWidth(hWndList, nColumnIndex);
            RegSetValueEx(hKey, szColumnKey, 0, REG_DWORD, (LPBYTE) &dwColumnWidth, sizeof(dwColumnWidth));
        }

        // Set the window placement
        GetWindowPlacement(hWnd, &WindowPlacement);
        WindowPlacement.showCmd = SW_SHOWNORMAL;
        RegSetValueEx(hKey, REGVAL_WINDOW_PLACEMENT, 0, REG_BINARY, (LPBYTE) &WindowPlacement, sizeof(WindowPlacement));

        RegCloseKey(hKey);
    }
}

VOID
GetColumnHeaderText(
    eListViewColumnIndex  eColumnIndex,
    LPTSTR                szColumnHeader
)
/*++

Routine Description:

  Builds a string containing the text of a column header to be added to the list view

Arguments:

  eColumnIndex - indicates the column number
  szColumnHeader - column header text

Return Value:

  None

--*/
{
    UINT   uResource = 0;
    TCHAR  szString[RESOURCE_STRING_LEN];

    switch (eColumnIndex) {
        case eDocumentName:
            uResource = IDS_DOCUMENT_NAME_COLUMN;
            break;

        case eJobType:
            uResource = IDS_JOB_TYPE_COLUMN;
            break;

        case eStatus:
            uResource = IDS_STATUS_COLUMN;
            break;

        case eOwner:
            uResource = IDS_OWNER_COLUMN;
            break;

        case ePages:
            uResource = IDS_PAGES_COLUMN;
            break;

        case eSize:
            uResource = IDS_SIZE_COLUMN;
            break;
         
        case eScheduledTime:
            uResource = IDS_SCHEDULED_TIME_COLUMN;
            break;

        case ePort:
            uResource = IDS_PORT_COLUMN;
            break;
    }

    if (uResource) {
        LoadString(g_hInstance, uResource, szString, RESOURCE_STRING_LEN);
        lstrcpy(szColumnHeader, szString);
    }
    else {
        lstrcpy(szColumnHeader, TEXT(""));
    }
}

LPVOID
LocalEnumPrinters(
    DWORD    dwFlags,
    DWORD    dwLevel,
    LPDWORD  pdwNumPrinters
)
/*++

Routine Description:

  Enumerate all the printers

Arguments:

  dwFlags - type of print objects to enumerate
  dwLevel - type of printer info structure
  pdwNumPrinters - pointer to the number of printers

Return Value:

  Pointer to the printers configuration

--*/
{
    // pPrintersConfig is a pointer to the printers configuration
    LPVOID  pPrintersConfig;
    DWORD   cb;

    *pdwNumPrinters = 0;

    // Enumerate all the printers
    if ((!EnumPrinters(dwFlags, NULL, dwLevel, NULL, 0, &cb, pdwNumPrinters)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPrinters failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrintersConfig = MemAlloc(cb);

        // Call EnumPrinters again with the correct size buffer
        if (!EnumPrinters(dwFlags, NULL, dwLevel, (LPBYTE) pPrintersConfig, cb, &cb, pdwNumPrinters)) {
            // EnumPrinters failed
            MemFree(pPrintersConfig);

            // Return NULL pointer
            return NULL;
        }

        // Return pointer to the buffer
        return pPrintersConfig;
    }

    // Return NULL pointer
    return NULL;
}

int __cdecl
ComparePrinterNames(
    const void  *arg1,
    const void  *arg2
)
{
    return (CompareString(LOCALE_USER_DEFAULT, 0, ((LPPRINTER_INFO_2) arg1)->pPrinterName, -1, ((LPPRINTER_INFO_2) arg2)->pPrinterName, -1) - 2);
}

LPVOID
GetFaxPrinters(
    LPDWORD  pdwNumFaxPrinters
)
/*++

Routine Description:

  Get the fax printers

Arguments:

  pdwNumFaxPrinters - pointer to the number of fax printers

Return Value:

  Pointer to the fax printers configuration

--*/
{
    // pFaxPrintersConfig is a pointer to the printers configuration
    LPPRINTER_INFO_2  pFaxPrintersConfig;
    // dwNumPrinters is the number of printers
    DWORD             dwNumPrinters;
    // dwNumFaxPrinters is the number of fax printers
    DWORD             dwNumFaxPrinters;
    // dwIndex is a counter to enumerate each printer
    DWORD             dwIndex;
    // dwFlags is the type of print objects to enumerate
    DWORD             dwFlags;

#ifdef WIN95
    dwFlags = PRINTER_ENUM_LOCAL;
#else
    dwFlags = PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS;
#endif // WIN95

    // Enumerate all the printers
    pFaxPrintersConfig = (LPPRINTER_INFO_2) LocalEnumPrinters(dwFlags, 2, &dwNumPrinters);
    if (!pFaxPrintersConfig) {
        *pdwNumFaxPrinters = 0;
        return NULL;
    }

    // Determine the number of fax printers
    for (dwIndex = 0, dwNumFaxPrinters = 0; dwIndex < dwNumPrinters; dwIndex++) {
        // A fax printer is determined by comparing the name of the current printer driver against the name of the fax printer driver
        if (!lstrcmpi((pFaxPrintersConfig)[dwIndex].pDriverName, FAX_DRIVER_NAME)) {
            // Name of the current printer driver and the name of the fax printer driver match
            // Increment the number of fax printers
            dwNumFaxPrinters += 1;
        }
    }

    if (dwNumFaxPrinters > 0) {
        for (dwIndex = 0, dwNumFaxPrinters = 0; dwIndex < dwNumPrinters; dwIndex++) {
            // A fax printer is determined by comparing the name of the current printer driver against the name of the fax printer driver
            if (!lstrcmpi((pFaxPrintersConfig)[dwIndex].pDriverName, FAX_DRIVER_NAME)) {
                // Name of the current printer driver and the name of the fax printer driver match
                // Move fax printer up to the next available slot
                pFaxPrintersConfig[dwNumFaxPrinters] = pFaxPrintersConfig[dwIndex];
                // Increment the number of fax printers
                dwNumFaxPrinters++;
            }
        }

        // Quick sort the fax printers
        qsort(pFaxPrintersConfig, dwNumFaxPrinters, sizeof(PRINTER_INFO_2), ComparePrinterNames);
    }
    else {
        MemFree(pFaxPrintersConfig);
        pFaxPrintersConfig = NULL;
    }

    *pdwNumFaxPrinters = dwNumFaxPrinters;
    return pFaxPrintersConfig;
}

LPTSTR
GetDefaultPrinterName(
)
/*++

Routine Description:

  Get the default printer

Return Value:

  Name of the default printer

--*/
{
    // szPrinterName is the printer name
    LPTSTR            szPrinterName;

#ifdef WIN95
    // pPrintersConfig is a pointer to the printers configuration
    LPPRINTER_INFO_5  pPrintersConfig;
    // dwNumPrinters is the number of printers
    DWORD             dwNumPrinters;

    // Enumerate all the printers
    pPrintersConfig = (LPPRINTER_INFO_5) LocalEnumPrinters(PRINTER_ENUM_DEFAULT, 5, &dwNumPrinters);
    if (!pPrintersConfig) {
        return NULL;
    }

    // Allocate the memory for the printer name
    szPrinterName = (LPTSTR) MemAlloc((lstrlen(pPrintersConfig->pPrinterName) + 1) * sizeof(TCHAR));
    // Copy the printer name
    lstrcpy(szPrinterName, pPrintersConfig->pPrinterName);
    MemFree(pPrintersConfig);

    return szPrinterName;
#else
    DWORD             cb;

    // Get the default printer
    cb = 0;
    if ((!GetDefaultPrinter(NULL, &cb)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // GetDefaultPrinter failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        szPrinterName = (LPTSTR) MemAlloc(cb * sizeof(TCHAR));

        // Call GetDefaultPrinter again with the correct size buffer
        if (!GetDefaultPrinter(szPrinterName, &cb)) {
            // GetDefaultPrinter failed
            MemFree(szPrinterName);

            // Return NULL pointer
            return NULL;
        }

        // Return pointer to the buffer
        return szPrinterName;
    }

    // Return NULL pointer
    return NULL;
#endif // WIN95
}

VOID
SetDefaultPrinterName(
    LPTSTR  szPrinterName
)
/*++

Routine Description:

  Set the default printer

Arguments:

  szPrinterName - name of the printer to set as the default

Return Value:

  None

--*/
{
#ifdef WIN95
    // hPrinter is the handle to the printer
    HANDLE            hPrinter;
    // pPrintersConfig is a pointer to the printers configuration
    LPPRINTER_INFO_2  pPrintersConfig;
    DWORD             cb;

    // Open the printer
    if (OpenPrinter(szPrinterName, &hPrinter, NULL)) {
        // Get the printer
        cb = 0;
        if ((!GetPrinter(hPrinter, 2, NULL, 0, &cb)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            // GetPrinter failed because the buffer is too small
            // cb is the size of the buffer needed, so allocate a buffer of that size
            pPrintersConfig = (LPPRINTER_INFO_2) MemAlloc(cb);

            // Call GetPrinter again with the correct size buffer
            if (!GetPrinter(hPrinter, 2, (LPBYTE) pPrintersConfig, cb, &cb)) {
                // GetPrinter failed
                MemFree(pPrintersConfig);

                // Close the printer
                ClosePrinter(hPrinter);

                // Return
                return;
            }

            // Set the default attribute
            pPrintersConfig->Attributes |= PRINTER_ATTRIBUTE_DEFAULT;

            // Set the printer
            SetPrinter(hPrinter, 2, (LPBYTE) pPrintersConfig, 0);

            MemFree(pPrintersConfig);
        }

        // Close the printer
        ClosePrinter(hPrinter);
    }
#else
    // Set the default printer
    SetDefaultPrinter(szPrinterName);
#endif // WIN95

}

VOID
Disconnect(
)
{
    // Wait for access to these fax service routines
    WaitForSingleObject(g_hFaxSvcMutex, INFINITE);

    // Decrement the number of connections to the fax service
    g_nNumConnections--;

    // Disconnect from the fax service if no outstanding connections
    if (!g_nNumConnections) {
        FaxClose(g_hFaxSvcHandle);
        g_hFaxSvcHandle = NULL;
    }

    ReleaseMutex(g_hFaxSvcMutex);
}

BOOL
Connect(
)
{
    BOOL  bVal = FALSE;

    // Wait for access to these fax service routines
    WaitForSingleObject(g_hFaxSvcMutex, INFINITE);

    // Connect to the fax service if not already connected
    if ((g_nNumConnections) || (FaxConnectFaxServer(g_szMachineName, &g_hFaxSvcHandle))) {
        // Increment the number of connections to the fax service
        g_nNumConnections++;
        bVal = TRUE;
    }

    ReleaseMutex(g_hFaxSvcMutex);

    return bVal;
}

LPTSTR
GetColumnItemText(
    eListViewColumnIndex  eColumnIndex,
    PFAX_JOB_ENTRY        pFaxJobEntry,
    LPTSTR                szDeviceName
)
/*++

Routine Description:

  Build a string containing the text of a column item to be added to the list view

Arguments:

  eColumnIndex - indicates the column number
  pFaxJobEntry - pointer to the fax job
  szDeviceName - device name the fax job is active on

Return Value:

  LPTSTR - text of the column item

--*/
{
    // szColumnItem is the text of the column item
    LPTSTR  szColumnItem;
    // szResourceString is a resource string
    TCHAR   szResourceString[RESOURCE_STRING_LEN];
    // uResource is the id of the resource string
    UINT    uResource;
    DWORD   cb;

    switch (eColumnIndex) {
        case eDocumentName:
            // szNullString is the null resource string
            TCHAR  szNullString[RESOURCE_STRING_LEN];

            // Determine the queue status resource string
            if (pFaxJobEntry->QueueStatus & JS_DELETING) {
                uResource = IDS_QUEUE_STATUS_DELETING;
            }
            else if (pFaxJobEntry->QueueStatus & JS_PAUSED) {
                uResource = IDS_QUEUE_STATUS_PAUSED;
            }
            else if (pFaxJobEntry->QueueStatus & JS_RETRYING) {
                uResource = IDS_QUEUE_STATUS_RETRYING;
            }
            else {
                uResource = 0;
            }

            // Load the queue status resource string, if necessary, and determine its memory requirement
            cb = 0;
            if (uResource) {
                LoadString(g_hInstance, uResource, szResourceString, RESOURCE_STRING_LEN);
                cb = lstrlen(szResourceString) * sizeof(TCHAR);
            }

            if (pFaxJobEntry->DocumentName) {
                cb += (lstrlen(pFaxJobEntry->DocumentName) + 1) * sizeof(TCHAR);
            }
            else {
                // Load the null resource string
                LoadString(g_hInstance, IDS_NO_DOCUMENT_NAME, szNullString, RESOURCE_STRING_LEN);
                cb += (lstrlen(szNullString) + 1) * sizeof(TCHAR);
            }

#ifdef DEBUG
            if (WinPosInfo.bDebug) {
                cb += lstrlen(TEXT("0x00000000 ")) * sizeof(TCHAR);
            }
#endif // DEBUG

            // Allocate the memory for the document name and set the document name
            szColumnItem = (LPTSTR) MemAlloc(cb);
            if (szColumnItem) {
#ifdef DEBUG
                if (WinPosInfo.bDebug) {
                    wsprintf(szColumnItem, TEXT("0x%08x "), pFaxJobEntry->JobId);
                }

                if (pFaxJobEntry->DocumentName) {
                    lstrcat(szColumnItem, pFaxJobEntry->DocumentName);
                }
                else {
                    lstrcat(szColumnItem, szNullString);
                }
#else
                if (pFaxJobEntry->DocumentName) {
                    lstrcpy(szColumnItem, pFaxJobEntry->DocumentName);
                }
                else {
                    lstrcpy(szColumnItem, szNullString);
                }
#endif // DEBUG

                if (uResource) {
                    lstrcat(szColumnItem, szResourceString);
                }

                return szColumnItem;
            }

            return NULL;

        case eJobType:
            // Determine the job type resource string
            switch (pFaxJobEntry->JobType) {
                case JT_SEND:
                    uResource = IDS_JOB_TYPE_SEND;
                    break;

                case JT_RECEIVE:
                    uResource = IDS_JOB_TYPE_RECEIVE;
                    break;

                case JT_ROUTING:
                    uResource = IDS_JOB_TYPE_ROUTING;
                    break;

                case JT_FAIL_RECEIVE:
                    uResource = IDS_JOB_TYPE_FAIL_RECEIVE;
                    break;

                default:
                    uResource = 0;
                    break;
            }

            // Load the job type resource string, if necessary
            if (uResource) {
                LoadString(g_hInstance, uResource, szResourceString, RESOURCE_STRING_LEN);
                // Allocate the memory for the job type and set the job type
                szColumnItem = (LPTSTR) MemAlloc((lstrlen(szResourceString) + 1) * sizeof(TCHAR));
                if (szColumnItem) {
                    lstrcpy(szColumnItem, szResourceString);

                    return szColumnItem;
                }
            }

            return NULL;

        case eStatus: 
            // Determine the job status resource string
            switch (pFaxJobEntry->Status) {
                case FPS_DIALING:
                    uResource = IDS_JOB_STATUS_DIALING;
                    break;

                case FPS_SENDING:
                    uResource = IDS_JOB_STATUS_SENDING;
                    break;

                case FPS_RECEIVING:
                    uResource = IDS_JOB_STATUS_RECEIVING;
                    break;

                case FPS_COMPLETED:
                    uResource = IDS_JOB_STATUS_COMPLETED;
                    break;

                case FPS_HANDLED:
                    uResource = IDS_JOB_STATUS_HANDLED;
                    break;

                case FPS_UNAVAILABLE:
                    uResource = IDS_JOB_STATUS_UNAVAILABLE;
                    break;

                case FPS_BUSY:
                    uResource = IDS_JOB_STATUS_BUSY;
                    break;

                case FPS_NO_ANSWER:
                    uResource = IDS_JOB_STATUS_NO_ANSWER;
                    break;

                case FPS_BAD_ADDRESS:
                    uResource = IDS_JOB_STATUS_BAD_ADDRESS;
                    break;

                case FPS_NO_DIAL_TONE:
                    uResource = IDS_JOB_STATUS_NO_DIAL_TONE;
                    break;

                case FPS_DISCONNECTED:
                    uResource = IDS_JOB_STATUS_DISCONNECTED;
                    break;

                case FPS_FATAL_ERROR:
                    if (pFaxJobEntry->JobType == JT_RECEIVE) {
                        uResource = IDS_JOB_STATUS_FATAL_ERROR_RCV;
                    }
                    else {
                        uResource = IDS_JOB_STATUS_FATAL_ERROR_SND;
                    }
                    break;

                case FPS_NOT_FAX_CALL:
                    uResource = IDS_JOB_STATUS_NOT_FAX_CALL;
                    break;

                case FPS_CALL_DELAYED:
                    uResource = IDS_JOB_STATUS_CALL_DELAYED;
                    break;

                case FPS_CALL_BLACKLISTED:
                    uResource = IDS_JOB_STATUS_CALL_BLACKLISTED;
                    break;

                case FPS_INITIALIZING:
                    uResource = IDS_JOB_STATUS_INITIALIZING;
                    break;

                case FPS_OFFLINE:
                    uResource = IDS_JOB_STATUS_OFFLINE;
                    break;

                case FPS_RINGING:
                    uResource = IDS_JOB_STATUS_RINGING;
                    break;

                case FPS_AVAILABLE:
                    uResource = IDS_JOB_STATUS_AVAILABLE;
                    break;

                case FPS_ABORTING:
                    uResource = IDS_JOB_STATUS_ABORTING;
                    break;

                case FPS_ROUTING:
                    uResource = IDS_JOB_STATUS_ROUTING;
                    break;

                case FPS_ANSWERED:
                    uResource = IDS_JOB_STATUS_ANSWERED;
                    break;

                default:
                    uResource = 0;
                    break;
            }

            // Determine if retries have been exceeded
            if (((pFaxJobEntry->JobType == JT_SEND) || (pFaxJobEntry->JobType == JT_ROUTING)) && (pFaxJobEntry->QueueStatus & JS_RETRIES_EXCEEDED)) {
                uResource = IDS_QUEUE_STATUS_RETRIES_EXCEEDED;
            }

            // Load the job status resource string, if necessary
            if (uResource) {
                LoadString(g_hInstance, uResource, szResourceString, RESOURCE_STRING_LEN);
                // Allocate the memory for the job status and set the job type
                if (uResource == IDS_JOB_STATUS_DIALING) {
                    szColumnItem = (LPTSTR) MemAlloc((lstrlen(szResourceString) + lstrlen(pFaxJobEntry->RecipientNumber) + 1) * sizeof(TCHAR));
                }
                else {
                    szColumnItem = (LPTSTR) MemAlloc((lstrlen(szResourceString) + 1) * sizeof(TCHAR));
                }
                if (szColumnItem) {
                    if (uResource == IDS_JOB_STATUS_DIALING) {
                        wsprintf(szColumnItem, szResourceString, pFaxJobEntry->RecipientNumber);
                    }
                    else {
                        lstrcpy(szColumnItem, szResourceString);
                    }

                    return szColumnItem;
                }
            }

            return NULL;

        case eOwner:
            // Allocate the memory for the job owner and set the job owner, if necessary
            if (pFaxJobEntry->UserName) {
                szColumnItem = (LPTSTR) MemAlloc((lstrlen(pFaxJobEntry->UserName) + 1) * sizeof(TCHAR));
                if (szColumnItem) {
                    lstrcpy(szColumnItem, pFaxJobEntry->UserName);

                    return szColumnItem;
                }
            }

            return NULL;

        case ePages:
            // Set the job pages resource string, if necessary
            if (pFaxJobEntry->PageCount) {
                wsprintf(szResourceString, TEXT("%d"), pFaxJobEntry->PageCount);
                // Allocate the memory for the job pages and set the job pages
                szColumnItem = (LPTSTR) MemAlloc((lstrlen(szResourceString) + 1) * sizeof(TCHAR));
                if (szColumnItem) {
                    lstrcpy(szColumnItem, szResourceString);

                    return szColumnItem;
                }
            }

            return NULL;

        case eSize:
            // Determine the job size resource string
            if (pFaxJobEntry->Size) {
                // szNumberString is the number string
                LPTSTR  szNumberString;

                if (pFaxJobEntry->Size < 1024) {
                    uResource = IDS_JOB_SIZE_BYTES;
                    // Set the job size number string
                    wsprintf(szResourceString, TEXT("%u"), pFaxJobEntry->Size);
                }
                else if (pFaxJobEntry->Size < 1024 * 1024) {
                    uResource = IDS_JOB_SIZE_KBYTES;
                    // Set the job size number string
                    wsprintf(szResourceString, TEXT("%u.%2u"), pFaxJobEntry->Size / 1024, pFaxJobEntry->Size % 1024);
                }
                else if (pFaxJobEntry->Size < 1024 * 1024 * 1024) {
                    uResource = IDS_JOB_SIZE_MBYTES;
                    // Set the job size number string
                    wsprintf(szResourceString, TEXT("%u.%2u"), pFaxJobEntry->Size / (1024 * 1024), pFaxJobEntry->Size % (1024 * 1024));
                }
                else {
                    uResource = IDS_JOB_SIZE_GBYTES;
                    // Set the job size number string
                    wsprintf(szResourceString, TEXT("%u.%2u"), pFaxJobEntry->Size / (1024 * 1024 * 1024), pFaxJobEntry->Size % (1024 * 1024 * 1024));
                }

                // Format the number string
                cb = GetNumberFormat(LOCALE_USER_DEFAULT, 0, szResourceString, NULL, NULL, 0);
                szNumberString = (LPTSTR) MemAlloc((cb + 1) * sizeof(TCHAR));
                if (szNumberString) {
                    GetNumberFormat(LOCALE_USER_DEFAULT, 0, szResourceString, NULL, szNumberString, cb);

                    LoadString(g_hInstance, uResource, szResourceString, RESOURCE_STRING_LEN);
                    // Allocate the memory for the job size and set the job size
                    szColumnItem = (LPTSTR) MemAlloc((lstrlen(szNumberString) + lstrlen(szResourceString) + 1) * sizeof(TCHAR));
                    if (szColumnItem) {
                        wsprintf(szColumnItem, szResourceString, szNumberString);
                        MemFree(szNumberString);

                        return szColumnItem;
                    }

                    MemFree(szNumberString);
                }
            }

            return NULL;

        case eScheduledTime:
            // Set the job scheduled time resource string
            if (pFaxJobEntry->ScheduleAction == JSA_NOW) {
                LoadString(g_hInstance, IDS_JOB_SCHEDULED_TIME_NOW, szResourceString, RESOURCE_STRING_LEN);
            }
            else {
                // Convert the schedule time to the local time zone
                SystemTimeToTzSpecificLocalTime(NULL, &pFaxJobEntry->ScheduleTime, &pFaxJobEntry->ScheduleTime);

                GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &pFaxJobEntry->ScheduleTime, NULL, szResourceString, RESOURCE_STRING_LEN);
                lstrcat(szResourceString, TEXT(" "));
                cb = lstrlen(szResourceString);
                GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &pFaxJobEntry->ScheduleTime, NULL, &szResourceString[cb], RESOURCE_STRING_LEN - cb);
            }

            // Allocate the memory for the job schedule time and set the job schedule time
            szColumnItem = (LPTSTR) MemAlloc((lstrlen(szResourceString) + 1) * sizeof(TCHAR));
            if (szColumnItem) {
                lstrcpy(szColumnItem, szResourceString);

                return szColumnItem;
            }

            return NULL;

        case ePort:
            // Allocate the memory for the job port and set the job port, if necessary
            if (szDeviceName) {
                szColumnItem = (LPTSTR) MemAlloc((lstrlen(szDeviceName) + 1) * sizeof(TCHAR));
                if (szColumnItem) {
                    lstrcpy(szColumnItem, szDeviceName);

                    return szColumnItem;
                }
            }

            return NULL;

        case eIllegalColumnIndex:
            break;
    }

    return NULL;
}

VOID
SetColumnItem(
    HWND            hWndListView,
    BOOL            bInsert,
    INT             iItem,
    INT             iSubItem,
    LPTSTR          szColumnItem,
    UINT            uState,
    PFAX_JOB_ENTRY  pFaxJobEntry
)
/*++

Routine Description:

  Set or insert a column item in the list view

Arguments:

  hWndListView - handle to the list view window
  bInsert - indicates item is to be inserted into the list view
  iItem - index of the item
  iSubItem - index of the subitem
  szColumnItem - column item text
  uState - state of the item
  pFaxJobEntry - pointer to the fax job

Return Value:

  None

--*/
{
    // lvi specifies the attributes of a particular item in the list view
    LV_ITEM  lvi;

    // Initialize lvi
    lvi.mask = LVIF_TEXT;
    // Set the item number
    lvi.iItem = iItem;
    // Set the subitem number
    lvi.iSubItem = iSubItem;
    // Set the item text
    lvi.pszText = szColumnItem;

    if (iSubItem == (INT) eDocumentName) {
        // Include the fax job id in the lParam
        lvi.mask = lvi.mask | LVIF_PARAM | LVIF_STATE;
        // Set the lParam
        lvi.lParam = pFaxJobEntry->JobId;
        // Set the item state
        lvi.state = uState;
        if (pFaxJobEntry->JobType == JT_SEND) {
            lvi.state |= ITEM_SEND_MASK;
        }
        if (!(pFaxJobEntry->QueueStatus & JS_INPROGRESS)) {
            lvi.state |= ITEM_IDLE_MASK;
        }
        if (pFaxJobEntry->QueueStatus & JS_PAUSED) {
            lvi.state |= ITEM_PAUSED_MASK;
        }
        if ((g_szCurrentUserName) && (!lstrcmpi(g_szCurrentUserName, pFaxJobEntry->UserName))) {
            lvi.state |= ITEM_USEROWNSJOB_MASK;
        }
        // Set the item state mask
        lvi.stateMask = uState | LVIS_OVERLAYMASK;
    }

    if ((bInsert) && (iSubItem == (INT) eDocumentName)) {
        ListView_InsertItem(hWndListView, &lvi);
    }
    else {
        ListView_SetItem(hWndListView, &lvi);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxview\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxview.c

Abstract:

    This file implements a simple TIFF image viewer.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxutil.h"
#include "faxreg.h"



extern WCHAR  LastDir[MAX_PATH*2];
extern DWORD  CurrZoom;



BOOL
SaveWindowPlacement(
    HWND hwnd
    )
{
    HKEY hKey;
    LONG rVal;
    WINDOWPLACEMENT wpl;


    wpl.length = sizeof(WINDOWPLACEMENT);

    if (!GetWindowPlacement( hwnd, &wpl )) {
        return FALSE;
    }

    rVal = RegCreateKey(
        HKEY_CURRENT_USER,
        REGKEY_FAXVIEW,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not create/open registry key") ));
        return FALSE;
    }

    rVal = RegSetValueEx(
        hKey,
        REGVAL_WINDOW_PLACEMENT,
        0,
        REG_BINARY,
        (LPBYTE) &wpl,
        sizeof(WINDOWPLACEMENT)
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not set registry value") ));
        return FALSE;
    }

    rVal = RegSetValueEx(
        hKey,
        REGVAL_LAST_ZOOM,
        0,
        REG_DWORD,
        (LPBYTE) &CurrZoom,
        sizeof(CurrZoom)
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not set registry value") ));
        return FALSE;
    }

    rVal = RegSetValueEx(
        hKey,
        REGVAL_LAST_DIR,
        0,
        REG_SZ,
        (LPBYTE) LastDir,
        StringSize( LastDir )
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not set registry value") ));
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
QueryWindowPlacement(
    HWND hwnd
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    WINDOWPLACEMENT wpl;


    rVal = RegCreateKey(
        HKEY_CURRENT_USER,
        REGKEY_FAXVIEW,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not create/open registry key") ));
        return FALSE;
    }

    RegSize = sizeof(WINDOWPLACEMENT);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_WINDOW_PLACEMENT,
        0,
        &RegType,
        (LPBYTE) &wpl,
        &RegSize
        );

    RegSize = sizeof(CurrZoom);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_LAST_ZOOM,
        0,
        &RegType,
        (LPBYTE) &CurrZoom,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        CurrZoom = 0;
    }

    RegSize = sizeof(LastDir);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_LAST_DIR,
        0,
        &RegType,
        (LPBYTE) LastDir,
        &RegSize
        );

    RegCloseKey( hKey );

    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query registry value, ec=0x%08x"), rVal ));
        return FALSE;
    }

    return SetWindowPlacement( hwnd, &wpl );
}



BOOL
IsItOkToAskForDefault(
    VOID
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD Ask;
    DWORD RegType;
    DWORD RegSize;


    rVal = RegCreateKey(
        HKEY_CURRENT_USER,
        REGKEY_FAXVIEW,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not create/open registry key") ));
        return TRUE;
    }

    RegSize = sizeof(DWORD);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_DONT_ASK,
        0,
        &RegType,
        (LPBYTE) &Ask,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query registry value, ec=0x%08x"), rVal ));
        Ask = 1;
    }

    return Ask;
}


BOOL
SetAskForViewerValue(
    DWORD Ask
    )
{
    HKEY hKey;
    LONG rVal;


    rVal = RegCreateKey(
        HKEY_CURRENT_USER,
        REGKEY_FAXVIEW,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not create/open registry key") ));
        return TRUE;
    }

    rVal = RegSetValueEx(
        hKey,
        REGVAL_DONT_ASK,
        0,
        REG_DWORD,
        (LPBYTE) &Ask,
        sizeof(DWORD)
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not set registry value") ));
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
IsFaxViewerDefaultViewer(
    VOID
    )
{
    WCHAR ValueBuf[64];
    LONG Size;


    Size = sizeof(ValueBuf);

    RegQueryValue(
        HKEY_CLASSES_ROOT,
        L".tif",
        ValueBuf,
        &Size
        );

    if (wcscmp( ValueBuf, L"Fax Document" ) == 0) {
        return TRUE;
    }

    return FALSE;
}


BOOL
CreateFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName,
    LPWSTR FileAssociationDescription,
    LPWSTR OpenCommand,
    LPWSTR PrintCommand,
    LPWSTR PrintToCommand,
    LPWSTR FileName,
    DWORD  IconIndex
    )
{
    LONG rVal = 0;
    HKEY hKey = NULL;
    HKEY hKeyOpen = NULL;
    HKEY hKeyPrint = NULL;
    HKEY hKeyPrintTo = NULL;
    HKEY hKeyIcon = NULL;
    DWORD Disposition = 0;
    WCHAR Buffer[MAX_PATH*2];


    rVal = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        FileExtension,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKey,
        NULL,
        0,
        REG_SZ,
        (LPBYTE) FileAssociationName,
        StringSize( FileAssociationName )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    RegCloseKey( hKey );

    rVal = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        FileAssociationName,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKey,
        NULL,
        0,
        REG_SZ,
        (LPBYTE) FileAssociationDescription,
        StringSize( FileAssociationDescription )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegCreateKeyEx(
        hKey,
        L"Shell\\Open\\Command",
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKeyOpen,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKeyOpen,
        NULL,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) OpenCommand,
        StringSize( OpenCommand )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    if (PrintCommand) {
        rVal = RegCreateKeyEx(
            hKey,
            L"Shell\\Print\\Command",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPrint,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        rVal = RegSetValueEx(
            hKeyPrint,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) PrintCommand,
            StringSize( PrintCommand )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

    if (PrintToCommand) {
        rVal = RegCreateKeyEx(
            hKey,
            L"Shell\\Printto\\Command",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPrintTo,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        rVal = RegSetValueEx(
            hKeyPrintTo,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) PrintToCommand,
            StringSize( PrintToCommand )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

    if (FileName) {
        rVal = RegCreateKeyEx(
            hKey,
            L"DefaultIcon",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyIcon,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        wsprintf( Buffer, L"%s,%d", FileName, IconIndex );

        rVal = RegSetValueEx(
            hKeyIcon,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) Buffer,
            StringSize( Buffer )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

exit:
    RegCloseKey( hKey );
    RegCloseKey( hKeyOpen );
    RegCloseKey( hKeyPrint );
    RegCloseKey( hKeyPrintTo );
    RegCloseKey( hKeyIcon );

    return rVal == ERROR_SUCCESS;
}


BOOL
MakeFaxViewerDefaultViewer(
    VOID
    )
{
    CreateFileAssociation(
        L".tif",
        L"Fax Document",
        L"Fax Document",
        L"%SystemRoot%\\system32\\FaxView.exe \"%1\"",
        L"%SystemRoot%\\system32\\FaxView.exe -p \"%1\"",
        L"%SystemRoot%\\system32\\FaxView.exe -pt \"%1\" \"%2\" \"%3\" \"%4\"",
        L"%SystemRoot%\\system32\\FaxView.exe",
        0
        );

    CreateFileAssociation(
        L".tiff",
        L"Fax Document",
        L"Fax Document",
        L"%SystemRoot%\\system32\\FaxView.exe \"%1\"",
        L"%SystemRoot%\\system32\\FaxView.exe -p \"%1\"",
        L"%SystemRoot%\\system32\\FaxView.exe -pt \"%1\" \"%2\" \"%3\" \"%4\"",
        L"%SystemRoot%\\system32\\FaxView.exe",
        0
        );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\faxview\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for TIFFVIEW's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


//
// icons
//
#define IDI_APPICON                     501

#define IDM_PRINT                       101
#define IDM_MAIL                        102
#define IDM_FILEOPEN                    103
#define IDM_PAGE_UP                     104
#define IDM_PAGE_DOWN                   105
#define IDM_PRINT_SETUP                 107
#define IDM_CLOSE                       108
#define IDM_HELP                        109
#define IDM_EXIT                        110
#define IDM_ABOUT                       111

#define IDM_ZOOM                        900
#define IDM_ZOOM_100                    901
#define IDM_ZOOM_90                     902
#define IDM_ZOOM_80                     903
#define IDM_ZOOM_70                     904
#define IDM_ZOOM_60                     905
#define IDM_ZOOM_50                     906
#define IDM_ZOOM_40                     907
#define IDM_ZOOM_30                     908
#define IDM_ZOOM_20                     909
#define IDM_ZOOM_10                     910

#define IDM_TOOLBAR                     301
#define IDM_COOLBAR                     302
#define IDM_STATUSBAR                   303
#define IDM_TOOLTIP                     304

#define FAXVIEW                         601
#define IDB_OPEN_BIG                    602
#define IDB_PRINT_BIG                   603
#define IDB_HELP_BIG                    604
#define IDB_COOLBAR                     605
#define IDB_ZOOM_BIG                    606

#define IDC_DEFAULT_VIEWER              201
#define IDD_VIEWER                      202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\config.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    config.h

Abstract:

    This file contains all typedefs, etc necessary
    for reading and writing the fax configuration
    information.

Author:

    Wesley Witt (wesw) 26-Dec-1993

Environment:

    User Mode

--*/

#ifndef _FAXCONFIG_
#define _FAXCONFIG_

#define SEND_ASAP                  0
#define SEND_CHEAP                 1
#define SEND_AT_TIME               2

#define SEND_BEST                  0
#define SEND_EDITABLE              1
#define SEND_PRINTED               2
#define DEFAULT_SEND_AS            SEND_BEST

#define PAPER_US_LETTER            0       // US Letter page size
#define PAPER_US_LEGAL             1
#define PAPER_A4                   2
#define PAPER_B4                   3
#define PAPER_A3                   4

#define PRINT_PORTRAIT             0       // Protrait printing
#define PRINT_LANDSCAPE            1
#define DEFAULT_PRINT_ORIENTATION  PRINT_PORTRAIT

#define IMAGE_QUALITY_BEST         0
#define IMAGE_QUALITY_STANDARD     1
#define IMAGE_QUALITY_FINE         2
#define IMAGE_QUALITY_300DPI       3
#define IMAGE_QUALITY_400DPI       4
#define DEFAULT_IMAGE_QUALITY      IMAGE_QUALITY_BEST

#define NUM_OF_SPEAKER_VOL_LEVELS  4   // Number of speaker volume levels
#define DEFAULT_SPEAKER_VOLUME     2   // Default speaker volume level
#define SPEAKER_ALWAYS_ON          2   // Speaker mode: always on
#define SPEAKER_ON_UNTIL_CONNECT   1   // speaker on unitl connected
#define SPEAKER_ALWAYS_OFF         0   // Speaker off
#define DEFAULT_SPEAKER_MODE       SPEAKER_ON_UNTIL_CONNECT   // Default speaker mode

#define NUM_OF_RINGS               3
#define ANSWER_NO                  0
#define ANSWER_MANUAL              1
#define ANSWER_AUTO                2
#define DEFAULT_ANSWER_MODE        ANSWER_NO

#define MakeTime(hh,mm,ampm)    ((ULONG)(((BYTE)(ampm)) | ((ULONG)((BYTE)(mm))) << 8) | ((ULONG)((BYTE)(hh))) << 16)
#define GetTime(tv,hh,mm,ampm)  \
                {\
                  ampm = (SHORT)((tv) & 0xff);\
                  mm   = (SHORT)(((tv) >> 8)  & 0xff);\
                  hh   = (SHORT)(((tv) >> 16) & 0xff);\
                }

typedef struct _FAX_CONFIGURATION {
    //
    // used for versioning
    //
    ULONG   SizeOfStruct;
    //
    // general
    //
    ULONG   Debug;
    TCHAR   DataFileDir[MAX_PATH];
    //
    // messaging
    //
    ULONG   SendTime;
    ULONG   CheapTimeStart;
    ULONG   CheapTimeEnd;
    ULONG   MsgFormat;
    ULONG   PaperSize;
    ULONG   ImageQuality;
    ULONG   Orientation;
    ULONG   SendCoverPage;
    ULONG   ChangeSubject;
    TCHAR   CoverPageName[MAX_PATH];
    //
    // dialing
    //
    ULONG   NumberRetries;
    ULONG   RetryDelay;
} FAX_CONFIGURATION, *PFAX_CONFIGURATION;


BOOL
GetFaxConfiguration(
    PFAX_CONFIGURATION  FaxConfig
    );

BOOL
SetFaxConfiguration(
    PFAX_CONFIGURATION  FaxConfig
    );

BOOL
SetDefaultFaxConfiguration(
    VOID
    );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\faxperf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxperf.h

Abstract:

    This file defines the fax perfmon dll interface.

Author:

    Wesley Witt (wesw) 22-Aug-1996

Environment:

    User Mode

--*/


#ifndef _FAXPERF_
#define _FAXPERF_

#ifdef __cplusplus
extern "C" {
#endif


#define FAXPERF_SHARED_MEMORY       TEXT("FaxPerfCounters")


typedef struct _FAX_PERF_COUNTERS {
    DWORD InboundBytes;
    DWORD InboundFaxes;
    DWORD InboundPages;
    DWORD InboundMinutes;
    DWORD InboundFailedReceive;
    DWORD OutboundBytes;
    DWORD OutboundFaxes;
    DWORD OutboundPages;
    DWORD OutboundMinutes;
    DWORD OutboundFailedConnections;
    DWORD OutboundFailedXmit;
    DWORD TotalBytes;
    DWORD TotalFaxes;
    DWORD TotalPages;
    DWORD TotalMinutes;
} FAX_PERF_COUNTERS, *PFAX_PERF_COUNTERS;



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\inc\dapi.h ===
/*******************************************************************
 *
 * Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *
 *    DESCRIPTION:   This header file defines the functions, structures,
 *                   and macros used to access the Microsoft Exchange
 *                   APIs for modifying entries in the Exchange 4.0 DIT.
 *                   These APIs permit a calling process to create, 
 *                   modify, or delete DIT objects by specifying the
 *                   name of a CSV text file containing attributes 
 *                   for objects to import into ( or to modify) 
 *                   the DIT.  See the Directory Access Functions
 *                   section of the Exchange Developer's Kit for 
 *                   more detailed description of this interface.
 *                   
 *                   Calling programs must link with DAPI.LIB.
 *                   
 *                   Error and warning codes are defined in DAPIMSG.H
 *
 *
 *******************************************************************/

/** include files **/
#ifndef _WINDOWS_
#include <windows.h>
#endif

/** local definitions **/

#ifndef  _DAPI_INCLUDED_
#define  _DAPI_INCLUDED_

#ifdef __cplusplus
extern "C"
{
#endif

// Import / Export APIs check for the presence of this signature in 
// the dwDAPISignature field in the import parameter blocks.
// This signature will be incremented each time one of the parameter
// blocks is changed so that header synchronization problems can be 
// detected.
#define  DAPI_SIGNATURE                   0x46414400


// Combinable flags used to control the API functions.

   // The following flags control filtering of DAPI events
   // The default action is DAPI_EVENT_ALL
#define DAPI_EVENT_MASK                   0x00000007  /* bit-field containing event-filtering requested 
                                                         if none of these bits are set, DAPI_EVENT_ALL is assumed */
#define DAPI_EVENT_MIN                    0x00000001  /* No warning or error logging.
                                                         Log start and stop messages */
#define DAPI_EVENT_SOME                   0x00000002  /* Start, Stop, and Error messages will be logged. */
#define DAPI_EVENT_ALL                    0x00000004  /* Start, Stop, Error, and Warning messages
                                                         will be logged. */
                                                         
   // The following flags control schema read and use of the schema
#define DAPI_FORCE_SCHEMA_LOAD            0x00000010  /* Unload previously loaded schema
                                                         and read schema again.
                                                         Default action is to re-use
                                                         previously loaded schema if read
                                                         from the same messaging domain */
#define DAPI_RAW_MODE                     0x00000020  /* Import / Export in "Raw" mode.  Import
                                                         lines are taken literally.  No
                                                         attributes will be inherited, 
                                                         constructed, etc.  Aliases for 
                                                         attribute and class names will
                                                         not be recognized. */
                                                         
#define DAPI_OVERRIDE_CONTAINER           0x00000040  /* Container specified in the parameter block
                                                         overrides the contents of the container column.
                                                         Default behaviour is for the value specified
                                                         in the Obj-Container column to override
                                                         that specified in the parameter block */
                                                 
#define DAPI_IMPORT_NO_ERR_FILE           0x00000080  /* Do not create Error File -- BatchImport only */
#define DAPI_IMPORT_WRITE_THROUGH         0x00400000  /* Commit write operations immediately */

// Flags defined for "Batch" operations only -- ignored by DAPIRead, DAPIWrite
#define DAPI_YES_TO_ALL                   0x00000100  /* Force "yes" response on any
                                                         user-prompt UI 
                                                         (i.e., continue w/o proxy addresses, etc.) */

#define DAPI_SUPPRESS_PROGRESS            0x00000200  /* Suppress progress thermometer on batch operations.
                                                         Default is to display progress */
#define DAPI_SUPPRESS_COMPLETION          0x00000400  /* Suppress completion notification message box on batch operations */
                                                         
#define DAPI_SUPPRESS_ARCHIVES            0x00000800  /* Suppress creation of "archive" copies
                                                         of output files -- BatchImport and BatchExport only*/
                                                         


// Flags defined for BatchExport
#define DAPI_EXPORT_MAILBOX               0x00001000  /* Export Mailbox recipients */
#define DAPI_EXPORT_CUSTOM                0x00002000  /* Export remote address recipients */
#define DAPI_EXPORT_DIST_LIST             0x00004000  /* Export Distribution Lists */
#define DAPI_EXPORT_RECIPIENTS       (DAPI_EXPORT_MAILBOX | DAPI_EXPORT_CUSTOM | DAPI_EXPORT_DIST_LIST)
                                                      /* Export all recipient objects */

#define DAPI_EXPORT_ALL_CLASSES           0x00008000  /* If this flag is set, all objects meeting other restrictions
                                                         (i.e., USN level, container scope, etc.) will be exported,
                                                         regardless of class */

#define DAPI_EXPORT_HIDDEN                0x00010000  /* Include Hidden objects in export.
                                                                      Default is no export if Hide-From-Address-Book */
#define DAPI_EXPORT_SUBTREE               0x00020000  /* Traverse the Directory Information Tree hierarchy,
                                                         exporting objects that meet the export restrictions */
#define DAPI_EXPORT_BASEPOINT_ONLY        0x00040000  /* Export only the requested attributes from
                                                         the named BasePoint object.  All other 
                                                         export restrictions are ignored (class flags, 
                                                         rgpszClasses, pszServerName). 
                                                         This flag implies DAPI_SUPPRESS_PROGRESS
                                                         and DAPI_SUPPRESS_COMPLETION */

// Flags defined only for BatchImport
#define DAPI_OVERRIDE_SYNCH_STATE         0x00080000  /* Override server's synchronization status,
                                                         normally checked on BatchImport.
                                                         NOTE:  This flag should normally NOT be set.
                                                                The normal behaviour is to prevent BatchImport
                                                                operations from possible conflict with directory
                                                                synchronization */


// Flags defined only for DAPIRead                                                         
#define  DAPI_READ_DEFINED_ATTRIBUTES     0x00100000  /* return all attributes that are set
                                                         for the current object. 
                                                         This flag is ignored if pAttributes is specified. */

#define  DAPI_READ_ALL_ATTRIBUTES         0x00200000  /* return all attributes that are defined
                                                         for the class of the current object. 
                                                         This flag is ignored if pAttributes is specified. */


 // The following flags control NT Security management
#define DAPI_RESTRICT_ACCESS              0x01000000  /* Apply NT Security Descriptor to 
                                                         created objects */
#define DAPI_CREATE_NT_ACCOUNT            0x02000000  /* Create NT accounts 
                                                         (valid only in Create/Modify mode) */
#define DAPI_CREATE_RANDOM_PASSWORD       0x04000000  /* Generate random passwords for
                                                         created NT accounts.  Ignored if DAPI_CREATE_NT_ACCOUNT
                                                         is not set */
                                                         
#define DAPI_DELETE_NT_ACCOUNT            0x08000000  /* Delete ASSOC-NT-ACCOUNT when
                                                         deleting mailbox */
// Flags defined only for DAPIWrite
#define DAPI_MODIFY_REPLACE_PROPERTIES    0x00800000  /* Append values to multi-value attributes when modifying */

#define  DAPI_WRITE_UPDATE                0x10000000  /* Modify if object exists, create if it doesn't.
                                                         NOTE:  This is the default mode */
#define  DAPI_WRITE_CREATE                0x20000000  /* Create object -- fail if object exists */
#define  DAPI_WRITE_MODIFY                0x30000000  /* Modify object -- fail if object does not exist */
#define  DAPI_WRITE_DELETE                0x40000000  /* Delete object */
#define  DAPI_WRITE_MODE_MASK             0x70000000



// Callback flags
#define  DAPI_CALLBACK_CHAIN              0x00000001  /* If set in dwFlags field of the ERROR_CALLBACK
                                                         and the CALLBACKPROGRESS structures, the default
                                                         handler will be invoked after calling out to the 
                                                         caller-supplied handler function, unless the user
                                                         function returns FALSE, indicating cancel.
                                                         NOTE:  This flag is not defined for the EXPORT_CALLBACK
                                                                structure.
                                                         NOTE:  This flag should not be set in the dwFlags
                                                                field of the main parameter block */


// default delimiter values used when parsing the import file

#define DAPI_DEFAULT_DELIMA   ','
#define DAPI_DEFAULT_QUOTEA   '"'
#define DAPI_DEFAULT_MV_SEPA  '%'
#define DAPI_DEFAULT_DELIMW   L','
#define DAPI_DEFAULT_QUOTEW   L'"'
#define DAPI_DEFAULT_MV_SEPW  L'%'


#define DAPI_CTRL_FILE_PTRA   '='
#define DAPI_CTRL_FILE_PTRW   L'='
#define DAPI_CTRL_META_CHARA  '~'
#define DAPI_CTRL_META_CHARW  L'~'
#define pszSubstServerA       "~SERVER"
#define pszSubstServerW       L"~SERVER"
#define cchSubstServer        ((sizeof (pszSubstServerA) / sizeof(CHAR)) - 1)
#define pszDeleteKeyA         "~DEL"
#define pszDeleteKeyW         L"~DEL"
#define cchDeleteKey          ((sizeof (pszDeleteKeyA) / sizeof(CHAR)) - 1)

#define DAPI_UNICODE_FILE     ((UINT)-1)

#ifdef UNICODE

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMW
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEW
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPW
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRW
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARW
#define pszSubstServer        pszSubstServerW
#define pszDeleteKey          pszDeleteKeyW

#else

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMA
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEA
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPA
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRA
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARA
#define pszSubstServer        pszSubstServerA
#define pszDeleteKey          pszDeleteKeyA

#endif


/*******************************************************************************
* Batch Operation Progress Callback Function Definitions
* Pointers to functions of these types are provided by the caller via the 
* CALLBACKPROGRESS structure in the Batch function parameter block
*               
********************************************************************************
*               
*  procedure :  PDAPI_FInitProgress
*               
*    purpose :  Initialize progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FResetProgress
*               
*    purpose :  Re-initialize progress handler (possibly reset progress bar)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not re-initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FEndProgress
*               
*    purpose :  Terminate progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not terminate progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgress
*               
*    purpose :  Completed processing item.  Called to indicate time to increment
*               progress display.
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgressText
*               
*    purpose :  Replace progress text area with provided text string
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************/
typedef BOOL (PASCAL * PDAPI_FInitProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FEndProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FResetProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgressText)
                          (LPVOID lpvAppDefined, LPTSTR pszText);
            
typedef struct CallBackProgressEntryPoints
{
   DWORD                      dwFlags;
   LPVOID                     lpvAppDefined;
   PDAPI_FInitProgress        pfnInitProgress;
   PDAPI_FUpdateProgress      pfnUpdateProgress;
   PDAPI_FEndProgress         pfnEndProgress;
   PDAPI_FResetProgress       pfnResetProgress;
   PDAPI_FUpdateProgressText  pfnUpdateProgressText;
} CALLBACKPROGRESS, *PCALLBACKPROGRESS;



// Values specified in the ulEvalTag field of the 
//    DAPI_ENTRY and EXPORT_CALLBACK structures
//    
typedef enum _DAPI_EVAL
{
   VALUE_ARRAY = 0,           // Each attribute has an entry in the array
                              //    Text strings and object names exported as text
                              //    Numerical values exported as numbers
                              //    Binary data exported as binary string
   TEXT_VALUE_ARRAY,          // Each attribute has an entry in the array
                              //    All values converted to text representation
   TEXT_LINE                  // first item in the rgEntryValues array
                              //    is a delimited text line
} DAPI_EVAL, *PDAPI_EVAL;

typedef enum _EXP_TYPE_TAG
{
   EXPORT_HEADER = 0,         // export item contains column headers
   EXPORT_ENTRY               // export item contains attribute values
} EXP_TYPE, * PEXP_TYPE;


typedef enum enumDAPI_DATA_TYPE
{
   DAPI_NO_VALUE = 0,
   DAPI_STRING8,
   DAPI_UNICODE,
   DAPI_BINARY,
   DAPI_INT,
   DAPI_BOOL,
} DAPI_DATA_TYPE, * PDAPI_DATA_TYPE;

#ifdef UNICODE
#define DAPI_TEXT DAPI_UNICODE
#else
#define DAPI_TEXT DAPI_STRING8
#endif

typedef union _DAPI_VALUE
{
   LPSTR    pszA;
   LPWSTR   pszW;
#ifdef UNICODE
   LPWSTR   pszValue;
#else
   LPSTR    pszValue;
#endif
   LPBYTE   lpBinary;
   INT      iValue;
   BOOL     bool;
} DAPI_VALUE, * PDAPI_VALUE;



// The ATT_VALUE structure contains a text representation of an attribute value
// A linked list of these structures is used for a multi-valued attribute
typedef struct _ATT_VALUE
{
   DAPI_DATA_TYPE       DapiType;         // How to evaluate DAPI_VALUE union
   DAPI_VALUE           Value;
   UINT                 size;             // size of the value -- 
                                          //    # chars if string type
                                          //    else, # bytes
   struct _ATT_VALUE *  pNextValue;
} ATT_VALUE, * PATT_VALUE;


typedef struct _DAPI_ENTRY
{
   UINT           unAttributes;              // Number of attributes exported
   DAPI_EVAL      ulEvalTag;                 // rgEntryValues is interpreted based on this value
   PATT_VALUE     rgEntryValues;             // if (ulEvalTag == TEXT_LINE)
                                             //    There is a single value, w/ delimited line
                                             // else
                                             //    unAttributes, each w/ 1 or more value in list
} DAPI_ENTRY, * PDAPI_ENTRY;

// Define type for address of application routine 
// for call-back on each exported entry.
// Return value of FALSE indicates that export operation should be cancelled
typedef BOOL (PASCAL DAPI_FNExportEntry) (
               EXP_TYPE    ExportDataType,   // What type of data is being exported
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_ENTRY pExportEntry      // pointer to exported entry data
                                             // NOTE: Data in this structure
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNExportEntry * PDAPI_FNExportEntry;

typedef struct _EXPORT_CALLBACK
{
   DWORD       dwFlags;                      // Flags defined to control callback functionality
                                             // See flag definitions below
   DAPI_EVAL   ulEvalTag;                    // Specifies data format on callback
   LPVOID      lpvAppDefined;                // Application-defined field, passed as parm to callback
   PDAPI_FNExportEntry  pfnExportEntry;      // Pointer to function called to process
                                             // each exported entry

} EXPORT_CALLBACK, * PEXPORT_CALLBACK;



/*******************************************************************************
*  procedure :  pfnErrorCallback
*               
*    purpose :  The following section defines structures for the error callback
*               mechanism of the Batch Import APIs
*               Events will be filtered based on the ControlfFlags set in the 
*               API parameter block
*               
********************************************************************************/

// Define flags used for export callback

// Define the maximum number of substitutions in a single event string
#define DAPI_MAX_SUBST 8


typedef struct _DAPI_EVENTA
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPSTR             rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPSTR             pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPSTR             pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTA * pNextEvent;       // Pointer to next event
} DAPI_EVENTA, *PDAPI_EVENTA;

typedef struct _DAPI_EVENTW
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPWSTR            rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPWSTR            pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPWSTR            pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTW * pNextEvent;       // Pointer to next event
} DAPI_EVENTW, *PDAPI_EVENTW;

#ifdef UNICODE
typedef DAPI_EVENTW  DAPI_EVENT;
typedef PDAPI_EVENTW PDAPI_EVENT;
#else
typedef DAPI_EVENTA  DAPI_EVENT;
typedef PDAPI_EVENTA PDAPI_EVENT;
#endif

// Define type for address of application routine 
// for call-back on each error encountered.
// Return value of FALSE indicates that operation should be cancelled
typedef BOOL (PASCAL DAPI_FNErrorCallback) (
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_EVENT pDapiEvent        // Event information structure
                                             // NOTE: Data in the event record
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNErrorCallback * PDAPI_FNErrorCallback;


typedef struct tagERROR_CALLBACK
{
   DWORD                   dwFlags;          // Flags defined to control callback functionality
                                             // See flag definitions above
   LPVOID                  lpvAppDefined;    // Application-defined field, passed back in callback
   PDAPI_FNErrorCallback   pfnErrorCallback; // Address of function that should be
                                             // called on each error encountered
                                             // If not supplied (NULL), default
                                             // error handler is called, which
                                             // writes the error into the 
                                             // NT Application event log

} ERROR_CALLBACK, * PERROR_CALLBACK;





/*******************************************************************************
*  
*   Batch Directory Import Interface definitions
*               
********************************************************************************/

/*******************************************************************************
*  procedure :  DAPIUninitialize
*               
*    purpose :  Notify DAPI that it is time to terminate background threads
*               and such in preparation for process shutdown
*               
* parameters :  dwFlags		combinable bits which may be set to control function
*               
*    returns :  nothing
*               
*    created :  11/01/95 
*               
*    changes :  
*               
********************************************************************************/
extern void APIENTRY DAPIUninitialize (
                              DWORD    dwFlags // Flags for call
);



/*******************************************************************************
*  procedure :  SchemaPreload
*               
*    purpose :  Called to perform asyncronous schema load.  This entry point
*               spawns a thread that initializes all the attribute and class
*               tables for normal import/export operation.
*               
* parameters :  pSchemaPreloadParms    pointer to SchemaPreloadParameter block
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY SchemaPreloadA (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPSTR    pszDSA   // name of DSA from which to read schema
);

extern void APIENTRY SchemaPreloadW (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPWSTR   pszDSA   // name of DSA from which to read schema
);

#ifdef UNICODE
#define  SchemaPreload  SchemaPreloadW
#else
#define  SchemaPreload  SchemaPreloadA
#endif

typedef struct _BIMPORT_PARMSW
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;                // Windows handle to use when displaying message boxes
   LPWSTR   pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   WCHAR    chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR    chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR    chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR    creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPWSTR   pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPWSTR   pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSW, *PBIMPORT_PARMSW, *LPBIMPORT_PARMSW;

typedef struct _BIMPORT_PARMSA
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
  